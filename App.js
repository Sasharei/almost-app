import React, { useCallback, useEffect, useMemo, useRef, useState, forwardRef, useImperativeHandle } from "react";
import {
  View,
  Text as RNText,
  FlatList,
  Image,
  TouchableOpacity,
  Modal,
  StyleSheet,
  SafeAreaView,
  ScrollView,
  TextInput as RNTextInput,
  Alert,
  Keyboard,
  TouchableWithoutFeedback,
  Platform,
  Dimensions,
  Animated,
  Easing,
  Linking,
  NativeModules,
  PanResponder,
  LayoutAnimation,
  UIManager,
  StatusBar as RNStatusBar,
  AppState,
  Share,
  ActionSheetIOS,
  PixelRatio,
  InteractionManager,
  ActivityIndicator,
  Pressable,
} from "react-native";
import Svg, {
  Circle as SvgCircle,
  Defs,
  Mask,
  Rect as SvgRect,
  LinearGradient as SvgLinearGradient,
  Stop as SvgStop,
  Path as SvgPath,
} from "react-native-svg";
import AsyncStorage from "@react-native-async-storage/async-storage";
import ConfettiCannon from "react-native-confetti-cannon";
import * as Haptics from "expo-haptics";
import * as ImagePicker from "expo-image-picker";
import * as Notifications from "expo-notifications";
import * as NavigationBar from "expo-navigation-bar";
import * as FileSystem from "expo-file-system";
import { StatusBar } from "expo-status-bar";
import { BlurView as ExpoBlurView } from "expo-blur";
import * as SplashScreen from "expo-splash-screen";
let AudioModule = null;
try {
  // Optional native module - may be missing in some builds (e.g. older Expo Go).
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  AudioModule = require("expo-av")?.Audio || null;
} catch (error) {
  console.warn("expo-av unavailable", error);
}
import {
  useFonts,
  Inter_300Light,
  Inter_400Regular,
  Inter_500Medium,
  Inter_600SemiBold,
  Inter_700Bold,
  Inter_800ExtraBold,
  Inter_900Black,
} from "@expo-google-fonts/inter";
import Sentry, { initSentry } from "./sentry";
import { SafeAreaProvider, useSafeAreaInsets } from "react-native-safe-area-context";
import ViewShot, { captureRef as captureViewShotRef } from "react-native-view-shot";
import {
  initAnalytics,
  initPerformanceMonitoring,
  logEvent,
  logScreenView,
  registerLevelEvents,
  setAnalyticsOptOut as setAnalyticsOptOutFlag,
  setFacebookSdkReady,
  setUserProperties,
} from "./analytics";
import { SavingsProvider, useRealSavedAmount } from "./src/hooks/useRealSavedAmount";
import { useSavingsSimulation } from "./src/hooks/useSavingsSimulation";
import { calcPotentialSaved } from "./src/utils/savingsSimulation";
import { TRANSLATIONS } from "./src/constants/translations";
import { DAILY_CHALLENGE_POPULAR_IDS, DEFAULT_TEMPTATIONS } from "./src/constants/temptations";
import { PRIVACY_LINKS, TERMS_LINKS, TERMS_POINTS } from "./src/constants/legal";
import PremiumPaywallModal from "./src/components/PremiumPaywallModal";
import {
  buildDefaultPlanCards,
  buildPaywallCopy,
  FREE_PLAN_LIMITS,
  PREMIUM_FEATURE_KEYS,
  PREMIUM_PLAN_ORDER,
  resolveFallbackPlanPricing,
} from "./src/monetization/constants";
import {
  addCustomerInfoUpdateListener,
  configurePurchases,
  getActivePremiumEntitlement,
  getCustomerInfoSafe,
  getOfferingsSafe,
  isPremiumFromCustomerInfo,
  isPurchasesAvailable,
  mapOfferingPackagesByPlan,
  purchasePlanPackage,
  restorePurchasesSafe,
  setPurchasesAttributesSafe,
} from "./src/monetization/purchasesClient";
import { syncEntitlementSnapshot, validateStorePurchase } from "./src/monetization/backendSync";

const safeUseFonts =
  typeof useFonts === "function"
    ? useFonts
    : () => {
        if (__DEV__) {
          console.warn("useFonts is unavailable; continuing without custom fonts.");
        }
        return [true, new Error("useFonts is unavailable")];
      };
const safeUseSafeAreaInsets =
  typeof useSafeAreaInsets === "function"
    ? useSafeAreaInsets
    : () => {
        if (__DEV__) {
          console.warn("useSafeAreaInsets is unavailable; using zero insets.");
        }
        return { top: 0, bottom: 0, left: 0, right: 0 };
      };

let StoreReview = null;
try {
  // Optional native module - older builds might not include it.
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  StoreReview = require("expo-store-review");
} catch (error) {
  console.warn("StoreReview unavailable", error);
}
let Sharing = null;
try {
  // Optional: module might be missing on some builds (e.g. Expo Go).
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  Sharing = require("expo-sharing");
} catch (error) {
  console.warn("Sharing unavailable", error);
}
let FacebookSettings = null;
try {
  // Optional: module might be missing on some builds (e.g. Expo Go).
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  FacebookSettings = require("react-native-fbsdk-next")?.Settings || null;
} catch (error) {
  console.warn("Facebook SDK unavailable", error);
}
let TrackingTransparency = null;
try {
  // Optional: module might be missing in older builds or Expo Go.
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  TrackingTransparency = require("expo-tracking-transparency") || null;
} catch (error) {
  console.warn("Tracking transparency unavailable", error);
}
let Accelerometer = null;
try {
  // Optional: module might be missing in some builds (e.g. Expo Go).
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  Accelerometer = require("expo-sensors")?.Accelerometer || null;
} catch (error) {
  console.warn("expo-sensors unavailable", error);
}
let Gyroscope = null;
try {
  // Optional: module might be missing in some builds (e.g. Expo Go).
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  Gyroscope = require("expo-sensors")?.Gyroscope || null;
} catch (error) {
  console.warn("expo-sensors gyro unavailable", error);
}
let DeviceMotion = null;
try {
  // Optional: module might be missing in some builds (e.g. Expo Go).
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  DeviceMotion = require("expo-sensors")?.DeviceMotion || null;
} catch (error) {
  console.warn("expo-sensors device motion unavailable", error);
}

const safeNotifications = (() => {
  const api = Notifications || {};
  const isFn = (value) => typeof value === "function";
  const safeCall = (label, fn, ...args) => {
    if (!isFn(fn)) return null;
    try {
      return fn(...args);
    } catch (error) {
      console.warn(label, error);
      return null;
    }
  };
  const safeAsync = async (label, fn, ...args) => {
    if (!isFn(fn)) return null;
    try {
      return await fn(...args);
    } catch (error) {
      console.warn(label, error);
      return null;
    }
  };
  const swallow = (value) => {
    if (value && typeof value.catch === "function") {
      value.catch(() => {});
    }
  };
  return {
    setNotificationHandler: (handler) =>
      safeCall("notification handler", api.setNotificationHandler, handler),
    getPermissionsAsync: async () => safeAsync("notifications permissions", api.getPermissionsAsync),
    requestPermissionsAsync: async () =>
      safeAsync("notifications permissions", api.requestPermissionsAsync),
    getAllScheduledNotificationsAsync: async () => {
      const result = await safeAsync(
        "notifications scheduled list",
        api.getAllScheduledNotificationsAsync
      );
      return Array.isArray(result) ? result : [];
    },
    scheduleNotificationAsync: async (payload) =>
      safeAsync("notifications schedule", api.scheduleNotificationAsync, payload),
    cancelScheduledNotificationAsync: async (id) =>
      safeAsync("notifications cancel", api.cancelScheduledNotificationAsync, id),
    cancelAllScheduledNotificationsAsync: async () =>
      safeAsync("notifications cancel all", api.cancelAllScheduledNotificationsAsync),
    setNotificationChannelAsync: (id, config) =>
      swallow(safeCall("notifications channel", api.setNotificationChannelAsync, id, config)),
    setNotificationCategoryAsync: (id, actions) =>
      swallow(safeCall("notifications category", api.setNotificationCategoryAsync, id, actions)),
    setBadgeCountAsync: (count) =>
      swallow(safeCall("notifications badge", api.setBadgeCountAsync, count)),
    getLastNotificationResponseAsync: async () =>
      safeAsync("notifications last response", api.getLastNotificationResponseAsync),
    addNotificationResponseReceivedListener: (handler) =>
      safeCall("notifications response listener", api.addNotificationResponseReceivedListener, handler),
    addNotificationReceivedListener: (handler) =>
      safeCall("notifications listener", api.addNotificationReceivedListener, handler),
  };
})();

safeNotifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowAlert: true,
    shouldPlaySound: false,
    shouldSetBadge: false,
  }),
});

const DEFAULT_NOTIFICATION_ACTION_IDENTIFIER =
  Notifications?.DEFAULT_ACTION_IDENTIFIER ?? "default";

let AndroidBlurView = null;
try {
  AndroidBlurView = require("@react-native-community/blur")?.BlurView || null;
} catch (error) {
  AndroidBlurView = null;
}
const getWidgetStorage = () => NativeModules?.WidgetStorage ?? null;
const canUpdateWidgetStorage = () => {
  const storage = getWidgetStorage();
  return !!storage && typeof storage.setWidgetData === "function";
};
const setWidgetDataSafely = (payload) => {
  const storage = getWidgetStorage();
  if (!storage || typeof storage.setWidgetData !== "function") return false;
  storage.setWidgetData(payload).catch(() => {});
  return true;
};
const hasInstalledHomeWidget = async () => {
  if (Platform.OS !== "ios" && Platform.OS !== "android") return false;
  const storage = getWidgetStorage();
  if (!storage || typeof storage.hasInstalledHomeWidget !== "function") return false;
  try {
    const value = await storage.hasInstalledHomeWidget();
    if (typeof value === "boolean") return value;
    if (typeof value === "number") return value === 1;
    if (typeof value === "string") {
      const normalized = value.trim().toLowerCase();
      return normalized === "1" || normalized === "true";
    }
  } catch (error) {
    console.warn("widget install check", error);
  }
  return false;
};

// Android BlurView (Dimezis) can crash during layout animations on newer OS versions.
// Keep blur enabled, but avoid aggressive auto-updates to reduce crashes.
const ANDROID_DIMEZIS_DISABLED = false;
const ANDROID_BLUR_AUTO_UPDATE = false;

const BLUR_VIEW_MANAGER_NAMES = ["ViewManagerAdapter_ExpoBlurView", "ExpoBlurView"];
const isExpoBlurViewAvailable = () => {
  if (!UIManager) return false;
  if (typeof UIManager.getViewManagerConfig === "function") {
    return BLUR_VIEW_MANAGER_NAMES.some((name) => !!UIManager.getViewManagerConfig(name));
  }
  return BLUR_VIEW_MANAGER_NAMES.some((name) => !!UIManager[name]);
};
const isBlurViewAvailable = () => {
  if (Platform.OS === "android") {
    return (!!AndroidBlurView && !ANDROID_DIMEZIS_DISABLED) || isExpoBlurViewAvailable();
  }
  return isExpoBlurViewAvailable();
};

const runLayoutAnimation = (preset = LayoutAnimation.Presets.easeInEaseOut) => {
  if (!LayoutAnimation || typeof LayoutAnimation.configureNext !== "function") return;
  // Skip layout animations on Android when Dimezis blur is enabled to avoid pre-ordered draw crashes.
  if (Platform.OS === "android" && !ANDROID_DIMEZIS_DISABLED) return;
  LayoutAnimation.configureNext(preset);
};

const IOS_TRACKING_BLOCKED_STATUSES = new Set(["denied", "restricted"]);
const isTrackingStatusBlocked = (status) => {
  if (!status || typeof status !== "string") return false;
  return IOS_TRACKING_BLOCKED_STATUSES.has(status.trim().toLowerCase());
};

const bootstrapMonitoring = (() => {
  let initialized = false;
  return (enabled = false) => {
    if (!enabled || initialized) return;
    initialized = true;
    InteractionManager.runAfterInteractions(() => {
      initSentry();
      initAnalytics();
      initPerformanceMonitoring();
    });
  };
})();
// Keep native splash visible until our custom LogoSplash is ready.
SplashScreen.preventAutoHideAsync().catch(() => {});

const STORAGE_KEYS = {
  PURCHASES: "@almost_purchases",
  PROFILE: "@almost_profile",
  THEME: "@almost_theme",
  PRO_THEME_ACCENT: "@almost_pro_theme_accent",
  LANGUAGE: "@almost_language",
  ONBOARDING: "@almost_onboarded",
  TERMS_ACCEPTED: "@almost_terms_accepted",
  CATALOG: "@almost_catalog_overrides",
  PRICE_PRECISION_OVERRIDES: "@almost_price_precision_overrides",
  TITLE_OVERRIDES: "@almost_title_overrides",
  EMOJI_OVERRIDES: "@almost_emoji_overrides",
  WISHES: "@almost_wishes",
  SAVED_TOTAL: "@almost_saved_total",
  SAVED_TOTAL_PROGRESS: "@almost_saved_total_progress",
  LEVEL_PROGRESS_OFFSET: "@almost_level_progress_offset",
  DECLINES: "@almost_declines",
  PENDING: "@almost_pending",
  FREE_DAY: "@almost_free_day_stats",
  USAGE_STREAK: "@almost_usage_streak",
  STREAK_PLEDGE: "@almost_streak_pledge",
  DECISION_STATS: "@almost_decision_stats",
  HISTORY: "@almost_history",
  REFUSE_STATS: "@almost_refuse_stats",
  REWARDS_CELEBRATED: "@almost_rewards_celebrated",
  HEALTH: "@almost_health_points",
  CLAIMED_REWARDS: "@almost_claimed_rewards",
  REWARD_TOTAL: "@almost_reward_total",
  ANALYTICS_OPT_OUT: "@almost_analytics_opt_out",
  TEMPTATION_GOALS: "@almost_temptation_goals",
  TEMPTATION_INTERACTIONS: "@almost_temptation_interactions",
  CUSTOM_TEMPTATIONS: "@almost_custom_temptations",
  HIDDEN_TEMPTATIONS: "@almost_hidden_temptations",
  ARCHIVED_TEMPTATIONS: "@almost_archived_temptations",
  IMPULSE_TRACKER: "@almost_impulse_tracker",
  MOOD_STATE: "@almost_mood_state",
  CHALLENGES: "@almost_challenges",
  CHALLENGE_BADGES: "@almost_challenge_badges",
  CUSTOM_REMINDER: "@almost_custom_reminder",
  SMART_REMINDERS: "@almost_smart_reminders",
  DAILY_NUDGES: "@almost_daily_nudges",
  DAILY_NUDGE_SCHEDULE_SIGNATURE: "@almost_daily_nudge_schedule_signature",
  LANGUAGE_CURRENCY_NUDGE: "@almost_language_currency_nudge",
  TAMAGOTCHI: "@almost_tamagotchi_state",
  TAMAGOTCHI_GREETING_DAY: "@almost_tamagotchi_greeting_day",
  DAILY_SUMMARY: "@almost_daily_summary",
  POTENTIAL_PUSH_PROGRESS: "@almost_potential_push_progress",
  PUSH_NOTIFICATIONS_ENABLED_LOGGED: "@almost_push_notifications_enabled_logged",
  HOME_WIDGET_INSTALLED_LOGGED: "@almost_home_widget_installed_logged",
  PUSH_DAY_THREE_PROMPT: "@almost_push_day_three_prompt",
  SPEND_LOGGING_REMINDER: "@almost_spend_logging_reminder",
  TUTORIAL: "@almost_tutorial_state",
  BUDGET_WIDGET_TUTORIAL: "@almost_budget_widget_tutorial",
  HERO_CAROUSEL_WIGGLE_SWIPE_AT: "@almost_hero_carousel_wiggle_swipe_at",
  HERO_CAROUSEL_WIGGLE_SEEN: "@almost_hero_carousel_wiggle_seen",
  TEMPTATION_TUTORIAL: "@almost_temptation_cards_tutorial",
  COIN_VALUE_MODAL: "@almost_coin_value_modal",
  DAILY_CHALLENGE: "@almost_daily_challenge_state",
  DAILY_CHALLENGE_COMPLETED_TOTAL: "@almost_daily_challenge_completed_total",
  DAILY_REWARD: "@almost_daily_reward",
  DAILY_REWARD_DAY_KEY: "@almost_daily_reward_day",
  FOCUS_TARGET: "@almost_focus_target",
  FOCUS_DIGEST: "@almost_focus_digest",
  FOCUS_VICTORY_TOTAL: "@almost_focus_victory_total",
  CATEGORY_OVERRIDES: "@almost_category_overrides",
  CUSTOM_CATEGORIES: "@almost_custom_categories",
  REMOVED_CATEGORIES: "@almost_removed_categories",
  SAVINGS_CATEGORY_OVERRIDE: "@almost_savings_category_override",
  CATEGORY_DEF_OVERRIDES: "@almost_category_def_overrides",
  DESCRIPTION_OVERRIDES: "@almost_description_overrides",
  FOCUS_DIGEST_PENDING: "@almost_focus_digest_pending",
  CUSTOM_TEMPTATIONS_CREATED: "@almost_custom_temptations_created",
  TAMAGOTCHI_SKIN: "@almost_tamagotchi_skin",
  TAMAGOTCHI_SKINS_UNLOCKED: "@almost_tamagotchi_skins_unlocked",
  TAMAGOTCHI_HUNGER_NOTIFICATIONS: "@almost_tamagotchi_hunger_notifications",
  TAMAGOTCHI_HUNGER_DAILY_COUNT: "@almost_tamagotchi_hunger_daily_count",
  TAMAGOTCHI_HUNGER_LAST_AT: "@almost_tamagotchi_hunger_last_at",
  SAVED_TOTAL_PEAK: "@almost_saved_total_peak",
  SAVED_TOTAL_PROGRESS_PEAK: "@almost_saved_total_progress_peak",
  LAST_CELEBRATED_LEVEL: "@almost_last_celebrated_level",
  LEVEL_REACHED_LOGGED: "@almost_level_reached_logged",
  ACTIVE_GOAL: "@almost_active_goal",
  POTENTIAL_OPEN_SNAPSHOT: "@almost_potential_open_snapshot",
  COIN_SLIDER_MAX: "@almost_coin_slider_max",
  FAB_TUTORIAL: "@almost_fab_tutorial",
  RATING_PROMPT: "@almost_rating_prompt",
  NORTH_STAR_METRIC: "@almost_north_star_metric",
  DAY_TWO_ACTIVITY: "@almost_day_two_activity",
  DAY_THREE_ACTIVITY: "@almost_day_three_activity",
  RETENTION_ACTIVE_DAYS: "@almost_retention_active_days",
  RETENTION_MILESTONES: "@almost_retention_milestones",
  PRIMARY_TEMPTATION_PROMPT: "@almost_primary_temptation_prompt",
  LAST_NOTIFICATION_AT: "@almost_last_notification_at",
  SOUND_ENABLED: "@almost_sound_enabled",
  REPORTS_BADGE: "@almost_reports_badge",
  REPORTS_LAST_AUTO_WEEK: "@almost_reports_last_auto_week",
  REPORTS_WEEKLY_NOTIFICATION: "@almost_reports_weekly_notification",
  INCOME_ENTRIES: "@almost_income_entries",
  BUDGET_LIMITS: "@almost_budget_limits",
  INCOME_PROMPT: "@almost_income_prompt",
  BUDGET_OVERSPEND: "@almost_budget_overspend",
  DAILY_GOAL_COLLECTED: "@almost_daily_goal_collected",
  PREMIUM_INSTALL_ID: "@almost_premium_install_id",
  PREMIUM_SOFT_PAYWALL_SHOWN: "@almost_premium_soft_paywall_shown",
  PREMIUM_HARD_PAYWALL_SHOWN: "@almost_premium_hard_paywall_shown",
  PREMIUM_CHALLENGE_CLAIMS: "@almost_premium_challenge_claims",
};

const COIN_VALUE_MODAL_STATUS = {
  PENDING: "pending",
  SHOWN: "shown",
};

const CELEBRATION_OVERLAY_GAP_MS = 15000;
const APP_RESUME_MODAL_GUARD_MS = 1500;

const DEFAULT_LANGUAGE = "en";
const FALLBACK_LANGUAGE = "en";
const SUPPORTED_LANGUAGES = ["en", "es", "fr", "ru"];
const SOUND_FILES = {
  coin: require("./assets/sounds/coin.wav"),
  tap: require("./assets/sounds/tap.wav"),
  counter: require("./assets/sounds/counter.wav"),
  cat: require("./assets/sounds/cat.wav"),
  challenge_accept: require("./assets/sounds/challenge_accept.wav"),
  focus_accept: require("./assets/sounds/focus_accept.wav"),
  reward: require("./assets/sounds/reward.wav"),
  thunder: require("./assets/sounds/thunder.wav"),
  daily_reward: require("./assets/sounds/daily_reward.wav"),
  level_up: require("./assets/sounds/level_up.wav"),
  party_beat: require("./assets/sounds/counter.wav"),
  party_clap: require("./assets/sounds/tap.wav"),
  party_cheer: require("./assets/sounds/reward.wav"),
};
const PRELOAD_SOUND_KEYS = new Set(["coin", "tap", "counter", "level_up"]);
const SOUND_COOLDOWNS = {
  coin: 200,
  tap: 120,
  counter: 60,
  cat: 600,
  challenge_accept: 500,
  focus_accept: 500,
  reward: 600,
  thunder: 900,
  daily_reward: 900,
  level_up: 1200,
  party_beat: 60,
  party_clap: 80,
  party_cheer: 600,
};
const SOUND_VOLUMES = {
  coin: 0.85,
  tap: 0.75,
  counter: 1.0,
  cat: 0.8,
  challenge_accept: 0.85,
  focus_accept: 0.85,
  reward: 0.9,
  thunder: 0.85,
  daily_reward: 0.9,
  level_up: 0.9,
  party_beat: 0.95,
  party_clap: 0.8,
  party_cheer: 0.85,
};
const LANGUAGE_LABEL_KEYS = {
  ru: "languageRussian",
  en: "languageEnglish",
  es: "languageSpanish",
  fr: "languageFrench",
};
const LANGUAGE_NATIVE_LABELS = {
  ru: "Ð ÑƒÑÑÐºÐ¸Ð¹",
  en: "English",
  es: "EspaÃ±ol",
  fr: "FranÃ§ais",
};
const normalizeLanguage = (value) =>
  SUPPORTED_LANGUAGES.includes(value) ? value : DEFAULT_LANGUAGE;
const getLanguageLabelKey = (language) =>
  LANGUAGE_LABEL_KEYS[language] || LANGUAGE_LABEL_KEYS[FALLBACK_LANGUAGE];
const FORMAT_LOCALES = {
  ru: "ru-RU",
  en: "en-US",
  es: "es-ES",
  fr: "fr-FR",
};
const SHORT_LANGUAGE_MAP = {
  ru: "ru",
  en: "en",
  es: "es",
  fr: "fr",
};
const getFormatLocale = (language) =>
  FORMAT_LOCALES[language] || FORMAT_LOCALES[FALLBACK_LANGUAGE];
const getShortLanguageKey = (language) =>
  SHORT_LANGUAGE_MAP[language] || SHORT_LANGUAGE_MAP[FALLBACK_LANGUAGE];

const PURCHASE_GOAL = 20000;
const FALLBACK_SAVE_ACTION_USD = 20;
const FINANCIAL_QUOTES = [
  {
    id: "franklin",
    en: "â€œA penny saved is a penny earned.â€ Benjamin Franklin",
    ru: "Â«Ð¡Ð±ÐµÑ€ÐµÐ¶Ñ‘Ð½Ð½Ñ‹Ð¹ Ñ€ÑƒÐ±Ð»ÑŒ Ñ€Ð°Ð²ÐµÐ½ Ð·Ð°Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð½Ð¾Ð¼Ñƒ.Â» Ð‘ÐµÐ½Ð´Ð¶Ð°Ð¼Ð¸Ð½ Ð¤Ñ€Ð°Ð½ÐºÐ»Ð¸Ð½",
    es: "â€œUn centavo ahorrado es un centavo ganado.â€ Benjamin Franklin",
    fr: "Â«Un sou Ã©conomisÃ© est un sou gagnÃ©.Â» Benjamin Franklin",
  },
  {
    id: "seneca",
    en: "â€œWealth is the slave of a wise man and the master of a fool.â€ Seneca",
    ru: "Â«Ð‘Ð¾Ð³Ð°Ñ‚ÑÑ‚Ð²Ð¾ ÑÐ»ÑƒÐ¶Ð¸Ñ‚ Ð¼ÑƒÐ´Ñ€Ð¾Ð¼Ñƒ Ð¸ Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ Ð³Ð»ÑƒÐ¿Ñ†Ð¾Ð¼.Â» Ð¡ÐµÐ½ÐµÐºÐ°",
    es: "â€œLa riqueza es la esclava del sabio y la dueÃ±a del necio.â€ SÃ©neca",
    fr: "Â«La richesse est l'esclave du sage et la maÃ®tresse du fou.Â» SÃ©nÃ¨que",
  },
  {
    id: "buffett",
    en: "â€œDo not save what is left after spending; spend what is left after saving.â€ Warren Buffett",
    ru: "Â«ÐÐµ Ð¾Ñ‚ÐºÐ»Ð°Ð´Ñ‹Ð²Ð°Ð¹ Ñ‚Ð¾, Ñ‡Ñ‚Ð¾ Ð¾ÑÑ‚Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾ÑÐ»Ðµ Ñ€Ð°ÑÑ…Ð¾Ð´Ð¾Ð², Ñ‚Ñ€Ð°Ñ‚ÑŒ Ñ‚Ð¾, Ñ‡Ñ‚Ð¾ Ð¾ÑÑ‚Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾ÑÐ»Ðµ ÑÐ±ÐµÑ€ÐµÐ¶ÐµÐ½Ð¸Ð¹.Â» Ð£Ð¾Ñ€Ñ€ÐµÐ½ Ð‘Ð°Ñ„Ñ„ÐµÑ‚",
    es: "â€œNo ahorres lo que quede despuÃ©s de gastar; gasta lo que quede despuÃ©s de ahorrar.â€ Warren Buffett",
    fr: "Â«N'Ã©pargne pas ce qui reste aprÃ¨s avoir dÃ©pensÃ©, dÃ©pense ce qui reste aprÃ¨s avoir Ã©pargnÃ©.Â» Warren Buffett",
  },
  {
    id: "ramsey",
    en: "â€œYou must gain control over your money or the lack of it will forever control you.â€ Dave Ramsey",
    ru: "Â«Ð›Ð¸Ð±Ð¾ Ñ‚Ñ‹ ÑƒÐ¿Ñ€Ð°Ð²Ð»ÑÐµÑˆÑŒ Ð´ÐµÐ½ÑŒÐ³Ð°Ð¼Ð¸, Ð»Ð¸Ð±Ð¾ Ð¸Ñ… Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²Ð¸Ðµ Ð±ÑƒÐ´ÐµÑ‚ ÑƒÐ¿Ñ€Ð°Ð²Ð»ÑÑ‚ÑŒ Ñ‚Ð¾Ð±Ð¾Ð¹ Ð²ÑÐµÐ³Ð´Ð°.Â» Ð”ÐµÐ¹Ð² Ð ÑÐ¼ÑÐ¸",
    es: "â€œDebes controlar tu dinero o la falta de Ã©l te controlarÃ¡ para siempre.â€ Dave Ramsey",
    fr: "Â«Prends le contrÃ´le de ton argent sinon son absence te contrÃ´lera pour toujours.Â» Dave Ramsey",
  },
  {
    id: "orman",
    en: "â€œA big part of financial freedom is having your heart and mind free from worry about the what-ifs of life.â€ Suze Orman",
    ru: "Â«Ð¤Ð¸Ð½Ð°Ð½ÑÐ¾Ð²Ð°Ñ ÑÐ²Ð¾Ð±Ð¾Ð´Ð° Ð½Ð°Ñ‡Ð¸Ð½Ð°ÐµÑ‚ÑÑ, ÐºÐ¾Ð³Ð´Ð° ÑÐµÑ€Ð´Ñ†Ðµ Ð¸ Ñ€Ð°Ð·ÑƒÐ¼ ÑÐ²Ð¾Ð±Ð¾Ð´Ð½Ñ‹ Ð¾Ñ‚ Ñ‚Ñ€ÐµÐ²Ð¾Ð³Ð¸ Ð¾ Ñ‚Ð¾Ð¼, Ñ‡Ñ‚Ð¾ Ð±ÑƒÐ´ÐµÑ‚, ÐµÑÐ»Ð¸.Â» Ð¡ÑŒÑŽÐ· ÐžÑ€Ð¼Ð°Ð½",
    es: "â€œGran parte de la libertad financiera es tener la mente y el corazÃ³n libres de preocuparse por los Â«quÃ© pasarÃ­a siÂ».â€ Suze Orman",
    fr: "Â«Une grande part de la libertÃ© financiÃ¨re consiste Ã  avoir l'esprit et le cÅ“ur libÃ©rÃ©s des inquiÃ©tudes du et si.Â» Suze Orman",
  },
  {
    id: "lynch",
    en: "â€œKnow what you own, and know why you own it.â€ Peter Lynch",
    ru: "Â«Ð—Ð½Ð°Ð¹, Ñ‡ÐµÐ¼ Ð²Ð»Ð°Ð´ÐµÐµÑˆÑŒ, Ð¸ Ð¿Ð¾Ð½Ð¸Ð¼Ð°Ð¹, Ð·Ð°Ñ‡ÐµÐ¼ ÑÑ‚Ð¾ Ñ‚ÐµÐ±Ðµ.Â» ÐŸÐ¸Ñ‚ÐµÑ€ Ð›Ð¸Ð½Ñ‡",
    es: "â€œSabe quÃ© posees y por quÃ© lo posees.â€ Peter Lynch",
    fr: "Â«Sache ce que tu possÃ¨des et pourquoi tu le possÃ¨des.Â» Peter Lynch",
  },
  {
    id: "jefferson",
    en: "â€œNever spend your money before you have it.â€ Thomas Jefferson",
    ru: "Â«ÐÐ¸ÐºÐ¾Ð³Ð´Ð° Ð½Ðµ Ñ‚Ñ€Ð°Ñ‚ÑŒ Ð´ÐµÐ½ÑŒÐ³Ð¸ Ñ€Ð°Ð½ÑŒÑˆÐµ, Ñ‡ÐµÐ¼ Ð¾Ð½Ð¸ Ñƒ Ñ‚ÐµÐ±Ñ ÐµÑÑ‚ÑŒ.Â» Ð¢Ð¾Ð¼Ð°Ñ Ð”Ð¶ÐµÑ„Ñ„ÐµÑ€ÑÐ¾Ð½",
    es: "â€œNunca gastes tu dinero antes de tenerlo.â€ Thomas Jefferson",
    fr: "Â«Ne dÃ©pense jamais ton argent avant de l'avoir.Â» Thomas Jefferson",
  },
  {
    id: "thatcher",
    en: "â€œPennies do not come from heaven. They have to be earned here on earth.â€ Margaret Thatcher",
    ru: "Â«ÐœÐ¾Ð½ÐµÑ‚Ñ‹ Ð½Ðµ Ð¿Ð°Ð´Ð°ÑŽÑ‚ Ñ Ð½ÐµÐ±ÐµÑ, Ð¸Ñ… Ð½ÑƒÐ¶Ð½Ð¾ Ð·Ð°Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ñ‚ÑŒ Ð½Ð° Ð·ÐµÐ¼Ð»Ðµ.Â» ÐœÐ°Ñ€Ð³Ð°Ñ€ÐµÑ‚ Ð¢ÑÑ‚Ñ‡ÐµÑ€",
    es: "â€œLos centavos no caen del cielo, hay que ganarlos aquÃ­ en la tierra.â€ Margaret Thatcher",
    fr: "Â«Les piÃ¨ces ne tombent pas du ciel, il faut les gagner ici-bas.Â» Margaret Thatcher",
  },
  {
    id: "kiyosaki",
    en: "â€œIt's not how much money you make, but how much money you keep, how hard it works for you, and how many generations you keep it for.â€ Robert Kiyosaki",
    ru: "Â«Ð’Ð°Ð¶Ð½Ñ‹ Ð½Ðµ ÑÑ‚Ð¾Ð»ÑŒÐºÐ¾ Ð·Ð°Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð½Ñ‹Ðµ Ð´ÐµÐ½ÑŒÐ³Ð¸, ÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ñ‚Ð¾, ÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ñ‚Ñ‹ ÑÐ¾Ñ…Ñ€Ð°Ð½ÑÐµÑˆÑŒ, ÐºÐ°Ðº Ð¾Ð½Ð¸ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÑŽÑ‚ Ð½Ð° Ñ‚ÐµÐ±Ñ Ð¸ Ð½Ð° ÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ð¿Ð¾ÐºÐ¾Ð»ÐµÐ½Ð¸Ð¹ Ð¸Ñ… Ñ…Ð²Ð°Ñ‚Ð¸Ñ‚.Â» Ð Ð¾Ð±ÐµÑ€Ñ‚ ÐšÐ¸Ð¾ÑÐ°ÐºÐ¸",
    es: "â€œNo importa cuÃ¡nto dinero ganes, sino cuÃ¡nto conservas, quÃ© tan duro trabaja para ti y por cuÃ¡ntas generaciones lo mantienes.â€ Robert Kiyosaki",
    fr: "Â«Ce n'est pas ce que tu gagnes qui compte mais ce que tu conserves, la faÃ§on dont cet argent travaille pour toi et le nombre de gÃ©nÃ©rations qui en profitent.Â» Robert Kiyosaki",
  },
];
const MAX_ACTIVE_CHALLENGES = 3;
const MAX_ACTIVE_GOALS = 5;
const FREE_GOAL_LIMIT = FREE_PLAN_LIMITS.activeGoals;
const FREE_PENDING_LIMIT = FREE_PLAN_LIMITS.activePendingCards || 2;
const FREE_HISTORY_WINDOW_MS = FREE_PLAN_LIMITS.historyDays * 1000 * 60 * 60 * 24;
const FREE_CUSTOM_TEMPTATION_LIMIT = FREE_PLAN_LIMITS.customTemptationCards;
const FREE_CHALLENGE_CLAIMS_LIMIT = FREE_PLAN_LIMITS.challengeClaims;
const FREE_REPORTS_WEEK_COUNT = FREE_PLAN_LIMITS.reportsWeeks;
const FREE_REPORTS_MONTH_COUNT = FREE_PLAN_LIMITS.reportsMonths;
const FREE_BUDGET_AUTO_DAYS = FREE_PLAN_LIMITS.budgetAutoFreeDays || 30;
const HARD_PAYWALL_DELAY_MS = 700;
const PREMIUM_PAYWALL_REOPEN_GUARD_MS = 1200;
const ANDROID_API_LEVEL =
  Platform.OS === "android"
    ? typeof Platform.Version === "string"
      ? parseInt(Platform.Version, 10) || 0
      : Number(Platform.Version) || 0
    : 0;
const SHOULD_USE_ANDROID_LEGACY_MEDIA_PICKER =
  Platform.OS === "android" && ANDROID_API_LEVEL > 0 && ANDROID_API_LEVEL < 33;
const CLASSIC_TAMAGOTCHI_ANIMATIONS = {
  idle: require("./assets/Cat_idle.gif"),
  curious: require("./assets/Cat_curious.gif"),
  follow: require("./assets/Cat_follows.gif"),
  speak: require("./assets/Cat_speaks.gif"),
  happy: require("./assets/Cat_happy.gif"),
  happyHeadshake: require("./assets/Cat_happy_headshake.gif"),
  sad: require("./assets/Cat_sad.gif"),
  ohno: require("./assets/Cat_oh_oh.gif"),
  cry: require("./assets/Cat_cry.gif"),
  waving: require("./assets/Cat_waving.gif"),
};
const GREEN_TAMAGOTCHI_ANIMATIONS = {
  idle: require("./assets/tamagotchi_skins/green/Cat_idle.gif"),
  curious: require("./assets/tamagotchi_skins/green/Cat_curious.gif"),
  follow: require("./assets/tamagotchi_skins/green/Cat_follows.gif"),
  speak: require("./assets/tamagotchi_skins/green/Cat_speaks.gif"),
  happy: require("./assets/tamagotchi_skins/green/Cat_happy.gif"),
  happyHeadshake: require("./assets/tamagotchi_skins/green/Cat_happy_headshake.gif"),
  sad: require("./assets/tamagotchi_skins/green/Cat_sad.gif"),
  ohno: require("./assets/tamagotchi_skins/green/Cat_oh_oh.gif"),
  cry: require("./assets/tamagotchi_skins/green/Cat_cry.gif"),
  waving: require("./assets/tamagotchi_skins/green/Cat_waving.gif"),
};
const TEAL_TAMAGOTCHI_ANIMATIONS = {
  idle: require("./assets/tamagotchi_skins/teal/Cat_idle.gif"),
  curious: require("./assets/tamagotchi_skins/teal/Cat_curious.gif"),
  follow: require("./assets/tamagotchi_skins/teal/Cat_follows.gif"),
  speak: require("./assets/tamagotchi_skins/teal/Cat_speaks.gif"),
  happy: require("./assets/tamagotchi_skins/teal/Cat_happy.gif"),
  happyHeadshake: require("./assets/tamagotchi_skins/teal/Cat_happy_headshake.gif"),
  sad: require("./assets/tamagotchi_skins/teal/Cat_sad.gif"),
  ohno: require("./assets/tamagotchi_skins/teal/Cat_oh_oh.gif"),
  cry: require("./assets/tamagotchi_skins/teal/Cat_cry.gif"),
  waving: require("./assets/tamagotchi_skins/teal/Cat_waving.gif"),
};
const PENDING_COUNTDOWN_FAST_MS = 1000;
const PENDING_BADGE_TICK_MS = 60000;
const PERSIST_DEBOUNCE_MS = 400;
const STORM_OVERLAY_DURATION_MS = 6000;

const stripEmojis = (text = "") =>
  text
    .replace(
      /(?:\uD83C[\uDF00-\uDFFF]|\uD83D[\uDC00-\uDE4F]|\uD83D[\uDE80-\uDEFF]|[\u2600-\u27BF])/g,
      ""
    )
    .replace(/\s{2,}/g, " ")
    .trim();
const keepEmojiWithText = (value = "") => {
  const trimmed = String(value || "").trim();
  if (!trimmed) return "";
  const match = trimmed.match(/^(\S+)\s+(.*)$/);
  if (!match) return trimmed;
  const firstToken = match[1];
  const rest = (match[2] || "").trimStart();
  if (!rest) return trimmed;
  if (stripEmojis(firstToken) === "") {
    return `${firstToken}\u00A0${rest}`;
  }
  return trimmed;
};
const createMonetizationInstallId = () =>
  `m_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 10)}`;
const resolveNonEmptyString = (value = "") => {
  const normalized = String(value || "").trim();
  return normalized || "";
};
const normalizeProductIdentifier = (value = "") =>
  resolveNonEmptyString(value).toLowerCase();
const normalizeMonetizationToken = (value = "", fallback = "unknown") => {
  const normalized = String(value || "")
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "_")
    .replace(/^_+|_+$/g, "");
  if (!normalized) return fallback;
  return normalized.slice(0, 40);
};
const hashAnalyticsText = (value = "") => {
  const normalized = String(value || "").trim().toLowerCase().slice(0, 160);
  if (!normalized) return "none";
  let hash = 2166136261;
  for (let index = 0; index < normalized.length; index += 1) {
    hash ^= normalized.charCodeAt(index);
    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
  }
  return `h_${(hash >>> 0).toString(36)}`;
};
const resolvePlanIdFromProductIdentifier = (productIdentifier = "") => {
  const identifier = String(productIdentifier || "").toLowerCase();
  if (identifier.includes("lifetime") || identifier.includes("life_time")) return "lifetime";
  if (identifier.includes("year") || identifier.includes("annual")) return "yearly";
  if (identifier.includes("month")) return "monthly";
  return null;
};
const resolvePlanIdFromPackage = (pkg) => {
  const packageType = typeof pkg?.packageType === "string" ? pkg.packageType : "";
  if (packageType === "ANNUAL") return "yearly";
  if (packageType === "MONTHLY") return "monthly";
  if (packageType === "LIFETIME") return "lifetime";
  return resolvePlanIdFromProductIdentifier(pkg?.product?.identifier || pkg?.identifier || "");
};
const resolvePremiumProductIdentifier = ({ purchaseResult = null, customerInfo = null, fallbackProductId = "" } = {}) => {
  const fromPurchaseResult = resolveNonEmptyString(purchaseResult?.productIdentifier || "");
  if (fromPurchaseResult) return fromPurchaseResult;
  const fromFallback = resolveNonEmptyString(fallbackProductId || "");
  if (fromFallback && fromFallback !== "unknown") return fromFallback;
  const entitlement = getActivePremiumEntitlement(customerInfo);
  const fromEntitlement = resolveNonEmptyString(
    entitlement?.productIdentifier || entitlement?.productId || entitlement?.product_id || ""
  );
  if (fromEntitlement) return fromEntitlement;
  const activeSubscriptions = Array.isArray(customerInfo?.activeSubscriptions)
    ? customerInfo.activeSubscriptions
    : [];
  const fromActiveSubscription = activeSubscriptions
    .map((entry) => resolveNonEmptyString(entry))
    .find(Boolean);
  if (fromActiveSubscription) return fromActiveSubscription;
  const nonSubscriptionTransactions = Array.isArray(customerInfo?.nonSubscriptionTransactions)
    ? customerInfo.nonSubscriptionTransactions
    : [];
  const fromNonSubscription = nonSubscriptionTransactions
    .map((entry) => resolveNonEmptyString(entry?.productIdentifier || ""))
    .find(Boolean);
  return fromNonSubscription || "";
};
const resolveStoreTransactionIdentifier = ({
  purchaseResult = null,
  customerInfo = null,
  productId = "",
} = {}) => {
  const fromPurchaseResult = resolveNonEmptyString(
    purchaseResult?.transaction?.transactionIdentifier ||
      purchaseResult?.transaction?.transactionId ||
      purchaseResult?.transaction?.identifier ||
      ""
  );
  if (fromPurchaseResult) return fromPurchaseResult;

  const normalizedProductId = normalizeProductIdentifier(productId);
  const subscriptionsByProductIdentifier =
    customerInfo?.subscriptionsByProductIdentifier &&
    typeof customerInfo.subscriptionsByProductIdentifier === "object"
      ? customerInfo.subscriptionsByProductIdentifier
      : null;

  if (subscriptionsByProductIdentifier) {
    if (normalizedProductId) {
      const directSubscriptionEntry = Object.entries(subscriptionsByProductIdentifier).find(
        ([entryProductId]) => normalizeProductIdentifier(entryProductId) === normalizedProductId
      );
      const directStoreTransactionId = resolveNonEmptyString(
        directSubscriptionEntry?.[1]?.storeTransactionId || ""
      );
      if (directStoreTransactionId) return directStoreTransactionId;
    }
    const activeStoreTransactionId = Object.values(subscriptionsByProductIdentifier)
      .map((entry) => (entry?.isActive ? resolveNonEmptyString(entry?.storeTransactionId || "") : ""))
      .find(Boolean);
    if (activeStoreTransactionId) return activeStoreTransactionId;
  }

  const nonSubscriptionTransactions = Array.isArray(customerInfo?.nonSubscriptionTransactions)
    ? customerInfo.nonSubscriptionTransactions
    : [];
  if (normalizedProductId) {
    const directTransaction = nonSubscriptionTransactions.find(
      (entry) => normalizeProductIdentifier(entry?.productIdentifier || "") === normalizedProductId
    );
    const directTransactionId = resolveNonEmptyString(directTransaction?.transactionIdentifier || "");
    if (directTransactionId) return directTransactionId;
  }
  const fallbackNonSubscriptionId = nonSubscriptionTransactions
    .map((entry) => resolveNonEmptyString(entry?.transactionIdentifier || ""))
    .find(Boolean);
  return fallbackNonSubscriptionId || "";
};
const resolvePlanLabel = (planId, language = "en") => {
  const isRussian = language === "ru";
  if (planId === "yearly") return isRussian ? "Ð“Ð¾Ð´" : "Yearly";
  if (planId === "monthly") return isRussian ? "ÐœÐµÑÑÑ†" : "Monthly";
  if (planId === "lifetime") return "Lifetime";
  return isRussian ? "Premium" : "Premium";
};
const resolveMonetizationLanguage = (language = "en") => (language === "ru" ? "ru" : "en");
const PAYWALL_EQUIVALENT_SOURCE_IDS = [
  "coffee_to_go",
  "netflix_subscription",
  "croissant_break",
  "fancy_latte",
  "pizza",
  "late_night_takeout",
  "movie_premiere_combo",
  "cocktail_night",
  "comfort_utilities",
  "beauty_box",
  "grooming_upgrade_set",
  "studio_pass",
  "rent_upgrade",
];
const PAYWALL_YEAR_SUFFIX_BY_LANGUAGE = {
  ru: "/Ð³Ð¾Ð´",
  en: "/yr",
};
const PAYWALL_MONTH_SUFFIX_BY_LANGUAGE = {
  ru: "/Ð¼ÐµÑ",
  en: "/mo",
};
const PAYWALL_BILLING_LABEL_BY_LANGUAGE = {
  monthly: {
    ru: "Ð¡Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ ÐºÐ°Ð¶Ð´Ñ‹Ð¹ Ð¼ÐµÑÑÑ†",
    en: "Billed monthly",
  },
  lifetime: {
    ru: "Ð Ð°Ð·Ð¾Ð²Ñ‹Ð¹ Ð¿Ð»Ð°Ñ‚ÐµÐ¶",
    en: "One-time purchase",
  },
};
const PAYWALL_EQUIVALENT_TEMPLATE_BY_LANGUAGE = {
  ru: {
    monthly: "â‰ˆ {{emoji}} {{count}} Ã— {{item}} Ð² Ð¼ÐµÑÑÑ†",
    yearly: "â‰ˆ {{emoji}} {{count}} Ã— {{item}} Ð² Ð³Ð¾Ð´",
    lifetime: "â‰ˆ {{emoji}} {{count}} Ã— {{item}} Ñ€Ð°Ð·Ð¾Ð²Ð¾",
  },
  en: {
    monthly: "â‰ˆ {{emoji}} {{count}}x {{item}} / month",
    yearly: "â‰ˆ {{emoji}} {{count}}x {{item}} / year",
    lifetime: "â‰ˆ {{emoji}} {{count}}x {{item}} one-time",
  },
};
const DEFAULT_TEMPTATION_BY_ID = new Map(DEFAULT_TEMPTATIONS.map((item) => [item.id, item]));
const parseLocalizedPriceValue = (value) => {
  if (Number.isFinite(value)) return Number(value);
  const raw = String(value || "").trim();
  if (!raw) return null;
  let normalized = raw.replace(/\s/g, "").replace(/[^\d,.-]/g, "");
  if (!normalized) return null;
  const hasDot = normalized.includes(".");
  const hasComma = normalized.includes(",");
  if (hasDot && hasComma) {
    if (normalized.lastIndexOf(",") > normalized.lastIndexOf(".")) {
      normalized = normalized.replace(/\./g, "").replace(",", ".");
    } else {
      normalized = normalized.replace(/,/g, "");
    }
  } else if (hasComma) {
    const commaParts = normalized.split(",");
    const lastPart = commaParts[commaParts.length - 1] || "";
    if (lastPart.length <= 2) {
      normalized = `${commaParts.slice(0, -1).join("")}.${lastPart}`;
    } else {
      normalized = normalized.replace(/,/g, "");
    }
  }
  const parsed = Number(normalized);
  return Number.isFinite(parsed) ? parsed : null;
};
const PAYWALL_SAR_MARKERS_REGEX = /(ï·¼|sar|Ø±\.?\s*Ø³\.?|Ø±ÙŠØ§Ù„(?:Ø§Øª)?)/gi;
const PAYWALL_BIDI_MARKS_REGEX = /[\u200e\u200f\u061c]/g;
const PAYWALL_DIGIT_FRAGMENT_REGEX = /[0-9\u0660-\u0669][0-9\u0660-\u0669\s.,]*/;
const normalizePaywallPriceLabel = (value, currencyCode = DEFAULT_PROFILE.currency) => {
  if (value === undefined || value === null) return "";
  const raw = String(value).trim();
  if (!raw) return "";
  const normalizedCurrency =
    typeof currencyCode === "string" ? currencyCode.trim().toUpperCase() : "";
  if (normalizedCurrency !== "SAR") return raw;
  let normalized = raw.replace(PAYWALL_BIDI_MARKS_REGEX, "").trim();
  normalized = normalized.replace(PAYWALL_SAR_MARKERS_REGEX, "SAR").replace(/\s{2,}/g, " ").trim();
  if (!normalized) return "SAR";
  const amountMatch = normalized.match(PAYWALL_DIGIT_FRAGMENT_REGEX);
  if (!amountMatch) {
    return normalized.startsWith("SAR") ? normalized : `SAR ${normalized}`.trim();
  }
  const amount = amountMatch[0].trim();
  const tail = normalized
    .replace(amountMatch[0], "")
    .replace(/\bSAR\b/gi, "")
    .replace(/\s{2,}/g, " ")
    .trim();
  const suffix = tail ? (tail.startsWith("/") ? tail : ` ${tail}`) : "";
  return `SAR ${amount}${suffix}`.replace(/\s{2,}/g, " ").trim();
};
const formatEquivalentUnits = (value, language = "en") => {
  const lang = resolveMonetizationLanguage(language);
  const safeValue = Number.isFinite(value) ? Math.max(0.1, value) : 1;
  const rounded = safeValue >= 10 ? Math.round(safeValue) : Math.round(safeValue * 10) / 10;
  const formatted = Number.isInteger(rounded) ? String(rounded) : rounded.toFixed(1);
  return lang === "ru" ? formatted.replace(".", ",") : formatted;
};
const pickClosestTemptationEquivalent = ({
  targetLocal = 0,
  currencyCode = DEFAULT_PROFILE.currency,
  preferCoffee = false,
  excludeCoffee = false,
} = {}) => {
  if (!Number.isFinite(targetLocal) || targetLocal <= 0) return null;
  const candidates = PAYWALL_EQUIVALENT_SOURCE_IDS.map((id) => DEFAULT_TEMPTATION_BY_ID.get(id))
    .filter(Boolean)
    .filter((item) => !(excludeCoffee && item.id === "coffee_to_go"))
    .map((item) => {
      const usdValue = Number(item.priceUSD || item.basePriceUSD || 0);
      const localValue = convertToCurrency(usdValue, currencyCode);
      if (!Number.isFinite(localValue) || localValue <= 0) return null;
      return { ...item, localValue };
    })
    .filter(Boolean);
  if (!candidates.length) return null;
  if (preferCoffee) {
    const coffeeCandidate = candidates.find((item) => item.id === "coffee_to_go");
    if (coffeeCandidate) {
      const coffeeUnits = targetLocal / coffeeCandidate.localValue;
      if (coffeeUnits >= 0.4 && coffeeUnits <= 2.5) {
        return {
          ...coffeeCandidate,
          units: coffeeUnits,
        };
      }
    }
  }
  let bestCandidate = null;
  let bestScore = Number.POSITIVE_INFINITY;
  candidates.forEach((item) => {
    const units = targetLocal / item.localValue;
    if (!Number.isFinite(units) || units <= 0) return;
    const score = Math.abs(Math.log(units));
    if (score < bestScore) {
      bestScore = score;
      bestCandidate = { ...item, units };
    }
  });
  return bestCandidate;
};
const buildTemptationEquivalentLine = ({
  planId = "monthly",
  amountLocal = 0,
  currencyCode = DEFAULT_PROFILE.currency,
  language = "en",
} = {}) => {
  if (!Number.isFinite(amountLocal) || amountLocal <= 0) return null;
  const lang = resolveMonetizationLanguage(language);
  const planKey =
    planId === "yearly" || planId === "lifetime" || planId === "monthly" ? planId : "monthly";
  const matched = pickClosestTemptationEquivalent({
    targetLocal: amountLocal,
    currencyCode,
    preferCoffee: planKey === "monthly",
    excludeCoffee: planKey !== "monthly",
  });
  if (!matched) return null;
  const template =
    PAYWALL_EQUIVALENT_TEMPLATE_BY_LANGUAGE[lang]?.[planKey] ||
    PAYWALL_EQUIVALENT_TEMPLATE_BY_LANGUAGE.en.monthly;
  const title = matched.title?.[lang] || matched.title?.en || "temptation";
  return template
    .replace("{{emoji}}", matched.emoji || "ðŸ’¸")
    .replace("{{count}}", formatEquivalentUnits(matched.units, lang))
    .replace("{{item}}", title);
};
const YELLOW_TAMAGOTCHI_ANIMATIONS = {
  idle: require("./assets/tamagotchi_skins/yellow/Cat_idle.gif"),
  curious: require("./assets/tamagotchi_skins/yellow/Cat_curious.gif"),
  follow: require("./assets/tamagotchi_skins/yellow/Cat_follows.gif"),
  speak: require("./assets/tamagotchi_skins/yellow/Cat_speaks.gif"),
  happy: require("./assets/tamagotchi_skins/yellow/Cat_happy.gif"),
  happyHeadshake: require("./assets/tamagotchi_skins/yellow/Cat_happy_headshake.gif"),
  sad: require("./assets/tamagotchi_skins/yellow/Cat_sad.gif"),
  ohno: require("./assets/tamagotchi_skins/yellow/Cat_oh_oh.gif"),
  cry: require("./assets/tamagotchi_skins/yellow/Cat_cry.gif"),
  waving: require("./assets/tamagotchi_skins/yellow/Cat_waving.gif"),
};
const PURPLE_TAMAGOTCHI_ANIMATIONS = {
  idle: require("./assets/tamagotchi_skins/purple/Cat_idle.gif"),
  curious: require("./assets/tamagotchi_skins/purple/Cat_curious.gif"),
  follow: require("./assets/tamagotchi_skins/purple/Cat_follows.gif"),
  speak: require("./assets/tamagotchi_skins/purple/Cat_speaks.gif"),
  happy: require("./assets/tamagotchi_skins/purple/Cat_happy.gif"),
  happyHeadshake: require("./assets/tamagotchi_skins/purple/Cat_happy_headshake.gif"),
  sad: require("./assets/tamagotchi_skins/purple/Cat_sad.gif"),
  ohno: require("./assets/tamagotchi_skins/purple/Cat_oh_oh.gif"),
  cry: require("./assets/tamagotchi_skins/purple/Cat_cry.gif"),
  waving: require("./assets/tamagotchi_skins/purple/Cat_waving.gif"),
};
const TAMAGOTCHI_SKIN_OPTIONS = [
  {
    id: "classic",
    label: { ru: "ÐšÐ»Ð°ÑÑÐ¸Ñ‡ÐµÑÐºÐ¸Ð¹", en: "Classic", es: "ClÃ¡sico", fr: "Classique" },
    description: {
      ru: "Ð—Ð½Ð°ÐºÐ¾Ð¼Ñ‹Ð¹ Ð¾Ð±Ñ€Ð°Ð· ÐÐ»Ð¼Ð¸",
      en: "The original Almi look",
      es: "El estilo original de Almi",
      fr: "Le look original d'Almi",
    },
    preview: require("./assets/Cat_mascot.png"),
    avatar: require("./assets/Cat_mascot.png"),
    animations: CLASSIC_TAMAGOTCHI_ANIMATIONS,
  },
  {
    id: "green",
    label: { ru: "Ð›ÐµÑÐ½Ð¾Ð¹", en: "Forest", es: "Verde bosque", fr: "ForÃªt" },
    description: {
      ru: "ÐœÑÑ‚Ð½Ñ‹Ð¹ Ð¸ÑÑÐ»ÐµÐ´Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ",
      en: "Mint explorer",
      es: "Explorador mentolado",
      fr: "Exploratrice mentholÃ©e",
    },
    preview: require("./assets/tamagotchi_skins/green/Cat_idle.gif"),
    avatar: require("./assets/tamagotchi_skins/green/Cat_idle.gif"),
    animations: GREEN_TAMAGOTCHI_ANIMATIONS,
  },
  {
    id: "teal",
    label: { ru: "Ð›Ð°Ð·ÑƒÑ€Ð½Ñ‹Ð¹", en: "Teal breeze", es: "Brisa turquesa", fr: "Brise turquoise" },
    description: {
      ru: "Ð¡Ð²ÐµÐ¶Ð¸Ð¹ Ð¼Ð¾Ñ€ÑÐºÐ¾Ð¹ Ð¾Ñ‚Ñ‚ÐµÐ½Ð¾Ðº",
      en: "Ocean breeze palette",
      es: "Paleta brisa marina",
      fr: "Palette brise ocÃ©ane",
    },
    preview: require("./assets/tamagotchi_skins/teal/Cat_idle.gif"),
    avatar: require("./assets/tamagotchi_skins/teal/Cat_idle.gif"),
    animations: TEAL_TAMAGOTCHI_ANIMATIONS,
  },
  {
    id: "yellow",
    label: { ru: "Ð¡Ð¾Ð»Ð½ÐµÑ‡Ð½Ñ‹Ð¹", en: "Sunny", es: "Amarillo brillante", fr: "EnsoleillÃ©" },
    description: {
      ru: "Ð¢Ñ‘Ð¿Ð»Ñ‹Ð¹ Ð¸ ÑÐ½ÐµÑ€Ð³Ð¸Ñ‡Ð½Ñ‹Ð¹",
      en: "Bright and energising",
      es: "CÃ¡lido y lleno de energÃ­a",
      fr: "Chaud et plein d'Ã©nergie",
    },
    preview: require("./assets/tamagotchi_skins/yellow/Cat_idle.gif"),
    avatar: require("./assets/tamagotchi_skins/yellow/Cat_idle.gif"),
    animations: YELLOW_TAMAGOTCHI_ANIMATIONS,
  },
  {
    id: "purple",
    label: { ru: "Ð¡Ð¸Ñ€ÐµÐ½ÐµÐ²Ñ‹Ð¹", en: "Lavender", es: "Lavanda", fr: "Lavande" },
    description: {
      ru: "ÐÐµÐ¼Ð½Ð¾Ð³Ð¾ Ð·Ð°Ð³Ð°Ð´Ð¾Ñ‡Ð½Ñ‹Ð¹",
      en: "A dreamy violet vibe",
      es: "Un toque violeta soÃ±ador",
      fr: "Une touche violette rÃªveuse",
    },
    preview: require("./assets/tamagotchi_skins/purple/Cat_idle.gif"),
    avatar: require("./assets/tamagotchi_skins/purple/Cat_idle.gif"),
    animations: PURPLE_TAMAGOTCHI_ANIMATIONS,
  },
];
const TAMAGOTCHI_SKINS = TAMAGOTCHI_SKIN_OPTIONS.reduce((acc, skin) => {
  acc[skin.id] = skin;
  return acc;
}, {});
const DEFAULT_TAMAGOTCHI_SKIN = "classic";
const SUPPORT_EMAIL = "almostappsup@gmail.com";
const INSTAGRAM_URL =
  "https://www.instagram.com/almostsavings?igsh=YzZ5aXB5YWd5ODZy&utm_source=qr";
const FACEBOOK_APP_ID = "1653035139013896";
const HEALTH_COIN_TIERS = [
  { id: "green", value: 1, asset: require("./assets/coins/Coin_green.png") },
  { id: "blue", value: 10, asset: require("./assets/coins/Coin_blue.png") },
  { id: "orange", value: 100, asset: require("./assets/coins/Coin_orange.png") },
  { id: "red", value: 1000, asset: require("./assets/coins/Coin_red.png") },
  { id: "pink", value: 10000, asset: require("./assets/coins/Coin_pink.png") },
];
const BLUE_HEALTH_COIN_TIER =
  HEALTH_COIN_TIERS.find((tier) => tier.id === "blue") || HEALTH_COIN_TIERS[1];
const GREEN_HEALTH_COIN_TIER =
  HEALTH_COIN_TIERS.find((tier) => tier.id === "green") || HEALTH_COIN_TIERS[0];
const BLUE_HEALTH_COIN_ASSET = BLUE_HEALTH_COIN_TIER?.asset || null;
const BLUE_HEALTH_COIN_VALUE = BLUE_HEALTH_COIN_TIER?.value || 10;
const GREEN_HEALTH_COIN_ASSET = GREEN_HEALTH_COIN_TIER?.asset || null;
const GOAL_COMPLETION_REWARD_COINS = 5;
const GOAL_COMPLETION_REWARD_TIER = BLUE_HEALTH_COIN_TIER || HEALTH_COIN_TIERS[1];
const GOAL_COMPLETION_REWARD_VALUE =
  GOAL_COMPLETION_REWARD_COINS * (GOAL_COMPLETION_REWARD_TIER?.value || 1);
const TEMPTATION_SOFT_LIMIT = 150;
const TEMPTATION_HARD_LIMIT = 200;
const SCREEN_WIDTH = Dimensions.get("window").width;
const SCREEN_HEIGHT = Dimensions.get("window").height;
const SAVE_PROGRESS_BAR_WIDTH = Math.min(SCREEN_WIDTH - 80, 340);
const CTA_LETTER_SPACING = 0.4;
const FONT_SCALE = typeof PixelRatio.getFontScale === "function" ? PixelRatio.getFontScale() : 1;
const IS_EXTRA_COMPACT_DEVICE = SCREEN_WIDTH <= 375 || (SCREEN_WIDTH <= 390 && FONT_SCALE > 1.1);
const TYPOGRAPHY_SCALE = IS_EXTRA_COMPACT_DEVICE ? 0.92 : 1;
const scaleFontSize = (value) =>
  typeof value === "number" ? Number((value * TYPOGRAPHY_SCALE).toFixed(2)) : value;
const scaleLetterSpacing = (value) =>
  typeof value === "number" ? Number((value * TYPOGRAPHY_SCALE).toFixed(3)) : value;
const scaleTypographyOverrides = (overrides = {}) => {
  if (!overrides || typeof overrides !== "object") return overrides;
  let next = overrides;
  const applyScaled = (key, scaleFn) => {
    if (typeof overrides[key] === "number") {
      if (next === overrides) next = { ...overrides };
      next[key] = scaleFn(overrides[key]);
    }
  };
  applyScaled("fontSize", scaleFontSize);
  applyScaled("lineHeight", scaleFontSize);
  applyScaled("letterSpacing", scaleLetterSpacing);
  return next;
};
// Limit how far dialog-style cards can move when the keyboard is visible.
const MAX_MODAL_KEYBOARD_OFFSET = Math.min(SCREEN_HEIGHT * 0.45, 360);
const OVERLAY_CARD_MAX_WIDTH = Math.min(SCREEN_WIDTH - 40, 440);
const IS_COMPACT_DEVICE = SCREEN_WIDTH <= 380;
const IS_SHORT_DEVICE = SCREEN_HEIGHT <= 740;
const IS_ANDROID_COMPACT = Platform.OS === "android" && (IS_COMPACT_DEVICE || IS_SHORT_DEVICE);
const SAVE_COUNTER_DIGIT_HEIGHT = 64;
const SAVE_COUNTER_SPIN_LOOPS = 2;
const STREAK_COUNTER_DIGIT_HEIGHT = IS_SHORT_DEVICE ? 90 : 112;
const STREAK_COUNTER_DIGIT_WIDTH = IS_SHORT_DEVICE ? 60 : 76;
const STREAK_COUNTER_SPIN_LOOPS = 2;
const SAVE_PROGRESS_DELAY_MS = 800;
const SAVE_PROGRESS_PULSE_SCALE = 1.08;
const SAVE_COUNTDOWN_ZOOM_DELAY_AFTER_SPIN = 1500;
const SAVE_COUNTDOWN_FINAL_HOLD_DELAY = 2600;
const PROFILE_SUBTITLE_FONT_SIZE = scaleFontSize(IS_COMPACT_DEVICE ? 12 : 13);
const PROFILE_SUBTITLE_LINE_HEIGHT = scaleFontSize(IS_COMPACT_DEVICE ? 16 : 18);
const PROFILE_STAT_LABEL_FONT_SIZE = scaleFontSize(IS_COMPACT_DEVICE ? 8.5 : 10);
const PROFILE_STAT_LETTER_SPACING = scaleLetterSpacing(
  IS_COMPACT_DEVICE ? CTA_LETTER_SPACING * 0.6 : CTA_LETTER_SPACING * 0.8
);
const CHALLENGE_TITLE_FONT_SIZE = scaleFontSize(IS_COMPACT_DEVICE ? 15 : 16);
const CHALLENGE_DESC_FONT_SIZE = scaleFontSize(IS_COMPACT_DEVICE ? 13 : 14);
const CHALLENGE_LINE_HEIGHT = scaleFontSize(IS_COMPACT_DEVICE ? 18 : 20);
const CHALLENGE_META_FONT_SIZE = scaleFontSize(IS_COMPACT_DEVICE ? 11.5 : 12);

const THEMES = {
  light: {
    background: "#F6F7FB",
    card: "#FFFFFF",
    text: "#1C1A2A",
    muted: "#7A7F92",
    border: "#E5E6ED",
    primary: "#111",
  },
  dark: {
    background: "#05070D",
    card: "#161B2A",
    text: "#F7F9FF",
    muted: "#A5B1CC",
    border: "#2E374F",
    primary: "#FFC857",
  },
  pro: {
    background: "#EEF1FF",
    card: "#FFFFFF",
    text: "#101B45",
    muted: "#5F6B98",
    border: "#C7D1FF",
    primary: "#4353FF",
  },
};
const DEFAULT_THEME = "light";
const PRO_THEME_ID = "pro";
const THEME_IDS = ["light", "dark", PRO_THEME_ID];
const PRO_THEME_ACCENT_OPTIONS = [
  {
    id: "indigo",
    accent: "#4353FF",
    label: { ru: "Ð˜Ð½Ð´Ð¸Ð³Ð¾", en: "Indigo", es: "Ãndigo", fr: "Indigo" },
    emoji: "ðŸ«",
  },
  {
    id: "emerald",
    accent: "#1FBF8F",
    label: { ru: "Ð˜Ð·ÑƒÐ¼Ñ€ÑƒÐ´", en: "Emerald", es: "Esmeralda", fr: "Ã‰meraude" },
    emoji: "ðŸ’š",
  },
  {
    id: "sunset",
    accent: "#FF7A59",
    label: { ru: "Ð¡Ð°Ð½ÑÐµÑ‚", en: "Sunset", es: "Atardecer", fr: "Coucher" },
    emoji: "ðŸŒ‡",
  },
  {
    id: "gold",
    accent: "#E3A62B",
    label: { ru: "Ð—Ð¾Ð»Ð¾Ñ‚Ð¾", en: "Gold", es: "Oro", fr: "Or" },
    emoji: "âœ¨",
  },
  {
    id: "violet",
    accent: "#8B61FF",
    label: { ru: "Ð¤Ð¸Ð¾Ð»ÐµÑ‚", en: "Violet", es: "Violeta", fr: "Violet" },
    emoji: "ðŸª»",
  },
  {
    id: "aqua",
    accent: "#2FA8FF",
    label: { ru: "ÐÐºÐ²Ð°", en: "Aqua", es: "Aqua", fr: "Aqua" },
    emoji: "ðŸŒŠ",
  },
];
const DEFAULT_PRO_THEME_ACCENT_ID = "indigo";
const normalizeProThemeAccentId = (value) => {
  const normalized = typeof value === "string" ? value.trim().toLowerCase() : "";
  return PRO_THEME_ACCENT_OPTIONS.some((option) => option.id === normalized)
    ? normalized
    : DEFAULT_PRO_THEME_ACCENT_ID;
};
const resolveProThemeAccentOption = (accentId) =>
  PRO_THEME_ACCENT_OPTIONS.find((option) => option.id === normalizeProThemeAccentId(accentId)) ||
  PRO_THEME_ACCENT_OPTIONS[0];
const resolveProAccentLabel = (option, language = DEFAULT_LANGUAGE) => {
  const normalizedLanguage = normalizeLanguage(language);
  return (
    option?.label?.[normalizedLanguage] ||
    option?.label?.en ||
    option?.label?.ru ||
    option?.id ||
    "Accent"
  );
};
const PRO_THEME_ACCENT_COPY = {
  ru: {
    title: "ÐÐºÑ†ÐµÐ½Ñ‚ PRO-Ñ‚ÐµÐ¼Ñ‹",
    subtitle: "Ð’Ñ‹Ð±ÐµÑ€Ð¸ Ñ†Ð²ÐµÑ‚, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð±ÑƒÐ´ÐµÑ‚ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒÑÑ Ð´Ð»Ñ ÐºÐ½Ð¾Ð¿Ð¾Ðº Ð¸ Ð°ÐºÑ†ÐµÐ½Ñ‚Ð¾Ð² Ð¸Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹ÑÐ°.",
    selected: "Ð’Ñ‹Ð±Ñ€Ð°Ð½Ð¾",
  },
  en: {
    title: "PRO theme accent",
    subtitle: "Pick the color used for buttons and highlighted UI accents.",
    selected: "Selected",
  },
  es: {
    title: "Acento del tema PRO",
    subtitle: "Elige el color para botones y acentos principales de la interfaz.",
    selected: "Seleccionado",
  },
  fr: {
    title: "Accent du thÃ¨me PRO",
    subtitle: "Choisis la couleur utilisÃ©e pour les boutons et accents d'interface.",
    selected: "SÃ©lectionnÃ©",
  },
};
const normalizeThemeId = (value) => {
  const normalized = typeof value === "string" ? value.trim().toLowerCase() : "";
  return THEME_IDS.includes(normalized) ? normalized : DEFAULT_THEME;
};
const resolveThemeColors = (themeId = DEFAULT_THEME, proAccentId = DEFAULT_PRO_THEME_ACCENT_ID) => {
  if (themeId !== PRO_THEME_ID) return THEMES[themeId] || THEMES[DEFAULT_THEME];
  const accentOption = resolveProThemeAccentOption(proAccentId);
  const accent = accentOption.accent;
  return {
    ...THEMES.pro,
    background: blendHexColors(THEMES.pro.background, accent, 0.12),
    text: blendHexColors(THEMES.pro.text, accent, 0.06),
    muted: blendHexColors(THEMES.pro.muted, accent, 0.12),
    border: blendHexColors(THEMES.pro.border, accent, 0.32),
    primary: accent,
  };
};
const buildThemeSelectedEventPayload = (
  themeId = DEFAULT_THEME,
  proAccentId = DEFAULT_PRO_THEME_ACCENT_ID,
  source = "theme_toggle"
) => {
  const normalizedThemeId = normalizeThemeId(themeId);
  const isProTheme = normalizedThemeId === PRO_THEME_ID;
  const normalizedAccentId = isProTheme ? normalizeProThemeAccentId(proAccentId) : "none";
  const accentOption = isProTheme ? resolveProThemeAccentOption(normalizedAccentId) : null;
  return {
    theme: normalizedThemeId,
    is_pro: isProTheme ? 1 : 0,
    pro_color_id: normalizedAccentId,
    pro_color_hex: isProTheme ? String(accentOption?.accent || "none").toLowerCase() : "none",
    source,
  };
};

const INTER_FONTS = {
  light: "Inter_300Light",
  regular: "Inter_400Regular",
  medium: "Inter_500Medium",
  semiBold: "Inter_600SemiBold",
  bold: "Inter_700Bold",
  extraBold: "Inter_800ExtraBold",
  black: "Inter_900Black",
};

const SMART_REMINDER_DELAY_MS = 23 * 60 * 60 * 1000;
const SMART_REMINDER_MIN_INTERVAL_MS = 60 * 60 * 1000;
const SMART_REMINDER_RETENTION_MS = 14 * 24 * 60 * 60 * 1000;
const SMART_REMINDER_LIMIT = 40;
const RECENT_EVENT_NOTIFICATION_WINDOW_MS = 2 * 24 * 60 * 60 * 1000;
const DAILY_NUDGE_REMINDERS = [
  { id: "morning", hour: 9, minute: 0, titleKey: "dailyNudgeMorningTitle", bodyKey: "dailyNudgeMorningBody" },
  { id: "daytime", hour: 12, minute: 30, titleKey: "dailyNudgeDayTitle", bodyKey: "dailyNudgeDayBody" },
  {
    id: "afternoon",
    hour: 15,
    minute: 30,
    titleKey: "dailyNudgeAfternoonTitle",
    bodyKey: "dailyNudgeAfternoonBody",
  },
  { id: "evening", hour: 19, minute: 0, titleKey: "dailyNudgeEveningTitle", bodyKey: "dailyNudgeEveningBody" },
  { id: "streak_20", hour: 20, minute: 0, titleKey: "dailyNudgeStreak20Title", bodyKey: "dailyNudgeStreak20Body" },
  { id: "streak_21", hour: 21, minute: 0, titleKey: "dailyNudgeStreak21Title", bodyKey: "dailyNudgeStreak21Body" },
  { id: "streak_22", hour: 22, minute: 0, titleKey: "dailyNudgeStreak22Title", bodyKey: "dailyNudgeStreak22Body" },
  { id: "streak_23", hour: 23, minute: 0, titleKey: "dailyNudgeStreak23Title", bodyKey: "dailyNudgeStreak23Body" },
  { id: "streak_2330", hour: 23, minute: 30, titleKey: "dailyNudgeStreak2330Title", bodyKey: "dailyNudgeStreak2330Body" },
];
const DAILY_NUDGE_TITLE_KEYS = [
  "dailyNudgeMorningTitle",
  "dailyNudgeDayTitle",
  "dailyNudgeAfternoonTitle",
  "dailyNudgeEveningTitle",
  "dailyNudgeStreak20Title",
  "dailyNudgeStreak21Title",
  "dailyNudgeStreak22Title",
  "dailyNudgeStreak23Title",
  "dailyNudgeStreak2330Title",
];
const DAILY_NUDGE_BODY_KEYS = [
  "dailyNudgeMorningBody",
  "dailyNudgeDayBody",
  "dailyNudgeAfternoonBody",
  "dailyNudgeEveningBody",
  "dailyNudgeStreak20Body",
  "dailyNudgeStreak21Body",
  "dailyNudgeStreak22Body",
  "dailyNudgeStreak23Body",
  "dailyNudgeStreak2330Body",
];
const DAILY_NUDGE_LANGUAGES = SUPPORTED_LANGUAGES;
const DAILY_NUDGE_NOTIFICATION_TAG = "daily_nudge";
const ANDROID_DAILY_NUDGE_CHANNEL_ID = "daily-nudges";
const ANDROID_TAMAGOTCHI_CHANNEL_ID = "tamagotchi-hunger";
const ANDROID_REPORTS_CHANNEL_ID = "weekly-reports";
const DAILY_CHALLENGE_MIN_SPEND_EVENTS = 2;
const DAILY_CHALLENGE_FIXED_REWARD = 2;
const DAILY_CHALLENGE_REWARD_MULTIPLIER = 10;
const DAILY_CHALLENGE_DRAW_COUNT = 3;
const DAILY_CHALLENGE_DRAW_CARD_WIDTH = Math.min(
  122,
  Math.max(64, (SCREEN_WIDTH - 108) / DAILY_CHALLENGE_DRAW_COUNT)
);
const DAILY_CHALLENGE_DRAW_CARD_HEIGHT = Math.round(DAILY_CHALLENGE_DRAW_CARD_WIDTH * 1.38);
const DAILY_CHALLENGE_DRAW_CARD_TILT = [-8, 0, 8];
const DAILY_CHALLENGE_LOOKBACK_MS = 24 * 60 * 60 * 1000;
const DAILY_CHALLENGE_POSITIVE_COOLDOWN_MS = 2 * 24 * 60 * 60 * 1000;
const DAILY_CHALLENGE_POPULAR_TEMPLATE_IDS = new Set(DAILY_CHALLENGE_POPULAR_IDS);
const DAILY_CHALLENGE_POPULAR_CUSTOM_PRICE_CAP_USD = 120;
const DAILY_CHALLENGE_STATUS = {
  IDLE: "idle",
  OFFER: "offer",
  ACTIVE: "active",
  COMPLETED: "completed",
  FAILED: "failed",
};
const FOCUS_VICTORY_THRESHOLD = 3;
const FOCUS_VICTORY_REWARD = 3;
const FOCUS_LOSS_THRESHOLD = 3;
const FOCUS_RECENT_WINDOW_MS = 2 * 24 * 60 * 60 * 1000;
const FOCUS_RECENT_MIN_SPEND_COUNT = 2;
const CHALLENGE_REWARD_SCALE = 0.5;
const getScaledChallengeReward = (value = 0) =>
  Math.max(1, Math.round(Math.max(0, value) * CHALLENGE_REWARD_SCALE));
const PUSH_NOTIFICATION_COOLDOWN_MS = 30 * 60 * 1000;
const PUSH_DEDUPE_WINDOW_MS = 6 * 60 * 60 * 1000;
const ACTIONABLE_NOTIFICATION_CATEGORY_ID = "impulse_action";
const NOTIFICATION_ACTION_SAVE = "action_save";
const NOTIFICATION_ACTION_SPEND = "action_spend";
const WEEKLY_REPORT_WEEKDAY = 6;
const WEEKLY_REPORT_HOUR = 18;
const WEEKLY_REPORT_MINUTE = 0;
const REPORTS_WEEKLY_NOTIFICATION_DEDUPE = "weekly_report_schedule";

const buildTemptationPressureMap = (events = []) => {
  const map = {};
  (Array.isArray(events) ? events : []).forEach((event) => {
    if (!event?.templateId) return;
    const entry = map[event.templateId] || {
      spend: 0,
      save: 0,
      lastTimestamp: 0,
    };
    if (event.action === "spend") {
      entry.spend += 1;
      if (event.timestamp && event.timestamp > entry.lastTimestamp) {
        entry.lastTimestamp = event.timestamp;
      }
    } else if (event.action === "save") {
      entry.save += 1;
    }
    map[event.templateId] = entry;
  });
  return map;
};

const resolveDailyChallengeTemplateId = (
  pressureMap = {},
  minSpendEvents = DAILY_CHALLENGE_MIN_SPEND_EVENTS,
  isValidTemplate = null
) => {
  const ranked = Object.entries(pressureMap || {})
    .map(([templateId, stats]) => ({
      templateId,
      spend: stats?.spend || 0,
      save: stats?.save || 0,
      lastTimestamp: stats?.lastTimestamp || 0,
      score: (stats?.spend || 0) * 2 - (stats?.save || 0),
    }))
    .filter((entry) => entry.spend >= minSpendEvents && entry.spend > entry.save)
    .sort((a, b) => {
      if (b.score !== a.score) return b.score - a.score;
      if (b.spend !== a.spend) return b.spend - a.spend;
      return b.lastTimestamp - a.lastTimestamp;
    });
  for (const entry of ranked) {
    if (typeof isValidTemplate === "function" && !isValidTemplate(entry.templateId)) {
      continue;
    }
    return entry.templateId;
  }
  return null;
};

const createInitialDailyChallengeState = () => ({
  id: null,
  dateKey: null,
  templateId: null,
  templateTitle: "",
  emoji: "âœ¨",
  priceUSD: 0,
  rewardBonus: 0,
  baseReward: 0,
  templateLabel: "",
  target: 1,
  progress: 0,
  status: DAILY_CHALLENGE_STATUS.IDLE,
  acceptedAt: null,
  completedAt: null,
  failedAt: null,
  offerDismissed: false,
  rewardGranted: false,
  completionDismissed: false,
  deferUntilKey: null,
});
const buildDailyNudgeTrigger = (hour, minute, options = {}) => {
  const { repeats = true, allowPast = false } = options || {};
  if (!repeats) {
    const now = new Date();
    const target = new Date(now);
    target.setHours(hour, minute, 0, 0);
    if (target.getTime() <= now.getTime()) {
      if (!allowPast) return null;
      target.setDate(target.getDate() + 1);
    }
    return target;
  }
  if (Platform.OS === "android") {
    const now = new Date();
    const next = new Date(now);
    next.setHours(hour, minute, 0, 0);
    if (next.getTime() <= now.getTime()) {
      next.setDate(next.getDate() + 1);
    }
    return next;
  }
  return { hour, minute, second: 0, repeats: true };
};


const normalizeSmartReminderEntries = (list) => {
  const now = Date.now();
  const seen = new Set();
  const normalized = [];
  (Array.isArray(list) ? list : []).forEach((entry) => {
    if (!entry) return;
    const timestamp = Number(entry.timestamp);
    if (!Number.isFinite(timestamp)) return;
    if (now - timestamp > SMART_REMINDER_RETENTION_MS) return;
    const eventId = entry.eventId || entry.id;
    if (!eventId || seen.has(eventId)) return;
    seen.add(eventId);
    normalized.push({
      id: entry.id || `smart-${eventId}`,
      eventId,
      kind: typeof entry.kind === "string" ? entry.kind : "refuse_spend",
      title: typeof entry.title === "string" ? entry.title : "",
      timestamp,
      scheduledAt: Number(entry.scheduledAt) || timestamp + SMART_REMINDER_DELAY_MS,
      notificationId: entry.notificationId || null,
      templateId: typeof entry.templateId === "string" ? entry.templateId : null,
    });
  });
  normalized.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
  return normalized.slice(0, SMART_REMINDER_LIMIT);
};

const DEFERRED_STORAGE_PARSE_THRESHOLD = 120000;
const shouldDeferLargeParse = (raw) =>
  typeof raw === "string" && raw.length >= DEFERRED_STORAGE_PARSE_THRESHOLD;
const deferNonFeedHydration = (task) => {
  InteractionManager.runAfterInteractions(task);
};

const minuteTicker = (() => {
  let subscribers = new Set();
  let timeoutId = null;
  let intervalId = null;
  const notify = () => {
    const now = Date.now();
    subscribers.forEach((cb) => cb(now));
  };
  const clear = () => {
    if (timeoutId) clearTimeout(timeoutId);
    if (intervalId) clearInterval(intervalId);
    timeoutId = null;
    intervalId = null;
  };
  const schedule = () => {
    clear();
    const now = Date.now();
    const delay = 60000 - (now % 60000);
    timeoutId = setTimeout(() => {
      notify();
      intervalId = setInterval(notify, 60000);
    }, delay);
  };
  return {
    subscribe(callback) {
      subscribers.add(callback);
      if (subscribers.size === 1) {
        schedule();
      }
      return () => {
        subscribers.delete(callback);
        if (!subscribers.size) {
          clear();
        }
      };
    },
  };
})();

const useMinuteTicker = (active = true) => {
  const [now, setNow] = useState(() => Date.now());
  useEffect(() => {
    if (!active) return undefined;
    setNow(Date.now());
    return minuteTicker.subscribe(setNow);
  }, [active]);
  return active ? now : null;
};

const resolveInterFontFamily = (fontWeight) => {
  if (typeof fontWeight === "string") {
    if (fontWeight.toLowerCase() === "bold") return INTER_FONTS.bold;
    if (fontWeight.toLowerCase() === "normal") return INTER_FONTS.regular;
  }
  const numericWeight = Number(fontWeight) || 0;
  if (numericWeight >= 900) return INTER_FONTS.black;
  if (numericWeight >= 800) return INTER_FONTS.extraBold;
  if (numericWeight >= 700) return INTER_FONTS.bold;
  if (numericWeight >= 600) return INTER_FONTS.semiBold;
  if (numericWeight >= 500) return INTER_FONTS.medium;
  if (numericWeight >= 300) return INTER_FONTS.light;
  return INTER_FONTS.regular;
};

const AppText = React.memo(
  forwardRef(function AppText({ style, ...props }, ref) {
    const baseStyles = Array.isArray(style) ? style.filter(Boolean) : style ? [style] : [];
    const flattened = baseStyles.length ? StyleSheet.flatten(baseStyles) || {} : {};
    if (flattened.fontFamily) {
      return <RNText ref={ref} style={style} {...props} />;
    }
    const resolvedFontFamily = resolveInterFontFamily(flattened.fontWeight);
    const fontStyle = { fontFamily: resolvedFontFamily };
    const nextStyle = baseStyles.length ? [...baseStyles, fontStyle] : fontStyle;
    return <RNText ref={ref} style={nextStyle} {...props} />;
  })
);

const AppTextInput = React.memo(
  forwardRef(function AppTextInput({ style, ...props }, ref) {
    const baseStyles = Array.isArray(style) ? style.filter(Boolean) : style ? [style] : [];
    const flattened = baseStyles.length ? StyleSheet.flatten(baseStyles) || {} : {};
    if (flattened.fontFamily) {
      return <RNTextInput ref={ref} style={style} {...props} />;
    }
    const resolvedFontFamily = resolveInterFontFamily(flattened.fontWeight);
    const fontStyle = { fontFamily: resolvedFontFamily };
    const nextStyle = baseStyles.length ? [...baseStyles, fontStyle] : fontStyle;
    return <RNTextInput ref={ref} style={nextStyle} {...props} />;
  })
);

const Text = AppText;
const TextInput = AppTextInput;
const AnimatedText = Animated.createAnimatedComponent(AppText);

const APP_TUTORIAL_BASE_STEPS = [
  {
    id: "feed",
    icon: "âš¡",
    titleKey: "tutorialFeedTitle",
    descriptionKey: "tutorialFeedDesc",
    tabs: ["feed"],
    featureKeys: ["feedTab", "coinEntrySaveLabel", "quickCustomTitle"],
    visualBars: [0.92, 0.58, 0.8, 0.66, 0.84],
    palette: {
      primary: "#62AEFF",
      secondary: "#7FE3C7",
      glow: "#79A9FF",
    },
  },
  {
    id: "goals",
    icon: "ðŸ“Š",
    titleKey: "tutorialGoalsTitle",
    descriptionKey: "tutorialGoalsDesc",
    tabs: ["cart"],
    featureKeys: ["wishlistTab", "budgetWidgetTitle", "challengeTabTitle"],
    visualBars: [0.86, 0.48, 0.72, 0.94, 0.61],
    palette: {
      primary: "#FFB169",
      secondary: "#FFD98E",
      glow: "#FFB784",
    },
  },
  {
    id: "rewards",
    icon: "ðŸŽ",
    titleKey: "tutorialRewardsTitle",
    descriptionKey: "tutorialRewardsDesc",
    tabs: ["purchases"],
    requiresRewards: true,
    featureKeys: ["purchasesTitle", "dailyRewardButtonLabel", "challengeRewardsTabTitle"],
    visualBars: [0.68, 0.92, 0.56, 0.79, 0.88],
    palette: {
      primary: "#9E8CFF",
      secondary: "#FF9EC7",
      glow: "#A498FF",
    },
  },
  {
    id: "profile",
    icon: "ðŸ› ï¸",
    titleKey: "tutorialProfileTitle",
    descriptionKey: "tutorialProfileDesc",
    tabs: ["profile"],
    featureKeys: ["profileTab", "languageTitle", "themeLabel", "soundLabel"],
    visualBars: [0.72, 0.54, 0.88, 0.64, 0.77],
    palette: {
      primary: "#7FD5FF",
      secondary: "#A7F0BC",
      glow: "#7FCBFF",
    },
  },
];
const TEMPTATION_TUTORIAL_STEPS = [
  {
    id: "actions",
    icon: "âœ…",
    titleKey: "temptationTutorialActionsTitle",
    descriptionKey: "temptationTutorialActionsDesc",
    featureKeys: ["coinEntrySaveLabel", "coinEntrySpendLabel", "newPendingTitle"],
    visualBars: [0.62, 0.91, 0.73, 0.55, 0.84],
    palette: {
      primary: "#65C1FF",
      secondary: "#8BE2C8",
      glow: "#7DB8FF",
    },
  },
  {
    id: "swipe",
    icon: "â†”ï¸",
    titleKey: "temptationTutorialSwipeTitle",
    descriptionKey: "temptationTutorialSwipeDesc",
    featureKeys: ["temptationTutorialSwipeTitle", "tutorialFeedTitle"],
    visualBars: [0.9, 0.52, 0.77, 0.68, 0.59],
    palette: {
      primary: "#FFB96E",
      secondary: "#FFC9A0",
      glow: "#FFBE7D",
    },
  },
];
const FAB_TUTORIAL_STATUS = {
  DONE: "done",
  PENDING: "pending",
  SHOWING: "showing",
};
const QUEUED_MODAL_TYPES = {
  FAB_TUTORIAL: "fab_tutorial",
  DAILY_CHALLENGE: "daily_challenge",
  DAILY_CHALLENGE_COMPLETE: "daily_challenge_complete",
  FOCUS_DIGEST: "focus_digest",
  DAILY_SUMMARY: "daily_summary",
  INCOME_PROMPT: "income_prompt",
};
const CARD_TEXTURE_ACCENTS = ["#8AB9FF", "#FFA4C0", "#8CE7CF", "#FFD48A", "#BBA4FF", "#7FD8FF"];
const TEMPTATION_CARD_RADIUS = 28;
// Fine-tune Android highlight alignment when using measureInWindow (positive moves the cutout lower).
const ANDROID_TUTORIAL_HIGHLIGHT_OFFSET = 6;
const TAB_BAR_BASE_HEIGHT = 64;
const TAB_BAR_BASE_HEIGHT_COMPACT = 56;
const HERO_MASCOT_SIZE = 96;
const FAB_BUTTON_SIZE = 64;
const FAB_CONTAINER_BOTTOM = 96;
const FAB_CONTAINER_SIDE = 24;
const FAB_HIDE_TRANSLATE = FAB_BUTTON_SIZE + FAB_CONTAINER_SIDE + 12;
const FAB_TUTORIAL_MIN_SESSIONS = 2;
const FAB_TUTORIAL_HALO_SIZE = 128;
const FAB_TUTORIAL_CARD_SPACING = 140;
const FAB_TUTORIAL_HALO_INSET = (FAB_TUTORIAL_HALO_SIZE - FAB_BUTTON_SIZE) / 2;
const TUTORIAL_HIGHLIGHT_INSET = { top: 0, right: 0, bottom: 0, left: 0 };
const BACK_GESTURE_EDGE_WIDTH = 32;
const BACK_GESTURE_TRIGGER_DISTANCE = 60;
const BACK_GESTURE_VERTICAL_SLOP = 60;
const MAX_TAB_HISTORY = 12;

const CELEBRATION_BASE_RU = [
  "Ð¥Ð¾Ð¿! Ð•Ñ‰Ñ‘ Ð¾Ð´Ð½Ð° Ð¾ÑÐ¾Ð·Ð½Ð°Ð½Ð½Ð°Ñ ÑÐºÐ¾Ð½Ð¾Ð¼Ð¸Ñ",
  "ÐœÐµÐ½ÑŒÑˆÐµ Ð»Ð¸ÑˆÐ½Ð¸Ñ… Ð¿Ð¾ÐºÑƒÐ¿Ð¾Ðº, Ð±Ð¾Ð»ÑŒÑˆÐµ Ð¿Ð»Ð°Ð½Ð°",
  "ÐšÐ¾ÑˆÐµÐ»Ñ‘Ðº Ð²Ð·Ð´Ð¾Ñ…Ð½ÑƒÐ» ÑÐ¿Ð¾ÐºÐ¾Ð¹Ð½Ð¾",
];

const CELEBRATION_MESSAGES = {
  ru: {
    female: [...CELEBRATION_BASE_RU, "Ð¢Ñ‹ ÑÐ½Ð¾Ð²Ð° Ð²Ñ‹Ð±Ñ€Ð°Ð»Ð° ÑƒÐ¼Ð½Ñ‹Ð¹ ÑÐ²Ð¾Ð¿ Ð²Ð¼ÐµÑÑ‚Ð¾ Ñ€Ð°ÑÑ‚Ñ€Ð°Ñ‚"],
    male: [...CELEBRATION_BASE_RU, "Ð¢Ñ‹ ÑÐ½Ð¾Ð²Ð° Ð²Ñ‹Ð±Ñ€Ð°Ð» ÑƒÐ¼Ð½Ñ‹Ð¹ ÑÐ²Ð¾Ð¿ Ð²Ð¼ÐµÑÑ‚Ð¾ Ñ€Ð°ÑÑ‚Ñ€Ð°Ñ‚"],
    none: [...CELEBRATION_BASE_RU, "Ð¡Ð½Ð¾Ð²Ð° Ð²Ñ‹Ð±Ñ€Ð°Ð½ ÑƒÐ¼Ð½Ñ‹Ð¹ ÑÐ²Ð¾Ð¿ Ð²Ð¼ÐµÑÑ‚Ð¾ Ñ€Ð°ÑÑ‚Ñ€Ð°Ñ‚"],
    level: "Ð£Ñ€Ð¾Ð²ÐµÐ½ÑŒ {{level}}! Ð­ÐºÐ¾Ð½Ð¾Ð¼Ð¸Ñ ÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑÑ Ð¿Ñ€Ð¸Ð²Ñ‹Ñ‡ÐºÐ¾Ð¹ ðŸ’Ž",
  },
  en: {
    default: [
      "Boom! Another mindful deal",
      "Less impulse, more plan",
      "Wallet just sighed with relief",
      "Smart deal locked - savings are safe",
    ],
    level: "Level {{level}}! Savings armor upgraded âœ¨",
  },
  fr: {
    default: [
      "Boom ! Encore un choix conscient",
      "Moins d'impulsions, plus de plan",
      "Le portefeuille respire enfin",
      "Accord malin verrouillÃ© - l'Ã©pargne est en sÃ©curitÃ©",
    ],
    level: "Niveau {{level}} ! Armure d'Ã©pargne amÃ©liorÃ©e âœ¨",
  },
  es: {
    default: [
      "Â¡Boom! Otro ahorro consciente",
      "Menos impulso, mÃ¡s plan",
      "La cartera respira aliviada",
      "Intercambio inteligente: el ahorro estÃ¡ a salvo",
    ],
    female: [
      "Â¡Boom! Otro ahorro consciente",
      "Menos impulso, mÃ¡s plan",
      "La cartera respira aliviada",
      "Intercambio inteligente: el ahorro estÃ¡ a salvo",
    ],
    male: [
      "Â¡Boom! Otro ahorro consciente",
      "Menos impulso, mÃ¡s plan",
      "La cartera respira aliviada",
      "Intercambio inteligente: el ahorro estÃ¡ a salvo",
    ],
    none: [
      "Â¡Boom! Otro ahorro consciente",
      "Menos impulso, mÃ¡s plan",
      "La cartera respira aliviada",
      "Intercambio inteligente: el ahorro estÃ¡ a salvo",
    ],
    level: "Â¡Nivel {{level}}! Tu armadura de ahorro sube de rango âœ¨",
  },
};

const getCelebrationMessages = (language, gender = "none") => {
  const normalized = normalizeLanguage(language);
  const entry = CELEBRATION_MESSAGES[normalized] || CELEBRATION_MESSAGES[FALLBACK_LANGUAGE];
  if (!entry) return [];
  if (Array.isArray(entry)) return entry;
  if (Array.isArray(entry.default)) return entry.default;
  const variant =
    (gender && entry[gender]) ||
    entry.none ||
    entry.default ||
    Object.values(entry)[0];
  return Array.isArray(variant) ? variant : [];
};

const RAIN_DROPS = 20;
const LTR_MARK = "\u200E"; // keeps currency labels left-to-right even with RTL symbols
const RTL_CURRENCIES = new Set(["SAR"]);
const CURRENCY_RATES = {
  AED: 3.67,
  AUD: 1.5,
  BYN: 3.3,
  CAD: 1.35,
  EUR: 0.92,
  GBP: 0.79,
  JPY: 150,
  KZT: 450,
  KRW: 1350,
  MXN: 17,
  PLN: 4,
  RUB: 92,
  SAR: 3.75,
  USD: 1,
};
const CURRENCY_REWARD_STEPS = {
  AED: 20,
  AUD: 5,
  BYN: 5,
  CAD: 5,
  EUR: 5,
  GBP: 5,
  JPY: 750,
  KZT: 2000,
  KRW: 7000,
  MXN: 100,
  PLN: 20,
  RUB: 500,
  SAR: 20,
  USD: 5,
};
const DEFAULT_COIN_SLIDER_MAX_USD = 50;
const COIN_SLIDER_SIZE = IS_SHORT_DEVICE ? 190 : 220;
const COIN_REVEAL_SIZE = FAB_BUTTON_SIZE;
const COIN_FLIGHT_SIZE = IS_SHORT_DEVICE ? 56 : 64;
const COIN_SLIDER_VALUE_DEADBAND = 0.01;
const COIN_SLIDER_STATE_MIN_INTERVAL = 16;
const COIN_SLIDER_HAPTIC_COOLDOWN_MS = 80;
const COIN_SLIDER_STEP_STICKINESS = 0.95;
const COIN_SLIDER_GESTURE_DEADBAND = 0.03;
const COIN_FILL_MIN_HEIGHT = 12;
const CURRENCY_SIGNS = {
  AED: "AED ",
  AUD: "A$",
  BYN: "Br",
  CAD: "C$",
  EUR: "â‚¬",
  GBP: "Â£",
  JPY: "Â¥",
  KZT: "â‚¸",
  KRW: "â‚©",
  MXN: "MX$",
  PLN: "zÅ‚",
  RUB: "â‚½",
  SAR: "ï·¼",
  USD: "$",
};
const CURRENCY_FINE_STEPS = {
  AED: 0.5,
  AUD: 0.5,
  BYN: 0.5,
  CAD: 0.5,
  EUR: 0.5,
  GBP: 0.5,
  JPY: 10,
  KZT: 10,
  KRW: 100,
  MXN: 0.5,
  PLN: 0.5,
  RUB: 5,
  SAR: 0.5,
  USD: 0.5,
};
const CURRENCY_DISPLAY_PRECISION = {
  AED: 0,
  AUD: 0,
  BYN: 0,
  CAD: 0,
  EUR: 0,
  GBP: 0,
  MXN: 0,
  PLN: 0,
  SAR: 0,
  USD: 0,
};
const ECONOMY_RULES = {
  saveRewardStepUSD: 5,
  minSaveReward: 1,
  maxSaveReward: 24,
  baseAchievementReward: 60,
  freeDayRescueCost: 60,
  tamagotchiFeedCost: 2,
  tamagotchiFeedBoost: 24,
  tamagotchiPartyCost: 300,
};
const DEFAULT_REMOTE_IMAGE =
  "https://images.unsplash.com/photo-1498050108023-c5249f4df085?auto=format&fit=crop&w=600&q=80";
const REMINDER_DAYS = 14;
const DAY_MS = 1000 * 60 * 60 * 24;
const CHALLENGE_REPEAT_COOLDOWN_MS = DAY_MS * 7;
const CHALLENGE_FAIL_COOLDOWN_MS = DAY_MS * 14;
const HOUR_MS = 1000 * 60 * 60;
const MINUTE_MS = 1000 * 60;
const REWARD_RESET_INTERVAL_MS = DAY_MS * 14;
const REMINDER_MS = REMINDER_DAYS * DAY_MS;
const PENDING_EXTENSION_DAYS = 7;
const PENDING_EXTENSION_MS = PENDING_EXTENSION_DAYS * DAY_MS;
const PENDING_REMINDER_LEAD_MS = HOUR_MS;
const PENDING_REMINDER_GRACE_MS = 30 * MINUTE_MS;
const SAVE_SPAM_WINDOW_MS = 1000 * 60 * 5;
const SAVED_TOTAL_RESET_GRACE_MS = 1000 * 5;
const SAVE_SPAM_ITEM_LIMIT = 3;
const SAVE_SPAM_GLOBAL_LIMIT = 4;
const NORTH_STAR_SAVE_THRESHOLD = 2;
const NORTH_STAR_WINDOW_MS = DAY_MS;
const SAVE_ACTION_COLOR = "#2EB873";
const SPEND_ACTION_COLOR = "#D94862";
// Android darkens translucent backgrounds when elevation is applied, so use opaque fallbacks there.
const COIN_ENTRY_SAVE_BACKGROUND = SAVE_ACTION_COLOR;
const COIN_ENTRY_SPEND_BACKGROUND = SPEND_ACTION_COLOR;
const GOAL_HIGHLIGHT_COLOR = "#F6C16B";
const GOAL_SWIPE_THRESHOLD = 80;
const DELETE_SWIPE_THRESHOLD = 130;
const CHALLENGE_SWIPE_ACTION_WIDTH = 120;
const BASELINE_SAMPLE_USD = 120;
const CUSTOM_SPEND_SAMPLE_USD = 7.5;
const CUSTOM_SPEND_SAVINGS_RANGE = { low: 0.7, high: 1.3 };
const CUSTOM_SPEND_MONTHLY_WEEKS = 4.33;
const RATING_PROMPT_DELAY_DAYS = 2; // show on the third calendar day (after two full days)
const RATING_PROMPT_ACTION_THRESHOLD = 2;
const RATING_PROMPT_ACTION_TYPES = new Set(["save", "spend", "wish", "pending"]);
const ANDROID_REVIEW_URL = "market://details?id=com.sasarei.almostclean";
const ANDROID_REVIEW_WEB_URL = "https://play.google.com/store/apps/details?id=com.sasarei.almostclean";
const IOS_REVIEW_URL = "itms-apps://itunes.apple.com/app/id6756276744?action=write-review";
const IOS_REVIEW_WEB_URL = "https://apps.apple.com/app/id6756276744?action=write-review";
const IOS_MANAGE_SUBSCRIPTIONS_URL = "https://apps.apple.com/account/subscriptions";
const ANDROID_MANAGE_SUBSCRIPTIONS_URL =
  "https://play.google.com/store/account/subscriptions?package=com.sasarei.almostclean";
const LEVEL_SHARE_CAT = require("./assets/Cat_mascot.png");
const LEVEL_SHARE_LOGO = require("./assets/Almost_icon.png");
const LEVEL_SHARE_ACCENT = "#FFB347";
const LEVEL_SHARE_BG = "#050C1A";
const LEVEL_SHARE_MUTED = "rgba(255,255,255,0.65)";
const createInitialRatingPromptState = () => ({
  firstOpenAt: new Date().toISOString(),
  completed: false,
  lastShownAt: null,
  lastAction: null,
  respondedAt: null,
  actionCount: 0,
  actionCountStart: null,
  actionPrompted: false,
});
const RETENTION_MILESTONE_DAYS = new Set([2, 3, 7, 14, 30, 60, 90, 180, 365]);

const normalizeRetentionDayKeys = (value) => {
  if (!Array.isArray(value)) return [];
  const unique = new Set();
  value.forEach((entry) => {
    if (typeof entry !== "string") return;
    const trimmed = entry.trim();
    if (!trimmed) return;
    if (!parseDayKey(trimmed)) return;
    unique.add(trimmed);
  });
  return Array.from(unique).sort((a, b) => a.localeCompare(b));
};

const normalizeRetentionMilestoneDays = (value) => {
  if (!Array.isArray(value)) return [];
  const unique = new Set();
  value.forEach((entry) => {
    const day = Math.floor(Number(entry) || 0);
    if (day > 0) {
      unique.add(day);
    }
  });
  return Array.from(unique).sort((a, b) => a - b);
};

const getDayKey = (date) => {
  const d = new Date(date);
  if (Number.isNaN(d.getTime())) return "";
  d.setHours(0, 0, 0, 0);
  const year = d.getFullYear();
  const month = String(d.getMonth() + 1).padStart(2, "0");
  const day = String(d.getDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
};

const parseDayKey = (key) => {
  if (typeof key !== "string" || key.trim().length === 0) return null;
  const [yearStr, monthStr, dayStr] = key.split("-");
  const year = Number(yearStr);
  const month = Number(monthStr);
  const day = Number(dayStr);
  if (!year || !month || !day) return null;
  const date = new Date(year, month - 1, day);
  if (Number.isNaN(date.getTime())) return null;
  date.setHours(0, 0, 0, 0);
  return date;
};

const getDayDiff = (fromKey, toKey) => {
  const fromDate = parseDayKey(fromKey);
  const toDate = parseDayKey(toKey);
  if (!fromDate || !toDate) return null;
  return Math.round((toDate.getTime() - fromDate.getTime()) / DAY_MS);
};

const getConsecutiveActiveDays = (dayKeys = []) => {
  if (!Array.isArray(dayKeys) || !dayKeys.length) return 0;
  let streak = 1;
  for (let index = dayKeys.length - 1; index > 0; index -= 1) {
    const diff = getDayDiff(dayKeys[index - 1], dayKeys[index]);
    if (diff !== 1) {
      break;
    }
    streak += 1;
  }
  return streak;
};

const getMissedUsageStreakDays = (lastDayKey, todayKey) => {
  if (!lastDayKey || !todayKey) return 0;
  const diff = getDayDiff(lastDayKey, todayKey);
  if (!Number.isFinite(diff) || diff <= 1) return 0;
  return Math.max(0, diff - 1);
};

const getUsageStreakRestoreBase = (payload, todayKey = getDayKey(Date.now())) => {
  const data = payload && typeof payload === "object" ? payload : {};
  const missed = !!data.missed;
  const previousCount = Math.max(0, Number(data.previousCount) || 0);
  const lostCount = Math.max(0, Number(data.lostCount) || 0, previousCount);
  const timestamp = Number.isFinite(data.timestamp) ? data.timestamp : Date.now();
  const fallbackDayKey = getDayKey(timestamp);
  const dayKey = typeof data.dayKey === "string" && data.dayKey ? data.dayKey : fallbackDayKey;
  const streakEndDayKey =
    typeof data.streakEndDayKey === "string" && data.streakEndDayKey ? data.streakEndDayKey : dayKey;
  const missedDays = Number.isFinite(data.missedDays)
    ? Math.max(0, Math.floor(Number(data.missedDays) || 0))
    : getMissedUsageStreakDays(streakEndDayKey, todayKey);
  const shouldOfferRestore = missed && lostCount > 0 && missedDays > 0;
  const hasLoggedToday = dayKey === todayKey;
  return { shouldOfferRestore, missedDays, lostCount, streakEndDayKey, hasLoggedToday };
};

const resolveUsageStreakRestoreDetails = (
  payload,
  { healthPoints = 0, language = DEFAULT_LANGUAGE, todayKey = getDayKey(Date.now()) } = {}
) => {
  const base = getUsageStreakRestoreBase(payload, todayKey);
  const costBlueCount = base.shouldOfferRestore
    ? base.missedDays * STREAK_RESTORE_BLUE_COINS_PER_DAY
    : 0;
  const costValue = base.shouldOfferRestore ? base.missedDays * STREAK_RESTORE_COST_PER_DAY : 0;
  const labels = HEALTH_COIN_LABELS[language] || HEALTH_COIN_LABELS.en;
  const costLabel = costBlueCount ? `${costBlueCount} ${labels.blue || "blue coins"}` : "";
  const canRestore = base.shouldOfferRestore && healthPoints >= costValue;
  return { ...base, costBlueCount, costValue, costLabel, canRestore };
};

const isSameDay = (tsA, tsB = Date.now()) => {
  if (!tsA) return false;
  return getDayKey(tsA) === getDayKey(tsB);
};
const WEEKDAY_FULL_LABELS = {
  ru: ["Ð²Ð¾ÑÐºÑ€ÐµÑÐµÐ½ÑŒÐµ", "Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»ÑŒÐ½Ð¸Ðº", "Ð²Ñ‚Ð¾Ñ€Ð½Ð¸Ðº", "ÑÑ€ÐµÐ´Ð°", "Ñ‡ÐµÑ‚Ð²ÐµÑ€Ð³", "Ð¿ÑÑ‚Ð½Ð¸Ñ†Ð°", "ÑÑƒÐ±Ð±Ð¾Ñ‚Ð°"],
  en: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  es: ["domingo", "lunes", "martes", "miÃ©rcoles", "jueves", "viernes", "sÃ¡bado"],
  fr: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"],
};
const formatRelativeDayLabel = (timestamp, referenceTs, language = DEFAULT_LANGUAGE) => {
  if (!Number.isFinite(timestamp) || !Number.isFinite(referenceTs)) return null;
  const fromKey = getDayKey(timestamp);
  const toKey = getDayKey(referenceTs);
  const diff = getDayDiff(fromKey, toKey);
  if (diff === null) return null;
  const normalizedLanguage = normalizeLanguage(language);
  const weekdayLabels = WEEKDAY_FULL_LABELS[normalizedLanguage] || WEEKDAY_FULL_LABELS[DEFAULT_LANGUAGE];
  const weekday = weekdayLabels[new Date(timestamp).getDay()] || weekdayLabels[0];
  const formatDaysAgo = (count) => {
    if (!Number.isFinite(count) || count <= 0) return null;
    if (normalizedLanguage === "ru") {
      const mod10 = count % 10;
      const mod100 = count % 100;
      let unit = "Ð´Ð½ÐµÐ¹";
      if (mod10 === 1 && mod100 !== 11) {
        unit = "Ð´ÐµÐ½ÑŒ";
      } else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
        unit = "Ð´Ð½Ñ";
      }
      return `${count} ${unit} Ð½Ð°Ð·Ð°Ð´`;
    }
    if (normalizedLanguage === "es") {
      return `hace ${count} dÃ­a${count === 1 ? "" : "s"}`;
    }
    if (normalizedLanguage === "fr") {
      return `il y a ${count} jour${count === 1 ? "" : "s"}`;
    }
    return `${count} day${count === 1 ? "" : "s"} ago`;
  };
  const formatOnWeekday = (dayLabel) => {
    if (!dayLabel) return null;
    if (normalizedLanguage === "ru") return `Ð² ${dayLabel}`;
    if (normalizedLanguage === "es") return `el ${dayLabel}`;
    if (normalizedLanguage === "fr") return `le ${dayLabel}`;
    return `on ${dayLabel}`;
  };
  if (diff === 0) {
    if (normalizedLanguage === "ru") return "ÑÐµÐ³Ð¾Ð´Ð½Ñ";
    if (normalizedLanguage === "es") return "hoy";
    if (normalizedLanguage === "fr") return "aujourd'hui";
    return "today";
  }
  if (diff === 1) {
    if (normalizedLanguage === "ru") return "Ð²Ñ‡ÐµÑ€Ð°";
    if (normalizedLanguage === "es") return "ayer";
    if (normalizedLanguage === "fr") return "hier";
    return "yesterday";
  }
  if (diff === 2) {
    return formatDaysAgo(2);
  }
  if (diff > 2 && diff <= 6) {
    return formatOnWeekday(weekday);
  }
  if (diff < 0) {
    return formatOnWeekday(weekday);
  }
  return formatDaysAgo(Math.abs(diff));
};
const DEFAULT_TEMPTATION_EMOJI = "âœ¨";
const DEFAULT_GOAL_EMOJI = "ðŸŽ¯";
const MAX_HISTORY_EVENTS = 200;
const HISTORY_RETENTION_MS = DAY_MS * 31;
const HERO_RECENT_HISTORY_WINDOW_MS = DAY_MS * 7;
const PROFILE_HISTORY_PAGE_WINDOW_MS = DAY_MS * 14;
const SPEND_LOGGING_REMINDER_DELAY_MS = DAY_MS * 1.5;
const SPEND_LOGGING_REMINDER_COOLDOWN_MS = DAY_MS * 2;
const HISTORY_VIEWPORT_ROWS = 5;
const HISTORY_ITEM_HEIGHT = 60;
const HISTORY_VIEWPORT_HEIGHT = HISTORY_VIEWPORT_ROWS * HISTORY_ITEM_HEIGHT;
const HISTORY_SAVED_GAIN_EVENTS = new Set(["refuse_spend", "pending_to_decline", "income_savings"]);
const HISTORY_PROGRESS_GAIN_EVENTS = new Set(["refuse_spend", "pending_to_decline"]);
const HISTORY_SAVED_LOSS_EVENTS = new Set(["spend"]);
const DAILY_GOAL_COIN_EVENTS = new Set(HISTORY_SAVED_GAIN_EVENTS);
const DAILY_GOAL_WEEKDAY_BOOST = [0.95, 1.02, 1.0, 1.05, 1.08, 0.94, 0.9];
const DAILY_GOAL_SHAKE_THRESHOLD = 1.2;
const DAILY_GOAL_SHAKE_COOLDOWN_MS = 700;
const DAILY_GOAL_GYRO_THRESHOLD = 0.6;
const DAILY_GOAL_GYRO_COOLDOWN_MS = 350;
const DAILY_GOAL_GYRO_ACCEL = 260;
const DAILY_GOAL_GYRO_CLAMP = 2.2;
const DAILY_GOAL_TILT_ACCEL = 1200;
const DAILY_GOAL_TILT_FRICTION = 0.7;
const DAILY_GOAL_TILT_DRAG = 0.0006;
const DAILY_GOAL_TILT_BOUNCE = 0.35;
const DAILY_GOAL_COIN_COLLISION_BOUNCE = 0.32;
const DAILY_GOAL_COIN_COLLISION_SLOP = 0.6;
const DAILY_GOAL_COIN_COLLISION_PERCENT = 0.48;
const DAILY_GOAL_COIN_COLLISION_VELOCITY_EPS = 12;
const DAILY_GOAL_COIN_COLLISION_ITERATIONS = 2;
const DAILY_GOAL_COIN_COLLISION_RESTITUTION_MIN_SPEED = 60;
const DAILY_GOAL_COIN_COLLISION_RESTITUTION_RANGE = 200;
const DAILY_GOAL_COIN_COLLISION_REST_SPEED = 28;
const DAILY_GOAL_COIN_COLLISION_REST_DAMPING = 0.96;
const DAILY_GOAL_TILT_MAX_SPEED = 2600;
const DAILY_GOAL_TILT_DEADZONE = 0.025;
const DAILY_GOAL_TILT_STOP_SPEED = 5;
const DAILY_GOAL_TILT_STOP_TILT = 0.02;
const DAILY_GOAL_TILT_STOP_GYRO = 0.04;
const DAILY_GOAL_GRAVITY = 240;
const PIGGY_COIN_PADDING_X = 18;
const PIGGY_COIN_PADDING_Y = 12;
const HERO_CAROUSEL_ITEM_GUTTER = 16;
const HERO_CAROUSEL_PREMIUM_ATTEMPT_TRIGGER_PX = 10;
const HERO_CAROUSEL_PREMIUM_DRAG_LIMIT_PX = 30;
const HERO_CAROUSEL_WIDGET_ANALYTICS_KEYS = ["H", "B", "P"];
const REPORTS_WEEK_COUNT = 8;
const REPORTS_MONTH_COUNT = 6;
const REPORTS_MAX_INSIGHTS = 3;
const REPORTS_MAX_STEPS = 3;
const REPORTS_MIN_ACTIONS_WEEK = 3;
const REPORTS_MIN_ACTIONS_MONTH = 6;
const getReportsMinActions = (type = "week") =>
  type === "month" ? REPORTS_MIN_ACTIONS_MONTH : REPORTS_MIN_ACTIONS_WEEK;
const getReportsActiveDaysTarget = ({ type = "week", dayCount = 0 } = {}) => {
  const safeDayCount = Math.max(1, Number(dayCount) || 0);
  const minTarget = type === "month" ? 6 : 3;
  const ratio = type === "month" ? 0.4 : 0.6;
  const baseTarget = Math.ceil(safeDayCount * ratio);
  return Math.min(safeDayCount, Math.max(minTarget, baseTarget));
};
const getReportsShareTarget = ({
  percent = 0,
  type = "week",
  activeDays = 0,
  dayCount = 0,
  totalActions = 0,
} = {}) => {
  const safePercent = Math.round(Number(percent) || 0);
  if (!safePercent || safePercent >= 90) return null;
  const minActions = getReportsMinActions(type);
  if (totalActions < minActions) return null;
  const safeDayCount = Math.max(1, Number(dayCount) || 0);
  const activityRatio = Math.max(0, Math.min(1, Number(activeDays) / safeDayCount));
  let step = type === "month" ? 6 : 8;
  if (safePercent < 30) step += type === "month" ? 3 : 5;
  else if (safePercent < 45) step += 2;
  else if (safePercent < 60) step += 1;
  else if (safePercent < 75) step -= 1;
  else if (safePercent < 85) step -= 2;
  else step -= 3;
  if (activityRatio < 0.35) step = Math.max(3, step - 2);
  if (activityRatio > 0.7) step += 1;
  const target = Math.min(95, Math.round(safePercent + step));
  if (!Number.isFinite(target) || target <= safePercent + 2) return null;
  return target;
};
const describeHistoryEntry = (entry, { t, formatLocalAmount }) => {
  if (!entry) return t("historyUnknown");
  const { kind, meta = {} } = entry;
  const title = meta.title || t("historyUnknown");
  switch (kind) {
    case "wish_added":
      return t("historyWishAdded", { title });
    case "wish_progress":
      return t("historyWishProgress", {
        title,
        amount: formatLocalAmount(meta.savedUSD),
        target: formatLocalAmount(meta.targetUSD),
      });
    case "wish_completed":
      return t("historyWishDone", { title });
    case "decline":
      return t("historyDecline", { title, amount: formatLocalAmount(meta.amountUSD) });
    case "refuse_spend":
      return t("historyRefuseSpend", { title, amount: formatLocalAmount(meta.amountUSD) });
    case "pending_added":
      return t("historyPendingAdded", { title });
    case "pending_to_wish":
      return t("historyPendingWant", { title });
    case "pending_to_decline":
      return t("historyPendingDecline", { title, amount: formatLocalAmount(meta.amountUSD) });
    case "pending_removed":
      return t("historyPendingRemoved", { title });
    case "free_day":
      return t("historyFreeDay", { total: meta.total || 0 });
    case "spend":
      return t("historySpend", { title, amount: formatLocalAmount(meta.amountUSD) });
    case "wish_removed":
      return t("historyWishRemoved", { title });
    case "goal_started":
      return t("historyGoalStarted", { title });
    case "goal_cancelled":
      return t("historyGoalCancelled", { title });
    case "reward_claimed":
      return t("historyRewardClaimed", { title: title || meta.rewardId || t("historyUnknown") });
    case "income_savings":
      return t("historyIncomeSavings", { amount: formatLocalAmount(meta.amountUSD) });
    default:
      return t("historyUnknown");
  }
};
const formatHistoryEntryMeta = (entry, { t, locale }) => {
  if (!entry?.timestamp) return "";
  try {
    const date = new Date(entry.timestamp);
    const dateLabel = date.toLocaleDateString(locale, { day: "numeric", month: "short" });
    const timeLabel = date.toLocaleTimeString(locale, { hour: "2-digit", minute: "2-digit" });
    return t("historyTimestamp", { date: dateLabel, time: timeLabel });
  } catch {
    return "";
  }
};
const normalizeClaimedRewardEntry = (value, now = Date.now()) => {
  if (!value) return null;
  if (typeof value === "object" && Number.isFinite(value.claimedAt)) {
    return { claimedAt: value.claimedAt };
  }
  if (typeof value === "number" && Number.isFinite(value)) {
    return { claimedAt: value };
  }
  if (value === true) {
    return { claimedAt: now };
  }
  return null;
};
const normalizeClaimedRewardsMap = (map, now = Date.now()) => {
  if (!map || typeof map !== "object") return {};
  const normalized = {};
  Object.entries(map).forEach(([key, entry]) => {
    const normalizedEntry = normalizeClaimedRewardEntry(entry, now);
    if (!normalizedEntry) return;
    if (now - normalizedEntry.claimedAt < REWARD_RESET_INTERVAL_MS) {
      normalized[key] = normalizedEntry;
    }
  });
  return normalized;
};
const claimedRewardsEqual = (a = {}, b = {}) => {
  const aKeys = Object.keys(a || {});
  const bKeys = Object.keys(b || {});
  if (aKeys.length !== bKeys.length) return false;
  return aKeys.every((key) => {
    const aEntry = a[key];
    const bEntry = b[key];
    if (!bEntry || !aEntry) return false;
    return Number(aEntry.claimedAt) === Number(bEntry.claimedAt);
  });
};
const getHealthCoinTierForAmount = (amount = 0) => {
  const normalized = Math.max(0, Math.floor(amount));
  for (let i = HEALTH_COIN_TIERS.length - 1; i >= 0; i -= 1) {
    const tier = HEALTH_COIN_TIERS[i];
    if (normalized >= tier.value) {
      return tier;
    }
  }
  return HEALTH_COIN_TIERS[0];
};
const getHealthCoinDisplayCount = (amount = 0) => {
  const normalized = Math.max(0, Math.floor(amount));
  const tier = getHealthCoinTierForAmount(normalized);
  const tierValue = Math.max(1, Number(tier?.value) || 1);
  return Math.max(1, Math.ceil(normalized / tierValue));
};
const getHealthCoinBreakdown = (amount = 0) => {
  let remaining = Math.max(0, Math.floor(amount));
  const breakdown = {};
  for (let i = HEALTH_COIN_TIERS.length - 1; i >= 0; i -= 1) {
    const tier = HEALTH_COIN_TIERS[i];
    const count = Math.floor(remaining / tier.value);
    breakdown[tier.id] = count;
    remaining -= count * tier.value;
  }
  HEALTH_COIN_TIERS.forEach((tier) => {
    if (!breakdown[tier.id]) breakdown[tier.id] = 0;
  });
  return breakdown;
};
const buildHealthCoinEntries = (amount = 0) => {
  const breakdown = getHealthCoinBreakdown(amount);
  return HEALTH_COIN_TIERS.slice().reverse().map((tier) => ({
    ...tier,
    count: breakdown[tier.id] || 0,
  }));
};
const getLocalRewardStep = (currencyCode = activeCurrency) => {
  const code = typeof currencyCode === "string" && currencyCode.trim() ? currencyCode : activeCurrency;
  if (code && CURRENCY_REWARD_STEPS[code]) {
    return CURRENCY_REWARD_STEPS[code];
  }
  const rate = code ? CURRENCY_RATES[code] : null;
  if (rate && ECONOMY_RULES.saveRewardStepUSD > 0) {
    return ECONOMY_RULES.saveRewardStepUSD * rate;
  }
  return ECONOMY_RULES.saveRewardStepUSD;
};
const computeRefuseCoinReward = (amountUSD = 0, currencyCode = activeCurrency) => {
  if (!amountUSD || amountUSD <= 0) return 0;
  const localAmount = convertToCurrency(amountUSD, currencyCode);
  const localStep = getLocalRewardStep(currencyCode);
  if (!localStep || localStep <= 0) return 0;
  const normalized = Math.ceil(localAmount / localStep);
  if (normalized <= 0) return 0;
  const adjusted = Math.max(ECONOMY_RULES.minSaveReward, normalized);
  return Math.min(ECONOMY_RULES.maxSaveReward, adjusted);
};

const computeDailyChallengeBonus = (amountUSD = 0, currencyCode = activeCurrency) => {
  const baseReward = computeRefuseCoinReward(amountUSD, currencyCode);
  const multiplier = Math.max(1, DAILY_CHALLENGE_REWARD_MULTIPLIER);
  if (!baseReward || multiplier <= 1) return 0;
  return baseReward * (multiplier - 1);
};

const computeLevelRewardCoins = (level) => {
  if (level <= 1) return 0;
  if (level <= 9) return Math.max(1, level - 1);
  return level;
};

const sumLevelRewardCoins = (level, levelsEarned = 1) => {
  if (level <= 1 || levelsEarned <= 0) return 0;
  const start = Math.max(2, level - levelsEarned + 1);
  let total = 0;
  for (let current = start; current <= level; current += 1) {
    total += computeLevelRewardCoins(current);
  }
  return total;
};

const DEFAULT_DAILY_REWARD_STATE = {
  lastKey: null,
  lastAmount: 0,
  lastClaimAt: 0,
  streak: 0,
};

const DAILY_REWARD_STREAK_LENGTH = 7;

const computeDailyAlmiReward = (savedUSD = 0) => {
  const normalized = Math.max(0, Number(savedUSD) || 0);
  if (normalized <= 0) return ECONOMY_RULES.minSaveReward;
  if (normalized < 50) return 2;
  if (normalized < 200) return 3;
  if (normalized < 500) return 4;
  if (normalized < 1000) return 6;
  return Math.min(12, Math.round(normalized / 200));
};

const buildDailyRewardSchedule = (baseAmount = 0) => {
  const base = Math.max(1, Math.round(baseAmount || 0));
  const rewards = Array.from({ length: DAILY_REWARD_STREAK_LENGTH - 1 }).map(
    (_, index) => base + index
  );
  const daySix = rewards[rewards.length - 1] || base;
  const superPrize = Math.max(daySix + 2, base + Math.round(base * 1.5));
  return [...rewards, superPrize];
};

const getDailyRewardForDay = (baseAmount = 0, day = 1) => {
  const schedule = buildDailyRewardSchedule(baseAmount);
  const index = Math.min(DAILY_REWARD_STREAK_LENGTH, Math.max(1, Number(day) || 1)) - 1;
  return schedule[index] || schedule[0] || Math.max(1, Math.round(baseAmount || 0));
};

const getTemptationPriceLimitForLevel = (level = 1) => {
  if (!Number.isFinite(level) || level <= 1) return 15;
  if (level < 4) return 50;
  if (level < 6) return 150;
  return Infinity;
};

const FEATURE_UNLOCK_STEPS = [
  { level: 2, messageKey: "level2UnlockMessage" },
  { level: 3, messageKey: "level3UnlockMessage" },
  { level: 4, messageKey: "level4UnlockMessage" },
  { level: 5, messageKey: "level5UnlockMessage" },
  { level: 6, messageKey: "level6UnlockMessage" },
  { level: 7, messageKey: "level7UnlockMessage" },
];
const FEATURE_UNLOCK_VARIANT_MAP = {
  level2UnlockMessage: "rewardsDaily",
  level3UnlockMessage: "thinkingList",
  level4UnlockMessage: "impulseMap",
  level5UnlockMessage: "rewardsCustomization",
  level6UnlockMessage: "reports",
  level7UnlockMessage: "freeDay",
};
const FEATURE_UNLOCK_VARIANT_CONFIG = {
  rewardsDaily: {
    titleKey: "featureUnlockRewardsDailyTitle",
    descriptionKey: "featureUnlockRewardsDailyDescription",
    previewLabelKey: "featureUnlockRewardsDailyPreview",
  },
  feedFocus: {
    titleKey: "featureUnlockFeedFocusTitle",
    descriptionKey: "featureUnlockFeedFocusDescription",
    previewLabelKey: "featureUnlockFeedFocusPreview",
  },
  rewardsCustomization: {
    titleKey: "featureUnlockRewardsCustomizationTitle",
    descriptionKey: "featureUnlockRewardsCustomizationDescription",
    previewLabelKey: "featureUnlockRewardsCustomizationPreview",
  },
  catCustomization: {
    titleKey: "featureUnlockCatCustomizationTitle",
    descriptionKey: "featureUnlockCatCustomizationDescription",
    previewLabelKey: "featureUnlockCatCustomizationPreview",
  },
  reports: {
    titleKey: "featureUnlockReportsTitle",
    descriptionKey: "featureUnlockReportsDescription",
    previewLabelKey: "featureUnlockReportsPreview",
  },
  rewardsChallenges: {
    titleKey: "featureUnlockRewardsChallengesTitle",
    descriptionKey: "featureUnlockRewardsChallengesDescription",
    previewLabelKey: "featureUnlockRewardsChallengesPreview",
  },
  impulseMap: {
    titleKey: "featureUnlockImpulseMapTitle",
    descriptionKey: "featureUnlockImpulseMapDescription",
    previewLabelKey: "featureUnlockImpulseMapPreview",
  },
  thinkingList: {
    titleKey: "featureUnlockThinkingTitle",
    descriptionKey: "featureUnlockThinkingDescription",
    previewLabelKey: "featureUnlockThinkingPreview",
  },
  freeDay: {
    titleKey: "featureUnlockFreeDayTitle",
    descriptionKey: "featureUnlockFreeDayDescription",
    previewLabelKey: "featureUnlockFreeDayTitle",
  },
};
const FEATURE_UNLOCK_LEVELS = {
  rewardsDaily: 2,
  feedFocus: 3,
  rewardsCustomization: 5,
  catCustomization: 6,
  reports: 6,
  rewardsChallenges: 1,
  impulseMap: 4,
  thinkingList: 3,
  freeDay: 7,
};
const FEATURE_UNLOCK_PREMIUM_VARIANTS = new Set(["impulseMap", "reports", "catCustomization"]);

const HEALTH_COIN_LABELS = {
  ru: {
    pink: "Ñ€Ð¾Ð·Ð¾Ð²Ñ‹Ñ… Ð¼Ð¾Ð½ÐµÑ‚",
    red: "ÐºÑ€Ð°ÑÐ½Ñ‹Ñ… Ð¼Ð¾Ð½ÐµÑ‚",
    orange: "Ð¾Ñ€Ð°Ð½Ð¶ÐµÐ²Ñ‹Ñ… Ð¼Ð¾Ð½ÐµÑ‚",
    blue: "ÑÐ¸Ð½Ð¸Ñ… Ð¼Ð¾Ð½ÐµÑ‚",
    green: "Ð·ÐµÐ»Ñ‘Ð½Ñ‹Ñ… Ð¼Ð¾Ð½ÐµÑ‚",
  },
  en: {
    pink: "pink coins",
    red: "red coins",
    orange: "orange coins",
    blue: "blue coins",
    green: "green coins",
  },
  es: {
    pink: "monedas rosas",
    red: "monedas rojas",
    orange: "monedas naranjas",
    blue: "monedas azules",
    green: "monedas verdes",
  },
  fr: {
    pink: "piÃ¨ces roses",
    red: "piÃ¨ces rouges",
    orange: "piÃ¨ces orange",
    blue: "piÃ¨ces bleues",
    green: "piÃ¨ces vertes",
  },
};
const ZERO_HEALTH_REWARD_LABELS = {
  ru: "0 Ð¼Ð¾Ð½ÐµÑ‚",
  en: "0 coins",
  es: "0 monedas",
  fr: "0 piÃ¨ce",
};
const formatHealthRewardLabel = (amount = 0, language = DEFAULT_LANGUAGE) => {
  const entries = buildHealthCoinEntries(amount);
  const normalizedLang = normalizeLanguage(language);
  const labels = HEALTH_COIN_LABELS[normalizedLang] || HEALTH_COIN_LABELS.en;
  const parts = entries
    .filter((entry) => entry.count > 0)
    .map((entry) => `${entry.count} ${labels[entry.id] || entry.id}`);
  if (!parts.length) {
    return ZERO_HEALTH_REWARD_LABELS[language] || ZERO_HEALTH_REWARD_LABELS.en;
  }
  return parts.join(" Â· ");
};

const HealthRewardTokens = ({
  amount = 0,
  color = "#fff",
  iconSize = 18,
  maxItems = 3,
  zeroLabel = "0",
  textSize = 12,
  rowStyle = null,
  countStyle = null,
}) => {
  const entries = useMemo(
    () => buildHealthCoinEntries(amount).filter((entry) => entry.count > 0),
    [amount]
  );
  const visible = entries.slice(0, maxItems);
  const rowStyles = rowStyle ? [styles.healthRewardTokenRow, rowStyle] : [styles.healthRewardTokenRow];
  const countStyles = [
    styles.healthRewardTokenCount,
    { color, fontSize: textSize },
    ...(countStyle ? [countStyle] : []),
  ];
  if (!visible.length) {
    return (
      <View style={rowStyles}>
        <Text style={countStyles}>{zeroLabel}</Text>
      </View>
    );
  }
  return (
    <View style={rowStyles}>
      {visible.map((entry) => (
        <View key={`${entry.id}-${entry.count}`} style={styles.healthRewardToken}>
          <Image
            source={entry.asset}
            style={[styles.healthRewardTokenIcon, { width: iconSize, height: iconSize }]}
          />
          <Text style={countStyles}>{`Ã—${entry.count}`}</Text>
        </View>
      ))}
    </View>
  );
};
const INITIAL_DECISION_STATS = {
  resolvedToWishes: 0,
  resolvedToDeclines: 0,
};

const MOOD_IDS = {
  NEUTRAL: "neutral",
  FOCUSED: "focused",
  IMPULSIVE: "impulsive",
  DOUBTER: "doubter",
  TIRED: "tired",
  DREAMER: "dreamer",
};
const MOOD_MAX_EVENTS = 24;
const MOOD_ACTION_WINDOW_MS = 1000 * 60 * 60 * 48;
const MOOD_EVENT_THRESHOLD = 3;
const MOOD_PENDING_THRESHOLD = 4;
const MOOD_DREAM_WISH_THRESHOLD = 3;
const MOOD_INACTIVITY_THRESHOLD_MS = 1000 * 60 * 60 * 72;
const createMoodStateForToday = (overrides = {}) => ({
  current: MOOD_IDS.NEUTRAL,
  events: [],
  lastInteractionAt: null,
  lastVisitAt: null,
  pendingSnapshot: 0,
  dayKey: getDayKey(Date.now()),
  ...overrides,
});

const INITIAL_MOOD_STATE = createMoodStateForToday();

const MOOD_PRESETS = {
  [MOOD_IDS.NEUTRAL]: {
    label: { ru: "Ð ÐµÐ¶Ð¸Ð¼ Ð±Ð°Ð»Ð°Ð½ÑÐ°", en: "Balanced mode", es: "Modo balance", fr: "Mode Ã©quilibre" },
    hero: {
      ru: "Ð‘Ð°Ð»Ð°Ð½Ñ Ð´ÐµÑ€Ð¶Ð¸Ñ‚ÑÑ, Ð¿Ñ€Ð¾ÑÑ‚Ð¾ Ð¿Ñ€Ð¾Ð´Ð¾Ð»Ð¶Ð°Ð¹ Ð¾Ñ‚Ð¼ÐµÑ‡Ð°Ñ‚ÑŒ Ð¿Ð¾Ð±ÐµÐ´Ñ‹.",
      en: "Balance holds steady-keep logging the wins.",
      es: "El balance se mantiene: sigue registrando victorias.",
      fr: "L'Ã©quilibre tient bon : continue de noter tes victoires.",
    },
    heroComplete: {
      ru: "Ð ÐµÐ¶Ð¸Ð¼ ÑÐ¿Ð¾ÐºÐ¾Ð¹ÑÑ‚Ð²Ð¸Ñ Ñ„Ð¸ÐºÑÐ¸Ñ€ÑƒÐµÑ‚ ÐºÐ°Ð¶Ð´Ð¾Ðµ Ð´Ð¾ÑÑ‚Ð¸Ð¶ÐµÐ½Ð¸Ðµ.",
      en: "Calm mode celebrates each milestone.",
      es: "El modo calma celebra cada logro.",
      fr: "Le mode calme cÃ©lÃ¨bre chaque Ã©tape.",
    },
    motivation: {
      ru: "ÐÐµÐ±Ð¾Ð»ÑŒÑˆÐ¾Ð¹ ÑˆÐ°Ð³ ÑÐµÐ³Ð¾Ð´Ð½Ñ ÑÐ¿Ð°ÑÐ°ÐµÑ‚ Ð·Ð°Ð²Ñ‚Ñ€Ð°ÑˆÐ½Ð¸Ð¹ Ð¿Ð»Ð°Ð½.",
      en: "A tiny step today protects tomorrowâ€™s plan.",
      es: "Un paso pequeÃ±o hoy protege el plan de maÃ±ana.",
      fr: "Un petit pas aujourd'hui protÃ¨ge le plan de demain.",
    },
    saveOverlay: {
      ru: "Ð‘Ð°Ð»Ð°Ð½Ñ ÑƒÑÐ¸Ð»ÐµÐ½ ÐµÑ‰Ñ‘ Ð¾Ð´Ð½Ð¸Ð¼ Ð¾Ñ‚ÐºÐ°Ð·Ð¾Ð¼.",
      en: "Balance reinforced with another skip.",
      es: "El balance se refuerza con otro rechazo.",
      fr: "L'Ã©quilibre est renforcÃ© par un refus de plus.",
    },
    impulseOverlay: {
      ru: "Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ ÑÐ¿Ð¾ÐºÐ¾Ð¹ÑÑ‚Ð²Ð¸Ðµ Ð´Ð°Ð¶Ðµ Ð¿Ñ€Ð¸ ÑˆÑ‚Ð¾Ñ€Ð¼Ð°Ñ….",
      en: "Staying calm even when urges spike.",
      es: "Mantenemos la calma incluso cuando suben los impulsos.",
      fr: "On reste calme mÃªme quand les envies montent.",
    },
    pushPendingTitle: {
      ru: "Ð‘Ð°Ð»Ð°Ð½Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÑ‚ Ñ…Ð¾Ñ‚ÐµÐ»ÐºÑƒ ðŸ˜º",
      en: "Balance check-in ðŸ˜º",
      es: "Recordatorio de balance ðŸ˜º",
      fr: "ContrÃ´le Ã©quilibre ðŸ˜º",
    },
    pushPendingBody: {
      ru: "Â«{{title}}Â» Ð¶Ð´ÐµÑ‚ Ñ€ÐµÑˆÐµÐ½Ð¸Ñ. ÐŸÐ¾Ð´ÑƒÐ¼Ð°Ð¹, ÑÑ‚Ð¾Ð¸Ñ‚ Ð»Ð¸ Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ ÐºÑƒÑ€Ñ. ðŸ§­",
      en: "â€œ{{title}}â€ is waiting. Decide if it fits the plan. ðŸ§­",
      es: "â€œ{{title}}â€ sigue esperando. Decide si se queda en el plan. ðŸ§­",
      fr: "Â« {{title}} Â» attend. DÃ©cide si Ã§a reste dans le plan. ðŸ§­",
    },
    pushImpulseTitle: {
      ru: "Ð‘Ð°Ð»Ð°Ð½Ñ Ð² Ð´ÐµÐ»Ðµ ðŸ˜º",
      en: "Balance alert ðŸ˜º",
      es: "Aviso de balance ðŸ˜º",
      fr: "Alerte Ã©quilibre ðŸ˜º",
    },
    pushImpulseBody: {
      ru: "Ð’ ÑÑ‚Ð¾ Ð²Ñ€ÐµÐ¼Ñ Ñ…Ð¾Ñ‡ÐµÑ‚ÑÑ {{temptation}}, Ð½Ð¾ Ð±Ð°Ð»Ð°Ð½Ñ Ð¿Ñ€ÐµÐ´Ð»Ð°Ð³Ð°ÐµÑ‚ ÑÐ¿Ð°ÑÑ‚Ð¸ {{amount}}. ðŸ’§",
      en: "This hour usually tempts {{temptation}}, but balance can bank {{amount}}. ðŸ’§",
      es: "A esta hora suele ganar {{temptation}}, pero el balance puede guardar {{amount}}. ðŸ’§",
      fr: "Ã€ cette heure {{temptation}} appelle, mais l'Ã©quilibre peut mettre {{amount}} de cÃ´tÃ©. ðŸ’§",
    },
  },
  [MOOD_IDS.FOCUSED]: {
    label: { ru: "Ð’Ð¾Ð»ÐµÐ²Ð¾Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼", en: "Focused mode", es: "Modo enfoque", fr: "Mode focus" },
    hero: {
      ru: "Ð’Ð¾Ð»ÐµÐ²Ð¾Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ Ð°ÐºÑ‚Ð¸Ð²ÐµÐ½ - Ð¸ÑÐºÑƒÑˆÐµÐ½Ð¸Ñ ÑÐ°Ð¼Ð¸ Ð¿ÑƒÐ³Ð°ÑŽÑ‚ÑÑ.",
      en: "Focused mode is on-temptations get nervous.",
      es: "El modo enfoque estÃ¡ activo: las tentaciones se ponen nerviosas.",
      fr: "Le mode focus est activÃ© : les tentations se crispent.",
    },
    heroComplete: {
      ru: "Ð’Ð¾Ð»ÐµÐ²Ð¾Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ Ð¸ Ñ†ÐµÐ»ÑŒ ÑÐ´ÐµÐ»Ð°Ð½Ñ‹! ÐœÐ¾Ð¶Ð½Ð¾ Ð¿Ð»Ð°Ð½Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð±Ð¾Ð»ÑŒÑˆÐµ.",
      en: "Focused mode + goal complete! Time to plan even bigger.",
      es: "Modo enfoque + meta completa. Hora de un objetivo mÃ¡s grande.",
      fr: "Mode focus + objectif atteint ! Place Ã  un rÃªve plus grand.",
    },
    motivation: {
      ru: "Ð ÐµÐ¶Ð¸Ð¼ ÑÐ¸Ð»Ñ‹: ÑÐ¾Ð±ÐµÑ€Ð¸ ÐµÑ‰Ñ‘ Ð¾Ð´Ð½Ð¾ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ðµ Ð´Ð¸ÑÑ†Ð¸Ð¿Ð»Ð¸Ð½Ñ‹.",
      en: "Power mode: lock in one more proof of discipline.",
      es: "Modo potencia: suma otra prueba de disciplina.",
      fr: "Mode puissance : ajoute une preuve de discipline de plus.",
    },
    saveOverlay: {
      ru: "Ð’Ð¾Ð»ÐµÐ²Ð¾Ðµ Ñ€ÐµÑˆÐµÐ½Ð¸Ðµ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¾. Ð¢Ð°Ðº Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ!",
      en: "Willpower locked in. Keep it going!",
      es: "La fuerza de voluntad quedÃ³ registrada. Â¡Sigue asÃ­!",
      fr: "Force de volontÃ© verrouillÃ©e. Continue comme Ã§a !",
    },
    impulseOverlay: {
      ru: "Ð’Ð¾Ð»ÐµÐ²Ð¾Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ ÑƒÐ¼ÐµÐµÑ‚ Ñ‚Ð¾Ñ€Ð¼Ð¾Ð·Ð¸Ñ‚ÑŒ Ð¸Ð¼Ð¿ÑƒÐ»ÑŒÑÑ‹.",
      en: "Focused mode crushes impulse spikes.",
      es: "El modo enfoque aplasta los impulsos.",
      fr: "Le mode focus Ã©crase les pics d'impulsion.",
    },
    pushPendingTitle: {
      ru: "Ð’Ð¾Ð»ÐµÐ²Ð¾Ð¹ Ð¿Ð¸Ð½Ð³ ðŸ˜¼",
      en: "Focused ping ðŸ˜¼",
      es: "Ping de enfoque ðŸ˜¼",
      fr: "Ping focus ðŸ˜¼",
    },
    pushPendingBody: {
      ru: "Ð¢Ñ‹ Ð² Ð²Ð¾Ð»ÐµÐ²Ð¾Ð¼ Ñ€ÐµÐ¶Ð¸Ð¼Ðµ - Ñ€ÐµÑˆÐ¸, Ð¸Ð´ÐµÐ¼ Ð»Ð¸ Ð´Ð°Ð»ÑŒÑˆÐµ Ñ Â«{{title}}Â». ðŸ’ª",
      en: "Focused mode speaking-decide what to do with â€œ{{title}}â€. ðŸ’ª",
      es: "Modo enfoque al habla: decide quÃ© hacer con Â«{{title}}Â». ðŸ’ª",
      fr: "Le mode focus te parle : dÃ©cide quoi faire de Â« {{title}} Â». ðŸ’ª",
    },
    pushImpulseTitle: {
      ru: "Ð’Ð¾Ð»ÐµÐ²Ð¾Ð¹ ÑÐ¸Ð³Ð½Ð°Ð» ðŸ˜¼",
      en: "Focused alert ðŸ˜¼",
      es: "Alerta de enfoque ðŸ˜¼",
      fr: "Alerte focus ðŸ˜¼",
    },
    pushImpulseBody: {
      ru: "Ð¡ÐµÐ¹Ñ‡Ð°Ñ Ñ‡Ð°Ñ‰Ðµ Ñ…Ð¾Ñ‡ÐµÑ‚ÑÑ {{temptation}}, Ð½Ð¾ Ð²Ð¾Ð»ÐµÐ²Ð¾Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ Ð¼Ð¾Ð¶ÐµÑ‚ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ {{amount}} Ð² ÐºÐ¾Ð¿Ð¸Ð»ÐºÑƒ. ðŸ¦",
      en: "This hour begs for {{temptation}}, but focused mode can stash {{amount}}. ðŸ¦",
      es: "A esta hora pide {{temptation}}, pero el modo enfoque puede guardar {{amount}}. ðŸ¦",
      fr: "Ã€ cette heure {{temptation}} insiste, mais le mode focus peut mettre {{amount}} de cÃ´tÃ©. ðŸ¦",
    },
  },
  [MOOD_IDS.IMPULSIVE]: {
    label: { ru: "Ð˜Ð¼Ð¿ÑƒÐ»ÑŒÑÐ¸Ð²Ð½Ñ‹Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼", en: "Impulse mode", es: "Modo impulso", fr: "Mode impulsif" },
    hero: {
      ru: "Ð˜Ð¼Ð¿ÑƒÐ»ÑŒÑÐ¸Ð²Ð½Ñ‹Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ Ð²ÐºÐ»ÑŽÑ‡Ñ‘Ð½ - ÑÑ‚Ð¾Ð¸Ñ‚ Ð¿Ð¾Ð¹Ð¼Ð°Ñ‚ÑŒ Ð¿Ð°Ñ€Ñƒ Ð¿Ð¾Ð±ÐµÐ´.",
      en: "Impulse mode detected-time to capture a few wins.",
      es: "Modo impulso activado: toca atrapar un par de victorias.",
      fr: "Mode impulsif dÃ©tectÃ© : il est temps de dÃ©crocher quelques victoires.",
    },
    heroComplete: {
      ru: "Ð˜Ð¼Ð¿ÑƒÐ»ÑŒÑÑ‹ Ð±Ñ‹Ð»Ð¸ ÑÐ¸Ð»ÑŒÐ½Ñ‹Ð¼Ð¸, Ð½Ð¾ Ñ†ÐµÐ»ÑŒ Ð²ÑÑ‘ Ñ€Ð°Ð²Ð½Ð¾ Ð·Ð°ÐºÑ€Ñ‹Ñ‚Ð°.",
      en: "Impulses were strong, yet you still hit the target.",
      es: "El impulso fue fuerte, pero aun asÃ­ lograste la meta.",
      fr: "Les envies Ã©taient fortes, mais tu as quand mÃªme atteint la cible.",
    },
    motivation: {
      ru: "ÐœÐ°Ð»ÐµÐ½ÑŒÐºÐ¸Ð¹ Ð¾Ñ‚ÐºÐ°Ð· Ð¿Ñ€ÑÐ¼Ð¾ ÑÐµÐ¹Ñ‡Ð°Ñ Ð²ÐµÑ€Ð½Ñ‘Ñ‚ ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»ÑŒ.",
      en: "One tiny skip right now resets control.",
      es: "Un pequeÃ±o â€œnoâ€ ahora recupera el control.",
      fr: "Un petit Â« non Â» maintenant rend le contrÃ´le.",
    },
    saveOverlay: {
      ru: "Ð˜Ð¼Ð¿ÑƒÐ»ÑŒÑÑ‹ Ð¼ÐµÐ´Ð»ÑÑ‚ - Ñ‚Ñ‹ Ð¿ÐµÑ€ÐµÑ…Ð²Ð°Ñ‚Ð¸Ð» ÑƒÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ.",
      en: "Impulse paused-you took the controls back.",
      es: "El impulso se detuvo: retomaste el mando.",
      fr: "Impulsion stoppÃ©e : tu reprends les commandes.",
    },
    impulseOverlay: {
      ru: "ÐŸÐ¾Ð¹Ð¼Ð°Ð¹ ÐµÑ‰Ñ‘ Ð¾Ð´Ð¸Ð½ Ð¼Ð¾Ð¼ÐµÐ½Ñ‚ Ð¸ Ð¿ÐµÑ€ÐµÐ²ÐµÐ´Ð¸ ÐµÐ³Ð¾ Ð² ÐºÐ¾Ð¿Ð¸Ð»ÐºÑƒ.",
      en: "Catch the next urge and reroute it into savings.",
      es: "Atrapa el siguiente impulso y conviÃ©rtelo en ahorro.",
      fr: "Attrape la prochaine envie et transforme-la en Ã©pargne.",
    },
    pushPendingTitle: {
      ru: "Ð˜Ð¼Ð¿ÑƒÐ»ÑŒÑ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÑ‚ Â«{{title}}Â» ðŸ™€",
      en: "Impulse check-in ðŸ™€",
      es: "Aviso del impulso ðŸ™€",
      fr: "ContrÃ´le impulsif ðŸ™€",
    },
    pushPendingBody: {
      ru: "Ð˜Ð¼Ð¿ÑƒÐ»ÑŒÑÐ¸Ð²Ð½Ñ‹Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ Ð¿Ñ€Ð¾ÑÐ¸Ñ‚ ÑÑÐ½Ð¾ÑÑ‚Ð¸: Ð¾ÑÑ‚Ð°Ð²Ð»ÑÐµÐ¼ Â«{{title}}Â» Ð¸Ð»Ð¸ ÐºÐ¾Ð¿Ð¸Ð¼? ðŸ”¥",
      en: "Impulse mode needs clarity: keep â€œ{{title}}â€ or bank it? ðŸ”¥",
      es: "El modo impulso pide claridad: Â¿dejamos Â«{{title}}Â» o lo convertimos en ahorro? ðŸ”¥",
      fr: "Le mode impulsif demande une dÃ©cision : on garde Â« {{title}} Â» ou on le convertit en Ã©pargne ? ðŸ”¥",
    },
    pushImpulseTitle: {
      ru: "Ð˜Ð¼Ð¿ÑƒÐ»ÑŒÑ Ð½Ð° Ð¿Ð¾Ð´Ñ…Ð¾Ð´Ðµ ðŸ™€",
      en: "Impulse incoming ðŸ™€",
      es: "Impulso en camino ðŸ™€",
      fr: "Impulsion en approche ðŸ™€",
    },
    pushImpulseBody: {
      ru: "Ð§Ð°Ñ‰Ðµ Ð²ÑÐµÐ³Ð¾ ÑÐµÐ¹Ñ‡Ð°Ñ Ð±ÐµÑ€ÐµÑˆÑŒ {{temptation}}. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ {{amount}} Ð² ÐºÐ¾Ð¿Ð¸Ð»ÐºÑƒ. ðŸ§²",
      en: "{{temptation}} usually wins now. Try sending {{amount}} to savings instead. ðŸ§²",
      es: "Ahora suele ganar {{temptation}}. Intenta enviar {{amount}} al ahorro. ðŸ§²",
      fr: "{{temptation}} gagne souvent maintenant. Essaie d'envoyer {{amount}} vers l'Ã©pargne. ðŸ§²",
    },
  },
  [MOOD_IDS.DOUBTER]: {
    label: { ru: "Ð ÐµÐ¶Ð¸Ð¼ ÑÐ¾Ð¼Ð½ÐµÐ½Ð¸Ð¹", en: "Doubter mode", es: "Modo dudas", fr: "Mode doutes" },
    hero: {
      ru: "Ð ÐµÐ¶Ð¸Ð¼ ÑÐ¾Ð¼Ð½ÐµÐ½Ð¸Ð¹ Ð°ÐºÑ‚Ð¸Ð²ÐµÐ½ - Ð²Ñ‹Ð±ÐµÑ€Ð¸ Ñ…Ð¾Ñ‚Ñ Ð±Ñ‹ Ð¾Ð´Ð½Ð¾ ÑƒÐ²ÐµÑ€ÐµÐ½Ð½Ð¾Ðµ Ñ€ÐµÑˆÐµÐ½Ð¸Ðµ.",
      en: "Doubter mode is on-choose one confident move.",
      es: "Modo dudas activo: elige al menos un movimiento seguro.",
      fr: "Le mode doutes est activÃ© : choisis au moins un geste sÃ»r.",
    },
    heroComplete: {
      ru: "Ð¡Ð¾Ð¼Ð½ÐµÐ²Ð°ÐµÑˆÑŒÑÑ, Ð½Ð¾ Ñ†ÐµÐ»Ð¸ Ð´Ð¾ÑÑ‚Ð¸Ð³Ð°ÑŽÑ‚ÑÑ. Ð—Ð½Ð°Ñ‡Ð¸Ñ‚, ÐºÑƒÑ€Ñ Ð²ÐµÑ€Ð½Ñ‹Ð¹.",
      en: "Doubts aside, goals still get reached. The course works.",
      es: "Aun con dudas, las metas se cumplen. Vas en buen camino.",
      fr: "MÃªme avec des doutes, les objectifs avancent. Le cap est bon.",
    },
    motivation: {
      ru: "Ð’Ñ‹Ð±ÐµÑ€Ð¸ Ð¾Ð´Ð½Ñƒ Ð¼Ñ‹ÑÐ»ÑŒ Â«ÐºÐ¾Ð¿Ð¸Ñ‚ÑŒÂ» Ð¸ Ð·Ð°ÐºÑ€ÐµÐ¿Ð¸ ÑƒÐ²ÐµÑ€ÐµÐ½Ð½Ð¾ÑÑ‚ÑŒ.",
      en: "Pick one â€œsave itâ€ thought and lock it in.",
      es: "Elige un â€œahÃ³rraloâ€ y afianza la confianza.",
      fr: "Choisis un Â« j'Ã©conomise Â» et consolide ta confiance.",
    },
    saveOverlay: {
      ru: "Ð­Ñ‚Ð¾ Ñ€ÐµÑˆÐµÐ½Ð¸Ðµ ÑÐ½Ð¸Ð¼Ð°ÐµÑ‚ ÑÐ¾Ð¼Ð½ÐµÐ½Ð¸Ñ.",
      en: "That choice dissolves doubts.",
      es: "Esa decisiÃ³n disuelve las dudas.",
      fr: "Ce choix dissout les doutes.",
    },
    impulseOverlay: {
      ru: "Ð¡Ð¾Ð¼Ð½ÐµÐ½Ð¸Ñ Ð»ÑƒÑ‡ÑˆÐµ Ð¿ÐµÑ€ÐµÐ²Ð¾Ð´Ð¸Ñ‚ÑŒ Ð² Ñ†Ð¸Ñ„Ñ€Ñ‹, Ð° Ð½Ðµ Ð¿Ð¾ÐºÑƒÐ¿ÐºÐ¸.",
      en: "Turn doubts into numbers, not purchases.",
      es: "Convierte las dudas en nÃºmeros, no en compras.",
      fr: "Transforme les doutes en chiffres, pas en achats.",
    },
    pushPendingTitle: {
      ru: "Ð¡Ð¾Ð¼Ð½ÐµÐ½Ð¸Ñ Ð¿Ñ€Ð¾ÑÑÑ‚ Ð¾Ñ‚Ð²ÐµÑ‚Ð° ðŸ˜¿",
      en: "Doubter check ðŸ˜¿",
      es: "Chequeo de dudas ðŸ˜¿",
      fr: "ContrÃ´le des doutes ðŸ˜¿",
    },
    pushPendingBody: {
      ru: "Â«{{title}}Â» Ð²Ð¸ÑÐ¸Ñ‚ Ð² ÑÐ¾Ð¼Ð½ÐµÐ½Ð¸ÑÑ…. Ð ÐµÑˆÐ¸, ÐºÑƒÐ´Ð° ÐµÐ³Ð¾ Ð½Ð°Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ. ðŸ§©",
      en: "â€œ{{title}}â€ is stuck in limbo. Decide where it belongs. ðŸ§©",
      es: "â€œ{{title}}â€ sigue en duda. Decide adÃ³nde va. ðŸ§©",
      fr: "Â« {{title}} Â» plane encore. DÃ©cide oÃ¹ l'envoyer. ðŸ§©",
    },
    pushImpulseTitle: {
      ru: "Ð¡Ð¾Ð¼Ð½ÐµÐ²Ð°ÐµÑˆÑŒÑÑ? ðŸ˜¿",
      en: "Feeling unsure? ðŸ˜¿",
      es: "Â¿Con dudas? ðŸ˜¿",
      fr: "Un doute ? ðŸ˜¿",
    },
    pushImpulseBody: {
      ru: "ÐšÐ¾Ð³Ð´Ð° Ñ‚ÑÐ½ÐµÑ‚ Ðº {{temptation}}, Ð¿Ð¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹ Ð½Ð°Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ {{amount}} Ð² ÐºÐ¾Ð¿Ð¸Ð»ÐºÑƒ - ÑƒÐ²ÐµÑ€ÐµÐ½Ð½Ð¾ÑÑ‚ÑŒ Ð²ÐµÑ€Ð½Ñ‘Ñ‚ÑÑ. ðŸ§­",
      en: "When {{temptation}} calls, redirect {{amount}} to savings to regain certainty. ðŸ§­",
      es: "Cuando llame {{temptation}}, dirige {{amount}} al ahorro para recuperar seguridad. ðŸ§­",
      fr: "Quand {{temptation}} appelle, envoie {{amount}} vers l'Ã©pargne pour retrouver confiance. ðŸ§­",
    },
  },
  [MOOD_IDS.TIRED]: {
    label: { ru: "Ð ÐµÐ¶Ð¸Ð¼ Ð¾Ñ‚Ð´Ñ‹Ñ…Ð°", en: "Recharge mode", es: "Modo descanso", fr: "Mode recharge" },
    hero: {
      ru: "Ð”Ð°Ð²Ð½Ð¾ Ð½Ðµ Ð²Ð¸Ð´ÐµÐ»Ð¸ÑÑŒ - Ñ€ÐµÐ¶Ð¸Ð¼ Ð¾Ñ‚Ð´Ñ‹Ñ…Ð° Ð½Ð°Ð¿Ð¾Ð¼Ð¸Ð½Ð°ÐµÑ‚ Ð¾ Ð¼ÑÐ³ÐºÐ¾Ð¼ ÑÑ‚Ð°Ñ€Ñ‚Ðµ.",
      en: "Long time no see-recharge mode suggests a gentle restart.",
      es: "Tiempo sin verte: el modo descanso propone un reinicio suave.",
      fr: "Ã‡a faisait longtemps : le mode recharge propose un redÃ©marrage tout doux.",
    },
    heroComplete: {
      ru: "ÐŸÐ°ÑƒÐ·Ñ‹ Ñ‚Ð¾Ð¶Ðµ Ñ‡Ð°ÑÑ‚ÑŒ Ð¿ÑƒÑ‚Ð¸. Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°Ð¹ÑÑ, ÐºÐ¾Ð³Ð´Ð° Ð³Ð¾Ñ‚Ð¾Ð².",
      en: "Breaks are part of the path. Return when ready.",
      es: "Los descansos son parte del camino. Vuelve cuando estÃ©s listo.",
      fr: "Les pauses font partie du chemin. Reviens quand tu es prÃªtÂ·e.",
    },
    motivation: {
      ru: "ÐÐ°Ñ‡Ð½Ð¸ Ñ Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð¾Ñ‚ÐºÐ°Ð·Ð° ÑÐµÐ³Ð¾Ð´Ð½Ñ Ð¸ Ð¿Ð¾ÑÐ¼Ð¾Ñ‚Ñ€Ð¸, Ñ‡Ñ‚Ð¾ Ð¸Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑÑ.",
      en: "Start with one skip today and see the shift.",
      es: "Empieza con un rechazo hoy y nota el cambio.",
      fr: "Commence par un refus aujourd'hui et observe le dÃ©clic.",
    },
    saveOverlay: {
      ru: "Ð’Ð¾Ñ‚ Ð¸ Ð¼ÑÐ³ÐºÐ¸Ð¹ Ñ€ÐµÑÑ‚Ð°Ñ€Ñ‚. Ð¢Ð°Ðº Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ.",
      en: "Thereâ€™s the gentle restart. Nice.",
      es: "AsÃ­ se ve un reinicio suave. Bien hecho.",
      fr: "VoilÃ  un redÃ©marrage tout doux. Bravo.",
    },
    impulseOverlay: {
      ru: "ÐžÑ‚Ð´Ð¾Ñ…Ð½ÑƒÐ²ÑˆÐ°Ñ Ð²ÐµÑ€ÑÐ¸Ñ Ñ‚ÐµÐ±Ñ ÑƒÐ¼ÐµÐµÑ‚ Ð³Ð¾Ð²Ð¾Ñ€Ð¸Ñ‚ÑŒ Â«Ð¿Ð¾Ñ‚Ð¾Ð¼Â».",
      en: "Rested-you can say â€œlaterâ€ with ease.",
      es: "En modo descanso es mÃ¡s fÃ¡cil decir â€œluegoâ€.",
      fr: "ReposÃ©Â·e, tu peux dire \"plus tard\" sans effort.",
    },
    pushPendingTitle: {
      ru: "Ð’ÐµÑ€Ð½Ð¸ÑÑŒ Ðº Â«{{title}}Â» ðŸ˜½ðŸ’¤",
      en: "Come back to â€œ{{title}}â€ ðŸ˜½ðŸ’¤",
      es: "Vuelve a Â«{{title}}Â» ðŸ˜½ðŸ’¤",
      fr: "Reviens Ã  Â« {{title}} Â» ðŸ˜½ðŸ’¤",
    },
    pushPendingBody: {
      ru: "Ð ÐµÐ¶Ð¸Ð¼ Ð¾Ñ‚Ð´Ñ‹Ñ…Ð° Ð½Ðµ Ð²ÐµÑ‡Ð½Ñ‹Ð¹. Ð ÐµÑˆÐ¸, Ñ‡Ñ‚Ð¾ Ð´ÐµÐ»Ð°Ñ‚ÑŒ Ñ Â«{{title}}Â». ðŸ«¶",
      en: "Recharge mode isnâ€™t forever. Decide what to do with â€œ{{title}}â€. ðŸ«¶",
      es: "El modo descanso no es eterno. Decide quÃ© hacer con Â«{{title}}Â». ðŸ«¶",
      fr: "Le mode recharge n'est pas Ã©ternel. DÃ©cide quoi faire de Â« {{title}} Â». ðŸ«¶",
    },
    pushImpulseTitle: {
      ru: "ÐœÑÐ³ÐºÐ¸Ð¹ ÑÐ¸Ð³Ð½Ð°Ð» ðŸ˜½ðŸ’¤",
      en: "Gentle alert ðŸ˜½ðŸ’¤",
      es: "Alerta suave ðŸ˜½ðŸ’¤",
      fr: "Alerte douce ðŸ˜½ðŸ’¤",
    },
    pushImpulseBody: {
      ru: "ÐŸÐ°ÑƒÐ·Ñ‹ Ð±Ñ‹Ð»Ð¸ Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¼Ð¸, Ð½Ð¾ Ð´Ð°Ð¶Ðµ ÑÐµÐ¹Ñ‡Ð°Ñ Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ±ÐµÑ€ÐµÑ‡ÑŒ {{amount}} Ð¾Ñ‚ {{temptation}}. ðŸ’«",
      en: "Breaks ran long, yet this minute can still save {{amount}} from {{temptation}}. ðŸ’«",
      es: "El descanso fue largo, pero aÃºn puedes salvar {{amount}} de {{temptation}}. ðŸ’«",
      fr: "La pause a durÃ©, mais tu peux encore sauver {{amount}} de {{temptation}}. ðŸ’«",
    },
  },
  [MOOD_IDS.DREAMER]: {
    label: { ru: "ÐœÐµÑ‡Ñ‚Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼", en: "Dreamer mode", es: "Modo soÃ±ador", fr: "Mode rÃªveur" },
    hero: {
      ru: "ÐœÐµÑ‡Ñ‚Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ Ð°ÐºÑ‚Ð¸Ð²ÐµÐ½ - Ð² Â«Ð´ÑƒÐ¼Ð°ÐµÐ¼Â» ÑƒÐ¶Ðµ Ñ†ÐµÐ»Ð°Ñ Ð³Ð°Ð»ÐµÑ€ÐµÑ.",
      en: "Dreamer mode is on-your Thinking shelf is a gallery.",
      es: "Modo soÃ±ador activo: tu estante En pausa parece una galerÃ­a.",
      fr: "Le mode rÃªveur est activÃ© : ton onglet En pause ressemble Ã  une galerie.",
    },
    heroComplete: {
      ru: "Ð”Ð°Ð¶Ðµ Ð¼ÐµÑ‡Ñ‚Ð°Ñ‚ÐµÐ»Ð¸ Ð´Ð¾Ð²Ð¾Ð´ÑÑ‚ Ð¿Ð»Ð°Ð½Ñ‹ Ð´Ð¾ ÐºÐ¾Ð½Ñ†Ð°.",
      en: "Even dreamers finish their plans.",
      es: "Incluso los soÃ±adores concluyen sus planes.",
      fr: "MÃªme les rÃªveurs bouclent leurs plans.",
    },
    motivation: {
      ru: "Ð’Ñ‹Ð±ÐµÑ€Ð¸ Ð¾Ð´Ð½Ñƒ Ð¼ÐµÑ‡Ñ‚Ñƒ Ð¸ Ð½Ð°Ð¶Ð¼Ð¸ Â«ÐºÐ¾Ð¿Ð¸Ñ‚ÑŒÂ» ÑÐµÐ³Ð¾Ð´Ð½Ñ.",
      en: "Pick one dream and tap â€œsave itâ€ today.",
      es: "Elige un sueÃ±o y pulsa â€œahÃ³rraloâ€ hoy.",
      fr: "Choisis un rÃªve et appuie sur Â« j'Ã©conomise Â» aujourd'hui.",
    },
    saveOverlay: {
      ru: "ÐœÐµÑ‡Ñ‚Ð° Ð·Ð°Ñ„Ð¸ÐºÑÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð° Ñ€ÐµÐ°Ð»ÑŒÐ½Ñ‹Ð¼ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸ÐµÐ¼.",
      en: "Dream locked in with a real action.",
      es: "SueÃ±o asegurado con una acciÃ³n real.",
      fr: "RÃªve sÃ©curisÃ© par une vraie action.",
    },
    impulseOverlay: {
      ru: "ÐŸÑƒÑÑ‚ÑŒ Ð¼ÐµÑ‡Ñ‚Ñ‹ ÐºÐ¾Ð¿ÑÑ‚ÑÑ Ð² Ñ†Ð¸Ñ„Ñ€Ð°Ñ…, Ð° Ð½Ðµ Ñ€Ð°ÑÑ…Ð¾Ð´Ð°Ñ….",
      en: "Let dreams live in numbers, not expenses.",
      es: "Que los sueÃ±os vivan en cifras y no en gastos.",
      fr: "Que les rÃªves vivent en chiffres, pas en dÃ©penses.",
    },
    pushPendingTitle: {
      ru: "ÐœÐµÑ‡Ñ‚Ñ‹ Ð¶Ð´ÑƒÑ‚ ÑÑ‚Ð°Ñ€Ñ‚Ð° ðŸ˜»",
      en: "Dreams are waiting ðŸ˜»",
      es: "Los sueÃ±os esperan ðŸ˜»",
      fr: "Les rÃªves attendent ðŸ˜»",
    },
    pushPendingBody: {
      ru: "Ð’ Â«Ð´ÑƒÐ¼Ð°ÐµÐ¼Â» ÑƒÐ¶Ðµ Ð¾Ñ‡ÐµÑ€ÐµÐ´ÑŒ. Ð ÐµÑˆÐ¸, Ñ‡Ñ‚Ð¾ Ð´ÐµÐ»Ð°Ñ‚ÑŒ Ñ Â«{{title}}Â». ðŸŒˆ",
      en: "Thinking is crowded. Decide what to do with â€œ{{title}}â€. ðŸŒˆ",
      es: "Hay fila en En pausa. Decide quÃ© hacer con Â«{{title}}Â». ðŸŒˆ",
      fr: "L'onglet En pause est plein. DÃ©cide quoi faire de Â« {{title}} Â». ðŸŒˆ",
    },
    pushImpulseTitle: {
      ru: "ÐœÐµÑ‡Ñ‚Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ ÑÐ¸Ð³Ð½Ð°Ð» ðŸ˜»",
      en: "Dreamer alert ðŸ˜»",
      es: "Alerta soÃ±adora ðŸ˜»",
      fr: "Alerte rÃªveuse ðŸ˜»",
    },
    pushImpulseBody: {
      ru: "Ð›ÑƒÑ‡ÑˆÐµ Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ {{amount}} Ð² Ð¼ÐµÑ‡Ñ‚Ñƒ, Ñ‡ÐµÐ¼ ÑÐ½Ð¾Ð²Ð° Ð±Ñ€Ð°Ñ‚ÑŒ {{temptation}}. ðŸŒŸ",
      en: "Add {{amount}} to the dream instead of grabbing {{temptation}} again. ðŸŒŸ",
      es: "Mejor suma {{amount}} al sueÃ±o antes que volver a tomar {{temptation}}. ðŸŒŸ",
      fr: "Ajoute {{amount}} au rÃªve plutÃ´t que de reprendre {{temptation}}. ðŸŒŸ",
    },
  },
};

const lightenColor = (hex, amount = 0.25) => {
  if (typeof hex !== "string" || !hex.startsWith("#") || (hex.length !== 7 && hex.length !== 4)) {
    return hex;
  }
  const full = hex.length === 4 ? `#${hex[1]}${hex[1]}${hex[2]}${hex[2]}${hex[3]}${hex[3]}` : hex;
  const num = parseInt(full.slice(1), 16);
  if (Number.isNaN(num)) return hex;
  const adjust = (channel) => {
    const delta = 255 * amount;
    const next = channel + delta;
    return Math.max(0, Math.min(255, Math.round(next)));
  };
  const r = adjust((num >> 16) & 255);
  const g = adjust((num >> 8) & 255);
  const b = adjust(num & 255);
  return `rgb(${r}, ${g}, ${b})`;
};

const MOOD_GRADIENTS = {
  [MOOD_IDS.NEUTRAL]: {
    start: "#CDE6FF",
    end: "#F3F7FF",
    accent: "#A2C9FF",
  },
  [MOOD_IDS.FOCUSED]: {
    start: "#FFE8C7",
    end: "#FFD6E7",
    accent: "#FFB973",
  },
  [MOOD_IDS.IMPULSIVE]: {
    start: "#FFD1CC",
    end: "#FFF0DA",
    accent: "#FF8A7F",
  },
  [MOOD_IDS.DOUBTER]: {
    start: "#E3D8FF",
    end: "#F7E9FF",
    accent: "#C7B1FF",
  },
  [MOOD_IDS.TIRED]: {
    start: "#D5E0FF",
    end: "#ECEFF5",
    accent: "#9AB0FF",
  },
  [MOOD_IDS.DREAMER]: {
    start: "#CFF7F1",
    end: "#E9E2FF",
    accent: "#94D8C7",
  },
};

const getMoodGradient = (moodId = MOOD_IDS.NEUTRAL) =>
  MOOD_GRADIENTS[moodId] || MOOD_GRADIENTS[MOOD_IDS.NEUTRAL];

const applyThemeToMoodGradient = (palette, themeKey = "light") => {
  if (!palette) return getMoodGradient();
  if (themeKey === PRO_THEME_ID) {
    return {
      start: lightenColor(palette.start, 0.24),
      end: lightenColor(palette.end, 0.18),
      accent: lightenColor(palette.accent, 0.32),
    };
  }
  if (themeKey !== "dark") return palette;
  return {
    start: lightenColor(palette.start, -0.55),
    end: lightenColor(palette.end, -0.65),
    accent: lightenColor(palette.accent, 0.35),
  };
};

const MoodGradientBlock = ({ colors: palette, style, children }) => {
  const gradientColors = palette || MOOD_GRADIENTS[MOOD_IDS.NEUTRAL];
  return (
    <View
      style={[
        styles.moodGradientBlock,
        { backgroundColor: gradientColors.start },
        style,
      ]}
    >
      <View
        pointerEvents="none"
        style={[
          styles.moodGradientOverlay,
          { backgroundColor: gradientColors.end },
        ]}
      />
      {children}
    </View>
  );
};

const CoinRainOverlay = React.memo(({ dropCount = 14, asset = null }) => {
  const coinAsset = asset || HEALTH_COIN_TIERS[0].asset;
  const drops = useRef(
    Array.from({ length: dropCount }).map((_, idx) => {
      const anim = new Animated.Value(Math.random());
      return {
        key: `coin_rain_${idx}`,
        anim,
        left: Math.random() * (SCREEN_WIDTH - 40),
        size: 20 + Math.random() * 14,
        duration: 4200 + Math.random() * 1800,
        delay: Math.random() * 1400,
      };
    })
  ).current;

  useEffect(() => {
    const loops = drops.map(({ anim, duration, delay }) => {
      const animation = Animated.loop(
        Animated.sequence([
          Animated.delay(delay),
          Animated.timing(anim, {
            toValue: 1,
            duration,
            easing: Easing.out(Easing.cubic),
            useNativeDriver: true,
          }),
          Animated.timing(anim, {
            toValue: 0,
            duration: 0,
            useNativeDriver: true,
          }),
        ])
      );
      animation.start();
      return animation;
    });
    return () => {
      loops.forEach((animation) => animation?.stop?.());
    };
  }, [drops]);

  return (
    <View pointerEvents="none" style={StyleSheet.absoluteFillObject}>
      {drops.map(({ key, anim, left, size }) => {
        const translateY = anim.interpolate({
          inputRange: [0, 1],
          outputRange: [-160, Dimensions.get("window").height + 120],
        });
        const translateX = anim.interpolate({
          inputRange: [0, 0.2, 0.5, 0.8, 1],
          outputRange: [left - 16, left + 12, left - 8, left + 6, left - 2],
        });
        const opacity = anim.interpolate({
          inputRange: [0, 0.15, 0.85, 1],
          outputRange: [0, 0.9, 0.8, 0],
        });
        const rotate = anim.interpolate({
          inputRange: [0, 1],
          outputRange: ["180deg", "540deg"],
        });
        return (
          <Animated.Image
            key={key}
            source={coinAsset}
            style={{
              position: "absolute",
              left: 0,
              width: size,
              height: size,
              opacity,
              transform: [
                { translateX },
                { translateY },
                { rotate },
              ],
            }}
            resizeMode="contain"
          />
        );
      })}
    </View>
  );
});

const PartyFirework = ({ color, size = 160, delay = 0, style }) => {
  const scale = useRef(new Animated.Value(0.2)).current;
  const opacity = useRef(new Animated.Value(0)).current;
  useEffect(() => {
    scale.setValue(0.2);
    opacity.setValue(0);
    const animation = Animated.loop(
      Animated.sequence([
        Animated.delay(delay),
        Animated.parallel([
          Animated.timing(scale, {
            toValue: 1,
            duration: 1100,
            easing: Easing.out(Easing.cubic),
            useNativeDriver: true,
          }),
          Animated.sequence([
            Animated.timing(opacity, {
              toValue: 0.85,
              duration: 220,
              useNativeDriver: true,
            }),
            Animated.timing(opacity, {
              toValue: 0,
              duration: 880,
              useNativeDriver: true,
            }),
          ]),
        ]),
        Animated.timing(scale, {
          toValue: 0.2,
          duration: 0,
          useNativeDriver: true,
        }),
      ])
    );
    animation.start();
    return () => animation.stop();
  }, [delay, opacity, scale]);
  return (
    <Animated.View
      pointerEvents="none"
      style={[
        styles.partyFireworkRing,
        style,
        {
          borderColor: color,
          width: size,
          height: size,
          borderRadius: size / 2,
          transform: [{ scale }],
          opacity,
        },
      ]}
    />
  );
};

const PartyFireworksLayer = ({ isDarkMode = false }) => {
  const palette = useMemo(
    () => (isDarkMode ? PARTY_FIREWORK_COLORS.dark : PARTY_FIREWORK_COLORS.light),
    [isDarkMode]
  );
  return (
    <View pointerEvents="none" style={styles.partyFireworksOverlay}>
      {PARTY_FIREWORK_CONFIGS.map((config, index) => (
        <PartyFirework
          key={`firework_${index}`}
          color={palette[index % palette.length]}
          size={config.size}
          delay={config.delay}
          style={{
            top: config.top,
            bottom: config.bottom,
            left: config.left,
            right: config.right,
          }}
        />
      ))}
    </View>
  );
};

const PartySparklesLayer = React.memo(({ isDarkMode = false, count = 18 }) => {
  const palette = useMemo(
    () => (isDarkMode ? PARTY_FIREWORK_COLORS.dark : PARTY_FIREWORK_COLORS.light),
    [isDarkMode]
  );
  const sparkles = useRef(
    Array.from({ length: count }).map((_, idx) => ({
      key: `party_sparkle_${idx}`,
      anim: new Animated.Value(Math.random()),
      size: 6 + Math.random() * 10,
      top: `${6 + Math.random() * 54}%`,
      left: `${8 + Math.random() * 84}%`,
      duration: 900 + Math.random() * 900,
      delay: Math.random() * 700,
      colorIndex: idx,
    }))
  ).current;

  useEffect(() => {
    const loops = sparkles.map(({ anim, duration, delay }) => {
      const animation = Animated.loop(
        Animated.sequence([
          Animated.delay(delay),
          Animated.timing(anim, {
            toValue: 1,
            duration,
            easing: Easing.out(Easing.quad),
            useNativeDriver: true,
          }),
          Animated.timing(anim, {
            toValue: 0,
            duration: 0,
            useNativeDriver: true,
          }),
        ])
      );
      animation.start();
      return animation;
    });
    return () => loops.forEach((animation) => animation?.stop?.());
  }, [sparkles]);

  return (
    <View pointerEvents="none" style={styles.partySparklesOverlay}>
      {sparkles.map((sparkle) => {
        const scale = sparkle.anim.interpolate({
          inputRange: [0, 0.55, 1],
          outputRange: [0.2, 1, 0.2],
        });
        const opacity = sparkle.anim.interpolate({
          inputRange: [0, 0.2, 0.85, 1],
          outputRange: [0, 0.9, 0.9, 0],
        });
        const color = palette[sparkle.colorIndex % palette.length];
        return (
          <Animated.View
            key={sparkle.key}
            pointerEvents="none"
            style={[
              styles.partySparkle,
              {
                top: sparkle.top,
                left: sparkle.left,
                width: sparkle.size,
                height: sparkle.size,
                borderRadius: sparkle.size / 2,
                backgroundColor: color,
                opacity,
                transform: [{ scale }],
              },
            ]}
          />
        );
      })}
    </View>
  );
});

const TAMAGOTCHI_IDLE_VARIANTS = ["idle", "idle", "curious", "follow", "speak"];
const TAMAGOTCHI_STARVING_VARIANTS = ["cry", "cry", "sad", "ohno", "idle"];
const TAMAGOTCHI_PLAY_DEPRIVED_VARIANTS = ["cry", "sad", "cry", "ohno", "sad"];
const TAMAGOTCHI_REACTION_DURATION = {
  happy: 3600,
  happyHeadshake: 3600,
  sad: 4200,
  ohno: 4000,
};
const TAMAGOTCHI_SPEECH_DURATION_MS = 7000;
const TAMAGOTCHI_SPEECH_COOLDOWN_MS = 9000;
const TAMAGOTCHI_SPEECH_ACTION_COOLDOWN_MS = 2500;
const TAMAGOTCHI_GREETING_SOON_MS = 1000 * 60 * 30;
const TAMAGOTCHI_GREETING_WARM_MS = 1000 * 60 * 60 * 6;
const TAMAGOTCHI_ACTION_SPEECH_REASONS = new Set([
  "save",
  "spend",
  "challenge_progress",
  "level_progress",
  "level_up",
  "focus_set",
  "feed",
  "play",
  "clean",
]);
const TAMAGOTCHI_SPEECH_REASON_PRIORITY = {
  level_up: 5,
  spend: 4,
  save: 4,
  challenge_progress: 3,
  level_progress: 3,
  focus_set: 2,
  play: 2,
  clean: 2,
  feed: 1,
};
const TAMAGOTCHI_DECAY_INTERVAL_MS = 1000 * 60 * 10;
const TAMAGOTCHI_DECAY_STEP = 1.35;
const TAMAGOTCHI_COIN_DECAY_TICKS = 6;
const TAMAGOTCHI_FEED_AMOUNT = ECONOMY_RULES.tamagotchiFeedBoost;
const TAMAGOTCHI_MAX_HUNGER = 100;
const TAMAGOTCHI_MAX_STATE_VALUE = 100;
const TAMAGOTCHI_LOW_MOOD_THRESHOLD = 34;
const TAMAGOTCHI_LOW_CLEANLINESS_THRESHOLD = 34;
const TAMAGOTCHI_DIRTY_DESAT_THRESHOLD = 45;
const TAMAGOTCHI_DECAY_MOOD_STEP = 0.72;
const TAMAGOTCHI_DECAY_CLEANLINESS_STEP = 0.62;
const TAMAGOTCHI_DECAY_MOOD_HUNGER_PENALTY_THRESHOLD = 42;
const TAMAGOTCHI_DECAY_MOOD_CLEAN_PENALTY_THRESHOLD = 44;
const TAMAGOTCHI_HUNGER_NOTIFICATION_DAILY_LIMIT = 3;
const TAMAGOTCHI_HUNGER_NOTIFICATION_WINDOW_MS = 1000 * 60 * 60 * 6;
const TAMAGOTCHI_FEED_COST = ECONOMY_RULES.tamagotchiFeedCost;
const TAMAGOTCHI_PARTY_COST = ECONOMY_RULES.tamagotchiPartyCost;
const TAMAGOTCHI_PARTY_IMMUNITY_MS = DAY_MS * 2;
const PARTY_FIREWORK_CONFIGS = [
  { top: "12%", left: "18%", size: 150, delay: 0 },
  { top: "18%", right: "16%", size: 120, delay: 180 },
  { bottom: "26%", left: "20%", size: 170, delay: 360 },
  { bottom: "22%", right: "18%", size: 140, delay: 520 },
  { top: "30%", left: "40%", size: 110, delay: 420 },
  { top: "10%", right: "30%", size: 130, delay: 260 },
  { bottom: "32%", right: "35%", size: 150, delay: 620 },
];
const PARTY_FIREWORK_COLORS = {
  light: ["#FFB457", "#FF6FD8", "#7CDAFF", "#FFD36E"],
  dark: ["#FFD685", "#FF8FF3", "#7DC6FF", "#9BFFDA"],
};
const PARTY_SOUND_LOOP_MS = 1400;
const PARTY_SOUND_SEQUENCE = [
  { at: 0, key: "party_beat" },
  { at: 140, key: "party_clap" },
  { at: 280, key: "party_beat" },
  { at: 420, key: "party_clap" },
  { at: 560, key: "party_beat" },
  { at: 700, key: "party_clap" },
  { at: 860, key: "party_beat" },
  { at: 1040, key: "party_cheer" },
];
const TAMAGOTCHI_PARTY_BLUE_COST = Math.max(
  1,
  Math.round(TAMAGOTCHI_PARTY_COST / HEALTH_COIN_TIERS[1].value)
);
const TAMAGOTCHI_FOOD_OPTIONS = [
  {
    id: "berries",
    tier: "snack",
    emoji: "ðŸ“",
    hungerBoost: Math.round(TAMAGOTCHI_FEED_AMOUNT * 0.55),
    cost: Math.max(1, Math.round(TAMAGOTCHI_FEED_COST)),
    label: { ru: "Ð¯Ð³Ð¾Ð´ÐºÐ¸", en: "Berries", es: "Frutos rojos", fr: "Baies" },
  },
  {
    id: "fish",
    tier: "treat",
    emoji: "ðŸŸ",
    hungerBoost: TAMAGOTCHI_FEED_AMOUNT,
    cost: Math.max(2, Math.round(TAMAGOTCHI_FEED_COST * 2)),
    label: { ru: "Ð Ñ‹Ð±ÐºÐ°", en: "Fish", es: "Pescado", fr: "Poisson" },
  },
  {
    id: "sushi",
    tier: "deluxe",
    emoji: "ðŸ£",
    hungerBoost: TAMAGOTCHI_FEED_AMOUNT + 12,
    cost: Math.max(4, Math.round(TAMAGOTCHI_FEED_COST * 4)),
    label: { ru: "Ð¡ÑƒÑˆÐ¸", en: "Sushi", es: "Sushi", fr: "Sushi" },
  },
  {
    id: "cake",
    tier: "deluxe",
    emoji: "ðŸ°",
    hungerBoost: TAMAGOTCHI_FEED_AMOUNT + 18,
    cost: Math.max(5, Math.round(TAMAGOTCHI_FEED_COST * 5)),
    label: { ru: "Ð”ÐµÑÐµÑ€Ñ‚", en: "Dessert", es: "Postre", fr: "Dessert" },
  },
];
const TAMAGOTCHI_FOOD_MAP = TAMAGOTCHI_FOOD_OPTIONS.reduce((acc, option) => {
  acc[option.id] = option;
  return acc;
}, {});
const TAMAGOTCHI_DEFAULT_FOOD_ID =
  TAMAGOTCHI_FOOD_OPTIONS[0]?.id || (TAMAGOTCHI_FOOD_OPTIONS[1]?.id ?? "berries");
const resolveTamagotchiFoodTier = (hunger = TAMAGOTCHI_MAX_HUNGER) => {
  const normalized = Math.max(0, Math.min(TAMAGOTCHI_MAX_HUNGER, hunger));
  if (normalized < 30) return "deluxe";
  if (normalized < 60) return "treat";
  return "snack";
};
const pickTamagotchiFoodByTier = (tier = "snack", excludeId = null) => {
  const pool = TAMAGOTCHI_FOOD_OPTIONS.filter((food) => food.tier === tier);
  const fallback = pool.length ? pool : TAMAGOTCHI_FOOD_OPTIONS;
  if (!fallback.length) return null;
  const candidates =
    excludeId && fallback.length > 1 ? fallback.filter((food) => food.id !== excludeId) : fallback;
  const list = candidates.length ? candidates : fallback;
  const randomIndex = Math.floor(Math.random() * list.length);
  return list[randomIndex]?.id || fallback[0].id;
};
const resolveNextTamagotchiFoodId = (
  hunger = TAMAGOTCHI_MAX_HUNGER,
  prevId = TAMAGOTCHI_DEFAULT_FOOD_ID,
  forceChange = false
) => {
  const nextTier = resolveTamagotchiFoodTier(hunger);
  const prevFood = TAMAGOTCHI_FOOD_MAP[prevId];
  const prevTier = prevFood?.tier || resolveTamagotchiFoodTier(TAMAGOTCHI_MAX_HUNGER);
  if (!forceChange && prevTier === nextTier && prevFood) {
    return prevId;
  }
  return pickTamagotchiFoodByTier(nextTier, forceChange ? prevId : null) || prevId;
};
const TAMAGOTCHI_TOY_OPTIONS = [
  {
    id: "yarn",
    tier: "calm",
    emoji: "ðŸ§¶",
    cost: Math.max(1, Math.round(TAMAGOTCHI_FEED_COST * 0.8)),
    moodBoost: 14,
    cleanPenalty: 2,
    label: { ru: "ÐšÐ»ÑƒÐ±Ð¾Ðº", en: "Yarn", es: "Ovillo", fr: "Pelote" },
  },
  {
    id: "feather",
    tier: "focus",
    emoji: "ðŸª¶",
    cost: Math.max(2, Math.round(TAMAGOTCHI_FEED_COST * 1.3)),
    moodBoost: 18,
    cleanPenalty: 3,
    label: { ru: "ÐŸÐµÑ€Ð¾", en: "Feather", es: "Pluma", fr: "Plume" },
  },
  {
    id: "mouse",
    tier: "focus",
    emoji: "ðŸ­",
    cost: Math.max(3, Math.round(TAMAGOTCHI_FEED_COST * 1.8)),
    moodBoost: 22,
    cleanPenalty: 4,
    label: { ru: "ÐœÑ‹ÑˆÐºÐ°", en: "Toy mouse", es: "Ratoncito", fr: "Souris" },
  },
  {
    id: "laser",
    tier: "active",
    emoji: "ðŸ”´",
    cost: Math.max(4, Math.round(TAMAGOTCHI_FEED_COST * 2.4)),
    moodBoost: 28,
    cleanPenalty: 5,
    label: { ru: "Ð›Ð°Ð·ÐµÑ€", en: "Laser", es: "LÃ¡ser", fr: "Laser" },
  },
];
const TAMAGOTCHI_TOY_MAP = TAMAGOTCHI_TOY_OPTIONS.reduce((acc, option) => {
  acc[option.id] = option;
  return acc;
}, {});
const TAMAGOTCHI_DEFAULT_TOY_ID =
  TAMAGOTCHI_TOY_OPTIONS[0]?.id || (TAMAGOTCHI_TOY_OPTIONS[1]?.id ?? "yarn");
const resolveTamagotchiToyTier = (mood = TAMAGOTCHI_MAX_STATE_VALUE) => {
  const normalized = Math.max(0, Math.min(TAMAGOTCHI_MAX_STATE_VALUE, mood));
  if (normalized < 35) return "active";
  if (normalized < 65) return "focus";
  return "calm";
};
const pickTamagotchiToyByTier = (tier = "calm", excludeId = null) => {
  const pool = TAMAGOTCHI_TOY_OPTIONS.filter((toy) => toy.tier === tier);
  const fallback = pool.length ? pool : TAMAGOTCHI_TOY_OPTIONS;
  if (!fallback.length) return null;
  const candidates =
    excludeId && fallback.length > 1 ? fallback.filter((toy) => toy.id !== excludeId) : fallback;
  const list = candidates.length ? candidates : fallback;
  const randomIndex = Math.floor(Math.random() * list.length);
  return list[randomIndex]?.id || fallback[0].id;
};
const resolveNextTamagotchiToyId = (
  mood = TAMAGOTCHI_MAX_STATE_VALUE,
  prevId = TAMAGOTCHI_DEFAULT_TOY_ID,
  forceChange = false
) => {
  const nextTier = resolveTamagotchiToyTier(mood);
  const prevToy = TAMAGOTCHI_TOY_MAP[prevId];
  const prevTier = prevToy?.tier || resolveTamagotchiToyTier(TAMAGOTCHI_MAX_STATE_VALUE);
  if (!forceChange && prevTier === nextTier && prevToy) {
    return prevId;
  }
  return pickTamagotchiToyByTier(nextTier, forceChange ? prevId : null) || prevId;
};
const TAMAGOTCHI_CLEAN_TOOLS = [
  {
    id: "soap_foam",
    type: "soap",
    emoji: "ðŸ§¼",
    cost: Math.max(1, Math.round(TAMAGOTCHI_FEED_COST * 0.8)),
    maxUses: 14,
    cleanBoost: 3,
    moodBoost: 0,
    label: { ru: "ÐœÑ‹Ð»Ð¾-Ð¿ÐµÐ½ÐºÐ°", en: "Foam soap", es: "JabÃ³n espuma", fr: "Savon mousse" },
  },
  {
    id: "soap_bubbles",
    type: "soap",
    emoji: "ðŸ«§",
    cost: Math.max(2, Math.round(TAMAGOTCHI_FEED_COST * 1.2)),
    maxUses: 16,
    cleanBoost: 4,
    moodBoost: 0,
    label: { ru: "ÐœÑ‹Ð»ÑŒÐ½Ñ‹Ðµ Ð¿ÑƒÐ·Ñ‹Ñ€Ð¸", en: "Bubbly soap", es: "JabÃ³n burbujas", fr: "Savon bulles" },
  },
  {
    id: "brush_soft",
    type: "brush",
    emoji: "ðŸª¥",
    cost: Math.max(2, Math.round(TAMAGOTCHI_FEED_COST * 1.5)),
    maxUses: 12,
    cleanBoost: 4,
    moodBoost: 1,
    label: { ru: "ÐœÑÐ³ÐºÐ°Ñ Ñ‰Ñ‘Ñ‚ÐºÐ°", en: "Soft brush", es: "Cepillo suave", fr: "Brosse douce" },
  },
  {
    id: "brush_massage",
    type: "brush",
    emoji: "ðŸ§½",
    cost: Math.max(3, Math.round(TAMAGOTCHI_FEED_COST * 2)),
    maxUses: 12,
    cleanBoost: 5,
    moodBoost: 1,
    label: { ru: "ÐœÐ°ÑÑÐ°Ð¶Ð½Ð°Ñ Ñ‰Ñ‘Ñ‚ÐºÐ°", en: "Massage brush", es: "Cepillo masaje", fr: "Brosse massage" },
  },
];
const TAMAGOTCHI_CLEAN_TOOL_MAP = TAMAGOTCHI_CLEAN_TOOLS.reduce((acc, option) => {
  acc[option.id] = option;
  return acc;
}, {});
const TAMAGOTCHI_DEFAULT_CLEAN_TOOL_ID =
  TAMAGOTCHI_CLEAN_TOOLS[0]?.id || (TAMAGOTCHI_CLEAN_TOOLS[1]?.id ?? "soap_foam");
const TAMAGOTCHI_CLEAN_SOAP_TARGET = 6;
const TAMAGOTCHI_CLEAN_BRUSH_TARGET = 6;
const TAMAGOTCHI_CLEAN_SWIPE_DISTANCE_PX = 28;
const TAMAGOTCHI_CLEAN_SWIPE_STROKE_COOLDOWN_MS = 70;
const TAMAGOTCHI_CLOSE_EDGE_WIDTH = 56;
const TAMAGOTCHI_CLOSE_SWIPE_DISTANCE = 52;
const TAMAGOTCHI_CLOSE_VERTICAL_SLOP = 72;
const createTamagotchiCleaningProgress = () => ({
  stage: "soap",
  soapHits: 0,
  brushHits: 0,
});
const createDefaultTamagotchiToolSupplies = (fillRatio = 0) =>
  TAMAGOTCHI_CLEAN_TOOLS.reduce((acc, tool) => {
    const maxUses = Math.max(1, Number(tool.maxUses) || 1);
    const nextValue = Math.round(maxUses * Math.max(0, Math.min(1, fillRatio)));
    acc[tool.id] = Math.max(0, Math.min(maxUses, nextValue));
    return acc;
  }, {});
const normalizeTamagotchiToolSupplies = (value) =>
  TAMAGOTCHI_CLEAN_TOOLS.reduce((acc, tool) => {
    const maxUses = Math.max(1, Number(tool.maxUses) || 1);
    const raw = Number(value?.[tool.id]);
    const nextValue = Number.isFinite(raw) ? Math.round(raw) : 0;
    acc[tool.id] = Math.max(0, Math.min(maxUses, nextValue));
    return acc;
  }, {});
const TAMAGOTCHI_HUNGER_LOW_THRESHOLD = Math.round(TAMAGOTCHI_MAX_HUNGER * 0.3);
const TAMAGOTCHI_START_STATE = {
  hunger: 80,
  mood: 76,
  cleanliness: 78,
  coins: 5,
  lastFedAt: null,
  lastPlayedAt: null,
  lastCleanedAt: null,
  lastDecayAt: null,
  coinTick: 0,
  desiredFoodId: TAMAGOTCHI_DEFAULT_FOOD_ID,
  desiredToyId: TAMAGOTCHI_DEFAULT_TOY_ID,
  cleanToolSupplies: createDefaultTamagotchiToolSupplies(0),
  hungerImmunityUntil: 0,
};
const TAMAGOTCHI_NOTIFICATION_COPY = {
  ru: {
    low: "ÐÐ»Ð¼Ð¸ Ð¿Ñ€Ð¾Ð³Ð¾Ð»Ð¾Ð´Ð°Ð»ÑÑ - Ð·Ð°Ð³Ð»ÑÐ½Ð¸ Ð¸ Ð¿Ð¾ÐºÐ¾Ñ€Ð¼Ð¸ ÐµÐ³Ð¾. ðŸ˜ºðŸ¥£",
    starving: "ÐÐ»Ð¼Ð¸ ÑÐ¾Ð²ÑÐµÐ¼ Ð¾ÑÐ»Ð°Ð±. ÐžÑ‚ÐºÑ€Ð¾Ð¹ Almost Ð¸ Ð½Ð°ÐºÐ¾Ñ€Ð¼Ð¸ ÐµÐ³Ð¾ ÑÐºÐ¾Ñ€ÐµÐµ. ðŸ˜¿ðŸ«¶",
  },
  en: {
    low: "Almi is hungry - drop in and feed him. ðŸ˜ºðŸ¥£",
    starving: "Almi is starving. Open Almost and give him a snack. ðŸ˜¿ðŸ«¶",
  },
};

const normalizeTamagotchiStateValue = (value, fallback = TAMAGOTCHI_MAX_STATE_VALUE) =>
  Math.min(
    TAMAGOTCHI_MAX_STATE_VALUE,
    Math.max(0, Number.isFinite(Number(value)) ? Number(value) : fallback)
  );

const computeTamagotchiDecay = (state = TAMAGOTCHI_START_STATE, timestamp = Date.now()) => {
  const source = state || {};
  const now = Number.isFinite(timestamp) ? timestamp : Date.now();
  const lastStored = source.lastDecayAt;
  let last =
    typeof lastStored === "number" && Number.isFinite(lastStored)
      ? lastStored
      : Number(lastStored) || now;
  if (last > now) {
    last = now;
  }
  const hunger = Math.min(TAMAGOTCHI_MAX_HUNGER, Math.max(0, Number(source.hunger) || 0));
  const mood = normalizeTamagotchiStateValue(source.mood, TAMAGOTCHI_START_STATE.mood);
  const cleanliness = normalizeTamagotchiStateValue(
    source.cleanliness,
    TAMAGOTCHI_START_STATE.cleanliness
  );
  const cleanToolSupplies = normalizeTamagotchiToolSupplies(source.cleanToolSupplies);
  const coins = Math.max(0, Math.floor(Number(source.coins) || 0));
  const coinTick = Math.max(0, Number(source.coinTick) || 0);
  const immunityUntil = Math.max(0, Number(source.hungerImmunityUntil) || 0);
  const decayBaseAt = immunityUntil > last ? immunityUntil : last;
  const elapsed = Math.max(0, now - decayBaseAt);
  const ticks = Math.floor(elapsed / TAMAGOTCHI_DECAY_INTERVAL_MS);
  const noTickLastDecayAt = decayBaseAt > now ? now : decayBaseAt;
  if (ticks <= 0) {
    return {
      state: {
        ...source,
        hunger,
        mood: Math.round(mood),
        cleanliness: Math.round(cleanliness),
        coins,
        coinTick,
        lastDecayAt: noTickLastDecayAt,
        desiredFoodId: source?.desiredFoodId || TAMAGOTCHI_DEFAULT_FOOD_ID,
        desiredToyId:
          source?.desiredToyId || resolveNextTamagotchiToyId(mood, source?.desiredToyId, false),
        cleanToolSupplies,
        hungerImmunityUntil: immunityUntil > now ? immunityUntil : 0,
      },
      burnedCoins: 0,
    };
  }
  const hungerTicks = ticks;
  const hungerDrop = hungerTicks * TAMAGOTCHI_DECAY_STEP;
  const nextHunger = Math.max(0, hunger - hungerDrop);
  const cleanlinessDropBase = ticks * TAMAGOTCHI_DECAY_CLEANLINESS_STEP;
  const cleanlinessPenalty = nextHunger < TAMAGOTCHI_HUNGER_LOW_THRESHOLD ? ticks * 0.18 : 0;
  const nextCleanliness = Math.max(0, cleanliness - cleanlinessDropBase - cleanlinessPenalty);
  const moodPenaltyFromHunger =
    Math.max(0, TAMAGOTCHI_DECAY_MOOD_HUNGER_PENALTY_THRESHOLD - nextHunger) * 0.022 * ticks;
  const moodPenaltyFromClean =
    Math.max(0, TAMAGOTCHI_DECAY_MOOD_CLEAN_PENALTY_THRESHOLD - nextCleanliness) * 0.02 * ticks;
  const moodDrop = ticks * TAMAGOTCHI_DECAY_MOOD_STEP + moodPenaltyFromHunger + moodPenaltyFromClean;
  const nextMood = Math.max(0, mood - moodDrop);
  const totalTicks = coinTick + ticks;
  const nextCoinTick = totalTicks % TAMAGOTCHI_COIN_DECAY_TICKS;
  const decayDuration = ticks * TAMAGOTCHI_DECAY_INTERVAL_MS;
  const hungerDelta = hunger - nextHunger;
  const tierChanged = resolveTamagotchiFoodTier(nextHunger) !== resolveTamagotchiFoodTier(hunger);
  const shouldRefreshCraving =
    !source?.desiredFoodId || tierChanged || hungerDelta >= TAMAGOTCHI_DECAY_STEP * 3;
  const desiredFoodId = shouldRefreshCraving
    ? resolveNextTamagotchiFoodId(nextHunger, source?.desiredFoodId, hungerDelta > 0)
    : source.desiredFoodId;
  const moodDelta = mood - nextMood;
  const toyTierChanged = resolveTamagotchiToyTier(nextMood) !== resolveTamagotchiToyTier(mood);
  const shouldRefreshToy =
    !source?.desiredToyId || toyTierChanged || moodDelta >= TAMAGOTCHI_DECAY_MOOD_STEP * 3;
  const desiredToyId = shouldRefreshToy
    ? resolveNextTamagotchiToyId(nextMood, source?.desiredToyId, moodDelta > 0)
    : source.desiredToyId;
  return {
    state: {
      ...source,
      hunger: Math.round(nextHunger),
      mood: Math.round(nextMood),
      cleanliness: Math.round(nextCleanliness),
      coins,
      lastDecayAt: decayBaseAt + decayDuration,
      coinTick: nextCoinTick,
      desiredFoodId: desiredFoodId || TAMAGOTCHI_DEFAULT_FOOD_ID,
      desiredToyId: desiredToyId || TAMAGOTCHI_DEFAULT_TOY_ID,
      cleanToolSupplies,
      hungerImmunityUntil: immunityUntil > now ? immunityUntil : 0,
    },
    burnedCoins: 0,
  };
};

const getTamagotchiMood = (state = TAMAGOTCHI_START_STATE, language = DEFAULT_LANGUAGE) => {
  const hunger = Math.min(TAMAGOTCHI_MAX_HUNGER, Math.max(0, Number(state?.hunger) || 0));
  const mood = normalizeTamagotchiStateValue(state?.mood, TAMAGOTCHI_START_STATE.mood);
  const cleanliness = normalizeTamagotchiStateValue(
    state?.cleanliness,
    TAMAGOTCHI_START_STATE.cleanliness
  );
  const texts = {
	    ru: {
	      happy: "Ð² Ð¾Ñ‚Ð»Ð¸Ñ‡Ð½Ð¾Ð¹ Ñ„Ð¾Ñ€Ð¼Ðµ",
	      calm: "Ð±Ð¾Ð´Ñ€Ñ‹Ð¹, Ð½Ð¾ Ñ‚Ñ€ÐµÐ±ÑƒÐµÑ‚ Ð²Ð½Ð¸Ð¼Ð°Ð½Ð¸Ñ",
	      sad: "Ð³Ñ€ÑƒÑÑ‚Ð¸Ñ‚ Ð¸ Ð·Ð¾Ð²Ñ‘Ñ‚ Ð¿Ð¾Ð¸Ð³Ñ€Ð°Ñ‚ÑŒ",
	      urgent: "ÑÑ€Ð¾Ñ‡Ð½Ð¾ Ð¿Ñ€Ð¾ÑÐ¸Ñ‚ Ð¾ Ð¿Ð¾Ð¼Ð¾Ñ‰Ð¸!",
	      needPlay: "Ñ…Ð¾Ñ‡ÐµÑ‚ Ð¸Ð³Ñ€Ð°Ñ‚ÑŒ",
	      needClean: "Ð¸ÑÐ¿Ð°Ñ‡ÐºÐ°Ð»ÑÑ, Ð½ÑƒÐ¶Ð½Ð° Ñ‡Ð¸ÑÑ‚ÐºÐ°",
	      needFood: "Ð¿Ñ€Ð¾Ð³Ð¾Ð»Ð¾Ð´Ð°Ð»ÑÑ",
	    },
	    en: {
	      happy: "feels great",
	      calm: "is okay but needs attention",
	      sad: "is sad and wants to play",
	      urgent: "needs urgent care!",
	      needPlay: "wants to play",
	      needClean: "got dirty and needs cleaning",
	      needFood: "is hungry",
	    },
	    es: {
	      happy: "estÃ¡ genial",
	      calm: "estÃ¡ bien pero necesita atenciÃ³n",
	      sad: "estÃ¡ triste y quiere jugar",
	      urgent: "Â¡necesita ayuda urgente!",
	      needPlay: "quiere jugar",
	      needClean: "estÃ¡ sucio y necesita limpieza",
	      needFood: "tiene hambre",
	    },
	    fr: {
	      happy: "est en pleine forme",
	      calm: "va bien mais demande de l'attention",
	      sad: "est triste et veut jouer",
	      urgent: "a besoin d'aide immÃ©diatement !",
	      needPlay: "veut jouer",
	      needClean: "est sale et veut Ãªtre lavÃ©",
	      needFood: "a faim",
	    },
	  };
  const dict = texts[language] || texts.ru;
  const hungerPressure = Math.max(0, 100 - hunger);
  const playPressure = Math.max(0, 100 - mood);
  const cleanPressure = Math.max(0, 100 - cleanliness);
  let need = "none";
  let topPressure = hungerPressure;
  if (playPressure > topPressure) {
    topPressure = playPressure;
    need = "play";
  }
  if (cleanPressure > topPressure) {
    topPressure = cleanPressure;
    need = "clean";
  }
  if (need === "none" && hungerPressure >= 35) {
    need = "food";
  }
  let tone = "happy";
  if (topPressure >= 72 || hunger <= 20) {
    tone = "urgent";
  } else if (topPressure >= 50 || mood <= TAMAGOTCHI_LOW_MOOD_THRESHOLD) {
    tone = "sad";
  } else if (topPressure >= 28) {
    tone = "calm";
  }
  const label =
    need === "play"
      ? dict.needPlay
      : need === "clean"
      ? dict.needClean
      : need === "food"
      ? dict.needFood
      : tone === "urgent"
      ? dict.urgent
      : tone === "sad"
      ? dict.sad
      : tone === "calm"
      ? dict.calm
      : dict.happy;
  return {
    label,
    tone,
    need,
    hunger,
    mood,
    cleanliness,
  };
};

function AlmiTamagotchi({
  override,
  onOverrideComplete,
  style,
  isStarving = false,
  isPlayDeprived = false,
  desaturation = 0,
  animations = CLASSIC_TAMAGOTCHI_ANIMATIONS,
}) {
  const [currentKey, setCurrentKey] = useState("idle");
  const idleTimerRef = useRef(null);
  const overrideTimerRef = useRef(null);
  const normalizedDesaturation = Math.max(0, Math.min(1, Number(desaturation) || 0));
  const idleVariants = useMemo(
    () =>
      isPlayDeprived
        ? TAMAGOTCHI_PLAY_DEPRIVED_VARIANTS
        : isStarving
        ? TAMAGOTCHI_STARVING_VARIANTS
        : TAMAGOTCHI_IDLE_VARIANTS,
    [isPlayDeprived, isStarving]
  );
  const resolveNextIdleKey = useCallback(() => {
    const pool = idleVariants.length ? idleVariants : TAMAGOTCHI_IDLE_VARIANTS;
    const index = Math.floor(Math.random() * pool.length);
    return pool[index] || "idle";
  }, [idleVariants]);

  const scheduleIdleCycle = useCallback(
    (delay = 4500) => {
      if (idleTimerRef.current) clearTimeout(idleTimerRef.current);
      idleTimerRef.current = setTimeout(() => {
        const next = resolveNextIdleKey();
        setCurrentKey(next);
        scheduleIdleCycle(5000 + Math.random() * 3000);
      }, delay);
    },
    [resolveNextIdleKey]
  );

  useEffect(() => {
    scheduleIdleCycle(2200);
    return () => {
      if (idleTimerRef.current) clearTimeout(idleTimerRef.current);
      if (overrideTimerRef.current) clearTimeout(overrideTimerRef.current);
    };
  }, [scheduleIdleCycle]);

  useEffect(() => {
    if (!override) return;
    if (idleTimerRef.current) clearTimeout(idleTimerRef.current);
    if (overrideTimerRef.current) clearTimeout(overrideTimerRef.current);
    const key = animations[override.type] ? override.type : "happy";
    setCurrentKey(key);
    overrideTimerRef.current = setTimeout(() => {
      onOverrideComplete?.();
      scheduleIdleCycle(2500);
    }, override.duration || 3200);
  }, [animations, override?.key, override?.type, override?.duration, onOverrideComplete, scheduleIdleCycle]);

  const source = animations[currentKey] || animations.idle;
  return (
    <View style={[styles.almiMascotWrap, style]}>
      <Image
        source={source}
        defaultSource={animations.idle}
        style={[
          styles.almiMascotImage,
          normalizedDesaturation > 0 && { opacity: 1 - normalizedDesaturation * 0.35 },
        ]}
        resizeMode="contain"
        fadeDuration={0}
      />
    </View>
  );
}
const MAX_IMPULSE_EVENTS = 180;
const MIN_IMPULSE_EVENTS_FOR_MAP = 4;
const IMPULSE_SEQUENCE_WINDOW_MS = 12 * 60 * 60 * 1000;
const IMPULSE_SEQUENCE_MAX_FOLLOWUPS = 4;
const IMPULSE_SEQUENCE_MIN_HITS = 2;
const IMPULSE_SEQUENCE_MIN_WEIGHT = 2;
const IMPULSE_SEQUENCE_TOP_INSIGHTS = 2;
const IMPULSE_SEQUENCE_RECENCY_DAYS = 21;
const IMPULSE_ALERT_COOLDOWN_MS = 1000 * 60 * 45;
const BASE_IMPULSE_CATEGORY_DEFS = {
  food: { id: "food", ru: "Ð•Ð´Ð°", en: "Food", es: "Comida", fr: "Nourriture", emoji: "ðŸœ" },
  rent: { id: "rent", ru: "ÐÑ€ÐµÐ½Ð´Ð° Ð¶Ð¸Ð»ÑŒÑ", en: "Rent", es: "Alquiler", fr: "Loyer", emoji: "ðŸ¡" },
  utilities: { id: "utilities", ru: "ÐšÐ¾Ð¼Ð¼ÑƒÐ½Ð°Ð»ÑŒÐ½Ñ‹Ðµ", en: "Utilities", es: "Servicios", fr: "Charges", emoji: "ðŸ’¡" },
  car: { id: "car", ru: "ÐœÐ°ÑˆÐ¸Ð½Ð°", en: "Car", es: "Auto", fr: "Voiture", emoji: "ðŸš—" },
  mandatory: {
    id: "mandatory",
    ru: "ÐžÐ±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ð¿Ð»Ð°Ñ‚ÐµÐ¶Ð¸",
    en: "Mandatory payments",
    es: "Pagos obligatorios",
    fr: "Paiements obligatoires",
    emoji: "ðŸ§¾",
  },
  home: { id: "home", ru: "Ð”Ð¾Ð¼", en: "Home", es: "Hogar", fr: "Maison", emoji: "ðŸ " },
  transport: { id: "transport", ru: "Ð¢Ñ€Ð°Ð½ÑÐ¿Ð¾Ñ€Ñ‚", en: "Transport", es: "Transporte", fr: "Transport", emoji: "ðŸš‡" },
  health: { id: "health", ru: "Ð—Ð´Ð¾Ñ€Ð¾Ð²ÑŒÐµ", en: "Health", es: "Salud", fr: "SantÃ©", emoji: "ðŸ’Š" },
  beauty: { id: "beauty", ru: "Ð‘ÑŒÑŽÑ‚Ð¸", en: "Beauty", es: "Belleza", fr: "BeautÃ©", emoji: "ðŸ’…" },
  fun: {
    id: "fun",
    ru: "Ð Ð°Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð¸Ñ",
    en: "Entertainment",
    es: "DiversiÃ³n",
    fr: "Divertissement",
    emoji: "ðŸŽ‰",
  },
  things: { id: "things", ru: "ÐŸÐ¾ÐºÑƒÐ¿ÐºÐ¸", en: "Shopping", es: "Compras", fr: "Achats", emoji: "ðŸ›ï¸" },
  clothing: { id: "clothing", ru: "ÐžÐ´ÐµÐ¶Ð´Ð°", en: "Clothing", es: "Ropa", fr: "VÃªtements", emoji: "ðŸ‘•" },
  education: { id: "education", ru: "ÐžÐ±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ", en: "Education", es: "EducaciÃ³n", fr: "Ã‰ducation", emoji: "ðŸŽ“" },
  pets: { id: "pets", ru: "ÐŸÐ¸Ñ‚Ð¾Ð¼Ñ†Ñ‹", en: "Pets", es: "Mascotas", fr: "Animaux", emoji: "ðŸ¾" },
  subscriptions: {
    id: "subscriptions",
    ru: "ÐŸÐ¾Ð´Ð¿Ð¸ÑÐºÐ¸",
    en: "Subscriptions",
    es: "Suscripciones",
    fr: "Abonnements",
    emoji: "ðŸ”",
  },
  vices: {
    id: "vices",
    ru: "Ð¡Ð»Ð°Ð±Ð¾ÑÑ‚Ð¸",
    en: "Small vices",
    es: "PequeÃ±os vicios",
    fr: "Petits vices",
    emoji: "âš¡ï¸",
  },
};
const IMPULSE_CATEGORY_DEFS = { ...BASE_IMPULSE_CATEGORY_DEFS };
const IMPULSE_CATEGORY_ORDER = [
  "food",
  "rent",
  "utilities",
  "car",
  "mandatory",
  "home",
  "transport",
  "health",
  "beauty",
  "fun",
  "things",
  "clothing",
  "education",
  "pets",
  "subscriptions",
  "vices",
];
const DEFAULT_IMPULSE_CATEGORY = "vices";
const INITIAL_IMPULSE_TRACKER = {
  events: [],
  lastAlerts: {},
};

const DEFAULT_INCOME_PAYDAY = 1;
const INCOME_PROMPT_GRACE_DAYS = 4;
const INCOME_SAVINGS_SHARE = 0.15;
const BUDGET_BAR_MAX_HEIGHT = IS_SHORT_DEVICE ? 150 : 180;
const BUDGET_WIDGET_CARD_GAP = 10;
const BUDGET_MIN_REMAINING_RATE = 0.06;
const BUDGET_MAX_SAVINGS_RATE = 0.4;
const BUDGET_MIN_SAVINGS_RATE = 0.08;
const BUDGET_DEFAULT_SAVINGS_RATE = 0.18;
const MAX_INCOME_ENTRIES = 24;
const BUDGET_SPEECH_LOW_THRESHOLD = 0.2;
const BUDGET_CARD_LOW_THRESHOLD = BUDGET_SPEECH_LOW_THRESHOLD;
const BUDGET_SPEECH_ESSENTIAL_IDS = new Set(["rent", "utilities", "mandatory", "car"]);
const isEssentialImpulseCategory = (id) =>
  typeof id === "string" && BUDGET_SPEECH_ESSENTIAL_IDS.has(id);

const DEFAULT_SAVINGS_CATEGORY_DEF = {
  id: "savings",
  ru: "Ð¡Ð±ÐµÑ€ÐµÐ¶ÐµÐ½Ð¸Ñ",
  en: "Savings",
  es: "Ahorros",
  fr: "Ã‰pargne",
  emoji: "ðŸ’Ž",
};
const BUDGET_SPECIAL_CATEGORY_DEFS = {
  savings: { ...DEFAULT_SAVINGS_CATEGORY_DEF },
};
const BUDGET_DEFAULT_FLEX_WEIGHT = 0.08;
const BUDGET_CATEGORY_META = {
  savings: { group: "savings" },
  rent: { group: "essential", baseWeight: 0.25 },
  utilities: { group: "essential", baseWeight: 0.08 },
  car: { group: "essential", baseWeight: 0.06 },
  mandatory: { group: "essential", baseWeight: 0.08 },
  food: { group: "essential", baseWeight: 0.12 },
  transport: { group: "essential", baseWeight: 0.06 },
  health: { group: "flex", fallbackWeight: 0.1 },
  subscriptions: { group: "flex", fallbackWeight: 0.08 },
  home: { group: "flex", fallbackWeight: 0.08 },
  fun: { group: "flex", fallbackWeight: 0.12 },
  things: { group: "flex", fallbackWeight: 0.14 },
  beauty: { group: "flex", fallbackWeight: 0.08 },
  clothing: { group: "flex", fallbackWeight: 0.08 },
  education: { group: "flex", fallbackWeight: 0.08 },
  pets: { group: "flex", fallbackWeight: 0.08 },
  vices: { group: "flex", fallbackWeight: 0.08 },
};

const getBudgetCategoryOrder = () => {
  const order = ["savings", ...IMPULSE_CATEGORY_ORDER];
  return Array.from(new Set(order));
};

const getBudgetCategoryMeta = (id) => {
  if (BUDGET_CATEGORY_META[id]) return BUDGET_CATEGORY_META[id];
  if (id === "savings") return { group: "savings" };
  return { group: "flex", fallbackWeight: BUDGET_DEFAULT_FLEX_WEIGHT };
};

const getBudgetCategoryLabel = (id, language = DEFAULT_LANGUAGE) => {
  if (id === "savings") {
    const entry = BUDGET_SPECIAL_CATEGORY_DEFS.savings;
    const key = getShortLanguageKey(language);
    return entry[key] || entry.en || entry.ru || id;
  }
  return getImpulseCategoryName(id, language);
};

const getBudgetCategoryEmoji = (id) => {
  if (id === "savings") return BUDGET_SPECIAL_CATEGORY_DEFS.savings?.emoji || "ðŸ’Ž";
  return IMPULSE_CATEGORY_DEFS[id]?.emoji || "âœ¨";
};

const getMonthKey = (value = Date.now()) => {
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return "";
  const year = date.getFullYear();
  const month = `${date.getMonth() + 1}`.padStart(2, "0");
  return `${year}-${month}`;
};

const parseMonthKey = (key) => {
  if (typeof key !== "string" || key.trim().length === 0) return null;
  const [yearStr, monthStr] = key.split("-");
  const year = Number(yearStr);
  const month = Number(monthStr);
  if (!year || !month) return null;
  const date = new Date(year, month - 1, 1);
  if (Number.isNaN(date.getTime())) return null;
  date.setHours(0, 0, 0, 0);
  return date;
};

const getMonthLabel = (value = Date.now(), locale = "en-US") => {
  try {
    const date = new Date(value);
    return date.toLocaleDateString(locale, { month: "long", year: "numeric" });
  } catch {
    return "";
  }
};

const getMonthLabelForKey = (monthKey, locale = "en-US") => {
  const parsed = parseMonthKey(monthKey);
  if (!parsed) return "";
  return getMonthLabel(parsed, locale);
};

const INCOME_ENTRY_TYPES = {
  MONTHLY: "monthly",
  EXTRA: "extra",
};

const normalizeIncomeEntryType = (value) =>
  value === INCOME_ENTRY_TYPES.EXTRA ? INCOME_ENTRY_TYPES.EXTRA : INCOME_ENTRY_TYPES.MONTHLY;

const normalizeIncomeEntry = (entry) => {
  if (!entry || typeof entry !== "object") return null;
  const amountUSD = Math.max(0, Number(entry.amountUSD) || 0);
  if (!Number.isFinite(amountUSD) || amountUSD <= 0) return null;
  const receivedAt = Number(entry.receivedAt) || Date.now();
  if (!Number.isFinite(receivedAt)) return null;
  const id =
    typeof entry.id === "string" && entry.id.trim()
      ? entry.id
      : `income_${receivedAt}_${Math.random().toString(16).slice(2, 8)}`;
  const entryType = normalizeIncomeEntryType(entry.entryType);
  return {
    id,
    amountUSD,
    receivedAt,
    createdAt: Number(entry.createdAt) || receivedAt,
    note: typeof entry.note === "string" ? entry.note : "",
    entryType,
  };
};

const normalizeIncomeEntries = (list) => {
  const entries = Array.isArray(list) ? list : [];
  const normalized = entries.map(normalizeIncomeEntry).filter(Boolean);
  normalized.sort((a, b) => (b.receivedAt || 0) - (a.receivedAt || 0));
  return normalized;
};

const getIncomeForMonth = (entries, monthKey, options = {}) => {
  if (!monthKey) return 0;
  const entryTypeFilter = options?.entryType;
  return (Array.isArray(entries) ? entries : []).reduce((sum, entry) => {
    if (!entry?.receivedAt) return sum;
    if (getMonthKey(entry.receivedAt) !== monthKey) return sum;
    if (
      entryTypeFilter &&
      normalizeIncomeEntryType(entry?.entryType) !== entryTypeFilter
    ) {
      return sum;
    }
    return sum + Math.max(0, Number(entry.amountUSD) || 0);
  }, 0);
};

const getRecurringIncomeForMonth = (entries, monthKey) => {
  if (!monthKey) return 0;
  let latestMonthlyEntry = null;
  (Array.isArray(entries) ? entries : []).forEach((entry) => {
    const entryType = normalizeIncomeEntryType(entry?.entryType);
    if (entryType !== INCOME_ENTRY_TYPES.MONTHLY) return;
    const entryMonthKey = getMonthKey(entry?.receivedAt);
    if (!entryMonthKey || entryMonthKey > monthKey) return;
    const receivedAt = Number(entry?.receivedAt) || 0;
    if (!latestMonthlyEntry || receivedAt >= (Number(latestMonthlyEntry?.receivedAt) || 0)) {
      latestMonthlyEntry = entry;
    }
  });
  return Math.max(0, Number(latestMonthlyEntry?.amountUSD) || 0);
};

const getExtraIncomeForMonth = (entries, monthKey) =>
  getIncomeForMonth(entries, monthKey, { entryType: INCOME_ENTRY_TYPES.EXTRA });

const getBudgetIncomeForMonth = (entries, monthKey) =>
  getRecurringIncomeForMonth(entries, monthKey) + getExtraIncomeForMonth(entries, monthKey);

const getNextMonthKey = (monthKey) => {
  const parsed = parseMonthKey(monthKey);
  if (!parsed) return "";
  parsed.setMonth(parsed.getMonth() + 1);
  return getMonthKey(parsed.getTime());
};

const collectBudgetMonthKeys = (incomeEntries = [], historyEvents = [], currentMonthKey = "") => {
  const keys = new Set();
  if (currentMonthKey) {
    keys.add(currentMonthKey);
  }
  let earliestRecurringMonthKey = "";
  (Array.isArray(incomeEntries) ? incomeEntries : []).forEach((entry) => {
    const monthKey = getMonthKey(entry?.receivedAt);
    if (!monthKey) return;
    keys.add(monthKey);
    const entryType = normalizeIncomeEntryType(entry?.entryType);
    if (entryType === INCOME_ENTRY_TYPES.MONTHLY) {
      if (!earliestRecurringMonthKey || monthKey < earliestRecurringMonthKey) {
        earliestRecurringMonthKey = monthKey;
      }
    }
  });
  (Array.isArray(historyEvents) ? historyEvents : []).forEach((entry) => {
    const timestamp = Number(entry?.timestamp) || 0;
    if (!timestamp) return;
    const monthKey = getMonthKey(timestamp);
    if (monthKey) {
      keys.add(monthKey);
    }
  });
  let latestMonthKey = "";
  keys.forEach((key) => {
    if (!latestMonthKey || key > latestMonthKey) {
      latestMonthKey = key;
    }
  });
  if (
    earliestRecurringMonthKey &&
    latestMonthKey &&
    earliestRecurringMonthKey <= latestMonthKey
  ) {
    let cursor = earliestRecurringMonthKey;
    let guard = 0;
    while (cursor && cursor <= latestMonthKey && guard < 240) {
      keys.add(cursor);
      cursor = getNextMonthKey(cursor);
      guard += 1;
    }
  }
  const list = Array.from(keys).filter(Boolean);
  list.sort((a, b) => (a < b ? 1 : -1));
  return list;
};

const clampNumber = (value, min = 0, max = 1) => Math.min(Math.max(value, min), max);

const deriveSavingStyle = (decisionStats = {}) => {
  const totalDecisions =
    (decisionStats?.resolvedToDeclines || 0) + (decisionStats?.resolvedToWishes || 0);
  if (!totalDecisions) return "balanced";
  const declineShare = (decisionStats?.resolvedToDeclines || 0) / totalDecisions;
  if (declineShare >= 0.7) return "aggressive";
  if (declineShare <= 0.4) return "relaxed";
  return "balanced";
};

const computeSavingsRate = ({ decisionStats, baselineMonthlyWasteUSD = 0, incomeUSD = 0 }) => {
  if (!incomeUSD) return BUDGET_DEFAULT_SAVINGS_RATE;
  const savingStyle = deriveSavingStyle(decisionStats);
  const baseRate =
    savingStyle === "aggressive"
      ? 0.26
      : savingStyle === "relaxed"
      ? 0.12
      : BUDGET_DEFAULT_SAVINGS_RATE;
  const wasteRatio = clampNumber((Number(baselineMonthlyWasteUSD) || 0) / Math.max(incomeUSD, 1), 0, 1);
  const wasteBoost = clampNumber(wasteRatio * 0.35, 0, 0.12);
  return clampNumber(baseRate + wasteBoost, BUDGET_MIN_SAVINGS_RATE, BUDGET_MAX_SAVINGS_RATE);
};

const normalizeBudgetOverrides = (value) => {
  if (!value || typeof value !== "object") return {};
  const next = {};
  Object.entries(value).forEach(([key, raw]) => {
    const normalized = Number(raw);
    if (!Number.isFinite(normalized) || normalized < 0) return;
    next[key] = normalized;
  });
  return next;
};

const buildBudgetPlan = ({
  incomeUSD = 0,
  carryoverUSD = 0,
  budgetOverrides = {},
  spendDistribution = {},
  spendToDateByCategory = {},
  spendToDateTotalUSD = 0,
  decisionStats = {},
  baselineMonthlyWasteUSD = 0,
  language = DEFAULT_LANGUAGE,
  monthKey = "",
  autoAllocationEnabled = true,
}) => {
  const normalizedIncome = Math.max(0, Number(incomeUSD) || 0);
  const normalizedCarryover = Number.isFinite(carryoverUSD) ? carryoverUSD : 0;
  const locale = getFormatLocale(language);
  const resolvedMonthLabel = monthKey ? getMonthLabelForKey(monthKey, locale) : "";
  const monthLabel = resolvedMonthLabel || getMonthLabel(Date.now(), locale);
  const safeOverrides = normalizeBudgetOverrides(budgetOverrides);
  const budgetOrder = getBudgetCategoryOrder();
  const essentialIds = budgetOrder.filter((id) => getBudgetCategoryMeta(id).group === "essential");
  const flexIds = budgetOrder.filter((id) => getBudgetCategoryMeta(id).group === "flex");
  const essentialWeightSum = essentialIds.reduce(
    (sum, id) => sum + (Number(getBudgetCategoryMeta(id).baseWeight) || 0),
    0
  );
  let savingsRate = computeSavingsRate({ decisionStats, baselineMonthlyWasteUSD, incomeUSD: normalizedIncome });
  let remainingRate = 1 - savingsRate - essentialWeightSum;
  if (remainingRate < BUDGET_MIN_REMAINING_RATE) {
    const deficit = BUDGET_MIN_REMAINING_RATE - remainingRate;
    savingsRate = clampNumber(savingsRate - deficit, BUDGET_MIN_SAVINGS_RATE, BUDGET_MAX_SAVINGS_RATE);
    remainingRate = 1 - savingsRate - essentialWeightSum;
  }
  let essentialScale = 1;
  if (remainingRate < 0 && essentialWeightSum > 0) {
    essentialScale = clampNumber((1 - savingsRate) / essentialWeightSum, 0, 1);
    remainingRate = 0;
  }
  const flexSpendTotal = flexIds.reduce(
    (sum, id) => sum + (Number(spendDistribution[id]) || 0),
    0
  );
  const flexFallbackTotal = flexIds.reduce(
    (sum, id) => sum + (Number(getBudgetCategoryMeta(id).fallbackWeight) || BUDGET_DEFAULT_FLEX_WEIGHT),
    0
  );
  const flexWeights = flexIds.reduce((acc, id) => {
    const fallback = Number(getBudgetCategoryMeta(id).fallbackWeight) || BUDGET_DEFAULT_FLEX_WEIGHT;
    const fallbackShare = flexFallbackTotal > 0 ? fallback / flexFallbackTotal : 1 / Math.max(flexIds.length, 1);
    const spendShare = flexSpendTotal > 0 ? (Number(spendDistribution[id]) || 0) / flexSpendTotal : 0;
    const weight = flexSpendTotal > 0 ? 0.6 * spendShare + 0.4 * fallbackShare : fallbackShare;
    acc[id] = weight;
    return acc;
  }, {});
  const categories = budgetOrder.map((id) => {
    const def = id === "savings" ? BUDGET_SPECIAL_CATEGORY_DEFS.savings : IMPULSE_CATEGORY_DEFS[id];
    if (!def) return null;
    const meta = getBudgetCategoryMeta(id);
    const group = meta.group || "flex";
    let rate = 0;
    if (autoAllocationEnabled) {
      if (group === "savings") {
        rate = savingsRate;
      } else if (group === "essential") {
        rate = (Number(meta.baseWeight) || 0) * essentialScale;
      } else {
        rate = remainingRate * (flexWeights[id] || 0);
      }
    }
    let limitUSD = autoAllocationEnabled && normalizedIncome > 0 ? normalizedIncome * rate : 0;
    let isOverride = false;
    if (Number.isFinite(safeOverrides[id])) {
      limitUSD = Math.max(0, safeOverrides[id]);
      isOverride = true;
    }
    return {
      id,
      label: getBudgetCategoryLabel(id, language),
      emoji: getBudgetCategoryEmoji(id),
      group,
      rate,
      limitUSD,
      isOverride,
      spentUSD: Math.max(0, Number(spendToDateByCategory?.[id]) || 0),
    };
  }).filter(Boolean);
  const allocatedTotalUSD = categories.reduce((sum, entry) => sum + (entry.limitUSD || 0), 0);
  const totalSpentUSD = Number.isFinite(spendToDateTotalUSD)
    ? Math.max(0, spendToDateTotalUSD)
    : categories.reduce((sum, entry) => sum + (entry.spentUSD || 0), 0);
  const remainingUSD = normalizedIncome + normalizedCarryover - totalSpentUSD;
  return {
    monthLabel,
    incomeUSD: normalizedIncome,
    carryoverUSD: normalizedCarryover,
    savingsRate,
    autoAllocationEnabled: !!autoAllocationEnabled,
    allocatedTotalUSD,
    totalSpentUSD,
    remainingUSD,
    categories,
  };
};

const padHour = (value) => value.toString().padStart(2, "0");
const formatImpulseWindowLabel = (hour, span = 2) => {
  if (!Number.isInteger(hour)) return null;
  const start = padHour(hour);
  const end = padHour((hour + span) % 24);
  return `${start}:00-${end}:00`;
};
const IMPULSE_DELAY_UNITS = {
  ru: { hour: "Ñ‡", minute: "Ð¼Ð¸Ð½" },
  en: { hour: "h", minute: "m" },
  es: { hour: "h", minute: "min" },
  fr: { hour: "h", minute: "min" },
};
const IMPULSE_REMINDER_MIN_DELAY_MS = 5 * 60 * 1000;
const formatImpulseDelayLabel = (minutes, language = DEFAULT_LANGUAGE) => {
  if (!Number.isFinite(minutes) || minutes <= 0) return null;
  const normalizedLanguage = normalizeLanguage(language);
  const units = IMPULSE_DELAY_UNITS[normalizedLanguage] || IMPULSE_DELAY_UNITS[DEFAULT_LANGUAGE];
  const totalMinutes = Math.max(1, Math.round(minutes));
  const hours = Math.floor(totalMinutes / 60);
  const mins = totalMinutes % 60;
  const parts = [];
  if (hours > 0) {
    parts.push(`${hours}${units.hour}`);
  }
  if (mins > 0) {
    parts.push(`${mins}${units.minute}`);
  }
  if (!parts.length) {
    parts.push(`1${units.minute}`);
  }
  return parts.join(" ");
};
const getImpulseReminderTimestamp = (timestamp) => {
  if (!Number.isFinite(timestamp)) return null;
  const base = new Date(timestamp);
  const reminder = new Date(base);
  reminder.setDate(base.getDate() + 1);
  const reminderHour = Math.max(0, base.getHours() - 1);
  reminder.setHours(reminderHour, base.getMinutes(), 0, 0);
  return reminder.getTime();
};

const resolveImpulseCategory = (item = {}) => {
  const override = typeof item?.impulseCategoryOverride === "string" ? item.impulseCategoryOverride : null;
  if (override && IMPULSE_CATEGORY_DEFS[override]) {
    return override;
  }
  const categories = Array.isArray(item.categories)
    ? item.categories.map((entry) => (entry || "").toLowerCase())
    : [];
  const price = Number(item.priceUSD ?? item.basePriceUSD ?? 0) || 0;
  const matches = (...keys) => categories.some((cat) => keys.includes(cat));
  if (matches("food", "groceries", "meal", "dining", "snack", "coffee", "tea")) return "food";
  if (matches("rent", "lease")) return "rent";
  if (matches("utility", "utilities", "electric", "water", "gas", "internet", "phone", "bill", "bills")) return "utilities";
  if (matches("car", "auto", "vehicle", "parking", "fuel", "gasoline", "maintenance", "service")) return "car";
  if (matches("tax", "taxes", "loan", "debt", "insurance", "fee", "fees")) return "mandatory";
  if (matches("transport", "ride", "taxi", "uber", "bus", "metro", "train", "commute")) return "transport";
  if (matches("home", "decor", "furniture", "appliance")) return "home";
  if (matches("health", "fitness", "gym", "doctor", "medicine", "wellness")) return "health";
  if (matches("beauty", "cosmetic", "cosmetics", "skincare", "makeup", "salon", "spa", "grooming")) return "beauty";
  if (matches("subscription", "subscriptions", "software", "streaming", "membership", "plan")) return "subscriptions";
  if (matches("travel", "wow", "game", "gaming", "fun", "experience", "movie", "concert", "event")) return "fun";
  if (matches("clothing", "apparel", "fashion", "style", "shoe", "shoes", "sneaker", "sneakers")) return "clothing";
  if (matches("tech", "phone", "wearable", "flagship", "gadget", "electronics")) return "things";
  if (matches("education", "course", "study", "learning", "school", "university", "tuition")) return "education";
  if (matches("pet", "pets", "animal", "vet", "veterinary")) return "pets";
  if (matches("lifestyle", "custom", "gift") && price <= 60) return "vices";
  if (price <= 18) return "vices";
  if (price <= 90) return "food";
  if (price <= 250) return "things";
  return "fun";
};

const normalizeImpulseCategoryId = (value) => {
  if (!value || typeof value !== "string") return DEFAULT_IMPULSE_CATEGORY;
  const normalized = value.trim().toLowerCase();
  if (!normalized) return DEFAULT_IMPULSE_CATEGORY;
  if (IMPULSE_CATEGORY_DEFS[normalized]) return normalized;
  if (["subscription", "subscriptions", "plan", "membership"].includes(normalized)) {
    return "subscriptions";
  }
  if (["entertainment", "fun", "experience", "movie", "gaming", "game", "event", "travel", "dream", "wow"].includes(normalized)) {
    return "fun";
  }
  if (["rent", "lease"].includes(normalized)) {
    return "rent";
  }
  if (["utility", "utilities", "electric", "water", "gas", "internet", "phone", "bill", "bills"].includes(normalized)) {
    return "utilities";
  }
  if (["car", "auto", "vehicle", "parking", "fuel", "gasoline", "maintenance", "service"].includes(normalized)) {
    return "car";
  }
  if (["mandatory", "tax", "taxes", "loan", "debt", "insurance", "fee", "fees"].includes(normalized)) {
    return "mandatory";
  }
  if (["coffee", "food", "groceries", "meal", "dining", "snack", "tea"].includes(normalized)) {
    return "food";
  }
  if (["home", "decor", "furniture", "appliance"].includes(normalized)) {
    return "home";
  }
  if (["transport", "ride", "taxi", "uber", "bus", "metro", "train", "commute", "car"].includes(normalized)) {
    return "transport";
  }
  if (["health", "fitness", "gym", "doctor", "medicine", "wellness"].includes(normalized)) {
    return "health";
  }
  if (["beauty", "cosmetic", "cosmetics", "skincare", "makeup", "salon", "spa", "grooming"].includes(normalized)) {
    return "beauty";
  }
  if (["clothing", "apparel", "fashion", "style", "shoe", "shoes", "sneaker", "sneakers"].includes(normalized)) {
    return "clothing";
  }
  if (["education", "course", "study", "learning", "school", "university", "tuition"].includes(normalized)) {
    return "education";
  }
  if (["pet", "pets", "animal", "vet", "veterinary"].includes(normalized)) {
    return "pets";
  }
  if (["tech", "phone", "wearable", "sport", "flagship", "gadget", "gift", "shopping", "things", "electronics"].includes(normalized)) {
    return "things";
  }
  if (["lifestyle", "custom", "vices", "vice"].includes(normalized)) {
    return "vices";
  }
  return DEFAULT_IMPULSE_CATEGORY;
};

const slugifyCategoryName = (value = "") =>
  value
    .toString()
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "_")
    .replace(/^_+|_+$/g, "");

const ensureUniqueCategoryId = (baseId) => {
  if (!baseId) return `custom_${Date.now()}`;
  if (!IMPULSE_CATEGORY_DEFS[baseId]) return baseId;
  let suffix = 2;
  let nextId = `${baseId}_${suffix}`;
  while (IMPULSE_CATEGORY_DEFS[nextId]) {
    suffix += 1;
    nextId = `${baseId}_${suffix}`;
  }
  return nextId;
};

const removeCategoryFromRuntime = (categoryId) => {
  if (!categoryId || categoryId === "savings") return;
  if (IMPULSE_CATEGORY_DEFS[categoryId]) {
    delete IMPULSE_CATEGORY_DEFS[categoryId];
  }
  const index = IMPULSE_CATEGORY_ORDER.indexOf(categoryId);
  if (index >= 0) {
    IMPULSE_CATEGORY_ORDER.splice(index, 1);
  }
};

const applyRemovedCategories = (list = []) => {
  const normalized = Array.isArray(list) ? list : [];
  normalized.forEach((id) => removeCategoryFromRuntime(id));
  return normalized.filter((id) => id && id !== "savings");
};

const registerCustomCategory = (entry) => {
  if (!entry || typeof entry !== "object") return null;
  const baseId = slugifyCategoryName(entry.id || entry.en || entry.ru || entry.es || entry.fr || "");
  const id = ensureUniqueCategoryId(baseId);
  if (!id) return null;
  const normalized = {
    id,
    ru: entry.ru || entry.en || entry.es || entry.fr || "ÐšÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ",
    en: entry.en || entry.ru || entry.es || entry.fr || "Category",
    es: entry.es || entry.en || entry.ru || entry.fr || "Categoria",
    fr: entry.fr || entry.en || entry.ru || entry.es || "Categorie",
    emoji: entry.emoji || "âœ¨",
    custom: true,
  };
  IMPULSE_CATEGORY_DEFS[id] = normalized;
  if (!IMPULSE_CATEGORY_ORDER.includes(id)) {
    IMPULSE_CATEGORY_ORDER.push(id);
  }
  return normalized;
};

const resolveGoalTypeFromTarget = (targetUSD = 0) => {
  if (!Number.isFinite(targetUSD)) return "short_term";
  return targetUSD >= 1000 ? "long_term" : "short_term";
};

const isCustomTemptation = (item = null) => {
  if (!item) return false;
  const categories = Array.isArray(item.categories) ? item.categories : [];
  if (categories.includes("custom")) return true;
  if (typeof item.id === "string") {
    return item.id.startsWith("custom_") || item.id.startsWith("custom");
  }
  return false;
};

const buildImpulseInsights = (events = []) => {
  if (!Array.isArray(events) || !events.length) {
    const categories = IMPULSE_CATEGORY_ORDER.reduce((acc, id) => {
      acc[id] = { save: 0, spend: 0 };
      return acc;
    }, {});
    return {
      categories,
      hotLose: null,
      hotWin: null,
      activeRisk: null,
      hottestSpendCategory: null,
      eventCount: 0,
      sequenceInsights: [],
      sequenceHotspots: { slip: null, rebound: null },
    };
  }
  const categories = IMPULSE_CATEGORY_ORDER.reduce((acc, id) => {
    acc[id] = { save: 0, spend: 0 };
    return acc;
  }, {});
  const templateStats = new Map();
  let processedEvents = 0;
  let totalSaves = 0;
  let totalSpends = 0;
  const chronologicalEvents = [];
  events.forEach((event) => {
    if (!event || !event.templateId) return;
    if (Number.isFinite(event.timestamp)) {
      chronologicalEvents.push(event);
    }
    processedEvents += 1;
    const category = normalizeImpulseCategoryId(event.category);
    if (!categories[category]) {
      categories[category] = { save: 0, spend: 0 };
    }
    if (event.action === "save") {
      categories[category].save += 1;
      totalSaves += 1;
    } else if (event.action === "spend") {
      categories[category].spend += 1;
      totalSpends += 1;
    }
    const stat =
      templateStats.get(event.templateId) || {
        templateId: event.templateId,
        title: event.title,
        emoji: event.emoji,
        category,
        saveCount: 0,
        spendCount: 0,
        saveHours: Array(24).fill(0),
        spendHours: Array(24).fill(0),
        lastAmountUSD: event.amountUSD || 0,
      };
    if (event.action === "save") {
      stat.saveCount += 1;
      if (Number.isInteger(event.hour)) {
        stat.saveHours[event.hour] = (stat.saveHours[event.hour] || 0) + 1;
      }
    } else if (event.action === "spend") {
      stat.spendCount += 1;
      if (Number.isInteger(event.hour)) {
        stat.spendHours[event.hour] = (stat.spendHours[event.hour] || 0) + 1;
      }
      stat.lastAmountUSD = event.amountUSD || stat.lastAmountUSD;
    }
    templateStats.set(event.templateId, stat);
  });
  chronologicalEvents.sort((a, b) => {
    const tsA = Number(a.timestamp) || 0;
    const tsB = Number(b.timestamp) || 0;
    return tsA - tsB;
  });
  const sequenceStats = new Map();
  const sequenceEvents = chronologicalEvents.filter(
    (event) =>
      event &&
      event.templateId &&
      event.action &&
      Number.isFinite(event.timestamp)
  );
  const nowTimestamp = Date.now();
  const cleanSequenceTitle = (value) => {
    const stripped = stripEmojis(value || "");
    return stripped || value || "";
  };
  const addSequenceStat = (from, to, delayMs) => {
    if (!from || !to) return;
    const key = `${from.templateId}->${to.templateId}:${from.action}->${to.action}`;
    const weight =
      1 +
      Math.max(0, 1 - delayMs / IMPULSE_SEQUENCE_WINDOW_MS) * 0.4;
    const stat =
      sequenceStats.get(key) || {
        fromTemplateId: from.templateId,
        toTemplateId: to.templateId,
        fromTitle: cleanSequenceTitle(from.title),
        toTitle: cleanSequenceTitle(to.title),
        fromAction: from.action,
        toAction: to.action,
        count: 0,
        weightedCount: 0,
        lastTimestamp: 0,
        totalDelayMs: 0,
        toHours: Array(24).fill(0),
      };
    stat.count += 1;
    stat.weightedCount += weight;
    stat.totalDelayMs += delayMs;
    stat.lastTimestamp = Math.max(stat.lastTimestamp || 0, to.timestamp || 0);
    const hour =
      Number.isInteger(to.hour) ? to.hour : Number.isFinite(to.timestamp) ? new Date(to.timestamp).getHours() : null;
    if (Number.isInteger(hour)) {
      stat.toHours[hour] = (stat.toHours[hour] || 0) + 1;
    }
    sequenceStats.set(key, stat);
  };
  for (let i = 0; i < sequenceEvents.length; i += 1) {
    const from = sequenceEvents[i];
    let followups = 0;
    for (let j = i + 1; j < sequenceEvents.length; j += 1) {
      const to = sequenceEvents[j];
      const delay = (to.timestamp || 0) - (from.timestamp || 0);
      if (delay <= 0) continue;
      if (delay > IMPULSE_SEQUENCE_WINDOW_MS) break;
      if (!to.templateId || !to.action) continue;
      if (from.templateId === to.templateId) continue;
      addSequenceStat(from, to, delay);
      followups += 1;
      if (followups >= IMPULSE_SEQUENCE_MAX_FOLLOWUPS) break;
    }
  }
  const scoreSequence = (stat) => {
    if (!stat) return 0;
    const recencyDays = Number.isFinite(stat.lastTimestamp)
      ? (nowTimestamp - stat.lastTimestamp) / DAY_MS
      : Number.POSITIVE_INFINITY;
    const recencyBoost =
      Number.isFinite(recencyDays) && recencyDays >= 0
        ? Math.max(0, 1 - recencyDays / IMPULSE_SEQUENCE_RECENCY_DAYS) * 0.35
        : 0;
    return (stat.weightedCount || 0) + recencyBoost;
  };
  const sequenceCandidates = Array.from(sequenceStats.values()).filter((stat) => {
    if (!stat) return false;
    if ((stat.count || 0) < IMPULSE_SEQUENCE_MIN_HITS) return false;
    if ((stat.weightedCount || 0) < IMPULSE_SEQUENCE_MIN_WEIGHT) return false;
    return true;
  });
  const pickSequence = (predicate) => {
    let best = null;
    sequenceCandidates.forEach((stat) => {
      if (predicate && !predicate(stat)) return;
      const score = scoreSequence(stat);
      if (!best || score > best.score) {
        best = { ...stat, score };
        return;
      }
      if (score === best.score) {
        if ((stat.count || 0) > (best.count || 0)) {
          best = { ...stat, score };
          return;
        }
        if (
          (stat.count || 0) === (best.count || 0) &&
          (stat.lastTimestamp || 0) > (best.lastTimestamp || 0)
        ) {
          best = { ...stat, score };
        }
      }
    });
    return best;
  };
  const slipSequence = pickSequence(
    (stat) => stat.fromAction === "spend" && stat.toAction === "spend"
  );
  const reboundSequence = pickSequence(
    (stat) => stat.fromAction === "save" && stat.toAction === "save"
  );
  const makeSequencePayload = (stat) => {
    if (!stat) return null;
    return {
      fromTemplateId: stat.fromTemplateId,
      toTemplateId: stat.toTemplateId,
      fromTitle: stat.fromTitle,
      toTitle: stat.toTitle,
      fromAction: stat.fromAction,
      toAction: stat.toAction,
      count: stat.count,
      windowLabel: selectHotHour(stat.toHours || []).label || null,
    };
  };
  const selectHotHour = (hours = []) => {
    let chosen = null;
    let best = 0;
    hours.forEach((value, hour) => {
      if (value > best) {
        best = value;
        chosen = hour;
      }
    });
    return {
      hour: Number.isInteger(chosen) ? chosen : null,
      count: best,
      label: Number.isInteger(chosen) ? formatImpulseWindowLabel(chosen) : null,
    };
  };
  const sequenceInsights = sequenceCandidates
    .map((stat) => ({ ...stat, score: scoreSequence(stat) }))
    .sort((a, b) => {
      if (b.score !== a.score) return b.score - a.score;
      if ((b.count || 0) !== (a.count || 0)) return (b.count || 0) - (a.count || 0);
      return (b.lastTimestamp || 0) - (a.lastTimestamp || 0);
    })
    .slice(0, IMPULSE_SEQUENCE_TOP_INSIGHTS)
    .map((stat) => ({
      key: `${stat.fromTemplateId}-${stat.toTemplateId}-${stat.fromAction}-${stat.toAction}`,
      fromTitle: stat.fromTitle,
      toTitle: stat.toTitle,
      fromAction: stat.fromAction,
      toAction: stat.toAction,
      count: stat.count,
      windowLabel: selectHotHour(stat.toHours || []).label || null,
    }));
  let hotLose = null;
  let hotWin = null;
  templateStats.forEach((stat) => {
    const total = stat.saveCount + stat.spendCount;
    if (!total) return;
    const loseRate = stat.spendCount / total;
    if (stat.spendCount >= 1 && loseRate >= 0.5) {
      if (
        !hotLose ||
        total > hotLose.totalInteractions ||
        (total === hotLose.totalInteractions && stat.spendCount > hotLose.spendCount) ||
        (total === hotLose.totalInteractions &&
          stat.spendCount === hotLose.spendCount &&
          loseRate > hotLose.lossRate)
      ) {
        hotLose = {
          ...stat,
          totalInteractions: total,
          lossRate: loseRate,
          hotspot: selectHotHour(stat.spendHours),
        };
      }
    }
    const winRate = stat.saveCount / total;
    if (stat.saveCount >= 1 && winRate >= 0.5) {
      if (
        !hotWin ||
        total > hotWin.totalInteractions ||
        (total === hotWin.totalInteractions && stat.saveCount > hotWin.saveCount) ||
        (total === hotWin.totalInteractions &&
          stat.saveCount === hotWin.saveCount &&
          winRate > hotWin.winRate)
      ) {
        hotWin = {
          ...stat,
          totalInteractions: total,
          winRate,
          hotspot: selectHotHour(stat.saveHours),
        };
      }
    }
  });
  const nowHour = new Date().getHours();
  let activeRisk = null;
  templateStats.forEach((stat) => {
    const spendHits = stat.spendHours[nowHour] || 0;
    if (spendHits < 2) return;
    const saveHits = stat.saveHours[nowHour] || 0;
    if (saveHits >= spendHits) return;
    const total = stat.saveCount + stat.spendCount;
    if (!total) return;
    const lossRate = stat.spendCount / total;
    if (lossRate < 0.6) return;
    if (!activeRisk || spendHits > activeRisk.spendHits) {
      activeRisk = {
        templateId: stat.templateId,
        title: stat.title,
        emoji: stat.emoji,
        category: stat.category,
        spendHits,
        hour: nowHour,
        windowLabel: formatImpulseWindowLabel(nowHour),
        amountUSD: stat.lastAmountUSD,
      };
    }
  });
  const hottestSpendCategory = IMPULSE_CATEGORY_ORDER.reduce((best, id) => {
    const entry = categories[id] || { save: 0, spend: 0 };
    const spendCount = entry.spend || 0;
    const saveCount = entry.save || 0;
    const interactions = spendCount + saveCount;
    if (spendCount === 0) {
      return best;
    }
    if (
      !best ||
      spendCount > best.spendCount ||
      (spendCount === best.spendCount && interactions > (best.interactions || 0))
    ) {
      return { id, spendCount, interactions, saveCount };
    }
    return best;
  }, null);
  return {
    categories,
    hotLose: hotLose
      ? {
          templateId: hotLose.templateId,
          title: hotLose.title,
          emoji: hotLose.emoji,
          category: hotLose.category,
          count: hotLose.spendCount,
          rate: hotLose.lossRate,
          windowLabel: hotLose.hotspot?.label || null,
        }
      : null,
    hotWin: hotWin
      ? {
          templateId: hotWin.templateId,
          title: hotWin.title,
          emoji: hotWin.emoji,
          category: hotWin.category,
          count: hotWin.saveCount,
          rate: hotWin.winRate,
          windowLabel: hotWin.hotspot?.label || null,
        }
      : null,
    activeRisk,
    hottestSpendCategory,
    eventCount: processedEvents,
    totalSaveCount: totalSaves,
    totalSpendCount: totalSpends,
    sequenceInsights,
    sequenceHotspots: {
      slip: makeSequencePayload(slipSequence),
      rebound: makeSequencePayload(reboundSequence),
    },
  };
};

const renderTemplateString = (template, params = {}) => {
  if (!template || typeof template !== "string") return "";
  return template.replace(/\{\{(\w+)\}\}/g, (_, key) =>
    params[key] !== undefined && params[key] !== null ? String(params[key]) : ""
  );
};

const SwipeableChallengeCard = ({
  children,
  colors,
  cancelLabel,
  onCancel,
  onSwipeOpen,
  onSwipeClose,
}) => {
  const translateX = useRef(new Animated.Value(0)).current;
  const ACTION_WIDTH = CHALLENGE_SWIPE_ACTION_WIDTH;
  const gestureStartOffset = useRef(0);
  const closerRef = useRef(null);
  const isOpenRef = useRef(false);

  const closeRow = useCallback(
    (notify = true) => {
      isOpenRef.current = false;
      Animated.timing(translateX, {
        toValue: 0,
        duration: 150,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }).start(() => {
        if (notify) {
          onSwipeClose?.(closerRef.current);
          closerRef.current = null;
        }
      });
    },
    [onSwipeClose, translateX]
  );

  const openRow = useCallback(() => {
    isOpenRef.current = true;
    Animated.timing(translateX, {
      toValue: -ACTION_WIDTH,
      duration: 180,
      easing: Easing.out(Easing.quad),
      useNativeDriver: true,
    }).start(() => {
      const closer = () => closeRow();
      closerRef.current = closer;
      onSwipeOpen?.(closer);
    });
  }, [ACTION_WIDTH, closeRow, onSwipeOpen, translateX]);

  useEffect(() => {
    return () => {
      translateX.stopAnimation();
      translateX.setValue(0);
      if (closerRef.current) {
        onSwipeClose?.(closerRef.current);
        closerRef.current = null;
      }
    };
  }, [onSwipeClose, translateX]);

  const panResponder = useMemo(
    () =>
      PanResponder.create({
        onMoveShouldSetPanResponder: (_, gestureState) =>
          Math.abs(gestureState.dx) > Math.abs(gestureState.dy) && Math.abs(gestureState.dx) > 8,
        onMoveShouldSetPanResponderCapture: (_, gestureState) =>
          Math.abs(gestureState.dx) > Math.abs(gestureState.dy) && Math.abs(gestureState.dx) > 8,
        onPanResponderTerminationRequest: () => false,
        onPanResponderGrant: () => {
          translateX.stopAnimation((value) => {
            gestureStartOffset.current = value;
          });
        },
        onPanResponderMove: (_, gestureState) => {
          const base = gestureStartOffset.current || 0;
          const next = Math.max(-ACTION_WIDTH, Math.min(base + gestureState.dx, 0));
          translateX.setValue(next);
        },
        onPanResponderRelease: (_, gestureState) => {
          translateX.stopAnimation((value) => {
            const fastLeft = gestureState.vx < -0.5;
            const fastRight = gestureState.vx > 0.5;
            const shouldOpen = fastLeft || value < -ACTION_WIDTH * 0.45;
            const shouldClose = fastRight || value > -ACTION_WIDTH * 0.45;
            if (shouldOpen) {
              openRow();
              return;
            }
            if (shouldClose) {
              closeRow();
              return;
            }
            if (isOpenRef.current) {
              openRow();
            } else {
              closeRow();
            }
          });
        },
        onPanResponderTerminate: () => {
          closeRow();
        },
      }),
    [ACTION_WIDTH, closeRow, openRow, translateX]
  );

  return (
    <View style={styles.challengeSwipeWrapper}>
      <View style={[styles.challengeSwipeActions, { backgroundColor: SPEND_ACTION_COLOR }]}>
        <TouchableOpacity
          style={[styles.challengeSwipeButton, { backgroundColor: SPEND_ACTION_COLOR }]}
          onPress={() => {
            closeRow();
            onCancel?.();
          }}
          activeOpacity={0.85}
        >
          <Text style={[styles.challengeSwipeButtonText, { color: colors.background }]}>{cancelLabel}</Text>
        </TouchableOpacity>
      </View>
      <Animated.View style={{ transform: [{ translateX }] }} {...panResponder.panHandlers}>
        {children}
      </Animated.View>
    </View>
  );
};

const getMoodPreset = (moodId = MOOD_IDS.NEUTRAL, language = DEFAULT_LANGUAGE) => {
  const preset = MOOD_PRESETS[moodId] || MOOD_PRESETS[MOOD_IDS.NEUTRAL];
  const localize = (value) => {
    if (!value) return "";
    if (typeof value === "string") return value;
    return value[language] || value.en || "";
  };
  return {
    id: preset.id || moodId,
    label: localize(preset.label),
    hero: localize(preset.hero),
    heroComplete: localize(preset.heroComplete),
    motivation: localize(preset.motivation),
    saveOverlay: localize(preset.saveOverlay),
    impulseOverlay: localize(preset.impulseOverlay),
    pushPendingTitle: localize(preset.pushPendingTitle),
    pushPendingBody: localize(preset.pushPendingBody),
    pushImpulseTitle: localize(preset.pushImpulseTitle),
    pushImpulseBody: localize(preset.pushImpulseBody),
  };
};

const getLatestEventTimestamp = (events = [], type) => {
  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];
    if (event?.type === type && event.timestamp) {
      return event.timestamp;
    }
  }
  return null;
};

const evaluateMoodState = (state = createMoodStateForToday(), context = {}) => {
  const now = context.now || Date.now();
  const pendingCount =
    context.pendingCount !== undefined ? context.pendingCount : state.pendingSnapshot || 0;
  const filteredEvents = (state.events || []).filter(
    (event) => now - (event.timestamp || 0) <= MOOD_ACTION_WINDOW_MS
  );
  const counts = filteredEvents.reduce(
    (acc, event) => {
      if (event?.type && acc[event.type] !== undefined) {
        acc[event.type] += 1;
      }
      return acc;
    },
    { save: 0, spend: 0, maybe: 0, dream: 0 }
  );
  let nextMood = state.current || MOOD_IDS.NEUTRAL;
  const lastInteraction = state.lastInteractionAt || state.lastVisitAt || 0;
  if (lastInteraction && now - lastInteraction >= MOOD_INACTIVITY_THRESHOLD_MS) {
    nextMood = MOOD_IDS.TIRED;
  } else {
    const candidates = [];
    if (counts.spend >= MOOD_EVENT_THRESHOLD) {
      const timestamp = getLatestEventTimestamp(filteredEvents, "spend");
      if (timestamp) candidates.push({ mood: MOOD_IDS.IMPULSIVE, timestamp });
    }
    if (counts.save >= MOOD_EVENT_THRESHOLD) {
      const timestamp = getLatestEventTimestamp(filteredEvents, "save");
      if (timestamp) candidates.push({ mood: MOOD_IDS.FOCUSED, timestamp });
    }
    if (counts.maybe >= MOOD_EVENT_THRESHOLD) {
      const timestamp = getLatestEventTimestamp(filteredEvents, "maybe");
      if (timestamp) candidates.push({ mood: MOOD_IDS.DOUBTER, timestamp });
    }
    if (counts.dream >= MOOD_DREAM_WISH_THRESHOLD) {
      const timestamp = getLatestEventTimestamp(filteredEvents, "dream");
      if (timestamp) candidates.push({ mood: MOOD_IDS.DREAMER, timestamp });
    }
    if (pendingCount >= MOOD_PENDING_THRESHOLD) {
      candidates.push({ mood: MOOD_IDS.DREAMER, timestamp: now });
    }
    if (candidates.length) {
      candidates.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
      nextMood = candidates[0].mood;
    } else {
      nextMood = MOOD_IDS.NEUTRAL;
    }
  }
  return {
    ...state,
    current: nextMood,
    events: filteredEvents,
    pendingSnapshot: pendingCount,
  };
};

const mapHistoryEventsToMoodEvents = (history = [], now = Date.now()) =>
  history
    .filter((entry) => entry?.timestamp && now - entry.timestamp <= MOOD_ACTION_WINDOW_MS)
    .map((entry) => {
      if (entry.kind === "refuse_spend") return { type: "save", timestamp: entry.timestamp };
      if (entry.kind === "spend") return { type: "spend", timestamp: entry.timestamp };
      if (entry.kind === "pending_added") return { type: "maybe", timestamp: entry.timestamp };
      if (entry.kind === "wish_added") return { type: "dream", timestamp: entry.timestamp };
      return null;
    })
    .filter(Boolean)
    .slice(0, MOOD_MAX_EVENTS);

const WEEKDAY_LABELS = {
  ru: ["Ð’Ñ", "ÐŸÐ½", "Ð’Ñ‚", "Ð¡Ñ€", "Ð§Ñ‚", "ÐŸÑ‚", "Ð¡Ð±"],
  en: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  es: ["Dom", "Lun", "Mar", "MiÃ©", "Jue", "Vie", "SÃ¡b"],
  fr: ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"],
};
const WEEKDAY_LABELS_MONDAY_FIRST = {
  ru: ["ÐŸÐ½", "Ð’Ñ‚", "Ð¡Ñ€", "Ð§Ñ‚", "ÐŸÑ‚", "Ð¡Ð±", "Ð’Ñ"],
  en: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
  es: ["Lun", "Mar", "MiÃ©", "Jue", "Vie", "SÃ¡b", "Dom"],
  fr: ["Lun", "Mar", "Mer", "Jeu", "Ven", "Sam", "Dim"],
};
const PENDING_DAY_SUFFIX = { ru: "Ð´", en: "d", es: "d", fr: "j" };

const buildSavingsBreakdown = (
  history = [],
  currency = DEFAULT_PROFILE.currency,
  resolveTemplateTitle,
  language = DEFAULT_LANGUAGE,
  { range = "day", offset = 0 } = {}
) => {
  const resolveTemplate = (template, params = {}) => {
    if (!template) return "";
    return template.replace(/\{\{(\w+)\}\}/g, (match, key) =>
      Object.prototype.hasOwnProperty.call(params, key) ? params[key] : match
    );
  };
  const locale = getFormatLocale(language);
  const defaultDeclineTitle = resolveTranslationValueForLanguage(language, "defaultDeclineLabel") || "Skip";
  const incomeSavingsLabel =
    resolveTranslationValueForLanguage(language, "incomeEntryVisualSavings") ||
    resolveTranslationValueForLanguage(language, "budgetSavingsLabel") ||
    "Savings";
  const otherLabel = resolveTranslationValueForLanguage(language, "savingsBreakdownOtherLabel") || "Other";
  const dayLabels = WEEKDAY_LABELS[language] || WEEKDAY_LABELS.en;
  const palette = ["#3E8EED", "#F6A23D", "#8F7CF6", "#2EB873", "#E15555", "#FFC857"];
  const totalsByTitle = {};
  const buckets = [];
  const now = new Date();
  const startOfDay = (date) => {
    const next = new Date(date);
    next.setHours(0, 0, 0, 0);
    return next;
  };
  const getWeekStart = (date) => {
    const next = startOfDay(date);
    const weekday = (next.getDay() + 6) % 7;
    next.setDate(next.getDate() - weekday);
    return next;
  };
  const addMonths = (date, delta) => new Date(date.getFullYear(), date.getMonth() + delta, 1);
  const formatMonthLabel = (date) => {
    const raw = date.toLocaleDateString(locale, { month: "short" }).replace(".", "").trim();
    if (!raw) return "";
    return raw[0].toUpperCase() + raw.slice(1);
  };
  const formatWeekRangeLabel = (startDate, endDate) => {
    const startMonth = formatMonthLabel(startDate);
    const endMonth = formatMonthLabel(endDate);
    const startDay = startDate.getDate();
    const endDay = endDate.getDate();
    if (startMonth === endMonth) {
      return `${startMonth}${startDay}-${endDay}`;
    }
    return `${startMonth}${startDay}-${endMonth}${endDay}`;
  };
  const addBucket = (label, startMs, endMs, divisor = 1) => {
    const stacks = {};
    (Array.isArray(history) ? history : []).forEach((entry) => {
      if (!isStatsSaveEvent(entry?.kind)) return;
      const timestamp = Number(entry.timestamp) || 0;
      if (!timestamp || timestamp < startMs || timestamp >= endMs) return;
      const isIncomeSavings = entry?.kind === "income_savings";
      const resolvedTitle = isIncomeSavings
        ? incomeSavingsLabel
        : (resolveTemplateTitle &&
            resolveTemplateTitle(entry.meta?.templateId, entry.meta?.title || entry.title)) ||
          null;
      const baseTitle =
        (resolvedTitle ||
          entry.meta?.title ||
          entry.title ||
          entry.meta?.templateId ||
          entry.emoji ||
          entry.id ||
          defaultDeclineTitle)
          .toString()
          .slice(0, 42);
      const stripped = stripEmojis(baseTitle);
      const title = (stripped || baseTitle || defaultDeclineTitle).trim();
      const amount = Math.max(0, Number(entry.meta?.amountUSD) || 0) / divisor;
      stacks[title] = (stacks[title] || 0) + amount;
      totalsByTitle[title] = (totalsByTitle[title] || 0) + amount;
    });
    const total = Object.values(stacks).reduce((sum, v) => sum + v, 0);
    buckets.push({ label, stacks, total });
  };

  let rangeCount = 0;
  let isAverage = false;
  if (range === "week") {
    rangeCount = 4;
    const baseEnd = new Date(getWeekStart(now).getTime() + DAY_MS * 7);
    const windowEnd = new Date(baseEnd.getTime() - offset * rangeCount * DAY_MS * 7);
    const windowStart = new Date(windowEnd.getTime() - rangeCount * DAY_MS * 7);
    Array.from({ length: rangeCount }).forEach((_, index) => {
      const weekStart = new Date(windowStart.getTime() + index * DAY_MS * 7);
      const weekEnd = new Date(weekStart.getTime() + DAY_MS * 7);
      const label = formatWeekRangeLabel(weekStart, new Date(weekEnd.getTime() - DAY_MS));
      addBucket(label, weekStart.getTime(), weekEnd.getTime(), 1);
    });
  } else if (range === "month") {
    rangeCount = 12;
    const baseEnd = addMonths(addMonths(now, 0), 1);
    const windowEnd = addMonths(baseEnd, -offset * rangeCount);
    const windowStart = addMonths(windowEnd, -rangeCount);
    Array.from({ length: rangeCount }).forEach((_, index) => {
      const monthStart = addMonths(windowStart, index);
      const monthEnd = addMonths(monthStart, 1);
      addBucket(formatMonthLabel(monthStart), monthStart.getTime(), monthEnd.getTime(), 1);
    });
  } else {
    rangeCount = 7;
    const baseEnd = new Date(startOfDay(now).getTime() + DAY_MS);
    const windowEnd = new Date(baseEnd.getTime() - offset * rangeCount * DAY_MS);
    const windowStart = new Date(windowEnd.getTime() - rangeCount * DAY_MS);
    Array.from({ length: rangeCount }).forEach((_, index) => {
      const dayStart = new Date(windowStart.getTime() + index * DAY_MS);
      const dayEnd = new Date(dayStart.getTime() + DAY_MS);
      const label = dayLabels[dayStart.getDay()] || "";
      addBucket(label, dayStart.getTime(), dayEnd.getTime(), 1);
    });
  }

  const sortedTitles = Object.entries(totalsByTitle)
    .sort((a, b) => b[1] - a[1])
    .map(([title]) => title);
  const topTitles = sortedTitles.slice(0, 5);
  const colorMap = {};
  topTitles.forEach((title, idx) => {
    colorMap[title] = palette[idx % palette.length];
  });
  const otherColor = "#F6C16B";
  const normalizedBuckets = buckets.map((bucket) => {
    const stacksArray = [];
    const otherSum = Object.entries(bucket.stacks).reduce((acc, [title, value]) => {
      if (colorMap[title]) {
        stacksArray.push({ title, value, color: colorMap[title] });
        return acc;
      }
      return acc + value;
    }, 0);
    if (otherSum > 0) {
      stacksArray.push({ title: otherLabel, value: otherSum, color: otherColor });
    }
    return { label: bucket.label, total: bucket.total, stacks: stacksArray };
  });
  const grandTotal = Object.values(totalsByTitle).reduce((sum, v) => sum + v, 0) || 1;
  const legend = topTitles.map((title, idx) => ({
    id: title,
    label: title,
    value: totalsByTitle[title],
    percent: Math.round((totalsByTitle[title] / grandTotal) * 100),
    color: palette[idx % palette.length],
  }));
  const otherTotal = grandTotal - legend.reduce((sum, item) => sum + item.value, 0);
  if (otherTotal > 0) {
    legend.push({
      id: "other",
      label: otherLabel,
      value: otherTotal,
      percent: Math.max(1, Math.round((otherTotal / grandTotal) * 100)),
      color: otherColor,
    });
  }
  const formatLocal = (usd) => formatCurrency(convertToCurrency(usd || 0, currency), currency);
  const rangeTitleKey =
    range === "week" ? "spendStatsRangeWeeks" : range === "month" ? "spendStatsRangeMonths" : "spendStatsRangeDays";
  const rangeTitleTemplate =
    resolveTranslationValueForLanguage(language, rangeTitleKey) || "Last {{count}}";
  const rangeTitle = resolveTemplate(rangeTitleTemplate, { count: rangeCount });
  const averageLabel =
    isAverage && (resolveTranslationValueForLanguage(language, "spendStatsAverageLabel") || "Daily average");
  return {
    buckets: normalizedBuckets,
    legend,
    formatLocal,
    rangeCount,
    rangeTitle,
    averageLabel: averageLabel || "",
  };
};

const buildSpendingBreakdown = (
  history = [],
  currency = DEFAULT_PROFILE.currency,
  resolveTemplateTitle,
  language = DEFAULT_LANGUAGE,
  { range = "day", offset = 0 } = {}
) => {
  const resolveTemplate = (template, params = {}) => {
    if (!template) return "";
    return template.replace(/\{\{(\w+)\}\}/g, (match, key) =>
      Object.prototype.hasOwnProperty.call(params, key) ? params[key] : match
    );
  };
  const locale = getFormatLocale(language);
  const defaultSpendTitle = resolveTranslationValueForLanguage(language, "defaultSpendLabel") || "Spend";
  const otherLabel = resolveTranslationValueForLanguage(language, "savingsBreakdownOtherLabel") || "Other";
  const dayLabels = WEEKDAY_LABELS[language] || WEEKDAY_LABELS.en;
  const palette = ["#E15555", "#F6A23D", "#8F7CF6", "#3E8EED", "#2EB873", "#FFC857"];
  const spendEntries = Array.isArray(history)
    ? history.filter((entry) => entry?.kind === "spend" && entry?.timestamp)
    : [];
  const totalsByTitle = {};
  const buckets = [];
  const now = new Date();
  const startOfDay = (date) => {
    const next = new Date(date);
    next.setHours(0, 0, 0, 0);
    return next;
  };
  const getWeekStart = (date) => {
    const next = startOfDay(date);
    const weekday = (next.getDay() + 6) % 7;
    next.setDate(next.getDate() - weekday);
    return next;
  };
  const addMonths = (date, delta) => new Date(date.getFullYear(), date.getMonth() + delta, 1);
  const formatMonthLabel = (date) => {
    const raw = date.toLocaleDateString(locale, { month: "short" }).replace(".", "").trim();
    if (!raw) return "";
    return raw[0].toUpperCase() + raw.slice(1);
  };
  const formatWeekRangeLabel = (startDate, endDate) => {
    const startMonth = formatMonthLabel(startDate);
    const endMonth = formatMonthLabel(endDate);
    const startDay = startDate.getDate();
    const endDay = endDate.getDate();
    if (startMonth === endMonth) {
      return `${startMonth}${startDay}-${endDay}`;
    }
    return `${startMonth}${startDay}-${endMonth}${endDay}`;
  };
  const addBucket = (label, startMs, endMs, divisor = 1) => {
    const stacks = {};
    spendEntries.forEach((entry) => {
      const timestamp = Number(entry.timestamp) || 0;
      if (!timestamp || timestamp < startMs || timestamp >= endMs) return;
      const resolvedTitle =
        (resolveTemplateTitle &&
          resolveTemplateTitle(entry.meta?.templateId, entry.meta?.title || entry.title)) ||
        null;
      const baseTitle =
        (resolvedTitle ||
          entry.meta?.title ||
          entry.title ||
          entry.meta?.templateId ||
          entry.emoji ||
          entry.id ||
          defaultSpendTitle)
          .toString()
          .slice(0, 42);
      const stripped = stripEmojis(baseTitle);
      const title = (stripped || baseTitle || defaultSpendTitle).trim();
      const amount = Math.max(0, Number(entry.meta?.amountUSD) || 0) / divisor;
      stacks[title] = (stacks[title] || 0) + amount;
      totalsByTitle[title] = (totalsByTitle[title] || 0) + amount;
    });
    const total = Object.values(stacks).reduce((sum, v) => sum + v, 0);
    buckets.push({ label, stacks, total });
  };

  let rangeCount = 0;
  let isAverage = false;
  if (range === "week") {
    rangeCount = 4;
    const baseEnd = new Date(getWeekStart(now).getTime() + DAY_MS * 7);
    const windowEnd = new Date(baseEnd.getTime() - offset * rangeCount * DAY_MS * 7);
    const windowStart = new Date(windowEnd.getTime() - rangeCount * DAY_MS * 7);
    Array.from({ length: rangeCount }).forEach((_, index) => {
      const weekStart = new Date(windowStart.getTime() + index * DAY_MS * 7);
      const weekEnd = new Date(weekStart.getTime() + DAY_MS * 7);
      const label = formatWeekRangeLabel(weekStart, new Date(weekEnd.getTime() - DAY_MS));
      addBucket(label, weekStart.getTime(), weekEnd.getTime(), 1);
    });
  } else if (range === "month") {
    rangeCount = 12;
    const baseEnd = addMonths(addMonths(now, 0), 1);
    const windowEnd = addMonths(baseEnd, -offset * rangeCount);
    const windowStart = addMonths(windowEnd, -rangeCount);
    Array.from({ length: rangeCount }).forEach((_, index) => {
      const monthStart = addMonths(windowStart, index);
      const monthEnd = addMonths(monthStart, 1);
      addBucket(formatMonthLabel(monthStart), monthStart.getTime(), monthEnd.getTime(), 1);
    });
  } else {
    rangeCount = 7;
    const baseEnd = new Date(startOfDay(now).getTime() + DAY_MS);
    const windowEnd = new Date(baseEnd.getTime() - offset * rangeCount * DAY_MS);
    const windowStart = new Date(windowEnd.getTime() - rangeCount * DAY_MS);
    Array.from({ length: rangeCount }).forEach((_, index) => {
      const dayStart = new Date(windowStart.getTime() + index * DAY_MS);
      const dayEnd = new Date(dayStart.getTime() + DAY_MS);
      const label = dayLabels[dayStart.getDay()] || "";
      addBucket(label, dayStart.getTime(), dayEnd.getTime(), 1);
    });
  }

  const sortedTitles = Object.entries(totalsByTitle)
    .sort((a, b) => b[1] - a[1])
    .map(([title]) => title);
  const topTitles = sortedTitles.slice(0, 5);
  const colorMap = {};
  topTitles.forEach((title, idx) => {
    colorMap[title] = palette[idx % palette.length];
  });
  const otherColor = "#F6C16B";
  const normalizedBuckets = buckets.map((bucket) => {
    const stacksArray = [];
    const otherSum = Object.entries(bucket.stacks).reduce((acc, [title, value]) => {
      if (colorMap[title]) {
        stacksArray.push({ title, value, color: colorMap[title] });
        return acc;
      }
      return acc + value;
    }, 0);
    if (otherSum > 0) {
      stacksArray.push({ title: otherLabel, value: otherSum, color: otherColor });
    }
    return { label: bucket.label, total: bucket.total, stacks: stacksArray };
  });
  const grandTotal = Object.values(totalsByTitle).reduce((sum, v) => sum + v, 0) || 1;
  const legend = topTitles.map((title, idx) => ({
    id: title,
    label: title,
    value: totalsByTitle[title],
    percent: Math.round((totalsByTitle[title] / grandTotal) * 100),
    color: palette[idx % palette.length],
  }));
  const otherTotal = grandTotal - legend.reduce((sum, item) => sum + item.value, 0);
  if (otherTotal > 0) {
    legend.push({
      id: "other",
      label: otherLabel,
      value: otherTotal,
      percent: Math.max(1, Math.round((otherTotal / grandTotal) * 100)),
      color: otherColor,
    });
  }
  const formatLocal = (usd) => formatCurrency(convertToCurrency(usd || 0, currency), currency);
  const rangeTitleKey =
    range === "week" ? "spendStatsRangeWeeks" : range === "month" ? "spendStatsRangeMonths" : "spendStatsRangeDays";
  const rangeTitleTemplate =
    resolveTranslationValueForLanguage(language, rangeTitleKey) || "Last {{count}}";
  const rangeTitle = resolveTemplate(rangeTitleTemplate, { count: rangeCount });
  const averageLabel =
    isAverage && (resolveTranslationValueForLanguage(language, "spendStatsAverageLabel") || "Daily average");
  return {
    buckets: normalizedBuckets,
    legend,
    formatLocal,
    rangeCount,
    rangeTitle,
    averageLabel: averageLabel || "",
  };
};

const capitalizeFirstLetter = (value = "") => {
  if (!value) return "";
  return value.slice(0, 1).toUpperCase() + value.slice(1);
};

const getWeekStartMonday = (date) => {
  const next = new Date(date);
  next.setHours(0, 0, 0, 0);
  const weekday = (next.getDay() + 6) % 7;
  next.setDate(next.getDate() - weekday);
  return next;
};

const getReportWeekKey = (date) => getDayKey(getWeekStartMonday(date));

const formatReportMonthLabel = (date, locale) => {
  const raw = date.toLocaleDateString(locale, { month: "long", year: "numeric" }).replace(".", "").trim();
  return capitalizeFirstLetter(raw);
};

const formatReportWeekLabel = (startDate, endDate, locale) => {
  const formatShortMonth = (date) => {
    const raw = date.toLocaleDateString(locale, { month: "short" }).replace(".", "").trim();
    if (!raw) return "";
    return raw[0].toUpperCase() + raw.slice(1);
  };
  const startMonth = formatShortMonth(startDate);
  const endMonth = formatShortMonth(endDate);
  const startDay = startDate.getDate();
  const endDay = endDate.getDate();
  if (startMonth === endMonth) {
    return `${startMonth}${startDay}-${endDay}`;
  }
  return `${startMonth}${startDay}-${endMonth}${endDay}`;
};

const buildReportPeriods = (type, count, nowDate, locale) => {
  const safeCount = Math.max(1, Number(count) || 1);
  if (type === "month") {
    const currentMonthStart = new Date(nowDate.getFullYear(), nowDate.getMonth(), 1);
    const baseMonthStart = new Date(currentMonthStart.getFullYear(), currentMonthStart.getMonth() - 1, 1);
    return Array.from({ length: safeCount }).map((_, index) => {
      const start = new Date(baseMonthStart.getFullYear(), baseMonthStart.getMonth() - index, 1);
      const end = new Date(start.getFullYear(), start.getMonth() + 1, 1);
      const monthKey = String(start.getMonth() + 1).padStart(2, "0");
      const yearKey = String(start.getFullYear());
      return {
        type,
        periodKey: `${yearKey}-${monthKey}`,
        startMs: start.getTime(),
        endMs: end.getTime(),
        label: formatReportMonthLabel(start, locale),
      };
    });
  }
  const currentWeekStart = getWeekStartMonday(nowDate);
  const baseWeekStart = new Date(currentWeekStart);
  baseWeekStart.setDate(currentWeekStart.getDate() - 7);
  return Array.from({ length: safeCount }).map((_, index) => {
    const start = new Date(baseWeekStart);
    start.setDate(baseWeekStart.getDate() - index * 7);
    const end = new Date(start);
    end.setDate(start.getDate() + 7);
    const endLabelDate = new Date(end.getTime() - DAY_MS);
    return {
      type,
      periodKey: getDayKey(start),
      startMs: start.getTime(),
      endMs: end.getTime(),
      label: formatReportWeekLabel(start, endLabelDate, locale),
    };
  });
};

const buildReportsSnapshot = ({
  history = [],
  language = DEFAULT_LANGUAGE,
  currency = DEFAULT_PROFILE.currency,
  resolveTemplateTitle,
  t,
  now = Date.now(),
  joinedAt = null,
} = {}) => {
  const locale = getFormatLocale(language);
  const defaultDeclineTitle = (t && t("defaultDeclineLabel")) || "Skip";
  const incomeSavingsLabel =
    (t && t("incomeEntryVisualSavings")) || (t && t("budgetSavingsLabel")) || "Savings";
  const defaultSpendTitle = (t && t("defaultSpendLabel")) || "Spend";
  const safeHistory = Array.isArray(history) ? history : [];
  const nowDate = new Date(now);
  const joinAtMs = (() => {
    if (!joinedAt) return null;
    if (typeof joinedAt === "number" && Number.isFinite(joinedAt)) return joinedAt;
    if (typeof joinedAt === "string") {
      const parsed = Date.parse(joinedAt);
      return Number.isFinite(parsed) ? parsed : null;
    }
    return null;
  })();
  const resolveEntryLabel = (entry, fallbackLabel) => {
    const meta = entry?.meta || {};
    const templateId = meta.templateId || meta.template_id || entry?.templateId || null;
    const resolvedTitle =
      (resolveTemplateTitle &&
        resolveTemplateTitle(templateId, meta.title || entry?.title || "")) ||
      meta.title ||
      entry?.title ||
      fallbackLabel;
    const displayTitle =
      typeof resolvedTitle === "string" && resolvedTitle.trim() ? resolvedTitle.trim() : fallbackLabel;
    const stripped = stripEmojis(displayTitle || "").trim();
    const normalizedTitle = stripped || displayTitle || fallbackLabel;
    return { templateId, displayTitle, normalizedTitle };
  };
  const addToBucket = (bucketMap, entry, amount, fallbackLabel) => {
    const { templateId, displayTitle, normalizedTitle } = resolveEntryLabel(entry, fallbackLabel);
    const key = templateId ? `id:${templateId}` : `label:${normalizedTitle.toLowerCase()}`;
    const current =
      bucketMap.get(key) || {
        templateId: templateId || null,
        title: normalizedTitle || fallbackLabel,
        displayTitle: displayTitle || normalizedTitle || fallbackLabel,
        amountUSD: 0,
        count: 0,
      };
    current.amountUSD += amount;
    current.count += 1;
    bucketMap.set(key, current);
  };
  const pickTopBucket = (bucketMap) => {
    const entries = Array.from(bucketMap.values());
    entries.sort((a, b) => {
      if (b.amountUSD !== a.amountUSD) return b.amountUSD - a.amountUSD;
      if (b.count !== a.count) return b.count - a.count;
      return (a.displayTitle || "").localeCompare(b.displayTitle || "");
    });
    return entries[0] || null;
  };
  const buildReport = (period) => {
    const startMs = period.startMs;
    const endMs = period.endMs;
    const effectiveEndMs = Math.min(endMs, now);
    const effectiveStartMs =
      Number.isFinite(joinAtMs) && joinAtMs > 0 ? Math.max(startMs, joinAtMs) : startMs;
    if (Number.isFinite(joinAtMs) && effectiveEndMs <= joinAtMs) {
      return null;
    }
    if (effectiveEndMs <= effectiveStartMs) return null;
    const saveBuckets = new Map();
    const spendBuckets = new Map();
    const dayStats = new Map();
    let savedUSD = 0;
    let spendUSD = 0;
    let savedCount = 0;
    let spendCount = 0;
    let weekendSaveUSD = 0;
    let weekdaySaveUSD = 0;
    let weekendSpendUSD = 0;
    let weekdaySpendUSD = 0;
    safeHistory.forEach((entry) => {
      const timestamp = Number(entry?.timestamp) || 0;
      if (!timestamp || timestamp < effectiveStartMs || timestamp >= effectiveEndMs) return;
      const amount = Math.max(0, Number(entry?.meta?.amountUSD) || 0);
      if (!amount) return;
      const dayKey = getDayKey(timestamp);
      if (!dayKey) return;
      const stats = dayStats.get(dayKey) || {
        saveUSD: 0,
        spendUSD: 0,
        saveCount: 0,
        spendCount: 0,
      };
      if (isStatsSaveEvent(entry?.kind)) {
        savedUSD += amount;
        savedCount += 1;
        const saveFallbackTitle =
          entry?.kind === "income_savings" ? incomeSavingsLabel : defaultDeclineTitle;
        addToBucket(saveBuckets, entry, amount, saveFallbackTitle);
        stats.saveUSD += amount;
        stats.saveCount += 1;
        if (isWeekendTimestamp(timestamp)) {
          weekendSaveUSD += amount;
        } else {
          weekdaySaveUSD += amount;
        }
      } else if (entry?.kind === "spend") {
        spendUSD += amount;
        spendCount += 1;
        addToBucket(spendBuckets, entry, amount, defaultSpendTitle);
        stats.spendUSD += amount;
        stats.spendCount += 1;
        if (isWeekendTimestamp(timestamp)) {
          weekendSpendUSD += amount;
        } else {
          weekdaySpendUSD += amount;
        }
      }
      dayStats.set(dayKey, stats);
    });
    const rangeMs = Math.max(DAY_MS, effectiveEndMs - effectiveStartMs);
    const dayCount = Math.max(1, Math.ceil(rangeMs / DAY_MS));
    const statsArray = Array.from(dayStats.entries()).map(([dayKey, stats]) => ({
      dayKey,
      ...stats,
      netUSD: (stats.saveUSD || 0) - (stats.spendUSD || 0),
    }));
    const activeDays = statsArray.length;
    const saveDays = statsArray.filter((entry) => (entry.saveUSD || 0) > 0).length;
    const spendDays = statsArray.filter((entry) => (entry.spendUSD || 0) > 0).length;
    const peakSaveDay = statsArray.reduce((best, current) => {
      if ((current.saveUSD || 0) <= 0) return best;
      if (!best || current.saveUSD > best.saveUSD) return current;
      return best;
    }, null);
    const peakSpendDay = statsArray.reduce((best, current) => {
      if ((current.spendUSD || 0) <= 0) return best;
      if (!best || current.spendUSD > best.spendUSD) return current;
      return best;
    }, null);
    const saveShare = savedUSD + spendUSD > 0 ? savedUSD / (savedUSD + spendUSD) : 0;
    const avgSavePerDay = savedUSD / dayCount;
    const avgSpendPerDay = spendUSD / dayCount;
    const avgSavePerAction = savedCount ? savedUSD / savedCount : 0;
    const avgSpendPerAction = spendCount ? spendUSD / spendCount : 0;
    const weekendSpendShare = spendUSD > 0 ? weekendSpendUSD / spendUSD : 0;
    const weekendSaveShare = savedUSD > 0 ? weekendSaveUSD / savedUSD : 0;
    return {
      id: `${period.type}_${period.periodKey}`,
      type: period.type,
      periodKey: period.periodKey,
      label: period.label,
      startAt: new Date(effectiveStartMs).toISOString(),
      endAt: new Date(effectiveEndMs).toISOString(),
      totals: {
        savedUSD,
        spendUSD,
        savedCount,
        spendCount,
        dayCount,
      },
      metrics: {
        activeDays,
        saveDays,
        spendDays,
        saveShare,
        avgSavePerDay,
        avgSpendPerDay,
        avgSavePerAction,
        avgSpendPerAction,
        weekendSpendShare,
        weekendSaveShare,
        weekendSpendUSD,
        weekdaySpendUSD,
      },
      peakSaveDay,
      peakSpendDay,
      topSave: pickTopBucket(saveBuckets),
      topSpend: pickTopBucket(spendBuckets),
      currency,
    };
  };
  const weeklyPeriods = buildReportPeriods("week", REPORTS_WEEK_COUNT, nowDate, locale);
  const monthlyPeriods = buildReportPeriods("month", REPORTS_MONTH_COUNT, nowDate, locale);
  return {
    weekly: weeklyPeriods.map(buildReport).filter(Boolean),
    monthly: monthlyPeriods.map(buildReport).filter(Boolean),
    updatedAt: new Date(now).toISOString(),
  };
};

const reportHasMeaningfulData = (report) => {
  if (!report || typeof report !== "object") return false;
  const totals = report.totals || {};
  const savedUSD = Math.max(0, Number(totals.savedUSD) || 0);
  const spendUSD = Math.max(0, Number(totals.spendUSD) || 0);
  const savedCount = Math.max(0, Number(totals.savedCount) || 0);
  const spendCount = Math.max(0, Number(totals.spendCount) || 0);
  return savedUSD > 0 || spendUSD > 0 || savedCount + spendCount > 0;
};

const reportsSnapshotHasMeaningfulData = (snapshot) => {
  if (!snapshot || typeof snapshot !== "object") return false;
  const weekly = Array.isArray(snapshot.weekly) ? snapshot.weekly : [];
  const monthly = Array.isArray(snapshot.monthly) ? snapshot.monthly : [];
  const latestWeekly = weekly[0] || null;
  const latestMonthly = monthly[0] || null;
  return reportHasMeaningfulData(latestWeekly) || reportHasMeaningfulData(latestMonthly);
};

const reportsSnapshotHasWeeklyData = (snapshot) => {
  if (!snapshot || typeof snapshot !== "object") return false;
  const weekly = Array.isArray(snapshot.weekly) ? snapshot.weekly : [];
  return reportHasMeaningfulData(weekly[0] || null);
};

const getReportsSnapshotComparablePayload = (snapshot) => ({
  weekly: Array.isArray(snapshot?.weekly) ? snapshot.weekly : [],
  monthly: Array.isArray(snapshot?.monthly) ? snapshot.monthly : [],
});

const reportsSnapshotsEquivalent = (leftSnapshot, rightSnapshot) => {
  try {
    return (
      JSON.stringify(getReportsSnapshotComparablePayload(leftSnapshot)) ===
      JSON.stringify(getReportsSnapshotComparablePayload(rightSnapshot))
    );
  } catch {
    return false;
  }
};

const computeUsageStreakFromHistory = (history = [], now = Date.now()) => {
  if (!Array.isArray(history) || !history.length) return { ...INITIAL_USAGE_STREAK };
  const dayIndices = new Set();
  let latestTimestamp = 0;
  history.forEach((entry) => {
    if (!entry?.timestamp) return;
    if (entry.kind !== "refuse_spend" && entry.kind !== "spend") return;
    const dayIndex = getDayIndexFromTimestamp(entry.timestamp);
    if (!Number.isFinite(dayIndex)) return;
    dayIndices.add(dayIndex);
    if (entry.timestamp > latestTimestamp) {
      latestTimestamp = entry.timestamp;
    }
  });
  if (!dayIndices.size) return { ...INITIAL_USAGE_STREAK };
  const sortedIndices = Array.from(dayIndices).sort((a, b) => a - b);
  let best = 0;
  let run = 0;
  let prevIndex = null;
  sortedIndices.forEach((idx) => {
    if (prevIndex !== null && idx === prevIndex + 1) {
      run += 1;
    } else {
      run = 1;
    }
    best = Math.max(best, run);
    prevIndex = idx;
  });
  const todayIndex = getDayIndexFromTimestamp(now);
  const yesterdayIndex = todayIndex - 1;
  const latestIndex = sortedIndices[sortedIndices.length - 1];
  const isActive = latestIndex === todayIndex || latestIndex === yesterdayIndex;
  let current = 0;
  if (isActive) {
    let cursor = latestIndex;
    while (dayIndices.has(cursor)) {
      current += 1;
      cursor -= 1;
    }
  }
  return {
    total: dayIndices.size,
    current,
    best,
    lastDate: latestTimestamp ? getDayKey(latestTimestamp) : null,
  };
};

const deriveMoodFromState = (state = createMoodStateForToday(), pendingCount = 0, now = Date.now()) => {
  const events = Array.isArray(state.events) ? state.events : [];
  const filtered = events.filter(
    (event) => event?.timestamp && now - event.timestamp <= MOOD_ACTION_WINDOW_MS
  );
  const counts = filtered.reduce(
    (acc, event) => {
      if (event?.type && acc[event.type] !== undefined) {
        acc[event.type] += 1;
      }
      return acc;
    },
    { save: 0, spend: 0, maybe: 0, dream: 0 }
  );
  const lastInteraction = state.lastInteractionAt || state.lastVisitAt || filtered[0]?.timestamp || 0;
  if (lastInteraction && now - lastInteraction >= MOOD_INACTIVITY_THRESHOLD_MS) {
    return MOOD_IDS.TIRED;
  }
  const candidates = [];
  if (counts.spend >= MOOD_EVENT_THRESHOLD) {
    const timestamp = getLatestEventTimestamp(filtered, "spend");
    if (timestamp) candidates.push({ mood: MOOD_IDS.IMPULSIVE, timestamp });
  }
  if (counts.save >= MOOD_EVENT_THRESHOLD) {
    const timestamp = getLatestEventTimestamp(filtered, "save");
    if (timestamp) candidates.push({ mood: MOOD_IDS.FOCUSED, timestamp });
  }
  if (counts.maybe >= MOOD_EVENT_THRESHOLD) {
    const timestamp = getLatestEventTimestamp(filtered, "maybe");
    if (timestamp) candidates.push({ mood: MOOD_IDS.DOUBTER, timestamp });
  }
  if (counts.dream >= MOOD_DREAM_WISH_THRESHOLD) {
    const timestamp = getLatestEventTimestamp(filtered, "dream");
    if (timestamp) candidates.push({ mood: MOOD_IDS.DREAMER, timestamp });
  }
  if (pendingCount >= MOOD_PENDING_THRESHOLD) {
    candidates.push({ mood: MOOD_IDS.DREAMER, timestamp: now });
  }
  if (candidates.length) {
    candidates.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
    return candidates[0].mood;
  }
  return MOOD_IDS.NEUTRAL;
};

const getImpulseCategoryName = (id, language = "en") => {
  const entry = IMPULSE_CATEGORY_DEFS[id];
  if (!entry) return id || "";
  const localeKey = getShortLanguageKey(language);
  return entry[localeKey] || entry.en || entry.ru || id;
};

const getImpulseCategoryLabel = (id, language = "en") => {
  const entry = IMPULSE_CATEGORY_DEFS[id];
  if (!entry) return id;
  return `${entry.emoji} ${getImpulseCategoryName(id, language)}`;
};

const RainOverlay = ({ colors }) => {
  const drops = useMemo(
    () =>
      Array.from({ length: RAIN_DROPS }, (_, index) => ({
        id: index,
        left: Math.random() * SCREEN_WIDTH,
        delay: Math.random() * 800,
        height: 80 + Math.random() * 60,
      })),
    []
  );

  return (
    <View style={styles.rainLayer} pointerEvents="none">
      {drops.map((drop) => (
        <RainDrop key={drop.id} {...drop} colors={colors} />
      ))}
    </View>
  );
};

const RainDrop = ({ left, delay, height, colors }) => {
  const translateY = useRef(new Animated.Value(-120)).current;

  useEffect(() => {
    const loop = Animated.loop(
      Animated.sequence([
        Animated.delay(delay),
        Animated.timing(translateY, {
          toValue: 500,
          duration: 1400,
          useNativeDriver: true,
        }),
        Animated.timing(translateY, {
          toValue: -120,
          duration: 0,
          useNativeDriver: true,
        }),
      ])
    );
    loop.start();
    return () => loop.stop();
  }, [delay, translateY]);

  return (
    <Animated.View
      style={[
        styles.rainDrop,
        {
          left,
          height,
          backgroundColor: colors.muted,
          transform: [{ translateY }],
        },
      ]}
    />
  );
};

const AnimatedTouchableOpacity = Animated.createAnimatedComponent(TouchableOpacity);
const BASE_HORIZONTAL_PADDING = Platform.OS === "android" ? 20 : 30;

if (Platform.OS === "android" && UIManager.setLayoutAnimationEnabledExperimental) {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

const triggerHaptic = (style = Haptics.ImpactFeedbackStyle.Light) => {
  Haptics.impactAsync(style).catch(() => {});
};

const triggerSuccessHaptic = () => {
  Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success).catch(() => {});
};

const triggerSelectionHaptic = () => {
  Haptics.selectionAsync().catch(() => {});
};

const triggerCoinRewardHaptics = () => {
  const pulses = [0, 90, 180, 270];
  pulses.forEach((delay) => {
    setTimeout(() => {
      triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    }, delay);
  });
};

const convertToCurrency = (valueUSD = 0, currency = activeCurrency) => {
  if (!valueUSD) return 0;
  const rate = CURRENCY_RATES[currency] || 1;
  return valueUSD * rate;
};

const convertFromCurrency = (valueLocal = 0, currency = activeCurrency) => {
  if (!valueLocal) return 0;
  const rate = CURRENCY_RATES[currency] || 1;
  if (!rate) return valueLocal;
  return valueLocal / rate;
};

const POTENTIAL_PUSH_STEP_EUR = 10;
const POTENTIAL_PUSH_STEP_USD = convertFromCurrency(POTENTIAL_PUSH_STEP_EUR, "EUR");
const POTENTIAL_PUSH_STEP_LOCAL_MAP = {
  AED: 10,
  AUD: 10,
  BYN: 10,
  CAD: 10,
  EUR: 10,
  GBP: 10,
  JPY: 1000,
  KZT: 3000,
  KRW: 15000,
  MXN: 100,
  PLN: 10,
  RUB: 1000,
  SAR: 10,
  USD: 10,
  DEFAULT: 10,
};
const POTENTIAL_PUSH_STEP_LOCAL_FALLBACK =
  POTENTIAL_PUSH_STEP_LOCAL_MAP.DEFAULT || POTENTIAL_PUSH_STEP_EUR;
const POTENTIAL_PUSH_MAX_MULTIPLIER = 5;
const POTENTIAL_PUSH_FAST_GAIN_WINDOW_MS = 2 * 60 * 60 * 1000;
const POTENTIAL_PUSH_COOLDOWN_WINDOW_MS = 36 * 60 * 60 * 1000;
const DEFAULT_POTENTIAL_PUSH_STATE = {
  lastStep: 0,
  lastStatus: null,
  baselineKey: null,
  stepMultiplier: 1,
  lastNotifiedAt: 0,
};

const getCurrencyPrecision = (currency = activeCurrency) => {
  if (
    currency === "AED" ||
    currency === "AUD" ||
    currency === "BYN" ||
    currency === "CAD" ||
    currency === "EUR" ||
    currency === "GBP" ||
    currency === "MXN" ||
    currency === "PLN" ||
    currency === "SAR" ||
    currency === "USD"
  )
    return 2;
  return 0;
};

const getCurrencyDisplayPrecision = (currency = activeCurrency) => {
  if (Object.prototype.hasOwnProperty.call(CURRENCY_DISPLAY_PRECISION, currency)) {
    return CURRENCY_DISPLAY_PRECISION[currency];
  }
  return getCurrencyPrecision(currency);
};

const getCurrencyFineStep = (currency = activeCurrency) => {
  if (CURRENCY_FINE_STEPS[currency]) return CURRENCY_FINE_STEPS[currency];
  const precision = getCurrencyPrecision(currency);
  return precision > 0 ? Math.pow(10, -precision) : 1;
};

const roundCurrencyValue = (value = 0, currency = activeCurrency, precisionOverride = null) => {
  const precision =
    typeof precisionOverride === "number" && Number.isFinite(precisionOverride)
      ? precisionOverride
      : getCurrencyPrecision(currency);
  const factor = Math.pow(10, precision);
  if (!Number.isFinite(factor) || factor <= 0) return Number(value) || 0;
  return Math.round(((Number(value) || 0) + Number.EPSILON) * factor) / factor;
};

const snapCurrencyValue = (value = 0, currency = activeCurrency) => {
  const step = CURRENCY_FINE_STEPS[currency];
  if (!step || step <= 0) {
    return roundCurrencyValue(value, currency);
  }
  const snapped = Math.round((Number(value) || 0) / step) * step;
  return roundCurrencyValue(snapped, currency);
};

const getFriendlyDisplayStep = (amount = 0) => {
  const value = Math.abs(amount);
  if (value === 0) return 1;
  if (value < 1) return 0.1;
  if (value < 5) return 0.25;
  if (value < 20) return 1;
  if (value < 50) return 2;
  if (value < 100) return 5;
  if (value < 250) return 10;
  if (value < 1000) return 25;
  if (value < 5000) return 50;
  if (value < 20000) return 100;
  if (value < 100000) return 250;
  return 500;
};

const applyFriendlyDisplayRounding = (value = 0, currency = activeCurrency) => {
  if (!Number.isFinite(value) || value === 0) return value || 0;
  const baseStep = getFriendlyDisplayStep(value);
  const fineStep = getCurrencyFineStep(currency) || 0;
  const step = Math.max(baseStep, fineStep || 0);
  if (!Number.isFinite(step) || step === 0) return value;
  return Math.round(value / step) * step;
};

const roundRemainingDisplayUSD = (value = 0, currency = activeCurrency) => {
  if (!Number.isFinite(value) || value <= 0) return 0;
  const localValue = convertToCurrency(value, currency);
  const baseStep = getFriendlyDisplayStep(localValue);
  const fineStep = getCurrencyFineStep(currency) || 0;
  const step = Math.max(baseStep, fineStep || 0);
  if (!Number.isFinite(step) || step <= 0) return value;
  const roundedLocal = Math.ceil(localValue / step) * step;
  return convertFromCurrency(roundedLocal, currency);
};

const formatSampleAmount = (valueUSD, currencyCode) =>
  formatCurrency(convertToCurrency(valueUSD, currencyCode), currencyCode);

const formatNumberInputValue = (value, precisionOverride = 2) => {
  if (!Number.isFinite(value)) return "";
  const precision =
    typeof precisionOverride === "number" && Number.isFinite(precisionOverride)
      ? Math.max(0, Math.min(6, precisionOverride))
      : 2;
  const formatted = value.toFixed(precision).replace(/\.?0+$/, "");
  return formatted;
};

const normalizeNumberInputParts = (value = "") => {
  if (typeof value !== "string") {
    return { normalized: "", fractionDigits: 0 };
  }
  const cleaned = value.replace(/[^\d,.\s]/g, "").replace(/\s+/g, "");
  if (!cleaned) {
    return { normalized: "", fractionDigits: 0 };
  }
  const lastComma = cleaned.lastIndexOf(",");
  const lastDot = cleaned.lastIndexOf(".");
  const decimalIndex = Math.max(lastComma, lastDot);
  if (decimalIndex < 0) {
    return { normalized: cleaned, fractionDigits: 0 };
  }
  const integerPartRaw = cleaned.slice(0, decimalIndex).replace(/[.,]/g, "");
  const fractionPartRaw = cleaned.slice(decimalIndex + 1).replace(/[.,]/g, "");
  const integerPart = integerPartRaw.length ? integerPartRaw : "0";
  const normalized = `${integerPart}.${fractionPartRaw}`;
  return {
    normalized,
    fractionDigits: fractionPartRaw.length,
  };
};

const parseNumberInputValue = (value = "") => {
  const { normalized } = normalizeNumberInputParts(value);
  if (!normalized) return NaN;
  const parsed = parseFloat(normalized);
  return Number.isFinite(parsed) ? parsed : NaN;
};

const getManualInputPrecision = (value = "") => {
  const { fractionDigits } = normalizeNumberInputParts(value);
  return Math.max(0, Math.min(6, fractionDigits));
};

const normalizeTimestampMs = (value) => {
  if (value === null || value === undefined) return 0;
  let parsed = 0;
  if (typeof value === "number") {
    parsed = value;
  } else if (typeof value === "string") {
    const trimmed = value.trim();
    if (!trimmed) return 0;
    const numericValue = Number(trimmed);
    if (Number.isFinite(numericValue)) {
      parsed = numericValue;
    } else {
      const dateValue = Date.parse(trimmed);
      parsed = Number.isFinite(dateValue) ? dateValue : 0;
    }
  } else if (value instanceof Date) {
    parsed = value.getTime();
  }
  if (!Number.isFinite(parsed) || parsed <= 0) return 0;
  // Support legacy timestamps stored in seconds/microseconds/nanoseconds.
  if (parsed > 1e18) {
    parsed = Math.round(parsed / 1e6);
  } else if (parsed > 1e15) {
    parsed = Math.round(parsed / 1e3);
  } else if (parsed < 1e11) {
    parsed = Math.round(parsed * 1e3);
  }
  return Number.isFinite(parsed) && parsed > 0 ? parsed : 0;
};

const formatLatestSavingTimestamp = (timestamp, language = DEFAULT_LANGUAGE) => {
  if (!timestamp) return null;
  try {
    const locale = getFormatLocale(language);
    const date = new Date(timestamp);
    const dateLabel = date.toLocaleDateString(locale, { day: "numeric", month: "short" });
    const timeLabel = date.toLocaleTimeString(locale, {
      hour: "2-digit",
      minute: "2-digit",
      hour12: false,
    });
    return `${dateLabel}, ${timeLabel}`;
  } catch {
    return null;
  }
};

const normalizeEmojiValue = (value, fallback) => {
  const trimmed = (value || "").trim();
  if (!trimmed) return fallback;
  const firstGrapheme = Array.from(trimmed)[0];
  return firstGrapheme || fallback;
};

const limitEmojiInput = (value) => {
  if (!value) return "";
  const trimmed = value.trim();
  const firstGrapheme = Array.from(trimmed)[0];
  return firstGrapheme || "";
};

const applySavingsCategoryOverride = (override) => {
  const normalized = override && typeof override === "object" ? override : null;
  const label = typeof normalized?.label === "string" ? normalized.label.trim() : "";
  const emoji = normalized?.emoji ? limitEmojiInput(String(normalized.emoji)) : "";
  BUDGET_SPECIAL_CATEGORY_DEFS.savings = {
    ...DEFAULT_SAVINGS_CATEGORY_DEF,
    ru: label || DEFAULT_SAVINGS_CATEGORY_DEF.ru,
    en: label || DEFAULT_SAVINGS_CATEGORY_DEF.en,
    es: label || DEFAULT_SAVINGS_CATEGORY_DEF.es,
    fr: label || DEFAULT_SAVINGS_CATEGORY_DEF.fr,
    emoji: emoji || DEFAULT_SAVINGS_CATEGORY_DEF.emoji,
  };
};

const resetImpulseCategoryDef = (categoryId) => {
  const base = BASE_IMPULSE_CATEGORY_DEFS[categoryId];
  if (!base) return;
  if (!IMPULSE_CATEGORY_DEFS[categoryId]) return;
  IMPULSE_CATEGORY_DEFS[categoryId] = { ...base };
};

const applyCategoryDefOverrides = (overrides = {}) => {
  if (!overrides || typeof overrides !== "object") return;
  Object.entries(overrides).forEach(([categoryId, value]) => {
    if (!categoryId || categoryId === "savings") return;
    const def = IMPULSE_CATEGORY_DEFS[categoryId];
    if (!def) return;
    const label = typeof value?.label === "string" ? value.label.trim() : "";
    const emoji = value?.emoji ? limitEmojiInput(String(value.emoji)) : "";
    if (label) {
      def.ru = label;
      def.en = label;
      def.es = label;
      def.fr = label;
    }
    if (emoji) {
      def.emoji = emoji;
    }
  });
};

const getPersonaPreset = (personaId) => PERSONA_PRESETS[personaId] || PERSONA_PRESETS[DEFAULT_PERSONA_ID];

const createPersonaTemptation = (preset) => {
  if (!preset?.habit) return null;
  const habit = preset.habit;
  return {
    id: `persona_${preset.id}`,
    emoji: habit.emoji || preset.emoji || "âœ¨",
    image: habit.image,
    color: habit.color || "#FFF5E6",
    categories: habit.categories || ["habit"],
    basePriceUSD: habit.basePriceUSD || 5,
    priceUSD: habit.basePriceUSD || 5,
    title: habit.title,
    description: habit.description,
    audience: preset.audience || habit.audience || null,
  };
};

const parseAmountValue = (value) => {
  if (value === null || value === undefined) return 0;
  if (typeof value === "number") return Number.isFinite(value) ? value : 0;
  if (typeof value === "string") {
    const parsed = Number(value.replace(",", "."));
    return Number.isFinite(parsed) ? parsed : 0;
  }
  return 0;
};

const resolveCustomPriceUSD = (customSpend, fallbackCurrency = DEFAULT_PROFILE.currency) => {
  const direct = parseAmountValue(customSpend?.amountUSD);
  if (direct > 0) return direct;
  const local = parseAmountValue(customSpend?.amount ?? customSpend?.amountLocal ?? customSpend?.price);
  if (local > 0) {
    const currencyCode = customSpend?.currency || fallbackCurrency || DEFAULT_PROFILE.currency;
    return convertFromCurrency(local, currencyCode);
  }
  return 0;
};

const buildCustomTemptationDescription = (gender = "none") => {
  const isFemale = gender === "female";
  const isMale = gender === "male";
  let ru = "Ð­Ñ‚Ð¾ Ð¸ÑÐºÑƒÑˆÐµÐ½Ð¸Ðµ Ñ‚Ñ‹ Ð´Ð¾Ð±Ð°Ð²Ð¸Ð»(Ð°) ÑÐ°Ð¼(Ð°). ÐžÑ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ð¹ ÐµÐ³Ð¾ Ð¸ Ð¿Ð¾Ð±ÐµÐ¶Ð´Ð°Ð¹ Ñ‡Ð°Ñ‰Ðµ.";
  if (isMale) {
    ru = "Ð­Ñ‚Ð¾ Ð¸ÑÐºÑƒÑˆÐµÐ½Ð¸Ðµ Ñ‚Ñ‹ Ð´Ð¾Ð±Ð°Ð²Ð¸Ð» ÑÐ°Ð¼. ÐžÑ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ð¹ ÐµÐ³Ð¾ Ð¸ Ð¿Ð¾Ð±ÐµÐ¶Ð´Ð°Ð¹ Ñ‡Ð°Ñ‰Ðµ.";
  } else if (isFemale) {
    ru = "Ð­Ñ‚Ð¾ Ð¸ÑÐºÑƒÑˆÐµÐ½Ð¸Ðµ Ñ‚Ñ‹ Ð´Ð¾Ð±Ð°Ð²Ð¸Ð»Ð° ÑÐ°Ð¼Ð°. ÐžÑ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ð¹ ÐµÐ³Ð¾ Ð¸ Ð¿Ð¾Ð±ÐµÐ¶Ð´Ð°Ð¹ Ñ‡Ð°Ñ‰Ðµ.";
  }
  const en = "You added this temptation yourself. Track it and beat it more often.";
  const esBase = "AÃ±adiste esta tentaciÃ³n tÃº misma. RegÃ­strala y supÃ©rala mÃ¡s seguido.";
  const es = isMale
    ? "AÃ±adiste esta tentaciÃ³n tÃº mismo. RegÃ­strala y supÃ©rala mÃ¡s seguido."
    : esBase;
  const fr = "Tu as ajoutÃ© cette tentation toi-mÃªme. Suis-la et bats-la plus souvent.";
  return {
    ru,
    en,
    es,
    fr,
  };
};

const CUSTOM_HABIT_FALLBACK_TITLES = {
  ru: "ÐœÐ¾Ñ Ð¿Ñ€Ð¸Ð²Ñ‹Ñ‡ÐºÐ°",
  en: "My impulse",
  es: "Mi impulso",
  fr: "Mon impulsion",
};

const createCustomHabitTemptation = (customSpend, fallbackCurrency = DEFAULT_PROFILE.currency, gender = "none") => {
  const price = resolveCustomPriceUSD(customSpend, fallbackCurrency) || CUSTOM_SPEND_SAMPLE_USD;
  const createdAt = Number.isFinite(Number(customSpend?.createdAt)) ? Number(customSpend.createdAt) : null;
  const precision =
    typeof customSpend?.pricePrecision === "number" && Number.isFinite(customSpend.pricePrecision)
      ? Math.max(0, Math.min(6, customSpend.pricePrecision))
      : null;
  let frequency = normalizeFrequencyId(customSpend?.frequency) || null;
  let frequencyCustom =
    normalizeCustomFrequency(customSpend?.frequencyCustom || customSpend?.customFrequency) || null;
  if (frequency === "biweekly") {
    frequency = "custom";
    frequencyCustom = { ...DEFAULT_CUSTOM_FREQUENCY };
  }
  if (frequency === "custom" && !frequencyCustom) {
    frequencyCustom = { ...DEFAULT_CUSTOM_FREQUENCY };
  }
  const frequencyIntervalMs = frequency === "custom" ? getCustomFrequencyIntervalMs(frequencyCustom) : null;
  const resolvedTitle = customSpend?.title;
  const title =
    resolvedTitle && resolvedTitle.trim().length
      ? resolvedTitle.trim()
      : CUSTOM_HABIT_FALLBACK_TITLES.en;
  const description = buildCustomTemptationDescription(gender);
  const impulseCategory =
    customSpend?.impulseCategory && IMPULSE_CATEGORY_DEFS[customSpend.impulseCategory]
      ? customSpend.impulseCategory
      : null;
  const categories = ["habit", "custom"];
  if (impulseCategory) {
    categories.push(impulseCategory);
  }
  return {
    id: customSpend.id || "custom_habit",
    emoji: customSpend.emoji || "ðŸ’¡",
    color: "#FFF5E6",
    categories,
    basePriceUSD: price,
    priceUSD: price,
    pricePrecision: precision,
    createdAt: createdAt || null,
    frequency: frequency || null,
    frequencyCustom: frequency === "custom" ? frequencyCustom || null : null,
    frequencyIntervalMs: frequency === "custom" ? frequencyIntervalMs || null : null,
    title: {
      ru: resolvedTitle || CUSTOM_HABIT_FALLBACK_TITLES.ru,
      en: title || CUSTOM_HABIT_FALLBACK_TITLES.en,
      es: resolvedTitle || CUSTOM_HABIT_FALLBACK_TITLES.es,
      fr: resolvedTitle || CUSTOM_HABIT_FALLBACK_TITLES.fr,
    },
    description,
    impulseCategoryOverride: impulseCategory,
  };
};

const hasValidCustomPrice = (entry) => {
  if (!entry || typeof entry !== "object") return false;
  const price = Number(entry.priceUSD);
  if (Number.isFinite(price) && price > 0) return true;
  const basePrice = Number(entry.basePriceUSD);
  return Number.isFinite(basePrice) && basePrice > 0;
};

const normalizeCustomTemptationEntry = (
  entry,
  fallbackCurrency = DEFAULT_PROFILE.currency
) => {
  if (!entry || typeof entry !== "object") return null;
  const genderValue = entry?.gender || "none";
  if (hasValidCustomPrice(entry)) {
    const entryCategory =
      entry.impulseCategoryOverride || entry.impulseCategory || null;
    const normalizedCategory =
      entryCategory && IMPULSE_CATEGORY_DEFS[entryCategory] ? entryCategory : null;
    return {
      ...entry,
      description: buildCustomTemptationDescription(genderValue),
      impulseCategoryOverride: normalizedCategory,
      quickTemptation: true,
    };
  }
  const rebuilt = createCustomHabitTemptation(entry, fallbackCurrency, genderValue);
  if (!rebuilt) return null;
  const merged = { ...rebuilt, ...entry };
  merged.priceUSD = rebuilt.priceUSD;
  merged.basePriceUSD = rebuilt.basePriceUSD;
  merged.description = rebuilt.description;
  const entryCategory =
    entry.impulseCategoryOverride || entry.impulseCategory || rebuilt.impulseCategoryOverride;
  merged.impulseCategoryOverride =
    entryCategory && IMPULSE_CATEGORY_DEFS[entryCategory] ? entryCategory : rebuilt.impulseCategoryOverride || null;
  merged.quickTemptation = true;
  return merged;
};

const matchesGenderAudience = (card, gender = "none") => {
  if (!card || !card.audience || !gender || gender === "none") return true;
  const list = Array.isArray(card.audience) ? card.audience : [card.audience];
  return list.includes(gender);
};

const buildPersonalizedTemptations = (profile, baseList = DEFAULT_TEMPTATIONS) => {
  const preset = getPersonaPreset(profile?.persona);
  const personaExtras = PERSONA_TEMPTATION_PRESETS[preset?.id] || [];
  const customFirst = profile?.customSpend
    ? createCustomHabitTemptation(
        profile.customSpend,
        profile?.currency,
        profile?.gender
      )
    : null;
  const personaCard = createPersonaTemptation(preset);
  const priorityIds = ["coffee_to_go", "netflix_subscription"];
  const gender = profile?.gender || "none";
  const seen = new Set();
  const skippedIds = new Set();
  const result = [];
  const pushIfVisible = (card) => {
    if (!card || seen.has(card.id)) return;
    if (!matchesGenderAudience(card, gender)) return;
    seen.add(card.id);
    result.push(card);
  };

  // 1) ÐšÐ°ÑÑ‚Ð¾Ð¼Ð½Ð°Ñ ÐºÐ°Ñ€Ñ‚Ð° Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð²ÑÐµÐ³Ð´Ð° Ð¿ÐµÑ€Ð²Ð°Ñ, ÐµÑÐ»Ð¸ ÐµÑÑ‚ÑŒ.
  pushIfVisible(customFirst);
  // 2) ÐšÐ°Ñ€Ñ‚Ð° Ð¿ÐµÑ€ÑÐ¾Ð½Ñ‹ - ÑÑ€Ð°Ð·Ñƒ Ð¿Ð¾ÑÐ»Ðµ ÐºÐ°ÑÑ‚Ð¾Ð¼Ð½Ð¾Ð¹ Ð¸Ð»Ð¸ Ð¿ÐµÑ€Ð²Ð¾Ð¹, ÐµÑÐ»Ð¸ ÐºÐ°ÑÑ‚Ð¾Ð¼Ð½Ð¾Ð¹ Ð½ÐµÑ‚.
  const hasBaseCoffee = baseList.some((item) => item?.id === "coffee_to_go");
  const personaHasCoffee =
    preset?.id === "mindful_coffee" ||
    (personaCard && Array.isArray(personaCard.categories) && personaCard.categories.includes("coffee"));
  const shouldSkipPersona = !customFirst && hasBaseCoffee && personaHasCoffee;
  if (!shouldSkipPersona) {
    pushIfVisible(personaCard);
  }
  const sortedPersonaExtras = personaExtras
    .filter((card) => matchesGenderAudience(card, gender))
    .sort((a, b) => getTemptationPrice(a) - getTemptationPrice(b));
  sortedPersonaExtras.forEach((card) => pushIfVisible(card));
  // 3) Ð”ÐµÑ€Ð¶Ð¸Ð¼ ÐºÐ¾Ñ„Ðµ Ð½Ð°Ð²Ñ‹Ð½Ð¾Ñ Ð¸ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÑƒ Netflix ÑÑ€Ð°Ð·Ñƒ Ð¿Ð¾ÑÐ»Ðµ ÐºÐ°ÑÑ‚Ð¾Ð¼Ð½Ð¾Ð¹/Ð¿ÐµÑ€ÑÐ¾Ð½Ñ‹.
  const resolvedPriorityIds = [...priorityIds];
  if (!shouldSkipPersona && preset?.id === "mindful_coffee" && personaHasCoffee) {
    const altCoffee = baseList.find((item) => item?.id === "croissant_break")?.id || "croissant_break";
    resolvedPriorityIds.splice(0, 1, altCoffee);
    skippedIds.add("coffee_to_go");
  }
  resolvedPriorityIds.forEach((id) => {
    if (skippedIds.has(id)) return;
    const card = baseList.find((item) => item?.id === id);
    pushIfVisible(card);
  });

  // ÐžÑÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ðµ, Ð¾Ñ‚ÑÐ¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ Ð¿Ð¾ Ñ†ÐµÐ½Ðµ.
  const pool = [...baseList].filter((item) => item && !seen.has(item.id) && !skippedIds.has(item.id));
  const sortedPool = pool
    .filter((item) => matchesGenderAudience(item, gender))
    .sort((a, b) => {
      const priceA = a.priceUSD ?? a.basePriceUSD ?? Number.POSITIVE_INFINITY;
      const priceB = b.priceUSD ?? b.basePriceUSD ?? Number.POSITIVE_INFINITY;
      return priceA - priceB;
    });
  return [...result, ...sortedPool];
};

const mergeInteractionStatMaps = (base = {}, incoming = {}) => {
  const result = { ...(base || {}) };
  Object.entries(incoming || {}).forEach(([templateId, stats]) => {
    if (!stats) return;
    const current = result[templateId] || {};
    const merged = { ...current };
    merged.saveCount = (current.saveCount || 0) + (stats.saveCount || 0);
    merged.spendCount = (current.spendCount || 0) + (stats.spendCount || 0);
    merged.lastInteractionAt = Math.max(current.lastInteractionAt || 0, stats.lastInteractionAt || 0);
    const latestIsIncoming = (stats.lastInteractionAt || 0) >= (current.lastInteractionAt || 0);
    if (latestIsIncoming) {
      merged.previousInteractionAt = stats.previousInteractionAt || merged.previousInteractionAt || null;
      merged.secondPreviousInteractionAt =
        stats.secondPreviousInteractionAt ?? merged.secondPreviousInteractionAt ?? null;
      merged.detectedIntervalMs = stats.detectedIntervalMs ?? merged.detectedIntervalMs ?? null;
      merged.frequency = stats.frequency ?? merged.frequency ?? null;
      merged.frequencyCustom = stats.frequencyCustom ?? merged.frequencyCustom ?? null;
      merged.intervalMs = stats.intervalMs ?? merged.intervalMs ?? null;
      merged.nextCheckAt = stats.nextCheckAt ?? merged.nextCheckAt ?? null;
      merged.lastTimerResetAt = stats.lastTimerResetAt ?? merged.lastTimerResetAt ?? null;
      merged.frequencyReminderId = stats.frequencyReminderId ?? merged.frequencyReminderId ?? null;
      merged.frequencyReminderIds = Array.isArray(stats.frequencyReminderIds)
        ? [...stats.frequencyReminderIds]
        : Array.isArray(merged.frequencyReminderIds)
        ? merged.frequencyReminderIds
        : [];
      merged.frequencyReminderScheduledAt =
        stats.frequencyReminderScheduledAt ?? merged.frequencyReminderScheduledAt ?? null;
      merged.frequencyReminderLocale =
        stats.frequencyReminderLocale ?? merged.frequencyReminderLocale ?? null;
      merged.frequencyReminderPlanKey =
        stats.frequencyReminderPlanKey ?? merged.frequencyReminderPlanKey ?? null;
      merged.templateTitle = stats.templateTitle ?? merged.templateTitle ?? null;
    } else {
      if (!merged.previousInteractionAt && stats.previousInteractionAt) {
        merged.previousInteractionAt = stats.previousInteractionAt;
      }
      if (!merged.secondPreviousInteractionAt && stats.secondPreviousInteractionAt) {
        merged.secondPreviousInteractionAt = stats.secondPreviousInteractionAt;
      }
    }
    merged.missedCycles = (current.missedCycles || 0) + (stats.missedCycles || 0);
    if (!merged.templateTitle && stats.templateTitle) {
      merged.templateTitle = stats.templateTitle;
    }
    if (!merged.frequencyReminderIds && Array.isArray(stats.frequencyReminderIds)) {
      merged.frequencyReminderIds = [...stats.frequencyReminderIds];
    }
    if (!merged.frequencyReminderPlanKey && stats.frequencyReminderPlanKey) {
      merged.frequencyReminderPlanKey = stats.frequencyReminderPlanKey;
    }
    result[templateId] = merged;
  });
  return result;
};

const useFadeIn = () => {
  const fade = useRef(new Animated.Value(0)).current;
  useEffect(() => {
    Animated.timing(fade, {
      toValue: 1,
      duration: 350,
      useNativeDriver: true,
    }).start();
  }, [fade]);
  return fade;
};

const getSessionShuffleValue = (seed, value) => {
  const normalizedSeed = Number.isFinite(seed) ? seed : 0;
  const seedInt = Math.floor(normalizedSeed * 0x7fffffff) | 0;
  const text = String(value ?? "");
  let hash = 0;
  for (let i = 0; i < text.length; i += 1) {
    hash = (hash * 31 + text.charCodeAt(i)) | 0;
  }
  const combined = (hash ^ seedInt) >>> 0;
  return combined / 0xffffffff;
};

const FEED_FREQUENT_PIN_LIMIT = 5;
const DAILY_FREQUENCY_INTERVAL_MS = 26 * 60 * 60 * 1000;
const DAILY_SECOND_ACTION_THRESHOLD_MS = DAILY_FREQUENCY_INTERVAL_MS;
const DAILY_COOLDOWN_TO_WEEKLY_MS = 36 * 60 * 60 * 1000;
const WEEKLY_FREQUENCY_THRESHOLD_MS = DAY_MS * 7;
const BIWEEKLY_FREQUENCY_THRESHOLD_MS = DAY_MS * 14;
const MONTHLY_FREQUENCY_THRESHOLD_MS = DAY_MS * 14;
const TEMPTATION_FREQUENCY_BUCKETS = {
  daily: {
    id: "daily",
    intervalMs: DAILY_FREQUENCY_INTERVAL_MS,
    thresholdMs: DAILY_SECOND_ACTION_THRESHOLD_MS,
    sectionKey: "frequencySectionDaily",
    badgeKey: "frequencyBadgeDaily",
  },
  weekly: {
    id: "weekly",
    intervalMs: DAY_MS * 7,
    thresholdMs: WEEKLY_FREQUENCY_THRESHOLD_MS,
    sectionKey: "frequencySectionWeekly",
    badgeKey: "frequencyBadgeWeekly",
  },
  biweekly: {
    id: "biweekly",
    intervalMs: DAY_MS * 14,
    thresholdMs: MONTHLY_FREQUENCY_THRESHOLD_MS,
    sectionKey: "frequencySectionBiweekly",
    badgeKey: "frequencyBadgeBiweekly",
  },
  monthly: {
    id: "monthly",
    intervalMs: DAY_MS * 30,
    thresholdMs: Number.POSITIVE_INFINITY,
    sectionKey: "frequencySectionMonthly",
    badgeKey: "frequencyBadgeMonthly",
  },
};
const FREQUENCY_PICKER_OPTIONS = [
  { id: "daily", labelKey: "frequencyPickerDaily" },
  { id: "weekly", labelKey: "frequencyPickerWeekly" },
  { id: "monthly", labelKey: "frequencyPickerMonthly" },
  { id: "custom", labelKey: "frequencyPickerCustom" },
];
const CUSTOM_FREQUENCY_UNITS = [
  { id: "day", ms: DAY_MS, shortKey: "frequencyUnitDayShort", longKey: "frequencyUnitDay" },
  { id: "week", ms: DAY_MS * 7, shortKey: "frequencyUnitWeekShort", longKey: "frequencyUnitWeek" },
  { id: "month", ms: DAY_MS * 30, shortKey: "frequencyUnitMonthShort", longKey: "frequencyUnitMonth" },
];
const DEFAULT_CUSTOM_FREQUENCY = { count: 2, unit: "week" };
const normalizeFrequencyId = (value) => {
  const normalized = typeof value === "string" ? value.trim().toLowerCase() : "";
  if (!normalized) return null;
  if (["daily", "weekly", "monthly", "custom", "biweekly"].includes(normalized)) {
    return normalized;
  }
  return null;
};
const normalizeCustomFrequency = (custom = null) => {
  if (!custom || typeof custom !== "object") return null;
  const rawCount = Number(custom.count ?? custom.value ?? custom.amount ?? custom.times);
  const count = Number.isFinite(rawCount) ? Math.max(1, Math.round(rawCount)) : 1;
  const rawUnit = typeof custom.unit === "string" ? custom.unit.trim().toLowerCase() : "";
  const unit = CUSTOM_FREQUENCY_UNITS.some((entry) => entry.id === rawUnit) ? rawUnit : "day";
  return { count, unit };
};
const getCustomFrequencyIntervalMs = (custom = null) => {
  const normalized = normalizeCustomFrequency(custom);
  if (!normalized) return null;
  const unitDef = CUSTOM_FREQUENCY_UNITS.find((entry) => entry.id === normalized.unit);
  if (!unitDef) return null;
  return Math.max(1, normalized.count) * unitDef.ms;
};
const resolveFrequencyIntervalMs = (frequencyId, customFrequency = null) => {
  if (frequencyId === "custom") {
    return getCustomFrequencyIntervalMs(customFrequency);
  }
  return getFrequencyIntervalMs(frequencyId);
};
const TEMPTATION_FREQUENCY_ORDER = ["daily", "weekly", "biweekly", "monthly"];
const FREQUENCY_DEMOTION_THRESHOLDS = {
  daily: DAILY_COOLDOWN_TO_WEEKLY_MS,
  weekly: BIWEEKLY_FREQUENCY_THRESHOLD_MS,
  biweekly: MONTHLY_FREQUENCY_THRESHOLD_MS,
};
const getDemotedFrequencyBucket = (bucketId, lastInteractionAt) => {
  if (!bucketId || !Number.isFinite(lastInteractionAt)) return bucketId;
  const threshold = FREQUENCY_DEMOTION_THRESHOLDS[bucketId];
  if (!threshold) return bucketId;
  if (Date.now() - lastInteractionAt < threshold) return bucketId;
  const index = TEMPTATION_FREQUENCY_ORDER.indexOf(bucketId);
  if (index < 0 || index >= TEMPTATION_FREQUENCY_ORDER.length - 1) return bucketId;
  return TEMPTATION_FREQUENCY_ORDER[index + 1];
};
const FREQUENCY_COUNTDOWN_TOKENS = {
  ru: { day: "Ð´", hour: "Ñ‡", minute: "Ð¼" },
  en: { day: "d", hour: "h", minute: "m" },
  es: { day: "d", hour: "h", minute: "m" },
  fr: { day: "j", hour: "h", minute: "m" },
};
const FREQUENCY_CRITICAL_WINDOW_MS = 2 * 60 * 60 * 1000;
const FREQUENCY_REMINDER_INTERVAL_MS = 30 * 60 * 1000;
const FREQUENCY_REMINDER_GRACE_MS = 30 * 60 * 1000;
const getFrequencyIntervalMs = (bucketId) => {
  return TEMPTATION_FREQUENCY_BUCKETS[bucketId]?.intervalMs || null;
};
const formatFrequencyCountdown = (ms, language = DEFAULT_LANGUAGE) => {
  if (!Number.isFinite(ms) || ms <= 0) return "";
  const normalized = Math.max(0, Math.round(ms / (1000 * 60))); // minutes
  const tokens = FREQUENCY_COUNTDOWN_TOKENS[language] || FREQUENCY_COUNTDOWN_TOKENS[DEFAULT_LANGUAGE];
  const minutesInDay = 60 * 24;
  const days = Math.floor(normalized / minutesInDay);
  const hours = Math.floor((normalized % minutesInDay) / 60);
  const minutes = Math.max(0, normalized % 60);
  const parts = [];
  if (days > 0) {
    parts.push(`${days}${tokens.day}`);
  }
  if (hours > 0 && parts.length < 2) {
    parts.push(`${hours}${tokens.hour}`);
  }
  if (parts.length < 2 && minutes > 0) {
    parts.push(`${minutes}${tokens.minute}`);
  }
  if (!parts.length) {
    parts.push(`1${tokens.minute}`);
  }
  return parts.join(" ");
};

const formatCustomFrequencySummary = (customFrequency, t) => {
  const normalized = normalizeCustomFrequency(customFrequency);
  if (!normalized) return "";
  const unitDef = CUSTOM_FREQUENCY_UNITS.find((entry) => entry.id === normalized.unit);
  const unitLabel =
    (unitDef && typeof t === "function" ? t(unitDef.shortKey) : "") || normalized.unit;
  const prefix = typeof t === "function" ? t("frequencyCustomEvery") : "";
  const safePrefix = prefix && prefix.trim().length ? prefix.trim() : "Every";
  return `${safePrefix} ${normalized.count} ${unitLabel}`;
};

const buildFrequencyReminderSchedule = (nextCheckAt, now = Date.now()) => {
  if (!Number.isFinite(nextCheckAt)) return [];
  const windowStart = nextCheckAt - FREQUENCY_CRITICAL_WINDOW_MS;
  const windowEnd = nextCheckAt + FREQUENCY_REMINDER_GRACE_MS;
  if (!Number.isFinite(windowStart) || !Number.isFinite(windowEnd)) return [];
  if (now > windowEnd) return [];
  const triggers = [];
  for (
    let trigger = nextCheckAt - FREQUENCY_REMINDER_INTERVAL_MS;
    trigger <= windowEnd;
    trigger += FREQUENCY_REMINDER_INTERVAL_MS
  ) {
    if (trigger > now && trigger >= windowStart) {
      triggers.push(trigger);
    }
  }
  return triggers.sort((a, b) => a - b);
};

const normalizeInteractionKey = (value) => {
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  return trimmed.length ? trimmed : null;
};

const buildHistoryInteractionMap = (entries = []) => {
  if (!Array.isArray(entries) || !entries.length) return {};
  const map = {};
  entries.forEach((entry) => {
    if (!entry || (entry.kind !== "refuse_spend" && entry.kind !== "spend")) return;
    const templateId =
      normalizeInteractionKey(entry?.meta?.templateId) ||
      normalizeInteractionKey(entry?.meta?.id) ||
      normalizeInteractionKey(entry?.meta?.template);
    if (!templateId) return;
    const timestamp = Number(entry.timestamp) || 0;
    if (!timestamp) return;
    const bucket = map[templateId] || {
      saveCount: 0,
      spendCount: 0,
      timestamps: [],
    };
    bucket.timestamps.push(timestamp);
    if (entry.kind === "refuse_spend") {
      bucket.saveCount += 1;
    } else if (entry.kind === "spend") {
      bucket.spendCount += 1;
    }
    map[templateId] = bucket;
  });
  Object.values(map).forEach((bucket) => {
    bucket.timestamps.sort((a, b) => b - a);
    bucket.lastInteractionAt = bucket.timestamps[0] || null;
    bucket.previousInteractionAt = bucket.timestamps[1] || null;
    bucket.secondPreviousInteractionAt = bucket.timestamps[2] || null;
    delete bucket.timestamps;
  });
  return map;
};

const LANGUAGE_OVERRIDES = {
  es: {
    languageLabel: "Idioma",
    languageTitle: "Elige idioma",
    languageSubtitle: "Configura el idioma y la moneda antes de empezar",
    languageRussian: "Ruso",
    languageEnglish: "InglÃ©s",
    languageSpanish: "EspaÃ±ol",
  },
  fr: {
    languageLabel: "Langue",
    languageTitle: "Choisir une langue",
    languageSubtitle: "Configure la langue et la devise avant de commencer",
    languageRussian: "Russe",
    languageEnglish: "Anglais",
    languageSpanish: "Espagnol",
    languageFrench: "FranÃ§ais",
  },
};
const resolveTranslationValueForLanguage = (language, key, gender = "none") => {
  const normalizedLanguage = normalizeLanguage(language);
  const override = LANGUAGE_OVERRIDES[normalizedLanguage]?.[key];
  const dictionary = TRANSLATIONS[normalizedLanguage] || {};
  let raw =
    override !== undefined
      ? override
      : dictionary[key] ??
        TRANSLATIONS[FALLBACK_LANGUAGE]?.[key] ??
        TRANSLATIONS[DEFAULT_LANGUAGE]?.[key];
  if (raw && typeof raw === "object" && !Array.isArray(raw)) {
    const genderValue = raw[gender];
    if (typeof genderValue === "string") {
      raw = genderValue;
    } else if (typeof raw.none === "string") {
      raw = raw.none;
    } else {
      const fallbackValue = Object.values(raw).find((value) => typeof value === "string");
      raw = fallbackValue !== undefined ? fallbackValue : undefined;
    }
  }
  return raw;
};

const resolveLanguageMapValue = (value, language) => {
  if (!value || typeof value !== "object" || Array.isArray(value)) return null;
  const normalizedLanguage = normalizeLanguage(language);
  const direct = value[normalizedLanguage];
  if (typeof direct === "string" && direct.length) {
    return direct;
  }
  const fallback = value[FALLBACK_LANGUAGE];
  if (typeof fallback === "string" && fallback.length) {
    return fallback;
  }
  const defaultValue = value[DEFAULT_LANGUAGE];
  if (typeof defaultValue === "string" && defaultValue.length) {
    return defaultValue;
  }
  const generic = Object.values(value).find((entry) => typeof entry === "string" && entry.length);
  return typeof generic === "string" ? generic : null;
};
const collectDailyNudgeVariants = (keys = []) => {
  const variants = new Set();
  DAILY_NUDGE_LANGUAGES.forEach((lng) => {
    const dict = TRANSLATIONS[lng] || TRANSLATIONS[FALLBACK_LANGUAGE] || {};
    keys.forEach((key) => {
      const raw = dict[key];
      if (Array.isArray(raw)) {
        raw.forEach((value) => {
          if (typeof value === "string") {
            const normalized = value.trim();
            if (normalized.length) {
              variants.add(normalized);
            }
          }
        });
      } else if (typeof raw === "string") {
        const normalized = raw.trim();
        if (normalized.length) {
          variants.add(normalized);
        }
      }
    });
  });
  return variants;
};
const DAILY_NUDGE_TITLE_VARIANTS = collectDailyNudgeVariants(DAILY_NUDGE_TITLE_KEYS);
const DAILY_NUDGE_BODY_VARIANTS = collectDailyNudgeVariants(DAILY_NUDGE_BODY_KEYS);
const matchesDailyNudgeText = (text, variants) => {
  if (typeof text !== "string") return false;
  const normalized = text.trim();
  return normalized.length > 0 && variants.has(normalized);
};
const isKnownDailyNudgeNotification = (content = {}) => {
  if (!content) return false;
  const data = content.data;
  if (data?.type === DAILY_NUDGE_NOTIFICATION_TAG || data?.tag === DAILY_NUDGE_NOTIFICATION_TAG) {
    return true;
  }
  return (
    matchesDailyNudgeText(content.title, DAILY_NUDGE_TITLE_VARIANTS) &&
    matchesDailyNudgeText(content.body, DAILY_NUDGE_BODY_VARIANTS)
  );
};

const CURRENCIES = ["USD", "AED", "AUD", "BYN", "CAD", "EUR", "GBP", "JPY", "KZT", "KRW", "MXN", "PLN", "RUB", "SAR"];
const normalizeCurrencyCode = (value) => {
  const raw = typeof value === "string" ? value.trim().toUpperCase() : "";
  return CURRENCIES.includes(raw) ? raw : DEFAULT_PROFILE.currency;
};

const CURRENCY_LOCALES = {
  AED: "en-AE",
  AUD: "en-AU",
  BYN: "be-BY",
  CAD: "en-CA",
  EUR: "de-DE",
  GBP: "en-GB",
  JPY: "ja-JP",
  KZT: "kk-KZ",
  KRW: "ko-KR",
  MXN: "es-MX",
  PLN: "pl-PL",
  RUB: "ru-RU",
  SAR: "en-US", // keep layout LTR; symbol handled manually
  USD: "en-US",
};

const HOW_IT_WORKS_STEPS = [
  { id: "impact", emoji: "ðŸ“‰", titleKey: "guideStepRewardTitle", descKey: "guideStepRewardDesc" },
  { id: "mindset", emoji: "ðŸ§ ", titleKey: "guideStepTrackTitle", descKey: "guideStepTrackDesc" },
  { id: "smart", emoji: "ðŸ¤–", titleKey: "guideStepDecisionTitle", descKey: "guideStepDecisionDesc" },
];

const PERSONA_PRESETS = {
  mindful_coffee: {
    id: "mindful_coffee",
    emoji: "â˜•ï¸",
    title: {
      ru: "Ð›ÑŽÐ±Ð¸Ñ‚ÐµÐ»ÑŒ ÐºÐ¾Ñ„Ðµ",
      en: "Coffee devotee",
      es: "Fan del cafÃ©",
      fr: "Fan de cafÃ©",
    },
    description: {
      ru: "ÐŸÐµÑ€Ð²Ð°Ñ Ñ†ÐµÐ»ÑŒ: Ð·Ð°Ð¼ÐµÐ´Ð»Ð¸Ñ‚ÑŒ Ð¿Ð¾Ñ…Ð¾Ð´Ñ‹ Ð·Ð° ÐºÐ¾Ñ„Ðµ Ð½Ð°Ð²Ñ‹Ð½Ð¾Ñ.",
      en: "Goal one: slow down the take-away coffee habit.",
      es: "Primer paso: reducir los cafÃ©s para llevar.",
      fr: "Objectif nÂ°1 : freiner la manie du cafÃ© Ã  emporter.",
    },
    tagline: {
      ru: "ÐšÐ°Ð¶Ð´Ð°Ñ Ð½ÐµÐºÑƒÐ¿Ð»ÐµÐ½Ð½Ð°Ñ Ñ‡Ð°ÑˆÐºÐ° Ð´Ð°Ñ€Ð¸Ñ‚ +{{amount}} ÐºÐ¾Ð¿Ð¸Ð»ÐºÐµ.",
      en: "Every skipped cup adds +{{amount}} to the stash.",
      es: "Cada taza que saltas suma +{{amount}} al cofre.",
      fr: "Chaque tasse Ã©vitÃ©e ajoute +{{amount}} Ã  la cagnotte.",
    },
    habit: {
      emoji: "â˜•ï¸",
      color: "#FFF3E0",
      categories: ["habit", "food", "coffee"],
      basePriceUSD: 5,
      title: {
        ru: "ÐšÐ¾Ñ„Ðµ Ð½Ð°Ð²Ñ‹Ð½Ð¾Ñ",
        en: "Coffee run",
        es: "CafÃ© para llevar",
        fr: "Course cafÃ©",
      },
      description: {
        ru: "Ð¡Ð»Ð°Ð´ÐºÐ¸Ð¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ‚ ÑÐ»Ð°Ð±Ð¾ÑÑ‚Ð¸ ÐºÐ°Ð¶Ð´Ð¾Ðµ ÑƒÑ‚Ñ€Ð¾.",
        en: "Sweet little impulse every morning.",
        es: "Ese pequeÃ±o impulso dulce de cada maÃ±ana.",
        fr: "Petit Ã©cart sucrÃ© de chaque matin.",
      },
    },
  },
  habit_smoking: {
    id: "habit_smoking",
    emoji: "ðŸš¬",
    title: {
      ru: "ÐžÑ‚ÐºÐ°Ð· Ð¾Ñ‚ ÑÐ¸Ð³Ð°Ñ€ÐµÑ‚",
      en: "Quit smoking",
      es: "Dejar de fumar",
      fr: "ArrÃªter de fumer",
    },
    description: {
      ru: "ÐŸÐµÑ€Ð²Ð°Ñ ÑÑ‚ÑƒÐ¿ÐµÐ½ÑŒ: Ð¼ÐµÐ½ÑŒÑˆÐµ ÑÐ»ÑƒÑ‡Ð°Ð¹Ð½Ñ‹Ñ… ÑÐ¸Ð³Ð°Ñ€ÐµÑ‚ Ð¸ Ð¿ÐµÑ€ÐµÐºÑƒÑ€Ð¾Ð².",
      en: "First tier: fewer casual cigarettes and smoke breaks.",
      es: "Primer nivel: menos cigarrillos casuales y descansos de humo.",
      fr: "Premier palier : moins de cigarettes prises Â« au cas oÃ¹ Â» et de pauses clope.",
    },
    tagline: {
      ru: "ÐšÐ°Ð¶Ð´Ð°Ñ Ð¿Ñ€Ð¾Ð¿ÑƒÑ‰ÐµÐ½Ð½Ð°Ñ ÑÐ¸Ð³Ð°Ñ€ÐµÑ‚Ð° Ð´ÐµÑ€Ð¶Ð¸Ñ‚ Ð±ÑŽÐ´Ð¶ÐµÑ‚ Ð² Ñ‚Ð¾Ð½ÑƒÑÐµ.",
      en: "Every skipped cigarette keeps the budget sharp.",
      es: "Cada cigarro que saltas mantiene el presupuesto firme.",
      fr: "Chaque cigarette Ã©vitÃ©e garde ton budget affÃ»tÃ©.",
    },
    habit: {
      emoji: "ðŸš¬",
      color: "#FFE8E0",
      categories: ["habit", "vices"],
      basePriceUSD: 7,
      title: {
        ru: "ÐŸÐ°Ñ‡ÐºÐ° ÑÐ¸Ð³Ð°Ñ€ÐµÑ‚",
        en: "Pack of cigarettes",
        es: "Paquete de cigarrillos",
        fr: "Paquet de cigarettes",
      },
      description: {
        ru: "ÐŸÑ€Ð¾Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ Ð¿ÐµÑ€ÐµÐºÑƒÑ€ Ð·Ð½Ð°Ñ‡Ð¸Ñ‚ ÑƒÑÐºÐ¾Ñ€Ð¸Ñ‚ÑŒ Ð¿Ñ€Ð¾Ð³Ñ€ÐµÑÑ.",
        en: "Skip the smoke break, speed up the progress.",
        es: "Saltarte el cigarro acelera el progreso.",
        fr: "Sauter une pause clope accÃ©lÃ¨re le progrÃ¨s.",
      },
    },
  },
  glam_beauty: {
    id: "glam_beauty",
    emoji: "ðŸ’„",
    audience: ["female"],
    title: {
      ru: "Ð‘ÑŒÑŽÑ‚Ð¸-Ñ„Ð°Ð½Ð°Ñ‚",
      en: "Beauty fan",
      es: "FanÃ¡tica del beauty",
      fr: "Fan de beautÃ©",
    },
    description: {
      ru: "ÐšÐ¾Ð½Ñ‚Ñ€Ð¾Ð»Ð¸Ñ€ÑƒÐµÐ¼ ÑÐ¿Ð¾Ð½Ñ‚Ð°Ð½Ð½Ñ‹Ðµ Ð±ÑŒÑŽÑ‚Ð¸-Ð¿Ð¾ÐºÑƒÐ¿ÐºÐ¸ Ð¸ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ¸.",
      en: "Keep beauty splurges and subs in check.",
      es: "Domina las compras y suscripciones de belleza.",
      fr: "On garde les achats et abonnements beautÃ© sous contrÃ´le.",
    },
    tagline: {
      ru: "ÐžÐ´Ð¸Ð½ Ð¿Ñ€Ð¾Ð¿ÑƒÑ‰ÐµÐ½Ð½Ñ‹Ð¹ Ð±ÑŒÑŽÑ‚Ð¸-Ð´Ñ€Ð¾Ð¿ = {{amount}} Ð´Ð»Ñ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ð¹ Ñ†ÐµÐ»Ð¸.",
      en: "One skipped beauty drop = {{amount}} toward the big goal.",
      es: "Cada beauty drop que saltas suma {{amount}} a la meta mayor.",
      fr: "Chaque drop beautÃ© Ã©vitÃ© = {{amount}} en plus pour ton grand objectif.",
    },
    habit: {
      emoji: "ðŸ’„",
      color: "#FFE5F1",
      categories: ["habit", "beauty"],
      basePriceUSD: 18,
      title: {
        ru: "ÐœÐ¸Ð½Ð¸ Ð±ÑŒÑŽÑ‚Ð¸-Ð´Ñ€Ð¾Ð¿",
        en: "Mini beauty haul",
        es: "Mini compra beauty",
        fr: "Mini craquage beautÃ©",
      },
      description: {
        ru: "Ð¢ÐµÐ½Ð¸, Ð¿Ð¾Ð¼Ð°Ð´Ð° Ð¸ ÐµÑ‰Ñ‘ Ð¾Ð´Ð¸Ð½ Â«Ð½ÑƒÐ¶Ð½Ñ‹Ð¹Â» ÑƒÑ…Ð¾Ð´.",
        en: "Shadow, lipstick and yet another â€œneededâ€ serum.",
        es: "Sombras, labial y otro serum â€œimprescindibleâ€.",
        fr: "Fard, rouge et un Ã©niÃ¨me sÃ©rum soi-disant indispensable.",
      },
    },
  },
  gamer_loot: {
    id: "gamer_loot",
    emoji: "ðŸŽ®",
    audience: ["male"],
    title: {
      ru: "Ð“ÐµÐ¹Ð¼ÐµÑ€",
      en: "Gamer",
      es: "Gamer",
      fr: "Gamer",
    },
    description: {
      ru: "Ð—Ð°Ð¼ÐµÐ´Ð»ÑÐµÐ¼ Ð´Ð¾Ð½Ð°Ñ‚Ñ‹, Ð»ÑƒÑ‚Ð±Ð¾ÐºÑÑ‹ Ð¸ Ð½Ð¾Ñ‡Ð½Ñ‹Ðµ DLC.",
      en: "Cool down loot boxes, microtransactions and DLC binges.",
      es: "Baja el ritmo de loot boxes, DLC y microtransacciones.",
      fr: "On calme les loot boxes, microtransactions et DLC nocturnes.",
    },
    tagline: {
      ru: "ÐšÐ°Ð¶Ð´Ñ‹Ð¹ Ð¿Ñ€Ð¾Ð¿ÑƒÑ‰ÐµÐ½Ð½Ñ‹Ð¹ Ð´Ð¾Ð½Ð°Ñ‚ = {{amount}} Ð½Ð° Ð¼ÐµÑ‡Ñ‚Ñƒ IRL.",
      en: "Every skipped microtransaction frees {{amount}} for IRL goals.",
      es: "Cada donaciÃ³n que evitas libera {{amount}} para metas reales.",
      fr: "Chaque microtransaction Ã©vitÃ©e libÃ¨re {{amount}} pour tes buts IRL.",
    },
    habit: {
      emoji: "ðŸŽ®",
      color: "#D9F7FF",
      categories: ["habit", "fun"],
      basePriceUSD: 10,
      title: {
        ru: "Ð˜Ð³Ñ€Ð¾Ð²Ð¾Ð¹ Ð´Ð¾Ð½Ð°Ñ‚",
        en: "Game microtransaction",
        es: "MicrotransacciÃ³n",
        fr: "Microtransaction",
      },
      description: {
        ru: "ÐŸÐ°Ñ€Ð° Ð¿Ñ€Ð¾Ð¿ÑƒÑ‰ÐµÐ½Ð½Ñ‹Ñ… ÑÐºÐ¸Ð½Ð¾Ð² Ð´Ð°Ñ‘Ñ‚ Ð¿Ð»ÑŽÑ Ðº Ð¿Ñ€Ð¾Ð³Ñ€ÐµÑÑÑƒ.",
        en: "Skip a couple skins, gain momentum.",
        es: "Salta un par de skins y gana impulso.",
        fr: "Saute deux skins et tu gagnes en vitesse.",
      },
    },
  },
  foodie_delivery: {
    id: "foodie_delivery",
    emoji: "ðŸ•",
    title: {
      ru: "Ð›ÑŽÐ±Ð¸Ñ‚ÐµÐ»ÑŒ Ð´Ð¾ÑÑ‚Ð°Ð²ÐºÐ¸",
      en: "Delivery lover",
      es: "Fan de la entrega",
      fr: "Accro Ã  la livraison",
    },
    description: {
      ru: "ÐŸÐµÑ€Ð²Ð°Ñ Ð¼Ð¸ÑÑÐ¸Ñ: Ð¼ÐµÐ½ÑŒÑˆÐµ ÑÐ¿Ð¾Ð½Ñ‚Ð°Ð½Ð½Ð¾Ð¹ ÐµÐ´Ñ‹ Ð¸Ð· Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ.",
      en: "Mission one: fewer random delivery orders.",
      es: "MisiÃ³n uno: menos pedidos impulsivos en apps.",
      fr: "Mission 1 : moins de commandes impulsives via l'app.",
    },
    tagline: {
      ru: "ÐŸÐµÑ€ÐµÑÐºÐ¾Ñ‡Ð¸Ð» Ð´Ð¾ÑÑ‚Ð°Ð²ÐºÑƒ Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ð» {{amount}} Ð½Ð° Ñ€ÐµÐ°Ð»ÑŒÐ½ÑƒÑŽ Ñ†ÐµÐ»ÑŒ.",
      en: "Skip delivery, unlock {{amount}} for real goals.",
      es: "Saltarte la entrega libera {{amount}} para la meta real.",
      fr: "Saute une livraison et libÃ¨re {{amount}} pour ton vrai but.",
    },
    habit: {
      emoji: "ðŸ•",
      color: "#FFF8E3",
      categories: ["habit", "food"],
      basePriceUSD: 15,
      title: {
        ru: "Ð”Ð¾ÑÑ‚Ð°Ð²ÐºÐ° Ð²ÐµÑ‡ÐµÑ€ÐºÐ¾Ð¼",
        en: "Night delivery",
        es: "Delivery nocturno",
        fr: "Livraison nocturne",
      },
      description: {
        ru: "ÐŸÐ¸Ñ†Ñ†Ð°, Ð¿Ð¾ÐºÐµ Ð¸Ð»Ð¸ ÑÑƒÑˆÐ¸? Ð’Ñ‹Ð±Ð¸Ñ€Ð°ÐµÑˆÑŒ Ð¿Ñ€Ð¾Ð³Ñ€ÐµÑÑ.",
        en: "Pizza, poke or sushi? You choose progress.",
        es: "Â¿Pizza, poke o sushi? TÃº eliges el progreso.",
        fr: "Pizza, poke ou sushi ? Tu choisis le progrÃ¨s.",
      },
    },
  },
  online_impulse: {
    id: "online_impulse",
    emoji: "ðŸ“¦",
    title: {
      ru: "ÐžÐ½Ð»Ð°Ð¹Ð½-ÑˆÐ¾Ð¿ÐµÑ€",
      en: "Online shopper",
      es: "Comprador online",
      fr: "Shoppeur en ligne",
    },
    description: {
      ru: "Ð›ÑŽÐ±Ð¸Ñ‚ Ð¸Ð¼Ð¿ÑƒÐ»ÑŒÑÐ¸Ð²Ð½Ñ‹Ðµ Ð¾Ð½Ð»Ð°Ð¹Ð½-Ð¿Ð¾ÐºÑƒÐ¿ÐºÐ¸. ÐšÐ»Ð°Ð´Ñ‘Ð¼ Ð² ÑÐ¿Ð¸ÑÐ¾Ðº, Ð° Ð½Ðµ Ð² ÐºÐ¾Ñ€Ð·Ð¸Ð½Ñƒ.",
      en: "Loves impulse online buys. Park them in a list instead of checkout.",
      es: "Le encantan las compras impulsivas online. Mejor guÃ¡rdalas en una lista.",
      fr: "Fan des achats impulsifs en ligne. On les range dans une liste plutÃ´t que dans le panier.",
    },
    tagline: {
      ru: "ÐšÐ°Ð¶Ð´Ñ‹Ð¹ Ð½ÐµÑÐ¾ÑÑ‚Ð¾ÑÐ²ÑˆÐ¸Ð¹ÑÑ Ð·Ð°ÐºÐ°Ð· = {{amount}} Ð±Ð»Ð¸Ð¶Ðµ Ðº Ñ†ÐµÐ»Ð¸.",
      en: "Every skipped checkout moves {{amount}} closer to your goal.",
      es: "Cada carrito sin pagar acerca {{amount}} a tu meta.",
      fr: "Chaque panier abandonnÃ© rapproche de {{amount}} ta prochaine Ã©tape.",
    },
    habit: {
      emoji: "ðŸ“¦",
      color: "#E8F0FF",
      categories: ["habit", "clothing"],
      basePriceUSD: 25,
      title: {
        ru: "ÐžÐ½Ð»Ð°Ð¹Ð½-Ð¸Ð¼Ð¿ÑƒÐ»ÑŒÑ",
        en: "Online impulse",
        es: "Impulso online",
        fr: "Impulsion en ligne",
      },
      description: {
        ru: "Ð•Ñ‰Ñ‘ Ð¾Ð´Ð½Ð° Ð¿Ð¾ÑÑ‹Ð»ÐºÐ°, ÐºÐ¾Ñ‚Ð¾Ñ€Ð°Ñ Ð¼Ð¾Ð³Ð»Ð° ÑÑ‚Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¾Ð³Ñ€ÐµÑÑÐ¾Ð¼.",
        en: "Another package that could have been progress.",
        es: "Otro paquete que podrÃ­a haber sido progreso.",
        fr: "Un colis de plus qui aurait pu devenir du progrÃ¨s.",
      },
    },
  },
  home_picks: {
    id: "home_picks",
    emoji: "ðŸ›‹ï¸",
    title: {
      ru: "Ð›ÑŽÐ±Ð¸Ñ‚ÐµÐ»ÑŒ Ð°ÐºÑÐµÑÑÑƒÐ°Ñ€Ð¾Ð² Ð´Ð»Ñ Ð´Ð¾Ð¼Ð°",
      en: "Home picks",
      es: "Detalles para el hogar",
      fr: "Fan de dÃ©co",
    },
    description: {
      ru: "Ð“Ð»Ð°Ð²Ð½Ð°Ñ Ñ†ÐµÐ»ÑŒ: Ð¼ÐµÐ½ÑŒÑˆÐµ Ð¸Ð¼Ð¿ÑƒÐ»ÑŒÑÐ¸Ð²Ð½Ð¾Ð³Ð¾ Ð´ÐµÐºÐ¾Ñ€Ð° Ð¸ Ð¿Ð¾ÐºÑƒÐ¿Ð¾Ðº Ð´Ð»Ñ Ð´Ð¾Ð¼Ð°.",
      en: "Main goal: fewer impulse home-decor buys.",
      es: "Meta principal: menos compras impulsivas para el hogar.",
      fr: "Objectif : moins dâ€™achats dÃ©co impulsifs.",
    },
    tagline: {
      ru: "ÐšÐ°Ð¶Ð´Ð°Ñ Ð¿Ñ€Ð¾Ð¿ÑƒÑ‰ÐµÐ½Ð½Ð°Ñ Ð¿Ð¾ÐºÑƒÐ¿ÐºÐ° Ð´Ð»Ñ Ð´Ð¾Ð¼Ð° = {{amount}} Ðº Ñ†ÐµÐ»Ð¸.",
      en: "Every skipped home pick adds {{amount}} toward the goal.",
      es: "Cada compra de hogar que evitas suma {{amount}} a la meta.",
      fr: "Chaque achat dÃ©co Ã©vitÃ© ajoute {{amount}} Ã  ton objectif.",
    },
    habit: {
      emoji: "ðŸ¡",
      color: "#F1F7F2",
      categories: ["habit", "home"],
      basePriceUSD: 22,
      title: {
        ru: "Ð”Ð¾Ð¼Ð°ÑˆÐ½Ð¸Ð¹ Ð´ÐµÐºÐ¾Ñ€",
        en: "Home decor pick",
        es: "Detalle para el hogar",
        fr: "DÃ©co maison",
      },
      description: {
        ru: "Ð’Ð°Ð·Ð°, ÑÐ²ÐµÑ‡Ð° Ð¸Ð»Ð¸ Ð¿Ð¾Ð´ÑƒÑˆÐºÐ° - Ñ€ÐµÑˆÐ°Ð¹ Ð¾ÑÐ¾Ð·Ð½Ð°Ð½Ð½Ð¾.",
        en: "Vase, candle or pillow - decide mindfully.",
        es: "JarrÃ³n, vela o cojÃ­n: decide con calma.",
        fr: "Vase, bougie ou coussin : choisis en conscience.",
      },
    },
  },
  anime_fan: {
    id: "anime_fan",
    emoji: "ðŸŽŒ",
    title: {
      ru: "Ð›ÑŽÐ±Ð¸Ñ‚ÐµÐ»ÑŒ Ð°Ð½Ð¸Ð¼Ðµ",
      en: "Anime fan",
      es: "Fan del anime",
      fr: "Fan d'anime",
    },
    description: {
      ru: "ÐœÐµÑ€Ñ‡, Ð¼Ð°Ð½Ð³Ð° Ð¸ Ñ„Ð¸Ð³ÑƒÑ€ÐºÐ¸. Ð¤Ð¸ÐºÑÐ¸Ñ€ÑƒÐµÐ¼ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ñ‚Ð¾, Ñ‡Ñ‚Ð¾ Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾ Ð²Ð°Ð¶Ð½Ð¾.",
      en: "Merch, manga, figures. Log only what truly matters.",
      es: "Merch, manga, figuras. Registra solo lo que importa.",
      fr: "Merch, manga et figurines : on ne garde que l'essentiel.",
    },
    tagline: {
      ru: "ÐŸÑ€Ð¾Ð¿ÑƒÑÑ‚Ð¸Ð» Ð¾Ñ‡ÐµÑ€ÐµÐ´Ð½Ð¾Ð¹ ÑÐµÑ‚ - {{amount}} Ð² ÐºÐ¾Ð¿Ð¸Ð»ÐºÑƒ Ð¼ÐµÑ‡Ñ‚Ñ‹.",
      en: "Skipped the next merch drop-{{amount}} to your dream.",
      es: "Saltarse el nuevo drop suma {{amount}} a tu sueÃ±o.",
      fr: "Skip le prochain drop = {{amount}} de plus pour ton rÃªve.",
    },
    habit: {
      emoji: "ðŸŽŒ",
      color: "#F2E8FF",
      categories: ["habit", "things"],
      basePriceUSD: 18,
      title: {
        ru: "ÐÐ½Ð¸Ð¼Ðµ-Ð¼ÐµÑ€Ñ‡",
        en: "Anime merch",
        es: "Merch anime",
        fr: "Merch anime",
      },
      description: {
        ru: "Ð¤Ð¸Ð³ÑƒÑ€ÐºÐ°, Ñ‚Ð¾Ð¼Ð¸Ðº Ð¸Ð»Ð¸ Ð±Ñ€ÐµÐ»Ð¾Ðº - Ñ€ÐµÑˆÐ°Ð¹ Ð¾ÑÐ¾Ð·Ð½Ð°Ð½Ð½Ð¾.",
        en: "Figure, volume, or keychain-choose mindfully.",
        es: "Figura, tomo o llavero: decide con consciencia.",
        fr: "Figurine, tome ou porte-clÃ©s : dÃ©cide en conscience.",
      },
    },
  },
  sub_lover: {
    id: "sub_lover",
    emoji: "ðŸ§¾",
    title: {
      ru: "Ð›ÑŽÐ±Ð¸Ñ‚ÐµÐ»ÑŒ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐ¾Ðº",
      en: "Subscription lover",
      es: "Fan de las suscripciones",
      fr: "Fan des abonnements",
    },
    description: {
      ru: "Ð¡Ñ‚Ñ€Ð¸Ð¼Ð¸Ð½Ð³, ÑÐµÑ€Ð²Ð¸ÑÑ‹, Ð´Ð¾Ð¿â€‘Ñ„Ð¸Ñ‡Ð¸. Ð”ÐµÑ€Ð¶Ð¸Ð¼ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ¸ Ð¿Ð¾Ð´ ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»ÐµÐ¼.",
      en: "Streaming, SaaS, extra features. Keep subs under control.",
      es: "Streaming, servicios, extras. MantÃ©n a raya las suscripciones.",
      fr: "Streaming, services et options : on garde les abonnements sous contrÃ´le.",
    },
    tagline: {
      ru: "ÐžÑ‚Ð¼ÐµÐ½Ð¸Ð» Ð»Ð¸ÑˆÐ½ÐµÐµ - {{amount}} Ð¾ÑÑ‚Ð°Ð»Ð°ÑÑŒ Ð² Ñ†ÐµÐ»ÑÑ….",
      en: "Cancel the extra sub-{{amount}} stays with your goals.",
      es: "Cancelar la suscripciÃ³n extra deja {{amount}} en tus metas.",
      fr: "Annule un abonnement de trop et {{amount}} reste pour tes objectifs.",
    },
    habit: {
      emoji: "ðŸ§¾",
      color: "#E9FFF3",
      categories: ["habit", "subscriptions"],
      basePriceUSD: 12,
      title: {
        ru: "Ð›Ð¸ÑˆÐ½ÑÑ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ°",
        en: "Extra subscription",
        es: "SuscripciÃ³n extra",
        fr: "Abonnement en trop",
      },
      description: {
        ru: "ÐœÐµÑÑÑ‡Ð½Ñ‹Ðµ Ð¿Ð»Ð°Ñ‚ÐµÐ¶Ð¸, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ Ð½ÐµÐ·Ð°Ð¼ÐµÑ‚Ð½Ð¾ ÑÑŠÐµÐ´Ð°ÑŽÑ‚ Ð±ÑŽÐ´Ð¶ÐµÑ‚.",
        en: "Monthly payments quietly draining the budget.",
        es: "Pagos mensuales que se comen el presupuesto sin avisar.",
        fr: "Des prÃ©lÃ¨vements mensuels qui mangent le budget sans prÃ©venir.",
      },
    },
  },
  fashion_fan: {
    id: "fashion_fan",
    emoji: "ðŸ‘—",
    title: {
      ru: "Ð›ÑŽÐ±Ð¸Ñ‚ÐµÐ»ÑŒ ÑˆÐ¼Ð¾Ñ‚Ð¾Ðº",
      en: "Fashion lover",
      es: "Fan de la moda",
      fr: "PassionnÃ©Â·e de mode",
    },
    description: {
      ru: "Ð¡Ð»ÐµÐ´Ð¸Ñ‚ Ð·Ð° Ð´Ñ€Ð¾Ð¿Ð°Ð¼Ð¸ Ð¸ ÑÐºÐ¸Ð´ÐºÐ°Ð¼Ð¸. Ð£Ñ‡Ð¸Ð¼ÑÑ Ñ‚Ð¾Ñ€Ð¼Ð¾Ð·Ð¸Ñ‚ÑŒ Ð¸Ð¼Ð¿ÑƒÐ»ÑŒÑÑ‹.",
      en: "Tracks drops and sales. Time to slow the impulses.",
      es: "Sigue drops y rebajas. Toca frenar los impulsos.",
      fr: "Scrute les drops et promos. On apprend Ã  freiner les impulsions.",
    },
    tagline: {
      ru: "ÐšÐ°Ð¶Ð´Ñ‹Ð¹ Ð½ÐµÑÐºÑƒÐ¿Ð»ÐµÐ½Ð½Ñ‹Ð¹ Ð´Ñ€Ð¾Ð¿ = {{amount}} Ðº Ð±Ð¾Ð»ÑŒÑˆÐ¾Ð¼Ñƒ Ð¿Ð»Ð°Ð½Ñƒ.",
      en: "Every unsnapped drop adds {{amount}} to the big plan.",
      es: "Cada drop que dejas pasar suma {{amount}} a tu plan grande.",
      fr: "Chaque drop laissÃ© passer ajoute {{amount}} au grand plan.",
    },
    habit: {
      emoji: "ðŸ‘œ",
      color: "#FFF0F2",
      categories: ["habit", "things"],
      basePriceUSD: 35,
      title: {
        ru: "Ð˜Ð¼Ð¿ÑƒÐ»ÑŒÑÐ½Ñ‹Ð¹ ÑˆÐ¾Ð¿Ð¿Ð¸Ð½Ð³",
        en: "Impulse fashion pick",
        es: "Antojo de moda",
        fr: "Craquage mode",
      },
      description: {
        ru: "Ð¡ÑƒÐ¼ÐºÐ°, Ñ…ÑƒÐ´Ð¸ Ð¸Ð»Ð¸ ÐºÑ€Ð¾ÑÑÑ‹ - Ñ„Ð¸ÐºÑÐ¸Ñ€ÑƒÐ¹, Ð° Ð½Ðµ Ñ…Ð²Ð°Ñ‚Ð°Ð¹.",
        en: "Bag, hoodie or sneakers-log it, don't grab it.",
        es: "Bolso, hoodie o sneakers: regÃ­stralo antes de comprar.",
        fr: "Sac, hoodie ou sneakers : note-le avant de craquer.",
      },
    },
  },
};

const PERSONA_TEMPTATION_PRESETS = {
  glam_beauty: [
    {
      id: "beauty_budget_dupe",
      emoji: "ðŸ’…",
      image:
        "https://images.unsplash.com/photo-1515377905703-c4788e51af15?auto=format&fit=crop&w=900&q=80",
      color: "#FFF0F7",
      categories: ["beauty"],
      audience: ["female"],
      basePriceUSD: 15,
      priceUSD: 15,
      title: {
        ru: "Ð‘ÑŽÐ´Ð¶ÐµÑ‚Ð½Ñ‹Ð¹ Ð±ÑŒÑŽÑ‚Ð¸-Ð´ÑŽÐ¿",
        en: "Budget beauty dupe",
        es: "Dupe beauty econÃ³mico",
        fr: "Dupe beautÃ© abordable",
      },
      description: {
        ru: "Â«ÐŸÐ¾Ñ‡Ñ‚Ð¸ ÐºÐ°Ðº Ð»ÑŽÐºÑÂ» Ð¸Ð· Ð¼Ð°ÑÑ-Ð¼Ð°Ñ€ÐºÐµÑ‚Ð°, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð»ÐµÐ³ÐºÐ¾ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ Ð² ÐºÐ¾Ð¿Ð¸Ð»ÐºÑƒ.",
        en: "A \"luxury lookalike\" from the drugstore that could go straight to savings.",
        es: "Ese \"casi lujo\" de farmacia que puede ir directo al ahorro.",
        fr: "Ce Â« faux luxe Â» de grande surface peut filer direct Ã  la cagnotte.",
      },
    },
    {
      id: "beauty_spa_break",
      emoji: "ðŸ§–â€â™€ï¸",
      image:
        "https://images.unsplash.com/photo-1506617420156-8e4536971650?auto=format&fit=crop&w=900&q=80",
      color: "#FFF7F1",
      categories: ["beauty"],
      audience: ["female"],
      basePriceUSD: 45,
      priceUSD: 45,
      title: {
        ru: "Ð¡Ð¿Ð¾Ð½Ñ‚Ð°Ð½Ð½Ñ‹Ð¹ ÑÐ°Ð»Ð¾Ð½",
        en: "Spontaneous salon day",
        es: "DÃ­a de salÃ³n espontÃ¡neo",
        fr: "Passage salon improvisÃ©",
      },
      description: {
        ru: "ÐœÐ°Ð½Ð¸ÐºÑŽÑ€ Ð¸Ð»Ð¸ ÑƒÑ…Ð¾Ð´ Â«Ð¿Ñ€Ð¾ÑÑ‚Ð¾ Ð¿Ð¾Ñ‚Ð¾Ð¼Ñƒ Ñ‡Ñ‚Ð¾Â». ÐœÐ¾Ð¶Ð½Ð¾ Ð¿Ð¾Ð¹Ð¼Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¾Ð³Ñ€ÐµÑÑ Ð²Ð¼ÐµÑÑ‚Ð¾ Ñ‡ÐµÐºÐ°.",
        en: "Mani or facial \"just because.\" Swap the receipt for progress instead.",
        es: "Mani o facial \"porque sÃ­\". Cambia el ticket por progreso.",
        fr: "Manucure ou soin Â« juste parce que Â». Remplace la note par du progrÃ¨s.",
      },
    },
    {
      id: "beauty_pro_gadget",
      emoji: "ðŸŒ¸",
      image:
        "https://images.unsplash.com/photo-1522335789203-aabd1fc54bc9?auto=format&fit=crop&w=900&q=80",
      color: "#F6ECFF",
      categories: ["beauty"],
      audience: ["female"],
      basePriceUSD: 140,
      priceUSD: 140,
      title: {
        ru: "Ð”Ð¾Ð¼Ð°ÑˆÐ½Ð¸Ð¹ Ð±ÑŒÑŽÑ‚Ð¸-Ð³Ð°Ð´Ð¶ÐµÑ‚",
        en: "At-home beauty gadget",
        es: "Gadget beauty en casa",
        fr: "Appareil beautÃ© maison",
      },
      description: {
        ru: "Ð©Ñ‘Ñ‚ÐºÐ°, LED-Ð¼Ð°ÑÐºÐ° Ð¸Ð»Ð¸ Ð´ÐµÐ²Ð°Ð¹Ñ, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð¼Ð¾Ð¶ÐµÑ‚ Ð¿Ð¾Ð´Ð¾Ð¶Ð´Ð°Ñ‚ÑŒ Ñ€Ð°Ð´Ð¸ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ð¹ Ñ†ÐµÐ»Ð¸.",
        en: "Cleansing brush, LED mask or device that can wait for the big goal.",
        es: "Cepillo, mÃ¡scara LED o gadget que puede esperar a la gran meta.",
        fr: "Brosse, masque LED ou gadget qui peut attendre lâ€™objectif majeur.",
      },
    },
  ],
  home_picks: [
    {
      id: "home_candle_glow",
      emoji: "ðŸ•¯ï¸",
      image:
        "https://images.unsplash.com/photo-1501004318641-b39e6451bec6?auto=format&fit=crop&w=900&q=80",
      color: "#FFF6E8",
      categories: ["home"],
      basePriceUSD: 18,
      priceUSD: 18,
      title: {
        ru: "ÐÑ€Ð¾Ð¼Ð°ÑÐ²ÐµÑ‡Ð°",
        en: "Scented candle",
        es: "Vela aromÃ¡tica",
        fr: "Bougie parfumÃ©e",
      },
      description: {
        ru: "Ð£ÑŽÑ‚Ð½Ñ‹Ð¹ Ñ€Ð¸Ñ‚ÑƒÐ°Ð», ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð¼Ð¾Ð¶ÐµÑ‚ Ð¿Ð¾Ð´Ð¾Ð¶Ð´Ð°Ñ‚ÑŒ.",
        en: "A cozy ritual that can wait.",
        es: "Un ritual cozy que puede esperar.",
        fr: "Un rituel cosy qui peut attendre.",
      },
    },
    {
      id: "home_pillow_drop",
      emoji: "ðŸ›‹ï¸",
      image:
        "https://images.unsplash.com/photo-1519710164239-da123dc03ef4?auto=format&fit=crop&w=900&q=80",
      color: "#EEF3FF",
      categories: ["home"],
      basePriceUSD: 35,
      priceUSD: 35,
      title: {
        ru: "Ð”ÐµÐºÐ¾Ñ€Ð°Ñ‚Ð¸Ð²Ð½Ñ‹Ðµ Ð¿Ð¾Ð´ÑƒÑˆÐºÐ¸",
        en: "Throw pillows",
        es: "Cojines decorativos",
        fr: "Coussins dÃ©co",
      },
      description: {
        ru: "Ð•Ñ‰Ñ‘ Ð¾Ð´Ð¸Ð½ Â«Ð¼Ð¸Ð»Ñ‹Ð¹ ÑÐµÑ‚Â» - Ð¸Ð»Ð¸ ÑˆÐ°Ð³ Ðº Ñ†ÐµÐ»Ð¸.",
        en: "Another cute set, or a step toward your goal.",
        es: "Otro set bonito o un paso a tu meta.",
        fr: "Encore un joli set, ou un pas vers ton objectif.",
      },
    },
    {
      id: "home_wall_art",
      emoji: "ðŸ–¼ï¸",
      image:
        "https://images.unsplash.com/photo-1524758631624-e2822e304c36?auto=format&fit=crop&w=900&q=80",
      color: "#F3F0FF",
      categories: ["home"],
      basePriceUSD: 48,
      priceUSD: 48,
      title: {
        ru: "ÐšÐ°Ñ€Ñ‚Ð¸Ð½Ð°/Ð¿Ð¾ÑÑ‚ÐµÑ€",
        en: "Wall art",
        es: "Arte de pared",
        fr: "DÃ©co murale",
      },
      description: {
        ru: "ÐÐ¾Ð²Ð°Ñ ÑÑÑ‚ÐµÑ‚Ð¸ÐºÐ° Ð¼Ð¾Ð¶ÐµÑ‚ Ð¿Ð¾Ð´Ð¾Ð¶Ð´Ð°Ñ‚ÑŒ Ñ€Ð°Ð´Ð¸ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ð¹ Ñ†ÐµÐ»Ð¸.",
        en: "That new aesthetic can wait for the bigger goal.",
        es: "Esa nueva estÃ©tica puede esperar por la gran meta.",
        fr: "Cette nouvelle esthÃ©tique peut attendre pour le grand objectif.",
      },
    },
  ],
};

const PERSONA_TEMPTATION_LOOKUP = Object.values(PERSONA_TEMPTATION_PRESETS).reduce(
  (acc, list) => acc.concat(list || []),
  []
);

const PERSONA_HABIT_TYPES = {
  mindful_coffee: "coffee",
  habit_smoking: "smoking",
  glam_beauty: "beauty",
  gamer_loot: "gaming",
  foodie_delivery: "delivery",
  online_impulse: "shopping",
  home_picks: "home",
  anime_fan: "anime",
  sub_lover: "subscriptions",
  fashion_fan: "fashion",
};

const PERSONA_SELECTED_EVENTS = {
  coffee: "persona_coffee_selected",
  smoking: "persona_smoking_selected",
  beauty: "persona_beauty_selected",
  gaming: "persona_gaming_selected",
  delivery: "persona_delivery_selected",
  shopping: "persona_shopping_selected",
  home: "persona_home_selected",
  anime: "persona_anime_selected",
  subscriptions: "persona_subscriptions_selected",
  fashion: "persona_fashion_selected",
  custom: "persona_custom_selected",
};

const LANGUAGE_SELECTED_EVENTS = {
  ru: "language_ru_selected",
  en: "language_en_selected",
  es: "language_es_selected",
  fr: "language_fr_selected",
};

const GENDER_SELECTED_EVENTS = {
  female: "gender_female_selected",
  male: "gender_male_selected",
  none: "gender_none_selected",
};

const CURRENCY_SELECTED_EVENTS = {
  USD: "currency_usd_selected",
  AED: "currency_aed_selected",
  AUD: "currency_aud_selected",
  BYN: "currency_byn_selected",
  CAD: "currency_cad_selected",
  EUR: "currency_eur_selected",
  GBP: "currency_gbp_selected",
  JPY: "currency_jpy_selected",
  KZT: "currency_kzt_selected",
  KRW: "currency_krw_selected",
  MXN: "currency_mxn_selected",
  PLN: "currency_pln_selected",
  RUB: "currency_rub_selected",
  SAR: "currency_sar_selected",
};

const getPersonaSelectedEvent = (personaId) => {
  const habitType = PERSONA_HABIT_TYPES[personaId] || "custom";
  return PERSONA_SELECTED_EVENTS[habitType] || null;
};

const getLanguageSelectedEvent = (language) => {
  const normalized = normalizeLanguage(language);
  return LANGUAGE_SELECTED_EVENTS[normalized] || null;
};

const getGenderSelectedEvent = (gender) => {
  const normalized = gender || "none";
  return GENDER_SELECTED_EVENTS[normalized] || null;
};

const getCurrencySelectedEvent = (code) => {
  const normalized = (code || "").toUpperCase();
  return CURRENCY_SELECTED_EVENTS[normalized] || null;
};

const DEFAULT_PERSONA_ID = "mindful_coffee";

const GENDER_OPTIONS = [
  { id: "female", label: { ru: "Ð–ÐµÐ½Ñ‰Ð¸Ð½Ð°", en: "Female", es: "Mujer", fr: "Femme" }, emoji: "ðŸ’â€â™€ï¸" },
  { id: "male", label: { ru: "ÐœÑƒÐ¶Ñ‡Ð¸Ð½Ð°", en: "Male", es: "Hombre", fr: "Homme" }, emoji: "ðŸ§‘â€ðŸ¦±" },
  {
    id: "none",
    label: {
      ru: "ÐÐµ ÑƒÐºÐ°Ð·Ñ‹Ð²Ð°Ñ‚ÑŒ",
      en: "Prefer not to say",
      es: "Prefiero no decirlo",
      fr: "Je prÃ©fÃ¨re ne pas le dire",
    },
    emoji: "ðŸ¤«",
  },
];

const GOAL_PRESETS = [
  { id: "travel", ru: "ÐŸÑƒÑ‚ÐµÑˆÐµÑÑ‚Ð²Ð¸Ñ", en: "Travel", es: "Viajes", fr: "Voyages", emoji: "âœˆï¸", targetUSD: 1500 },
  { id: "tech", ru: "Ð¢ÐµÑ…Ð½Ð¸ÐºÐ°", en: "Tech upgrade", es: "TecnologÃ­a", fr: "Upgrade tech", emoji: "ðŸ’»", targetUSD: 900 },
  {
    id: "daily",
    ru: "Ð•Ð¶ÐµÐ´Ð½ÐµÐ²Ð½Ñ‹Ðµ Ñ†ÐµÐ»Ð¸",
    en: "Daily treats",
    es: "Caprichos diarios",
    fr: "Plaisirs quotidiens",
    emoji: "ðŸ©",
    targetUSD: 250,
  },
  {
    id: "save",
    ru: "ÐŸÑ€Ð¾ÑÑ‚Ð¾ ÐºÐ¾Ð¿Ð¸Ñ‚ÑŒ",
    en: "Rainy-day fund",
    es: "Fondo de respaldo",
    fr: "Fonds de secours",
    emoji: "ðŸ’°",
    targetUSD: 600,
  },
];

const PRIMARY_GOAL_KIND = "primary_goal";
const PRIMARY_GOAL_WISH_ID_LEGACY = "wish_primary_goal";
const getPrimaryGoalWishId = (goalId = "default") => `wish_primary_goal_${goalId}`;

const getGoalPreset = (goalId) => GOAL_PRESETS.find((goal) => goal.id === goalId);
const getGoalDefaultTargetUSD = (goalId) => {
  const preset = getGoalPreset(goalId);
  return preset?.targetUSD || 500;
};

const resolveProfileGoalId = (profile) => {
  if (!profile || typeof profile !== "object") return null;
  if (profile.goal) return profile.goal;
  if (Array.isArray(profile.primaryGoals)) {
    const first = profile.primaryGoals.find((entry) => entry?.id);
    if (first?.id) return first.id;
  }
  return null;
};

const insertWishAfterPrimary = (list = [], newWish) => {
  if (!newWish) return list;
  const lastPrimaryIndex = list.reduce(
    (lastIndex, wish, index) => (wish?.kind === PRIMARY_GOAL_KIND ? index : lastIndex),
    -1
  );
  if (lastPrimaryIndex === -1) {
    return [newWish, ...list];
  }
  const before = list.slice(0, lastPrimaryIndex + 1);
  const after = list.slice(lastPrimaryIndex + 1);
  return [...before, newWish, ...after];
};

const removePrimaryGoalFromProfile = (profileState = {}, goalId) => {
  if (!goalId) return profileState;
  const currentGoals = Array.isArray(profileState.primaryGoals) ? profileState.primaryGoals : [];
  const filtered = currentGoals.filter((goal) => goal.id !== goalId);
  const nextGoalId = filtered[0]?.id || profileState.goal || DEFAULT_PROFILE.goal;
  const nextGoalTarget = filtered[0]
    ? (Number.isFinite(filtered[0].targetUSD) && filtered[0].targetUSD > 0
        ? filtered[0].targetUSD
        : getGoalDefaultTargetUSD(filtered[0].id))
    : getGoalDefaultTargetUSD(nextGoalId);
  return {
    ...profileState,
    primaryGoals: filtered,
    goal: nextGoalId,
    goalTargetUSD: nextGoalTarget,
    goalCelebrated: filtered.length ? profileState.goalCelebrated : false,
  };
};

const updatePrimaryGoalTargetInProfile = (profileState = {}, goalId, targetUSD, extra = {}) => {
  if (!goalId) return profileState;
  const currentGoals = Array.isArray(profileState.primaryGoals) ? profileState.primaryGoals : [];
  const updated = currentGoals.map((goal) =>
    goal.id === goalId ? { ...goal, targetUSD, ...extra } : goal
  );
  const activeGoalId = profileState.goal || updated[0]?.id || goalId;
  const activeEntry = updated.find((goal) => goal.id === activeGoalId) || updated[0] || null;
  const nextTarget = activeEntry
    ? (Number.isFinite(activeEntry.targetUSD) && activeEntry.targetUSD > 0
        ? activeEntry.targetUSD
        : getGoalDefaultTargetUSD(activeEntry.id))
    : getGoalDefaultTargetUSD(activeGoalId);
  return {
    ...profileState,
    primaryGoals: updated,
    goal: activeEntry?.id || activeGoalId,
    goalTargetUSD: nextTarget,
  };
};

const PROFILE_BIO_FALLBACKS = {
  ru: "Ð›ÑŽÐ±Ð»ÑŽ ÐºÑ€Ð°ÑÐ¸Ð²Ñ‹Ðµ Ð²ÐµÑ‰Ð¸, Ð½Ð¾ Ð±Ð¾Ð»ÑŒÑˆÐµ Ð»ÑŽÐ±Ð»ÑŽ Ñ„Ð¸Ð½Ð°Ð½ÑÐ¾Ð²Ñ‹Ð¹ Ð¿Ð»Ð°Ð½",
  en: "I love nice things, but I love my money plan even more",
  es: "Me encantan las cosas bonitas, pero mÃ¡s mi plan financiero",
  fr: "Jâ€™aime les belles choses, mais jâ€™adore encore plus mon plan financier",
};
const PROFILE_BIO_FALLBACK_VALUES = Object.values(PROFILE_BIO_FALLBACKS);
const EMPTY_PROFILE_REPORTS = {
  weekly: [],
  monthly: [],
  updatedAt: null,
};
const normalizeProfileReports = (reports) => {
  if (!reports || typeof reports !== "object") {
    return { ...EMPTY_PROFILE_REPORTS };
  }
  const weekly = Array.isArray(reports.weekly) ? reports.weekly.filter(Boolean) : [];
  const monthly = Array.isArray(reports.monthly) ? reports.monthly.filter(Boolean) : [];
  const updatedAt = typeof reports.updatedAt === "string" ? reports.updatedAt : null;
  return {
    weekly: weekly.slice(0, REPORTS_WEEK_COUNT),
    monthly: monthly.slice(0, REPORTS_MONTH_COUNT),
    updatedAt,
  };
};

const AVATAR_STORAGE_DIR = "profile-avatars/";

const normalizeAvatarStorageValue = (value) => {
  if (!value || typeof value !== "string") return "";
  const documentDir = FileSystem.documentDirectory;
  if (documentDir && value.startsWith(documentDir)) {
    return value.slice(documentDir.length);
  }
  if (value.startsWith("file://")) {
    const marker = "/Documents/";
    const index = value.indexOf(marker);
    if (index !== -1) {
      const candidate = value.slice(index + marker.length);
      if (candidate.startsWith(AVATAR_STORAGE_DIR)) {
        return candidate;
      }
    }
  }
  if (value.startsWith("/")) {
    return value.replace(/^\/+/, "");
  }
  return value;
};

const resolveAvatarUri = (value) => {
  if (!value || typeof value !== "string") return "";
  if (
    value.startsWith("file://") ||
    value.startsWith("content://") ||
    value.startsWith("http://") ||
    value.startsWith("https://") ||
    value.startsWith("data:")
  ) {
    return value;
  }
  const documentDir = FileSystem.documentDirectory;
  if (!documentDir) return value;
  const cleaned = value.replace(/^\/+/, "");
  return `${documentDir}${cleaned}`;
};

const DEFAULT_PROFILE = {
  name: "Nina Cleanova",
  firstName: "Nina",
  lastName: "Cleanova",
  subtitle: "",
  motto: "",
  bio: PROFILE_BIO_FALLBACKS.en,
  avatar: "",
  currency: "USD",
  goal: "save",
  goalTargetUSD: getGoalDefaultTargetUSD("save"),
  primaryGoals: [{ id: "save", targetUSD: getGoalDefaultTargetUSD("save") }],
  goalCelebrated: false,
  goalRenewalPending: false,
  persona: "mindful_coffee",
  gender: "none",
  customSpend: null,
  spendReducesSavings: false,
  incomePayday: DEFAULT_INCOME_PAYDAY,
  spendingProfile: {
    baselineMonthlyWasteUSD: 0,
    baselineStartAt: null,
  },
  joinedAt: null,
  reports: { ...EMPTY_PROFILE_REPORTS },
};

const DEFAULT_PROFILE_PLACEHOLDER = {
  ...DEFAULT_PROFILE,
  name: "",
  firstName: "",
  lastName: "",
  subtitle: "",
  motto: "",
  bio: "",
  goal: null,
  goalTargetUSD: 0,
  primaryGoals: [],
  reports: { ...EMPTY_PROFILE_REPORTS },
};

const resolvePotentialPushStepUSD = (currencyCode = DEFAULT_PROFILE.currency) => {
  const normalizedCode =
    typeof currencyCode === "string" && currencyCode.trim().length > 0
      ? currencyCode.trim().toUpperCase()
      : DEFAULT_PROFILE.currency;
  const convertCode = CURRENCIES.includes(normalizedCode) ? normalizedCode : DEFAULT_PROFILE.currency;
  const localStep =
    POTENTIAL_PUSH_STEP_LOCAL_MAP[normalizedCode] ??
    POTENTIAL_PUSH_STEP_LOCAL_MAP[convertCode] ??
    POTENTIAL_PUSH_STEP_LOCAL_FALLBACK;
  const resolvedUSD = convertFromCurrency(localStep, convertCode);
  if (Number.isFinite(resolvedUSD) && resolvedUSD > 0) {
    return resolvedUSD;
  }
  return POTENTIAL_PUSH_STEP_USD;
};

const INITIAL_REGISTRATION = {
  firstName: "",
  lastName: "",
  motto: "",
  avatar: "",
  currency: "USD",
  gender: "none",
  persona: "mindful_coffee",
  customSpendTitle: "",
  customSpendAmount: "",
  customSpendFrequency: "",
  customSpendCategory: DEFAULT_IMPULSE_CATEGORY,
  incomeMonthlyAmount: "",
  baselineMonthlyWaste: "",
  baselineCapturedAt: null,
  goalSelections: [],
  goalTargetMap: {},
  customGoals: [],
  goalTargetConfirmed: [],
};

const findTemplateById = (id) =>
  DEFAULT_TEMPTATIONS.find((item) => item.id === id) ||
  PERSONA_TEMPTATION_LOOKUP.find((item) => item.id === id);

const INITIAL_FREE_DAY_STATS = {
  total: 0,
  current: 0,
  best: 0,
  lastDate: null,
  achievements: [],
  blockedDate: null,
};

const INITIAL_USAGE_STREAK = {
  total: 0,
  current: 0,
  best: 0,
  lastDate: null,
  lostCount: 0,
};

const FREE_DAY_MILESTONES = [3, 7, 30];
const HEALTH_PER_REWARD = ECONOMY_RULES.baseAchievementReward;
const FREE_DAY_RESCUE_COST = ECONOMY_RULES.freeDayRescueCost;
const FREE_DAY_LOGIN_BLUE_COINS = 2;
const STREAK_RESTORE_BLUE_COINS_PER_DAY = 10;
const STREAK_RESTORE_COST_PER_DAY = STREAK_RESTORE_BLUE_COINS_PER_DAY * BLUE_HEALTH_COIN_VALUE;
const STREAK_PLEDGE_STATUS = {
  IDLE: "idle",
  ACTIVE: "active",
  COMPLETED: "completed",
  FAILED: "failed",
};
const INITIAL_STREAK_PLEDGE = {
  status: STREAK_PLEDGE_STATUS.IDLE,
  targetDays: 0,
  startCount: 0,
  startDayKey: null,
  rewardBlueCoins: 0,
  rewardValue: 0,
  rewardPending: false,
  rewardDeliveredAt: 0,
  lastPromptDayKey: null,
  introSeen: false,
};
const STREAK_PLEDGE_BLUE_COINS_PER_DAY = 1;
const USAGE_STREAK_WEEKLY_BONUS_DAYS = 7;
const USAGE_STREAK_WEEKLY_BONUS_MULTIPLIER = 2;
const USAGE_STREAK_WEEKLY_BONUS_BLUE_COINS = Math.max(
  0,
  Math.round(
    USAGE_STREAK_WEEKLY_BONUS_DAYS *
      STREAK_PLEDGE_BLUE_COINS_PER_DAY *
      USAGE_STREAK_WEEKLY_BONUS_MULTIPLIER
  )
);
const STREAK_PLEDGE_OPTIONS = [
  { id: "week", days: 7, labelKey: "streakPledgeOptionWeek" },
  { id: "two_weeks", days: 14, labelKey: "streakPledgeOptionTwoWeeks" },
  { id: "month", days: 30, labelKey: "streakPledgeOptionMonth" },
  { id: "fifty_days", days: 50, labelKey: "streakPledgeOptionFiftyDays" },
];
const normalizeStreakPledgeStatus = (value) => {
  const values = Object.values(STREAK_PLEDGE_STATUS);
  return values.includes(value) ? value : STREAK_PLEDGE_STATUS.IDLE;
};
const normalizeStreakPledgeState = (value) => {
  if (!value || typeof value !== "object") return { ...INITIAL_STREAK_PLEDGE };
  const status = normalizeStreakPledgeStatus(value.status);
  const targetDays = Math.max(0, Number(value.targetDays) || 0);
  const startCount = Math.max(0, Number(value.startCount) || 0);
  const startDayKey = typeof value.startDayKey === "string" ? value.startDayKey : null;
  const rewardBlueCoins = Math.max(0, Number(value.rewardBlueCoins) || 0);
  const rewardValue = Math.max(0, Number(value.rewardValue) || 0);
  const rewardPending = Boolean(value.rewardPending);
  const rewardDeliveredAt = Math.max(0, Number(value.rewardDeliveredAt) || 0);
  const lastPromptDayKey = typeof value.lastPromptDayKey === "string" ? value.lastPromptDayKey : null;
  const introSeen = Boolean(value.introSeen);
  return {
    ...INITIAL_STREAK_PLEDGE,
    status,
    targetDays,
    startCount,
    startDayKey,
    rewardBlueCoins,
    rewardValue,
    rewardPending,
    rewardDeliveredAt,
    lastPromptDayKey,
    introSeen,
  };
};
const computeStreakPledgeReward = (days) => {
  const normalizedDays = Math.max(0, Number(days) || 0);
  const blueCoins = Math.max(0, Math.round(normalizedDays * STREAK_PLEDGE_BLUE_COINS_PER_DAY));
  const rewardValue = blueCoins * BLUE_HEALTH_COIN_VALUE;
  return { blueCoins, rewardValue };
};
const computeUsageStreakWeeklyBonus = (streakCount) => {
  const normalized = Math.max(0, Number(streakCount) || 0);
  if (!normalized || normalized % USAGE_STREAK_WEEKLY_BONUS_DAYS !== 0) return null;
  const rewardBlueCoins = Math.max(0, USAGE_STREAK_WEEKLY_BONUS_BLUE_COINS);
  if (!rewardBlueCoins) return null;
  const rewardValue = rewardBlueCoins * BLUE_HEALTH_COIN_VALUE;
  const weekIndex = Math.max(1, Math.floor(normalized / USAGE_STREAK_WEEKLY_BONUS_DAYS));
  return { days: normalized, weekIndex, rewardBlueCoins, rewardValue };
};

let activeCurrency = DEFAULT_PROFILE.currency;
const setActiveCurrency = (code) => {
  activeCurrency = CURRENCIES.includes(code) ? code : DEFAULT_PROFILE.currency;
};

const GOALS = [
  {
    id: "starter",
    target: 250,
    copy: {
      ru: { title: "Ð—Ð°Ð±Ñ€Ð¾Ð½ÑŒ 250$", desc: "Ð¼ÐµÐ½ÑŒÑˆÐµ ÐºÐ¾Ñ„ÐµÐµÐ½, Ð±Ð¾Ð»ÑŒÑˆÐµ Ñ€ÐµÐ·ÐµÑ€Ð²Ð°" },
      en: { title: "Lock $250", desc: "skip cafÃ©s, build reserves" },
      es: { title: "Asegura $250", desc: "menos cafÃ©s, mÃ¡s reserva" },
      fr: { title: "Verrouille 250 $", desc: "moins de cafÃ©s, plus de rÃ©serve" },
    },
  },
  {
    id: "focus",
    target: 1000,
    copy: {
      ru: { title: "Ð¡Ð´ÐµÑ€Ð¶Ð¸ 1000$", desc: "Ð¾ÑÐ¾Ð·Ð½Ð°Ð½Ð½Ñ‹Ðµ Ð³Ð°Ð´Ð¶ÐµÑ‚Ñ‹ Ð²Ð¼ÐµÑÑ‚Ð¾ Ñ…Ð°Ð¾ÑÐ°" },
      en: { title: "Hold $1000", desc: "mindful tech deals only" },
      es: { title: "RetÃ©n $1000", desc: "gadgets con consciencia" },
      fr: { title: "Garde 1 000 $", desc: "des gadgets rÃ©flÃ©chis uniquement" },
    },
  },
  {
    id: "pro",
    target: 5000,
    copy: {
      ru: { title: "Ð“ÐµÑ€Ð¾Ð¹ ÑÐºÐ¾Ð½Ð¾Ð¼Ð¸Ð¸", desc: "Ñ‚Ñ‹ Ð·Ð°Ð¼ÐµÐ½ÑÐµÑˆÑŒ Ñ‚Ñ€Ð°Ñ‚Ñ‹ Ð¿Ñ€Ð¸Ð²Ñ‹Ñ‡ÐºÐ¾Ð¹" },
      en: { title: "Savings hero", desc: "deals became a habit" },
      es: { title: "HÃ©roe del ahorro", desc: "los rechazos son tu hÃ¡bito" },
      fr: { title: "HÃ©ros de l'Ã©pargne", desc: "les refus sont devenus ton habitude" },
    },
  },
];

const SAVINGS_TIERS = [
  10,
  20,
  50,
  100,
  250,
  500,
  1000,
  2500,
  5000,
  10000,
  20000,
  50000,
  100000,
  250000,
  500000,
  1000000,
  2500000,
  5000000,
  10000000,
  20000000,
  50000000,
  100000000,
  250000000,
  500000000,
  1000000000,
  2500000000,
  5000000000,
  10000000000,
  20000000000,
];
const LEVEL_XP_BASE_USD = 5;
const LEVEL_XP_SCALE = 200;
const LEVEL_XP_STEP = 140;
const EARLY_LEVEL_XP_MULTIPLIER = 1.3;
const EARLY_LEVEL_XP_STEPS = 2;
const LEVEL_TARGET_MULTIPLIERS = {
  2: 1.2,
  3: 1.05,
  4: 1.19,
  5: 1.1075,
};
const MAX_LEVEL = SAVINGS_TIERS.length + 1;
registerLevelEvents(MAX_LEVEL);
const getLevelXP = (savedUSD = 0) => {
  const normalized = Math.max(0, Number(savedUSD) || 0);
  return LEVEL_XP_SCALE * Math.log1p(normalized / LEVEL_XP_BASE_USD);
};
const getUSDFromLevelXP = (xp = 0) => {
  const normalizedXP = Math.max(0, Number(xp) || 0);
  return LEVEL_XP_BASE_USD * Math.expm1(normalizedXP / LEVEL_XP_SCALE);
};
const getTierTargetsXP = () =>
  Array.from({ length: Math.max(0, MAX_LEVEL - 1) }, (_, index) => {
    const level = index + 2;
    const baseTarget = (index + 1) * LEVEL_XP_STEP;
    let targetXP = baseTarget;
    if (index < EARLY_LEVEL_XP_STEPS) {
      targetXP *= EARLY_LEVEL_XP_MULTIPLIER;
    }
    const multiplier = LEVEL_TARGET_MULTIPLIERS[level];
    if (multiplier) {
      targetXP *= multiplier;
    }
    return targetXP;
  });
const getLevelTwoTargetUSD = (currencyCode = activeCurrency) => {
  const code = currencyCode || activeCurrency;
  const localTargetRounded = Math.round(convertToCurrency(10, code));
  return convertFromCurrency(localTargetRounded, code);
};
const getTierTargetsUSD = (currencyCode = activeCurrency) => {
  const code = currencyCode || activeCurrency;
  const levelTwoTarget = getLevelTwoTargetUSD(code);
  return [levelTwoTarget, ...SAVINGS_TIERS.slice(1)];
};

const intlFallbackWarnings = new Set();
const warnIntlFallback = (currency, locale, error) => {
  const key = `${currency || "unknown"}:${locale || "default"}`;
  if (intlFallbackWarnings.has(key)) return;
  intlFallbackWarnings.add(key);
  console.warn(
    "Intl.NumberFormat fallback",
    currency || "currency_unknown",
    locale || "locale_unknown",
    error?.message || error
  );
};

const formatNumberWithGrouping = (value, fractionDigits = 0) => {
  const safePrecision =
    typeof fractionDigits === "number" && Number.isFinite(fractionDigits)
      ? Math.max(0, Math.min(6, fractionDigits))
      : 0;
  const numericValue = Number(value) || 0;
  const absolute = Math.abs(numericValue);
  const fixed = absolute.toFixed(safePrecision);
  const [integerPart, decimalPart] = fixed.split(".");
  const groupedInteger = integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, " ");
  const sign = numericValue < 0 ? "-" : "";
  if (safePrecision > 0 && decimalPart) {
    return `${sign}${groupedInteger}.${decimalPart}`;
  }
  return `${sign}${groupedInteger}`;
};

const formatCurrencyFallback = (value, currency, fractionDigits = 0) => {
  const digits = formatNumberWithGrouping(value, fractionDigits);
  const isRtl = RTL_CURRENCIES.has(currency);
  const symbol = CURRENCY_SIGNS[currency] || (isRtl ? "" : "$");
  const prefix = isRtl ? `${LTR_MARK}${symbol}` : symbol;
  return `${prefix}${digits}`;
};

const formatCurrency = (value = 0, currency = activeCurrency, options = null) => {
  const locale = CURRENCY_LOCALES[currency] || "en-US";
  const displayPrecision = getCurrencyDisplayPrecision(currency);
  const precisionOverride =
    typeof options?.precisionOverride === "number" && Number.isFinite(options.precisionOverride)
      ? Math.max(0, Math.min(6, options.precisionOverride))
      : null;
  const friendlyRequested = Boolean(options?.friendly);
  const friendly = friendlyRequested && precisionOverride === null;
  const baseValue = Number(value) || 0;
  const adjusted = friendly ? applyFriendlyDisplayRounding(baseValue, currency) : baseValue;
  const precision = precisionOverride ?? displayPrecision;
  const normalized = roundCurrencyValue(adjusted, currency, precision);
  const minFractionDigits = precisionOverride !== null ? precision : 0;
  const maxFractionDigits = precision;
  try {
    if (RTL_CURRENCIES.has(currency)) {
      const digits = new Intl.NumberFormat("en-US", {
        minimumFractionDigits: minFractionDigits,
        maximumFractionDigits: maxFractionDigits,
      }).format(normalized);
      const symbol = CURRENCY_SIGNS[currency] || "";
      return `${LTR_MARK}${symbol}${digits}`;
    }
    return new Intl.NumberFormat(locale, {
      style: "currency",
      currency,
      minimumFractionDigits: minFractionDigits,
      maximumFractionDigits: maxFractionDigits,
    }).format(normalized);
  } catch (intlError) {
    warnIntlFallback(currency, locale, intlError);
    try {
      if (RTL_CURRENCIES.has(currency)) {
        const digits = normalized.toLocaleString("en-US", {
          minimumFractionDigits: minFractionDigits,
          maximumFractionDigits: maxFractionDigits,
        });
        const symbol = CURRENCY_SIGNS[currency] || "";
        return `${LTR_MARK}${symbol}${digits}`;
      }
      const digits = normalized.toLocaleString(locale, {
        minimumFractionDigits: minFractionDigits,
        maximumFractionDigits: maxFractionDigits,
      });
      const symbol = CURRENCY_SIGNS[currency] || "$";
      return `${symbol}${digits}`;
    } catch (localeError) {
      warnIntlFallback(currency, locale, localeError);
      return formatCurrencyFallback(normalized, currency, maxFractionDigits);
    }
  }
};

const formatCurrencyWhole = (value = 0, currency = activeCurrency, precisionOverride = null) => {
  const locale = CURRENCY_LOCALES[currency] || "en-US";
  const basePrecision = getCurrencyDisplayPrecision(currency);
  const normalizedPrecision =
    typeof precisionOverride === "number" && Number.isFinite(precisionOverride)
      ? Math.max(0, Math.min(6, precisionOverride))
      : basePrecision;
  const rounded = roundCurrencyValue(Number(value) || 0, currency, normalizedPrecision);
  try {
    if (RTL_CURRENCIES.has(currency)) {
      const digits = new Intl.NumberFormat("en-US", {
        minimumFractionDigits: normalizedPrecision,
        maximumFractionDigits: normalizedPrecision,
      }).format(rounded);
      const symbol = CURRENCY_SIGNS[currency] || "";
      return `${LTR_MARK}${symbol}${digits}`;
    }
    return new Intl.NumberFormat(locale, {
      style: "currency",
      currency,
      minimumFractionDigits: normalizedPrecision,
      maximumFractionDigits: normalizedPrecision,
    }).format(rounded);
  } catch (intlError) {
    warnIntlFallback(currency, locale, intlError);
    try {
      if (RTL_CURRENCIES.has(currency)) {
        const digits = rounded.toLocaleString("en-US", {
          minimumFractionDigits: normalizedPrecision,
          maximumFractionDigits: normalizedPrecision,
        });
        const symbol = CURRENCY_SIGNS[currency] || "";
        return `${LTR_MARK}${symbol}${digits}`;
      }
      const digits = rounded.toLocaleString(locale, {
        minimumFractionDigits: normalizedPrecision,
        maximumFractionDigits: normalizedPrecision,
      });
      const symbol = CURRENCY_SIGNS[currency] || "$";
      return `${symbol}${digits}`;
    } catch (localeError) {
      warnIntlFallback(currency, locale, localeError);
      return formatCurrencyFallback(rounded, currency, normalizedPrecision);
    }
  }
};

const splitCurrencyLabel = (label = "", currency = activeCurrency) => {
  if (!label) return { value: "", symbol: "" };
  const normalized = `${label}`.replace(/[\u00A0\u202F]/g, " ").trim();
  if (!normalized) return { value: "", symbol: "" };
  const preferredSymbol = CURRENCY_SIGNS[currency] || "";
  const hasPreferredSymbol = preferredSymbol && normalized.includes(preferredSymbol);
  const fallbackSymbol = normalized.replace(/[-\d\s.,]/g, "").trim();
  const symbol = hasPreferredSymbol ? preferredSymbol : fallbackSymbol;
  const value = symbol ? normalized.replace(symbol, "").trim() : normalized;
  return {
    value: value.replace(/\s{2,}/g, " "),
    symbol,
  };
};

const getCopyForPurchase = (item, language, t) => {
  if (item.copy?.[language]) return item.copy[language];
  const product = DEFAULT_TEMPTATIONS.find((prod) => prod.id === item.productId);
  if (product) {
    return {
      title: product.title?.[language] || product.title?.en || product.id,
      desc: product.description?.[language] || product.description?.en || t("defaultDealDesc"),
    };
  }
  return {
    title: t("defaultDealTitle"),
    desc: t("defaultDealDesc"),
  };
};

const parseColor = (value) => {
  if (typeof value !== "string") return { r: 0, g: 0, b: 0 };
  if (value.startsWith("#")) {
    const full =
      value.length === 4
        ? `#${value[1]}${value[1]}${value[2]}${value[2]}${value[3]}${value[3]}`
        : value;
    const num = parseInt(full.slice(1), 16);
    if (Number.isNaN(num)) return { r: 0, g: 0, b: 0 };
    return { r: (num >> 16) & 255, g: (num >> 8) & 255, b: num & 255 };
  }
  const rgbMatch = value.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/i);
  if (rgbMatch) {
    return { r: Number(rgbMatch[1]), g: Number(rgbMatch[2]), b: Number(rgbMatch[3]) };
  }
  return { r: 0, g: 0, b: 0 };
};

const blendColors = (colorA, colorB, ratio = 0.5) => {
  const clamp = (num) => Math.max(0, Math.min(255, Math.round(num)));
  const t = Math.max(0, Math.min(1, ratio));
  const a = parseColor(colorA);
  const b = parseColor(colorB);
  const r = clamp(a.r * (1 - t) + b.r * t);
  const g = clamp(a.g * (1 - t) + b.g * t);
  const bl = clamp(a.b * (1 - t) + b.b * t);
  return `rgb(${r}, ${g}, ${bl})`;
};

const blendHexColors = (colorA, colorB, ratio = 0.5) => {
  const clamp = (num) => Math.max(0, Math.min(255, Math.round(num)));
  const toHex = (num) => clamp(num).toString(16).padStart(2, "0");
  const t = Math.max(0, Math.min(1, ratio));
  const a = parseColor(colorA);
  const b = parseColor(colorB);
  const r = a.r * (1 - t) + b.r * t;
  const g = a.g * (1 - t) + b.g * t;
  const bl = a.b * (1 - t) + b.b * t;
  return `#${toHex(r)}${toHex(g)}${toHex(bl)}`;
};

const colorWithAlpha = (color, alpha = 1) => {
  const normalized = Math.max(0, Math.min(1, alpha));
  const { r, g, b } = parseColor(color);
  return `rgba(${r}, ${g}, ${b}, ${normalized})`;
};

const getTierProgress = (savedUSD = 0, currencyCode = activeCurrency) => {
  const tierTargetsXP = getTierTargetsXP();
  const savedXP = getLevelXP(savedUSD);
  let previousTargetXP = 0;
  for (let i = 0; i < tierTargetsXP.length; i += 1) {
    const targetXP = tierTargetsXP[i];
    if (savedXP < targetXP) {
      return {
        level: i + 1,
        prevTargetUSD: getUSDFromLevelXP(previousTargetXP),
        nextTargetUSD: getUSDFromLevelXP(targetXP),
      };
    }
    previousTargetXP = targetXP;
  }
  return {
    level: tierTargetsXP.length + 1,
    prevTargetUSD: getUSDFromLevelXP(previousTargetXP),
    nextTargetUSD: null,
  };
};

const resolveTemptationTitle = (item, language, override) => {
  if (override) return override;
  if (item.titleOverride) return item.titleOverride;
  const source = item.title;
  if (typeof source === "string") return source;
  return (
    source?.[language] ||
    source?.en ||
    (typeof source === "object" ? Object.values(source)[0] : null) ||
    "Goal"
  );
};

const buildTemptationDisplayTitle = (emojiValue, titleValue, fallbackTitle = "Goal") => {
  const emoji = (emojiValue || "").trim();
  const title = (titleValue || "").trim() || fallbackTitle || "";
  return emoji ? `${emoji} ${title}`.trim() : title;
};

const getTemptationPrice = (item) => {
  const price = typeof item?.priceUSD === "number" ? item.priceUSD : item?.basePriceUSD;
  if (typeof price === "number" && !Number.isNaN(price)) {
    return price;
  }
  return 0;
};

const getTemptationPricePrecision = (item) => {
  if (!item) return null;
  const precision = item.pricePrecision;
  if (typeof precision === "number" && Number.isFinite(precision) && precision >= 0) {
    return precision;
  }
  return null;
};

const formatTemptationPriceLabel = (item, currency) => {
  const priceUSD = getTemptationPrice(item);
  const precision = getTemptationPricePrecision(item);
  const hasOverride = precision !== null;
  return formatCurrency(convertToCurrency(priceUSD, currency), currency, {
    friendly: !hasOverride,
    precisionOverride: hasOverride ? precision : null,
  });
};

const filterTemptationsByPrice = (list, limitUSD) => {
  if (!Array.isArray(list)) return [];
  if (!Number.isFinite(limitUSD)) return list;
  return list.filter((item) => isCustomTemptation(item) || getTemptationPrice(item) <= limitUSD);
};

const isDailyChallengePopularTemplate = (template) => {
  if (!template || !template.id) return false;
  if (DAILY_CHALLENGE_POPULAR_TEMPLATE_IDS.has(template.id)) return true;
  if (isCustomTemptation(template) || template.quickTemptation) {
    const priceUSD = getTemptationPrice(template);
    return (
      Number.isFinite(priceUSD) &&
      priceUSD > 0 &&
      priceUSD <= DAILY_CHALLENGE_POPULAR_CUSTOM_PRICE_CAP_USD
    );
  }
  return false;
};

function TemptationCardComponent({
  item,
  language,
  colors,
  onAction,
  playSound,
  onAmountSliderToggle,
  t,
  currency = activeCurrency,
  stats = {},
  feedback,
  titleOverride,
  descriptionOverride = null,
  goalLabel = null,
  isWishlistGoal = false,
  isFocusTarget = false,
  editCategoryValue = DEFAULT_IMPULSE_CATEGORY,
  onEditCategoryChange,
  onToggleEdit,
  isEditing = false,
  editTitleValue = "",
  editPriceValue = "",
  editGoalLabel = "",
  editEmojiValue = "",
  editDescriptionValue = "",
  onEditTitleChange,
  onEditPriceChange,
  onEditEmojiChange,
  onEditDescriptionChange,
  onEditSave,
  onEditCancel,
  onEditDelete,
  onEditGoalSelect,
  onSwipeDelete,
  onSwipeArchive,
  showEditorInline = false,
  cardStyle = null,
  isPrimaryTemptation = false,
  isArchived = false,
  tutorialHighlightMode = null,
  tutorialHighlightMeasureTick = 0,
  tutorialHighlightOffset = null,
  onTutorialHighlightLayoutChange = null,
  interaction = null,
  interactionRefreshKey = "",
  allowThinkAction = true,
  onFocusBadgePress,
  budgetStatus = null,
  budgetAlertText = null,
}) {
  const title = resolveTemptationTitle(item, language, titleOverride);
  const isCustomCard =
    Array.isArray(item?.categories) && item.categories.some((category) => category === "custom");
  const descriptionString = typeof item.description === "string" ? item.description : null;
  const descriptionMap =
    item.description && typeof item.description === "object" && !Array.isArray(item.description)
      ? item.description
      : null;
  const customDescriptionFallback = isCustomCard
    ? buildCustomTemptationDescription(item?.gender || "none")
    : null;
  const customLanguageFallback = customDescriptionFallback
    ? resolveLanguageMapValue(customDescriptionFallback, language)
    : null;
  const descriptionLanguageValue = descriptionMap ? resolveLanguageMapValue(descriptionMap, language) : null;
  let resolvedDesc = descriptionOverride || null;
  if (!resolvedDesc) {
    const baseDescription = descriptionLanguageValue || descriptionString || "";
    resolvedDesc = isCustomCard ? baseDescription || customLanguageFallback || "" : baseDescription;
  }
  const desc = resolvedDesc || "";
  const tutorialHighlightActive = Boolean(tutorialHighlightMode);
  const tutorialHighlightActions = tutorialHighlightMode === "actions";
  const tutorialHighlightSwipe = tutorialHighlightMode === "swipe";
  const tutorialHighlightThink = tutorialHighlightMode === "think" && allowThinkAction;
  const tutorialHighlightFrame = tutorialHighlightSwipe || tutorialHighlightActions;
  const tutorialHighlightCardRef = useRef(null);
  const updateTutorialHighlightLayout = useCallback(() => {
    if (typeof onTutorialHighlightLayoutChange !== "function") return;
    if (!tutorialHighlightActive) {
      onTutorialHighlightLayoutChange(null);
      return;
    }
    const node = tutorialHighlightCardRef.current;
    const measureTarget = node && typeof node.measureInWindow !== "function"
      ? node.getNode?.()
      : node;
    if (!measureTarget || typeof measureTarget.measureInWindow !== "function") return;
    requestAnimationFrame(() => {
      measureTarget.measureInWindow((x, y, width, height) => {
        const androidFineTune =
          Platform.OS === "android"
            ? (Number.isFinite(tutorialHighlightOffset)
                ? tutorialHighlightOffset
                : ANDROID_TUTORIAL_HIGHLIGHT_OFFSET) + (RNStatusBar.currentHeight || 0)
            : 0;
        onTutorialHighlightLayoutChange({
          x,
          y: y + androidFineTune,
          width,
          height,
        });
      });
    });
  }, [onTutorialHighlightLayoutChange, tutorialHighlightActive]);
  const handleTutorialCardLayout = useCallback(() => {
    updateTutorialHighlightLayout();
  }, [updateTutorialHighlightLayout]);
  useEffect(() => {
    updateTutorialHighlightLayout();
    const timer = setTimeout(() => {
      updateTutorialHighlightLayout();
    }, 300);
    return () => clearTimeout(timer);
  }, [updateTutorialHighlightLayout]);
  useEffect(() => {
    if (!tutorialHighlightActive) return;
    const frame = requestAnimationFrame(() => updateTutorialHighlightLayout());
    return () => cancelAnimationFrame(frame);
  }, [tutorialHighlightActive, tutorialHighlightMeasureTick, updateTutorialHighlightLayout]);
  useEffect(() => {
    if (!tutorialHighlightActive) return;
    const subscription = Dimensions.addEventListener("change", updateTutorialHighlightLayout);
    return () => {
      if (subscription?.remove) {
        subscription.remove();
      } else if (typeof subscription === "function") {
        subscription();
      }
    };
  }, [tutorialHighlightActive, updateTutorialHighlightLayout]);
  useEffect(() => {
    return () => {
      if (typeof onTutorialHighlightLayoutChange === "function") {
        onTutorialHighlightLayoutChange(null);
      }
    };
  }, [onTutorialHighlightLayoutChange]);
  const highlight = true;
  const isDarkTheme = colors.background === THEMES.dark.background;
  const baseColor = item.color || colors.card;
  const focusActive = isFocusTarget && !showEditorInline;
  const darkCardPalette = highlight
    ? {
        background: blendColors(baseColor, "#2B1A00", 0.4),
        border: "#F6C16B",
        text: "#FFEED0",
        muted: "rgba(255,238,208,0.75)",
        badgeBg: "rgba(255,255,255,0.2)",
        badgeBorder: "rgba(255,255,255,0.32)",
        swipeBg: "rgba(255,255,255,0.08)",
        swipeBorder: "rgba(255,255,255,0.18)",
      }
    : {
        background: "#101526",
        border: "rgba(255,255,255,0.08)",
        text: colors.text,
        muted: colors.muted,
        badgeBg: "rgba(255,255,255,0.08)",
        badgeBorder: "rgba(255,255,255,0.18)",
        swipeBg: "rgba(255,255,255,0.04)",
        swipeBorder: "rgba(255,255,255,0.08)",
      };
  const baseCardBackground = isDarkTheme
    ? blendColors(colors.card, baseColor, 0.2)
    : baseColor;
  const cardBackground = baseCardBackground;
  const cardSurfaceColor = isDarkTheme
    ? blendColors(cardBackground, "#FFFFFF", 0.08)
    : lightenColor(cardBackground, 0.18);
  const primaryHighlightColor = Platform.OS === "ios" ? "#FF6F7D" : "#FF4D5A";
  const cardTextColor = isDarkTheme ? darkCardPalette.text : colors.text;
  const cardMutedColor = isDarkTheme ? darkCardPalette.muted : colors.muted;
  const isBudgetOver = budgetStatus === "over";
  const isBudgetLow = budgetStatus === "low";
  const showBudgetAlert = !showEditorInline && (isBudgetOver || isBudgetLow) && !!budgetAlertText;
  const budgetAccentColor = isBudgetOver
    ? isDarkTheme
      ? "#FF9AA5"
      : "#E15555"
    : isBudgetLow
    ? isDarkTheme
      ? "#FFD59A"
      : "#F6C16B"
    : null;
  const budgetSurfaceTint = isBudgetOver
    ? blendColors(cardSurfaceColor, isDarkTheme ? "#351018" : "#FFE7EA", isDarkTheme ? 0.42 : 0.22)
    : isBudgetLow
    ? blendColors(cardSurfaceColor, isDarkTheme ? "#3A2B12" : "#FFF7E0", isDarkTheme ? 0.34 : 0.18)
    : cardSurfaceColor;
  const budgetAlertBackground = isBudgetOver
    ? isDarkTheme
      ? "rgba(255,92,92,0.2)"
      : "rgba(255,92,92,0.12)"
    : isBudgetLow
    ? isDarkTheme
      ? "rgba(246,193,107,0.2)"
      : "rgba(246,193,107,0.14)"
    : "transparent";
  const budgetAlertBorder = isBudgetOver
    ? isDarkTheme
      ? "rgba(255,92,92,0.5)"
      : "rgba(255,92,92,0.35)"
    : isBudgetLow
    ? isDarkTheme
      ? "rgba(246,193,107,0.45)"
      : "rgba(246,193,107,0.35)"
    : "transparent";
  const budgetAlertTextColor = isBudgetOver
    ? isDarkTheme
      ? "#FFC0C0"
      : "#C2153B"
    : isBudgetLow
    ? isDarkTheme
      ? "#FFE6B3"
      : "#5C3A00"
    : cardTextColor;
  const budgetAlertIcon = isBudgetOver ? "â›”" : "âš ï¸";
  const resolvedGoalLabel =
    typeof goalLabel === "string" && goalLabel.trim().length ? goalLabel.trim() : "";
  const coinBurstColor = isDarkTheme ? "#FFD78B" : "#FFF4B3";
  const effectiveWishlistGoal = isWishlistGoal && !isPrimaryTemptation;
  const canAssignGoal = !isPrimaryTemptation;
  const highlightPinned = effectiveWishlistGoal && !showEditorInline;
  const textureSeedSource = item.id || title || "";
  const textureSeed = textureSeedSource
    ? textureSeedSource.split("").reduce((acc, char) => acc + char.charCodeAt(0), 0)
    : 0;
  const textureVariant = textureSeed % CARD_TEXTURE_ACCENTS.length;
  const accentPaletteColor = CARD_TEXTURE_ACCENTS[textureVariant];
  const textureShift = (textureSeed % 7) * 0.02;
  const texturePrimaryColor = blendColors(
    cardBackground,
    isDarkTheme ? "#080808" : "#FFFFFF",
    isDarkTheme ? 0.12 + textureShift : 0.42 + textureShift * 0.5
  );
  const textureAccentColor = blendColors(
    cardBackground,
    isPrimaryTemptation ? "#FF6B8F" : highlightPinned ? "#FFD36E" : accentPaletteColor,
    isDarkTheme ? 0.25 + textureShift : 0.5 + textureShift * 0.5
  );
  const textureHighlightColor = blendColors(
    cardBackground,
    highlightPinned ? "#FFF6C8" : isPrimaryTemptation ? "#FF9FB0" : "#D9F2FF",
    isDarkTheme ? 0.18 : 0.32
  );
  const showCardTexture = false;
  const defaultShadowColor = isDarkTheme ? "rgba(255,255,255,0.55)" : "rgba(15,23,42,0.22)";
  const redShadowColor = Platform.OS === "ios" ? "rgba(244,37,78,0.6)" : "rgba(244,37,78,0.88)";
  const goldShadowColor = "rgba(255,198,110,0.75)";
  const focusShadowColor = "rgba(255,92,92,0.85)";
  const shadowColor = isPrimaryTemptation
    ? redShadowColor
    : focusActive
    ? focusShadowColor
    : highlightPinned
    ? goldShadowColor
    : defaultShadowColor;
  const shadowRadius = isPrimaryTemptation
    ? Platform.OS === "ios" ? 28 : 36
    : focusActive
    ? 34
    : highlightPinned
    ? 30
    : isDarkTheme
    ? 28
    : 22;
  const shadowOpacity = isPrimaryTemptation
    ? Platform.OS === "ios" ? 0.6 : 0.8
    : focusActive
    ? 0.75
    : highlightPinned
    ? 0.6
    : isDarkTheme
    ? 0.55
    : 0.3;
  const shadowElevation = isPrimaryTemptation ? 16 : focusActive ? 18 : highlightPinned ? 14 : isDarkTheme ? 12 : 8;
  const shadowOffsetHeight = isPrimaryTemptation
    ? Platform.OS === "ios" ? 12 : 18
    : focusActive
    ? 16
    : highlightPinned
    ? 16
    : isDarkTheme
    ? 14
    : 12;
  const baseCardShadowStyle = Platform.select({
    ios: {
      shadowColor,
      shadowOpacity,
      shadowRadius,
      shadowOffset: { width: 0, height: shadowOffsetHeight },
    },
    android: {
      elevation: shadowElevation,
      shadowColor,
    },
    default: {},
  });
  const cardShadowStyle = tutorialHighlightActive ? null : baseCardShadowStyle;
  const defaultGoalBadgeBackground = isDarkTheme ? "rgba(255,255,255,0.08)" : "rgba(0,0,0,0.04)";
  const defaultGoalBadgeBorder = isDarkTheme ? "rgba(255,255,255,0.24)" : "rgba(0,0,0,0.08)";
  const defaultGoalBadgeText = isDarkTheme ? "#FFF7E1" : colors.text;
  const hasGoalAssigned = !!resolvedGoalLabel;
  const refuseCount = stats?.count || 0;
  const totalRefusedLabel = formatCurrency(
    convertToCurrency(stats?.totalUSD || 0, currency),
    currency
  );
  const priceUSD = getTemptationPrice(item);
  const showThinkAction = allowThinkAction && priceUSD > 50;
  const actionConfig = [];
  if (showThinkAction) {
    actionConfig.push({ type: "maybe", label: t("maybeAction"), variant: "outline" });
  }
  actionConfig.push(
    { type: "save", label: t("saveAction"), variant: "primary" },
    { type: "spend", label: t("spendAction"), variant: "ghost" }
  );
  const interactionEntry = interaction || {};
  const frequencyId = interactionEntry.frequency || null;
  const lastInteractionAt = Number(interactionEntry.lastInteractionAt) || 0;
  const lastTimerResetAt = Number(interactionEntry.lastTimerResetAt) || 0;
  const effectiveIntervalMs =
    Number(interactionEntry.intervalMs) ||
    (frequencyId ? getFrequencyIntervalMs(frequencyId) : null) ||
    (lastInteractionAt ? DAILY_FREQUENCY_INTERVAL_MS : null);
  const rawNextCheckAt = Number(interactionEntry.nextCheckAt);
  const nextCheckAt =
    Number.isFinite(rawNextCheckAt) && rawNextCheckAt > 0 ? rawNextCheckAt : null;
  const derivedDueAt =
    effectiveIntervalMs && lastInteractionAt ? lastInteractionAt + effectiveIntervalMs : null;
  const rawDueAt =
    Number.isFinite(derivedDueAt) && Number.isFinite(nextCheckAt)
      ? Math.max(derivedDueAt, nextCheckAt)
      : Number.isFinite(derivedDueAt)
      ? derivedDueAt
      : nextCheckAt;
  const hasTimerSource = Number.isFinite(rawDueAt) && Boolean(lastInteractionAt);
  const minuteTick = useMinuteTicker(hasTimerSource);
  const timerReference = Number.isFinite(minuteTick)
    ? Math.max(minuteTick, lastInteractionAt, lastTimerResetAt)
    : Date.now();
  const timerExpired = hasTimerSource && rawDueAt <= timerReference;
  const timeRemaining = hasTimerSource ? rawDueAt - timerReference : null;
  const timerCritical =
    hasTimerSource &&
    !timerExpired &&
    Number.isFinite(timeRemaining) &&
    timeRemaining <= FREQUENCY_CRITICAL_WINDOW_MS;
  const timerDanger = timerExpired || timerCritical;
  const countdownLabel =
    hasTimerSource && !timerExpired
      ? formatFrequencyCountdown(rawDueAt - timerReference, language)
      : "";
  const timerLabel = hasTimerSource
    ? timerExpired
      ? t("frequencyTimerDue")
      : t("frequencyTimerLabel", { time: countdownLabel })
    : null;
  const archiveSwipeLabel = isArchived ? t("archiveSwipeRestore") : t("archiveSwipeAdd");
  const archiveSwipeIcon = isArchived ? "â†©ï¸" : "ðŸ“¦";
  const [coinBursts, setCoinBursts] = useState([]);
  const messageActive = feedback?.message;
  const burstKey = feedback?.burstKey;
  const translateX = useRef(new Animated.Value(0)).current;
  const swipeActionRef = useRef(false);
  const [amountSliderVisible, setAmountSliderVisible] = useState(false);
  const [amountSliderAction, setAmountSliderAction] = useState(null);
  const [amountSliderValue, setAmountSliderValue] = useState(0.5);
  const [amountSliderInteracted, setAmountSliderInteracted] = useState(false);
  const [amountSliderTrackWidth, setAmountSliderTrackWidth] = useState(0);
  const [amountSliderBaseOverrideUSD, setAmountSliderBaseOverrideUSD] = useState(null);
  const [amountManualVisible, setAmountManualVisible] = useState(false);
  const [amountManualValue, setAmountManualValue] = useState("");
  const [amountManualError, setAmountManualError] = useState("");
  const amountSliderBaseOverrideUSDRef = useRef(null);
  const amountSliderManualUSDRef = useRef(null);
  const amountSliderValueRef = useRef(0.5);
  const amountSliderInteractedRef = useRef(false);
  const amountSliderTrackWidthRef = useRef(0);
  const amountSliderTrackPageXRef = useRef(0);
  const amountSliderTrackRef = useRef(null);
  const amountSliderStepRef = useRef(null);
  const amountSliderHapticCooldownRef = useRef(0);
  const amountSliderRafRef = useRef(null);
  const amountSliderPendingValueRef = useRef(null);
  const lastAmountUSD = Number(interaction?.lastAmountUSD) || 0;
  const defaultBaseAmountUSD =
    lastAmountUSD > 0
      ? lastAmountUSD
      : priceUSD > 0
      ? priceUSD
      : 1;
  const resolvedBaseAmountUSD =
    Number(amountSliderBaseOverrideUSD) > 0
      ? Number(amountSliderBaseOverrideUSD)
      : defaultBaseAmountUSD;
  useEffect(() => {
    translateX.setValue(0);
  }, [item.id, translateX]);

  const amountSliderMinUSD = 0;
  const amountSliderMaxUSD = Math.max(resolvedBaseAmountUSD * 2, resolvedBaseAmountUSD);
  const amountSliderAmountUSD =
    amountSliderMinUSD + amountSliderValue * (amountSliderMaxUSD - amountSliderMinUSD);
  const amountSliderLocalValue = snapCurrencyValue(
    convertToCurrency(amountSliderAmountUSD, currency),
    currency
  );
  const amountSliderLabel = formatCurrency(amountSliderLocalValue, currency);
  const amountSliderMinLabel = formatCurrency(
    convertToCurrency(amountSliderMinUSD, currency),
    currency
  );
  const amountSliderMaxLabel = formatCurrency(
    convertToCurrency(amountSliderMaxUSD, currency),
    currency
  );
  const amountSliderFillWidth = Math.max(
    0,
    Math.min(amountSliderTrackWidth, amountSliderTrackWidth * amountSliderValue)
  );
  const amountSliderThumbX = amountSliderTrackWidth * amountSliderValue;
  const amountSliderThumbSize = 22;
  const amountSliderThumbRadius = amountSliderThumbSize / 2;
  const amountSliderThumbTranslate = amountSliderTrackWidth
    ? Math.max(
        0,
        Math.min(
          amountSliderThumbX - amountSliderThumbRadius,
          amountSliderTrackWidth - amountSliderThumbSize
        )
      )
    : 0;
  const amountSliderAccent =
    amountSliderAction === "spend" ? SPEND_ACTION_COLOR : SAVE_ACTION_COLOR;
  const amountSliderAccentSoft = colorWithAlpha(
    amountSliderAccent,
    isDarkTheme ? 0.28 : 0.22
  );
  const amountSliderTrackBase = isDarkTheme
    ? "rgba(255,255,255,0.16)"
    : "rgba(0,0,0,0.08)";
  const amountSliderSurface = isDarkTheme
    ? colorWithAlpha("#101622", 0.92)
    : colorWithAlpha("#FFFFFF", 0.95);
  const amountSliderBorder = colorWithAlpha(amountSliderAccent, isDarkTheme ? 0.4 : 0.25);
  const amountSliderStepCount = 24;
  const amountSliderHapticCooldownMs = 40;

  const markAmountSliderInteracted = useCallback(() => {
    if (amountSliderInteractedRef.current) return;
    amountSliderInteractedRef.current = true;
    setAmountSliderInteracted(true);
  }, []);

  const updateAmountSliderValue = useCallback(
    (nextValue, { fromUser = false, force = false } = {}) => {
      const clamped = Math.max(0, Math.min(1, Number.isFinite(nextValue) ? nextValue : 0));
      amountSliderValueRef.current = clamped;
      if (fromUser) {
        amountSliderManualUSDRef.current = null;
        markAmountSliderInteracted();
        const stepIndex = Math.round(clamped * amountSliderStepCount);
        if (stepIndex !== amountSliderStepRef.current) {
          amountSliderStepRef.current = stepIndex;
          const now = Date.now();
          if (now - amountSliderHapticCooldownRef.current > amountSliderHapticCooldownMs) {
            triggerSelectionHaptic();
            playSound?.("counter", { skipCooldown: true });
            amountSliderHapticCooldownRef.current = now;
          }
        }
      }
      if (force) {
        if (amountSliderRafRef.current) {
          cancelAnimationFrame(amountSliderRafRef.current);
          amountSliderRafRef.current = null;
        }
        amountSliderPendingValueRef.current = null;
        setAmountSliderValue(clamped);
        return clamped;
      }
      amountSliderPendingValueRef.current = clamped;
      if (amountSliderRafRef.current) {
        return clamped;
      }
      amountSliderRafRef.current = requestAnimationFrame(() => {
        amountSliderRafRef.current = null;
        const pending = amountSliderPendingValueRef.current;
        if (pending === null || pending === undefined) return;
        amountSliderPendingValueRef.current = null;
        setAmountSliderValue(pending);
      });
      return clamped;
    },
    [
      amountSliderHapticCooldownMs,
      amountSliderStepCount,
      markAmountSliderInteracted,
      playSound,
    ]
  );

  const notifyAmountSliderTouch = useCallback(
    (isTouching) => {
      if (typeof onAmountSliderToggle !== "function") return;
      onAmountSliderToggle(Boolean(isTouching), item?.id || null);
    },
    [item?.id, onAmountSliderToggle]
  );

  const openAmountSlider = useCallback(
    (actionType) => {
      if (showEditorInline) return;
      runLayoutAnimation();
      setAmountSliderAction(actionType);
      setAmountSliderVisible(true);
      amountSliderInteractedRef.current = false;
      setAmountSliderInteracted(false);
      amountSliderBaseOverrideUSDRef.current = null;
      amountSliderManualUSDRef.current = null;
      setAmountSliderBaseOverrideUSD(null);
      setAmountManualVisible(false);
      setAmountManualValue("");
      setAmountManualError("");
      amountSliderStepRef.current = Math.round(0.5 * amountSliderStepCount);
      amountSliderHapticCooldownRef.current = 0;
      updateAmountSliderValue(0.5, { fromUser: false });
      triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
      playSound?.("tap", { skipCooldown: true });
    },
    [
      amountSliderStepCount,
      playSound,
      showEditorInline,
      updateAmountSliderValue,
    ]
  );

  const closeAmountSlider = useCallback(() => {
    if (!amountSliderVisible) return;
    runLayoutAnimation();
    setAmountSliderVisible(false);
    setAmountSliderAction(null);
    amountSliderInteractedRef.current = false;
    setAmountSliderInteracted(false);
    amountSliderBaseOverrideUSDRef.current = null;
    amountSliderManualUSDRef.current = null;
    setAmountSliderBaseOverrideUSD(null);
    setAmountManualVisible(false);
    setAmountManualError("");
    notifyAmountSliderTouch(false);
    if (amountSliderRafRef.current) {
      cancelAnimationFrame(amountSliderRafRef.current);
      amountSliderRafRef.current = null;
    }
    amountSliderPendingValueRef.current = null;
  }, [amountSliderVisible, notifyAmountSliderTouch]);

  useEffect(() => {
    if (!amountSliderVisible) return;
    amountSliderTrackWidthRef.current = amountSliderTrackWidth;
  }, [amountSliderTrackWidth, amountSliderVisible]);

  useEffect(() => {
    if (!showEditorInline && !isEditing) return;
    if (!amountSliderVisible) return;
    closeAmountSlider();
  }, [amountSliderVisible, closeAmountSlider, isEditing, showEditorInline]);

  useEffect(() => {
    if (!amountSliderVisible) return;
    amountSliderValueRef.current = 0.5;
    amountSliderStepRef.current = Math.round(0.5 * amountSliderStepCount);
    setAmountSliderValue(0.5);
  }, [amountSliderStepCount, amountSliderVisible, item.id]);

  useEffect(() => {
    return () => {
      notifyAmountSliderTouch(false);
    };
  }, [notifyAmountSliderTouch]);

  useEffect(() => {
    return () => {
      if (amountSliderRafRef.current) {
        cancelAnimationFrame(amountSliderRafRef.current);
        amountSliderRafRef.current = null;
      }
    };
  }, []);

  const commitAmountSliderTrackLayout = useCallback((width, pageX) => {
    const nextWidth = Number(width) || 0;
    if (nextWidth > 0 && Math.abs(amountSliderTrackWidthRef.current - nextWidth) > 0.5) {
      amountSliderTrackWidthRef.current = nextWidth;
      setAmountSliderTrackWidth(nextWidth);
    }
    if (Number.isFinite(pageX)) {
      amountSliderTrackPageXRef.current = pageX;
    }
  }, []);

  const measureAmountSliderTrack = useCallback(() => {
    const trackNode = amountSliderTrackRef.current;
    if (!trackNode?.measureInWindow) return;
    trackNode.measureInWindow((x, _y, width) => {
      commitAmountSliderTrackLayout(width, x);
    });
  }, [commitAmountSliderTrackLayout]);

  const handleAmountSliderTrackLayout = useCallback(
    (event) => {
      const width = Number(event?.nativeEvent?.layout?.width) || 0;
      commitAmountSliderTrackLayout(width, amountSliderTrackPageXRef.current);
      requestAnimationFrame(() => {
        measureAmountSliderTrack();
      });
    },
    [commitAmountSliderTrackLayout, measureAmountSliderTrack]
  );

  useEffect(() => {
    if (!amountSliderVisible) return;
    requestAnimationFrame(() => {
      measureAmountSliderTrack();
    });
  }, [amountSliderVisible, measureAmountSliderTrack]);

  const openAmountManual = useCallback(() => {
    const precision = getCurrencyPrecision(currency);
    const formatted = formatNumberInputValue(amountSliderLocalValue, precision);
    setAmountManualValue(formatted);
    setAmountManualError("");
    setAmountManualVisible(true);
    triggerSelectionHaptic();
    playSound?.("tap", { skipCooldown: true });
  }, [amountSliderLocalValue, currency, playSound]);

  const closeAmountManual = useCallback(() => {
    setAmountManualVisible(false);
    setAmountManualError("");
  }, []);

  const handleAmountManualSave = useCallback(() => {
    const parsedLocal = parseNumberInputValue(amountManualValue);
    if (!Number.isFinite(parsedLocal) || parsedLocal <= 0) {
      setAmountManualError(t("coinEntryManualError"));
      return;
    }
    const normalizedLocal = snapCurrencyValue(parsedLocal, currency);
    const parsedUSD = convertFromCurrency(normalizedLocal, currency);
    if (!Number.isFinite(parsedUSD) || parsedUSD <= 0) {
      setAmountManualError(t("coinEntryManualError"));
      return;
    }
    amountSliderBaseOverrideUSDRef.current = parsedUSD;
    amountSliderManualUSDRef.current = parsedUSD;
    setAmountSliderBaseOverrideUSD(parsedUSD);
    updateAmountSliderValue(0.5, { fromUser: false });
    markAmountSliderInteracted();
    setAmountManualVisible(false);
    setAmountManualError("");
    Keyboard.dismiss();
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    playSound?.("tap", { skipCooldown: true });
  }, [amountManualValue, currency, markAmountSliderInteracted, playSound, t, updateAmountSliderValue]);

  const handleAmountSliderTouch = useCallback(
    (event) => {
      const width = amountSliderTrackWidthRef.current || amountSliderTrackWidth;
      if (!width) return;
      const pageX = Number(event?.nativeEvent?.pageX);
      if (!Number.isFinite(pageX)) return;
      const localX = pageX - amountSliderTrackPageXRef.current;
      const nextValue = localX / width;
      updateAmountSliderValue(nextValue, { fromUser: true });
    },
    [amountSliderTrackWidth, updateAmountSliderValue]
  );

  const amountSliderPanResponder = useMemo(
    () =>
      PanResponder.create({
        onStartShouldSetPanResponder: () => true,
        onMoveShouldSetPanResponder: () => true,
        onPanResponderGrant: (event) => {
          notifyAmountSliderTouch(true);
          handleAmountSliderTouch(event);
        },
        onPanResponderMove: (event) => {
          handleAmountSliderTouch(event);
        },
        onPanResponderRelease: () => {
          updateAmountSliderValue(amountSliderValueRef.current, { force: true });
          notifyAmountSliderTouch(false);
        },
        onPanResponderTerminate: () => {
          updateAmountSliderValue(amountSliderValueRef.current, { force: true });
          notifyAmountSliderTouch(false);
        },
      }),
    [handleAmountSliderTouch, notifyAmountSliderTouch, updateAmountSliderValue]
  );

  const confirmAmountAction = useCallback(
    (actionType) => {
      const manualAmountUSD = Number(amountSliderManualUSDRef.current);
      let normalizedAmount =
        Number.isFinite(manualAmountUSD) && manualAmountUSD > 0 ? manualAmountUSD : 0;
      if (!normalizedAmount) {
        const sliderValue = Math.max(0, Math.min(1, Number(amountSliderValueRef.current) || 0));
        const manualBaseUSD = Number(amountSliderBaseOverrideUSDRef.current);
        const resolvedBaseUSD =
          Number.isFinite(manualBaseUSD) && manualBaseUSD > 0 ? manualBaseUSD : defaultBaseAmountUSD;
        const maxAmountUSD = Math.max(resolvedBaseUSD * 2, resolvedBaseUSD);
        const amountUSD = amountSliderMinUSD + sliderValue * (maxAmountUSD - amountSliderMinUSD);
        const amountLocal = snapCurrencyValue(convertToCurrency(amountUSD, currency), currency);
        normalizedAmount = convertFromCurrency(amountLocal, currency);
      }
      if (!Number.isFinite(normalizedAmount) || normalizedAmount <= 0) {
        triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
        playSound?.("counter", { skipCooldown: true });
        return;
      }
      triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
      closeAmountSlider();
      onAction?.(actionType, item, { amountUSD: normalizedAmount });
    },
    [
      closeAmountSlider,
      currency,
      defaultBaseAmountUSD,
      amountSliderMinUSD,
      item,
      onAction,
      playSound,
    ]
  );

  const handleSwipeRelease = useCallback(
    (dx = 0) => {
      if (!showEditorInline) {
        if (dx > GOAL_SWIPE_THRESHOLD && onSwipeArchive) {
          swipeActionRef.current = true;
          onSwipeArchive(item);
        } else if (dx < -DELETE_SWIPE_THRESHOLD && onSwipeDelete) {
          swipeActionRef.current = true;
          onSwipeDelete(item);
        }
      }
      Animated.timing(translateX, {
        toValue: 0,
        duration: 160,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }).start();
    },
    [item, onSwipeArchive, onSwipeDelete, showEditorInline, translateX]
  );

  const panResponder = useMemo(
    () =>
      PanResponder.create({
        onStartShouldSetPanResponder: () => false,
        onMoveShouldSetPanResponder: (_, gestureState) =>
          !showEditorInline &&
          !amountSliderVisible &&
          Math.abs(gestureState.dx) > Math.abs(gestureState.dy) &&
          Math.abs(gestureState.dx) > 6,
        onPanResponderGrant: () => {
          translateX.stopAnimation();
        },
        onPanResponderMove: (_, gestureState) => {
          if (showEditorInline) return;
          const dx = Math.max(Math.min(gestureState.dx, 150), -180);
          translateX.setValue(dx);
        },
        onPanResponderRelease: (_, gestureState) => {
          handleSwipeRelease(gestureState.dx);
        },
        onPanResponderTerminationRequest: () => false,
        onPanResponderTerminate: () => handleSwipeRelease(0),
      }),
    [amountSliderVisible, handleSwipeRelease, showEditorInline, translateX]
  );

  useEffect(() => {
  }, [messageActive]);

  useEffect(() => {
    if (!burstKey) return;
    const coins = Array.from({ length: 5 }).map((_, index) => ({
      id: `${burstKey}-${index}`,
      progress: new Animated.Value(0),
      offsetX: (Math.random() - 0.5) * 80,
      rotation: (Math.random() > 0.5 ? 1 : -1) * (200 + Math.random() * 160),
      delay: index * 80,
    }));
    setCoinBursts(coins);
    coins.forEach((coin) => {
      Animated.timing(coin.progress, {
        toValue: 1,
        duration: 900,
        delay: coin.delay,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }).start();
    });
    const timeout = setTimeout(() => setCoinBursts([]), 1100);
    return () => clearTimeout(timeout);
  }, [burstKey]);

  const handleCardPress = useCallback(() => {
    if (swipeActionRef.current) {
      swipeActionRef.current = false;
      return;
    }
    if (amountSliderVisible) {
      closeAmountSlider();
      return;
    }
    onToggleEdit?.(item);
  }, [amountSliderVisible, closeAmountSlider, item, onToggleEdit]);

  return (
    <View style={styles.temptationSwipeWrapper}>
      <View
        style={[
          styles.temptationSwipeBackground,
          tutorialHighlightFrame && styles.temptationTutorialSwipeHint,
        ]}
        pointerEvents="none"
      >
        <View
          style={[
            styles.swipeHint,
            styles.swipeHintLeft,
            {
              borderColor: isDarkTheme ? "rgba(255,255,255,0.12)" : colors.border,
              backgroundColor: isDarkTheme ? "rgba(246,193,107,0.2)" : "rgba(246,193,107,0.12)",
            },
          ]}
        >
          <Text style={[styles.swipeHintIcon, { color: GOAL_HIGHLIGHT_COLOR }]}>
            {archiveSwipeIcon}
          </Text>
          <Text style={[styles.swipeHintText, { color: GOAL_HIGHLIGHT_COLOR }]}>
            {archiveSwipeLabel}
          </Text>
        </View>
        <View
          style={[
            styles.swipeHint,
            styles.swipeHintRight,
            {
              borderColor: isDarkTheme ? "rgba(255,255,255,0.12)" : colors.border,
              backgroundColor: isDarkTheme ? "rgba(255,87,115,0.15)" : "rgba(233,61,87,0.12)",
            },
          ]}
        >
          <Text style={[styles.swipeHintIcon, { color: "#E15555" }]}>ðŸ—‘ï¸</Text>
          <Text style={[styles.swipeHintText, { color: "#E15555" }]}>{t("goalSwipeDelete")}</Text>
        </View>
      </View>
    <Animated.View
      ref={tutorialHighlightCardRef}
      onLayout={handleTutorialCardLayout}
      {...panResponder.panHandlers}
      style={[
        styles.temptationCard,
        cardShadowStyle,
        cardStyle,
        {
          backgroundColor: budgetSurfaceTint,
          borderWidth: showBudgetAlert ? 1.2 : 0,
          borderColor: showBudgetAlert ? budgetAccentColor : "transparent",
          transform: [{ translateX }],
        },
        ]}
      >
        <TouchableWithoutFeedback onPress={handleCardPress}>
          <View>
            {showCardTexture && (
              <View pointerEvents="none" style={styles.temptationTextureContainer}>
                <View
                  style={[
                    styles.temptationTextureOverlay,
                    { backgroundColor: texturePrimaryColor, opacity: isDarkTheme ? 0.08 : 0.18 },
                  ]}
                />
                <View
                  style={[
                    styles.temptationTextureOverlay,
                    styles.temptationTextureAccent,
                    { backgroundColor: textureAccentColor },
                  ]}
                />
                <View
                  style={[
                    styles.temptationTextureOverlay,
                    styles.temptationTextureHighlight,
                    { backgroundColor: textureHighlightColor },
                  ]}
                />
              </View>
            )}
      <View
        style={[
          styles.temptationHeader,
          !showEditorInline && effectiveWishlistGoal && canAssignGoal ? { paddingRight: 64 } : null,
        ]}
      >
        {showEditorInline ? (
          <View style={styles.titleEditWrapper}>
            <View
              style={[
                styles.emojiEditWrapper,
                { borderColor: colors.border, backgroundColor: colors.card },
              ]}
            >
              <TextInput
                style={[styles.emojiEditInput, { color: colors.text }]}
                value={editEmojiValue ?? ""}
                onChangeText={onEditEmojiChange}
                placeholder={item.emoji || DEFAULT_TEMPTATION_EMOJI}
                placeholderTextColor={colors.muted}
                selectTextOnFocus
                maxLength={2}
              />
            </View>
            <View style={styles.titleEditInputContainer}>
              <TextInput
                style={[
                  styles.titleEditInput,
                  {
                    borderColor: colors.border,
                    color: colors.text,
                    backgroundColor: colors.card,
                  },
                ]}
                value={editTitleValue}
                onChangeText={onEditTitleChange}
                placeholder={t("priceEditNameLabel")}
                placeholderTextColor={colors.muted}
              />
            </View>
          </View>
        ) : (
          <>
            <View style={styles.emojiDisplayWrapper}>
              <Text style={[styles.temptationEmoji, { color: cardTextColor }]}>{item.emoji || "âœ¨"}</Text>
            </View>
            <Text style={[styles.temptationTitle, { color: cardTextColor }]}>{title}</Text>
          </>
        )}
      </View>
      {!showEditorInline && effectiveWishlistGoal && canAssignGoal && (
        <View style={styles.temptationBadgeStack} pointerEvents="none">
          {hasGoalAssigned && (
            <View
              style={[
                styles.temptationGoalBadge,
                styles.temptationGoalBadgeFloating,
                {
                  backgroundColor: isDarkTheme ? "#F6C16B22" : "#FFF2CC",
                  borderColor: isDarkTheme ? "#F6C16B55" : "#F6C16B",
                },
              ]}
            >
              <Text style={[styles.temptationGoalBadgeText, { color: isDarkTheme ? "#FEEAC4" : "#5C3A00" }]}>
                {t("goalPinnedBadge")}
              </Text>
            </View>
          )}
          {isWishlistGoal && (
            <View
              style={[
                styles.temptationPinnedBadge,
                {
                  borderColor: GOAL_HIGHLIGHT_COLOR,
                  backgroundColor: isDarkTheme ? "rgba(246,193,107,0.2)" : "rgba(246,193,107,0.12)",
                },
              ]}
            >
              <Text style={[styles.temptationPinnedBadgeText, { color: GOAL_HIGHLIGHT_COLOR }]}>
                {t("goalPinnedBadge")}
              </Text>
            </View>
          )}
        </View>
      )}
      {focusActive && (
        <TouchableOpacity
          style={[
            styles.temptationFocusBadge,
            {
              backgroundColor: isDarkTheme ? "rgba(255,92,92,0.15)" : "rgba(255,92,92,0.12)",
              borderColor: isDarkTheme ? "rgba(255,92,92,0.5)" : "rgba(255,92,92,0.45)",
            },
          ]}
          onPress={() => onFocusBadgePress?.(item)}
          activeOpacity={onFocusBadgePress ? 0.7 : 1}
        >
          <Text style={[styles.temptationFocusBadgeText, { color: isDarkTheme ? "#FFC0C0" : "#C2153B" }]}>
            {t("focusBadgeLabel")}
          </Text>
        </TouchableOpacity>
      )}
  {timerLabel && (
        <View
          style={[
            styles.temptationTimerBlock,
            {
              borderColor: timerDanger
                ? "rgba(194,21,59,0.6)"
                : isDarkTheme
                ? "rgba(255,255,255,0.15)"
                : "rgba(0,0,0,0.08)",
              backgroundColor: timerDanger
                ? "rgba(255,92,92,0.12)"
                : isDarkTheme
                ? "rgba(0,0,0,0.25)"
                : "rgba(255,255,255,0.7)",
            },
          ]}
        >
          {timerLabel ? (
            <Text
              style={[
                styles.temptationTimerCountdown,
                { color: timerDanger ? (isDarkTheme ? "#FF9AA5" : "#C2153B") : cardMutedColor },
              ]}
            >
              {timerLabel}
            </Text>
          ) : null}
        </View>
      )}
      {showBudgetAlert && (
        <View
          style={[
            styles.temptationBudgetAlert,
            {
              borderColor: budgetAlertBorder,
              backgroundColor: budgetAlertBackground,
            },
          ]}
        >
          <Text style={[styles.temptationBudgetAlertIcon, { color: budgetAlertTextColor }]}>
            {budgetAlertIcon}
          </Text>
          <Text
            style={[styles.temptationBudgetAlertText, { color: budgetAlertTextColor }]}
            numberOfLines={2}
          >
            {budgetAlertText}
          </Text>
        </View>
      )}
      {showEditorInline ? (
        <TouchableOpacity
          style={[
            styles.temptationGoalBadge,
            styles.temptationGoalBadgeEditable,
            { borderColor: colors.border, backgroundColor: colors.card },
          ]}
          onPress={onEditGoalSelect}
        >
          <Text style={[styles.temptationGoalBadgeText, { color: colors.text }]}>
            {goalLabel || t("goalAssignFieldLabel")}
          </Text>
        </TouchableOpacity>
      ) : null}
      {showEditorInline ? (
        <View style={styles.descriptionEditWrapper}>
          <TextInput
            multiline
            style={[
              styles.descriptionEditInput,
              {
                borderColor: colors.border,
                color: colors.text,
                backgroundColor: colors.card,
              },
            ]}
            value={editDescriptionValue ?? ""}
            onChangeText={onEditDescriptionChange}
            placeholder={t("priceEditDescriptionLabel")}
            placeholderTextColor={colors.muted}
          />
        </View>
      ) : desc ? (
        <Text style={[styles.temptationDesc, { color: cardMutedColor }]}>
          {desc}
        </Text>
      ) : null}
  {refuseCount > 0 && (
        <Text style={[styles.temptationRefuseMeta, { color: cardMutedColor }]}>
          {t("tileRefuseCount", { count: refuseCount, amount: totalRefusedLabel })}
        </Text>
      )}
  {showEditorInline ? (
    <View style={styles.temptationPriceRow}>
      <View
        style={[
          styles.temptationPricePill,
          { borderColor: colors.border, backgroundColor: colors.card },
        ]}
      >
        <TextInput
          style={[
            styles.pricePillInput,
            { color: colors.text },
          ]}
          value={editPriceValue ?? ""}
          onChangeText={onEditPriceChange}
          keyboardType="decimal-pad"
          placeholder={t("priceEditAmountLabel", { currency })}
          placeholderTextColor={colors.muted}
        />
      </View>
    </View>
  ) : hasGoalAssigned ? (
    <View style={styles.temptationGoalRow}>
      <View
        style={[
          styles.temptationGoalBadge,
          styles.temptationGoalBadgeInline,
          {
            backgroundColor: isDarkTheme ? "rgba(246,193,107,0.18)" : "rgba(246,193,107,0.12)",
            borderColor: isDarkTheme ? "rgba(246,193,107,0.55)" : "rgba(246,193,107,0.65)",
          },
        ]}
      >
        <Text style={[styles.temptationGoalBadgeText, { color: isDarkTheme ? "#FEEAC4" : "#5C3A00" }]}>
          {t("goalDestinationLabel")}: {resolvedGoalLabel}
        </Text>
      </View>
    </View>
  ) : null}
      {showEditorInline && (
        <View style={styles.categoryEditSection}>
          <Text style={[styles.categoryEditLabel, { color: colors.muted }]}>
            {t("impulseCategoryLabel")}
          </Text>
          <ImpulseCategorySelector
            value={editCategoryValue || DEFAULT_IMPULSE_CATEGORY}
            onChange={onEditCategoryChange}
            colors={colors}
            language={language}
            compact
            horizontal
            visibleCount={4}
            tall
          />
        </View>
      )}
          </View>
        </TouchableWithoutFeedback>
      {!showEditorInline && amountSliderVisible && (
        <View
          style={[
            styles.temptationAmountPanel,
            { backgroundColor: amountSliderSurface, borderColor: amountSliderBorder },
          ]}
        >
          <View style={styles.temptationAmountHeader}>
            <View style={[styles.temptationAmountPill, { backgroundColor: amountSliderAccentSoft }]}>
              <Text style={[styles.temptationAmountPillText, { color: amountSliderAccent }]}>
                {amountSliderAction === "spend" ? t("spendAction") : t("saveAction")}
              </Text>
            </View>
            <TouchableOpacity style={styles.temptationAmountClose} onPress={closeAmountSlider}>
              <Text style={[styles.temptationAmountCloseText, { color: colors.muted }]}>âœ•</Text>
            </TouchableOpacity>
          </View>
          <TouchableOpacity onPress={openAmountManual} activeOpacity={0.8}>
            <Text style={[styles.temptationAmountValue, { color: cardTextColor }]}>
              {amountSliderLabel}
            </Text>
          </TouchableOpacity>
          <View style={styles.temptationAmountTrackWrap} {...amountSliderPanResponder.panHandlers}>
            <View
              style={[styles.temptationAmountTrack, { backgroundColor: amountSliderTrackBase }]}
              onLayout={handleAmountSliderTrackLayout}
              ref={amountSliderTrackRef}
              collapsable={false}
            >
              <View
                style={[
                  styles.temptationAmountTrackFill,
                  { width: amountSliderFillWidth, backgroundColor: amountSliderAccentSoft },
                ]}
              />
            </View>
            <View
              style={[
                styles.temptationAmountTrackMid,
                { backgroundColor: colorWithAlpha(amountSliderAccent, 0.4) },
              ]}
            />
            <View
              style={[
                styles.temptationAmountThumb,
                {
                  width: amountSliderThumbSize,
                  height: amountSliderThumbSize,
                  borderRadius: amountSliderThumbRadius,
                  borderColor: amountSliderAccent,
                  backgroundColor: colors.card,
                  transform: [{ translateX: amountSliderThumbTranslate }],
                },
              ]}
            >
              <View
                style={[
                  styles.temptationAmountThumbInner,
                  { backgroundColor: amountSliderAccent },
                ]}
              />
            </View>
          </View>
          <View style={styles.temptationAmountScale}>
            <Text style={[styles.temptationAmountScaleText, { color: colors.muted }]}>
              {amountSliderMinLabel}
            </Text>
            <Text style={[styles.temptationAmountScaleText, { color: colors.muted }]}>
              {amountSliderMaxLabel}
            </Text>
          </View>
        </View>
      )}
      {amountManualVisible && (
        <Modal visible transparent animationType="fade" statusBarTranslucent onRequestClose={closeAmountManual}>
          <TouchableWithoutFeedback onPress={closeAmountManual}>
            <View style={styles.coinEntryManualBackdrop}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View
                  style={[
                    styles.coinEntryManualCard,
                    { backgroundColor: colors.card, borderColor: colors.border },
                  ]}
                >
                  <Text style={[styles.coinEntryManualTitle, { color: colors.text }]}>
                    {t("coinEntryManualAmountTitle")}
                  </Text>
                  <TextInput
                    style={[
                      styles.coinEntryManualInput,
                      { color: colors.text, borderColor: colors.border },
                    ]}
                    placeholder={t("coinEntryManualAmountPlaceholder")}
                    placeholderTextColor={colors.muted}
                    keyboardType="decimal-pad"
                    value={amountManualValue}
                    onChangeText={(value) => {
                      setAmountManualValue(value);
                      if (amountManualError) setAmountManualError("");
                    }}
                    returnKeyType="done"
                    onSubmitEditing={handleAmountManualSave}
                    autoFocus
                  />
                  {!!amountManualError && (
                    <Text style={[styles.coinEntryManualError, { color: SPEND_ACTION_COLOR }]}>
                      {amountManualError}
                    </Text>
                  )}
                  <View style={styles.coinEntryManualActions}>
                    <TouchableOpacity
                      style={[styles.coinEntryManualButtonGhost, { borderColor: colors.border }]}
                      onPress={closeAmountManual}
                    >
                      <Text style={[styles.coinEntryManualButtonGhostText, { color: colors.muted }]}>
                        {t("coinEntryManualCancel")}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[styles.coinEntryManualButtonPrimary, { backgroundColor: colors.text }]}
                      onPress={handleAmountManualSave}
                    >
                      <Text
                        style={[
                          styles.coinEntryManualButtonPrimaryText,
                          { color: colors.background },
                        ]}
                      >
                        {t("coinEntryManualSave")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>
      )}
      {!showEditorInline && (
        <View
          style={[
            styles.temptationActions,
            tutorialHighlightActions && styles.temptationTutorialAccent,
          ]}
        >
        {actionConfig.map((action) => {
          let buttonStyle;
          let textStyle;
          if (action.type === "save") {
            buttonStyle = [
              styles.temptationButtonPrimary,
              { backgroundColor: SAVE_ACTION_COLOR, opacity: action.disabled ? 0.4 : 1 },
            ];
            textStyle = [styles.temptationButtonPrimaryText, { color: "#FFFFFF" }];
          } else if (action.type === "spend") {
            buttonStyle = [
              styles.temptationButtonPrimary,
              { backgroundColor: SPEND_ACTION_COLOR, opacity: action.disabled ? 0.4 : 1 },
            ];
            textStyle = [styles.temptationButtonPrimaryText, { color: "#FFFFFF" }];
          } else if (action.variant === "primary") {
            buttonStyle = [
              styles.temptationButtonPrimary,
              { backgroundColor: colors.text, opacity: action.disabled ? 0.35 : 1 },
            ];
            textStyle = [styles.temptationButtonPrimaryText, { color: colors.background }];
          } else if (action.variant === "ghost") {
            buttonStyle = [styles.temptationButtonGhost, { borderColor: colors.text }];
            textStyle = [styles.temptationButtonGhostText, { color: colors.text }];
          } else {
            buttonStyle = [
              styles.temptationButtonOutline,
              {
                borderColor: isDarkTheme ? "rgba(255,255,255,0.22)" : colors.border,
                backgroundColor: isDarkTheme ? "rgba(255,255,255,0.08)" : "transparent",
              },
            ];
            textStyle = [
              styles.temptationButtonOutlineText,
              { color: isDarkTheme ? colors.text : colors.muted },
            ];
          }
          if (tutorialHighlightThink && action.type === "maybe") {
            buttonStyle = [
              ...buttonStyle,
              styles.temptationTutorialAccentButton,
            ];
            textStyle = [
              styles.temptationButtonPrimaryText,
              { color: colors.text },
            ];
          }
          if (amountSliderVisible && (action.type === "save" || action.type === "spend")) {
            buttonStyle = [...buttonStyle, styles.temptationButtonConfirm];
            if (action.type === amountSliderAction) {
              const confirmActiveStyle = { borderColor: amountSliderAccent };
              if (Platform.OS === "ios") {
                confirmActiveStyle.shadowColor = amountSliderAccent;
              }
              buttonStyle = [
                ...buttonStyle,
                styles.temptationButtonConfirmActive,
                confirmActiveStyle,
              ];
            }
          }
          if (
            action.type === "spend" &&
            amountSliderVisible &&
            amountSliderAction === "spend" &&
            amountSliderInteracted
          ) {
            buttonStyle = [...buttonStyle, styles.temptationButtonSpendFilled];
            textStyle = [...textStyle, styles.temptationButtonSpendFilledText];
          }
          return (
            <TouchableOpacity
              key={action.type}
              style={buttonStyle}
              onPress={() => {
                if (action.disabled) return;
                if (action.type === "save" || action.type === "spend") {
                  if (!amountSliderVisible) {
                    openAmountSlider(action.type);
                    return;
                  }
                  if (amountSliderAction !== action.type) {
                    setAmountSliderAction(action.type);
                    triggerSelectionHaptic();
                    playSound?.("tap", { skipCooldown: true });
                    return;
                  }
                  confirmAmountAction(action.type);
                  return;
                }
                if (amountSliderVisible) {
                  closeAmountSlider();
                }
                onAction?.(action.type, item);
              }}
            >
              <Text style={textStyle}>{action.label}</Text>
            </TouchableOpacity>
          );
        })}
        </View>
      )}
      {coinBursts.map((coin) => {
        const translateY = coin.progress.interpolate({
          inputRange: [0, 1],
          outputRange: [0, -140],
        });
        const translateXCoin = coin.progress.interpolate({
          inputRange: [0, 1],
          outputRange: [0, coin.offsetX],
        });
        const rotate = coin.progress.interpolate({
          inputRange: [0, 1],
          outputRange: ["0deg", `${coin.rotation}deg`],
        });
        const scale = coin.progress.interpolate({
          inputRange: [0, 0.3, 1],
          outputRange: [0.3, 1, 0.6],
        });
        const opacity = coin.progress.interpolate({
          inputRange: [0, 0.6, 1],
          outputRange: [1, 1, 0],
        });
        return (
          <Animated.View
            key={coin.id}
            pointerEvents="none"
            style={[
              styles.coinBurst,
              {
                opacity,
                transform: [{ translateX: translateXCoin }, { translateY }, { rotate }, { scale }],
              },
            ]}
          >
            <View style={[styles.coinBurstInner, { backgroundColor: coinBurstColor }]} />
          </Animated.View>
        );
      })}
      {messageActive && null}
      {showEditorInline && isEditing && (
        <View style={[styles.temptationEditor, { borderTopColor: colors.border }]}>
          <View style={styles.temptationEditorActions}>
            <TouchableOpacity
              style={[styles.priceModalPrimary, { backgroundColor: colors.text }]}
              onPress={onEditSave}
            >
              <Text style={[styles.priceModalPrimaryText, { color: colors.background }]}>
                {t("priceEditSave")}
              </Text>
            </TouchableOpacity>
            <TouchableOpacity onPress={onEditCancel}>
              <Text style={[styles.priceModalCancel, { color: colors.muted }]}>
                {t("priceEditCancel")}
              </Text>
            </TouchableOpacity>
            <TouchableOpacity onPress={onEditDelete}>
              <Text style={[styles.priceModalDeleteText, { color: "#E15555" }]}>
                {t("priceEditDelete")}
              </Text>
            </TouchableOpacity>
          </View>
        </View>
      )}
      </Animated.View>
    </View>
  );
}

const TemptationCard = React.memo(TemptationCardComponent);

const TemptationEditSheet = React.memo(function TemptationEditSheet({
  item,
  language,
  colors,
  t,
  currency,
  titleOverride,
  editTitleValue,
  editPriceValue,
  editGoalLabel,
  editEmojiValue,
  editDescriptionValue,
  editCategoryValue,
  editFrequencyValue,
  editFrequencyCustomValue,
  onEditTitleChange,
  onEditPriceChange,
  onEditEmojiChange,
  onEditDescriptionChange,
  onEditCategoryChange,
  onEditFrequencyChange,
  onEditFrequencyCustomChange,
  onEditGoalSelect,
  onEditSave,
  onEditCancel,
  onEditDelete,
}) {
  if (!item) return null;
  const fallbackTitle = resolveTemptationTitle(item, language, titleOverride);
  const previewTitle = buildTemptationDisplayTitle(editEmojiValue, editTitleValue, fallbackTitle);
  const goalLabelText =
    (typeof editGoalLabel === "string" && editGoalLabel.trim().length
      ? editGoalLabel.trim()
      : "") || t("goalAssignFieldLabel");
  const descriptionPlaceholder =
    t("priceEditDescriptionLabel") || t("priceEditPlaceholder") || "";

  return (
    <View
      style={[
        styles.temptationEditSheet,
        { backgroundColor: colors.card, borderColor: colors.border },
      ]}
    >
      <ScrollView
        style={styles.temptationEditScroll}
        contentContainerStyle={styles.temptationEditContent}
        keyboardShouldPersistTaps="handled"
        showsVerticalScrollIndicator={false}
      >
        <Text style={[styles.temptationEditSubtitle, { color: colors.muted }]}>
          {t("priceEditSubtitle")}
        </Text>
        <View style={styles.temptationEditField}>
          <FrequencyPicker
            value={editFrequencyValue}
            customValue={editFrequencyCustomValue}
            onValueChange={onEditFrequencyChange}
            onCustomChange={onEditFrequencyCustomChange}
            colors={colors}
            t={t}
          />
        </View>
        <View style={styles.temptationEditFieldRow}>
          <View style={styles.temptationEditField}>
            <Text style={[styles.temptationEditLabel, { color: colors.muted }]}>
              {t("quickCustomEmojiLabel")}
            </Text>
            <View
              style={[
                styles.temptationEditInputWrap,
                styles.temptationEditEmojiWrap,
                { borderColor: colors.border, backgroundColor: colors.background },
              ]}
            >
              <TextInput
                style={[styles.temptationEditEmojiInput, { color: colors.text }]}
                value={editEmojiValue ?? ""}
                onChangeText={onEditEmojiChange}
                placeholder={item.emoji || DEFAULT_TEMPTATION_EMOJI}
                placeholderTextColor={colorWithAlpha(colors.muted, 0.7)}
                selectTextOnFocus
                maxLength={2}
              />
            </View>
          </View>
          <View style={[styles.temptationEditField, styles.temptationEditFieldGrow]}>
            <Text style={[styles.temptationEditLabel, { color: colors.muted }]}>
              {t("priceEditNameLabel")}
            </Text>
            <View
              style={[
                styles.temptationEditInputWrap,
                { borderColor: colors.border, backgroundColor: colors.background },
              ]}
            >
              <TextInput
                style={[styles.temptationEditTextInput, { color: colors.text }]}
                value={editTitleValue}
                onChangeText={onEditTitleChange}
                placeholder={previewTitle}
                placeholderTextColor={colorWithAlpha(colors.muted, 0.7)}
              />
            </View>
          </View>
        </View>
        <View style={styles.temptationEditField}>
          <Text style={[styles.temptationEditLabel, { color: colors.muted }]}>
            {t("priceEditAmountLabel", { currency })}
          </Text>
          <View
            style={[
              styles.temptationEditInputWrap,
              styles.temptationEditAmountWrap,
              { borderColor: colors.border, backgroundColor: colors.background },
            ]}
          >
            <TextInput
              style={[styles.temptationEditAmountInput, { color: colors.text }]}
              value={editPriceValue ?? ""}
              onChangeText={onEditPriceChange}
              keyboardType="decimal-pad"
              placeholder={t("priceEditPlaceholder")}
              placeholderTextColor={colorWithAlpha(colors.muted, 0.7)}
            />
          </View>
        </View>
        <View style={styles.temptationEditField}>
          <Text style={[styles.temptationEditLabel, { color: colors.muted }]}>
            {t("goalDestinationLabel")}
          </Text>
          <TouchableOpacity
            style={[
              styles.temptationEditGoalButton,
              { borderColor: colors.border, backgroundColor: colors.background },
            ]}
            onPress={onEditGoalSelect}
            activeOpacity={0.85}
          >
            <Text
              style={[styles.temptationEditGoalText, { color: colors.text }]}
              numberOfLines={1}
            >
              {goalLabelText}
            </Text>
            <Text style={[styles.temptationEditGoalChevron, { color: colors.muted }]}>â€º</Text>
          </TouchableOpacity>
        </View>
        <View style={styles.temptationEditField}>
          <Text style={[styles.temptationEditLabel, { color: colors.muted }]}>
            {t("priceEditDescriptionLabel")}
          </Text>
          <View
            style={[
              styles.temptationEditInputWrap,
              { borderColor: colors.border, backgroundColor: colors.background },
            ]}
          >
            <TextInput
              style={[styles.temptationEditDescriptionInput, { color: colors.text }]}
              value={editDescriptionValue ?? ""}
              onChangeText={onEditDescriptionChange}
              placeholder={descriptionPlaceholder}
              placeholderTextColor={colorWithAlpha(colors.muted, 0.7)}
              multiline
              textAlignVertical="top"
            />
          </View>
        </View>
        <View style={styles.temptationEditField}>
          <Text style={[styles.temptationEditLabel, { color: colors.muted }]}>
            {t("impulseCategoryLabel")}
          </Text>
          <View style={styles.temptationEditCategoryWrap}>
            <ImpulseCategorySelector
              value={editCategoryValue || DEFAULT_IMPULSE_CATEGORY}
              onChange={onEditCategoryChange}
              colors={colors}
              language={language}
              compact
              horizontal
              visibleCount={4}
              tall
            />
          </View>
        </View>
      </ScrollView>
      <View style={[styles.temptationEditFooter, { borderTopColor: colors.border }]}>
        <TouchableOpacity
          style={[styles.temptationEditSave, { backgroundColor: colors.text }]}
          onPress={onEditSave}
        >
          <Text style={[styles.temptationEditSaveText, { color: colors.background }]}>
            {t("priceEditSave")}
          </Text>
        </TouchableOpacity>
        <View style={styles.temptationEditFooterRow}>
          <TouchableOpacity onPress={onEditCancel}>
            <Text style={[styles.temptationEditCancelText, { color: colors.muted }]}>
              {t("priceEditCancel")}
            </Text>
          </TouchableOpacity>
          <TouchableOpacity onPress={onEditDelete}>
            <Text style={[styles.temptationEditDeleteText, { color: "#E15555" }]}>
              {t("priceEditDelete")}
            </Text>
          </TouchableOpacity>
        </View>
      </View>
    </View>
  );
});


const FrequencySectionHeader = ({ title, count, collapsed, onToggle, colors, t }) => {
  const arrowIcon = collapsed ? "â–¾" : "â–´";
  const toggleLabel = collapsed ? t("frequencyExpandLabel") : t("frequencyCollapseLabel");

  return (
    <TouchableOpacity
      onPress={onToggle}
      style={[
        styles.frequencySectionHeader,
        { borderColor: colors.border, backgroundColor: colors.card },
      ]}
      activeOpacity={0.9}
    >
      <View style={styles.frequencySectionHeaderText}>
        <Text style={[styles.frequencySectionTitle, { color: colors.text }]}>{title}</Text>
        <Text style={[styles.frequencySectionCount, { color: colors.muted }]}>{count}</Text>
      </View>
      <View style={styles.frequencySectionToggle}>
        <Text style={[styles.frequencySectionToggleLabel, { color: colors.text }]}>
          {toggleLabel}
        </Text>
        <Text style={[styles.frequencySectionToggleArrow, { color: colors.text }]}>{arrowIcon}</Text>
      </View>
    </TouchableOpacity>
  );
};

const DailyRewardButton = React.memo(
  function DailyRewardButton({
    visible = false,
    width = 0,
    height = 0,
    top = 0,
    unlocked = false,
    ready = false,
    amount = 0,
    label = "",
    buttonBg,
    buttonBorder,
    buttonShadow,
    buttonText,
    lockedBg,
    lockedBorder,
    lockedText,
    onPress,
  }) {
    if (!visible) return null;
    return (
      <TouchableOpacity
        style={[
          styles.dailyRewardButton,
          styles.dailyRewardFloating,
          {
            width,
            height,
            minHeight: height,
            minWidth: width,
            top,
            backgroundColor: unlocked ? buttonBg : lockedBg,
            borderColor: unlocked ? buttonBorder : lockedBorder,
            shadowColor: unlocked ? buttonShadow : "transparent",
            shadowOpacity: unlocked && ready ? 0.2 : 0,
            shadowOffset: { width: 0, height: unlocked && ready ? 3 : 0 },
            shadowRadius: unlocked && ready ? 4 : 0,
            elevation: unlocked && ready ? 1 : 0,
          },
        ]}
        hitSlop={{ top: 8, bottom: 8, left: 8, right: 8 }}
        pressRetentionOffset={{ top: 10, bottom: 10, left: 10, right: 10 }}
        activeOpacity={unlocked && ready ? 0.85 : 1}
        onPress={unlocked ? onPress : undefined}
        disabled={!unlocked || !ready}
      >
        {unlocked ? (
          <>
            <Image
              source={(getHealthCoinTierForAmount(amount) || HEALTH_COIN_TIERS[0]).asset}
              style={styles.dailyRewardCoin}
            />
            {ready && amount > 0 && (
              <Text
                style={[
                  styles.dailyRewardAmount,
                  { color: buttonText },
                ]}
              >
                {`+${amount}`}
              </Text>
            )}
            <Text
              style={[
                styles.dailyRewardCaption,
                { color: buttonText },
              ]}
              numberOfLines={1}
              adjustsFontSizeToFit
              minimumFontScale={0.7}
              ellipsizeMode="clip"
            >
              {label}
            </Text>
          </>
        ) : (
          <>
            <Text style={[styles.dailyRewardLockedIcon, { color: lockedText }]}>
              ðŸ”’
            </Text>
            <Text
              style={[styles.dailyRewardLockedLabel, { color: lockedText }]}
              numberOfLines={1}
              adjustsFontSizeToFit
              minimumFontScale={0.7}
            >
              {label}
            </Text>
          </>
        )}
      </TouchableOpacity>
    );
  },
  (prev, next) =>
    prev.visible === next.visible &&
    prev.width === next.width &&
    prev.height === next.height &&
    prev.top === next.top &&
    prev.unlocked === next.unlocked &&
    prev.ready === next.ready &&
    prev.amount === next.amount &&
    prev.label === next.label &&
    prev.buttonBg === next.buttonBg &&
    prev.buttonBorder === next.buttonBorder &&
    prev.buttonShadow === next.buttonShadow &&
    prev.buttonText === next.buttonText &&
    prev.lockedBg === next.lockedBg &&
    prev.lockedBorder === next.lockedBorder &&
    prev.lockedText === next.lockedText &&
    prev.onPress === next.onPress
);

const SavingsHeroCard = forwardRef(function SavingsHeroCard({
  goldPalette,
  isDarkMode = false,
  heroSpendCopy,
  heroRecentEvents = [],
  heroEncouragementLine,
  onRecentEventsPress = null,
  playerLevel = null,
  totalSavedLabel,
  progressPercent,
  progressPercentLabel,
  isGoalComplete = false,
  completionLabel,
  t,
  analyticsPreview = [],
  baselineMonthlyWasteUSD = 0,
  baselineStartAt = null,
  actualSavedUSD = 0,
  potentialGrowthUSD = 0,
  showPotentialGrowth = false,
  currency,
  hasBaseline = false,
  hasActiveGoal = true,
  onBaselineSetup = () => {},
  onPotentialDetailsOpen = null,
  healthPoints = 0,
  onBreakdownPress = () => {},
  playSound = () => {},
  onAnchorChange = null,
  dailyRewardUnlocked = false,
  dailyRewardReady = false,
  dailyRewardAmount = 0,
  dailyRewardBaseAmount = 0,
  dailyRewardDay = 1,
  onDailyRewardClaim = () => {},
  onDailyRewardModalVisibilityChange = null,
  activeChallenge = null,
  onActiveChallengePress = () => {},
  onExpandedChange = null,
  style = null,
}, ref) {
  const [expanded, setExpanded] = useState(false);
  const heroRecentNowTick = useMinuteTicker(true);
  const heroCardRef = useRef(null);
  const heroAnchorRef = useRef(null);
  const dailyRewardClaimPendingRef = useRef(false);
  const dailyRewardClosePendingRef = useRef(false);
  const [isDailyRewardModalVisible, setDailyRewardModalVisible] = useState(false);
  const dailyRewardModalReveal = useRef(new Animated.Value(0)).current;
  const dailyRewardBackdropReveal = useRef(new Animated.Value(0)).current;
  const dailyRewardCoinPulse = useRef(new Animated.Value(0)).current;
  const dailyRewardHaloSpin = useRef(new Animated.Value(0)).current;
  const dailyRewardCollectFlash = useRef(new Animated.Value(0)).current;
  const dailyRewardDayAnimRefs = useRef(
    Array.from({ length: DAILY_REWARD_STREAK_LENGTH }, () => new Animated.Value(0))
  );
  const dailyRewardCoinPulseLoopRef = useRef(null);
  const dailyRewardHaloSpinLoopRef = useRef(null);
  const dailyRewardSfxTimersRef = useRef([]);
  const measureHeroAnchor = useCallback(() => {
    if (!onAnchorChange) return;
    const node = heroCardRef.current;
    if (!node || typeof node.measureInWindow !== "function") return;
    node.measureInWindow((x, y, width, height) => {
      if (!Number.isFinite(x) || !Number.isFinite(y) || !width || !height) return;
      const androidStatusBarOffset = Platform.OS === "android" ? RNStatusBar.currentHeight || 0 : 0;
      const next = {
        x: x + width / 2,
        y: y + height / 2 + androidStatusBarOffset,
        width,
        height,
      };
      const prev = heroAnchorRef.current;
      if (
        prev &&
        Math.abs(prev.x - next.x) < 0.5 &&
        Math.abs(prev.y - next.y) < 0.5 &&
        Math.abs(prev.width - next.width) < 0.5 &&
        Math.abs(prev.height - next.height) < 0.5
      ) {
        return;
      }
      heroAnchorRef.current = next;
      onAnchorChange(next);
    });
  }, [onAnchorChange]);
  const handleHeroLayout = useCallback(() => {
    measureHeroAnchor();
  }, [measureHeroAnchor]);
  const potentialSavedUSD = useSavingsSimulation(
    baselineMonthlyWasteUSD,
    baselineStartAt
  );
  const setDailyRewardModalState = useCallback(
    (visible) => {
      setDailyRewardModalVisible(visible);
      if (typeof onDailyRewardModalVisibilityChange === "function") {
        onDailyRewardModalVisibilityChange(visible);
      }
    },
    [onDailyRewardModalVisibilityChange]
  );
  const [potentialLayoutReady, setPotentialLayoutReady] = useState(false);
  const potentialGrowthAnim = useRef(new Animated.Value(0)).current;
  const potentialGrowthPlayedRef = useRef(false);
  const potentialLocal = formatCurrency(convertToCurrency(potentialSavedUSD || 0, currency), currency, {
    precisionOverride: getCurrencyPrecision(currency),
  });
  const actualLocal = formatCurrency(convertToCurrency(actualSavedUSD || 0, currency), currency, {
    precisionOverride: getCurrencyPrecision(currency),
  });
  const heroAmountBaseFontSize = IS_SHORT_DEVICE ? 36 : Platform.OS === "ios" ? 44 : 46;
  const heroAmountBaseLineHeight = IS_SHORT_DEVICE ? 40 : Platform.OS === "ios" ? 48 : 50;
  const heroAmountMinScale = 0.6;
  const heroAmountScale = useMemo(() => {
    const label = totalSavedLabel ? String(totalSavedLabel) : "";
    const digitCount = (label.match(/\d/g) || []).length;
    const roughLength = label.replace(/\s/g, "").length;
    const lengthScore = Math.max(digitCount, roughLength);
    if (lengthScore <= 6) return 1;
    const shrinkSteps = Math.min(lengthScore - 6, 10);
    const scale = 1 - shrinkSteps * 0.045;
    return Math.max(heroAmountMinScale, scale);
  }, [totalSavedLabel]);
  const heroAmountFontSize = Math.round(heroAmountBaseFontSize * heroAmountScale);
  const heroAmountLineHeight = Math.round(heroAmountBaseLineHeight * heroAmountScale);
  const potentialGrowthLabel = useMemo(() => {
    const value = Math.max(0, Number(potentialGrowthUSD) || 0);
    if (!Number.isFinite(value) || value <= 0) return "";
    return formatCurrency(convertToCurrency(value, currency), currency, {
      precisionOverride: getCurrencyPrecision(currency),
    });
  }, [currency, potentialGrowthUSD]);
  const coinEntries = useMemo(() => buildHealthCoinEntries(healthPoints), [healthPoints]);
  const hasCoinInventory = coinEntries.some((entry) => entry.count > 0);
  const potentialRatio = potentialSavedUSD > 0 ? Math.min(actualSavedUSD / potentialSavedUSD, 1) : 0;
  const missedUSD = Math.max(0, potentialSavedUSD - actualSavedUSD);
  const statusKey =
    actualSavedUSD > potentialSavedUSD
      ? "potentialBlockStatusAhead"
      : actualSavedUSD <= 0
      ? "potentialBlockStatusStart"
      : potentialRatio >= 0.8
      ? "potentialBlockStatusOnTrack"
      : "potentialBlockStatusBehind";
  const handlePotentialDetailsOpen = useCallback(() => {
    if (!hasBaseline) return;
    if (typeof onPotentialDetailsOpen === "function") {
      onPotentialDetailsOpen();
    }
  }, [hasBaseline, onPotentialDetailsOpen]);
  useEffect(() => {
    if (!showPotentialGrowth) {
      potentialGrowthPlayedRef.current = false;
      return;
    }
    if (!potentialGrowthLabel) return;
    if (potentialGrowthPlayedRef.current) return;
    if (!potentialLayoutReady) return;
    potentialGrowthPlayedRef.current = true;
    const task = InteractionManager.runAfterInteractions(() => {
      setTimeout(() => {
        requestAnimationFrame(() => {
          potentialGrowthAnim.setValue(0);
          Animated.sequence([
            Animated.timing(potentialGrowthAnim, {
              toValue: 1,
              duration: 260,
              useNativeDriver: true,
            }),
            Animated.timing(potentialGrowthAnim, {
              toValue: 0,
              duration: 240,
              useNativeDriver: true,
            }),
          ]).start();
        });
      });
    });
    return () => task?.cancel?.();
  }, [potentialGrowthAnim, potentialGrowthLabel, potentialLayoutReady, showPotentialGrowth]);
  useEffect(() => {
    if (!onAnchorChange) return;
    const frame = requestAnimationFrame(() => {
      measureHeroAnchor();
    });
    return () => cancelAnimationFrame(frame);
  }, [measureHeroAnchor, onAnchorChange]);
  const potentialGrowthScale = potentialGrowthAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [1, 1.22],
  });
  const potentialGrowthOpacity = potentialGrowthAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0.65, 1],
  });
  const dailyRewardPreview = useMemo(() => {
    const schedule = buildDailyRewardSchedule(dailyRewardBaseAmount || dailyRewardAmount);
    return schedule.map((amount, index) => ({
      day: index + 1,
      amount,
      isSuper: index + 1 === DAILY_REWARD_STREAK_LENGTH,
    }));
  }, [dailyRewardAmount, dailyRewardBaseAmount]);
  const dailyRewardModalPalette = isDarkMode
    ? {
        background: "#3A2405",
        border: "rgba(255,214,143,0.7)",
        subtext: "rgba(255,238,208,0.92)",
        text: "#FFEED0",
      }
    : {
        background: goldPalette.background,
        border: goldPalette.border,
        subtext: goldPalette.subtext,
        text: goldPalette.text,
      };
  const dailyRewardActiveAccent = isDarkMode ? "#7BFFB8" : "#1F7A4F";
  const dailyRewardActiveBorder = isDarkMode ? "rgba(123,255,184,0.85)" : "rgba(45,166,106,0.9)";
  const dailyRewardActiveBg = isDarkMode ? "rgba(123,255,184,0.18)" : "rgba(45,166,106,0.14)";
  const clearDailyRewardSfxTimers = useCallback(() => {
    if (!dailyRewardSfxTimersRef.current.length) return;
    dailyRewardSfxTimersRef.current.forEach((timerId) => clearTimeout(timerId));
    dailyRewardSfxTimersRef.current = [];
  }, []);
  const stopDailyRewardModalLoops = useCallback(() => {
    dailyRewardCoinPulseLoopRef.current?.stop?.();
    dailyRewardHaloSpinLoopRef.current?.stop?.();
    dailyRewardCoinPulseLoopRef.current = null;
    dailyRewardHaloSpinLoopRef.current = null;
  }, []);
  const closeDailyRewardModalAnimated = useCallback(() => {
    if (dailyRewardClosePendingRef.current) return;
    if (!isDailyRewardModalVisible) {
      setDailyRewardModalState(false);
      return;
    }
    dailyRewardClosePendingRef.current = true;
    stopDailyRewardModalLoops();
    clearDailyRewardSfxTimers();
    Animated.parallel([
      Animated.timing(dailyRewardModalReveal, {
        toValue: 0,
        duration: 220,
        easing: Easing.in(Easing.cubic),
        useNativeDriver: true,
      }),
      Animated.timing(dailyRewardBackdropReveal, {
        toValue: 0,
        duration: 180,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }),
      Animated.timing(dailyRewardCollectFlash, {
        toValue: 0,
        duration: 140,
        useNativeDriver: true,
      }),
    ]).start(() => {
      dailyRewardClosePendingRef.current = false;
      setDailyRewardModalState(false);
    });
  }, [
    clearDailyRewardSfxTimers,
    dailyRewardBackdropReveal,
    dailyRewardCollectFlash,
    dailyRewardModalReveal,
    isDailyRewardModalVisible,
    setDailyRewardModalState,
    stopDailyRewardModalLoops,
  ]);
  const handleDailyRewardClosePress = useCallback(() => {
    playSound?.("tap", { skipCooldown: true });
    closeDailyRewardModalAnimated();
  }, [closeDailyRewardModalAnimated, playSound]);
  const handleDailyRewardPress = useCallback(() => {
    if (!dailyRewardReady) return;
    if (dailyRewardClosePendingRef.current) return;
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    const day = Math.min(DAILY_REWARD_STREAK_LENGTH, Math.max(1, dailyRewardDay || 1));
    logEvent("daily_reward_opened", {
      coins: dailyRewardAmount,
      day,
      level: playerLevel,
    });
    setDailyRewardModalState(true);
  }, [
    dailyRewardAmount,
    dailyRewardDay,
    dailyRewardReady,
    playerLevel,
    setDailyRewardModalState,
    triggerHaptic,
  ]);
  useEffect(() => {
    if (!isDailyRewardModalVisible) {
      stopDailyRewardModalLoops();
      clearDailyRewardSfxTimers();
      dailyRewardModalReveal.setValue(0);
      dailyRewardBackdropReveal.setValue(0);
      dailyRewardCoinPulse.setValue(0);
      dailyRewardHaloSpin.setValue(0);
      dailyRewardCollectFlash.setValue(0);
      dailyRewardDayAnimRefs.current.forEach((anim) => anim.setValue(0));
      return;
    }
    dailyRewardClosePendingRef.current = false;
    dailyRewardModalReveal.setValue(0);
    dailyRewardBackdropReveal.setValue(0);
    dailyRewardCoinPulse.setValue(0);
    dailyRewardHaloSpin.setValue(0);
    dailyRewardCollectFlash.setValue(0);
    dailyRewardDayAnimRefs.current.forEach((anim) => anim.setValue(0));
    Animated.parallel([
      Animated.timing(dailyRewardBackdropReveal, {
        toValue: 1,
        duration: 220,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }),
      Animated.spring(dailyRewardModalReveal, {
        toValue: 1,
        tension: 170,
        friction: 18,
        useNativeDriver: true,
      }),
    ]).start();
    const dayAnimations = dailyRewardDayAnimRefs.current
      .slice(0, dailyRewardPreview.length)
      .map((anim) =>
        Animated.timing(anim, {
          toValue: 1,
          duration: 240,
          easing: Easing.out(Easing.cubic),
          useNativeDriver: true,
        })
      );
    Animated.stagger(44, dayAnimations).start();
    const coinPulseLoop = Animated.loop(
      Animated.sequence([
        Animated.timing(dailyRewardCoinPulse, {
          toValue: 1,
          duration: 780,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(dailyRewardCoinPulse, {
          toValue: 0,
          duration: 760,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    const haloSpinLoop = Animated.loop(
      Animated.timing(dailyRewardHaloSpin, {
        toValue: 1,
        duration: 5200,
        easing: Easing.linear,
        useNativeDriver: true,
      })
    );
    dailyRewardCoinPulseLoopRef.current = coinPulseLoop;
    dailyRewardHaloSpinLoopRef.current = haloSpinLoop;
    coinPulseLoop.start();
    haloSpinLoop.start();
    return () => {
      stopDailyRewardModalLoops();
      clearDailyRewardSfxTimers();
    };
  }, [
    clearDailyRewardSfxTimers,
    dailyRewardBackdropReveal,
    dailyRewardCollectFlash,
    dailyRewardCoinPulse,
    dailyRewardHaloSpin,
    dailyRewardModalReveal,
    dailyRewardPreview.length,
    isDailyRewardModalVisible,
    stopDailyRewardModalLoops,
  ]);
  const runDailyRewardClaim = useCallback(() => {
    try {
      const result = onDailyRewardClaim?.();
      Promise.resolve(result)
        .catch(() => {})
        .finally(() => {
          dailyRewardClaimPendingRef.current = false;
        });
    } catch (error) {
      dailyRewardClaimPendingRef.current = false;
    }
  }, [onDailyRewardClaim]);
  const handleDailyRewardModalDismiss = useCallback(() => {
    clearDailyRewardSfxTimers();
    if (!dailyRewardClaimPendingRef.current) return;
    runDailyRewardClaim();
  }, [clearDailyRewardSfxTimers, runDailyRewardClaim]);
  const handleDailyRewardCollect = useCallback(() => {
    if (dailyRewardClosePendingRef.current) return;
    if (!dailyRewardReady) {
      closeDailyRewardModalAnimated();
      return;
    }
    if (dailyRewardClaimPendingRef.current) {
      closeDailyRewardModalAnimated();
      return;
    }
    triggerSuccessHaptic();
    dailyRewardClaimPendingRef.current = true;
    clearDailyRewardSfxTimers();
    playSound?.("counter", { skipCooldown: true });
    dailyRewardSfxTimersRef.current.push(
      setTimeout(() => playSound?.("coin", { skipCooldown: true }), 120)
    );
    dailyRewardSfxTimersRef.current.push(
      setTimeout(() => playSound?.("reward", { skipCooldown: true }), 250)
    );
    Animated.sequence([
      Animated.timing(dailyRewardCollectFlash, {
        toValue: 1,
        duration: 140,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }),
      Animated.timing(dailyRewardCollectFlash, {
        toValue: 0,
        duration: 260,
        easing: Easing.in(Easing.quad),
        useNativeDriver: true,
      }),
    ]).start();
    closeDailyRewardModalAnimated();
    if (Platform.OS !== "ios") {
      runDailyRewardClaim();
    }
  }, [
    clearDailyRewardSfxTimers,
    closeDailyRewardModalAnimated,
    dailyRewardCollectFlash,
    dailyRewardReady,
    playSound,
    runDailyRewardClaim,
    triggerSuccessHaptic,
  ]);
  useImperativeHandle(
    ref,
    () => ({
      openDailyRewardModal: () => {
        handleDailyRewardPress();
      },
      closeDailyRewardModal: () => {
        closeDailyRewardModalAnimated();
      },
    }),
    [closeDailyRewardModalAnimated, handleDailyRewardPress]
  );
  const activeDailyRewardDay = dailyRewardReady
    ? Math.min(DAILY_REWARD_STREAK_LENGTH, Math.max(1, dailyRewardDay || 1))
    : null;
  const dailyRewardModalCardOpacity = dailyRewardModalReveal.interpolate({
    inputRange: [0, 0.6, 1],
    outputRange: [0, 0.88, 1],
  });
  const dailyRewardModalCardScale = dailyRewardModalReveal.interpolate({
    inputRange: [0, 1],
    outputRange: [0.9, 1],
  });
  const dailyRewardModalCardTranslateY = dailyRewardModalReveal.interpolate({
    inputRange: [0, 1],
    outputRange: [34, 0],
  });
  const dailyRewardModalCoinScale = dailyRewardCoinPulse.interpolate({
    inputRange: [0, 1],
    outputRange: [1, 1.08],
  });
  const dailyRewardModalHaloRotate = dailyRewardHaloSpin.interpolate({
    inputRange: [0, 1],
    outputRange: ["0deg", "360deg"],
  });
  const dailyRewardModalFlashOpacity = dailyRewardCollectFlash.interpolate({
    inputRange: [0, 1],
    outputRange: [0, 0.3],
  });
  const activeChallengeCount = activeChallenge?.targetValue || 0;
  const activeChallengeProgress = activeChallenge?.progressValue || 0;
  const showActiveChallenge =
    activeChallenge && activeChallenge.status === "active" && activeChallengeProgress > 0;
  const activeChallengePercent =
    activeChallenge && activeChallenge.targetValue
      ? Math.min(activeChallengeProgress / activeChallenge.targetValue, 1)
      : 0;
  const handleToggleExpanded = useCallback(() => {
    runLayoutAnimation();
    setExpanded((prev) => {
      const next = !prev;
      logEvent("hero_show_more_toggled", { expanded: next ? 1 : 0 });
      if (next) {
        logEvent("stats_screen_viewed", { tab: "feed" });
      }
      if (typeof onExpandedChange === "function") {
        onExpandedChange(next);
      }
      return next;
    });
  }, [onExpandedChange]);
  const resolvedHeroRecentEvents = useMemo(() => {
    const nowTimestamp = heroRecentNowTick || Date.now();
    const cutoffTimestamp = nowTimestamp - HERO_RECENT_HISTORY_WINDOW_MS;
    const safeList = Array.isArray(heroRecentEvents) ? heroRecentEvents : [];
    return safeList
      .filter((entry) => {
        const timestamp = normalizeTimestampMs(entry?.timestamp);
        if (!timestamp) return false;
        return timestamp >= cutoffTimestamp && timestamp <= nowTimestamp;
      })
      .slice(0, 3);
  }, [heroRecentEvents, heroRecentNowTick]);
  const RecentEventsWrap = onRecentEventsPress ? TouchableOpacity : View;
  return (
    <View
      ref={heroCardRef}
      onLayout={handleHeroLayout}
      style={[
        styles.progressHeroCard,
        styles.savedHeroCard,
        {
          backgroundColor: goldPalette.background,
          borderColor: goldPalette.border,
          shadowColor: goldPalette.shadow,
        },
        style,
      ]}
    >
      <View pointerEvents="none" style={styles.savedHeroGlowWrap}>
        <View style={[styles.savedHeroGlow, { backgroundColor: goldPalette.glow }]} />
        <View
          style={[
            styles.savedHeroGlow,
            styles.savedHeroGlowBottom,
            { backgroundColor: goldPalette.glow },
          ]}
        />
      </View>
      <View style={styles.savedHeroContent}>
        <View style={styles.savedHeroHeader}>
          <Text style={[styles.progressHeroTitle, { color: goldPalette.subtext }]}>
            {t("progressHeroTitle")}
          </Text>
        </View>
        <View style={styles.savedHeroAmountWrap}>
          <Text
            style={[
              styles.progressHeroAmount,
              { color: SAVE_ACTION_COLOR, fontSize: heroAmountFontSize, lineHeight: heroAmountLineHeight },
            ]}
            numberOfLines={1}
            adjustsFontSizeToFit
            minimumFontScale={heroAmountMinScale}
          >
            {totalSavedLabel}
          </Text>
        </View>
        <View style={[styles.savedHeroDivider, { backgroundColor: goldPalette.border }]} />
        {resolvedHeroRecentEvents.length > 0 ? (
          <RecentEventsWrap
            style={styles.savedHeroRecentList}
            {...(onRecentEventsPress ? { activeOpacity: 0.85, onPress: onRecentEventsPress } : {})}
          >
            <Text style={[styles.savedHeroRecentTitle, { color: goldPalette.subtext }]}>
              {t("heroSpendRecentTitle")}
            </Text>
            {resolvedHeroRecentEvents.map((entry) => (
              <Text
                key={entry.id}
                style={[
                  styles.savedHeroRecentItem,
                  { color: entry.isSpend ? goldPalette.danger : goldPalette.subtext },
                ]}
                numberOfLines={1}
                ellipsizeMode="tail"
              >
                {entry.label}
              </Text>
            ))}
          </RecentEventsWrap>
        ) : (
          <Text style={[styles.savedHeroSubtitle, { color: goldPalette.subtext }]}>
            {heroSpendCopy || heroEncouragementLine}
          </Text>
        )}

        {hasActiveGoal ? (
          <>
            <View style={styles.savedHeroGoalRow}>
              <Text style={[styles.goalLabel, { color: goldPalette.subtext }]}>
                {t("goalWidgetTitle")}
              </Text>
              <Text style={[styles.savedHeroGoalPercent, { color: goldPalette.text }]}>
                {progressPercentLabel}%
              </Text>
            </View>
            <View style={styles.savedHeroProgressRow}>
              <View
                style={[
                  styles.progressHeroBar,
                  styles.savedHeroBar,
                  { backgroundColor: goldPalette.barBg },
                ]}
              >
                <View
                  style={[
                    styles.progressHeroFill,
                    { backgroundColor: goldPalette.accent, width: `${progressPercent * 100}%` },
                  ]}
                />
              </View>
            </View>
          </>
        ) : (
          <View style={styles.savedHeroGoalRow}>
            <Text style={[styles.goalLabel, { color: goldPalette.subtext }]}>
              {t("heroDailyTitle")}
            </Text>
          </View>
        )}
        {hasActiveGoal && (
          <View style={styles.savedHeroGoalMetaRow}>
            <View style={styles.savedHeroGoalMetaActions}>
              {isGoalComplete && (
                <View
                  style={[
                    styles.goalCompleteBadge,
                    { backgroundColor: goldPalette.badgeBg, borderColor: goldPalette.badgeBorder },
                  ]}
                >
                  <Text style={[styles.goalCompleteBadgeText, { color: goldPalette.badgeText }]}>
                    {completionLabel}
                  </Text>
                </View>
              )}
            </View>
            <TouchableOpacity
              style={styles.savedHeroToggleButton}
              onPress={handleToggleExpanded}
            >
              <Text style={[styles.savedHeroToggleText, { color: goldPalette.subtext }]}>
                {expanded ? t("heroCollapse") : t("heroExpand")}
              </Text>
            </TouchableOpacity>
          </View>
        )}
      {expanded && (
        <View style={styles.savedHeroExpanded}>
          {showActiveChallenge && (
            <TouchableOpacity
              activeOpacity={0.9}
              onPress={() => onActiveChallengePress?.(activeChallenge.id)}
              style={[
                styles.heroChallengeBlock,
                { backgroundColor: goldPalette.badgeBg, borderColor: goldPalette.badgeBorder },
              ]}
            >
              <View style={styles.heroChallengeRow}>
                <View style={styles.heroChallengeTitleRow}>
                  <Text style={styles.heroChallengeEmoji}>{activeChallenge.emoji}</Text>
                  <Text style={[styles.heroChallengeName, { color: goldPalette.text }]} numberOfLines={1}>
                    {activeChallenge.title}
                  </Text>
                </View>
                <Text style={[styles.heroChallengeMeta, { color: goldPalette.subtext }]}>
                  {activeChallenge.timerLabel}
                </Text>
              </View>
              <View style={styles.heroChallengeProgressRow}>
                <View style={[styles.heroChallengeBar, { backgroundColor: goldPalette.barBg }]}>
                  <View
                    style={[
                      styles.heroChallengeFill,
                      { backgroundColor: goldPalette.accent, width: `${activeChallengePercent * 100}%` },
                    ]}
                  />
                </View>
                <Text style={[styles.heroChallengeLabel, { color: goldPalette.subtext }]}>
                  {activeChallenge.progressLabel}
                </Text>
              </View>
            </TouchableOpacity>
          )}
          <TouchableOpacity
            style={[
              styles.heroPotentialCard,
              {
                backgroundColor: goldPalette.badgeBg,
                borderColor: goldPalette.badgeBorder,
              },
            ]}
            activeOpacity={0.9}
            onPress={handlePotentialDetailsOpen}
            onLayout={() => {
              if (!potentialLayoutReady) setPotentialLayoutReady(true);
            }}
          >
            {hasBaseline ? (
              <>
                <View style={styles.heroPotentialHeader}>
                  <View style={styles.heroPotentialRow}>
                    <Text style={[styles.heroPotentialLabel, { color: goldPalette.text }]}>
                      {t("potentialBlockTitle")}
                    </Text>
                    <Text style={[styles.heroPotentialValue, { color: goldPalette.text }]}>
                      {potentialLocal}
                    </Text>
                  </View>
                  <View style={styles.heroPotentialRow}>
                    <Text style={[styles.heroPotentialStatus, { color: goldPalette.subtext }]}>
                      {t(statusKey)}
                    </Text>
                    {showPotentialGrowth && potentialGrowthLabel ? (
                      <AnimatedText
                        style={[
                          styles.heroPotentialDelta,
                          {
                            color: SAVE_ACTION_COLOR,
                            transform: [{ scale: potentialGrowthScale }],
                            opacity: potentialGrowthOpacity,
                          },
                        ]}
                      >
                        {`+${potentialGrowthLabel}`}
                      </AnimatedText>
                    ) : null}
                  </View>
                </View>
              </>
            ) : (
              <>
                <Text style={[styles.heroPotentialBody, { color: goldPalette.text }]}>
                  {t("potentialBlockCta")}
                </Text>
                <TouchableOpacity
                  style={[
                    styles.heroPotentialButton,
                    {
                      borderColor: goldPalette.text,
                    },
                  ]}
                  activeOpacity={0.85}
                  onPress={onBaselineSetup}
                >
                  <Text style={[styles.heroPotentialButtonText, { color: goldPalette.text }]}>
                    {t("baselineCTA")}
                  </Text>
                </TouchableOpacity>
              </>
            )}
          </TouchableOpacity>
          <View
            style={[
              styles.savedHeroCoinsCard,
              { backgroundColor: goldPalette.badgeBg, borderColor: goldPalette.badgeBorder },
            ]}
          >
            <View style={styles.savedHeroCoinsText}>
              <Text style={[styles.savedHeroCoinsLabel, { color: goldPalette.text }]}>
                {t("freeDayHealthTitle")}
              </Text>
              <Text style={[styles.savedHeroCoinsSubtitle, { color: goldPalette.subtext }]}>
                {t("freeDayHealthSubtitle")}
              </Text>
              {hasCoinInventory && (
                <View style={styles.freeDayCoinRow}>
                  {coinEntries.map((entry) =>
                    entry.count ? (
                      <View
                        key={entry.id}
                        style={[
                          styles.freeDayCoinBadge,
                          { borderColor: goldPalette.border, backgroundColor: goldPalette.background },
                        ]}
                      >
                        <Image source={entry.asset} style={styles.freeDayCoinImage} />
                        <Text style={[styles.freeDayCoinCount, { color: goldPalette.text }]}>Ã—{entry.count}</Text>
                      </View>
                    ) : null
                  )}
                </View>
              )}
            </View>
            <Text style={[styles.savedHeroCoinsValue, { color: goldPalette.accent }]}>
              {healthPoints}
            </Text>
          </View>

          <View style={styles.savedHeroDaily}>
            <Text style={[styles.savedHeroDailyTitle, { color: goldPalette.text }]}>
              {t("heroDailyTitle")}
            </Text>
            {analyticsPreview.length > 0 && (
              <View style={styles.savedHeroStatsRow}>
                {analyticsPreview.map((stat) => (
                  <View
                    key={stat.label}
                    style={[
                      styles.savedHeroStatsItem,
                      { backgroundColor: goldPalette.background, borderColor: goldPalette.border },
                    ]}
                  >
                    <Text style={[styles.savedHeroStatsValue, { color: goldPalette.text }]}>
                      {stat.value}
                    </Text>
                    <Text style={[styles.savedHeroStatsLabel, { color: goldPalette.subtext }]}>
                      {stat.label}
                    </Text>
                  </View>
                ))}
              </View>
            )}
          </View>
        </View>
      )}
      {!hasActiveGoal && (
        <View style={styles.savedHeroToggleRow}>
          <TouchableOpacity
            style={styles.savedHeroToggleButton}
            onPress={handleToggleExpanded}
          >
            <Text style={[styles.savedHeroToggleText, { color: goldPalette.subtext }]}>
              {expanded ? t("heroCollapse") : t("heroExpand")}
            </Text>
          </TouchableOpacity>
        </View>
      )}
      <Modal
        visible={isDailyRewardModalVisible}
        transparent
        animationType="none"
        statusBarTranslucent
        onRequestClose={handleDailyRewardClosePress}
        onDismiss={handleDailyRewardModalDismiss}
      >
        <View style={styles.dailyRewardModalLayer}>
          <TouchableWithoutFeedback onPress={handleDailyRewardClosePress}>
            <Animated.View
              style={[
                styles.dailyRewardModalBackdrop,
                {
                  backgroundColor: isDarkMode ? "rgba(0,0,0,0.72)" : "rgba(11,16,30,0.42)",
                  opacity: dailyRewardBackdropReveal,
                },
              ]}
            />
          </TouchableWithoutFeedback>
          <View style={styles.dailyRewardModalWrap} pointerEvents="box-none">
            <Animated.View
              style={[
                styles.dailyRewardModalCard,
                {
                  backgroundColor: dailyRewardModalPalette.background,
                  borderColor: dailyRewardModalPalette.border,
                  opacity: dailyRewardModalCardOpacity,
                  transform: [
                    { translateY: dailyRewardModalCardTranslateY },
                    { scale: dailyRewardModalCardScale },
                  ],
                },
              ]}
            >
              <Animated.View
                pointerEvents="none"
                style={[
                  styles.dailyRewardModalFlash,
                  {
                    backgroundColor: isDarkMode ? "rgba(255,255,255,0.28)" : "rgba(255,255,255,0.36)",
                    opacity: dailyRewardModalFlashOpacity,
                  },
                ]}
              />
              <Animated.View
                pointerEvents="none"
                style={[
                  styles.dailyRewardModalHalo,
                  {
                    borderColor: colorWithAlpha(goldPalette.accent, isDarkMode ? 0.54 : 0.3),
                    transform: [{ rotate: dailyRewardModalHaloRotate }],
                  },
                ]}
              />
              <View style={styles.dailyRewardModalHeaderRow}>
                <View
                  style={[
                    styles.dailyRewardModalPill,
                    {
                      borderColor: colorWithAlpha(dailyRewardModalPalette.text, isDarkMode ? 0.36 : 0.24),
                      backgroundColor: colorWithAlpha(goldPalette.accent, isDarkMode ? 0.24 : 0.12),
                    },
                  ]}
                >
                  <Text style={[styles.dailyRewardModalPillText, { color: dailyRewardModalPalette.text }]}>
                    {t("dailyRewardModalDayLabel", {
                      day: activeDailyRewardDay || Math.max(1, Number(dailyRewardDay) || 1),
                    })}
                  </Text>
                </View>
                <Text style={[styles.dailyRewardModalTitle, { color: dailyRewardModalPalette.text }]}>
                  {t("dailyRewardModalTitle")}
                </Text>
              </View>
              <View style={styles.dailyRewardModalHero}>
                <Animated.View
                  style={[
                    styles.dailyRewardModalCoinOrbit,
                    {
                      backgroundColor: colorWithAlpha(goldPalette.accent, isDarkMode ? 0.3 : 0.2),
                      borderColor: colorWithAlpha(goldPalette.accent, isDarkMode ? 0.62 : 0.34),
                      transform: [{ scale: dailyRewardModalCoinScale }],
                    },
                  ]}
                >
                  <Image
                    source={(getHealthCoinTierForAmount(dailyRewardAmount) || HEALTH_COIN_TIERS[0]).asset}
                    style={styles.dailyRewardModalCoinIcon}
                  />
                </Animated.View>
                <Text style={[styles.dailyRewardModalHeroAmount, { color: dailyRewardModalPalette.text }]}>
                  +{Math.max(0, Number(dailyRewardAmount) || 0)}
                </Text>
                <Text style={[styles.dailyRewardModalSubtitle, { color: dailyRewardModalPalette.subtext }]}>
                  {t("dailyRewardModalDescription")}
                </Text>
              </View>
              <View style={styles.dailyRewardCalendar}>
                {dailyRewardPreview.map((entry, index) => {
                  const isActive = entry.day === activeDailyRewardDay;
                  const isSuper = entry.isSuper;
                  const dayBg = isSuper ? "rgba(255,214,143,0.2)" : goldPalette.badgeBg;
                  const dayBorder = isSuper ? "rgba(255,171,64,0.85)" : goldPalette.border;
                  const superDayStyle = isSuper ? { minWidth: 84, maxWidth: 102, width: 92 } : null;
                  const dayAnim = dailyRewardDayAnimRefs.current[index] || dailyRewardModalReveal;
                  const dayOpacity = dayAnim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [0, 1],
                  });
                  const dayTranslateY = dayAnim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [10, 0],
                  });
                  const dayScale = dayAnim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [0.92, 1],
                  });
                  return (
                    <Animated.View
                      key={entry.day}
                      style={[
                        styles.dailyRewardCalendarDay,
                        superDayStyle,
                        {
                          backgroundColor: isActive ? dailyRewardActiveBg : dayBg,
                          borderWidth: isActive ? 1.5 : 1,
                          borderColor: isActive ? dailyRewardActiveBorder : dayBorder,
                          opacity: dayOpacity,
                          transform: [{ translateY: dayTranslateY }, { scale: dayScale }],
                        },
                      ]}
                    >
                      <Text
                        style={[
                          styles.dailyRewardCalendarDayLabel,
                          { color: isActive ? dailyRewardActiveAccent : dailyRewardModalPalette.subtext },
                        ]}
                        numberOfLines={1}
                      >
                        {t("dailyRewardModalDayLabel", { day: entry.day })}
                      </Text>
                      <Text
                        style={[
                          styles.dailyRewardCalendarAmount,
                          { color: isActive ? dailyRewardActiveAccent : dailyRewardModalPalette.text },
                        ]}
                      >
                        +{entry.amount}
                      </Text>
                      {isSuper && (
                        <Text
                          style={[
                            styles.dailyRewardCalendarSuperLabel,
                            { color: isActive ? dailyRewardActiveAccent : dailyRewardModalPalette.text },
                          ]}
                        >
                          {t("dailyRewardSuperLabel")}
                        </Text>
                      )}
                    </Animated.View>
                  );
                })}
              </View>
              <View
                style={[
                  styles.dailyRewardModalNoteWrap,
                  { borderColor: colorWithAlpha(dailyRewardModalPalette.text, isDarkMode ? 0.26 : 0.2) },
                ]}
              >
                <Text style={[styles.dailyRewardModalNoteIcon, { color: dailyRewardModalPalette.text }]}>âš¡</Text>
                <Text style={[styles.dailyRewardModalNote, { color: dailyRewardModalPalette.subtext }]}>
                  {t("dailyRewardModalGrowthNote")}
                </Text>
              </View>
              <View style={styles.dailyRewardModalActions}>
                <TouchableOpacity
                  style={[
                    styles.dailyRewardModalSecondary,
                    { borderColor: colorWithAlpha(dailyRewardModalPalette.text, 0.3) },
                  ]}
                  onPress={handleDailyRewardClosePress}
                  activeOpacity={0.85}
                >
                  <Text style={[styles.dailyRewardModalSecondaryText, { color: dailyRewardModalPalette.text }]}>
                    {t("dailyRewardModalLater")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.dailyRewardModalPrimary, { backgroundColor: goldPalette.accent }]}
                  onPress={handleDailyRewardCollect}
                  activeOpacity={0.9}
                >
                  <Text style={[styles.dailyRewardModalPrimaryText, { color: "#fff" }]}>
                    {t("dailyRewardModalCTA")}
                  </Text>
                </TouchableOpacity>
              </View>
            </Animated.View>
          </View>
        </View>
      </Modal>
      </View>
    </View>
  );
});

const BudgetHeroCard = React.memo(function BudgetHeroCard({
  colors,
  isDarkMode = false,
  t,
  monthLabel,
  remainingLabel,
  remainingNegative = false,
  categories = [],
  budgetHasIncome = false,
  formatLocalAmount = () => "",
  style = null,
}) {
  const accent = remainingNegative ? SPEND_ACTION_COLOR : SAVE_ACTION_COLOR;
  const subtitle = monthLabel
    ? t("budgetWidgetMonthLabel", { month: monthLabel })
    : t("budgetWidgetSubtitle");
  const budgetLimitWarningColor = isDarkMode ? "#FFD59A" : "#F6C16B";
  const glowColor = colorWithAlpha(accent, isDarkMode ? 0.25 : 0.2);
  return (
    <View
      style={[
        styles.progressHeroCard,
        styles.savedHeroCard,
        styles.heroBudgetCard,
        {
          backgroundColor: colors.card,
          borderColor: colors.border,
          shadowColor: isDarkMode ? "#000" : "rgba(0,0,0,0.2)",
        },
        style,
      ]}
    >
      <View pointerEvents="none" style={styles.savedHeroGlowWrap}>
        <View style={[styles.savedHeroGlow, { backgroundColor: glowColor }]} />
        <View style={[styles.savedHeroGlow, styles.savedHeroGlowBottom, { backgroundColor: glowColor }]} />
      </View>
      <View style={styles.heroBudgetHeader}>
        <View style={styles.heroBudgetTitleBlock}>
          <Text style={[styles.heroBudgetTitle, { color: colors.text }]}>
            {t("budgetWidgetTitle")}
          </Text>
          <Text style={[styles.heroBudgetSubtitle, { color: colors.muted }]}>
            {subtitle}
          </Text>
        </View>
        <View
          style={[
            styles.heroBudgetChip,
            {
              borderColor: colorWithAlpha(accent, 0.35),
              backgroundColor: colorWithAlpha(accent, 0.12),
            },
          ]}
        >
          <Text style={[styles.heroBudgetChipText, { color: accent }]}>
            {budgetHasIncome ? t("budgetRemainingLabel") : t("budgetAddIncome")}
          </Text>
        </View>
      </View>
      {budgetHasIncome ? (
        <>
          <View style={styles.heroBudgetSummary}>
            <Text style={[styles.heroBudgetSummaryLabel, { color: colors.muted }]}>
              {t("budgetRemainingLabel")}
            </Text>
            <Text
              style={[
                styles.heroBudgetSummaryValue,
                { color: remainingNegative ? SPEND_ACTION_COLOR : colors.text },
              ]}
              numberOfLines={1}
              adjustsFontSizeToFit
              minimumFontScale={0.75}
            >
              {remainingNegative ? `-${remainingLabel}` : remainingLabel}
            </Text>
          </View>
          <View style={styles.heroBudgetCategoryList}>
            {categories.map((entry) => {
              const limitUSD = entry.limitUSD || 0;
              const spentUSD = entry.spentUSD || 0;
              const ratio = limitUSD > 0 ? spentUSD / limitUSD : spentUSD > 0 ? 1.5 : 0;
              const spendPercent = limitUSD > 0 ? Math.min(Math.max(ratio, 0), 1) : spentUSD > 0 ? 1 : 0;
              const overflowPercent = limitUSD > 0 ? Math.min(Math.max(ratio - 1, 0), 1) : spentUSD > 0 ? 1 : 0;
              const remainingUSD = limitUSD - spentUSD;
              const remainingLabelLocal = formatLocalAmount(Math.abs(remainingUSD));
              const remainingValue = remainingUSD < -0.01 ? `-${remainingLabelLocal}` : remainingLabelLocal;
              const isLimitLow =
                limitUSD > 0 && remainingUSD >= 0 && remainingUSD / limitUSD <= BUDGET_CARD_LOW_THRESHOLD;
              return (
                <View key={entry.id} style={styles.heroBudgetRow}>
                  <View style={styles.heroBudgetRowHeader}>
                    <View style={styles.heroBudgetRowTitle}>
                      <Text style={styles.heroBudgetRowEmoji}>{entry.emoji}</Text>
                      <Text
                        style={[styles.heroBudgetRowLabel, { color: colors.text }]}
                        numberOfLines={1}
                      >
                        {entry.label}
                      </Text>
                    </View>
                    <Text
                      style={[
                        styles.heroBudgetRowValue,
                        { color: remainingUSD < -0.01 ? SPEND_ACTION_COLOR : colors.text },
                      ]}
                      numberOfLines={1}
                    >
                      {remainingValue}
                    </Text>
                  </View>
                  <View style={[styles.heroBudgetRowTrack, { backgroundColor: colors.border }]}>
                    <View
                      style={[
                        styles.heroBudgetRowFill,
                        {
                          width: `${spendPercent > 0 ? Math.max(6, spendPercent * 100) : 0}%`,
                          backgroundColor: isLimitLow ? budgetLimitWarningColor : SAVE_ACTION_COLOR,
                        },
                      ]}
                    />
                    {overflowPercent > 0 ? (
                      <View
                        style={[
                          styles.heroBudgetRowOverflow,
                          {
                            width: `${Math.max(6, overflowPercent * 100)}%`,
                            backgroundColor: SPEND_ACTION_COLOR,
                          },
                        ]}
                      />
                    ) : null}
                  </View>
                </View>
              );
            })}
          </View>
        </>
      ) : (
        <View style={styles.heroBudgetEmpty}>
          <Text style={[styles.heroBudgetEmptyTitle, { color: colors.text }]}>
            {t("budgetEmptyTitle")}
          </Text>
          <Text style={[styles.heroBudgetEmptySubtitle, { color: colors.muted }]}>
            {t("budgetEmptySubtitle")}
          </Text>
        </View>
      )}
    </View>
  );
});

const parsePercentValue = (value) => {
  if (typeof value === "string" && value.includes("%")) {
    return Number.parseFloat(value) / 100;
  }
  const numeric = Number(value);
  return Number.isFinite(numeric) ? numeric : 0;
};

const DailyGoalCard = React.memo(function DailyGoalCard({
  colors,
  isDarkMode = false,
  t,
  monthLabel,
  dailyGoalLabel = "",
  dailyGoalUSD = 0,
  todaySavedUSD = 0,
  savedCardCount = 0,
  coinDropTick = 0,
  isActive = false,
  playSound = null,
  shakeEnabled = true,
  onCollectCoins = null,
  isCollected = false,
  style = null,
}) {
  const palette = useMemo(
    () => ({
      background: colors.card,
      border: colors.border,
      text: colors.text,
      subtext: colors.muted,
    }),
    [colors]
  );
  const glowColor = colorWithAlpha(SAVE_ACTION_COLOR, isDarkMode ? 0.25 : 0.2);
  const blurAvailable = useMemo(() => isBlurViewAvailable(), []);
  const glassGradientId = useMemo(
    () => `piggy-glass-${Math.round(Math.random() * 1e9)}`,
    []
  );
  const glassShadeId = useMemo(
    () => `piggy-glass-shade-${Math.round(Math.random() * 1e9)}`,
    []
  );
  const hasGoal = Number.isFinite(dailyGoalUSD) && dailyGoalUSD > 0;
  const safeGoalUSD = hasGoal ? dailyGoalUSD : 0;
  const safeSavedUSD = Math.max(0, Number(todaySavedUSD) || 0);
  const progress = hasGoal ? Math.min(safeSavedUSD / safeGoalUSD, 1) : 0;
  const isGoalComplete = hasGoal && safeSavedUSD >= safeGoalUSD;
  const piggyPalette = useMemo(
    () => {
      if (isGoalComplete) {
        return {
          fill: isDarkMode ? "rgba(28,80,55,0.7)" : "rgba(190,245,216,0.86)",
          border: isDarkMode ? "rgba(120,230,175,0.8)" : "rgba(62,175,120,0.7)",
          highlight: isDarkMode ? "rgba(255,255,255,0.2)" : "rgba(255,255,255,0.78)",
          shadow: isDarkMode ? "rgba(0,0,0,0.6)" : "rgba(14,70,40,0.2)",
          value: isDarkMode ? "#D6FFE8" : "#0E5A36",
          rim: isDarkMode ? "rgba(170,255,215,0.35)" : "rgba(255,255,255,0.82)",
          innerShadow: isDarkMode ? "rgba(0,0,0,0.45)" : "rgba(46,184,115,0.28)",
          tint: isDarkMode ? "rgba(70,135,95,0.35)" : "rgba(120,210,160,0.3)",
        };
      }
      return {
        fill: isDarkMode ? "rgba(20,24,36,0.58)" : "rgba(235,244,255,0.46)",
        border: isDarkMode ? "rgba(255,255,255,0.28)" : "rgba(126,146,170,0.34)",
        highlight: isDarkMode ? "rgba(255,255,255,0.18)" : "rgba(255,255,255,0.72)",
        shadow: isDarkMode ? "rgba(0,0,0,0.55)" : "rgba(22,32,54,0.18)",
        value: isDarkMode ? "#7FE4AC" : "#1B1C2A",
        rim: isDarkMode ? "rgba(255,255,255,0.22)" : "rgba(255,255,255,0.78)",
        innerShadow: isDarkMode ? "rgba(0,0,0,0.4)" : "rgba(120,140,160,0.25)",
        tint: isDarkMode ? "rgba(60,80,110,0.24)" : "rgba(180,210,235,0.22)",
      };
    },
    [isDarkMode, isGoalComplete]
  );
  const glassBlurIntensity = Platform.OS === "android" ? 12 : 18;
  const glassBlurAmount = Math.max(3, Math.round(glassBlurIntensity * 0.4));
  const baseCoinSize = IS_SHORT_DEVICE ? 18 : 22;
  const coinSlots = useMemo(
    () => [
      { left: "18%", bottom: "18%", size: baseCoinSize, rotate: "-14deg" },
      { left: "32%", bottom: "26%", size: baseCoinSize * 0.92, rotate: "9deg" },
      { left: "48%", bottom: "16%", size: baseCoinSize * 0.96, rotate: "-6deg" },
      { left: "62%", bottom: "26%", size: baseCoinSize, rotate: "12deg" },
      { left: "72%", bottom: "18%", size: baseCoinSize * 0.86, rotate: "-8deg" },
      { left: "24%", bottom: "40%", size: baseCoinSize * 0.9, rotate: "6deg" },
      { left: "42%", bottom: "36%", size: baseCoinSize, rotate: "-10deg" },
      { left: "58%", bottom: "44%", size: baseCoinSize * 0.86, rotate: "8deg" },
      { left: "36%", bottom: "54%", size: baseCoinSize * 0.82, rotate: "-6deg" },
      { left: "54%", bottom: "56%", size: baseCoinSize * 0.76, rotate: "10deg" },
      { left: "16%", bottom: "58%", size: baseCoinSize * 0.7, rotate: "-4deg" },
      { left: "26%", bottom: "68%", size: baseCoinSize * 0.62, rotate: "8deg" },
      { left: "40%", bottom: "66%", size: baseCoinSize * 0.66, rotate: "-12deg" },
      { left: "52%", bottom: "70%", size: baseCoinSize * 0.6, rotate: "6deg" },
      { left: "68%", bottom: "62%", size: baseCoinSize * 0.64, rotate: "-8deg" },
      { left: "62%", bottom: "76%", size: baseCoinSize * 0.58, rotate: "12deg" },
    ],
    [baseCoinSize]
  );
  const jiggleAnim = useRef(new Animated.Value(0)).current;
  const dropAnim = useRef(new Animated.Value(0)).current;
  const lastDropTickRef = useRef(coinDropTick);
  const dropQueueRef = useRef(0);
  const dropRunningRef = useRef(false);
  const dropTimerRef = useRef(null);
  const [extraCoinCount, setExtraCoinCount] = useState(0);
  const lastSavedCountRef = useRef(0);
  const shakeStateRef = useRef({ lastMagnitude: 0, lastShakeAt: 0 });
  const gyroStateRef = useRef({ lastSpinAt: 0 });
  const [coinsClipLayout, setCoinsClipLayout] = useState({ width: 0, height: 0 });
  const [coinPhysics, setCoinPhysics] = useState([]);
  const coinPhysicsRef = useRef([]);
  const tiltRef = useRef({ x: 0, y: 0 });
  const tiltSmoothRef = useRef({ x: 0, y: 0 });
  const gyroRef = useRef({ x: 0, y: 0, z: 0 });
  const gyroSmoothRef = useRef({ x: 0, y: 0, z: 0 });
  const physicsLoopRef = useRef(null);
  const [appState, setAppState] = useState(() => AppState?.currentState || "active");
  const [tiltSource, setTiltSource] = useState(null);
  const [gyroSource, setGyroSource] = useState(null);
  const jiggleFactors = useMemo(
    () =>
      coinSlots.map(() => ({
        x: (Math.random() * 2 - 1) * 2.4,
        y: (Math.random() * 2 - 1) * 2.1,
        r: (Math.random() * 2 - 1) * 10,
      })),
    [coinSlots.length]
  );
  const handleCoinsClipLayout = useCallback((event) => {
    const { width, height } = event?.nativeEvent?.layout || {};
    if (!width || !height) return;
    setCoinsClipLayout((prev) =>
      prev.width === width && prev.height === height ? prev : { width, height }
    );
  }, []);
  const triggerJiggle = useCallback(() => {
    jiggleAnim.stopAnimation();
    jiggleAnim.setValue(0);
    Animated.sequence([
      Animated.timing(jiggleAnim, {
        toValue: 1,
        duration: 170,
        easing: Easing.out(Easing.cubic),
        useNativeDriver: true,
      }),
      Animated.timing(jiggleAnim, {
        toValue: 0,
        duration: 230,
        easing: Easing.inOut(Easing.cubic),
        useNativeDriver: true,
      }),
    ]).start();
  }, [jiggleAnim]);
  useEffect(() => {
    const subscription = AppState?.addEventListener?.("change", (nextState) => {
      setAppState(nextState || "active");
    });
    return () => subscription?.remove?.();
  }, []);
  useEffect(() => {
    let active = true;
    const isAvailable = async (sensor) => {
      if (!sensor) return false;
      if (typeof sensor.isAvailableAsync === "function") {
        try {
          return await sensor.isAvailableAsync();
        } catch (error) {
          console.warn("sensor availability", error);
          return false;
        }
      }
      return true;
    };
    const resolveSource = async (primary, fallback) => {
      if (await isAvailable(primary)) return primary;
      if (await isAvailable(fallback)) return fallback;
      return null;
    };
    (async () => {
      const tiltPrimary = Platform.OS === "android" ? Accelerometer : DeviceMotion;
      const tiltFallback = Platform.OS === "android" ? DeviceMotion : Accelerometer;
      const tilt = await resolveSource(tiltPrimary, tiltFallback);
      const gyro = await resolveSource(Gyroscope, DeviceMotion);
      if (!active) return;
      setTiltSource(tilt);
      setGyroSource(gyro);
    })();
    return () => {
      active = false;
    };
  }, []);
  useEffect(() => {
    return () => {
      if (dropTimerRef.current) {
        clearTimeout(dropTimerRef.current);
        dropTimerRef.current = null;
      }
    };
  }, []);
  useEffect(() => {
    if (!coinsClipLayout.width || !coinsClipLayout.height) return;
    const width = coinsClipLayout.width;
    const height = coinsClipLayout.height;
    const innerWidth = Math.max(0, width - PIGGY_COIN_PADDING_X * 2);
    const innerHeight = Math.max(0, height - PIGGY_COIN_PADDING_Y * 2);
    const nextPhysics = coinSlots.map((slot, index) => {
      const leftPercent = parsePercentValue(slot.left);
      const bottomPercent = parsePercentValue(slot.bottom);
      const size = slot.size;
      const leftPx = PIGGY_COIN_PADDING_X + leftPercent * innerWidth;
      const bottomPx = PIGGY_COIN_PADDING_Y + bottomPercent * innerHeight;
      const maxX = Math.max(PIGGY_COIN_PADDING_X, width - PIGGY_COIN_PADDING_X - size);
      const maxY = Math.max(PIGGY_COIN_PADDING_Y, height - PIGGY_COIN_PADDING_Y - size);
      const x = Math.max(PIGGY_COIN_PADDING_X, Math.min(leftPx, maxX));
      const y = Math.max(PIGGY_COIN_PADDING_Y, Math.min(height - bottomPx - size, maxY));
      return {
        id: `piggy-coin-${index}`,
        x,
        y,
        vx: 0,
        vy: 0,
        size,
        animX: new Animated.Value(x),
        animY: new Animated.Value(y),
        rotate: slot.rotate,
      };
    });
    coinPhysicsRef.current = nextPhysics;
    setCoinPhysics(nextPhysics);
  }, [coinSlots, coinsClipLayout.height, coinsClipLayout.width]);
  const runNextDrop = useCallback(() => {
    if (dropRunningRef.current) return;
    if (!isActive) return;
    if (dropQueueRef.current <= 0) return;
    dropRunningRef.current = true;
    dropQueueRef.current -= 1;
    dropAnim.stopAnimation();
    dropAnim.setValue(0);
    Animated.timing(dropAnim, {
      toValue: 1,
      duration: 720,
      easing: Easing.out(Easing.quad),
      useNativeDriver: true,
    }).start(() => {
      dropAnim.setValue(0);
      dropRunningRef.current = false;
      if (dropQueueRef.current > 0) {
        dropTimerRef.current = setTimeout(runNextDrop, 140);
      }
    });
    triggerJiggle();
  }, [dropAnim, isActive, triggerJiggle]);
  useEffect(() => {
    if (!GREEN_HEALTH_COIN_ASSET) return;
    if (coinDropTick === lastDropTickRef.current) return;
    const delta = coinDropTick - lastDropTickRef.current;
    lastDropTickRef.current = coinDropTick;
    if (delta <= 0) return;
    dropQueueRef.current += delta * 2;
    setExtraCoinCount((prev) => Math.min(coinSlots.length, prev + delta * 2));
    if (isActive) {
      runNextDrop();
    }
  }, [coinDropTick, coinSlots.length, isActive, runNextDrop]);
  useEffect(() => {
    if (!isActive) return;
    if (dropQueueRef.current > 0) {
      runNextDrop();
    }
  }, [isActive, runNextDrop]);
  const isAppActive = appState !== "background" && appState !== "inactive";
  const sensorActive = isAppActive;
  const effectiveTiltSource = Accelerometer || tiltSource || DeviceMotion;
  const effectiveGyroSource = Gyroscope || gyroSource || DeviceMotion;
  const gyroEnabled = Boolean(effectiveGyroSource);
  const physicsEnabled = isActive && isAppActive;
  const shakeActive = isActive && shakeEnabled && isAppActive;
  useEffect(() => {
    if (!Accelerometer || !shakeActive) return;
    try {
      Accelerometer.setUpdateInterval(120);
    } catch (error) {
      console.warn("accelerometer interval", error);
    }
    const subscription = Accelerometer.addListener(({ x, y, z }) => {
      const magnitude = Math.sqrt(x * x + y * y + z * z);
      const previous = shakeStateRef.current.lastMagnitude || magnitude;
      shakeStateRef.current.lastMagnitude = magnitude;
      const delta = Math.abs(magnitude - previous);
      const now = Date.now();
      if (
        delta > DAILY_GOAL_SHAKE_THRESHOLD &&
        now - shakeStateRef.current.lastShakeAt > DAILY_GOAL_SHAKE_COOLDOWN_MS
      ) {
        shakeStateRef.current.lastShakeAt = now;
        triggerJiggle();
      }
    });
    return () => subscription?.remove?.();
  }, [shakeActive, triggerJiggle]);
  useEffect(() => {
    if (!isAppActive) return;
    const activeTiltSource = effectiveTiltSource;
    if (!activeTiltSource) return;
    const requestPermissions = async () => {
      try {
        if (typeof activeTiltSource.getPermissionsAsync === "function") {
          await activeTiltSource.getPermissionsAsync();
          if (typeof activeTiltSource.requestPermissionsAsync === "function") {
            await activeTiltSource.requestPermissionsAsync();
          }
        } else if (typeof activeTiltSource.requestPermissionsAsync === "function") {
          await activeTiltSource.requestPermissionsAsync();
        }
      } catch (error) {
        // Swallow permission errors to avoid interrupting tilt updates.
      }
    };
    requestPermissions();
    try {
      activeTiltSource.setUpdateInterval?.(60);
    } catch (error) {
      console.warn("tilt interval", error);
    }
    const subscription = activeTiltSource.addListener((payload) => {
      let x = 0;
      let y = 0;
      if (payload?.gravity) {
        x = Number(payload.gravity.x ?? 0);
        y = Number(payload.gravity.y ?? 0);
      } else if (payload?.accelerationIncludingGravity) {
        x = Number(payload.accelerationIncludingGravity.x ?? 0);
        y = Number(payload.accelerationIncludingGravity.y ?? 0);
      } else if (typeof payload?.x === "number") {
        x = Number(payload.x);
        y = Number(payload.y);
      }
      if (Math.abs(x) > 2 || Math.abs(y) > 2) {
        x /= 9.81;
        y /= 9.81;
      }
      if (Platform.OS === "android") {
        // Android sensor Y axis is inverted relative to our screen physics.
        y = -y;
      }
      const clampedX = Math.max(-1, Math.min(1, x));
      const clampedY = Math.max(-1, Math.min(1, y));
      const prev = tiltSmoothRef.current;
      const smoothing = 0.35;
      const nextX = prev.x + (clampedX - prev.x) * smoothing;
      const nextY = prev.y + (clampedY - prev.y) * smoothing;
      tiltSmoothRef.current.x = nextX;
      tiltSmoothRef.current.y = nextY;
      tiltRef.current.x = nextX;
      tiltRef.current.y = nextY;

      const rotation = payload?.rotationRate || payload?.rotation || null;
      if (rotation) {
        const rawX = Number(rotation.x ?? rotation.alpha ?? 0);
        const rawY = Number(rotation.y ?? rotation.beta ?? 0);
        const rawZ = Number(rotation.z ?? rotation.gamma ?? 0);
        const clamp = (value) =>
          Math.max(-DAILY_GOAL_GYRO_CLAMP, Math.min(DAILY_GOAL_GYRO_CLAMP, value));
        const next = gyroSmoothRef.current;
        const gyroSmoothing = 0.18;
        const targetX = clamp(rawX);
        const targetY = clamp(rawY);
        const targetZ = clamp(rawZ);
        next.x = next.x + (targetX - next.x) * gyroSmoothing;
        next.y = next.y + (targetY - next.y) * gyroSmoothing;
        next.z = next.z + (targetZ - next.z) * gyroSmoothing;
        gyroRef.current.x = next.x;
        gyroRef.current.y = next.y;
        gyroRef.current.z = next.z;
      }
    });
    return () => {
      subscription?.remove?.();
    };
  }, [appState, effectiveTiltSource, isAppActive]);
  useEffect(() => {
    if (!gyroEnabled) return;
    const activeGyroSource = effectiveGyroSource;
    if (!activeGyroSource) return;
    try {
      activeGyroSource.setUpdateInterval?.(60);
    } catch (error) {
      console.warn("gyro interval", error);
    }
    const subscription = activeGyroSource.addListener((payload) => {
      const rotation = payload?.rotationRate || payload?.rotation || payload || {};
      const rawX = Number(rotation?.x ?? rotation?.alpha ?? 0);
      const rawY = Number(rotation?.y ?? rotation?.beta ?? 0);
      const rawZ = Number(rotation?.z ?? rotation?.gamma ?? 0);
      const clamp = (value) =>
        Math.max(-DAILY_GOAL_GYRO_CLAMP, Math.min(DAILY_GOAL_GYRO_CLAMP, value));
      const next = gyroSmoothRef.current;
      const gyroSmoothing = 0.18;
      const targetX = clamp(rawX);
      const targetY = clamp(rawY);
      const targetZ = clamp(rawZ);
      next.x = next.x + (targetX - next.x) * gyroSmoothing;
      next.y = next.y + (targetY - next.y) * gyroSmoothing;
      next.z = next.z + (targetZ - next.z) * gyroSmoothing;
      gyroRef.current.x = next.x;
      gyroRef.current.y = next.y;
      gyroRef.current.z = next.z;
    });
    return () => subscription?.remove?.();
  }, [effectiveGyroSource, gyroEnabled]);
  useEffect(() => {
    if (!physicsEnabled) return;
    if (!coinsClipLayout.width || !coinsClipLayout.height) return;
    if (!coinPhysics.length) return;
    let cancelled = false;
    let lastTime = Date.now();
    const step = () => {
      if (cancelled) return;
      const now = Date.now();
      const dt = Math.min(32, now - lastTime) / 1000;
      lastTime = now;
      const tiltX = Math.abs(tiltRef.current.x) < DAILY_GOAL_TILT_DEADZONE ? 0 : tiltRef.current.x;
      const tiltY = Math.abs(tiltRef.current.y) < DAILY_GOAL_TILT_DEADZONE ? 0 : tiltRef.current.y;
      const gyro = gyroRef.current;
      const gyroX = gyro?.y ?? 0;
      const gyroY = gyro?.x ?? 0;
      const gyroAccelX = gyroX * DAILY_GOAL_GYRO_ACCEL;
      const gyroAccelY = -gyroY * DAILY_GOAL_GYRO_ACCEL;
      const tiltMagnitude = Math.hypot(tiltX, tiltY);
      const tiltStrength = Math.min(1, tiltMagnitude);
      const gravityDir =
        tiltMagnitude > DAILY_GOAL_TILT_DEADZONE
          ? { x: tiltX / tiltMagnitude, y: -tiltY / tiltMagnitude }
          : { x: 0, y: 1 };
      const gravityStrength = DAILY_GOAL_GRAVITY + tiltStrength * DAILY_GOAL_TILT_ACCEL;
      const accelX = gravityDir.x * gravityStrength + gyroAccelX;
      const accelY = gravityDir.y * gravityStrength + gyroAccelY;
      const gyroMagnitude = Math.hypot(gyroX, gyroY);
      const allowSleep =
        tiltMagnitude < DAILY_GOAL_TILT_STOP_TILT && gyroMagnitude < DAILY_GOAL_TILT_STOP_GYRO;
      const maxSpeed = DAILY_GOAL_TILT_MAX_SPEED;
      const bounce = DAILY_GOAL_TILT_BOUNCE;
      const width = coinsClipLayout.width;
      const height = coinsClipLayout.height;
      const minX = PIGGY_COIN_PADDING_X;
      const minY = PIGGY_COIN_PADDING_Y;
      const maxX = width - PIGGY_COIN_PADDING_X;
      const maxY = height - PIGGY_COIN_PADDING_Y;
      const centerX = width / 2;
      const centerY = height / 2;
      const baseRadiusX = Math.max(1, (width - PIGGY_COIN_PADDING_X * 2) / 2);
      const baseRadiusY = Math.max(1, (height - PIGGY_COIN_PADDING_Y * 2) / 2);
      const coins = coinPhysicsRef.current;
      const collisionBounce = DAILY_GOAL_COIN_COLLISION_BOUNCE;
      const clampCoinToBounds = (coin) => {
        const limitX = Math.max(minX, maxX - coin.size);
        const limitY = Math.max(minY, maxY - coin.size);
        if (coin.x < minX) {
          coin.x = minX;
          coin.vx *= -bounce;
        } else if (coin.x > limitX) {
          coin.x = limitX;
          coin.vx *= -bounce;
        }
        if (coin.y < minY) {
          coin.y = minY;
          coin.vy *= -bounce;
        } else if (coin.y > limitY) {
          coin.y = limitY;
          coin.vy *= -bounce;
        }
        const radiusX = Math.max(1, baseRadiusX - coin.size / 2);
        const radiusY = Math.max(1, baseRadiusY - coin.size / 2);
        const coinCenterX = coin.x + coin.size / 2;
        const coinCenterY = coin.y + coin.size / 2;
        const normX = (coinCenterX - centerX) / radiusX;
        const normY = (coinCenterY - centerY) / radiusY;
        const distSq = normX * normX + normY * normY;
        if (distSq > 1) {
          const dist = Math.sqrt(distSq) || 1;
          const scale = 1 / dist;
          const clampedCenterX = centerX + (coinCenterX - centerX) * scale;
          const clampedCenterY = centerY + (coinCenterY - centerY) * scale;
          coin.x = clampedCenterX - coin.size / 2;
          coin.y = clampedCenterY - coin.size / 2;
          const normalXRaw = (clampedCenterX - centerX) / (radiusX * radiusX);
          const normalYRaw = (clampedCenterY - centerY) / (radiusY * radiusY);
          const normalLength = Math.hypot(normalXRaw, normalYRaw) || 1;
          const normalX = normalXRaw / normalLength;
          const normalY = normalYRaw / normalLength;
          const velocityDot = coin.vx * normalX + coin.vy * normalY;
          if (velocityDot > 0) {
            coin.vx -= (1 + bounce) * velocityDot * normalX;
            coin.vy -= (1 + bounce) * velocityDot * normalY;
          }
        }
      };
      coins.forEach((coin) => {
        if (!coin) return;
        coin.vx += accelX * dt;
        coin.vy += accelY * dt;
        const speed = Math.hypot(coin.vx, coin.vy);
        const drag = Math.exp(-(DAILY_GOAL_TILT_FRICTION + speed * DAILY_GOAL_TILT_DRAG) * dt);
        coin.vx *= drag;
        coin.vy *= drag;
        if (allowSleep && speed < DAILY_GOAL_TILT_STOP_SPEED) {
          coin.vx = 0;
          coin.vy = 0;
        }
        if (speed > maxSpeed && speed > 0) {
          const scale = maxSpeed / speed;
          coin.vx *= scale;
          coin.vy *= scale;
        }
        coin.x += coin.vx * dt;
        coin.y += coin.vy * dt;
        clampCoinToBounds(coin);
      });
      for (let iter = 0; iter < DAILY_GOAL_COIN_COLLISION_ITERATIONS; iter += 1) {
        const applyImpulse = iter === 0;
        for (let i = 0; i < coins.length; i += 1) {
          const coinA = coins[i];
          if (!coinA) continue;
          for (let j = i + 1; j < coins.length; j += 1) {
            const coinB = coins[j];
            if (!coinB) continue;
            const radiusA = coinA.size * 0.5;
            const radiusB = coinB.size * 0.5;
            const centerAx = coinA.x + radiusA;
            const centerAy = coinA.y + radiusA;
            const centerBx = coinB.x + radiusB;
            const centerBy = coinB.y + radiusB;
            const dx = centerBx - centerAx;
            const dy = centerBy - centerAy;
            const minDist = radiusA + radiusB;
            const distSq = dx * dx + dy * dy;
            if (distSq < minDist * minDist) {
              const dist = Math.sqrt(distSq) || 0.0001;
              const hasNormal = distSq > 0.000001;
              const normalX = hasNormal ? dx / dist : 1;
              const normalY = hasNormal ? dy / dist : 0;
              const overlap = minDist - dist;
              if (overlap > 0) {
                const correction =
                  Math.max(0, overlap - DAILY_GOAL_COIN_COLLISION_SLOP) *
                  DAILY_GOAL_COIN_COLLISION_PERCENT;
                if (correction > 0) {
                  const separation = correction / 2;
                  coinA.x -= normalX * separation;
                  coinA.y -= normalY * separation;
                  coinB.x += normalX * separation;
                  coinB.y += normalY * separation;
                }
              }
              const relVelX = coinA.vx - coinB.vx;
              const relVelY = coinA.vy - coinB.vy;
              const relVel = relVelX * normalX + relVelY * normalY;
              const relSpeed = Math.abs(relVel);
              if (applyImpulse && relVel < -DAILY_GOAL_COIN_COLLISION_VELOCITY_EPS) {
                const restitutionScale = Math.min(
                  1,
                  Math.max(
                    0,
                    (relSpeed - DAILY_GOAL_COIN_COLLISION_RESTITUTION_MIN_SPEED) /
                      DAILY_GOAL_COIN_COLLISION_RESTITUTION_RANGE
                  )
                );
                const restitution = collisionBounce * restitutionScale;
                const impulse = (-(1 + restitution) * relVel) / 2;
                const impulseX = impulse * normalX;
                const impulseY = impulse * normalY;
                coinA.vx += impulseX;
                coinA.vy += impulseY;
                coinB.vx -= impulseX;
                coinB.vy -= impulseY;
              }
              if (overlap > DAILY_GOAL_COIN_COLLISION_SLOP && relSpeed < DAILY_GOAL_COIN_COLLISION_REST_SPEED) {
                const cancel = relVel * 0.5;
                coinA.vx -= cancel * normalX;
                coinA.vy -= cancel * normalY;
                coinB.vx += cancel * normalX;
                coinB.vy += cancel * normalY;
                coinA.vx *= DAILY_GOAL_COIN_COLLISION_REST_DAMPING;
                coinA.vy *= DAILY_GOAL_COIN_COLLISION_REST_DAMPING;
                coinB.vx *= DAILY_GOAL_COIN_COLLISION_REST_DAMPING;
                coinB.vy *= DAILY_GOAL_COIN_COLLISION_REST_DAMPING;
              }
            }
          }
        }
      }
      coins.forEach((coin) => {
        if (!coin) return;
        clampCoinToBounds(coin);
        coin.animX.setValue(coin.x);
        coin.animY.setValue(coin.y);
      });
      physicsLoopRef.current = requestAnimationFrame(step);
    };
    physicsLoopRef.current = requestAnimationFrame(step);
    return () => {
      cancelled = true;
      if (physicsLoopRef.current) {
        cancelAnimationFrame(physicsLoopRef.current);
        physicsLoopRef.current = null;
      }
    };
  }, [coinPhysics.length, coinsClipLayout.height, coinsClipLayout.width, physicsEnabled]);
  useEffect(() => {
    if (!shakeActive) return;
    const activeGyroSource = effectiveGyroSource;
    if (!activeGyroSource) return;
    try {
      if (activeGyroSource !== DeviceMotion || !sensorActive) {
        activeGyroSource.setUpdateInterval?.(120);
      }
    } catch (error) {
      console.warn("gyro interval", error);
    }
    const subscription = activeGyroSource.addListener((payload) => {
      const rotation = payload?.rotationRate || payload?.rotation || payload || {};
      const x = Number(rotation.x ?? rotation.alpha ?? 0);
      const y = Number(rotation.y ?? rotation.beta ?? 0);
      const z = Number(rotation.z ?? rotation.gamma ?? 0);
      const spin = Math.sqrt(x * x + y * y + z * z);
      const now = Date.now();
    if (spin > DAILY_GOAL_GYRO_THRESHOLD && now - gyroStateRef.current.lastSpinAt > DAILY_GOAL_GYRO_COOLDOWN_MS) {
      gyroStateRef.current.lastSpinAt = now;
      triggerJiggle();
    }
  });
    return () => subscription?.remove?.();
  }, [effectiveGyroSource, sensorActive, shakeActive, triggerJiggle]);
  const safeSavedCardCount = Math.max(0, Math.floor(Number(savedCardCount) || 0));
  useEffect(() => {
    const prev = lastSavedCountRef.current;
    if (safeSavedCardCount === prev) return;
    lastSavedCountRef.current = safeSavedCardCount;
    const delta = safeSavedCardCount - prev;
    setExtraCoinCount((current) => {
      if (delta <= 0) return 0;
      const next = Math.max(0, current - delta * 2);
      return next;
    });
  }, [safeSavedCardCount]);
  const coinsToShow = Math.min(coinSlots.length, safeSavedCardCount * 2 + extraCoinCount);
  const displayGoalLabel = dailyGoalLabel || "0";
  const collectableCoins = Math.max(0, Math.floor(coinsToShow));
  const canCollect = isGoalComplete && collectableCoins > 0 && !isCollected;
  const collectHintLabel = useMemo(() => t("dailyGoalCollectHint"), [t]);
  const handleCollectPress = useCallback(() => {
    if (!canCollect) return;
    if (typeof onCollectCoins !== "function") return;
    onCollectCoins(collectableCoins);
  }, [canCollect, collectableCoins, onCollectCoins]);
  const checkmarkColor = isDarkMode ? "#7FE4AC" : SAVE_ACTION_COLOR;
  const lidPalette = useMemo(
    () =>
      isGoalComplete
        ? {
            base: isDarkMode ? "#E2B35C" : "#F5C978",
            border: isDarkMode ? "#B6842E" : "#D6A24C",
            shine: isDarkMode ? "rgba(255,255,255,0.4)" : "rgba(255,255,255,0.7)",
            knob: isDarkMode ? "#F6D28A" : "#FFE2A6",
            shadow: isDarkMode ? "rgba(0,0,0,0.5)" : "rgba(140,98,20,0.3)",
          }
        : null,
    [isDarkMode, isGoalComplete]
  );
  const dropTranslateY = dropAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [-60, 24],
  });
  const dropOpacity = dropAnim.interpolate({
    inputRange: [0, 0.12, 1],
    outputRange: [0, 1, 0.9],
  });
  const dropScale = dropAnim.interpolate({
    inputRange: [0, 0.45, 1],
    outputRange: [0.9, 1.05, 0.98],
  });
  return (
    <View
      style={[
        styles.progressHeroCard,
        styles.savedHeroCard,
        styles.heroDailyCard,
        {
          backgroundColor: palette.background,
          borderColor: palette.border,
          shadowColor: isDarkMode ? "#000" : "rgba(0,0,0,0.2)",
        },
        style,
      ]}
    >
      <View pointerEvents="none" style={styles.savedHeroGlowWrap}>
        <View style={[styles.savedHeroGlow, { backgroundColor: glowColor }]} />
        <View style={[styles.savedHeroGlow, styles.savedHeroGlowBottom, { backgroundColor: glowColor }]} />
      </View>
      <View style={styles.heroDailyHeader}>
        <Text style={[styles.heroDailyTitle, { color: palette.subtext }]}>
          {t("dailyGoalTitle")}
        </Text>
        {monthLabel ? (
          <View style={[styles.heroDailyChip, { borderColor: palette.border }]}>
            <Text style={[styles.heroDailyChipText, { color: palette.subtext }]} numberOfLines={1}>
              {monthLabel}
            </Text>
          </View>
        ) : null}
      </View>
      <View style={styles.heroDailyGoalBody}>
        <View style={styles.piggyWrap}>
          <Pressable
            style={styles.piggyBodyWrap}
            onPress={handleCollectPress}
            disabled={!canCollect}
          >
            <View style={[styles.piggyShadow, { shadowColor: piggyPalette.shadow }]} />
            <View
              style={[
                styles.piggyBody,
                {
                  backgroundColor: piggyPalette.fill,
                  borderColor: piggyPalette.border,
                  shadowColor: piggyPalette.shadow,
                },
              ]}
            >
              {blurAvailable ? (
                Platform.OS === "android" && AndroidBlurView && !ANDROID_DIMEZIS_DISABLED ? (
                  <AndroidBlurView
                    blurType={isDarkMode ? "dark" : "light"}
                    blurAmount={glassBlurAmount}
                    autoUpdate={ANDROID_BLUR_AUTO_UPDATE}
                    reducedTransparencyFallbackColor={piggyPalette.tint}
                    style={[StyleSheet.absoluteFill, styles.piggyGlassBlur]}
                  />
                ) : (
                  <ExpoBlurView
                    tint={isDarkMode ? "dark" : "light"}
                    intensity={glassBlurIntensity}
                    experimentalBlurMethod={
                      Platform.OS === "android" && !ANDROID_DIMEZIS_DISABLED
                        ? "dimezisBlurView"
                        : undefined
                    }
                    style={[StyleSheet.absoluteFill, styles.piggyGlassBlur]}
                  />
                )
              ) : (
                <View
                  style={[
                    StyleSheet.absoluteFill,
                    styles.piggyGlassBlurFallback,
                    { backgroundColor: piggyPalette.tint },
                  ]}
                />
              )}
              <Svg style={StyleSheet.absoluteFill} pointerEvents="none">
                <Defs>
                  <SvgLinearGradient id={glassGradientId} x1="0" y1="0" x2="1" y2="1">
                    <SvgStop offset="0" stopColor={colorWithAlpha("#FFFFFF", isDarkMode ? 0.16 : 0.5)} />
                    <SvgStop
                      offset="0.52"
                      stopColor={colorWithAlpha("#FFFFFF", isDarkMode ? 0.06 : 0.2)}
                    />
                    <SvgStop
                      offset="1"
                      stopColor={colorWithAlpha("#9FB3CF", isDarkMode ? 0.18 : 0.26)}
                    />
                  </SvgLinearGradient>
                  <SvgLinearGradient id={glassShadeId} x1="0.1" y1="0" x2="0.9" y2="1">
                    <SvgStop
                      offset="0"
                      stopColor={colorWithAlpha("#FFFFFF", isDarkMode ? 0.12 : 0.3)}
                    />
                    <SvgStop
                      offset="0.65"
                      stopColor={colorWithAlpha("#FFFFFF", isDarkMode ? 0.04 : 0.1)}
                    />
                    <SvgStop
                      offset="1"
                      stopColor={colorWithAlpha("#5D6C8A", isDarkMode ? 0.35 : 0.22)}
                    />
                  </SvgLinearGradient>
                </Defs>
                <SvgRect x="0" y="0" width="100%" height="100%" fill={`url(#${glassGradientId})`} />
                <SvgRect x="0" y="0" width="100%" height="100%" fill={`url(#${glassShadeId})`} />
              </Svg>
              <View style={[styles.piggyGlassInner, { borderColor: piggyPalette.innerShadow }]} />
              <View style={[styles.piggyGlassHighlight, { backgroundColor: piggyPalette.highlight }]} />
              <View
                style={[
                  styles.piggyGlassHighlight,
                  styles.piggyGlassHighlightSecondary,
                  { backgroundColor: piggyPalette.highlight },
                ]}
              />
              <View style={[styles.piggyGlassRim, { backgroundColor: piggyPalette.rim }]} />
              {isGoalComplete && lidPalette ? (
                <>
                  <View
                    style={[
                      styles.piggyLid,
                      {
                        backgroundColor: lidPalette.base,
                        borderColor: lidPalette.border,
                        shadowColor: lidPalette.shadow,
                      },
                    ]}
                  />
                  <View style={[styles.piggyLidHighlight, { backgroundColor: lidPalette.shine }]} />
                  <View
                    style={[
                      styles.piggyLidKnob,
                      { backgroundColor: lidPalette.knob, borderColor: lidPalette.border },
                    ]}
                  />
                </>
              ) : null}
              <View style={styles.piggyCoinsClip} onLayout={handleCoinsClipLayout} pointerEvents="none">
                {GREEN_HEALTH_COIN_ASSET
                  ? coinSlots.slice(0, coinsToShow).map((slot, index) => {
                      const jiggle = jiggleFactors[index] || { x: 0, y: 0, r: 0 };
                      const jiggleX = Animated.multiply(jiggleAnim, jiggle.x);
                      const jiggleY = Animated.multiply(jiggleAnim, jiggle.y);
                      const rotate = jiggleAnim.interpolate({
                        inputRange: [0, 1],
                        outputRange: ["0deg", `${jiggle.r}deg`],
                      });
                      const opacity = Math.max(0.3, 0.95 - index * 0.05);
                      const physicsCoin = coinPhysics[index];
                      const translateX = physicsCoin ? Animated.add(physicsCoin.animX, jiggleX) : jiggleX;
                      const translateY = physicsCoin ? Animated.add(physicsCoin.animY, jiggleY) : jiggleY;
                      const size = physicsCoin?.size ?? slot.size;
                      const baseStyle = physicsCoin
                        ? { left: 0, top: 0, width: size, height: size }
                        : { left: slot.left, bottom: slot.bottom, width: size, height: size };
                      return (
                        <Animated.Image
                          key={`piggy-coin-${index}`}
                          source={GREEN_HEALTH_COIN_ASSET}
                          style={[
                            styles.piggyCoin,
                            baseStyle,
                            {
                              opacity,
                              transform: [
                                { translateX },
                                { translateY },
                                { rotate: slot.rotate },
                                { rotate: rotate },
                              ],
                            },
                          ]}
                          pointerEvents="none"
                        />
                      );
                    })
                  : null}
              </View>
              <View style={styles.piggyGoalValueWrap}>
                {isGoalComplete ? (
                  <>
                    {canCollect ? (
                      <Text style={[styles.piggyCollectLabel, { color: checkmarkColor }]}>
                        {collectHintLabel}
                      </Text>
                    ) : null}
                    <Text style={[styles.piggyGoalCheck, { color: checkmarkColor }]}>âœ“</Text>
                  </>
                ) : (
                  <Text
                    style={[styles.piggyGoalValue, { color: piggyPalette.value }]}
                    numberOfLines={1}
                    adjustsFontSizeToFit
                    minimumFontScale={0.7}
                  >
                    {displayGoalLabel}
                  </Text>
                )}
              </View>
            </View>
            <View
              style={[
                styles.piggyEarLeft,
                { backgroundColor: piggyPalette.fill, borderColor: piggyPalette.border },
              ]}
            />
            <View
              style={[
                styles.piggyEarRight,
                { backgroundColor: piggyPalette.fill, borderColor: piggyPalette.border },
              ]}
            />
            <View
              style={[
                styles.piggySnout,
                { backgroundColor: piggyPalette.fill, borderColor: piggyPalette.border },
              ]}
            >
              <View style={styles.piggyNostrilRow}>
                <View style={[styles.piggyNostril, { backgroundColor: piggyPalette.border }]} />
                <View style={[styles.piggyNostril, { backgroundColor: piggyPalette.border }]} />
              </View>
            </View>
            <View
              style={[
                styles.piggyLegLeft,
                { backgroundColor: piggyPalette.fill, borderColor: piggyPalette.border },
              ]}
            />
            <View
              style={[
                styles.piggyLegRight,
                { backgroundColor: piggyPalette.fill, borderColor: piggyPalette.border },
              ]}
            />
            <View style={[styles.piggyTail, { backgroundColor: piggyPalette.border }]} />
            {GREEN_HEALTH_COIN_ASSET ? (
              <Animated.Image
                source={GREEN_HEALTH_COIN_ASSET}
                style={[
                  styles.piggyDropCoin,
                  {
                    opacity: dropOpacity,
                    transform: [{ translateY: dropTranslateY }, { scale: dropScale }],
                  },
                ]}
                pointerEvents="none"
              />
            ) : null}
          </Pressable>
        </View>
        <Text style={[styles.heroDailySubtitle, { color: palette.subtext }]}>
          {t("dailyGoalSubtitle")}
        </Text>
      </View>
    </View>
  );
});

const resolveFeatureUnlockCopy = (variantKey, t) => {
  const config = FEATURE_UNLOCK_VARIANT_CONFIG[variantKey];
  if (!config) {
    return { title: "", description: "" };
  }
  return {
    title: t(config.titleKey),
    description: t(config.descriptionKey),
  };
};

const compactUnlockCopy = (value, maxLength = 132) => {
  const raw = String(value || "").replace(/\s+/g, " ").trim();
  if (!raw) return "";
  const sentenceMatch = raw.match(/^(.+?[.!?])(\s|$)/);
  const firstSentence = sentenceMatch ? sentenceMatch[1].trim() : raw;
  if (
    firstSentence.length >= Math.max(24, Math.floor(maxLength * 0.4)) &&
    firstSentence.length <= maxLength
  ) {
    return firstSentence;
  }
  if (raw.length <= maxLength) return raw;
  const sliced = raw.slice(0, Math.max(16, maxLength)).trim();
  const clipped = sliced.replace(/[.,;:!?-]+$/g, "").trim();
  return `${clipped}...`;
};

const stripUnlockLevelPrefix = (value) =>
  String(value || "")
    .replace(/\s+/g, " ")
    .replace(/^(?:level|ÑƒÑ€Ð¾Ð²ÐµÐ½ÑŒ|niveau|nivel)\s*\d+\s*[:!.\-â€“â€”]?\s*/i, "")
    .trim();

const LockedFeatureOverlay = ({
  locked,
  variantKey,
  level,
  colors,
  t,
  style,
  contentStyle,
  borderRadius = 20,
  blurIntensity = 18,
  compact = false,
  centered = false,
  premiumStyle = false,
  children,
}) => {
  const blurAvailable = useMemo(() => isBlurViewAvailable(), []);
  if (!locked) {
    return <View style={style}>{children}</View>;
  }
  const { title, description } = resolveFeatureUnlockCopy(variantKey, t);
  const unlockLevel = Number(level) || FEATURE_UNLOCK_LEVELS[variantKey] || null;
  const isPremiumVariant = FEATURE_UNLOCK_PREMIUM_VARIANTS.has(variantKey);
  const unlockBadgeText = isPremiumVariant
    ? t("featureLockedPremiumLabel")
    : unlockLevel
    ? t("featureLockedLevelLabel", { level: unlockLevel })
    : "";
  const isDarkMode = colors?.background === THEMES.dark.background;
  const premiumAccent = isDarkMode ? "#8CB8FF" : "#4353FF";
  const textColor = premiumStyle
    ? isDarkMode
      ? "#EAF2FF"
      : "#1B2D59"
    : isDarkMode
    ? "#F7F2E6"
    : "#2A1C00";
  const subTextColor = premiumStyle
    ? isDarkMode
      ? "rgba(220,232,255,0.86)"
      : "rgba(38,61,110,0.82)"
    : isDarkMode
    ? "rgba(247,242,230,0.8)"
    : "rgba(42,28,0,0.7)";
  const badgeBg = premiumStyle
    ? colorWithAlpha(premiumAccent, isDarkMode ? 0.26 : 0.14)
    : isDarkMode
    ? "rgba(0,0,0,0.35)"
    : "rgba(255,255,255,0.8)";
  const badgeBorder = premiumStyle
    ? colorWithAlpha(premiumAccent, isDarkMode ? 0.56 : 0.32)
    : isDarkMode
    ? "rgba(255,255,255,0.2)"
    : "rgba(0,0,0,0.1)";
  const overlayScrim = premiumStyle
    ? isDarkMode
      ? Platform.OS === "android"
        ? "rgba(5,15,40,0.56)"
        : "rgba(5,15,40,0.7)"
      : Platform.OS === "android"
      ? "rgba(233,241,255,0.54)"
      : "rgba(239,246,255,0.78)"
    : isDarkMode
    ? Platform.OS === "android"
      ? "rgba(5,5,5,0.38)"
      : "rgba(5,5,5,0.58)"
    : Platform.OS === "android"
    ? "rgba(255,255,255,0.35)"
    : "rgba(255,255,255,0.7)";
  const lockIconColor = premiumStyle ? premiumAccent : textColor;
  const badgeTextColor = premiumStyle ? premiumAccent : textColor;
  const premiumPillBackground = colorWithAlpha(premiumAccent, isDarkMode ? 0.24 : 0.14);
  const premiumPillBorder = colorWithAlpha(premiumAccent, isDarkMode ? 0.52 : 0.3);
  const premiumBadgeText = unlockBadgeText ? `ðŸ”’ ${unlockBadgeText}` : "";
  const radiusStyle = Number.isFinite(borderRadius) ? { borderRadius } : null;
  const compactOverlayStyle = compact ? styles.lockedFeatureOverlayCompact : null;
  const compactContentStyle = compact ? styles.lockedFeatureOverlayContentCompact : null;
  const compactTitleStyle = compact ? styles.lockedFeatureTitleCompact : null;
  const compactDescriptionStyle = compact ? styles.lockedFeatureDescriptionCompact : null;
  const compactBadgeStyle = compact ? styles.lockedFeatureLevelBadgeCompact : null;
  const compactBadgeTextStyle = compact ? styles.lockedFeatureLevelTextCompact : null;
  const compactLockStyle = compact ? styles.lockedFeatureLockIconCompact : null;
  const centeredOverlayStyle = centered ? styles.lockedFeatureOverlayCentered : null;
  const centeredContentStyle = centered ? styles.lockedFeatureOverlayContentCentered : null;
  const centeredTitleStyle = centered ? styles.lockedFeatureTitleCentered : null;
  const centeredDescriptionStyle = centered ? styles.lockedFeatureDescriptionCentered : null;
  const centeredLockRowStyle = centered ? styles.lockedFeatureLockRowCentered : null;
  const centeredBadgeStyle = centered ? styles.lockedFeatureLevelBadgeCentered : null;
  const centeredLockStyle = centered ? styles.lockedFeatureLockIconCentered : null;
  const androidBlurAmount = Math.max(2, Math.round((Number(blurIntensity) || 0) * 0.3));
  const blurIntensityValue = Platform.OS === "android" ? androidBlurAmount : blurIntensity;
  const androidBlurFallback = isDarkMode ? "#0B0B0B" : "#F2F2F2";
  return (
    <View style={[styles.lockedFeatureWrap, radiusStyle, style]}>
      <View style={contentStyle} pointerEvents="none">
        {children}
      </View>
        <View
          style={[styles.lockedFeatureOverlay, radiusStyle, compactOverlayStyle, centeredOverlayStyle]}
          pointerEvents="auto"
        >
          {blurAvailable ? (
            Platform.OS === "android" && AndroidBlurView && !ANDROID_DIMEZIS_DISABLED ? (
              <AndroidBlurView
                blurType={isDarkMode ? "dark" : "light"}
                blurAmount={androidBlurAmount}
                autoUpdate={ANDROID_BLUR_AUTO_UPDATE}
                reducedTransparencyFallbackColor={androidBlurFallback}
                style={[StyleSheet.absoluteFill, styles.lockedFeatureBlur, radiusStyle]}
              />
            ) : (
              <ExpoBlurView
                tint={isDarkMode ? "dark" : "light"}
                intensity={blurIntensityValue}
                experimentalBlurMethod={
                  Platform.OS === "android" && !ANDROID_DIMEZIS_DISABLED
                    ? "dimezisBlurView"
                    : undefined
                }
                style={[StyleSheet.absoluteFill, styles.lockedFeatureBlur, radiusStyle]}
              />
            )
          ) : null}
          <View
            style={[styles.lockedFeatureScrim, styles.lockedFeatureBlur, radiusStyle, { backgroundColor: overlayScrim }]}
          />
          <View style={[styles.lockedFeatureOverlayContent, compactContentStyle, centeredContentStyle]}>
          <View style={[styles.lockedFeatureLockRow, centeredLockRowStyle]}>
            <Text style={[styles.lockedFeatureLockIcon, compactLockStyle, centeredLockStyle, { color: lockIconColor }]}>ðŸ”’</Text>
          </View>
          {premiumStyle ? (
            <View
              style={[
                styles.lockedFeaturePremiumPill,
                { backgroundColor: premiumPillBackground, borderColor: premiumPillBorder },
              ]}
            >
              <Text style={[styles.lockedFeaturePremiumPillText, { color: premiumAccent }]}>PREMIUM</Text>
            </View>
          ) : null}
          <Text
            style={[
              styles.lockedFeatureTitle,
              compactTitleStyle,
              centeredTitleStyle,
              { color: textColor },
            ]}
            numberOfLines={compact ? 2 : undefined}
          >
            {title}
          </Text>
          <Text
            style={[
              styles.lockedFeatureDescription,
              compactDescriptionStyle,
              centeredDescriptionStyle,
              { color: subTextColor },
            ]}
            numberOfLines={compact ? 3 : undefined}
          >
            {description}
          </Text>
          {(premiumStyle ? premiumBadgeText : unlockBadgeText) ? (
            <View
              style={[
                styles.lockedFeatureLevelBadge,
                compactBadgeStyle,
                centeredBadgeStyle,
                { backgroundColor: badgeBg, borderColor: badgeBorder },
              ]}
            >
              <Text style={[styles.lockedFeatureLevelText, compactBadgeTextStyle, { color: badgeTextColor }]}>
                {premiumStyle ? premiumBadgeText : unlockBadgeText}
              </Text>
            </View>
          ) : null}
        </View>
      </View>
    </View>
  );
};

const LockedFeatureCard = ({
  variantKey,
  level,
  colors,
  t,
  style,
  compact = false,
  square = false,
  minHeight = null,
  blurIntensity = 18,
  premiumStyle = false,
}) => {
  const isDarkMode = colors?.background === THEMES.dark.background;
  const premiumAccent = isDarkMode ? "#8CB8FF" : "#4353FF";
  const premiumSurface = colorWithAlpha(premiumAccent, isDarkMode ? 0.2 : 0.12);
  const premiumBorder = colorWithAlpha(premiumAccent, isDarkMode ? 0.56 : 0.32);
  const baseLineColor = premiumStyle
    ? colorWithAlpha(premiumAccent, isDarkMode ? 0.4 : 0.26)
    : colors?.border || "rgba(0,0,0,0.12)";
  const { title, description } = resolveFeatureUnlockCopy(variantKey, t);
  const copyLength = `${title} ${description}`.trim().length;
  const baseMinHeight = compact ? (IS_SHORT_DEVICE ? 150 : 140) : IS_SHORT_DEVICE ? 210 : 200;
  const boostedMinHeight = compact
    ? copyLength > 120
      ? baseMinHeight + 30
      : copyLength > 90
      ? baseMinHeight + 20
      : copyLength > 60
      ? baseMinHeight + 12
      : baseMinHeight
    : copyLength > 120
    ? baseMinHeight + (IS_SHORT_DEVICE ? 50 : 40)
    : copyLength > 90
    ? baseMinHeight + (IS_SHORT_DEVICE ? 35 : 25)
    : copyLength > 60
    ? baseMinHeight + (IS_SHORT_DEVICE ? 20 : 15)
    : baseMinHeight;
  const resolvedMinHeight = square
    ? null
    : Math.max(Number.isFinite(minHeight) ? minHeight : 0, boostedMinHeight);
  const placeholderStyle = compact ? styles.lockedFeaturePlaceholderCompact : styles.lockedFeaturePlaceholder;
  const squareStyle = square ? styles.lockedFeaturePlaceholderSquare : null;
  const sizeStyle = Number.isFinite(resolvedMinHeight) ? { minHeight: resolvedMinHeight } : null;
  return (
    <LockedFeatureOverlay
      locked
      variantKey={variantKey}
      level={level}
      colors={colors}
      t={t}
      style={style}
      blurIntensity={blurIntensity}
      compact={compact}
      premiumStyle={premiumStyle}
    >
      <View
        style={[
          placeholderStyle,
          squareStyle,
          sizeStyle,
          {
            backgroundColor: premiumStyle ? premiumSurface : colors?.card,
            borderColor: premiumStyle ? premiumBorder : colors?.border,
          },
        ]}
      >
        <View style={[styles.lockedFeaturePlaceholderLine, { width: "62%", backgroundColor: baseLineColor }]} />
        <View style={[styles.lockedFeaturePlaceholderLine, { width: "92%", backgroundColor: baseLineColor }]} />
        <View style={[styles.lockedFeaturePlaceholderLine, { width: "76%", backgroundColor: baseLineColor }]} />
      </View>
    </LockedFeatureOverlay>
  );
};

function FreeDayCard({
  colors,
  t,
  canLog,
  onLog,
  freeDayStats = INITIAL_FREE_DAY_STATS,
  todayKey,
  weekDays = [],
  weekCount = 0,
  canRescue = false,
  needsRescue = false,
  rescueStatus = null,
  rescueCost = FREE_DAY_RESCUE_COST,
  onRescue = () => {},
  hasRescueHealth = false,
}) {
  const [expanded, setExpanded] = useState(false);
  const streakActive = (freeDayStats.current || 0) > 0;
  const blockedToday = freeDayStats.blockedDate === todayKey;
  const palette = streakActive
    ? {
        background: "#E6F8EE",
        border: "#A8E5C5",
        accent: "#105B31",
      }
    : {
        background: colors.card,
        border: colors.border,
        accent: colors.text,
      };
  const buttonColor = streakActive ? palette.accent : "#20A36B";
  const statusLabel = canLog
    ? t("freeDayStatusAvailable")
    : freeDayStats.lastDate === todayKey
    ? t("freeDayStatusLogged")
    : blockedToday
    ? t("freeDayBlocked")
    : t("freeDayLocked");
  const stats = [
    { label: t("freeDayCurrentLabel"), value: `${freeDayStats.current || 0}` },
    { label: t("freeDayBestLabel"), value: `${freeDayStats.best || 0}` },
    { label: t("freeDayTotalShort"), value: `${freeDayStats.total || 0}` },
  ];
  const showRescueStatusAction = needsRescue && !canLog;
  const rescuePillDisabled = !hasRescueHealth;
  const rescuePillColor = "#FFD75E";
  const rescuePillTextColor = "#3C2A00";
  return (
    <View
      style={[
        styles.freeDayCard,
        {
          backgroundColor: palette.background,
          borderColor: palette.border,
        },
      ]}
    >
      <View style={styles.freeDayHeader}>
        <View style={styles.freeDayTitleBlock}>
          <Text style={[styles.freeDayLabel, { color: colors.text }]}>{t("freeDayCardTitle")}</Text>
        </View>
        {showRescueStatusAction ? (
          <TouchableOpacity
            style={[
              styles.freeDayStatusPill,
              { backgroundColor: rescuePillColor, borderColor: rescuePillColor },
              rescuePillDisabled && styles.freeDayStatusPillDisabled,
            ]}
            onPress={onRescue}
            disabled={rescuePillDisabled}
            activeOpacity={0.85}
          >
            <Text style={[styles.freeDayStatusText, { color: rescuePillTextColor }]}>
              {t("freeDayRescuePillLabel", { count: "1" })}
            </Text>
            {BLUE_HEALTH_COIN_ASSET ? (
              <Image source={BLUE_HEALTH_COIN_ASSET} style={styles.freeDayStatusCoin} />
            ) : null}
          </TouchableOpacity>
        ) : canLog ? (
          <TouchableOpacity
            style={[
              styles.freeDayStatusPill,
              { backgroundColor: buttonColor, borderColor: buttonColor },
            ]}
            onPress={onLog}
            activeOpacity={0.85}
          >
            <Text style={[styles.freeDayStatusText, { color: "#fff" }]}>{statusLabel}</Text>
          </TouchableOpacity>
        ) : (
          <View
            style={[
              styles.freeDayStatusPill,
              {
                borderColor: colors.border,
                backgroundColor: colors.background,
              },
            ]}
          >
            <Text style={[styles.freeDayStatusText, { color: colors.muted }]}>{statusLabel}</Text>
          </View>
        )}
      </View>
      <View style={styles.freeDaySummaryRow}>
        <View style={styles.freeDayChip}>
          <Text style={[styles.freeDayChipText, { color: palette.accent }]}>
            {t("freeDayWeekTitle")} Â· {weekCount}/7
          </Text>
        </View>
        <TouchableOpacity
          style={styles.freeDayToggle}
          onPress={() => {
            runLayoutAnimation();
            setExpanded((prev) => !prev);
          }}
        >
          <Text style={[styles.freeDayToggleText, { color: colors.muted }]}>
            {expanded ? t("freeDayCollapse") : t("freeDayExpand")}
          </Text>
        </TouchableOpacity>
      </View>
      {needsRescue && (
        <View
          style={[
            styles.freeDayRescueBanner,
            { borderColor: colors.border, backgroundColor: colors.background },
          ]}
        >
          <View style={{ flex: 1 }}>
            <Text style={[styles.freeDayRescueTitle, { color: colors.text }]}>
              {t("freeDayRescueTitle")}
            </Text>
            <Text style={[styles.freeDayRescueSubtitle, { color: colors.muted }]}>
              {canRescue
                ? t("freeDayRescueSubtitle", { cost: rescueCost })
                : rescueStatus || t("freeDayRescueSubtitle", { cost: rescueCost })}
            </Text>
          </View>
          <TouchableOpacity
            style={[
              styles.freeDayRescueButton,
              { backgroundColor: palette.accent },
              !canRescue && styles.freeDayRescueButtonDisabled,
            ]}
            onPress={onRescue}
            disabled={!canRescue}
          >
            <Text
              style={[
                styles.freeDayRescueButtonText,
                !canRescue && { color: palette.accent, opacity: 0.6 },
              ]}
            >
              {t("freeDayRescueButton")}
            </Text>
          </TouchableOpacity>
        </View>
      )}
      {expanded && (
        <>
          <View style={styles.freeDayStatsRow}>
            {stats.map((stat) => (
              <View key={stat.label} style={styles.freeDayStat}>
                <Text style={[styles.freeDayStatLabel, { color: colors.muted }]}>{stat.label}</Text>
                <Text style={[styles.freeDayStatValue, { color: palette.accent }]}>
                  {stat.value}
                </Text>
              </View>
            ))}
          </View>
          <View
            style={[
              styles.freeDayCalendar,
              { backgroundColor: streakActive ? "rgba(255,255,255,0.4)" : colors.card },
            ]}
          >
            <View style={styles.freeDayCalendarHeader}>
              <Text style={[styles.freeDayCalendarTitle, { color: colors.muted }]}>
                {t("freeDayWeekTitle")}
              </Text>
              <Text style={[styles.freeDayCalendarTitle, { color: colors.muted }]}>
                {weekCount}/7
              </Text>
            </View>
            <View style={styles.freeDayCalendarDays}>
              {weekDays.map((day) => (
                <View key={day.key} style={styles.freeDayCalendarDay}>
                  <Text style={[styles.freeDayCalendarLabel, { color: colors.muted }]}>
                    {day.label}
                  </Text>
                  <View
                    style={[
                      styles.freeDayCalendarDot,
                      day.active && styles.freeDayCalendarDotActive,
                      day.isToday && styles.freeDayCalendarDotToday,
                    ]}
                  />
                </View>
              ))}
            </View>
          </View>
        </>
      )}
    </View>
  );
}

function SpendConfirmSheet({
  visible,
  item,
  amountUSD = null,
  currency = DEFAULT_PROFILE.currency,
  language = DEFAULT_LANGUAGE,
  onCancel,
  onConfirm,
  colors,
  t,
  theme,
}) {
  const hasOverrideAmount = Number.isFinite(Number(amountUSD)) && Number(amountUSD) > 0;
  const priceLabel = hasOverrideAmount
    ? formatCurrency(convertToCurrency(Number(amountUSD), currency), currency)
    : item
    ? formatTemptationPriceLabel(item, currency)
    : formatCurrency(0, currency, { friendly: true });
  const displayTitle =
    item?.title?.[language] || item?.title?.en || item?.title || t("defaultDealTitle");
  const cancelColor = theme === "dark" ? "#64F2B5" : theme === PRO_THEME_ID ? colors.primary : "#1BA868";
  return (
    <Modal visible={visible} transparent animationType="fade" statusBarTranslucent>
      <View style={styles.payBackdrop}>
        <TouchableWithoutFeedback onPress={onCancel}>
          <View style={styles.payBackdropHit} />
        </TouchableWithoutFeedback>
        <View style={[styles.paySheet, { backgroundColor: colors.card }] }>
          <View style={styles.paySheetHandle} />
          <Text style={[styles.payBrand, { color: colors.text }]}>{t("spendSheetTitle")}</Text>
          <View style={[styles.payCard, { backgroundColor: colors.background }]}>
            <View style={styles.payCardIcon}>
              <Text style={styles.payCardEmoji}>{item?.emoji || "ðŸ’³"}</Text>
            </View>
            <View style={styles.payCardTexts}>
              <Text style={[styles.payCardTitle, { color: colors.text }]}>{displayTitle}</Text>
            </View>
            <Text style={[styles.payCardAmount, { color: colors.text }]}>{priceLabel}</Text>
          </View>
          <View style={styles.paySheetReminder}>
            <Text
              style={[styles.paySheetSubtitle, { color: colors.muted }]}
              numberOfLines={1}
              adjustsFontSizeToFit
              minimumFontScale={0.85}
              ellipsizeMode="tail"
            >
              {t("spendSheetSubtitle")}
            </Text>
          </View>
          <TouchableOpacity style={[styles.payConfirm, { backgroundColor: colors.text }]} onPress={onConfirm}>
            <Text style={[styles.payConfirmText, { color: colors.background }]}>
              {t("spendSheetConfirm")}
            </Text>
          </TouchableOpacity>
          <TouchableOpacity style={styles.payCancel} onPress={onCancel}>
            <Text style={[styles.payCancelText, { color: cancelColor }]}>
              {t("spendSheetCancel")}
            </Text>
          </TouchableOpacity>
        </View>
      </View>
    </Modal>
  );
}

const LightningBolt = ({ active, delay = 0, style }) => {
  const opacity = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    if (!active) {
      opacity.setValue(0);
      return;
    }
    const loop = Animated.loop(
      Animated.sequence([
        Animated.delay(delay),
        Animated.timing(opacity, { toValue: 1, duration: 120, useNativeDriver: true }),
        Animated.timing(opacity, { toValue: 0, duration: 280, useNativeDriver: true }),
        Animated.delay(900 + Math.random() * 500),
      ])
    );
    loop.start();
    return () => loop.stop();
  }, [active, delay, opacity]);

  return (
    <Animated.View pointerEvents="none" style={[styles.stormLightningBolt, style, { opacity }]}>
      <Svg width={60} height={140} viewBox="0 0 60 140">
        <SvgPath d="M24 0 L0 80 H18 L8 140 L60 55 H38 L48 0 Z" fill="rgba(255,255,255,0.95)" />
      </Svg>
    </Animated.View>
  );
};

function StormOverlay({ visible, t, catCrySource, colors, onDismiss }) {
  const flash = useRef(new Animated.Value(0)).current;
  const catBounce = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    if (!visible) {
      flash.setValue(0);
      return;
    }
    const loop = Animated.loop(
      Animated.sequence([
        Animated.delay(500),
        Animated.timing(flash, { toValue: 0.85, duration: 110, useNativeDriver: true }),
        Animated.timing(flash, { toValue: 0, duration: 360, useNativeDriver: true }),
        Animated.delay(700),
      ])
    );
    loop.start();
    return () => loop.stop();
  }, [flash, visible]);

  useEffect(() => {
    if (!visible) {
      catBounce.setValue(0);
      return;
    }
    const loop = Animated.loop(
      Animated.sequence([
        Animated.timing(catBounce, {
          toValue: 1,
          duration: 900,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(catBounce, {
          toValue: 0,
          duration: 900,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    loop.start();
    return () => loop.stop();
  }, [catBounce, visible]);

  if (!visible) return null;

  const handleDismiss = () => {
    if (typeof onDismiss === "function") {
      onDismiss();
    }
  };

  const rainColors =
    colors?.muted != null
      ? { muted: colorWithAlpha(colors.muted, 0.5) }
      : { muted: "rgba(173,196,255,0.5)" };
  const cardBackground = colorWithAlpha(colors?.card || "#0A0F23", 0.96);
  const borderColor = colorWithAlpha(colors?.text || "#FFFFFF", 0.18);
  const messageColor = colors?.text || "#F5F6FF";
  const comfortColor = colors?.muted || "rgba(245,246,255,0.75)";
  const catSource = catCrySource || CLASSIC_TAMAGOTCHI_ANIMATIONS.cry;
  const bobbing = catBounce.interpolate({
    inputRange: [0, 1],
    outputRange: [0, -10],
  });

  return (
    <Modal visible transparent animationType="fade" statusBarTranslucent>
      <TouchableWithoutFeedback onPress={handleDismiss}>
        <View style={styles.stormOverlay} pointerEvents="auto">
          <RainOverlay colors={rainColors} />
          <Animated.View style={[styles.stormFlash, { opacity: flash }]} />
          <LightningBolt
            active={visible}
            delay={150}
            style={{ left: 30, top: 80, transform: [{ rotate: "-10deg" }] }}
          />
          <LightningBolt
            active={visible}
            delay={640}
            style={{ right: 40, top: 130, transform: [{ rotate: "12deg" }] }}
          />
          <View style={[styles.stormMessageWrap, { backgroundColor: cardBackground, borderColor }]}>
            <Animated.View style={[styles.stormCatWrap, { transform: [{ translateY: bobbing }] }]}>
              <Image source={catSource} style={styles.stormCatImage} resizeMode="contain" />
            </Animated.View>
            <Text style={[styles.stormMessage, { color: messageColor }]}>{t("stormOverlayMessage")}</Text>
            <Text style={[styles.stormComfortText, { color: comfortColor }]}>
              {t("stormOverlayComfortMessage")}
            </Text>
          </View>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
}

function SaveSpamDisclaimerModal({
  visible,
  t,
  colors,
  catCuriousSource,
  onConfirm,
  onCancel,
}) {
  const catFloat = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    if (!visible) {
      catFloat.setValue(0);
      return;
    }
    const loop = Animated.loop(
      Animated.sequence([
        Animated.timing(catFloat, {
          toValue: 1,
          duration: 900,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(catFloat, {
          toValue: 0,
          duration: 900,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    loop.start();
    return () => loop.stop();
  }, [catFloat, visible]);

  if (!visible) return null;

  const cardBackground = colorWithAlpha(colors?.card || "#FFFFFF", 0.97);
  const borderColor = colorWithAlpha(SPEND_ACTION_COLOR, 0.3);
  const titleColor = colors?.text || "#111";
  const bodyColor = colors?.muted || "#445";
  const curiousSource = catCuriousSource || CLASSIC_TAMAGOTCHI_ANIMATIONS.curious;
  const floatY = catFloat.interpolate({
    inputRange: [0, 1],
    outputRange: [0, -8],
  });

  return (
    <Modal visible transparent animationType="fade" statusBarTranslucent onRequestClose={onCancel}>
      <TouchableWithoutFeedback onPress={onCancel}>
        <View style={styles.saveSpamOverlay}>
          <TouchableWithoutFeedback onPress={() => {}}>
            <View style={[styles.saveSpamCard, { backgroundColor: cardBackground, borderColor }]}>
              <Animated.View style={[styles.saveSpamCatWrap, { transform: [{ translateY: floatY }] }]}>
                <Image source={curiousSource} style={styles.saveSpamCatImage} resizeMode="contain" />
              </Animated.View>
              <Text style={[styles.saveSpamTitle, { color: titleColor }]}>{t("saveSpamModalTitle")}</Text>
              <Text style={[styles.saveSpamBody, { color: bodyColor }]}>{t("saveSpamModalBody")}</Text>
              <Text style={[styles.saveSpamHint, { color: bodyColor }]}>{t("saveSpamModalHint")}</Text>
              <View style={styles.saveSpamActions}>
                <TouchableOpacity
                  style={[styles.saveSpamButton, styles.saveSpamButtonCancel]}
                  onPress={onCancel}
                  activeOpacity={0.9}
                >
                  <Text style={styles.saveSpamButtonCancelText}>{t("saveSpamModalDecline")}</Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.saveSpamButton, styles.saveSpamButtonConfirm]}
                  onPress={onConfirm}
                  activeOpacity={0.9}
                >
                  <Text style={styles.saveSpamButtonConfirmText}>{t("saveSpamModalConfirm")}</Text>
                </TouchableOpacity>
              </View>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
}

const hasImpulseHistory = (insights) => {
  if (!insights?.categories) return false;
  if ((insights.eventCount || 0) < MIN_IMPULSE_EVENTS_FOR_MAP) return false;
  return IMPULSE_CATEGORY_ORDER.some((id) => {
    const entry = insights.categories[id];
    return (entry?.save || 0) + (entry?.spend || 0) > 0;
  });
};

function ImpulseMapCard({ insights, colors, t, language, expanded = false, onToggle }) {
  if (!insights) return null;
  const fallbackTime = t("impulseAnytimeLabel");
  const cleanTitle = (value) => {
    const stripped = stripEmojis(value || "");
    return stripped || value || "";
  };
  const formatInsightLine = (title, timeLabel) =>
    t("impulseInsightLine", {
      temptation: cleanTitle(title),
      time: timeLabel || fallbackTime,
    });
  const loseText = insights.hotLose
    ? formatInsightLine(insights.hotLose.title, insights.hotLose.windowLabel || fallbackTime)
    : t("impulseLoseEmptyShort");
  const winText = insights.hotWin
    ? formatInsightLine(insights.hotWin.title, insights.hotWin.windowLabel || fallbackTime)
    : t("impulseWinEmptyShort");
  const trendText =
    insights.hottestSpendCategory && insights.hottestSpendCategory.spendCount > 0
      ? t("impulseTrendShort", {
          category: getImpulseCategoryLabel(insights.hottestSpendCategory.id, language),
        })
      : null;
  const isDarkMode = colors.background === THEMES.dark.background;
  const cardBackground = isDarkMode ? lightenColor(colors.card, 0.12) : colors.card;
  const cardBorder = isDarkMode ? lightenColor(colors.border, 0.3) : colors.border;
  const dangerBg = isDarkMode ? "rgba(255,108,108,0.2)" : "#FFE6E6";
  const dangerBorder = isDarkMode ? "rgba(255,108,108,0.42)" : "rgba(255,108,108,0.35)";
  const successBg = isDarkMode ? "rgba(33,209,160,0.2)" : "#E6FBF2";
  const successBorder = isDarkMode ? "rgba(33,209,160,0.4)" : "rgba(33,209,160,0.32)";
  const neutralBg = isDarkMode ? "rgba(250,204,21,0.18)" : "#FFF5D9";
  const neutralBorder = isDarkMode ? "rgba(250,204,21,0.35)" : "rgba(250,204,21,0.3)";
  const toggleLabel = expanded ? t("impulseCollapse") : t("impulseExpand");
  const categories = IMPULSE_CATEGORY_ORDER.map((id, index) => {
    const entry = insights.categories?.[id] || { save: 0, spend: 0 };
    const save = entry.save || 0;
    const spend = entry.spend || 0;
    return {
      id,
      orderIndex: index,
      label: getImpulseCategoryLabel(id, language),
      save,
      spend,
      total: save + spend,
    };
  });
  const rankedCategories = [...categories].sort((a, b) => {
    if (b.total !== a.total) return b.total - a.total;
    return a.orderIndex - b.orderIndex;
  });
  const topRanked = rankedCategories.filter((entry) => entry.total > 0);
  const categoryLimit = IS_SHORT_DEVICE ? 2 : 4;
  const visibleCategories = expanded ? topRanked.slice(0, categoryLimit) : [];
  const sequenceEntries = [];
  const sequenceInsights = Array.isArray(insights.sequenceInsights) ? insights.sequenceInsights : [];
  const resolveBefore = (action) =>
    action === "save" ? t("impulseActionSaveBefore") : t("impulseActionSpendBefore");
  const resolveAfter = (action) =>
    action === "save" ? t("impulseActionSaveAfter") : t("impulseActionSpendAfter");
  if (sequenceInsights.length) {
    sequenceInsights.forEach((entry, index) => {
      sequenceEntries.push({
        key: entry.key || `sequence-${index}`,
        text: t("impulseSequenceInsight", {
          before: resolveBefore(entry.fromAction),
          after: resolveAfter(entry.toAction),
          from: entry.fromTitle || "",
          to: entry.toTitle || "",
          time: entry.windowLabel || fallbackTime,
        }),
      });
    });
  } else {
    const sequenceData = insights.sequenceHotspots || {};
    if (sequenceData.slip) {
      sequenceEntries.push({
        key: "slip",
        text: t("impulseSequenceInsight", {
          before: resolveBefore(sequenceData.slip.fromAction || "spend"),
          after: resolveAfter(sequenceData.slip.toAction || "spend"),
          from: sequenceData.slip.fromTitle || "",
          to: sequenceData.slip.toTitle || "",
          time: sequenceData.slip.windowLabel || fallbackTime,
        }),
      });
    }
    if (sequenceData.rebound) {
      sequenceEntries.push({
        key: "rebound",
        text: t("impulseSequenceInsight", {
          before: resolveBefore(sequenceData.rebound.fromAction || "save"),
          after: resolveAfter(sequenceData.rebound.toAction || "save"),
          from: sequenceData.rebound.fromTitle || "",
          to: sequenceData.rebound.toTitle || "",
          time: sequenceData.rebound.windowLabel || fallbackTime,
        }),
      });
    }
  }
  const sequencePreview = IS_SHORT_DEVICE ? sequenceEntries.slice(0, 2) : sequenceEntries;
  return (
    <View style={[styles.impulseCard, { backgroundColor: cardBackground, borderColor: cardBorder }]}>
      <View
        pointerEvents="none"
        style={[styles.impulseCardGlow, { backgroundColor: isDarkMode ? "#4A3A6E" : "#FFD8A9" }]}
      />
      <View style={styles.impulseHeaderRow}>
        <View style={styles.impulseHeader}>
          <Text style={[styles.impulseCardTitle, { color: colors.text }]}>{t("impulseCardTitle")}</Text>
          <Text style={[styles.impulseCardSubtitle, { color: colors.muted }]}>
            {t("impulseCardSubtitle")}
          </Text>
        </View>
        <TouchableOpacity
          onPress={onToggle}
          style={[
            styles.impulseToggle,
            { borderColor: cardBorder, backgroundColor: lightenColor(cardBackground, isDarkMode ? 0.08 : 0.2) },
          ]}
        >
          <Text style={[styles.impulseToggleText, { color: colors.text }]}>{toggleLabel}</Text>
        </TouchableOpacity>
      </View>
      <View style={styles.impulseSummaryGrid}>
        <View
          style={[
            styles.impulseBadge,
            { backgroundColor: dangerBg, borderColor: dangerBorder },
          ]}
        >
          <Text style={[styles.impulseSummaryLabel, { color: colors.text }]}>{t("impulseLoseLabel")}</Text>
          <Text style={[styles.impulseSummaryValue, { color: colors.text }]}>{loseText}</Text>
        </View>
        <View
          style={[
            styles.impulseBadge,
            { backgroundColor: successBg, borderColor: successBorder },
          ]}
        >
          <Text style={[styles.impulseSummaryLabel, { color: colors.text }]}>{t("impulseWinLabel")}</Text>
          <Text style={[styles.impulseSummaryValue, { color: colors.text }]}>{winText}</Text>
        </View>
      </View>
      {expanded && (
        <>
          {trendText ? (
            <View
              style={[
                styles.impulseTrendRow,
                { backgroundColor: neutralBg, borderColor: neutralBorder },
              ]}
            >
              <Text style={[styles.impulseTrendText, { color: colors.text }]}>{trendText}</Text>
            </View>
          ) : null}
          {visibleCategories.length ? (
            <View style={styles.impulseCategoryList}>
              {visibleCategories.map((category) => {
                const hasData = (category.save || 0) + (category.spend || 0) > 0;
                const isRisk = hasData && category.spend > category.save;
                const isWin = hasData && category.save > category.spend;
                let categoryBg = colors.card;
                let categoryBorder = colors.border;
                if (isRisk) {
                  categoryBg = dangerBg;
                  categoryBorder = dangerBorder;
                } else if (isWin) {
                  categoryBg = successBg;
                  categoryBorder = successBorder;
                }
                return (
                  <View
                    key={category.id}
                    style={[
                      styles.impulseCategoryRow,
                      {
                        borderColor: categoryBorder,
                        backgroundColor: categoryBg,
                      },
                    ]}
                  >
                  <Text style={[styles.impulseCategoryLabel, { color: colors.text }]}>
                    {category.label}
                  </Text>
                  <View style={styles.impulseCategoryStats}>
                    <Text style={[styles.impulseCategoryStat, { color: SAVE_ACTION_COLOR }]}>
                      {`â–² ${category.save}`}
                    </Text>
                    <Text style={[styles.impulseCategoryStat, { color: SPEND_ACTION_COLOR }]}>
                      {`â–¼ ${category.spend}`}
                    </Text>
                  </View>
                </View>
              );
            })}
          </View>
          ) : null}
          <View
            style={[
              styles.impulseSequenceSection,
              { borderColor: colors.border, backgroundColor: lightenColor(cardBackground, isDarkMode ? 0.08 : 0.16) },
            ]}
          >
            <Text style={[styles.impulseSequenceTitle, { color: colors.text }]}>{t("impulseSequenceTitle")}</Text>
            {sequencePreview.length ? (
              sequencePreview.map((entry) => (
                <Text key={entry.key} style={[styles.impulseSequenceEntry, { color: colors.muted }]}>
                  {entry.text}
                </Text>
              ))
            ) : (
              <Text style={[styles.impulseSequenceEntry, { color: colors.muted }]}>
                {t("impulseSequenceEmptyShort")}
              </Text>
            )}
          </View>
        </>
      )}
    </View>
  );
}

const HistoryModal = React.memo(function HistoryModal({
  visible = false,
  history = [],
  onClose = () => {},
  onHistoryDelete = () => {},
  t,
  colors,
  currency,
  language,
}) {
  const historyEntries = Array.isArray(history) ? history : [];
  const locale = getFormatLocale(language);
  const formatLocalAmount = useCallback(
    (valueUSD = 0) => formatCurrency(convertToCurrency(valueUSD || 0, currency), currency),
    [currency]
  );
  const describeHistory = useCallback(
    (entry) => describeHistoryEntry(entry, { t, formatLocalAmount }),
    [formatLocalAmount, t]
  );
  const formatHistoryMeta = useCallback(
    (entry) => formatHistoryEntryMeta(entry, { t, locale }),
    [locale, t]
  );
  const historyLastIndex = historyEntries.length - 1;
  const renderHistoryItem = useCallback(
    ({ item: entry, index }) => (
      <View
        style={[
          styles.historyItem,
          {
            borderColor: colors.border,
            borderBottomWidth:
              index === historyLastIndex ? 0 : StyleSheet.hairlineWidth,
          },
        ]}
      >
        <View style={styles.historyRow}>
          <View style={{ flex: 1 }}>
            <Text style={[styles.historyItemTitle, { color: colors.text }]}>
              {describeHistory(entry)}
            </Text>
            <Text style={[styles.historyItemMeta, { color: colors.muted }]}>
              {formatHistoryMeta(entry)}
            </Text>
          </View>
          <TouchableOpacity
            style={[styles.historyDeleteBtn, { borderColor: colors.border }]}
            onPress={() => onHistoryDelete?.(entry)}
          >
            <Text style={[styles.historyDeleteText, { color: colors.muted }]}>âœ•</Text>
          </TouchableOpacity>
        </View>
      </View>
    ),
    [
      colors.border,
      colors.muted,
      colors.text,
      describeHistory,
      formatHistoryMeta,
      historyLastIndex,
      onHistoryDelete,
    ]
  );
  const historyItemLayout = useCallback(
    (_, index) => ({
      length: HISTORY_ITEM_HEIGHT,
      offset: HISTORY_ITEM_HEIGHT * index,
      index,
    }),
    []
  );
  const [modalHeight, setModalHeight] = useState(0);
  const modalOpacity = useMemo(() => {
    const screenHeight = Dimensions.get("window").height || 1;
    const ratio = Math.max(0, Math.min((modalHeight || 0) / screenHeight, 1));
    return Math.min(0.5, Math.max(0.22, 0.18 + ratio * 0.45));
  }, [modalHeight]);
  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      statusBarTranslucent
      onRequestClose={onClose}
    >
      <View style={styles.progressCategoryModalRoot}>
        <TouchableWithoutFeedback onPress={onClose}>
          <View
            style={[
              styles.progressCategoryBackdrop,
              { backgroundColor: `rgba(0,0,0,${modalOpacity})` },
            ]}
          />
        </TouchableWithoutFeedback>
        <View style={styles.progressCategoryModalWrap} pointerEvents="box-none">
          <View
            style={[
              styles.progressCategoryModalCard,
              { backgroundColor: colors.card, borderColor: colors.border },
            ]}
            onLayout={(event) => {
              const nextHeight = event?.nativeEvent?.layout?.height || 0;
              if (nextHeight && nextHeight !== modalHeight) {
                setModalHeight(nextHeight);
              }
            }}
          >
            <View style={styles.progressCategoryModalHeader}>
              <Text style={[styles.progressCategoryModalTitle, { color: colors.text }]}>
                {t("historyTitle")}
              </Text>
              <TouchableOpacity onPress={onClose} style={styles.progressCategoryModalClose}>
                <Text style={[styles.progressCategoryModalCloseText, { color: colors.muted }]}>âœ•</Text>
              </TouchableOpacity>
            </View>
            {historyEntries.length === 0 ? (
              <Text style={[styles.historyEmpty, { color: colors.muted }]}>
                {t("historyEmpty")}
              </Text>
            ) : (
              <FlatList
                style={[styles.progressCategoryModalList, { borderColor: colors.border }]}
                contentContainerStyle={styles.historyListContent}
                showsVerticalScrollIndicator
                data={historyEntries}
                keyExtractor={(entry) => entry.id}
                renderItem={renderHistoryItem}
                getItemLayout={historyItemLayout}
                initialNumToRender={12}
                maxToRenderPerBatch={12}
                windowSize={5}
              />
            )}
          </View>
        </View>
      </View>
    </Modal>
  );
});

const ReportsModal = React.memo(function ReportsModal({
  visible = false,
  reports,
  activeTab = "weekly",
  onTabChange = () => {},
  onClose = () => {},
  t,
  colors,
  currency,
  language,
}) {
  const locale = getFormatLocale(language);
  const normalizedReports = useMemo(
    () => normalizeProfileReports(reports),
    [reports]
  );
  const weeklyReports = normalizedReports.weekly || [];
  const monthlyReports = normalizedReports.monthly || [];
  const resolvedTab = activeTab === "monthly" ? "monthly" : "weekly";
  const activeReports = resolvedTab === "monthly" ? monthlyReports : weeklyReports;
  const updatedAtLabel = useMemo(() => {
    if (!normalizedReports.updatedAt) return null;
    const date = new Date(normalizedReports.updatedAt);
    if (!Number.isFinite(date.getTime())) return null;
    const dateLabel = date.toLocaleDateString(locale, {
      day: "numeric",
      month: "short",
      year: "numeric",
    });
    const timeLabel = date.toLocaleTimeString(locale, { hour: "2-digit", minute: "2-digit" });
    return t("reportsUpdatedAt", { date: dateLabel, time: timeLabel });
  }, [locale, normalizedReports.updatedAt, t]);
  const formatLocalAmount = useCallback(
    (valueUSD = 0) => formatCurrency(convertToCurrency(valueUSD || 0, currency), currency),
    [currency]
  );
  const formatDayLabel = useCallback(
    (dayKey) => {
      if (!dayKey) return "";
      const ts = parseDayKey(dayKey)?.getTime();
      if (!Number.isFinite(ts)) return dayKey;
      return (
        formatRelativeDayLabel(ts, Date.now(), language) ||
        new Date(ts).toLocaleDateString(locale, { day: "numeric", month: "short" })
      );
    },
    [language, locale]
  );
  const buildInsights = useCallback(
    (report) => {
      if (!report?.totals) return [];
      const totals = report.totals || {};
      const metrics = report.metrics || {};
      const savedUSD = Math.max(0, Number(totals.savedUSD) || 0);
      const spendUSD = Math.max(0, Number(totals.spendUSD) || 0);
      const savedCount = Math.max(0, Number(totals.savedCount) || 0);
      const spendCount = Math.max(0, Number(totals.spendCount) || 0);
      const totalActions = savedCount + spendCount;
      const deltaUSD = savedUSD - spendUSD;
      const threshold = Math.max(1, Math.min(savedUSD, spendUSD) * 0.05);
      const reportType = report.type === "month" ? "month" : "week";
      const dayCount = Math.max(1, Number(totals.dayCount) || 0);
      const activeDays = Math.max(0, Number(metrics.activeDays) || 0);
      const saveShare = Math.max(0, Number(metrics.saveShare) || 0);
      const sharePercent = Math.round(saveShare * 100);
      const shareTarget = getReportsShareTarget({
        percent: sharePercent,
        type: reportType,
        activeDays,
        dayCount,
        totalActions,
      });
      const targetDays = getReportsActiveDaysTarget({ type: reportType, dayCount });
      const minActions = getReportsMinActions(reportType);
      const hasData = savedUSD > 0 || spendUSD > 0;
      const hasEnoughData = totalActions >= minActions;
      const insights = [];
      const pushInsight = (id, text, priority = 1) => {
        if (!text) return;
        if (insights.some((entry) => entry.id === id)) return;
        insights.push({ id, text, priority });
      };
      if (!hasData) {
        pushInsight("empty", t("reportsInsightEmpty"), 3.5);
      } else if (!hasEnoughData) {
        pushInsight(
          "low_data",
          t("reportsInsightLowData", { count: totalActions, target: minActions }),
          3.4
        );
      } else if (savedUSD === 0 && spendUSD > 0) {
        pushInsight("no_save", t("reportsInsightNoSave", { amount: formatLocalAmount(spendUSD) }), 3.4);
      } else if (spendUSD === 0 && savedUSD > 0) {
        pushInsight("no_spend", t("reportsInsightNoSpend", { amount: formatLocalAmount(savedUSD) }), 3.4);
      } else if (Math.abs(deltaUSD) <= threshold) {
        pushInsight("even", t("reportsInsightEvenAdvice"), 3.3);
      } else if (deltaUSD > 0) {
        if (report.topSpend?.displayTitle) {
          pushInsight(
            "win_top_spend",
            t("reportsInsightWinAdviceWithSpend", {
              amount: formatLocalAmount(deltaUSD),
              title: report.topSpend.displayTitle,
            }),
            3.3
          );
        } else {
          pushInsight(
            "win",
            t("reportsInsightWinAdvice", { amount: formatLocalAmount(deltaUSD) }),
            3.3
          );
        }
      } else {
        if (report.topSpend?.displayTitle) {
          pushInsight(
            "loss_top_spend",
            t("reportsInsightLossAdviceWithSpend", {
              amount: formatLocalAmount(Math.abs(deltaUSD)),
              title: report.topSpend.displayTitle,
            }),
            3.3
          );
        } else {
          pushInsight(
            "loss",
            t("reportsInsightLossAdvice", { amount: formatLocalAmount(Math.abs(deltaUSD)) }),
            3.3
          );
        }
      }
      const topSpendShare =
        spendUSD > 0 && report.topSpend?.amountUSD ? report.topSpend.amountUSD / spendUSD : 0;
      const dominantShareThreshold = reportType === "month" ? 0.4 : 0.45;
      if (report.topSpend?.displayTitle && topSpendShare >= dominantShareThreshold) {
        pushInsight(
          "dominant_spend",
          t("reportsInsightDominantSpend", {
            title: report.topSpend.displayTitle,
            percent: Math.round(topSpendShare * 100),
          }),
          2.7
        );
      }
      if (shareTarget) {
        pushInsight("share", t("reportsInsightShare", { percent: sharePercent, target: shareTarget }), 2.4);
      }
      if (activeDays && dayCount && activeDays < targetDays) {
        pushInsight(
          "active_days",
          t("reportsInsightActiveDays", { active: activeDays, total: dayCount, target: targetDays }),
          2.3
        );
      }
      if ((metrics.weekendSpendShare || 0) >= 0.6 && spendUSD > 0) {
        const percent = Math.round(metrics.weekendSpendShare * 100);
        pushInsight("weekend_spend", t("reportsInsightWeekendSpend", { percent }), 2.2);
      }
      if (report.peakSpendDay?.dayKey && (report.peakSpendDay.spendUSD || 0) > 0) {
        pushInsight(
          "peak_spend_day",
          t("reportsInsightPeakSpendDay", {
            day: formatDayLabel(report.peakSpendDay.dayKey),
            amount: formatLocalAmount(report.peakSpendDay.spendUSD || 0),
          }),
          1.8
        );
      }
      if (report.peakSaveDay?.dayKey && (report.peakSaveDay.saveUSD || 0) > 0) {
        pushInsight(
          "peak_save_day",
          t("reportsInsightPeakSaveDay", {
            day: formatDayLabel(report.peakSaveDay.dayKey),
            amount: formatLocalAmount(report.peakSaveDay.saveUSD || 0),
          }),
          1.7
        );
      }
      if ((metrics.avgSpendPerAction || 0) > 0 && (metrics.avgSavePerAction || 0) > 0) {
        const ratio = metrics.avgSpendPerAction / Math.max(metrics.avgSavePerAction || 1, 1);
        if (ratio >= 1.25) {
          pushInsight(
            "avg_ticket",
            t("reportsInsightAvgTicket", {
              spendAvg: formatLocalAmount(metrics.avgSpendPerAction || 0),
              saveAvg: formatLocalAmount(metrics.avgSavePerAction || 0),
            }),
            1.9
          );
        }
      }
      if (report.topSave?.displayTitle) {
        pushInsight(
          "top_save",
          t("reportsInsightTopSaveAdvice", { title: report.topSave.displayTitle }),
          1.6
        );
      }
      if (report.topSpend?.displayTitle) {
        pushInsight(
          "top_spend",
          t("reportsInsightTopSpendAdvice", { title: report.topSpend.displayTitle }),
          1.5
        );
      }
      const sorted = insights.sort((a, b) => b.priority - a.priority);
      return sorted.slice(0, REPORTS_MAX_INSIGHTS).map((entry) => entry.text);
    },
    [formatDayLabel, formatLocalAmount, t]
  );
  const buildNextSteps = useCallback(
    (report) => {
      if (!report?.totals) return [t("reportsNextStepStart")];
      const totals = report.totals || {};
      const metrics = report.metrics || {};
      const savedUSD = Math.max(0, Number(totals.savedUSD) || 0);
      const spendUSD = Math.max(0, Number(totals.spendUSD) || 0);
      const savedCount = Math.max(0, Number(totals.savedCount) || 0);
      const spendCount = Math.max(0, Number(totals.spendCount) || 0);
      const totalActions = savedCount + spendCount;
      const reportType = report.type === "month" ? "month" : "week";
      const dayCount = Math.max(1, Number(totals.dayCount) || 0);
      const activeDays = Math.max(0, Number(metrics.activeDays) || 0);
      const sharePercent = Math.round(Math.max(0, Number(metrics.saveShare) || 0) * 100);
      const shareTarget = getReportsShareTarget({
        percent: sharePercent,
        type: reportType,
        activeDays,
        dayCount,
        totalActions,
      });
      const targetDays = getReportsActiveDaysTarget({ type: reportType, dayCount });
      const minActions = getReportsMinActions(reportType);
      const steps = [];
      const pushStep = (id, text, priority = 1) => {
        if (!text) return;
        if (steps.some((entry) => entry.id === id)) return;
        steps.push({ id, text, priority });
      };
      const hasData = savedUSD > 0 || spendUSD > 0;
      if (!hasData) {
        return [t("reportsNextStepStart")];
      }
      if (totalActions < minActions) {
        pushStep("start", t("reportsNextStepStart"), 3.3);
      }
      const topSpendTitle = report.topSpend?.displayTitle;
      const topSpendShare =
        spendUSD > 0 && report.topSpend?.amountUSD ? report.topSpend.amountUSD / spendUSD : 0;
      const dominantShareThreshold = reportType === "month" ? 0.4 : 0.45;
      if (topSpendTitle) {
        if (topSpendShare >= dominantShareThreshold) {
          pushStep("cap_category", t("reportsNextStepCap", { title: topSpendTitle }), 3.1);
        } else if (spendUSD >= savedUSD) {
          pushStep("cut_category", t("reportsNextStepCut", { title: topSpendTitle }), 2.9);
        } else {
          pushStep("cut_category", t("reportsNextStepCut", { title: topSpendTitle }), 2.3);
        }
      }
      if ((metrics.weekendSpendShare || 0) >= 0.6 && spendUSD > 0) {
        pushStep("weekend_cap", t("reportsNextStepWeekendCap"), 2.8);
      }
      if (activeDays && dayCount && activeDays < targetDays) {
        pushStep("active_days", t("reportsNextStepActiveDays", { target: targetDays }), 2.7);
      }
      if (shareTarget) {
        pushStep("share_target", t("reportsNextStepShare", { target: shareTarget }), 2.6);
      }
      if (report.topSave?.displayTitle) {
        pushStep("repeat", t("reportsNextStepRepeat", { title: report.topSave.displayTitle }), 2.4);
      }
      pushStep("goal", t("reportsNextStepGoal"), 1.4);
      const sorted = steps.sort((a, b) => b.priority - a.priority);
      return sorted.slice(0, REPORTS_MAX_STEPS).map((entry) => entry.text);
    },
    [t]
  );
  const renderReportCard = (report) => {
    if (!report) return null;
    const savedUSD = Math.max(0, Number(report.totals?.savedUSD) || 0);
    const spendUSD = Math.max(0, Number(report.totals?.spendUSD) || 0);
    const balanceUSD = savedUSD - spendUSD;
    const balancePositive = balanceUSD >= 0;
    const savedLabel = formatLocalAmount(savedUSD);
    const spendLabel = spendUSD ? `-${formatLocalAmount(spendUSD)}` : formatLocalAmount(0);
    const balanceLabel = `${balancePositive ? "+" : "-"}${formatLocalAmount(Math.abs(balanceUSD))}`;
    const insights = buildInsights(report);
    const nextSteps = buildNextSteps(report);
    return (
      <View
        key={report.id}
        style={[styles.reportCard, { backgroundColor: colors.card, borderColor: colors.border }]}
      >
        <View style={styles.reportHeaderRow}>
          <Text style={[styles.reportTitle, { color: colors.text }]}>{report.label}</Text>
          <View
            style={[
              styles.reportBadge,
              { borderColor: colors.border, backgroundColor: colors.background },
            ]}
          >
            <Text style={[styles.reportBadgeText, { color: colors.muted }]}>
              {resolvedTab === "monthly" ? t("reportsMonthlyBadge") : t("reportsWeeklyBadge")}
            </Text>
          </View>
        </View>
        <View style={styles.reportStatsRow}>
          <View
            style={[
              styles.reportStatPill,
              { borderColor: colors.border, backgroundColor: colorWithAlpha(SAVE_ACTION_COLOR, 0.12) },
            ]}
          >
            <Text style={[styles.reportStatLabel, { color: colors.muted }]}>{t("reportsSavedLabel")}</Text>
            <Text style={[styles.reportStatValue, { color: SAVE_ACTION_COLOR }]}>{savedLabel}</Text>
          </View>
          <View
            style={[
              styles.reportStatPill,
              { borderColor: colors.border, backgroundColor: colorWithAlpha(SPEND_ACTION_COLOR, 0.12) },
            ]}
          >
            <Text style={[styles.reportStatLabel, { color: colors.muted }]}>{t("reportsSpentLabel")}</Text>
            <Text style={[styles.reportStatValue, { color: SPEND_ACTION_COLOR }]}>{spendLabel}</Text>
          </View>
          <View
            style={[
              styles.reportStatPill,
              { borderColor: colors.border, backgroundColor: colorWithAlpha(colors.text, 0.06) },
            ]}
          >
            <Text style={[styles.reportStatLabel, { color: colors.muted }]}>{t("reportsBalanceLabel")}</Text>
            <Text
              style={[
                styles.reportStatValue,
                { color: balancePositive ? SAVE_ACTION_COLOR : SPEND_ACTION_COLOR },
              ]}
            >
              {balanceLabel}
            </Text>
          </View>
        </View>
        <View style={styles.reportTopRow}>
          <View style={styles.reportTopItem}>
            <Text style={[styles.reportTopLabel, { color: colors.muted }]}>
              {t("reportsTopSavedLabel")}
            </Text>
            <Text style={[styles.reportTopValue, { color: colors.text }]} numberOfLines={1}>
              {report.topSave?.displayTitle || t("reportsEmptyShort")}
            </Text>
            {report.topSave?.amountUSD ? (
              <Text style={[styles.reportTopAmount, { color: SAVE_ACTION_COLOR }]}>
                {formatLocalAmount(report.topSave.amountUSD)}
              </Text>
            ) : null}
          </View>
          <View style={styles.reportTopItem}>
            <Text style={[styles.reportTopLabel, { color: colors.muted }]}>
              {t("reportsTopSpentLabel")}
            </Text>
            <Text style={[styles.reportTopValue, { color: colors.text }]} numberOfLines={1}>
              {report.topSpend?.displayTitle || t("reportsEmptyShort")}
            </Text>
            {report.topSpend?.amountUSD ? (
              <Text style={[styles.reportTopAmount, { color: SPEND_ACTION_COLOR }]}>
                {formatLocalAmount(report.topSpend.amountUSD)}
              </Text>
            ) : null}
          </View>
        </View>
        <View style={styles.reportSection}>
          <Text style={[styles.reportSectionTitle, { color: colors.text }]}>{t("reportsInsightsTitle")}</Text>
          <View style={styles.reportSectionList}>
            {insights.map((line, index) => (
              <Text key={`${report.id}-insight-${index}`} style={[styles.reportLine, { color: colors.muted }]}>
                {`â€¢ ${line}`}
              </Text>
            ))}
          </View>
        </View>
        <View style={styles.reportSection}>
          <Text style={[styles.reportSectionTitle, { color: colors.text }]}>{t("reportsNextStepsTitle")}</Text>
          <View style={styles.reportSectionList}>
            {nextSteps.map((line, index) => (
              <Text key={`${report.id}-step-${index}`} style={[styles.reportLine, { color: colors.muted }]}>
                {`â€¢ ${line}`}
              </Text>
            ))}
          </View>
        </View>
      </View>
    );
  };
  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      statusBarTranslucent
      onRequestClose={onClose}
    >
      <View style={styles.reportsModalRoot}>
        <TouchableWithoutFeedback onPress={onClose}>
          <View style={styles.reportsBackdrop} />
        </TouchableWithoutFeedback>
        <View style={styles.reportsModalWrap} pointerEvents="box-none">
          <View style={[styles.reportsModalCard, { backgroundColor: colors.card, borderColor: colors.border }]}>
            <View style={styles.reportsHeaderRow}>
              <View style={{ flex: 1 }}>
                <Text style={[styles.reportsTitle, { color: colors.text }]}>{t("reportsTitle")}</Text>
                {updatedAtLabel ? (
                  <Text style={[styles.reportsUpdated, { color: colors.muted }]}>{updatedAtLabel}</Text>
                ) : null}
              </View>
              <TouchableOpacity onPress={onClose} style={styles.reportsClose}>
                <Text style={[styles.reportsCloseText, { color: colors.muted }]}>âœ•</Text>
              </TouchableOpacity>
            </View>
            <View style={styles.reportsTabsRow}>
              {[
                { id: "weekly", label: t("reportsWeeklyTab") },
                { id: "monthly", label: t("reportsMonthlyTab") },
              ].map((tab) => {
                const isActive = resolvedTab === tab.id;
                return (
                  <TouchableOpacity
                    key={tab.id}
                    style={[
                      styles.reportsTab,
                      {
                        backgroundColor: isActive ? colors.text : "transparent",
                        borderColor: colors.border,
                      },
                    ]}
                    activeOpacity={0.85}
                    onPress={() => onTabChange(tab.id)}
                  >
                    <Text
                      style={[
                        styles.reportsTabText,
                        { color: isActive ? colors.background : colors.muted },
                      ]}
                    >
                      {tab.label}
                    </Text>
                  </TouchableOpacity>
                );
              })}
            </View>
            {activeReports.length === 0 ? (
              <Text style={[styles.reportsEmpty, { color: colors.muted }]}>
                {t("reportsEmpty")}
              </Text>
            ) : (
              <ScrollView
                style={styles.reportsList}
                contentContainerStyle={styles.reportsListContent}
                showsVerticalScrollIndicator
              >
                {activeReports.map(renderReportCard)}
              </ScrollView>
            )}
          </View>
        </View>
      </View>
    </Modal>
  );
});

const FeedScreen = React.memo(
  forwardRef(function FeedScreen(
    {
  products,
  archivedItems = [],
  savedTotalUSD,
  progressSavedTotalUSD,
  wishes = [],
  onTemptationAction,
  onTemptationEditToggle,
  onTemptationArchiveToggle,
  onNewTemptation = () => {},
  t,
  tVariant,
  language,
  colors,
  currency,
  freeDayStats,
  usageStreak = INITIAL_USAGE_STREAK,
  onUsageStreakPress = null,
  onFreeDayLog,
  healthPoints = 0,
  onFreeDayRescue,
  freeDayRescueCost = FREE_DAY_RESCUE_COST,
  analyticsStats = [],
  refuseStats = {},
  cardFeedback = {},
  historyEvents = [],
  onHistoryDelete = () => {},
  profile,
  incomeEntries = [],
  budgetOverrides = {},
  decisionStats = {},
  customCategories = [],
  titleOverrides = {},
  descriptionOverrides = {},
  onBaselineSetup,
  goalAssignments = {},
  impulseInsights = null,
  moodPreset = null,
  onMoodDetailsOpen = () => {},
  onPotentialDetailsOpen = null,
  heroGoalTargetUSD = 0,
  heroGoalSavedUSD = 0,
  potentialGrowthUSD = 0,
  showPotentialGrowth = false,
  dailyRewardUnlocked = false,
  dailyRewardReady = false,
  dailyRewardAmount = 0,
  dailyRewardBaseAmount = 0,
  dailyRewardDay = 1,
  onDailyRewardClaim = () => {},
  onDailyRewardModalVisibilityChange = null,
  dailyGoalCoinDropTick = 0,
  onDailyGoalCollect = () => {},
  dailyGoalCollectedToday = false,
  dailyGoalDayLabel = "",
  editingTemptationId = null,
  editingTitleValue = "",
  editingPriceValue = "",
  editingGoalLabel = "",
  editingEmojiValue = "",
  editingDescriptionValue = "",
  editingCategoryValue = DEFAULT_IMPULSE_CATEGORY,
  onTemptationEditTitleChange,
  onTemptationEditPriceChange,
  onTemptationEditEmojiChange,
  onTemptationEditDescriptionChange,
  onTemptationEditCategoryChange,
  onTemptationEditSave,
  onTemptationEditCancel,
  onTemptationEditDelete,
  onTemptationGoalSelect,
  onTemptationSwipeDelete,
  onSavingsBreakdownPress = () => {},
  onBudgetHeroPress = null,
  budgetAutoEnabled = true,
  savingsHeroRef = null,
  heroCarouselIndex = 0,
  heroCarouselLocked = false,
  onHeroCarouselIndexChange = null,
  onHeroCarouselLocked = null,
  onHeroCarouselPremiumAttempt = null,
  heroCarouselHintAllowed = false,
  mascotOverride = null,
  onMascotAnimationComplete = () => {},
  hideMascot = false,
  onMascotPress = () => {},
  resolveTemplateTitle = () => null,
  resolveTemplateCard = () => null,
  resolveTemptationCategory = null,
  tamagotchiMood = null,
  tamagotchiDesiredFood = null,
  tamagotchiDesiredToy = null,
  tamagotchiNeedsPlay = false,
  tamagotchiNeedsCleaning = false,
  tamagotchiDirtyLevel = 0,
  tamagotchiHungerImmunityUntil = 0,
  tamagotchiHasHungerImmunity = false,
  primaryTemptationId = null,
  primaryTemptationDescription = "",
  focusTemplateId = null,
  onFocusCancel = null,
  tamagotchiAnimations = CLASSIC_TAMAGOTCHI_ANIMATIONS,
  lifetimeSavedUSD = 0,
  progressLifetimeSavedUSD,
  levelProgressOffsetUSD = 0,
  playerLevel = 1,
  interactionStats = {},
  resolveCardRefuseStats = () => null,
  playSound = null,
  activeChallenge = null,
  onActiveChallengePress = () => {},
  onSavingsHeroAnchorChange = null,
  homeSpeechTick = 0,
  homeSpeechReason = "unknown",
  speechAllowed = true,
  speechWarmupTick = 0,
  lastVisitAt = null,
  lastVisitAtSnapshot = null,
  tamagotchiGreetingDayKey = null,
  onTamagotchiGreeting = () => {},
  tutorialTemptationStepId = null,
  tutorialHighlightMeasureTick = 0,
  onTutorialHighlightLayoutChange = null,
  allowThinkAction = true,
  isPremiumUser = false,
  budgetSpeechDataRef = null,
  onScrollActivityChange = null,
  },
    ref
  ) {
  const safeAreaInsets = safeUseSafeAreaInsets();
  const resolvedBudgetSpeechDataRef =
    typeof budgetSpeechDataRef === "undefined" ? null : budgetSpeechDataRef;
  const resolvedProgressSavedTotalUSD = Number.isFinite(progressSavedTotalUSD)
    ? progressSavedTotalUSD
    : savedTotalUSD;
  const resolvedProgressLifetimeSavedUSD = Number.isFinite(progressLifetimeSavedUSD)
    ? progressLifetimeSavedUSD
    : lifetimeSavedUSD;
  const tutorialHighlightOffset = useMemo(() => {
    if (Platform.OS !== "android") return 0;
    const bottomInset = Math.max(safeAreaInsets.bottom || 0, 0);
    return bottomInset <= 8 ? 0 : ANDROID_TUTORIAL_HIGHLIGHT_OFFSET;
  }, [safeAreaInsets.bottom]);
  const listRef = useRef(null);
  const [feedScrollLocked, setFeedScrollLocked] = useState(false);
  const activeAmountSliderCardIdRef = useRef(null);
  const heroSectionHeightRef = useRef(0);
  const heroCarouselRef = useRef(null);
  const [heroCarouselHeight, setHeroCarouselHeight] = useState(0);
  const [heroExpanded, setHeroExpanded] = useState(false);
  const heroCarouselHintAnim = useRef(new Animated.Value(0)).current;
  const heroCarouselHintPlayedRef = useRef(false);
  const heroCarouselScrollX = useRef(new Animated.Value(0)).current;
  const [heroCarouselWidth, setHeroCarouselWidth] = useState(
    Math.max(0, SCREEN_WIDTH - BASE_HORIZONTAL_PADDING * 2)
  );
  const heroCarouselPageWidth = useMemo(
    () => heroCarouselWidth + HERO_CAROUSEL_ITEM_GUTTER,
    [heroCarouselWidth]
  );
  const heroCarouselSnapThreshold = useMemo(() => Math.max(0.5, 1 / PixelRatio.get()), []);
  const heroCarouselIndexRef = useRef(heroCarouselIndex);
  const heroCarouselSnappingRef = useRef(false);
  const heroCarouselAutoScrollingRef = useRef(false);
  const heroCarouselDraggingRef = useRef(false);
  const heroCarouselUserSwipedRef = useRef(false);
  const heroCarouselPremiumAttemptedRef = useRef(false);
  const heroCarouselWiggleDisabledRef = useRef(false);
  const heroCarouselSeenMaskRef = useRef(0);
  const heroCarouselSeenPendingMaskRef = useRef(0);
  const heroCarouselWiggleCompletedRef = useRef(false);
  const [heroCarouselWiggleHydrated, setHeroCarouselWiggleHydrated] = useState(false);
  const heroCarouselIdleLoopRef = useRef(null);
  const heroCarouselIdleTimerRef = useRef(null);
  const feedScrollTimerRef = useRef(null);
  const feedScrollMomentumRef = useRef(false);
  const feedScrollingRef = useRef(false);
  const notifyFeedScrollState = useCallback(
    (next) => {
      if (feedScrollingRef.current === next) return;
      feedScrollingRef.current = next;
      if (typeof onScrollActivityChange === "function") {
        onScrollActivityChange(next);
      }
    },
    [onScrollActivityChange]
  );
  const handleFeedScrollBegin = useCallback(() => {
    if (feedScrollTimerRef.current) {
      clearTimeout(feedScrollTimerRef.current);
      feedScrollTimerRef.current = null;
    }
    feedScrollMomentumRef.current = false;
    notifyFeedScrollState(true);
  }, [notifyFeedScrollState]);
  const handleFeedScrollEnd = useCallback(() => {
    if (feedScrollMomentumRef.current) return;
    if (feedScrollTimerRef.current) {
      clearTimeout(feedScrollTimerRef.current);
    }
    feedScrollTimerRef.current = setTimeout(() => {
      notifyFeedScrollState(false);
    }, 140);
  }, [notifyFeedScrollState]);
  const handleFeedMomentumBegin = useCallback(() => {
    if (feedScrollTimerRef.current) {
      clearTimeout(feedScrollTimerRef.current);
      feedScrollTimerRef.current = null;
    }
    feedScrollMomentumRef.current = true;
    notifyFeedScrollState(true);
  }, [notifyFeedScrollState]);
  const handleFeedMomentumEnd = useCallback(() => {
    feedScrollMomentumRef.current = false;
    if (feedScrollTimerRef.current) {
      clearTimeout(feedScrollTimerRef.current);
      feedScrollTimerRef.current = null;
    }
    notifyFeedScrollState(false);
  }, [notifyFeedScrollState]);
  const handleAmountSliderToggle = useCallback((isTouching, cardId) => {
    if (isTouching) {
      activeAmountSliderCardIdRef.current = cardId || null;
      setFeedScrollLocked(true);
      return;
    }
    if (!cardId || activeAmountSliderCardIdRef.current === cardId) {
      activeAmountSliderCardIdRef.current = null;
      setFeedScrollLocked(false);
    }
  }, []);
  useEffect(() => {
    return () => {
      if (feedScrollTimerRef.current) {
        clearTimeout(feedScrollTimerRef.current);
        feedScrollTimerRef.current = null;
      }
    };
  }, []);
  const heroCarouselRealCount = 3;
  const heroCarouselSeenMaskAll = (1 << heroCarouselRealCount) - 1;
  const heroCarouselLoopCount = heroCarouselRealCount + 2;
  const heroCarouselIntervalMs = 0;
  const heroCarouselPremiumLocked = !isPremiumUser;
  useEffect(() => {
    heroCarouselIndexRef.current = heroCarouselIndex;
    heroCarouselSnappingRef.current = false;
  }, [heroCarouselIndex]);
  const heroCarouselLoopIndexForReal = useCallback((realIndex) => realIndex + 1, []);
  const resolveHeroCarouselRealIndex = useCallback(
    (loopIndex) => {
      if (loopIndex === 0) return heroCarouselRealCount - 1;
      if (loopIndex === heroCarouselRealCount + 1) return 0;
      return Math.min(Math.max(loopIndex - 1, 0), heroCarouselRealCount - 1);
    },
    [heroCarouselRealCount]
  );
  const setHeroCarouselIndexSafe = useCallback(
    (nextIndex) => {
      const clamped = Math.min(Math.max(nextIndex, 0), heroCarouselRealCount - 1);
      heroCarouselIndexRef.current = clamped;
      if (typeof onHeroCarouselIndexChange === "function") {
        onHeroCarouselIndexChange(clamped);
      }
    },
    [heroCarouselRealCount, onHeroCarouselIndexChange]
  );
  const scrollHeroCarouselToLoopIndex = useCallback(
    (loopIndex, animated = true) => {
      if (!heroCarouselRef.current || !heroCarouselPageWidth) return;
      const offsetX = heroCarouselPageWidth * loopIndex;
      heroCarouselRef.current.scrollTo({
        x: offsetX,
        y: 0,
        animated,
      });
      if (!animated) {
        heroCarouselScrollX.setValue(offsetX);
      }
    },
    [heroCarouselPageWidth, heroCarouselScrollX]
  );
  const handleHeroCarouselLayout = useCallback((event) => {
    const width = event?.nativeEvent?.layout?.width || 0;
    if (!width) return;
    setHeroCarouselWidth((prev) => (Math.abs(prev - width) < 1 ? prev : width));
  }, []);
  const handleHeroCardLayout = useCallback(
    (event) => {
      if (heroExpanded) return;
      const height = event?.nativeEvent?.layout?.height || 0;
      if (!height) return;
      setHeroCarouselHeight((prev) => (Math.abs(prev - height) < 1 ? prev : height));
    },
    [heroExpanded]
  );
  const stopHeroCarouselIdleWiggle = useCallback(
    (reset = true) => {
      if (heroCarouselIdleTimerRef.current) {
        clearTimeout(heroCarouselIdleTimerRef.current);
        heroCarouselIdleTimerRef.current = null;
      }
      if (heroCarouselIdleLoopRef.current) {
        heroCarouselIdleLoopRef.current.stop();
        heroCarouselIdleLoopRef.current = null;
      }
      if (reset) {
        heroCarouselHintAnim.stopAnimation(() => {
          heroCarouselHintAnim.setValue(0);
        });
      }
    },
    [heroCarouselHintAnim]
  );
  const startHeroCarouselIdleWiggle = useCallback(() => {
    if (heroCarouselIdleLoopRef.current) return;
    if (!heroCarouselHintAllowed) return;
    if (heroExpanded) return;
    if (heroCarouselWiggleCompletedRef.current || heroCarouselWiggleDisabledRef.current) return;
    const loop = Animated.loop(
      Animated.sequence([
        Animated.timing(heroCarouselHintAnim, {
          toValue: -18,
          duration: 280,
          easing: Easing.out(Easing.cubic),
          useNativeDriver: true,
        }),
        Animated.timing(heroCarouselHintAnim, {
          toValue: 0,
          duration: 300,
          easing: Easing.out(Easing.cubic),
          useNativeDriver: true,
        }),
        Animated.delay(1800),
      ])
    );
    heroCarouselIdleLoopRef.current = loop;
    loop.start();
  }, [heroCarouselHintAllowed, heroCarouselHintAnim, heroExpanded]);
  const refreshHeroCarouselWiggleDisabled = useCallback(() => {
    if (!heroCarouselWiggleHydrated) return true;
    if (heroCarouselWiggleCompletedRef.current) {
      heroCarouselWiggleDisabledRef.current = true;
      return true;
    }
    heroCarouselWiggleDisabledRef.current = false;
    return false;
  }, [heroCarouselWiggleHydrated]);
  const markHeroCarouselWidgetSeen = useCallback(
    (index) => {
      if (heroCarouselWiggleCompletedRef.current) return;
      const rawIndex = Number(index);
      if (!Number.isFinite(rawIndex)) return;
      const clampedIndex = Math.min(Math.max(Math.round(rawIndex), 0), heroCarouselRealCount - 1);
      const bit = 1 << clampedIndex;
      if (!heroCarouselWiggleHydrated) {
        heroCarouselSeenPendingMaskRef.current |= bit;
        return;
      }
      const prevMask = heroCarouselSeenMaskRef.current || 0;
      const nextMask = (prevMask | bit) & heroCarouselSeenMaskAll;
      if (nextMask === prevMask) return;
      heroCarouselSeenMaskRef.current = nextMask;
      AsyncStorage.setItem(
        STORAGE_KEYS.HERO_CAROUSEL_WIGGLE_SEEN,
        String(nextMask)
      ).catch(() => {});
      if (nextMask === heroCarouselSeenMaskAll) {
        heroCarouselWiggleCompletedRef.current = true;
        heroCarouselWiggleDisabledRef.current = true;
        stopHeroCarouselIdleWiggle();
      }
    },
    [
      heroCarouselRealCount,
      heroCarouselSeenMaskAll,
      heroCarouselWiggleHydrated,
      stopHeroCarouselIdleWiggle,
    ]
  );
  const scheduleHeroCarouselIdleWiggle = useCallback(() => {
    if (!heroCarouselWiggleHydrated) return;
    if (!heroCarouselHintAllowed) return;
    if (heroCarouselLocked) return;
    if (!heroCarouselPageWidth) return;
    if (heroExpanded) return;
    if (refreshHeroCarouselWiggleDisabled()) return;
    if (heroCarouselDraggingRef.current || heroCarouselAutoScrollingRef.current) return;
    stopHeroCarouselIdleWiggle(false);
    heroCarouselIdleTimerRef.current = setTimeout(() => {
      if (
        heroCarouselDraggingRef.current ||
        heroCarouselAutoScrollingRef.current ||
        heroExpanded ||
        heroCarouselLocked ||
        !heroCarouselHintAllowed ||
        heroCarouselWiggleDisabledRef.current
      ) {
        return;
      }
      startHeroCarouselIdleWiggle();
    }, 200);
  }, [
    heroExpanded,
    heroCarouselWiggleHydrated,
    heroCarouselHintAllowed,
    heroCarouselLocked,
    heroCarouselPageWidth,
    refreshHeroCarouselWiggleDisabled,
    startHeroCarouselIdleWiggle,
    stopHeroCarouselIdleWiggle,
  ]);
  useEffect(() => {
    let active = true;
    const hydrateHeroCarouselWiggle = async () => {
      const rawSeen = await AsyncStorage.getItem(
        STORAGE_KEYS.HERO_CAROUSEL_WIGGLE_SEEN
      ).catch(() => null);
      if (!active) return;
      const storedMask = Math.max(0, Number(rawSeen) || 0);
      const pendingMask = heroCarouselSeenPendingMaskRef.current || 0;
      const combinedMask = (storedMask | pendingMask) & heroCarouselSeenMaskAll;
      heroCarouselSeenPendingMaskRef.current = 0;
      heroCarouselSeenMaskRef.current = combinedMask;
      if (combinedMask !== (storedMask & heroCarouselSeenMaskAll)) {
        AsyncStorage.setItem(
          STORAGE_KEYS.HERO_CAROUSEL_WIGGLE_SEEN,
          String(combinedMask)
        ).catch(() => {});
      }
      if (combinedMask === heroCarouselSeenMaskAll) {
        heroCarouselWiggleCompletedRef.current = true;
        heroCarouselWiggleDisabledRef.current = true;
        stopHeroCarouselIdleWiggle();
      } else {
        heroCarouselWiggleCompletedRef.current = false;
        heroCarouselWiggleDisabledRef.current = false;
      }
      setHeroCarouselWiggleHydrated(true);
    };
    hydrateHeroCarouselWiggle();
    return () => {
      active = false;
    };
  }, [heroCarouselSeenMaskAll, stopHeroCarouselIdleWiggle]);
  useEffect(() => {
    if (!heroCarouselWiggleHydrated) return;
    markHeroCarouselWidgetSeen(heroCarouselIndexRef.current || 0);
  }, [heroCarouselWiggleHydrated, markHeroCarouselWidgetSeen]);
  const triggerHeroCarouselPremiumAttempt = useCallback(() => {
    if (!heroCarouselPremiumLocked) return;
    if (heroCarouselPremiumAttemptedRef.current) return;
    heroCarouselPremiumAttemptedRef.current = true;
    if (typeof onHeroCarouselPremiumAttempt === "function") {
      onHeroCarouselPremiumAttempt();
    }
  }, [heroCarouselPremiumLocked, onHeroCarouselPremiumAttempt]);
  const handleHeroCarouselScroll = useCallback(
    (event) => {
      if (!heroCarouselPremiumLocked) return;
      if (!heroCarouselPageWidth) return;
      if (!heroCarouselDraggingRef.current) return;
      const rawOffsetX = Number(event?.nativeEvent?.contentOffset?.x);
      if (!Number.isFinite(rawOffsetX)) return;
      const lockedOffset = heroCarouselPageWidth * heroCarouselLoopIndexForReal(0);
      const delta = rawOffsetX - lockedOffset;
      if (Math.abs(delta) >= HERO_CAROUSEL_PREMIUM_ATTEMPT_TRIGGER_PX) {
        triggerHeroCarouselPremiumAttempt();
      }
      if (Math.abs(delta) <= HERO_CAROUSEL_PREMIUM_DRAG_LIMIT_PX) return;
      const clampedOffset =
        lockedOffset + Math.sign(delta || 1) * HERO_CAROUSEL_PREMIUM_DRAG_LIMIT_PX;
      if (Math.abs(rawOffsetX - clampedOffset) < 0.5) return;
      heroCarouselRef.current?.scrollTo?.({ x: clampedOffset, y: 0, animated: false });
      heroCarouselScrollX.setValue(clampedOffset);
    },
    [
      heroCarouselLoopIndexForReal,
      heroCarouselPageWidth,
      heroCarouselPremiumLocked,
      heroCarouselScrollX,
      triggerHeroCarouselPremiumAttempt,
    ]
  );
  const handleHeroCarouselAnimatedScroll = useMemo(
    () =>
      Animated.event(
        [{ nativeEvent: { contentOffset: { x: heroCarouselScrollX } } }],
        { useNativeDriver: true, listener: handleHeroCarouselScroll }
      ),
    [handleHeroCarouselScroll, heroCarouselScrollX]
  );
  const handleHeroCarouselScrollBegin = useCallback(() => {
    heroCarouselDraggingRef.current = true;
    heroCarouselUserSwipedRef.current = true;
    heroCarouselWiggleDisabledRef.current = true;
    heroCarouselPremiumAttemptedRef.current = false;
    stopHeroCarouselIdleWiggle();
  }, [stopHeroCarouselIdleWiggle]);
  const handleHeroCarouselScrollEnd = useCallback(
    (event) => {
      heroCarouselDraggingRef.current = false;
      if (!heroCarouselPageWidth) return;
      if (heroCarouselPremiumLocked) {
        const offsetX = Number(event?.nativeEvent?.contentOffset?.x) || 0;
        const lockedOffset = heroCarouselPageWidth * heroCarouselLoopIndexForReal(0);
        const delta = offsetX - lockedOffset;
        if (Math.abs(delta) >= HERO_CAROUSEL_PREMIUM_ATTEMPT_TRIGGER_PX) {
          triggerHeroCarouselPremiumAttempt();
        }
        heroCarouselUserSwipedRef.current = false;
        heroCarouselAutoScrollingRef.current = false;
        setHeroCarouselIndexSafe(0);
        scrollHeroCarouselToLoopIndex(heroCarouselLoopIndexForReal(0), false);
        heroCarouselPremiumAttemptedRef.current = false;
        return;
      }
      const offsetX = event?.nativeEvent?.contentOffset?.x || 0;
      const loopIndex = Math.round(offsetX / heroCarouselPageWidth);
      const targetOffsetX = loopIndex * heroCarouselPageWidth;
      const offsetDelta = Math.abs(offsetX - targetOffsetX);
      if (offsetDelta > heroCarouselSnapThreshold) {
        if (!heroCarouselSnappingRef.current) {
          heroCarouselSnappingRef.current = true;
          scrollHeroCarouselToLoopIndex(loopIndex, true);
        }
        return;
      }
      heroCarouselSnappingRef.current = false;
      const resolvedRealIndex = resolveHeroCarouselRealIndex(loopIndex);
      markHeroCarouselWidgetSeen(resolvedRealIndex);
      const previousIndex = heroCarouselIndexRef.current;
      const atLoopHead = loopIndex === 0;
      const atLoopTail = loopIndex === heroCarouselRealCount + 1;
      if (heroCarouselAutoScrollingRef.current) {
        heroCarouselAutoScrollingRef.current = false;
      }
      const didSwipe = heroCarouselUserSwipedRef.current;
      if (didSwipe) {
        heroCarouselUserSwipedRef.current = false;
        const widgetKey =
          HERO_CAROUSEL_WIDGET_ANALYTICS_KEYS[resolvedRealIndex] ||
          HERO_CAROUSEL_WIDGET_ANALYTICS_KEYS[0];
        logEvent("hero_widget_stopped", { widget: widgetKey });
        if (resolvedRealIndex !== previousIndex) {
          triggerSelectionHaptic();
        }
        if (resolvedRealIndex !== previousIndex && !heroCarouselLocked && typeof onHeroCarouselLocked === "function") {
          onHeroCarouselLocked(true);
        }
      }
      setHeroCarouselIndexSafe(resolvedRealIndex);
      if (atLoopHead) {
        scrollHeroCarouselToLoopIndex(heroCarouselRealCount, false);
        scheduleHeroCarouselIdleWiggle();
        return;
      }
      if (atLoopTail) {
        scrollHeroCarouselToLoopIndex(1, false);
        scheduleHeroCarouselIdleWiggle();
        return;
      }
      scheduleHeroCarouselIdleWiggle();
    },
    [
      heroCarouselLocked,
      heroCarouselPremiumLocked,
      heroCarouselRealCount,
      heroCarouselLoopIndexForReal,
      heroCarouselPageWidth,
      heroCarouselSnapThreshold,
      markHeroCarouselWidgetSeen,
      onHeroCarouselLocked,
      resolveHeroCarouselRealIndex,
      scrollHeroCarouselToLoopIndex,
      scheduleHeroCarouselIdleWiggle,
      setHeroCarouselIndexSafe,
      triggerHeroCarouselPremiumAttempt,
      logEvent,
    ]
  );
  useEffect(() => {
    if (!heroCarouselPageWidth) return;
    const loopIndex = heroCarouselLoopIndexForReal(heroCarouselIndexRef.current || 0);
    scrollHeroCarouselToLoopIndex(loopIndex, false);
  }, [heroCarouselLoopIndexForReal, heroCarouselPageWidth, scrollHeroCarouselToLoopIndex]);
  useEffect(() => {
    if (!heroCarouselPremiumLocked) return;
    heroCarouselDraggingRef.current = false;
    heroCarouselAutoScrollingRef.current = false;
    heroCarouselSnappingRef.current = false;
    heroCarouselUserSwipedRef.current = false;
    heroCarouselPremiumAttemptedRef.current = false;
    setHeroCarouselIndexSafe(0);
    if (!heroCarouselPageWidth) return;
    const lockedLoopIndex = heroCarouselLoopIndexForReal(0);
    scrollHeroCarouselToLoopIndex(lockedLoopIndex, false);
  }, [
    heroCarouselLoopIndexForReal,
    heroCarouselPageWidth,
    heroCarouselPremiumLocked,
    scrollHeroCarouselToLoopIndex,
    setHeroCarouselIndexSafe,
  ]);
  useEffect(() => {
    if (!heroCarouselPageWidth) return;
    if (!heroCarouselIntervalMs) return;
    if (heroCarouselLocked) return;
    const timer = setInterval(() => {
      if (
        heroCarouselLocked ||
        heroCarouselDraggingRef.current ||
        heroCarouselAutoScrollingRef.current
      ) {
        return;
      }
      const nextIndex = (heroCarouselIndexRef.current + 1) % heroCarouselRealCount;
      const currentLoopIndex = heroCarouselLoopIndexForReal(heroCarouselIndexRef.current || 0);
      const nextLoopIndex = Math.min(currentLoopIndex + 1, heroCarouselLoopCount - 1);
      heroCarouselAutoScrollingRef.current = true;
      setHeroCarouselIndexSafe(nextIndex);
      scrollHeroCarouselToLoopIndex(nextLoopIndex, true);
    }, heroCarouselIntervalMs);
    return () => clearInterval(timer);
  }, [
    heroCarouselIntervalMs,
    heroCarouselLocked,
    heroCarouselLoopCount,
    heroCarouselLoopIndexForReal,
    heroCarouselRealCount,
    heroCarouselPageWidth,
    scrollHeroCarouselToLoopIndex,
    setHeroCarouselIndexSafe,
  ]);
  useEffect(() => {
    if (!heroCarouselWiggleHydrated) return;
    if (!heroCarouselHintAllowed) return;
    if (heroCarouselHintPlayedRef.current) return;
    if (!heroCarouselPageWidth) return;
    if (heroCarouselLocked) return;
    if (heroExpanded) return;
    if (refreshHeroCarouselWiggleDisabled()) return;
    heroCarouselHintPlayedRef.current = true;
    stopHeroCarouselIdleWiggle(false);
    Animated.sequence([
      Animated.timing(heroCarouselHintAnim, {
        toValue: -16,
        duration: 240,
        easing: Easing.out(Easing.cubic),
        useNativeDriver: true,
      }),
      Animated.timing(heroCarouselHintAnim, {
        toValue: 0,
        duration: 260,
        easing: Easing.out(Easing.cubic),
        useNativeDriver: true,
      }),
    ]).start(() => {
      heroCarouselHintAnim.setValue(0);
      startHeroCarouselIdleWiggle();
    });
  }, [
    heroCarouselHintAllowed,
    heroCarouselHintAnim,
    heroCarouselLocked,
    heroCarouselPageWidth,
    heroExpanded,
    heroCarouselWiggleHydrated,
    refreshHeroCarouselWiggleDisabled,
    startHeroCarouselIdleWiggle,
    stopHeroCarouselIdleWiggle,
  ]);
  useEffect(() => {
    if (!heroCarouselWiggleHydrated) return;
    if (!heroCarouselHintAllowed || heroCarouselLocked || heroExpanded) {
      stopHeroCarouselIdleWiggle();
      return;
    }
    if (!heroCarouselHintPlayedRef.current) return;
    if (!refreshHeroCarouselWiggleDisabled()) {
      startHeroCarouselIdleWiggle();
    }
    return () => stopHeroCarouselIdleWiggle();
  }, [
    heroCarouselHintAllowed,
    heroCarouselLocked,
    heroExpanded,
    heroCarouselWiggleHydrated,
    refreshHeroCarouselWiggleDisabled,
    startHeroCarouselIdleWiggle,
    stopHeroCarouselIdleWiggle,
  ]);
  useEffect(() => {
    if (!heroCarouselWiggleHydrated) return;
    if (!heroCarouselHintAllowed) {
      stopHeroCarouselIdleWiggle();
      return;
    }
    if (!heroCarouselPageWidth) return;
    if (heroCarouselLocked || heroExpanded) {
      stopHeroCarouselIdleWiggle();
      return;
    }
    if (refreshHeroCarouselWiggleDisabled()) {
      stopHeroCarouselIdleWiggle();
      return;
    }
    if (heroCarouselDraggingRef.current || heroCarouselAutoScrollingRef.current) return;
    startHeroCarouselIdleWiggle();
    return () => stopHeroCarouselIdleWiggle();
  }, [
    heroCarouselHintAllowed,
    heroCarouselLocked,
    heroExpanded,
    heroCarouselPageWidth,
    heroCarouselWiggleHydrated,
    refreshHeroCarouselWiggleDisabled,
    startHeroCarouselIdleWiggle,
    stopHeroCarouselIdleWiggle,
  ]);
  const scrollToTop = useCallback(
    ({ animated = false } = {}) => {
      if (!listRef.current) return false;
      try {
        listRef.current.scrollToOffset({ offset: 0, animated });
        return true;
      } catch (error) {
        return false;
      }
    },
    []
  );
  const scrollToTemptations = useCallback(
    ({ animated = true, extraOffset = 0 } = {}) => {
      if (!listRef.current) return false;
      const baseOffset = Math.max(0, (heroSectionHeightRef.current || 0) - 16);
      const offset = Math.max(0, baseOffset + (Number(extraOffset) || 0));
      try {
        listRef.current.scrollToOffset({ offset, animated });
        return true;
      } catch (error) {
        return false;
      }
    },
    []
  );
  const handleHeroLayout = useCallback((event) => {
    const height = event?.nativeEvent?.layout?.height || 0;
    if (!height) return;
    heroSectionHeightRef.current = height;
  }, []);
  useImperativeHandle(
    ref,
    () => ({
      scrollToTop,
      scrollToTemptations,
    }),
    [scrollToTop, scrollToTemptations]
  );
  const resolvedHistoryEvents = Array.isArray(historyEvents) ? historyEvents : [];
  const isEssentialHistoryEntry = useCallback((entry) => {
    const categoryId =
      entry?.meta?.category || entry?.meta?.impulseCategory || entry?.meta?.impulseCategoryOverride;
    return isEssentialImpulseCategory(categoryId);
  }, []);
  const [historyModalVisible, setHistoryModalVisible] = useState(false);
  const openHistoryModal = useCallback(() => setHistoryModalVisible(true), []);
  const closeHistoryModal = useCallback(() => setHistoryModalVisible(false), []);
  const feedShuffleSeedRef = useRef(Math.random());
  const heroNowTick = useMinuteTicker(true);
  const handleBaselineSetup = onBaselineSetup || (() => {});
  const realSavedUSD = useRealSavedAmount();
  const totalSavedLabel = useMemo(
    () => formatCurrency(convertToCurrency(realSavedUSD || 0, currency), currency),
    [realSavedUSD, currency]
  );
  const heroGoalSavedLabel = useMemo(
    () => formatCurrency(convertToCurrency(heroGoalSavedUSD || 0, currency), currency),
    [heroGoalSavedUSD, currency]
  );
  const heroTargetLabel = useMemo(
    () => formatCurrency(convertToCurrency(heroGoalTargetUSD || 0, currency), currency),
    [heroGoalTargetUSD, currency]
  );
  const heroHasActiveGoal =
    Boolean(profile?.goal) ||
    (Array.isArray(profile?.primaryGoals) && profile.primaryGoals.length > 0);
  const isGoalComplete = heroGoalTargetUSD > 0 && heroGoalSavedUSD >= heroGoalTargetUSD;
  const goalProgress = heroGoalTargetUSD > 0 ? heroGoalSavedUSD / heroGoalTargetUSD : 0;
  const remainingLocal = formatCurrency(
    convertToCurrency(Math.max(heroGoalTargetUSD - heroGoalSavedUSD, 0), currency),
    currency
  );
  const personaPreset = useMemo(() => getPersonaPreset(profile?.persona), [profile?.persona]);
  const recentActivity = useMemo(() => {
    const filtered = resolvedHistoryEvents.filter(
      (entry) => entry.kind === "refuse_spend" || entry.kind === "spend"
    );
    filtered.sort((a, b) => {
      const aTime = normalizeTimestampMs(a?.timestamp);
      const bTime = normalizeTimestampMs(b?.timestamp);
      return bTime - aTime;
    });
    return filtered.slice(0, 3);
  }, [resolvedHistoryEvents, isEssentialHistoryEntry]);
  const heroRecentActivity = useMemo(() => {
    const nowTimestamp = heroNowTick || Date.now();
    const cutoffTimestamp = nowTimestamp - HERO_RECENT_HISTORY_WINDOW_MS;
    const filtered = resolvedHistoryEvents.filter((entry) => {
      if (entry?.kind !== "refuse_spend" && entry?.kind !== "spend") return false;
      const timestamp = normalizeTimestampMs(entry?.timestamp);
      return timestamp >= cutoffTimestamp && timestamp <= nowTimestamp;
    });
    filtered.sort((a, b) => normalizeTimestampMs(b?.timestamp) - normalizeTimestampMs(a?.timestamp));
    return filtered.slice(0, 3);
  }, [heroNowTick, resolvedHistoryEvents]);
  const heroHistoryEntries = useMemo(() => {
    const nowTimestamp = heroNowTick || Date.now();
    const cutoffTimestamp = nowTimestamp - HERO_RECENT_HISTORY_WINDOW_MS;
    const filtered = resolvedHistoryEvents.filter((entry) => {
      const timestamp = normalizeTimestampMs(entry?.timestamp);
      if (!timestamp) return false;
      return timestamp >= cutoffTimestamp && timestamp <= nowTimestamp;
    });
    filtered.sort((a, b) => normalizeTimestampMs(b?.timestamp) - normalizeTimestampMs(a?.timestamp));
    return filtered;
  }, [heroNowTick, resolvedHistoryEvents]);
  const { latestSaveEvent, latestSpendEvent } = useMemo(() => {
    let latestSave = null;
    let latestSpend = null;
    resolvedHistoryEvents.forEach((entry) => {
      if (!entry || !entry.kind) return;
      if (isEssentialHistoryEntry(entry)) return;
      const timestamp = Number(entry.timestamp) || 0;
      if (!timestamp) return;
      if (entry.kind === "refuse_spend") {
        if (!latestSave || timestamp > Number(latestSave.timestamp || 0)) {
          latestSave = entry;
        }
      } else if (entry.kind === "spend") {
        if (!latestSpend || timestamp > Number(latestSpend.timestamp || 0)) {
          latestSpend = entry;
        }
      }
    });
    return { latestSaveEvent: latestSave, latestSpendEvent: latestSpend };
  }, [resolvedHistoryEvents]);
  const heroRecentEvents = useMemo(
    () =>
      heroRecentActivity.map((entry) => {
        const entryTimestamp = normalizeTimestampMs(entry?.timestamp);
        const resolvedTitle =
          resolveTemplateTitle(entry?.meta?.templateId, entry?.meta?.title) ||
          entry?.title ||
          t("defaultDealTitle");
        const timestampLabel = formatLatestSavingTimestamp(entryTimestamp, language);
        const isSpend = entry.kind === "spend";
        const prefix = isSpend ? "- " : "";
        return {
          id: entry.id,
          label: `${prefix}${resolvedTitle}${timestampLabel ? ` Â· ${timestampLabel}` : ""}`,
          isSpend,
          timestamp: entryTimestamp,
        };
      }),
    [heroRecentActivity, language, resolveTemplateTitle, t]
  );
  const resolveEventTitle = useCallback(
    (entry) =>
      resolveTemplateTitle(entry?.meta?.templateId, entry?.meta?.title) ||
      entry?.title ||
      t("defaultDealTitle"),
    [resolveTemplateTitle, t]
  );
  const resolveSpeechTitle = useCallback(
    (entry) => {
      const raw =
        resolveTemplateTitle(entry?.meta?.templateId, entry?.meta?.title) ||
        entry?.title ||
        t("defaultDealTitle");
      return String(raw || "")
        .replace(/^[^\p{L}\p{N}]+/gu, "")
        .replace(/^\s+/, "")
        .trim();
    },
    [resolveTemplateTitle, t]
  );
  const stripEmoji = useCallback((value) => {
    if (!value) return "";
    return String(value)
      .replace(/\p{Extended_Pictographic}+/gu, "")
      .replace(/\s{2,}/g, " ")
      .trim();
  }, []);
  const getInteractionKey = useCallback((value) => {
    if (typeof value === "number") {
      return normalizeInteractionKey(String(value));
    }
    if (typeof value === "string") {
      return normalizeInteractionKey(value);
    }
    return null;
  }, []);
  const heroSpendCopy = useMemo(() => {
    if (heroRecentEvents.length > 0) {
      return "";
    }
    if (!realSavedUSD || realSavedUSD <= 0) {
      return t("heroSpendFallback");
    }
    const template = personaPreset?.tagline?.[language];
    if (template) {
      return template.replace("{{amount}}", totalSavedLabel);
    }
    return t("heroSpendFallback");
  }, [heroRecentEvents.length, language, personaPreset, realSavedUSD, t, totalSavedLabel]);
  const heroEncouragementLine = useMemo(() => {
    const heroLine = isGoalComplete
      ? moodPreset?.heroComplete || t("goalWidgetCompleteTagline")
      : moodPreset?.hero || t("heroEconomyContinues");
    if (moodPreset?.motivation) {
      return `${heroLine} ${moodPreset.motivation}`;
    }
    return heroLine;
  }, [isGoalComplete, moodPreset, t]);
  const historyInteractionMap = useMemo(
    () => buildHistoryInteractionMap(resolvedHistoryEvents),
    [resolvedHistoryEvents]
  );
  const resolveHistoryEntryForItem = useCallback(
    (item) => {
      if (!item) return null;
      const keys = [
        normalizeInteractionKey(item.id),
        normalizeInteractionKey(item.templateId),
      ].filter(Boolean);
      if (!keys.length) return null;
      let best = null;
      keys.forEach((key) => {
        const candidate = historyInteractionMap?.[key];
        if (!candidate) return;
        if (!best || (candidate.lastInteractionAt || 0) > (best.lastInteractionAt || 0)) {
          best = candidate;
        }
      });
      return best;
    },
    [historyInteractionMap]
  );
  const isDarkMode = colors === THEMES.dark;
  const isProMode = colors === THEMES.pro || colors?.background === THEMES.pro.background;
  const heroProBadgePalette = useMemo(
    () => ({
      background: "#0C0C0C",
      border: "#0C0C0C",
      text: "#FFFFFF",
    }),
    []
  );
  const moodGradient = useMemo(
    () =>
      applyThemeToMoodGradient(
        getMoodGradient(moodPreset?.id),
        isDarkMode ? "dark" : isProMode ? PRO_THEME_ID : "light"
      ),
    [isDarkMode, isProMode, moodPreset?.id]
  );
  const mainTemptationId = primaryTemptationId;
  const resolveInteractionEntry = useCallback(
    (item) => {
      if (!item) return null;
      const rawItemKey =
        typeof item?.id === "string" || typeof item?.id === "number" ? String(item.id) : null;
      const rawTemplateKey =
        typeof item?.templateId === "string" || typeof item?.templateId === "number"
          ? String(item.templateId)
          : null;
      const itemKey = getInteractionKey(rawItemKey);
      const templateKey = getInteractionKey(rawTemplateKey);
      const direct =
        (itemKey && interactionStats?.[itemKey]) ||
        (rawItemKey ? interactionStats?.[rawItemKey] || null : null) ||
        null;
      const templated =
        (templateKey && interactionStats?.[templateKey]) ||
        (rawTemplateKey ? interactionStats?.[rawTemplateKey] || null : null) ||
        null;
      const historyEntry = resolveHistoryEntryForItem(item);
      const candidates = [direct, templated, historyEntry].filter(Boolean);
      if (!candidates.length) return null;
      const getEntryStamp = (entry) => {
        const lastInteractionAt = Number(entry?.lastInteractionAt) || 0;
        const lastTimerResetAt = Number(entry?.lastTimerResetAt) || 0;
        const nextCheckAt = Number(entry?.nextCheckAt) || 0;
        return Math.max(lastInteractionAt, lastTimerResetAt, nextCheckAt);
      };
      let base = candidates[0];
      let bestStamp = getEntryStamp(base);
      for (let index = 1; index < candidates.length; index += 1) {
        const candidate = candidates[index];
        const stamp = getEntryStamp(candidate);
        if (stamp > bestStamp) {
          bestStamp = stamp;
          base = candidate;
        }
      }
      if (!base) return null;
      if (base.frequency || base.intervalMs) return base;
      const fallback = candidates.find((entry) => entry && (entry.frequency || entry.intervalMs));
      if (!fallback || fallback === base) return base;
      return {
        ...base,
        frequency: fallback.frequency ?? base.frequency ?? null,
        frequencyCustom: fallback.frequencyCustom ?? base.frequencyCustom ?? null,
        intervalMs: fallback.intervalMs ?? base.intervalMs ?? null,
      };
    },
    [getInteractionKey, interactionStats, resolveHistoryEntryForItem]
  );
  const interactionEntryMap = useMemo(() => {
    const map = new Map();
    const list = [
      ...(Array.isArray(products) ? products : []),
      ...(Array.isArray(archivedItems) ? archivedItems : []),
    ];
    list.forEach((item) => {
      if (!item) return;
      const entry = resolveInteractionEntry(item);
      if (!entry) return;
      const rawItemKey =
        typeof item?.id === "string" || typeof item?.id === "number" ? String(item.id) : null;
      const rawTemplateKey =
        typeof item?.templateId === "string" || typeof item?.templateId === "number"
          ? String(item.templateId)
          : null;
      const itemKey = getInteractionKey(rawItemKey);
      const templateKey = getInteractionKey(rawTemplateKey);
      if (itemKey) {
        map.set(itemKey, entry);
      }
      if (templateKey) {
        map.set(templateKey, entry);
      }
      if (rawItemKey && rawItemKey !== itemKey) {
        map.set(rawItemKey, entry);
      }
      if (rawTemplateKey && rawTemplateKey !== templateKey) {
        map.set(rawTemplateKey, entry);
      }
    });
    return map;
  }, [archivedItems, getInteractionKey, products, resolveInteractionEntry]);
  const getInteractionEntry = useCallback(
    (item) => {
      if (!item) return null;
      const rawItemKey =
        typeof item?.id === "string" || typeof item?.id === "number" ? String(item.id) : null;
      const rawTemplateKey =
        typeof item?.templateId === "string" || typeof item?.templateId === "number"
          ? String(item.templateId)
          : null;
      const itemKey = getInteractionKey(rawItemKey);
      const templateKey = getInteractionKey(rawTemplateKey);
      return (
        (itemKey ? interactionEntryMap.get(itemKey) : null) ||
        (rawItemKey ? interactionEntryMap.get(rawItemKey) : null) ||
        (templateKey ? interactionEntryMap.get(templateKey) : null) ||
        (rawTemplateKey ? interactionEntryMap.get(rawTemplateKey) : null) ||
        null
      );
    },
    [getInteractionKey, interactionEntryMap]
  );
  const goldPalette = useMemo(
    () =>
      isGoalComplete
        ? isDarkMode
          ? {
              background: "#07281C",
              border: "rgba(134,255,192,0.4)",
              glow: "rgba(46,182,125,0.35)",
              accent: "#7BFFB8",
              text: "#E9FFF5",
              subtext: "rgba(233,255,245,0.8)",
              badgeBg: "rgba(0,0,0,0.45)",
              badgeBorder: "rgba(123,255,184,0.5)",
              badgeText: "#9FFFCF",
              barBg: "rgba(0,0,0,0.3)",
              shadow: "#032015",
              danger: "#FF9C9C",
            }
          : {
              background: "#E7FFE8",
              border: "rgba(107,201,128,0.7)",
              glow: "rgba(185,255,210,0.6)",
              accent: "#1C8F4A",
              text: "#064321",
              subtext: "rgba(6,67,33,0.75)",
              badgeBg: "rgba(255,255,255,0.92)",
              badgeBorder: "rgba(6,67,33,0.12)",
              badgeText: "#0E5B30",
              barBg: "rgba(255,255,255,0.65)",
              shadow: "#B2F8C3",
              danger: "#D63B3B",
            }
        : isDarkMode
        ? {
            background: "#2B1A00",
            border: "rgba(255,214,143,0.5)",
            glow: "rgba(255,184,0,0.25)",
            accent: "#FFCF6B",
            text: "#FFEED0",
            subtext: "rgba(255,238,208,0.8)",
            badgeBg: "rgba(0,0,0,0.35)",
            badgeBorder: "rgba(255,223,165,0.5)",
            badgeText: "#FFEED0",
            barBg: "rgba(0,0,0,0.3)",
            shadow: "#1B1100",
            danger: "#FF8F8F",
          }
        : {
            background: "#FFF6D5",
            border: "rgba(240,196,92,0.8)",
            glow: "rgba(255,255,255,0.8)",
            accent: "#D8960B",
            text: "#5C3300",
            subtext: "rgba(92,51,0,0.75)",
            badgeBg: "rgba(255,255,255,0.75)",
            badgeBorder: "rgba(255,255,255,0.9)",
            badgeText: "#7A4A00",
            barBg: "rgba(255,255,255,0.6)",
            shadow: "#F3C75A",
            danger: "#D63B3B",
          },
    [isDarkMode, isGoalComplete]
  );
  const heroMascotWrapStyle = useMemo(
    () =>
      isDarkMode
        ? { backgroundColor: "rgba(0,0,0,0.3)", borderColor: "rgba(255,255,255,0.12)" }
        : null,
    [isDarkMode]
  );
  const pickVariantText = useCallback(
    (key, replacements = {}) => (typeof tVariant === "function" ? tVariant(key, replacements) : t(key, replacements)),
    [t, tVariant]
  );
  const pickKeyText = useCallback(
    (keys = [], replacements = {}) => {
      if (!keys.length) return "";
      const key = keys[Math.floor(Math.random() * keys.length)] || keys[0];
      return t(key, replacements);
    },
    [t]
  );
  const shortenSpeechTitle = useCallback((value, maxLength = 20) => {
    if (!value) return "";
    const text = String(value).trim();
    if (text.length <= maxLength) return text;
    return `${text.slice(0, Math.max(1, maxLength - 1)).trim()}â€¦`;
  }, []);
  const [tamagotchiSpeech, setTamagotchiSpeech] = useState(() =>
    pickVariantText("tamagotchiSpeechGeneral")
  );
  const [tamagotchiSpeechVisible, setTamagotchiSpeechVisible] = useState(false);
  const tamagotchiSpeechTimerRef = useRef(null);
  const tamagotchiSpeechLastAtRef = useRef(0);
  const tamagotchiSpeechLastTextRef = useRef("");
  const tamagotchiSpeechReadyShownRef = useRef(false);
  const tamagotchiSpeechPrimedRef = useRef(false);
  const tamagotchiSpeechWarmupShownRef = useRef(false);
  const [tamagotchiSpeechWarmupVisible, setTamagotchiSpeechWarmupVisible] = useState(true);
  const speechAllowedRef = useRef(speechAllowed);
  useEffect(() => {
    speechAllowedRef.current = speechAllowed;
  }, [speechAllowed]);
  const [heroLevelExpanded, setHeroLevelExpanded] = useState(false);
  const heroLevelAnim = useRef(new Animated.Value(heroLevelExpanded ? 1 : 0)).current;
  const [heroRowWidth, setHeroRowWidth] = useState(0);
  const [heroLogoRight, setHeroLogoRight] = useState(0);
  const heroBubbleMaxWidth = useMemo(() => {
    if (!heroRowWidth || !heroLogoRight) return 200;
    return Math.max(90, heroRowWidth - heroLogoRight + 16);
  }, [heroRowWidth, heroLogoRight]);
  const heroBubbleTextMaxWidth = Math.max(0, heroBubbleMaxWidth - 16);
  const toggleHeroLevelExpanded = useCallback(() => {
    runLayoutAnimation();
    setHeroLevelExpanded((prev) => !prev);
  }, []);
  useEffect(() => {
    Animated.timing(heroLevelAnim, {
      toValue: heroLevelExpanded ? 1 : 0,
      duration: 240,
      easing: Easing.out(Easing.cubic),
      useNativeDriver: true,
    }).start();
  }, [heroLevelAnim, heroLevelExpanded]);
  const clearTamagotchiSpeechTimer = useCallback(() => {
    if (tamagotchiSpeechTimerRef.current) {
      clearTimeout(tamagotchiSpeechTimerRef.current);
      tamagotchiSpeechTimerRef.current = null;
    }
  }, []);
  const peekTamagotchiSpeech = useCallback(
    (reason = "unknown") => {
      let text = "";
      for (let i = 0; i < 4; i += 1) {
        const candidate = buildTamagotchiSpeech(reason);
        if (!candidate) continue;
        if (candidate === tamagotchiSpeechLastTextRef.current) {
          continue;
        }
        text = candidate;
        break;
      }
      if (!text) {
        const fallback = pickVariantText("tamagotchiSpeechGeneral");
        if (fallback && fallback !== tamagotchiSpeechLastTextRef.current) {
          text = fallback;
        }
      }
      return text;
    },
    [buildTamagotchiSpeech, pickVariantText]
  );
  const getNextTamagotchiSpeech = useCallback(
    (reason = "unknown") => {
      const text = peekTamagotchiSpeech(reason);
      if (!text) return "";
      tamagotchiSpeechLastTextRef.current = text;
      tamagotchiSpeechLastAtRef.current = Date.now();
      return text;
    },
    [peekTamagotchiSpeech]
  );
  const primeTamagotchiSpeech = useCallback(
    (reason = "ready") => {
      if (tamagotchiSpeechPrimedRef.current) return;
      if (tamagotchiSpeech) {
        tamagotchiSpeechPrimedRef.current = true;
        return;
      }
      const nextText = peekTamagotchiSpeech(reason);
      if (!nextText) return;
      tamagotchiSpeechPrimedRef.current = true;
      setTamagotchiSpeech(nextText);
    },
    [peekTamagotchiSpeech, tamagotchiSpeech]
  );
  useEffect(() => {
    primeTamagotchiSpeech("ready");
  }, [primeTamagotchiSpeech]);
  const scheduleNextTamagotchiSpeech = useCallback(() => {
    clearTamagotchiSpeechTimer();
    tamagotchiSpeechTimerRef.current = setTimeout(() => {
      if (!speechAllowedRef.current) {
        setTamagotchiSpeechVisible(false);
        scheduleNextTamagotchiSpeech();
        return;
      }
      const nextText = getNextTamagotchiSpeech("unknown");
      if (!nextText) {
        setTamagotchiSpeechVisible(false);
        return;
      }
      setTamagotchiSpeech(nextText);
      setTamagotchiSpeechVisible(true);
      scheduleNextTamagotchiSpeech();
    }, TAMAGOTCHI_SPEECH_DURATION_MS);
  }, [clearTamagotchiSpeechTimer, getNextTamagotchiSpeech]);
  useEffect(() => () => clearTamagotchiSpeechTimer(), [clearTamagotchiSpeechTimer]);
  useEffect(() => {
    if (!speechAllowed) {
      if (!tamagotchiSpeechWarmupVisible) {
        setTamagotchiSpeechVisible(false);
      }
      if (!tamagotchiSpeechTimerRef.current) {
        scheduleNextTamagotchiSpeech();
      }
      return;
    }
    if (tamagotchiSpeechWarmupVisible) {
      setTamagotchiSpeechWarmupVisible(false);
    }
    const now = Date.now();
    const speechStale =
      tamagotchiSpeechLastAtRef.current > 0 &&
      now - tamagotchiSpeechLastAtRef.current > TAMAGOTCHI_SPEECH_DURATION_MS * 2;
    if (tamagotchiSpeechVisible && tamagotchiSpeechTimerRef.current && !speechStale) return;
    if (speechStale) {
      tamagotchiSpeechLastAtRef.current = now;
    }
    if (!tamagotchiSpeech) {
      const nextText = getNextTamagotchiSpeech("ready");
      if (nextText) {
        tamagotchiSpeechPrimedRef.current = true;
        setTamagotchiSpeech(nextText);
      }
    } else {
      tamagotchiSpeechLastTextRef.current = tamagotchiSpeech;
      tamagotchiSpeechLastAtRef.current = now;
      tamagotchiSpeechPrimedRef.current = true;
    }
    setTamagotchiSpeechVisible(true);
    scheduleNextTamagotchiSpeech();
  }, [
    getNextTamagotchiSpeech,
    scheduleNextTamagotchiSpeech,
    speechAllowed,
    tamagotchiSpeech,
    tamagotchiSpeechWarmupVisible,
    tamagotchiSpeechVisible,
  ]);
  useEffect(() => {
    if (tamagotchiSpeechWarmupShownRef.current) return;
    tamagotchiSpeechWarmupShownRef.current = true;
    setTamagotchiSpeechWarmupVisible(true);
    const seedText = tamagotchiSpeech || peekTamagotchiSpeech("ready");
    if (seedText && !tamagotchiSpeech) {
      setTamagotchiSpeech(seedText);
    }
    if (seedText) {
      tamagotchiSpeechLastTextRef.current = seedText;
      tamagotchiSpeechLastAtRef.current = Date.now();
    }
    setTamagotchiSpeechVisible(true);
    scheduleNextTamagotchiSpeech();
  }, [
    peekTamagotchiSpeech,
    scheduleNextTamagotchiSpeech,
    speechWarmupTick,
    tamagotchiSpeech,
  ]);
  const showTamagotchiSpeech = useCallback(
    (text) => {
      if (!text) return;
      setTamagotchiSpeech(text);
      setTamagotchiSpeechVisible(true);
      scheduleNextTamagotchiSpeech();
    },
    [scheduleNextTamagotchiSpeech]
  );
  const levelProgressBaseUSD = Math.max(
    progressSavedTotalUSD || 0,
    progressLifetimeSavedUSD || 0
  );
  const levelProgressUSD = Math.max(0, levelProgressBaseUSD - levelProgressOffsetUSD);
  const heroLevelCurrency = profile?.currency || DEFAULT_PROFILE.currency;
  const tierInfo = getTierProgress(levelProgressUSD || 0, heroLevelCurrency);
  const span = Math.max(
    (tierInfo.nextTargetUSD ?? tierInfo.prevTargetUSD ?? 1) -
      (tierInfo.prevTargetUSD ?? 0),
    1
  );
  const tierProgress = tierInfo.nextTargetUSD
    ? (levelProgressUSD - tierInfo.prevTargetUSD) / span
    : 1;
  const heroLevelHasNext = !!tierInfo.nextTargetUSD;
  const heroLevelRemainingUSD = heroLevelHasNext
    ? Math.max(tierInfo.nextTargetUSD - levelProgressUSD, 0)
    : 0;
  const heroLevelRemainingRoundedUSD = roundRemainingDisplayUSD(heroLevelRemainingUSD, heroLevelCurrency);
  const heroLevelRemainingLabel = heroLevelHasNext
    ? formatCurrency(convertToCurrency(heroLevelRemainingRoundedUSD, heroLevelCurrency), heroLevelCurrency)
    : "";
  const heroLevelTargetLabel = heroLevelHasNext
    ? formatCurrency(convertToCurrency(tierInfo.nextTargetUSD, heroLevelCurrency), heroLevelCurrency, {
        friendly: true,
      })
    : "";
  const heroLevelProgress = Math.min(Math.max(tierProgress, 0), 1);
  const buildTamagotchiSpeech = useCallback(
    (reason = "unknown") => {
      const tone = tamagotchiMood?.tone || "calm";
      const foodEmoji = tamagotchiDesiredFood?.emoji || t("tamagotchiHungryBubble");
      const toyEmoji = tamagotchiDesiredToy?.emoji || "ðŸ§¶";
      const needsPlay = !!tamagotchiNeedsPlay;
      const needsCleaning = !!tamagotchiNeedsCleaning;
      const now = Date.now();
      const lastVisitAtValue =
        reason === "ready" && lastVisitAtSnapshot ? lastVisitAtSnapshot : lastVisitAt;
      const lastVisitTimestamp = Number(lastVisitAtValue) || 0;
      const todayKey = getDayKey(now);
      const greetedToday =
        (typeof tamagotchiGreetingDayKey === "string" &&
          tamagotchiGreetingDayKey === todayKey) ||
        (lastVisitTimestamp > 0 && getDayKey(lastVisitTimestamp) === todayKey);
      const minutesAway =
        lastVisitTimestamp > 0 ? Math.floor((now - lastVisitTimestamp) / (1000 * 60)) : 0;
      const daysAway =
        lastVisitTimestamp > 0 ? Math.floor((now - lastVisitTimestamp) / DAY_MS) : 0;
      const awayLong =
        lastVisitTimestamp > 0 && now - lastVisitTimestamp >= DAY_MS * 2;
      const awayShort =
        lastVisitTimestamp > 0 && now - lastVisitTimestamp < TAMAGOTCHI_GREETING_SOON_MS;
      const awayWarm =
        lastVisitTimestamp > 0 && now - lastVisitTimestamp < TAMAGOTCHI_GREETING_WARM_MS;
      const firstVisit = lastVisitTimestamp <= 0;
      const greetingReason = reason === "ready" || reason === "resume";
      const saveTitleRaw = latestSaveEvent ? resolveSpeechTitle(latestSaveEvent) : "";
      const spendTitleRaw = latestSpendEvent ? resolveSpeechTitle(latestSpendEvent) : "";
      const saveTitle = shortenSpeechTitle(saveTitleRaw);
      const spendTitle = shortenSpeechTitle(spendTitleRaw);
      const speechRecentActivity = Array.isArray(recentActivity)
        ? recentActivity.filter((entry) => !isEssentialHistoryEntry(entry))
        : [];
      const recentEntry = speechRecentActivity.length
        ? speechRecentActivity[Math.floor(Math.random() * speechRecentActivity.length)]
        : null;
      const recentTitleRaw = recentEntry ? resolveSpeechTitle(recentEntry) : "";
      const recentTitle = shortenSpeechTitle(recentTitleRaw);
      const focusTitleRaw = focusTemplateId
        ? stripEmoji(resolveTemplateTitle(focusTemplateId, ""))
        : "";
      const focusTitle = shortenSpeechTitle(focusTitleRaw);
      const recentKind = recentEntry?.kind || "";
      const recentTimestamp = Number(recentEntry?.timestamp) || 0;
      const yesterdayKey = getDayKey(now - DAY_MS);
      const saveIsYesterday =
        latestSaveEvent && getDayKey(Number(latestSaveEvent.timestamp) || 0) === yesterdayKey;
      const spendIsYesterday =
        latestSpendEvent && getDayKey(Number(latestSpendEvent.timestamp) || 0) === yesterdayKey;
      const recentIsYesterday =
        recentTimestamp && getDayKey(recentTimestamp) === yesterdayKey;
      const saveContextTitle =
        (recentKind === "refuse_spend" && recentTitle) || saveTitle;
      const spendContextTitle =
        (recentKind === "spend" && recentTitle) || spendTitle;
      const challengeTitle = activeChallenge?.title || t("defaultDealTitle");
      const challengeProgressLabel = activeChallenge?.progressLabel || "";
      const levelRemainingLabel = heroLevelHasNext ? heroLevelRemainingLabel : "";
      const levelTarget = heroLevelHasNext ? heroLevelTargetLabel : "";
      const heroLevel = tierInfo?.level || 1;

      if (greetingReason && !greetedToday) {
        if (awayLong) {
          return tone === "urgent" || tone === "sad"
            ? pickVariantText("tamagotchiSpeechMissedHungry", { food: foodEmoji })
            : pickVariantText("tamagotchiSpeechMissed", { days: daysAway });
        }
        if (firstVisit) {
          return pickVariantText("tamagotchiSpeechGreetingFirst");
        }
        if (awayShort) {
          return tone === "urgent" || tone === "sad"
            ? pickVariantText("tamagotchiSpeechGreetingHungry", { food: foodEmoji })
            : pickVariantText("tamagotchiSpeechGreetingSoon", {
                minutes: Math.max(1, minutesAway || 1),
              });
        }
        if (awayWarm) {
          return tone === "urgent" || tone === "sad"
            ? pickVariantText("tamagotchiSpeechGreetingHungry", { food: foodEmoji })
            : pickVariantText("tamagotchiSpeechGreeting");
        }
        return pickVariantText("tamagotchiSpeechGreeting");
      }

      if (reason === "level_up") {
        return pickVariantText("tamagotchiSpeechLevelUp", { level: heroLevel });
      }

      if (reason === "feed") {
        return pickVariantText("tamagotchiSpeechFed", { food: foodEmoji });
      }

      if (reason === "play") {
        return pickVariantText("tamagotchiSpeechPlayed", { toy: toyEmoji });
      }

      if (reason === "clean") {
        return pickVariantText("tamagotchiSpeechCleaned");
      }

      if (reason === "focus_set" && focusTitle) {
        return pickVariantText("tamagotchiSpeechFocusActive", { title: focusTitle });
      }

      if (reason === "challenge_progress" && activeChallenge?.status === "active") {
        if (challengeProgressLabel) {
          return pickVariantText("tamagotchiSpeechChallengeProgress", {
            title: challengeTitle,
            progress: challengeProgressLabel,
          });
        }
      }

      if (reason === "level_progress" && levelRemainingLabel) {
        return pickVariantText("tamagotchiSpeechLevelProgress", {
          amount: levelRemainingLabel,
          target: levelTarget,
        });
      }

      if (reason === "save") {
        if (activeChallenge?.status === "active" && challengeProgressLabel) {
          return pickVariantText("tamagotchiSpeechChallengeProgress", {
            title: challengeTitle,
            progress: challengeProgressLabel,
          });
        }
        if (levelRemainingLabel && Math.random() < 0.45) {
          return pickVariantText("tamagotchiSpeechLevelProgress", {
            amount: levelRemainingLabel,
            target: levelTarget,
          });
        }
        if (saveContextTitle) {
          const key = recentIsYesterday || saveIsYesterday
            ? "tamagotchiSpeechPraiseSaveYesterday"
            : "tamagotchiSpeechPraiseSaveRecent";
          return pickVariantText(key, { title: saveContextTitle });
        }
        return pickVariantText("tamagotchiSpeechSaveWin");
      }

      if (reason === "spend") {
        if (spendContextTitle) {
          if (tone === "sad" || Math.random() < 0.35) {
            return pickVariantText("tamagotchiSpeechSpendRegret", { title: spendContextTitle });
          }
          const spendKeys = recentIsYesterday || spendIsYesterday
            ? [
                "tamagotchiSpeechTrollSpendYesterday1",
                "tamagotchiSpeechTrollSpendYesterday2",
                "tamagotchiSpeechTrollSpendYesterday3",
              ]
            : [
                "tamagotchiSpeechTrollSpendRecent1",
                "tamagotchiSpeechTrollSpendRecent2",
                "tamagotchiSpeechTrollSpendRecent3",
              ];
          return pickKeyText(spendKeys, { title: spendContextTitle });
        }
        return pickVariantText("tamagotchiSpeechSpendRegretGeneric");
      }

      if (!TAMAGOTCHI_ACTION_SPEECH_REASONS.has(reason)) {
        if (needsCleaning && Math.random() < 0.95) {
          return pickVariantText("tamagotchiSpeechNeedClean");
        }
        if (needsPlay) {
          return pickVariantText("tamagotchiSpeechNeedPlay", { toy: toyEmoji });
        }
      }

      if (awayLong) {
        return tone === "urgent" || tone === "sad"
          ? pickVariantText("tamagotchiSpeechMissedHungry", { food: foodEmoji })
          : pickVariantText("tamagotchiSpeechMissed", { days: daysAway });
      }

      if (
        (tone === "urgent" || tone === "sad") &&
        !TAMAGOTCHI_ACTION_SPEECH_REASONS.has(reason)
      ) {
        return tone === "urgent"
          ? pickVariantText("tamagotchiSpeechHungry", { food: foodEmoji })
          : pickVariantText("tamagotchiSpeechHungrySoft", { food: foodEmoji });
      }

      if (Math.random() < 0.22) {
        const budgetSpeechData = resolvedBudgetSpeechDataRef?.current;
        if (budgetSpeechData?.hasIncome) {
          const {
            monthRemainingValue,
            monthRemainingLabel,
            monthOverLabel,
            monthLabel,
            overCategories = [],
            lowCategories = [],
            okCategories = [],
          } = budgetSpeechData;
          const filteredOver = overCategories.filter((entry) => !entry?.essential);
          const filteredLow = lowCategories.filter((entry) => !entry?.essential);
          const filteredOk = okCategories.filter((entry) => !entry?.essential);
          const pickFrom = (list) => list[Math.floor(Math.random() * list.length)];
          const hasMonthValue = Math.abs(monthRemainingValue || 0) > 0.01;
          if (hasMonthValue && Math.random() < 0.28) {
            if (monthRemainingValue < -0.01) {
              return pickVariantText("tamagotchiSpeechBudgetMonthOver", {
                amount: monthOverLabel,
                month: monthLabel,
              });
            }
            return pickVariantText("tamagotchiSpeechBudgetMonthRemaining", {
              amount: monthRemainingLabel,
              month: monthLabel,
            });
          }
          let bucket = null;
          if (filteredOver.length && Math.random() < 0.55) {
            bucket = filteredOver;
          } else if (filteredLow.length && Math.random() < 0.6) {
            bucket = filteredLow;
          } else if (filteredOk.length) {
            bucket = filteredOk;
          } else if (filteredLow.length) {
            bucket = filteredLow;
          } else if (filteredOver.length) {
            bucket = filteredOver;
          }
          if (bucket?.length) {
            const choice = pickFrom(bucket);
            if (choice?.essential && Math.random() < 0.35) {
              return pickVariantText("tamagotchiSpeechBudgetEssential", { category: choice.label });
            }
            if (choice?.status === "over") {
              return pickVariantText("tamagotchiSpeechBudgetCategoryOver", {
                category: choice.label,
                amount: choice.overLabel || choice.remainingLabel,
              });
            }
            if (choice?.status === "low") {
              return pickVariantText("tamagotchiSpeechBudgetCategoryLow", {
                category: choice.label,
                amount: choice.remainingLabel,
              });
            }
            return pickVariantText("tamagotchiSpeechBudgetCategoryRemaining", {
              category: choice.label,
              amount: choice.remainingLabel,
            });
          }
        }
      }

      if (focusTitle && Math.random() < 0.25) {
        return pickVariantText("tamagotchiSpeechFocus", { title: focusTitle });
      }
      if (levelRemainingLabel && Math.random() < 0.22) {
        return pickVariantText("tamagotchiSpeechLevelProgress", {
          amount: levelRemainingLabel,
          target: levelTarget,
        });
      }
      if (
        activeChallenge?.status === "active" &&
        challengeProgressLabel &&
        Math.random() < 0.2
      ) {
        return pickVariantText("tamagotchiSpeechChallengeProgress", {
          title: challengeTitle,
          progress: challengeProgressLabel,
        });
      }
      if (recentTitle && Math.random() < 0.2) {
        return pickVariantText("tamagotchiSpeechRemember", { title: recentTitle });
      }
      if (Math.random() < 0.2) {
        return pickVariantText("tamagotchiSpeechFriendly");
      }
      if (Math.random() < 0.18) {
        return pickVariantText("tamagotchiSpeechSelfCare");
      }
      if (focusTitle && Math.random() < 0.12) {
        return pickVariantText("tamagotchiSpeechFocus", { title: focusTitle });
      }

      if (tone === "urgent") {
        const spendContextTitleUrgent =
          (recentKind === "spend" && recentTitle) || spendTitle;
        if (spendContextTitleUrgent) {
          const spendKeys = recentIsYesterday || spendIsYesterday
            ? [
                "tamagotchiSpeechTrollSpendYesterday1",
                "tamagotchiSpeechTrollSpendYesterday2",
                "tamagotchiSpeechTrollSpendYesterday3",
              ]
            : [
                "tamagotchiSpeechTrollSpendRecent1",
                "tamagotchiSpeechTrollSpendRecent2",
                "tamagotchiSpeechTrollSpendRecent3",
              ];
          return pickKeyText(spendKeys, { title: spendContextTitleUrgent });
        }
        return pickVariantText("tamagotchiSpeechHungry", { food: foodEmoji });
      }

      if (tone === "sad") {
        const spendContextTitleSad =
          (recentKind === "spend" && recentTitle) || spendTitle;
        if (spendContextTitleSad && Math.random() < 0.45) {
          const spendKeys = recentIsYesterday || spendIsYesterday
            ? [
                "tamagotchiSpeechTrollSpendYesterday1",
                "tamagotchiSpeechTrollSpendYesterday2",
                "tamagotchiSpeechTrollSpendYesterday3",
              ]
            : [
                "tamagotchiSpeechTrollSpendRecent1",
                "tamagotchiSpeechTrollSpendRecent2",
                "tamagotchiSpeechTrollSpendRecent3",
              ];
          return pickKeyText(spendKeys, { title: spendContextTitleSad });
        }
        return pickVariantText("tamagotchiSpeechHungrySoft", { food: foodEmoji });
      }

      if (saveContextTitle) {
        const key = recentIsYesterday || saveIsYesterday
          ? "tamagotchiSpeechPraiseSaveYesterday"
          : "tamagotchiSpeechPraiseSaveRecent";
        return pickVariantText(key, { title: saveContextTitle });
      }

      if (activeChallenge?.status === "active") {
        const title = activeChallenge.title || t("defaultDealTitle");
        return pickVariantText("tamagotchiSpeechChallenge", { title });
      }

      if (isGoalComplete) {
        return pickVariantText("tamagotchiSpeechGoalComplete");
      }

      if (heroHasActiveGoal && heroGoalTargetUSD > 0) {
        return pickVariantText("tamagotchiSpeechGoalProgress", { amount: remainingLocal });
      }

      return pickVariantText("tamagotchiSpeechGeneral");
    },
    [
      activeChallenge,
      heroGoalTargetUSD,
      heroHasActiveGoal,
      heroLevelHasNext,
      heroLevelRemainingLabel,
      heroLevelTargetLabel,
      isGoalComplete,
      isEssentialHistoryEntry,
      lastVisitAt,
      lastVisitAtSnapshot,
      tamagotchiGreetingDayKey,
      latestSaveEvent,
      latestSpendEvent,
      recentActivity,
      pickKeyText,
      pickVariantText,
      remainingLocal,
      resolveTemplateTitle,
      resolveEventTitle,
      resolveSpeechTitle,
      stripEmoji,
      shortenSpeechTitle,
      t,
      tamagotchiDesiredFood,
      tamagotchiDesiredToy,
      tamagotchiNeedsPlay,
      tamagotchiNeedsCleaning,
      tamagotchiMood?.tone,
      focusTemplateId,
      tierInfo?.level,
    ]
  );
  const triggerTamagotchiSpeech = useCallback(
    (reason = "unknown") => {
      const now = Date.now();
      const isGreetingReason = reason === "ready" || reason === "resume";
      const todayKey = isGreetingReason ? getDayKey(now) : "";
      const greetedByKey =
        isGreetingReason &&
        typeof tamagotchiGreetingDayKey === "string" &&
        tamagotchiGreetingDayKey === todayKey;
      const greetingVisitValue =
        reason === "ready" && lastVisitAtSnapshot ? lastVisitAtSnapshot : lastVisitAt;
      const greetingVisitTimestamp = Number(greetingVisitValue) || 0;
      const greetedByVisit =
        isGreetingReason &&
        greetingVisitTimestamp > 0 &&
        getDayKey(greetingVisitTimestamp) === todayKey;
      const shouldMarkGreeting = isGreetingReason && !greetedByKey && !greetedByVisit;
      const sinceLast = now - tamagotchiSpeechLastAtRef.current;
      const isActionReason = TAMAGOTCHI_ACTION_SPEECH_REASONS.has(reason);
      const actionCooldown = reason === "feed" ? 0 : TAMAGOTCHI_SPEECH_ACTION_COOLDOWN_MS;
      if (sinceLast < TAMAGOTCHI_SPEECH_COOLDOWN_MS && reason !== "ready") {
        if (!isActionReason || sinceLast < actionCooldown) {
          return;
        }
      }
      const text = getNextTamagotchiSpeech(reason);
      if (!text) return;
      showTamagotchiSpeech(text);
      if (shouldMarkGreeting) {
        onTamagotchiGreeting(todayKey);
      }
    },
    [
      getNextTamagotchiSpeech,
      lastVisitAt,
      lastVisitAtSnapshot,
      onTamagotchiGreeting,
      showTamagotchiSpeech,
      tamagotchiGreetingDayKey,
    ]
  );
  useEffect(() => {
    if (!homeSpeechTick) return;
    const isActionReason = TAMAGOTCHI_ACTION_SPEECH_REASONS.has(homeSpeechReason);
    if (!speechAllowed && !isActionReason) return;
    triggerTamagotchiSpeech(homeSpeechReason);
  }, [homeSpeechReason, homeSpeechTick, speechAllowed, triggerTamagotchiSpeech]);
  useEffect(() => {
    if (!speechAllowed) return;
    if (tamagotchiSpeechReadyShownRef.current) return;
    if (homeSpeechTick > 0 || (tamagotchiSpeechVisible && tamagotchiSpeechTimerRef.current)) {
      tamagotchiSpeechReadyShownRef.current = true;
      return;
    }
    tamagotchiSpeechReadyShownRef.current = true;
    triggerTamagotchiSpeech("ready");
  }, [homeSpeechTick, speechAllowed, tamagotchiSpeechVisible, triggerTamagotchiSpeech]);
  const showTamagotchiBubble = !hideMascot;
  const tamagotchiBubbleTheme = useMemo(
    () =>
      isDarkMode
        ? {
            backgroundColor: "rgba(5,7,15,0.92)",
            borderColor: "rgba(255,255,255,0.25)",
            textColor: "#F7F9FF",
            shadowColor: "rgba(0,0,0,0.6)",
          }
        : {
            backgroundColor: "rgba(255,255,255,0.96)",
            borderColor: "rgba(28,26,42,0.12)",
            textColor: "#1C1A2A",
            shadowColor: "rgba(218,171,86,0.35)",
          },
    [isDarkMode]
  );
  const tamagotchiImmunityUntilTimestamp = Math.max(
    0,
    Number(tamagotchiHungerImmunityUntil) || 0
  );
  const tamagotchiImmunityMinuteNow = useMinuteTicker(tamagotchiImmunityUntilTimestamp > 0);
  const hasTamagotchiHungerImmunity =
    tamagotchiHasHungerImmunity ||
    tamagotchiImmunityUntilTimestamp > (Number(tamagotchiImmunityMinuteNow) || Date.now());
  const [immunityHintVisible, setImmunityHintVisible] = useState(false);
  const [immunityHintTarget, setImmunityHintTarget] = useState("hero");
  const [immunityHintNow, setImmunityHintNow] = useState(() => Date.now());
  const immunityHintAnim = useRef(new Animated.Value(0)).current;
  const immunityHintHideTimerRef = useRef(null);
  const immunityHintRemainingMs = Math.max(0, tamagotchiImmunityUntilTimestamp - immunityHintNow);
  const immunityHintPalette = useMemo(
    () =>
      isDarkMode
        ? {
            backgroundColor: "rgba(8,13,24,0.96)",
            borderColor: "rgba(126,178,255,0.42)",
            titleColor: "#DCEAFF",
            textColor: "#9CC4FF",
          }
        : {
            backgroundColor: "rgba(255,255,255,0.98)",
            borderColor: "rgba(62,129,255,0.3)",
            titleColor: "#244A84",
            textColor: "#2F70FF",
          },
    [isDarkMode]
  );
  const clearImmunityHintTimer = useCallback(() => {
    if (immunityHintHideTimerRef.current) {
      clearTimeout(immunityHintHideTimerRef.current);
      immunityHintHideTimerRef.current = null;
    }
  }, []);
  const hideImmunityHint = useCallback(
    (immediate = false) => {
      clearImmunityHintTimer();
      immunityHintAnim.stopAnimation();
      if (immediate) {
        immunityHintAnim.setValue(0);
        setImmunityHintVisible(false);
        return;
      }
      Animated.timing(immunityHintAnim, {
        toValue: 0,
        duration: 180,
        easing: Easing.in(Easing.quad),
        useNativeDriver: true,
      }).start(({ finished }) => {
        if (finished) {
          setImmunityHintVisible(false);
        }
      });
    },
    [clearImmunityHintTimer, immunityHintAnim]
  );
  const formatImmunityCountdown = useCallback(
    (ms) => {
      if (ms <= 0) return "00:00:00";
      const totalSeconds = Math.floor(ms / 1000);
      const days = Math.floor(totalSeconds / 86400);
      const hours = Math.floor((totalSeconds % 86400) / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      const hh = String(hours).padStart(2, "0");
      const mm = String(minutes).padStart(2, "0");
      const ss = String(seconds).padStart(2, "0");
      if (days > 0) {
        return `${days}${t("challengeTimeDayShort")} ${hh}:${mm}:${ss}`.trim();
      }
      return `${hh}:${mm}:${ss}`;
    },
    [t]
  );
  const immunityHintCountdownLabel = useMemo(
    () => formatImmunityCountdown(immunityHintRemainingMs),
    [formatImmunityCountdown, immunityHintRemainingMs]
  );
  const showImmunityHint = useCallback(
    (target = "hero") => {
      if (!hasTamagotchiHungerImmunity || !tamagotchiImmunityUntilTimestamp) return;
      triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
      setImmunityHintTarget(target);
      setImmunityHintNow(Date.now());
      setImmunityHintVisible(true);
      clearImmunityHintTimer();
      immunityHintAnim.stopAnimation();
      immunityHintAnim.setValue(0);
      Animated.spring(immunityHintAnim, {
        toValue: 1,
        tension: 180,
        friction: 16,
        useNativeDriver: true,
      }).start();
      immunityHintHideTimerRef.current = setTimeout(() => {
        hideImmunityHint();
      }, 3600);
    },
    [
      clearImmunityHintTimer,
      hasTamagotchiHungerImmunity,
      hideImmunityHint,
      immunityHintAnim,
      tamagotchiImmunityUntilTimestamp,
    ]
  );
  useEffect(() => () => clearImmunityHintTimer(), [clearImmunityHintTimer]);
  useEffect(() => {
    if (!immunityHintVisible) return;
    setImmunityHintNow(Date.now());
    const intervalId = setInterval(() => {
      setImmunityHintNow(Date.now());
    }, 1000);
    return () => clearInterval(intervalId);
  }, [immunityHintVisible]);
  useEffect(() => {
    if (!immunityHintVisible) return;
    if (immunityHintRemainingMs > 0) return;
    hideImmunityHint(true);
  }, [hideImmunityHint, immunityHintRemainingMs, immunityHintVisible]);
  const previousSavedTotal = useRef(savedTotalUSD);
  useEffect(() => {
    if (savedTotalUSD > previousSavedTotal.current) {
      logEvent("savings_updated", {
        saved_usd_total: savedTotalUSD,
        tier_level: tierInfo.level,
        next_tier_usd: tierInfo.nextTargetUSD || null,
        profile_goal: resolveProfileGoalId(profile) || "none",
      });
    }
    previousSavedTotal.current = savedTotalUSD;
  }, [savedTotalUSD, tierInfo.level, tierInfo.nextTargetUSD, profile.goal, profile.primaryGoals]);
  const progressPercent = Math.min(Math.max(goalProgress, 0), 1);
  const progressPercentLabel = Math.round(progressPercent * 100);
  const levelLabel = t("progressHeroLevel", { level: tierInfo.level });
  const usageStreakCount = Math.max(0, Number(usageStreak?.current) || 0);
  const usageStreakLostCount = Math.max(0, Number(usageStreak?.lostCount) || 0);
  const usageStreakLost = usageStreakCount === 0 && usageStreakLostCount > 0;
  const usageStreakDisplayCount = usageStreakLost ? usageStreakLostCount : usageStreakCount;
  const showUsageStreak = usageStreakDisplayCount > 0;
  const streakBadgePalette = usageStreakLost
    ? {
        bg: isDarkMode ? "rgba(255,255,255,0.08)" : "rgba(0,0,0,0.06)",
        border: isDarkMode ? "rgba(255,255,255,0.2)" : "rgba(0,0,0,0.12)",
        text: isDarkMode ? "#E5E7EB" : "#5B5B5B",
      }
    : {
        bg: isDarkMode ? "rgba(255,170,90,0.2)" : "rgba(255,168,90,0.28)",
        border: isDarkMode ? "rgba(255,206,150,0.55)" : "rgba(255,162,92,0.6)",
        text: isDarkMode ? "#FFD7A1" : "#7A2E00",
      };
  const handleUsageStreakPress = useCallback(() => {
    if (!showUsageStreak) return;
    if (typeof onUsageStreakPress !== "function") return;
    const now = Date.now();
    const todayKey = getDayKey(now);
    const resolvedDayKey =
      typeof usageStreak?.lastDate === "string" && usageStreak.lastDate
        ? usageStreak.lastDate
        : todayKey;
    const missedDays = usageStreakLost
      ? getMissedUsageStreakDays(resolvedDayKey, todayKey)
      : 0;
    const missedDayKey = usageStreakLost
      ? getDayKey((parseDayKey(resolvedDayKey)?.getTime() || now) + DAY_MS)
      : null;
    onUsageStreakPress({
      count: Math.max(1, Number(usageStreakDisplayCount) || 1),
      dayKey: resolvedDayKey,
      streakEndDayKey: resolvedDayKey,
      timestamp: now,
      missed: usageStreakLost,
      previousCount: usageStreakLost ? usageStreakLostCount : usageStreakCount,
      missedDayKey,
      missedDays,
      lostCount: usageStreakLostCount,
    });
  }, [
    onUsageStreakPress,
    showUsageStreak,
    usageStreak,
    usageStreakCount,
    usageStreakDisplayCount,
    usageStreakLost,
    usageStreakLostCount,
  ]);
  const levelCurrency = profile?.currency || DEFAULT_PROFILE.currency;
  const levelProgress = Math.min(Math.max(tierProgress, 0), 1);
  const levelRemainingUSD = tierInfo.nextTargetUSD
    ? Math.max(tierInfo.nextTargetUSD - levelProgressUSD, 0)
    : 0;
  const levelRemainingRoundedUSD = roundRemainingDisplayUSD(levelRemainingUSD, levelCurrency);
  const levelRemainingLabel = formatCurrency(
    convertToCurrency(levelRemainingRoundedUSD, levelCurrency),
    levelCurrency
  );
  const levelTargetLabel = tierInfo.nextTargetUSD
    ? formatCurrency(convertToCurrency(tierInfo.nextTargetUSD, levelCurrency), levelCurrency, {
        friendly: true,
      })
    : "";
  const todayDate = new Date();
  const todayTimestamp = todayDate.getTime();
  const baselineMonthlyWasteUSD = Math.max(
    0,
    Number(profile?.spendingProfile?.baselineMonthlyWasteUSD) || 0
  );
  const baselineStartAt = profile?.spendingProfile?.baselineStartAt || null;
  const hasBaseline = !!(
    baselineMonthlyWasteUSD && baselineStartAt
  );
  const handlePotentialDetailsOpen = useCallback(() => {
    if (typeof onPotentialDetailsOpen === "function") {
      const currencyCode = profile?.currency || DEFAULT_PROFILE.currency;
      const formatLocal = (valueUSD = 0) =>
        formatCurrency(convertToCurrency(Math.max(valueUSD, 0), currencyCode), currencyCode, {
          precisionOverride: getCurrencyPrecision(currencyCode),
        });
      const potentialSavedUSD = calcPotentialSaved(baselineMonthlyWasteUSD, baselineStartAt);
      const potentialLocal = formatLocal(potentialSavedUSD);
      const actualLocal = formatLocal(realSavedUSD);
      const deltaLocal = formatLocal(Math.max(potentialSavedUSD - realSavedUSD, 0));
      onPotentialDetailsOpen(
        t("potentialBlockDetails", {
          potential: potentialLocal,
          actual: actualLocal,
          delta: deltaLocal,
        })
      );
    }
  }, [baselineMonthlyWasteUSD, baselineStartAt, onPotentialDetailsOpen, profile?.currency, realSavedUSD, t]);

  const formatLocalAmount = useCallback(
    (valueUSD = 0) => formatCurrency(convertToCurrency(valueUSD || 0, currency), currency),
    [currency]
  );
  const resolveHistoryCategoryId = useCallback(
    (entry) => {
      const metaCategory =
        entry?.meta?.category || entry?.meta?.impulseCategory || entry?.meta?.impulseCategoryOverride;
      if (metaCategory && IMPULSE_CATEGORY_DEFS[metaCategory]) return metaCategory;
      const templateId = entry?.meta?.templateId;
      if (!templateId || typeof resolveTemplateCard !== "function" || typeof resolveTemptationCategory !== "function") {
        return DEFAULT_IMPULSE_CATEGORY;
      }
      const template = resolveTemplateCard(templateId);
      if (!template) return DEFAULT_IMPULSE_CATEGORY;
      return resolveTemptationCategory(template);
    },
    [resolveTemplateCard, resolveTemptationCategory]
  );
  const budgetMonthKey = getMonthKey(todayTimestamp);
  const monthlyIncomeUSD = useMemo(
    () => getBudgetIncomeForMonth(incomeEntries, budgetMonthKey),
    [incomeEntries, budgetMonthKey]
  );
  const budgetSpendDistribution = useMemo(() => {
    const cutoff = Date.now() - DAY_MS * 30;
    const map = {};
    resolvedHistoryEvents.forEach((entry) => {
      if (!entry || entry.kind !== "spend") return;
      if (!entry.timestamp || entry.timestamp < cutoff) return;
      const impulseCategory = resolveHistoryCategoryId(entry);
      const amount = Math.max(0, Number(entry?.meta?.amountUSD) || 0);
      if (!amount) return;
      map[impulseCategory] = (map[impulseCategory] || 0) + amount;
    });
    return map;
  }, [resolvedHistoryEvents, resolveHistoryCategoryId]);
  const budgetMonthSpend = useMemo(() => {
    const map = {};
    let total = 0;
    resolvedHistoryEvents.forEach((entry) => {
      if (!entry || entry.kind !== "spend") return;
      if (!entry.timestamp) return;
      if (getMonthKey(entry.timestamp) !== budgetMonthKey) return;
      const impulseCategory = resolveHistoryCategoryId(entry);
      const amount = Math.max(0, Number(entry?.meta?.amountUSD) || 0);
      if (!amount) return;
      map[impulseCategory] = (map[impulseCategory] || 0) + amount;
      total += amount;
    });
    return { map, total };
  }, [resolvedHistoryEvents, resolveHistoryCategoryId, budgetMonthKey]);
  const budgetMonthSpendTotals = useMemo(() => {
    const totals = {};
    resolvedHistoryEvents.forEach((entry) => {
      if (!entry || entry.kind !== "spend") return;
      const timestamp = Number(entry?.timestamp) || 0;
      if (!timestamp) return;
      const monthKey = getMonthKey(timestamp);
      if (!monthKey) return;
      const amount = Math.max(0, Number(entry?.meta?.amountUSD) || 0);
      if (!amount) return;
      totals[monthKey] = (totals[monthKey] || 0) + amount;
    });
    return totals;
  }, [resolvedHistoryEvents]);
  const budgetCarryoverUSD = useMemo(() => {
    if (!budgetMonthKey) return 0;
    const monthKeys = collectBudgetMonthKeys(incomeEntries, resolvedHistoryEvents, budgetMonthKey);
    if (!monthKeys.length) return 0;
    const sortedAsc = [...monthKeys].sort();
    let running = 0;
    sortedAsc.forEach((monthKey) => {
      if (monthKey >= budgetMonthKey) return;
      const incomeUSD = getBudgetIncomeForMonth(incomeEntries, monthKey);
      const spendUSD = Math.max(0, Number(budgetMonthSpendTotals[monthKey]) || 0);
      running += incomeUSD - spendUSD;
    });
    return running;
  }, [budgetMonthKey, budgetMonthSpendTotals, incomeEntries, resolvedHistoryEvents]);
  const budgetPlan = useMemo(
    () =>
      buildBudgetPlan({
        incomeUSD: monthlyIncomeUSD,
        carryoverUSD: budgetCarryoverUSD,
        budgetOverrides,
        spendDistribution: budgetSpendDistribution,
        spendToDateByCategory: budgetMonthSpend.map,
        spendToDateTotalUSD: budgetMonthSpend.total,
        decisionStats,
        baselineMonthlyWasteUSD,
        language,
        monthKey: budgetMonthKey,
        autoAllocationEnabled: budgetAutoEnabled,
      }),
    [
      baselineMonthlyWasteUSD,
      budgetCarryoverUSD,
      budgetOverrides,
      budgetSpendDistribution,
      budgetMonthSpend,
      customCategories,
      decisionStats,
      language,
      monthlyIncomeUSD,
      budgetAutoEnabled,
    ]
  );
  const budgetDisplayCategories = useMemo(
    () => (budgetPlan?.categories || []).filter((entry) => entry.id !== "savings"),
    [budgetPlan?.categories]
  );
  const budgetWidgetCategories = useMemo(() => {
    const list = [...budgetDisplayCategories];
    if (list.length < 2) return list;
    const locale = getFormatLocale(language);
    const baseSorted = list.sort((a, b) => {
      const aSpent = Number(a?.spentUSD) || 0;
      const bSpent = Number(b?.spentUSD) || 0;
      if (bSpent !== aSpent) return bSpent - aSpent;
      const aLimit = Number(a?.limitUSD) || 0;
      const bLimit = Number(b?.limitUSD) || 0;
      if (bLimit !== aLimit) return bLimit - aLimit;
      const aLabel = a?.label || "";
      const bLabel = b?.label || "";
      return aLabel.localeCompare(bLabel, locale, { sensitivity: "base" });
    });
    const enriched = baseSorted.map((entry, index) => {
      const limit = Number(entry?.limitUSD) || 0;
      const spent = Number(entry?.spentUSD) || 0;
      const ratio = limit > 0 ? spent / limit : spent > 0 ? 1.5 : 0;
      return { entry, index, ratio };
    });
    const hasProgress = enriched.some((item) => item.ratio > 0);
    if (!hasProgress) return baseSorted;
    enriched.sort((a, b) => {
      if (b.ratio !== a.ratio) return b.ratio - a.ratio;
      return a.index - b.index;
    });
    return enriched.map((item) => item.entry);
  }, [budgetDisplayCategories, language]);
  const budgetHeroCategories = useMemo(
    () => budgetWidgetCategories.slice(0, 3),
    [budgetWidgetCategories]
  );
  const budgetHasIncome = (budgetPlan?.incomeUSD || 0) > 0;
  const budgetRemainingLabel = useMemo(
    () => formatLocalAmount(Math.abs(budgetPlan?.remainingUSD || 0)),
    [budgetPlan?.remainingUSD, formatLocalAmount]
  );
  const budgetRemainingNegative = (budgetPlan?.remainingUSD || 0) < -0.01;
  const daysInMonth = useMemo(() => {
    const date = new Date(todayTimestamp);
    if (Number.isNaN(date.getTime())) return 30;
    return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
  }, [todayTimestamp]);
  const dayOfMonth = useMemo(() => {
    const date = new Date(todayTimestamp);
    if (Number.isNaN(date.getTime())) return 1;
    return Math.max(1, date.getDate());
  }, [todayTimestamp]);
  const daysRemaining = useMemo(
    () => Math.max(1, Math.max(daysInMonth, 1) - dayOfMonth + 1),
    [dayOfMonth, daysInMonth]
  );
  const dailyGoalStats = useMemo(() => {
    const monthKey = budgetMonthKey;
    const todayKey = getDayKey(todayTimestamp);
    const cutoff30 = todayTimestamp - DAY_MS * 30;
    const cutoff7 = todayTimestamp - DAY_MS * 7;
    let savedMonth = 0;
    let saved30 = 0;
    let saved7 = 0;
    let savedToday = 0;
    let savedCardCountToday = 0;
    let savedCardCountTotal = 0;
    resolvedHistoryEvents.forEach((entry) => {
      if (!entry || !HISTORY_SAVED_GAIN_EVENTS.has(entry.kind)) return;
      const timestamp = Number(entry.timestamp) || 0;
      if (!timestamp) return;
      if (getDayKey(timestamp) === todayKey) {
        if (DAILY_GOAL_COIN_EVENTS.has(entry.kind)) {
          savedCardCountToday += 1;
        }
      }
      if (DAILY_GOAL_COIN_EVENTS.has(entry.kind)) {
        savedCardCountTotal += 1;
      }
      const amount = Math.max(0, Number(entry?.meta?.amountUSD) || 0);
      if (!amount) return;
      if (getMonthKey(timestamp) === monthKey) savedMonth += amount;
      if (timestamp >= cutoff30) saved30 += amount;
      if (timestamp >= cutoff7) saved7 += amount;
      if (getDayKey(timestamp) === todayKey) {
        savedToday += amount;
      }
    });
    return {
      savedMonth,
      saved30,
      saved7,
      savedToday,
      savedCardCountToday,
      savedCardCountTotal,
    };
  }, [budgetMonthKey, resolvedHistoryEvents, todayTimestamp]);
  const baselineDailyPotentialUSD = baselineMonthlyWasteUSD > 0 ? baselineMonthlyWasteUSD / 30 : 0;
  const recentDailyAvgUSD = dailyGoalStats.saved7 / 7;
  const budgetMonthlyGoalUSD =
    Number.isFinite(budgetPlan?.incomeUSD) && Number.isFinite(budgetPlan?.savingsRate)
      ? Math.max(0, budgetPlan.incomeUSD * budgetPlan.savingsRate)
      : 0;
  const monthlyTargetUSD = Math.max(
    budgetMonthlyGoalUSD,
    baselineMonthlyWasteUSD > 0 ? baselineMonthlyWasteUSD * 0.6 : 0,
    dailyGoalStats.saved30 > 0 ? dailyGoalStats.saved30 * 1.15 : 0,
    baselineDailyPotentialUSD * Math.max(daysInMonth, 1) * 0.35
  );
  const remainingTargetUSD = Math.max(monthlyTargetUSD - dailyGoalStats.savedMonth, 0);
  const rawDailyGoalUSD = remainingTargetUSD / daysRemaining;
  const weekdayBoost = DAILY_GOAL_WEEKDAY_BOOST[new Date(todayTimestamp).getDay() || 0] || 1;
  const momentumBoost =
    rawDailyGoalUSD > 0 && recentDailyAvgUSD > 0
      ? clampNumber(0.9 + (recentDailyAvgUSD / rawDailyGoalUSD - 1) * 0.15, 0.85, 1.15)
      : 1;
  const joinedAtTimestamp = profile?.joinedAt ? new Date(profile.joinedAt).getTime() : NaN;
  const lifetimeDays = Number.isFinite(joinedAtTimestamp)
    ? Math.max(1, Math.floor((todayTimestamp - joinedAtTimestamp) / DAY_MS) + 1)
    : 1;
  const lifetimeDailyAvgUSD =
    Number.isFinite(savedTotalUSD) && lifetimeDays > 0 ? savedTotalUSD / lifetimeDays : 0;
  const dailyGoalUSD = Math.max(
    0,
    Math.max(
      rawDailyGoalUSD * weekdayBoost * momentumBoost,
      baselineDailyPotentialUSD * 0.35,
      recentDailyAvgUSD * 0.4,
      lifetimeDailyAvgUSD * 0.5
    ) * 0.4
  );
  const todaySavedUSD = dailyGoalStats.savedToday;
  const todaySavedCardCount = dailyGoalStats.savedCardCountToday;
  const dailyGoalRemainingUSD = Math.max(dailyGoalUSD - todaySavedUSD, 0);
  const dailyGoalLabel = useMemo(
    () => formatLocalAmount(Math.max(dailyGoalRemainingUSD, 0)),
    [dailyGoalRemainingUSD, formatLocalAmount]
  );
  useEffect(() => {
    if (!resolvedBudgetSpeechDataRef) {
      return;
    }
    if (!budgetHasIncome) {
      resolvedBudgetSpeechDataRef.current = null;
      return;
    }
    const entries = (budgetPlan?.categories || [])
      .filter((entry) => entry.id !== "savings" && (Number(entry.limitUSD) || 0) > 0)
      .map((entry) => {
        const limit = Number(entry.limitUSD) || 0;
        const spent = Number(entry.spentUSD) || 0;
        const remaining = limit - spent;
        const over = remaining < -0.01;
        const low = !over && limit > 0 && remaining / limit <= BUDGET_SPEECH_LOW_THRESHOLD;
        return {
          id: entry.id,
          label: entry.label || getBudgetCategoryLabel(entry.id, language),
          remainingValue: remaining,
          remainingLabel: formatLocalAmount(Math.max(0, remaining)),
          overLabel: over ? formatLocalAmount(Math.abs(remaining)) : "",
          status: over ? "over" : low ? "low" : "ok",
          essential: BUDGET_SPEECH_ESSENTIAL_IDS.has(entry.id),
        };
      })
      .filter((entry) => entry.label);
    if (!entries.length) {
      resolvedBudgetSpeechDataRef.current = null;
      return;
    }
    const monthRemainingValue = Number(budgetPlan?.remainingUSD) || 0;
    resolvedBudgetSpeechDataRef.current = {
      hasIncome: true,
      monthRemainingValue,
      monthRemainingLabel: formatLocalAmount(Math.max(0, monthRemainingValue)),
      monthOverLabel: formatLocalAmount(Math.abs(Math.min(0, monthRemainingValue))),
      monthLabel: budgetPlan?.monthLabel || "",
      overCategories: entries.filter((entry) => entry.status === "over"),
      lowCategories: entries.filter((entry) => entry.status === "low"),
      okCategories: entries.filter((entry) => entry.status === "ok"),
    };
  }, [budgetHasIncome, budgetPlan, formatLocalAmount, language, resolvedBudgetSpeechDataRef]);

  const orderedProducts = useMemo(() => {
    const entries = Array.isArray(products) ? [...products] : [];
    if (!entries.length) return entries;
    const shuffleSeed = feedShuffleSeedRef.current;
    const enrichedEntries = entries.map((item, index) => {
      const stats = getInteractionEntry(item);
      const key = item?.id || item?.templateId || `item-${index}`;
      const total = (stats?.saveCount || 0) + (stats?.spendCount || 0);
      const lastInteractionAt = Number(stats?.lastInteractionAt) || 0;
      const price = getTemptationPrice(item);
      return {
        item,
        key,
        total,
        lastInteractionAt,
        price,
        shuffle: getSessionShuffleValue(shuffleSeed, key),
      };
    });
    const freshEntries = enrichedEntries
      .filter((entry) => {
        if (!entry?.item) return false;
        if (!entry.item.quickTemptation && !isCustomTemptation(entry.item)) return false;
        const createdAt = Number(entry.item?.createdAt);
        if (!Number.isFinite(createdAt) || createdAt <= 0) return false;
        return entry.total <= 0 && entry.lastInteractionAt <= 0;
      })
      .sort((a, b) => Number(b.item?.createdAt || 0) - Number(a.item?.createdAt || 0));
    const freshKeys = new Set(freshEntries.map((entry) => entry.key));
    const recentEntries = enrichedEntries
      .filter((entry) => entry.lastInteractionAt > 0)
      .sort((a, b) => b.lastInteractionAt - a.lastInteractionAt)
      .slice(0, 3);
    const recentKeys = new Set(recentEntries.map((entry) => entry.key));
    const popularEntries = enrichedEntries
      .filter((entry) => entry.total > 0)
      .sort((a, b) => {
        if (b.total !== a.total) return b.total - a.total;
        if (b.lastInteractionAt !== a.lastInteractionAt) {
          return b.lastInteractionAt - a.lastInteractionAt;
        }
        return a.price - b.price;
      })
      .slice(0, FEED_FREQUENT_PIN_LIMIT);
    const averagePopularPrice = popularEntries.length
      ? popularEntries.reduce((sum, entry) => sum + entry.price, 0) / popularEntries.length
      : null;
    const popularPriceCap = Number.isFinite(averagePopularPrice)
      ? averagePopularPrice * 1.3
      : Number.POSITIVE_INFINITY;
    const affordableEntries = [];
    const premiumEntries = [];
    enrichedEntries.forEach((entry) => {
      if (freshKeys.has(entry.key)) return;
      if (recentKeys.has(entry.key)) return;
      if (entry.price <= popularPriceCap) {
        affordableEntries.push(entry);
      } else {
        premiumEntries.push(entry);
      }
    });
    const priceSort = (a, b) => {
      const priceDiff = a.price - b.price;
      if (priceDiff !== 0) return priceDiff;
      if (a.shuffle !== b.shuffle) return a.shuffle - b.shuffle;
      return a.key.localeCompare(b.key);
    };
    affordableEntries.sort(priceSort);
    premiumEntries.sort(priceSort);
    return [...freshEntries, ...recentEntries, ...affordableEntries, ...premiumEntries].map(
      (entry) => entry.item
    );
  }, [products, getInteractionEntry]);

  const filteredProducts = orderedProducts;
  const feedEntries = useMemo(() => {
    return filteredProducts.map((item, index) => {
      const key = item?.id || item?.templateId || `item-${index}`;
      return {
        type: "card",
        id: `card-${key}`,
        item,
        interaction: getInteractionEntry(item),
      };
    });
  }, [filteredProducts, getInteractionEntry]);
  const archiveEntries = useMemo(() => {
    const entries = Array.isArray(archivedItems) ? archivedItems : [];
    return entries
      .map((item, index) => {
        if (!item) return null;
        const key = item?.id || item?.templateId || `archive-${index}`;
        return {
          type: "archive",
          id: `archive-${key}`,
          item,
          interaction: getInteractionEntry(item),
        };
      })
      .filter(Boolean);
  }, [archivedItems, getInteractionEntry]);
  const firstVisibleTemptationId = useMemo(() => {
    const firstCard = feedEntries.find(
      (entry) => entry?.type === "card" && entry.item?.id
    );
    return firstCard?.item?.id || null;
  }, [feedEntries]);
  const tutorialHighlightTemptationId = tutorialTemptationStepId
    ? firstVisibleTemptationId || filteredProducts[0]?.id || orderedProducts[0]?.id || null
    : null;
  const feedKeyExtractor = useCallback((entry) => entry.id, []);
  const [archiveExpanded, setArchiveExpanded] = useState(false);
  const archiveCount = archiveEntries.length;
  const toggleArchiveExpanded = useCallback(() => {
    runLayoutAnimation();
    setArchiveExpanded((prev) => !prev);
  }, []);
  const feedEmptyEntry = useMemo(() => ({ type: "feed_empty", id: "feed-empty" }), []);
  const archiveHeaderEntry = useMemo(
    () => ({ type: "archive_header", id: "archive-header" }),
    []
  );
  const feedData = useMemo(() => {
    const data = [];
    if (feedEntries.length) {
      data.push(...feedEntries);
    } else {
      data.push(feedEmptyEntry);
    }
    data.push(archiveHeaderEntry);
    if (archiveExpanded && archiveCount > 0) {
      data.push(...archiveEntries);
    }
    return data;
  }, [
    archiveCount,
    archiveEntries,
    archiveExpanded,
    archiveHeaderEntry,
    feedEmptyEntry,
    feedEntries,
  ]);
  const resolveAssignedGoalLabel = useCallback(
    (goalId, assignedGoal) => {
      if (assignedGoal) return getWishTitleWithoutEmoji(assignedGoal);
      if (!goalId || typeof goalId !== "string") return null;
      if (!goalId.startsWith("wish_primary_goal_")) return null;
      const primaryGoalId = goalId.replace("wish_primary_goal_", "");
      if (!primaryGoalId) return null;
      const primaryEntry = Array.isArray(profile.primaryGoals)
        ? profile.primaryGoals.find((goal) => goal?.id === primaryGoalId)
        : null;
      const customTitle =
        typeof primaryEntry?.customTitle === "string" ? primaryEntry.customTitle.trim() : "";
      const preset = getGoalPreset(primaryGoalId);
      return customTitle || preset?.[language] || preset?.en || primaryGoalId;
    },
    [language, profile.primaryGoals]
  );
  const renderTemptationCard = useCallback(
    (entry, { archived = false } = {}) => {
      const item = entry.item;
      const interactionEntry = entry.interaction;
      const interactionRefreshKey = interactionEntry
        ? `${interactionEntry.lastInteractionAt || 0}:${interactionEntry.lastTimerResetAt || 0}:${interactionEntry.nextCheckAt || 0}`
        : "0";
      const templateKey =
        getInteractionKey(item?.templateId) || getInteractionKey(item?.id) || item?.id;
      const focusTargetKey =
        typeof focusTemplateId === "string" && focusTemplateId.trim()
          ? focusTemplateId.trim()
          : focusTemplateId;
      const isFocusTargetMatch =
        !!focusTargetKey && (templateKey === focusTargetKey || item?.id === focusTargetKey);
      const assignedGoalId = goalAssignments?.[templateKey] || goalAssignments?.[item.id];
      const assignedGoal = assignedGoalId ? wishesById[assignedGoalId] : null;
      const resolvedGoalLabel = resolveAssignedGoalLabel(assignedGoalId, assignedGoal);
      const wishlistEntry = swipePinnedByTemplate[item.id];
      const isWishlistGoal = !!wishlistEntry;
      const overrideDescription =
        (descriptionOverrides && descriptionOverrides[item.id]) || null;
      const resolvedDescriptionOverride =
        overrideDescription ||
        (item.id === mainTemptationId ? primaryTemptationDescription : null);
      const statsEntry = resolveCardRefuseStats(item);
      const isTutorialHighlightTarget = tutorialHighlightTemptationId === item.id;
      let budgetStatus = null;
      let budgetAlertText = null;
      const budgetSpeechData = resolvedBudgetSpeechDataRef?.current;
      if (budgetSpeechData?.hasIncome && typeof resolveTemptationCategory === "function") {
        const categoryId = resolveTemptationCategory(item);
        const overEntry = budgetSpeechData?.overCategories?.find((entry) => entry?.id === categoryId);
        const lowEntry = budgetSpeechData?.lowCategories?.find((entry) => entry?.id === categoryId);
        const categoryLabel =
          overEntry?.label ||
          lowEntry?.label ||
          getBudgetCategoryLabel(categoryId || DEFAULT_IMPULSE_CATEGORY, language);
        if (overEntry) {
          budgetStatus = "over";
          budgetAlertText = t("budgetCardLimitOver", { category: categoryLabel });
        } else if (lowEntry) {
          budgetStatus = "low";
          budgetAlertText = t("budgetCardLimitLow", {
            category: categoryLabel,
            amount: lowEntry?.remainingLabel || "",
          });
        }
      }
      return (
        <TemptationCard
          item={item}
          language={language}
          colors={colors}
          t={t}
          allowThinkAction={allowThinkAction}
          descriptionOverride={resolvedDescriptionOverride}
          isFocusTarget={isFocusTargetMatch}
          onToggleEdit={() => onTemptationEditToggle?.(item)}
          currency={currency}
          stats={statsEntry}
          feedback={cardFeedback[item.id]}
          titleOverride={titleOverrides[item.id]}
          goalLabel={resolvedGoalLabel}
          isWishlistGoal={isWishlistGoal}
          isArchived={archived}
          isEditing={editingTemptationId === item.id}
          editTitleValue={editingTemptationId === item.id ? editingTitleValue : ""}
          editPriceValue={editingTemptationId === item.id ? editingPriceValue : ""}
          editGoalLabel={editingTemptationId === item.id ? editingGoalLabel : ""}
          editEmojiValue={editingTemptationId === item.id ? editingEmojiValue : ""}
          editDescriptionValue={editingTemptationId === item.id ? editingDescriptionValue : ""}
          editCategoryValue={
            editingTemptationId === item.id ? editingCategoryValue : DEFAULT_IMPULSE_CATEGORY
          }
          onEditTitleChange={onTemptationEditTitleChange}
          onEditPriceChange={onTemptationEditPriceChange}
          onEditEmojiChange={onTemptationEditEmojiChange}
          onEditDescriptionChange={onTemptationEditDescriptionChange}
          onEditCategoryChange={onTemptationEditCategoryChange}
          onEditSave={onTemptationEditSave}
          onEditCancel={onTemptationEditCancel}
          onEditDelete={() => onTemptationEditDelete?.(item)}
          onEditGoalSelect={() => onTemptationGoalSelect?.(item)}
          onSwipeDelete={() => onTemptationSwipeDelete?.(item)}
          onSwipeArchive={() => onTemptationArchiveToggle?.(item)}
          isPrimaryTemptation={item.id === mainTemptationId}
          onAction={async (type, _, actionOptions) => {
            await onTemptationAction(type, item, actionOptions);
          }}
          playSound={playSound}
          onAmountSliderToggle={handleAmountSliderToggle}
          onFocusBadgePress={onFocusCancel}
          tutorialHighlightMode={isTutorialHighlightTarget ? tutorialTemptationStepId : null}
          tutorialHighlightMeasureTick={
            isTutorialHighlightTarget ? tutorialHighlightMeasureTick : 0
          }
          tutorialHighlightOffset={tutorialHighlightOffset}
          onTutorialHighlightLayoutChange={
            isTutorialHighlightTarget ? onTutorialHighlightLayoutChange : null
          }
          interaction={interactionEntry}
          interactionRefreshKey={interactionRefreshKey}
          budgetStatus={budgetStatus}
          budgetAlertText={budgetAlertText}
        />
      );
    },
    [
      resolvedBudgetSpeechDataRef,
      cardFeedback,
      colors,
      currency,
      descriptionOverrides,
      editingCategoryValue,
      editingDescriptionValue,
      editingEmojiValue,
      editingGoalLabel,
      editingPriceValue,
      editingTemptationId,
      editingTitleValue,
      focusTemplateId,
      getInteractionKey,
      goalAssignments,
      handleAmountSliderToggle,
      language,
      mainTemptationId,
      onTemptationAction,
      onTemptationEditCancel,
      onTemptationEditDelete,
      onTemptationEditDescriptionChange,
      onTemptationEditEmojiChange,
      onTemptationEditPriceChange,
      onTemptationEditSave,
      onTemptationEditTitleChange,
      onTemptationEditToggle,
      onTemptationGoalSelect,
      onTemptationArchiveToggle,
      onTemptationSwipeDelete,
      onFocusCancel,
      playSound,
      primaryTemptationDescription,
      resolveCardRefuseStats,
      resolveTemptationCategory,
      swipePinnedByTemplate,
      t,
      titleOverrides,
      tutorialHighlightMeasureTick,
      tutorialHighlightOffset,
      resolveAssignedGoalLabel,
      wishesById,
      tutorialHighlightTemptationId,
      tutorialTemptationStepId,
      onTutorialHighlightLayoutChange,
    ]
  );
  const renderFeedItem = useCallback(
    ({ item: entry }) => {
      if (entry.type === "card") {
        return renderTemptationCard(entry);
      }
      if (entry.type === "archive") {
        return renderTemptationCard(entry, { archived: true });
      }
      if (entry.type === "archive_header") {
        return (
          <View style={styles.archiveSection}>
            <FrequencySectionHeader
              title={t("archiveSectionTitle")}
              count={String(archiveCount)}
              collapsed={!archiveExpanded}
              onToggle={toggleArchiveExpanded}
              colors={colors}
              t={t}
            />
            {archiveExpanded && archiveCount === 0 ? (
              <Text style={[styles.archiveEmptyText, { color: colors.muted }]}>
                {t("archiveEmpty")}
              </Text>
            ) : null}
          </View>
        );
      }
      if (entry.type === "feed_empty") {
        return (
          <View style={styles.emptyState}>
            <Text style={[styles.emptyStateTitle, { color: colors.text }]}>
              {t("feedEmptyTitle")}
            </Text>
            <Text style={[styles.emptyStateText, { color: colors.muted }]}>
              {t("feedEmptySubtitle")}
            </Text>
          </View>
        );
      }
      return null;
    },
    [archiveCount, archiveExpanded, colors, renderTemptationCard, t, toggleArchiveExpanded]
  );
  const analyticsPreview = analyticsStats.slice(0, 3);
  const { wishesById, swipePinnedByTemplate } = useMemo(() => {
    const byId = {};
    const swipePinned = {};
    (wishes || []).forEach((wish) => {
      if (wish?.id) {
        byId[wish.id] = wish;
      }
      if (wish?.templateId && wish?.pinnedSource === "swipe") {
        swipePinned[wish.templateId] = wish;
      }
    });
    return { wishesById: byId, swipePinnedByTemplate: swipePinned };
  }, [wishes]);

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: colors.background }] }>
      <FlatList
        ref={listRef}
        style={styles.feedList}
        data={feedData}
        keyExtractor={feedKeyExtractor}
        showsVerticalScrollIndicator={false}
        scrollEnabled={!feedScrollLocked}
        contentContainerStyle={styles.feedListContent}
        renderItem={renderFeedItem}
        initialNumToRender={6}
        maxToRenderPerBatch={6}
        windowSize={7}
        updateCellsBatchingPeriod={50}
        removeClippedSubviews={Platform.OS === "android"}
        scrollEventThrottle={16}
        onScrollBeginDrag={handleFeedScrollBegin}
        onScrollEndDrag={handleFeedScrollEnd}
        onMomentumScrollBegin={handleFeedMomentumBegin}
        onMomentumScrollEnd={handleFeedMomentumEnd}
        ListHeaderComponent={
          <View style={styles.feedHero} onLayout={handleHeroLayout}>
            <View style={styles.feedHeroTop}>
              <MoodGradientBlock colors={moodGradient} style={styles.heroMoodGradient}>
                <View
                  style={styles.heroMascotRow}
                  onLayout={(event) => setHeroRowWidth(event.nativeEvent.layout.width)}
                >
                  <View style={styles.heroTextWrap}>
                    <View style={styles.heroTitleRow}>
                      <Text
                        style={[styles.appName, { color: colors.text }]}
                        onLayout={(event) => {
                          const { x, width } = event.nativeEvent.layout;
                          setHeroLogoRight(x + width);
                        }}
                      >
                        Almost
                      </Text>
                      {isPremiumUser && (
                        <View
                          style={[
                            styles.heroProBadge,
                            {
                              backgroundColor: heroProBadgePalette.background,
                              borderColor: heroProBadgePalette.border,
                            },
                          ]}
                        >
                          <Text style={[styles.heroProBadgeText, { color: heroProBadgePalette.text }]}>PRO</Text>
                        </View>
                      )}
                    </View>
                    <Text style={[styles.heroTagline, { color: colors.muted }]}>
                      {t("appTagline")}
                    </Text>
                    <View style={styles.heroBadgeRow}>
                      <TouchableOpacity
                        style={[
                          styles.heroLevelBadge,
                          {
                            backgroundColor: goldPalette.badgeBg,
                            borderColor: goldPalette.badgeBorder,
                          },
                        ]}
                        onPress={toggleHeroLevelExpanded}
                        activeOpacity={0.85}
                      >
                        <Text style={[styles.heroLevelBadgeText, { color: goldPalette.badgeText }]}>
                          {levelLabel}
                        </Text>
                      </TouchableOpacity>
                      {showUsageStreak && (
                        <TouchableOpacity
                          style={[
                            styles.heroStreakBadge,
                            {
                              backgroundColor: streakBadgePalette.bg,
                              borderColor: streakBadgePalette.border,
                            },
                          ]}
                          onPress={handleUsageStreakPress}
                          activeOpacity={0.85}
                        >
                          <Text
                            style={[
                              styles.heroStreakEmoji,
                              usageStreakLost && styles.heroStreakEmojiLost,
                            ]}
                          >
                            ðŸ”¥
                          </Text>
                          <Text
                            style={[
                              styles.heroStreakBadgeText,
                              { color: streakBadgePalette.text },
                            ]}
                          >
                            {usageStreakDisplayCount}
                          </Text>
                        </TouchableOpacity>
                      )}
                    </View>
                  </View>
                  {!hideMascot && (
                    <View style={styles.heroMascotContainer}>
                      {showTamagotchiBubble && (
                        <View pointerEvents="none" style={styles.mascotBubbleWrap}>
                          <View
                            style={[
                              styles.mascotBubble,
                              {
                                maxWidth: heroBubbleMaxWidth,
                                backgroundColor: tamagotchiBubbleTheme.backgroundColor,
                                borderColor: tamagotchiBubbleTheme.borderColor,
                                shadowColor: tamagotchiBubbleTheme.shadowColor,
                              },
                            ]}
                          >
                            <Text
                              style={[
                                styles.mascotBubbleText,
                                { color: tamagotchiBubbleTheme.textColor, maxWidth: heroBubbleTextMaxWidth },
                              ]}
                              numberOfLines={3}
                              ellipsizeMode="tail"
                            >
                              {tamagotchiSpeech}
                            </Text>
                            <View
                              style={[
                                styles.mascotBubbleTail,
                                { backgroundColor: tamagotchiBubbleTheme.backgroundColor },
                              ]}
                            />
                          </View>
                        </View>
                      )}
                      <TouchableOpacity onPress={onMascotPress} activeOpacity={0.9}>
                        <AlmiTamagotchi
                          style={heroMascotWrapStyle}
                          override={mascotOverride}
                          onOverrideComplete={onMascotAnimationComplete}
                          isStarving={
                            tamagotchiMood?.need === "food" &&
                            tamagotchiMood?.tone === "urgent"
                          }
                          isPlayDeprived={tamagotchiNeedsPlay}
                          desaturation={tamagotchiDirtyLevel}
                          animations={tamagotchiAnimations}
                        />
                      </TouchableOpacity>
                      {hasTamagotchiHungerImmunity && (
                        <View pointerEvents="none" style={styles.heroMascotShieldOverlay}>
                          <Text style={styles.heroMascotShieldIcon}>ðŸ›¡ï¸</Text>
                        </View>
                      )}
                      {dailyRewardReady && (
                        <View style={styles.heroMascotBadge}>
                          <Text style={styles.heroMascotBadgeText}>1</Text>
                        </View>
                      )}
                    </View>
                  )}
              </View>
              <Animated.View
                pointerEvents={heroLevelExpanded ? "auto" : "none"}
                style={[
                  styles.heroLevelExpandedCard,
                  {
                    maxHeight: heroLevelExpanded ? 240 : 0,
                    marginTop: heroLevelExpanded ? 12 : 0,
                    opacity: heroLevelAnim,
                    transform: [
                      {
                        translateY: heroLevelAnim.interpolate({
                          inputRange: [0, 1],
                          outputRange: [-6, 0],
                        }),
                      },
                    ],
                  },
                ]}
              >
                <View
                  style={[
                    styles.heroLevelDetails,
                    {
                      backgroundColor: goldPalette.badgeBg,
                      borderColor: goldPalette.badgeBorder,
                    },
                  ]}
                >
                  <Text style={[styles.heroLevelTitle, { color: goldPalette.text }]}>
                    {t("levelWidgetTitle")}
                  </Text>
                  <Text style={[styles.heroLevelSubtitle, { color: goldPalette.subtext }]}>
                    {heroLevelHasNext
                      ? t("levelWidgetSubtitle", { amount: heroLevelRemainingLabel })
                      : t("levelWidgetMaxed")}
                  </Text>
                  <View style={[styles.levelWidgetBar, { backgroundColor: goldPalette.barBg }]}>
                    <View
                      style={[
                        styles.levelWidgetFill,
                        {
                          backgroundColor: goldPalette.accent,
                          width: `${Math.min(Math.max(heroLevelProgress, 0), 1) * 100}%`,
                        },
                      ]}
                    />
                  </View>
                </View>
              </Animated.View>
            </MoodGradientBlock>
          </View>
          <View style={styles.heroCarousel} onLayout={handleHeroCarouselLayout}>
            <Animated.View style={{ transform: [{ translateX: heroCarouselHintAnim }] }}>
              <Animated.ScrollView
                ref={heroCarouselRef}
                horizontal
                showsHorizontalScrollIndicator={false}
                scrollEventThrottle={16}
                scrollEnabled={!heroExpanded}
                directionalLockEnabled
                nestedScrollEnabled
                decelerationRate="fast"
                snapToInterval={heroCarouselPageWidth}
                snapToAlignment="start"
                disableIntervalMomentum
                onScrollBeginDrag={handleHeroCarouselScrollBegin}
                onMomentumScrollEnd={handleHeroCarouselScrollEnd}
                onScrollEndDrag={handleHeroCarouselScrollEnd}
                contentOffset={{ x: heroCarouselPageWidth * (heroCarouselIndex + 1), y: 0 }}
                onScroll={handleHeroCarouselAnimatedScroll}
              >
                {Array.from({ length: heroCarouselLoopCount }, (_, loopIndex) => {
                  const realIndex = resolveHeroCarouselRealIndex(loopIndex);
                  const isClone = loopIndex === 0 || loopIndex === heroCarouselRealCount + 1;
                  const baseItemHeight = heroCarouselHeight ? { height: heroCarouselHeight } : null;
                  const itemHeight =
                    heroExpanded && realIndex === 0 ? null : baseItemHeight;
                  const itemCenter = heroCarouselPageWidth * loopIndex;
                  const inputRange = [
                    itemCenter - heroCarouselPageWidth,
                    itemCenter,
                    itemCenter + heroCarouselPageWidth,
                  ];
                  const wiggleRotate = heroCarouselScrollX.interpolate({
                    inputRange,
                    outputRange: ["-2.4deg", "0deg", "2.4deg"],
                    extrapolate: "clamp",
                  });
                  const wiggleScale = heroCarouselScrollX.interpolate({
                    inputRange,
                    outputRange: [0.985, 1, 0.985],
                    extrapolate: "clamp",
                  });
                  const wiggleTranslateY = heroCarouselScrollX.interpolate({
                    inputRange,
                    outputRange: [6, 0, 6],
                    extrapolate: "clamp",
                  });
                  const wiggleStyle = {
                    transform: [
                      { translateY: wiggleTranslateY },
                      { rotate: wiggleRotate },
                      { scale: wiggleScale },
                    ],
                  };
                  if (realIndex === 0) {
                    return (
                      <Animated.View
                        key={`hero-carousel-${loopIndex}`}
                        style={[styles.heroCarouselItem, { width: heroCarouselWidth }, itemHeight, wiggleStyle]}
                        onLayout={!isClone ? handleHeroCardLayout : undefined}
                        pointerEvents={isClone ? "none" : "auto"}
                      >
                          <SavingsHeroCard
                            ref={isClone ? null : savingsHeroRef}
                            goldPalette={goldPalette}
                            isDarkMode={isDarkMode}
                            heroSpendCopy={heroSpendCopy}
                            heroRecentEvents={heroRecentEvents}
                          heroEncouragementLine={heroEncouragementLine}
                          onRecentEventsPress={openHistoryModal}
                          playerLevel={playerLevel}
                          totalSavedLabel={totalSavedLabel}
                          progressPercent={progressPercent}
                          progressPercentLabel={progressPercentLabel}
                          isGoalComplete={isGoalComplete}
                          completionLabel={t("goalWidgetComplete")}
                          t={t}
                          analyticsPreview={analyticsPreview}
                          baselineMonthlyWasteUSD={baselineMonthlyWasteUSD}
                          baselineStartAt={baselineStartAt}
                          actualSavedUSD={realSavedUSD}
                          potentialGrowthUSD={potentialGrowthUSD}
                          showPotentialGrowth={showPotentialGrowth}
                          currency={currency}
                          hasBaseline={hasBaseline}
                          hasActiveGoal={heroHasActiveGoal}
                          onBaselineSetup={handleBaselineSetup}
                          onPotentialDetailsOpen={handlePotentialDetailsOpen}
                          healthPoints={healthPoints}
                          onBreakdownPress={onSavingsBreakdownPress}
                          playSound={playSound}
                          dailyRewardUnlocked={dailyRewardUnlocked}
                          dailyRewardReady={dailyRewardReady}
                          dailyRewardAmount={dailyRewardAmount}
                          dailyRewardBaseAmount={dailyRewardBaseAmount}
                          dailyRewardDay={dailyRewardDay}
                            onDailyRewardClaim={onDailyRewardClaim}
                            onDailyRewardModalVisibilityChange={onDailyRewardModalVisibilityChange}
                            activeChallenge={activeChallenge}
                            onActiveChallengePress={onActiveChallengePress}
                            onAnchorChange={isClone ? null : onSavingsHeroAnchorChange}
                            onExpandedChange={isClone ? null : setHeroExpanded}
                            style={styles.heroCarouselSizedCard}
                          />
                      </Animated.View>
                    );
                  }
                  if (realIndex === 1) {
                    const isBudgetPressable = !isClone && typeof onBudgetHeroPress === "function";
                    return (
                      <Animated.View
                        key={`hero-carousel-${loopIndex}`}
                        style={[styles.heroCarouselItem, { width: heroCarouselWidth }, itemHeight, wiggleStyle]}
                        pointerEvents={isClone ? "none" : "auto"}
                      >
                        <Pressable
                          onPress={isBudgetPressable ? onBudgetHeroPress : undefined}
                          disabled={!isBudgetPressable}
                          style={[itemHeight, styles.heroCarouselSizedCard]}
                        >
                          <BudgetHeroCard
                            colors={colors}
                            isDarkMode={isDarkMode}
                            t={t}
                            monthLabel={budgetPlan?.monthLabel || ""}
                            remainingLabel={budgetRemainingLabel}
                            remainingNegative={budgetRemainingNegative}
                            categories={budgetHeroCategories}
                            budgetHasIncome={budgetHasIncome}
                            formatLocalAmount={formatLocalAmount}
                            style={[itemHeight, styles.heroCarouselSizedCard]}
                          />
                        </Pressable>
                      </Animated.View>
                    );
                  }
                  return (
                    <Animated.View
                      key={`hero-carousel-${loopIndex}`}
                      style={[styles.heroCarouselItem, { width: heroCarouselWidth }, itemHeight, wiggleStyle]}
                    >
                      <DailyGoalCard
                        colors={colors}
                        isDarkMode={isDarkMode}
                        t={t}
                        monthLabel={dailyGoalDayLabel}
                        dailyGoalLabel={dailyGoalLabel}
                        dailyGoalUSD={dailyGoalUSD}
                        todaySavedUSD={todaySavedUSD}
                        savedCardCount={todaySavedCardCount}
                        coinDropTick={dailyGoalCoinDropTick}
                        isActive={!isClone && heroCarouselIndex === 2}
                        playSound={playSound}
                        shakeEnabled
                        onCollectCoins={onDailyGoalCollect}
                        isCollected={dailyGoalCollectedToday}
                        style={[itemHeight, styles.heroCarouselSizedCard]}
                      />
                    </Animated.View>
                  );
                })}
              </Animated.ScrollView>
            </Animated.View>
          </View>
          <View style={styles.feedTemptationHeader}>
            <Text style={[styles.feedTemptationTitle, { color: colors.text }]}>
              {t("tutorialFeedTitle")}
            </Text>
            <TouchableOpacity
                style={[
                  styles.feedTemptationAddButton,
                  { backgroundColor: colors.text, borderColor: colors.text },
                ]}
                onPress={onNewTemptation}
                activeOpacity={0.85}
              >
                <Text style={[styles.feedTemptationAddIcon, { color: colors.background }]}>+</Text>
              </TouchableOpacity>
            </View>
          </View>
        }
      />
      <HistoryModal
        visible={historyModalVisible}
        history={heroHistoryEntries}
        onClose={closeHistoryModal}
        onHistoryDelete={onHistoryDelete}
        t={t}
        colors={colors}
        currency={currency}
        language={language}
      />
    </SafeAreaView>
  );
})
);

const SwipeableGoalRow = ({
  children,
  colors,
  t,
  onEdit,
  onDelete,
  onSwipeOpen,
  onSwipeClose,
}) => {
  const translateX = useRef(new Animated.Value(0)).current;
  const ACTION_WIDTH = 160;
  const gestureStartOffset = useRef(0);
  const externalCloserRef = useRef(null);

  const closeRow = useCallback(
    (notify = true) => {
      Animated.timing(translateX, {
        toValue: 0,
        duration: 150,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }).start(() => {
        if (notify) {
          onSwipeClose?.(externalCloserRef.current);
          externalCloserRef.current = null;
        }
      });
    },
    [onSwipeClose, translateX]
  );

  const notifyOpen = useCallback(() => {
    const closer = () => closeRow();
    externalCloserRef.current = closer;
    onSwipeOpen?.(closer);
  }, [closeRow, onSwipeOpen]);

  const panResponder = useMemo(
    () =>
      PanResponder.create({
        onMoveShouldSetPanResponder: (_, gestureState) =>
          Math.abs(gestureState.dx) > Math.abs(gestureState.dy) && Math.abs(gestureState.dx) > 6,
        onPanResponderGrant: () => {
          translateX.stopAnimation((value) => {
            gestureStartOffset.current = value;
          });
        },
        onPanResponderMove: (_, gestureState) => {
          const base = gestureStartOffset.current || 0;
          const next = Math.max(0, Math.min(base + gestureState.dx, ACTION_WIDTH));
          translateX.setValue(next);
        },
        onPanResponderRelease: () => {
          translateX.stopAnimation((value) => {
            const shouldOpen = value > ACTION_WIDTH * 0.35;
            Animated.timing(translateX, {
              toValue: shouldOpen ? ACTION_WIDTH : 0,
              duration: 180,
              easing: Easing.out(Easing.quad),
              useNativeDriver: true,
            }).start(() => {
              if (shouldOpen) {
                notifyOpen();
              } else {
                closeRow();
              }
            });
          });
        },
        onPanResponderTerminate: () => {
          closeRow();
        },
      }),
    [ACTION_WIDTH, closeRow, notifyOpen, translateX]
  );

  const handleEdit = () => {
    closeRow();
    onEdit?.();
  };

  const handleDelete = () => {
    closeRow();
    onDelete?.();
  };

  return (
    <View style={[styles.goalSwipeRow, { backgroundColor: colors.background }]}>
      <View style={[styles.goalSwipeActions, { backgroundColor: colors.background }]}>
        <TouchableOpacity
          style={[styles.goalSwipeButton, !onEdit && styles.goalSwipeButtonDisabled]}
          onPress={handleEdit}
          disabled={!onEdit}
        >
          <Text style={[styles.goalSwipeButtonText, { color: colors.text }]}>{t("goalEditAction")}</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.goalSwipeButton, !onDelete && styles.goalSwipeButtonDisabled]}
          onPress={handleDelete}
          disabled={!onDelete}
        >
          <Text style={[styles.goalSwipeButtonText, { color: colors.text }]}>{t("goalDeleteAction")}</Text>
        </TouchableOpacity>
      </View>
      <Animated.View style={[styles.goalSwipeContent, { transform: [{ translateX }] }]} {...panResponder.panHandlers}>
        {children}
      </Animated.View>
    </View>
  );
};

const resolveWishEmoji = (wish) => {
  if (wish?.emoji) return wish.emoji;
  const title = (wish?.title || "").trim();
  if (title) {
    const firstChar = Array.from(title)[0];
    if (firstChar && !/[A-Za-zÐ-Ð¯Ð°-Ñ0-9]/.test(firstChar)) {
      return firstChar;
    }
  }
  return DEFAULT_GOAL_EMOJI;
};

const getWishTitleWithoutEmoji = (wish) => {
  const title = typeof wish?.title === "string" ? wish.title : "";
  if (!title) return "";
  const trimmed = title.trimStart();
  if (!trimmed) return "";
  const wishEmoji = resolveWishEmoji(wish);
  if (wishEmoji) {
    const emojiToken = wishEmoji.trim();
    if (emojiToken && trimmed.startsWith(emojiToken)) {
      return trimmed.slice(emojiToken.length).trimStart();
    }
  }
  const firstChar = Array.from(trimmed)[0];
  if (!firstChar) return trimmed;
  const isSymbol = !/[A-Za-zÐ-Ð¯Ð°-Ñ0-9]/.test(firstChar);
  if (isSymbol && wishEmoji) {
    const rest = Array.from(trimmed).slice(1).join("").trimStart();
    return rest || trimmed;
  }
  return trimmed;
};

const selectMainGoalWish = (wishes = [], activeGoalId = null) => {
  const list = Array.isArray(wishes) ? wishes : [];
  if (activeGoalId) {
    const pinned = list.find(
      (wish) =>
        wish?.goalId === activeGoalId ||
        wish?.id === activeGoalId
    );
    if (pinned) return pinned;
  }
  const primaryActive = list.find(
    (wish) => wish?.kind === PRIMARY_GOAL_KIND && wish.status !== "done"
  );
  if (primaryActive) return primaryActive;
  return list.find((wish) => wish?.status !== "done") || null;
};

const ProgressRing = React.memo(function ProgressRing({
  size = 76,
  strokeWidth = 8,
  progress = 0,
  trackColor = "rgba(0,0,0,0.08)",
  progressColor = "#111",
}) {
  const normalized = Math.min(Math.max(progress, 0), 1);
  const radius = (size - strokeWidth) / 2;
  const circumference = 2 * Math.PI * radius;
  const dashOffset = circumference * (1 - normalized);
  return (
    <Svg width={size} height={size}>
      <SvgCircle
        cx={size / 2}
        cy={size / 2}
        r={radius}
        stroke={trackColor}
        strokeWidth={strokeWidth}
        fill="none"
      />
      <SvgCircle
        cx={size / 2}
        cy={size / 2}
        r={radius}
        stroke={progressColor}
        strokeWidth={strokeWidth}
        fill="none"
        strokeDasharray={`${circumference} ${circumference}`}
        strokeDashoffset={dashOffset}
        strokeLinecap="round"
        transform={`rotate(-90 ${size / 2} ${size / 2})`}
      />
    </Svg>
  );
});

const ChallengeProgressDots = React.memo(function ChallengeProgressDots({
  total = 0,
  progress = 0,
  colors,
}) {
  const count = Math.max(0, Math.round(total));
  if (!count) return null;
  return (
    <View style={styles.challengeDotRow}>
      {Array.from({ length: count }).map((_, index) => {
        const filled = index < progress;
        return (
          <View
            key={`dot-${index}`}
            style={[
              styles.challengeDot,
              {
                borderColor: filled ? colors.text : colors.border,
                backgroundColor: filled ? colors.text : "transparent",
              },
            ]}
          >
            {filled ? (
              <Text style={[styles.challengeDotCheck, { color: colors.background }]}>âœ“</Text>
            ) : null}
          </View>
        );
      })}
    </View>
  );
});

const BudgetWidgetTutorialModal = React.memo(function BudgetWidgetTutorialModal({
  visible,
  colors,
  t,
  theme,
  onClose,
}) {
  if (!visible) return null;
  const isDarkTheme = theme === "dark";
  const isProTheme = theme === PRO_THEME_ID;
  const accent = isDarkTheme ? "#FFD06A" : isProTheme ? colors.primary : "#FFB24A";
  const accentSoft = colorWithAlpha(accent, isDarkTheme ? 0.18 : isProTheme ? 0.24 : 0.22);
  const accentBorder = colorWithAlpha(accent, isDarkTheme ? 0.45 : isProTheme ? 0.5 : 0.35);
  const trackColor = colorWithAlpha(colors.text, isDarkTheme ? 0.2 : isProTheme ? 0.2 : 0.12);
  const bars = [
    { id: "food", emoji: "ðŸ²", width: "72%", color: SAVE_ACTION_COLOR },
    { id: "move", emoji: "ðŸš•", width: "48%", color: "#6BA9FF" },
    { id: "fun", emoji: "ðŸŽ‰", width: "58%", color: "#FF9F6A" },
  ];
  const cards = [
    {
      id: "smart",
      emoji: "ðŸ§ ",
      title: t("budgetWidgetTutorialSmartTitle"),
      desc: t("budgetWidgetTutorialSmartDesc"),
    },
    {
      id: "behavior",
      emoji: "ðŸ“Š",
      title: t("budgetWidgetTutorialBehaviorTitle"),
      desc: t("budgetWidgetTutorialBehaviorDesc"),
    },
    {
      id: "fresh",
      emoji: "âœ¨",
      title: t("budgetWidgetTutorialFreshTitle"),
      desc: t("budgetWidgetTutorialFreshDesc"),
    },
  ];
  return (
    <Modal
      visible
      transparent
      animationType="fade"
      statusBarTranslucent
      onRequestClose={() => onClose?.("back")}
    >
      <TouchableWithoutFeedback onPress={() => onClose?.("backdrop")}>
        <View style={styles.budgetTutorialBackdrop}>
          <TouchableWithoutFeedback onPress={() => {}}>
            <View
              style={[
                styles.budgetTutorialCard,
                { backgroundColor: colors.card, borderColor: colors.border },
              ]}
            >
              <Text style={[styles.budgetTutorialTitle, { color: colors.text }]}>
                {t("budgetWidgetTutorialTitle")}
              </Text>
              <Text style={[styles.budgetTutorialSubtitle, { color: colors.muted }]}>
                {t("budgetWidgetTutorialSubtitle")}
              </Text>
              <View
                style={[
                  styles.budgetTutorialHero,
                  { backgroundColor: colors.background, borderColor: colors.border },
                ]}
              >
                <View style={styles.budgetTutorialHeroHeader}>
                  <Text style={[styles.budgetTutorialHeroTitle, { color: colors.text }]}>
                    {t("budgetWidgetTitle")}
                  </Text>
                  <View
                    style={[
                      styles.budgetTutorialHeroChip,
                      { backgroundColor: accentSoft, borderColor: accentBorder },
                    ]}
                  >
                    <Text style={[styles.budgetTutorialHeroChipText, { color: accent }]}>
                      {t("budgetWidgetTutorialChip")}
                    </Text>
                  </View>
                </View>
                <View style={styles.budgetTutorialHeroRows}>
                  {bars.map((bar) => (
                    <View key={bar.id} style={styles.budgetTutorialHeroRow}>
                      <Text style={styles.budgetTutorialHeroEmoji}>{bar.emoji}</Text>
                      <View
                        style={[
                          styles.budgetTutorialHeroTrack,
                          { backgroundColor: trackColor },
                        ]}
                      >
                        <View
                          style={[
                            styles.budgetTutorialHeroFill,
                            { width: bar.width, backgroundColor: bar.color },
                          ]}
                        />
                      </View>
                    </View>
                  ))}
                </View>
              </View>
              <View style={styles.budgetTutorialIllustrations}>
                {cards.map((card) => (
                  <View
                    key={card.id}
                    style={[
                      styles.budgetTutorialIllustrationCard,
                      { backgroundColor: colors.background, borderColor: colors.border },
                    ]}
                  >
                    <Text style={styles.budgetTutorialIllustrationEmoji}>{card.emoji}</Text>
                    <Text style={[styles.budgetTutorialIllustrationTitle, { color: colors.text }]}>
                      {card.title}
                    </Text>
                    <Text style={[styles.budgetTutorialIllustrationDesc, { color: colors.muted }]}>
                      {card.desc}
                    </Text>
                  </View>
                ))}
              </View>
              <TouchableOpacity
                style={[styles.budgetTutorialButton, { backgroundColor: colors.text }]}
                activeOpacity={0.9}
                onPress={() => onClose?.("cta")}
              >
                <Text style={[styles.budgetTutorialButtonText, { color: colors.background }]}>
                  {t("budgetWidgetTutorialCta")}
                </Text>
              </TouchableOpacity>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
});

const BudgetBarItem = React.memo(function BudgetBarItem({
  entry,
  valueUSD = 0,
  spentUSD = 0,
  maxHeight = BUDGET_BAR_MAX_HEIGHT,
  colors,
  onManualEdit,
  formatAmount,
}) {
  const limitBaseUSD = Math.max(0, Number(valueUSD) || 0);
  const safeSpentUSD = Math.max(0, Number(spentUSD) || 0);
  const ratio = limitBaseUSD > 0 ? safeSpentUSD / limitBaseUSD : safeSpentUSD > 0 ? 2 : 0;
  const normalizedSpent = Math.min(Math.max(ratio, 0), 1);
  const overspendRatio = Math.max(ratio - 1, 0);
  const limitHeight = maxHeight;
  const spendWithinHeight = normalizedSpent * maxHeight;
  const overspendHeight = Math.min(overspendRatio, 1) * maxHeight;
  return (
    <Pressable
      style={styles.budgetModalBarItem}
      onPress={() => onManualEdit?.(entry.id, valueUSD)}
      hitSlop={8}
    >
      <View
        style={[styles.budgetModalBarTrack, { backgroundColor: colorWithAlpha(colors.text, 0.12) }]}
      >
        <View
          style={[
            styles.budgetModalLimitFill,
            { height: limitHeight, backgroundColor: colorWithAlpha(colors.text, 0.28) },
          ]}
        />
        <View
          style={[
            styles.budgetModalBarFill,
            {
              height: spendWithinHeight,
              backgroundColor: SAVE_ACTION_COLOR,
            },
          ]}
        />
        {overspendHeight > 0 ? (
          <View
            style={[
              styles.budgetModalBarOverflow,
              { height: overspendHeight, backgroundColor: SPEND_ACTION_COLOR, top: 0 },
            ]}
          />
        ) : null}
      </View>
      <Text style={[styles.budgetModalBarAmount, { color: colors.text }]}>
        {formatAmount(valueUSD)}
      </Text>
      <Text style={[styles.budgetModalBarLabel, { color: colors.muted }]} numberOfLines={2}>
        {entry.emoji} {entry.label}
      </Text>
    </Pressable>
  );
});

const ProgressScreen = React.memo(function ProgressScreen({
  wishes,
  currency = DEFAULT_PROFILE.currency,
  t,
  colors,
  onRemoveWish,
  primaryGoals = [],
  onGoalLongPress = null,
  onGoalEdit = null,
  activeGoalId = null,
  onSetActiveGoal = null,
  language = DEFAULT_LANGUAGE,
  catCuriousSource,
  healthPoints = 0,
  freeDayStats = INITIAL_FREE_DAY_STATS,
  onFreeDayLog,
  onFreeDayRescue,
  freeDayRescueCost = FREE_DAY_RESCUE_COST,
  historyEvents = [],
  incomeEntries = [],
  budgetOverrides = {},
  budgetAutoEnabled = true,
  onBudgetAutoLocked = null,
  savedTotalUSD = 0,
  decisionStats = {},
  baselineMonthlyWasteUSD = 0,
  onBudgetOverrideChange = () => {},
  onIncomeEntryOpen = () => {},
  onExtraIncomeEntryOpen = () => {},
  impulseInsights,
  showImpulseMap = false,
  showFreeDayCard = false,
  challenges = [],
  dailyChallenge = null,
  onChallengeAccept = () => {},
  onChallengeClaim = () => {},
  onChallengeCancel = () => {},
  onCreateGoal = () => {},
  onFocusCancel = null,
  focusChallengeId = null,
  onFocusHandled = () => {},
  challengeBadges = [],
  challengeBadgeCount = 0,
  playerLevel = 1,
  resolveTemplateCard = null,
  resolveTemptationCategory = null,
  customCategories = [],
  onWeeklySpendPress = null,
  budgetSpeechDataRef = null,
  scrollRef: externalScrollRef,
  onBudgetWidgetLayout = null,
  onImpulseMapLockedPress = null,
}) {
  const isDarkTheme = colors.background === THEMES.dark.background;
  const budgetLimitWarningColor = isDarkTheme ? "#FFD59A" : "#F6C16B";
  const resolvedBudgetSpeechDataRef =
    typeof budgetSpeechDataRef === "undefined" ? null : budgetSpeechDataRef;
  const [impulseExpanded, setImpulseExpanded] = useState(false);
  const handleImpulseToggle = useCallback(() => {
    runLayoutAnimation();
    setImpulseExpanded((prev) => !prev);
  }, []);
  const primaryGoalIds = Array.isArray(primaryGoals)
    ? primaryGoals.map((goal) => goal?.id).filter(Boolean)
    : [];
  useEffect(() => {
    const primaryEntries = (wishes || []).filter((wish) => wish?.kind === PRIMARY_GOAL_KIND);
    if (primaryEntries.length) {
      const summary = primaryEntries.map((wish) => ({
        id: wish.id,
        goalId: wish.goalId,
        savedUSD: wish.savedUSD,
        targetUSD: wish.targetUSD,
        status: wish.status,
      }));
      console.warn("primary_goal_wishlist_state", summary);
    }
  }, [wishes]);
  const listData = useMemo(() => {
    if (!Array.isArray(wishes)) return [];
    return wishes
      .map((wish, index) => ({ wish, index }))
      .sort((a, b) => {
        const aDone = a.wish?.status === "done";
        const bDone = b.wish?.status === "done";
        if (aDone === bDone) {
          return a.index - b.index;
        }
        return aDone ? 1 : -1;
      })
      .map((entry) => entry.wish);
  }, [wishes]);
  const swipeCloserRef = useRef(null);
  const handleSwipeOpen = useCallback((closeFn) => {
    if (swipeCloserRef.current && swipeCloserRef.current !== closeFn) {
      swipeCloserRef.current();
    }
    swipeCloserRef.current = closeFn;
  }, []);
  const handleSwipeClose = useCallback((closeFn) => {
    if (!closeFn || swipeCloserRef.current === closeFn) {
      swipeCloserRef.current = null;
    }
  }, []);
  const totalTarget = formatCurrency(
    convertToCurrency(listData.reduce((sum, wish) => sum + (wish.targetUSD || 0), 0), currency),
    currency
  );
  const resolvedActiveGoalId = activeGoalId || primaryGoalIds[0] || null;
  const activeGoalEntry = Array.isArray(primaryGoals)
    ? primaryGoals.find((goal) => goal?.id === resolvedActiveGoalId)
    : null;
  const activeGoalWish = listData.find((wish) => (wish.goalId || wish.id) === resolvedActiveGoalId) || null;
  const goalPreset = resolvedActiveGoalId ? getGoalPreset(resolvedActiveGoalId) : null;
  const goalTitle = activeGoalWish
    ? getWishTitleWithoutEmoji(activeGoalWish)
    : activeGoalEntry?.customTitle
    ? activeGoalEntry.customTitle
    : resolvedActiveGoalId
    ? goalPreset?.[language] || goalPreset?.en || ""
    : t("wishlistEmptyTitle");
  const goalEmoji =
    activeGoalWish?.emoji ||
    (activeGoalWish ? resolveWishEmoji(activeGoalWish) : null) ||
    activeGoalEntry?.customEmoji ||
    goalPreset?.emoji ||
    "ðŸŽ¯";
  const goalTargetUSD =
    Number.isFinite(activeGoalEntry?.targetUSD) && activeGoalEntry.targetUSD > 0
      ? activeGoalEntry.targetUSD
      : activeGoalWish?.targetUSD || (resolvedActiveGoalId ? getGoalDefaultTargetUSD(resolvedActiveGoalId) : 0);
  const goalSavedUSD = Number.isFinite(activeGoalEntry?.savedUSD)
    ? Math.max(activeGoalEntry.savedUSD, 0)
    : Math.max(activeGoalWish?.savedUSD || 0, 0);
  const goalProgress = goalTargetUSD > 0 ? Math.min(goalSavedUSD / goalTargetUSD, 1) : 0;
  const goalTargetLabel = formatCurrency(convertToCurrency(goalTargetUSD || 0, currency), currency);
  const goalRemainingLabel = formatCurrency(
    convertToCurrency(Math.max(goalTargetUSD - goalSavedUSD, 0), currency),
    currency
  );
  const coinEntries = useMemo(() => buildHealthCoinEntries(healthPoints), [healthPoints]);
  const hasCoinInventory = coinEntries.some((entry) => entry.count > 0);
  const activeChallenges = challenges.filter(
    (entry) => entry.status === CHALLENGE_STATUS.ACTIVE
  );
  const bestActiveChallenge = activeChallenges.reduce((best, current) => {
    if (!best) return current;
    if ((current.progressPercent || 0) > (best.progressPercent || 0)) return current;
    if ((current.progressPercent || 0) < (best.progressPercent || 0)) return best;
    return (current.progressValue || 0) >= (best.progressValue || 0) ? current : best;
  }, null);
  const activeChallenge = bestActiveChallenge || null;
  const activeChallengeIsAmount = activeChallenge ? !activeChallenge.isCountMetric : false;
  const activeChallengeProgressValue = activeChallenge?.progressValue || 0;
  const activeChallengeTargetValue = activeChallenge?.targetValue || 0;
  const activeChallengePercent =
    activeChallenge && activeChallengeTargetValue
      ? Math.min(activeChallengeProgressValue / activeChallengeTargetValue, 1)
      : 0;
  const activeChallengeActionEnabled =
    activeChallenge?.canClaim || activeChallenge?.canStart || false;
  useEffect(() => {
    runLayoutAnimation();
  }, [activeChallenge?.id]);
  const dailyChallengeRewardLabel = useMemo(() => {
    const bonus = Number(dailyChallenge?.rewardBonus) || 0;
    const base = Number(dailyChallenge?.baseReward) || 0;
    const total = Number(dailyChallenge?.rewardTotal) || base + bonus;
    return formatHealthRewardLabel(total, language);
  }, [dailyChallenge?.baseReward, dailyChallenge?.rewardBonus, dailyChallenge?.rewardTotal, language]);
  const progressChallengeList = useMemo(() => {
    const list = Array.isArray(challenges) ? challenges.filter(Boolean) : [];
    return list
      .map((entry, index) => ({ entry, index }))
      .sort((a, b) => {
        const aClaimable = a.entry?.canClaim ? 0 : 1;
        const bClaimable = b.entry?.canClaim ? 0 : 1;
        if (aClaimable !== bClaimable) return aClaimable - bClaimable;
        const base = compareChallengesForDisplay(a.entry, b.entry);
        if (base !== 0) return base;
        return a.index - b.index;
      })
      .map((item) => item.entry);
  }, [challenges]);

  const resolvedHistoryEvents = useMemo(
    () => (Array.isArray(historyEvents) ? historyEvents : []),
    [historyEvents]
  );
  const internalScrollRef = useRef(null);
  const scrollRef = externalScrollRef || internalScrollRef;
  const challengeSwipeCloserRef = useRef(null);
  const handleChallengeSwipeOpen = useCallback((closeFn) => {
    if (challengeSwipeCloserRef.current && challengeSwipeCloserRef.current !== closeFn) {
      challengeSwipeCloserRef.current();
    }
    challengeSwipeCloserRef.current = closeFn;
  }, []);
  const handleChallengeSwipeClose = useCallback((closeFn) => {
    if (!closeFn || challengeSwipeCloserRef.current === closeFn) {
      challengeSwipeCloserRef.current = null;
    }
  }, []);
  const closeChallengeSwipe = useCallback(() => {
    if (challengeSwipeCloserRef.current) {
      challengeSwipeCloserRef.current();
    }
  }, []);
  const challengeLayoutsRef = useRef({});
  const registerChallengeLayout = useCallback(
    (challengeId, event) => {
      if (!challengeId || !event?.nativeEvent?.layout) return;
      const layout = event.nativeEvent.layout;
      challengeLayoutsRef.current[challengeId] = layout;
      if (focusChallengeId && challengeId === focusChallengeId && scrollRef.current) {
        const targetY = Math.max(layout.y - 16, 0);
        scrollRef.current.scrollTo({ y: targetY, animated: true });
        onFocusHandled?.();
      }
    },
    [focusChallengeId, onFocusHandled]
  );
  const freeDayEventKeys = useMemo(() => {
    const keys = new Set();
    resolvedHistoryEvents.forEach((entry) => {
      if (entry.kind === "free_day") {
        keys.add(getDayKey(entry.timestamp));
      }
    });
    return keys;
  }, [resolvedHistoryEvents]);
  const todayDate = new Date();
  const todayTimestamp = todayDate.getTime();
  const todayKey = getDayKey(todayDate);
  const dayBeforeYesterdayKey = getDayKey(new Date(todayDate.getTime() - DAY_MS * 2));
  const freeDayBlockedToday = freeDayStats?.blockedDate === todayKey;
  const isEvening = new Date().getHours() >= 18;
  const canLogFreeDay = isEvening && freeDayStats?.lastDate !== todayKey && !freeDayBlockedToday;
  const streakNeedsRescue =
    (freeDayStats?.current || 0) > 0 &&
    freeDayStats?.lastDate === dayBeforeYesterdayKey &&
    freeDayStats?.lastDate !== todayKey;
  const hasRescueHealth = healthPoints >= freeDayRescueCost;
  const canRescueFreeDay = streakNeedsRescue && hasRescueHealth;
  const rescueStatus = !streakNeedsRescue
    ? null
    : !hasRescueHealth
    ? t("freeDayRescueNeedHealth", { cost: freeDayRescueCost })
    : null;
  const weekLabels = WEEKDAY_LABELS_MONDAY_FIRST[language] || WEEKDAY_LABELS_MONDAY_FIRST.en;
  const weekDays = useMemo(() => {
    const today = new Date(todayTimestamp);
    const start = new Date(today);
    const weekday = (today.getDay() + 6) % 7;
    start.setDate(today.getDate() - weekday);
    return Array.from({ length: 7 }).map((_, index) => {
      const date = new Date(start);
      date.setDate(start.getDate() + index);
      const key = getDayKey(date);
      return {
        key,
        label: weekLabels[index],
        active: freeDayEventKeys.has(key),
        isToday: key === todayKey,
      };
    });
  }, [freeDayEventKeys, todayTimestamp, todayKey, weekLabels]);
  const weekSuccessCount = useMemo(
    () => weekDays.filter((day) => day.active).length,
    [weekDays]
  );
  const categoryData = useMemo(() => {
    const categories = IMPULSE_CATEGORY_ORDER.map((id, index) => {
      const entry = impulseInsights?.categories?.[id] || { save: 0, spend: 0 };
      const total = (entry.save || 0) + (entry.spend || 0);
      return {
        id,
        orderIndex: index,
        label: getImpulseCategoryLabel(id, language),
        save: entry.save || 0,
        spend: entry.spend || 0,
        total,
      };
    });
    const maxTotal = categories.reduce((max, entry) => Math.max(max, entry.total || 0), 0);
    const sorted = [...categories].sort((a, b) => {
      if (b.total !== a.total) return b.total - a.total;
      return a.orderIndex - b.orderIndex;
    });
    return { categories: sorted, maxTotal: Math.max(maxTotal, 1) };
  }, [customCategories, impulseInsights?.categories, language]);
  const categoryListHeight = useMemo(() => 64 * 5, []);
  const weeklyComparison = useMemo(() => {
    const today = new Date(todayTimestamp);
    const currentStart = new Date(today);
    currentStart.setDate(today.getDate() - 6);
    const prevStart = new Date(currentStart);
    prevStart.setDate(currentStart.getDate() - 7);
    const currentRange = { start: currentStart.getTime(), end: today.getTime() };
    const prevRange = { start: prevStart.getTime(), end: currentStart.getTime() - 1 };
    let currentSavings = 0;
    let currentSpending = 0;
    let prevSavings = 0;
    let prevSpending = 0;
    resolvedHistoryEvents.forEach((entry) => {
      const timestamp = entry?.timestamp;
      if (!timestamp) return;
      const amount = Math.max(0, Number(entry?.meta?.amountUSD) || 0);
      if (!amount) return;
      if (timestamp >= currentRange.start && timestamp <= currentRange.end) {
        if (entry.kind === "refuse_spend") {
          currentSavings += amount;
        } else if (entry.kind === "spend") {
          currentSpending += amount;
        }
      } else if (timestamp >= prevRange.start && timestamp <= prevRange.end) {
        if (entry.kind === "refuse_spend") {
          prevSavings += amount;
        } else if (entry.kind === "spend") {
          prevSpending += amount;
        }
      }
    });
    const buildDelta = (current, previous) => {
      const deltaUSD = current - previous;
      return {
        deltaUSD,
        previous,
      };
    };
    return {
      savings: buildDelta(currentSavings, prevSavings),
      spending: buildDelta(currentSpending, prevSpending),
      currentSavings,
      currentSpending,
    };
  }, [resolvedHistoryEvents, todayTimestamp]);
  const weeklyTrend = useMemo(() => {
    const formatEntry = (entry, type) => {
      const delta = Number(entry?.deltaUSD) || 0;
      const absDelta = Math.abs(delta);
      const localValue = formatCurrency(convertToCurrency(absDelta, currency), currency);
      const symbol = delta >= 0 ? "â–²" : "â–¼";
      let color = SAVE_ACTION_COLOR;
      if (type === "savings") {
        color = delta >= 0 ? SAVE_ACTION_COLOR : SPEND_ACTION_COLOR;
      } else {
        color = delta >= 0 ? SPEND_ACTION_COLOR : SAVE_ACTION_COLOR;
      }
      return {
        symbol,
        label: localValue,
        color,
      };
    };
    const base = weeklyComparison || {};
    const savingsTrend = formatEntry(base.savings, "savings");
    const spendingTrend = formatEntry(base.spending, "spending");
    return { savings: savingsTrend, spending: spendingTrend };
  }, [currency, weeklyComparison]);
  const weeklyDailySavings = useMemo(() => {
    const today = new Date(todayTimestamp);
    const start = new Date(today);
    start.setDate(today.getDate() - 6);
    const minTimestamp = start.getTime();
    const map = new Map();
    resolvedHistoryEvents.forEach((entry) => {
      if (!entry.timestamp || entry.timestamp < minTimestamp) return;
      if (entry.kind !== "refuse_spend" && entry.kind !== "spend") return;
      const amount = Math.max(0, Number(entry.meta?.amountUSD) || 0);
      if (!amount) return;
      const key = getDayKey(entry.timestamp);
      const current = map.get(key) || { saveUSD: 0, spendUSD: 0 };
      if (entry.kind === "refuse_spend") {
        current.saveUSD += amount;
      } else {
        current.spendUSD += amount;
      }
      map.set(key, current);
    });
    const baseItems = Array.from({ length: 7 }).map((_, index) => {
      const date = new Date(start);
      date.setDate(start.getDate() + index);
      const key = getDayKey(date);
      const stats = map.get(key) || { saveUSD: 0, spendUSD: 0 };
      const saveUSD = stats.saveUSD || 0;
      const spendUSD = stats.spendUSD || 0;
      const weekdayIndex = (date.getDay() + 6) % 7;
      const label =
        WEEKDAY_LABELS_MONDAY_FIRST[language]?.[weekdayIndex] ||
        WEEKDAY_LABELS_MONDAY_FIRST.en[weekdayIndex];
      const saveLocal = convertToCurrency(saveUSD, currency);
      const spendLocal = convertToCurrency(spendUSD, currency);
      const amountLabel = saveUSD ? formatCurrency(saveLocal, currency) : formatCurrency(0, currency);
      const spendLabel = spendUSD ? `-${formatCurrency(spendLocal, currency)}` : formatCurrency(0, currency);
      const amountParts = splitCurrencyLabel(amountLabel, currency);
      const spendParts = splitCurrencyLabel(spendLabel, currency);
      const amountValueLabel =
        amountParts.value && typeof amountParts.value === "string"
          ? amountParts.value.replace(/ /g, "\u00A0")
          : amountParts.value;
      const spendValueLabel =
        spendParts.value && typeof spendParts.value === "string"
          ? spendParts.value.replace(/ /g, "\u00A0")
          : spendParts.value;
      return {
        key,
        label,
        amountUSD: saveUSD,
        saveUSD,
        spendUSD,
        amountLabel,
        amountValueLabel,
        amountCurrencySymbol: amountParts.symbol,
        spendLabel,
        spendValueLabel,
        spendCurrencySymbol: spendParts.symbol,
      };
    });
    return baseItems.map((item) => {
      const total = (item.saveUSD || 0) + (item.spendUSD || 0);
      const spendPercent = total > 0 ? (item.spendUSD / total) * 100 : 0;
      return {
        ...item,
        percent: 100,
        spendPercent,
        spendOverflow: item.spendUSD > item.saveUSD,
      };
    });
  }, [currency, language, resolvedHistoryEvents, todayTimestamp]);
  const weeklyCardPalette = isDarkTheme
    ? {
        background: "rgba(18,22,34,0.92)",
        border: "rgba(255,255,255,0.12)",
        text: "#F2F5FF",
        subtext: "rgba(242,245,255,0.62)",
        track: "rgba(255,255,255,0.08)",
        save: "#6BE2A1",
        spend: "#FF8F9A",
      }
    : {
        background: "#FFFFFF",
        border: "rgba(0,0,0,0.08)",
        text: "#2A1C00",
        subtext: "rgba(42,28,0,0.6)",
        track: "rgba(0,0,0,0.06)",
        save: SAVE_ACTION_COLOR,
        spend: SPEND_ACTION_COLOR,
      };
  const weeklyHasData = useMemo(
    () => weeklyDailySavings.some((day) => (day.amountUSD || 0) > 0 || (day.spendUSD || 0) > 0),
    [weeklyDailySavings]
  );
  const WeeklyCardWrap = onWeeklySpendPress ? TouchableOpacity : View;

  const renderWithLongPress = useCallback(
    (wish, content) => {
      if (typeof onGoalLongPress === "function") {
        return (
          <TouchableOpacity
            activeOpacity={0.96}
            delayLongPress={320}
            onLongPress={() => onGoalLongPress(wish)}
          >
            {content}
          </TouchableOpacity>
        );
      }
      return content;
    },
    [onGoalLongPress]
  );

  const renderWishRow = useCallback(
    ({ item: wish }) => {
        const targetLocal = formatCurrency(
          convertToCurrency(wish.targetUSD || 0, currency),
          currency
        );
        const progress = Math.min((wish.savedUSD || 0) / (wish.targetUSD || 1), 1);
        const progressLabel = t("wishlistProgress", {
          current: formatCurrency(convertToCurrency(wish.savedUSD || 0, currency), currency),
          target: targetLocal,
        });
        const isPrimaryGoal = wish.kind === PRIMARY_GOAL_KIND;
        const goalId = wish.goalId || wish.id;
        const isActiveGoal = !!activeGoalId && activeGoalId === goalId;
        const badgeText = isPrimaryGoal
          ? isActiveGoal
            ? t("goalPrimaryBadge")
            : t("goalPrimaryBadge")
          : wish.status === "done"
          ? t("wishlistDoneLabel")
          : `${Math.round(progress * 100)}%`;
        const remainingUSD = Math.max((wish.targetUSD || 0) - (wish.savedUSD || 0), 0);
        const remainingLabel = formatCurrency(convertToCurrency(remainingUSD, currency), currency);
        const displayTitle = getWishTitleWithoutEmoji(wish);
        if (isPrimaryGoal) {
          const preset = getGoalPreset(wish.goalId || primaryGoalIds[0]);
          const emblem = wish.emoji || resolveWishEmoji(wish) || preset?.emoji || "ðŸŽ¯";
          const secondaryColor = isDarkTheme
            ? "rgba(14,15,22,0.65)"
            : "rgba(246,247,251,0.8)";
          const badgeStyle = isDarkTheme
            ? {
                borderColor: "rgba(14,15,22,0.25)",
                backgroundColor: "rgba(14,15,22,0.08)",
              }
            : {
                borderColor: "rgba(246,247,251,0.35)",
                backgroundColor: "rgba(246,247,251,0.15)",
              };
          const trackColor = isDarkTheme
            ? "rgba(14,15,22,0.15)"
            : "rgba(246,247,251,0.2)";
          const fillColor = isDarkTheme
            ? "rgba(14,15,22,0.85)"
            : "rgba(246,247,251,0.95)";
          const cardContent = (
            <View
              style={[
                styles.primaryGoalCard,
                {
                  backgroundColor: colors.text,
                  borderColor: isActiveGoal ? GOAL_HIGHLIGHT_COLOR : colors.text,
                  borderWidth: isActiveGoal ? 2 : 0,
                },
              ]}
            >
              <View style={styles.primaryGoalTop}>
                <View style={{ flex: 1, gap: 8 }}>
                  <View
                    style={[
                      styles.primaryGoalBadge,
                      badgeStyle,
                    ]}
                  >
                    <Text style={[styles.primaryGoalBadgeText, { color: colors.background }]}>
                      {t("goalPrimaryBadge")}
                    </Text>
                  </View>
                  <Text style={[styles.primaryGoalTitle, { color: colors.background }]}>
                    {displayTitle}
                  </Text>
                </View>
                <View
                  style={[
                    styles.primaryGoalEmblem,
                    {
                      borderColor: badgeStyle.borderColor,
                      backgroundColor: badgeStyle.backgroundColor,
                    },
                  ]}
                >
                  <Text style={{ fontSize: 30 }}>{emblem}</Text>
                </View>
              </View>
              <Text style={[styles.primaryGoalSubtitle, { color: secondaryColor }]}>
                {t("primaryGoalRemaining", { amount: remainingLabel })}
              </Text>
              <Text style={[styles.primaryGoalSubtitle, { color: secondaryColor }]}>
                {progressLabel}
              </Text>
              <View style={styles.primaryGoalProgressRow}>
                <View
                  style={[
                    styles.primaryGoalProgressTrack,
                    {
                      backgroundColor: trackColor,
                    },
                  ]}
                >
                  <View
                    style={[
                      styles.primaryGoalProgressFill,
                      {
                        width: `${progress * 100}%`,
                        backgroundColor: fillColor,
                      },
                    ]}
                  />
                </View>
                <Text style={[styles.primaryGoalPercent, { color: colors.background }]}>
                  {`${Math.round(progress * 100)}%`}
                </Text>
              </View>
              <TouchableOpacity
                style={[
                  styles.goalSelectButton,
                  {
                    borderColor: isActiveGoal ? GOAL_HIGHLIGHT_COLOR : colors.border,
                    backgroundColor: isActiveGoal ? "rgba(246,193,107,0.15)" : colors.card,
                  },
                ]}
                activeOpacity={0.9}
                onPress={() => onSetActiveGoal?.(goalId)}
              >
                <Text
                  style={[
                    styles.goalSelectText,
                    { color: isActiveGoal ? GOAL_HIGHLIGHT_COLOR : colors.text },
                  ]}
                >
                  {isActiveGoal
                    ? (language || DEFAULT_LANGUAGE) === "ru"
                      ? "ÐÐºÑ‚Ð¸Ð²Ð½Ð°Ñ Ñ†ÐµÐ»ÑŒ"
                      : "Active goal"
                    : (language || DEFAULT_LANGUAGE) === "ru"
                    ? "Ð¡Ð´ÐµÐ»Ð°Ñ‚ÑŒ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð¾Ð¹"
                    : "Set active"}
                </Text>
              </TouchableOpacity>
            </View>
          );
          return (
            <SwipeableGoalRow
              colors={colors}
              t={t}
              onEdit={onGoalEdit ? () => onGoalEdit(wish) : undefined}
              onDelete={() => onRemoveWish(wish.id)}
              onSwipeOpen={handleSwipeOpen}
              onSwipeClose={handleSwipeClose}
            >
              {renderWithLongPress(wish, cardContent)}
            </SwipeableGoalRow>
          );
        }
        const wishEmoji = resolveWishEmoji(wish);
        const wishTitle = displayTitle;
        const cardContent = (
          <View
            style={[
              styles.wishCard,
              {
                backgroundColor: colors.card,
                borderColor: isActiveGoal ? GOAL_HIGHLIGHT_COLOR : colors.border,
                borderWidth: isActiveGoal ? 2 : 1,
              },
            ]}
          >
            <View style={styles.wishHeader}>
              <View style={styles.wishTitleWrap}>
                <Text style={[styles.wishEmoji, { color: colors.text }]}>{wishEmoji}</Text>
                <View style={{ flex: 1 }}>
                  <Text style={[styles.wishTitle, { color: colors.text }]}>{wishTitle}</Text>
                  <Text style={[styles.wishSavedHint, { color: colors.muted }]}>
                    {t("wishlistSavedHint")}
                  </Text>
                </View>
              </View>
              <View
                style={[
                  styles.wishBadge,
                  {
                    borderColor: isDarkTheme ? "rgba(255,255,255,0.18)" : "rgba(0,0,0,0.08)",
                    backgroundColor: isDarkTheme ? "rgba(255,255,255,0.08)" : "rgba(0,0,0,0.04)",
                  },
                ]}
              >
                <Text style={[styles.wishBadgeText, { color: colors.text }]}>{badgeText}</Text>
              </View>
            </View>
            <Text style={[styles.pendingPrice, { color: colors.text }]}>{targetLocal}</Text>
            <View style={styles.wishProgressRow}>
              <View style={[styles.wishProgressTrack, { backgroundColor: colors.border }]}>
                <View
                  style={[
                    styles.wishProgressFill,
                    {
                      width: `${progress * 100}%`,
                      backgroundColor: colors.text,
                    },
                  ]}
                />
              </View>
              <Text style={[styles.wishProgressLabel, { color: colors.muted }]}>{progressLabel}</Text>
            </View>
            <View style={styles.pendingButtons}>
              <TouchableOpacity
                style={[styles.pendingButtonPrimary, { backgroundColor: colors.text }]}
                onPress={() => {
                  if (!isActiveGoal) {
                    onSetActiveGoal?.(goalId);
                  }
                }}
                disabled={isActiveGoal}
              >
                <Text style={[styles.pendingButtonPrimaryText, { color: colors.background }]}>
                  {isActiveGoal ? t("wishlistActive") : t("wishlistSetActive")}
                </Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.pendingButtonSecondary, { borderColor: colors.border }]}
                onPress={() => onRemoveWish(wish.id)}
              >
                <Text style={{ color: colors.muted }}>{t("wishlistRemove")}</Text>
              </TouchableOpacity>
            </View>
          </View>
        );
        return (
          <SwipeableGoalRow
            colors={colors}
            t={t}
            onEdit={onGoalEdit ? () => onGoalEdit(wish) : undefined}
            onDelete={() => onRemoveWish(wish.id)}
            onSwipeOpen={handleSwipeOpen}
            onSwipeClose={handleSwipeClose}
          >
            {renderWithLongPress(wish, cardContent)}
          </SwipeableGoalRow>
        );
      },
      [
        activeGoalId,
        colors,
        currency,
        handleSwipeClose,
        handleSwipeOpen,
        isDarkTheme,
        onGoalEdit,
        onGoalLongPress,
        onRemoveWish,
        primaryGoalIds,
        renderWithLongPress,
        t,
      ]
    );

  const renderChallengeCard = useCallback(
    (challenge) => {
      const actionPalette = challenge.canClaim
        ? { background: SAVE_ACTION_COLOR, text: "#fff" }
        : challenge.canStart
        ? { background: colors.text, text: colors.background }
        : { background: colors.border, text: colors.muted };
      const confirmAccept = () => {
        Alert.alert(
          t("challengeAcceptConfirmTitle"),
          t("challengeAcceptConfirmMessage", { title: challenge.title }),
          [
            { text: t("challengeAcceptConfirmNo"), style: "cancel" },
            {
              text: t("challengeAcceptConfirmYes"),
              style: "default",
              onPress: () => onChallengeAccept?.(challenge.id),
            },
          ]
        );
      };
      const confirmCancel = () => {
        Alert.alert(
          t("challengeCancelConfirmTitle"),
          t("challengeCancelConfirmMessage", { title: challenge.title }),
          [
            { text: t("challengeCancelConfirmNo"), style: "cancel" },
            {
              text: t("challengeCancelConfirmYes"),
              style: "destructive",
              onPress: () => onChallengeCancel?.(challenge.id),
            },
          ]
        );
      };
      const handleActionPress = () => {
        if (challenge.canClaim) {
          onChallengeClaim?.(challenge.id);
        } else if (challenge.canStart) {
          confirmAccept();
        }
      };
      const isActionEnabled = challenge.canClaim || challenge.canStart;
      const isSwipeEnabled = challenge.status === CHALLENGE_STATUS.ACTIVE;
      const isCountMetric = challenge.isCountMetric;
      const isLocked = challenge.isLevelLocked;
      const cardBody = (
        <View
          style={[
            styles.challengeCard,
            { backgroundColor: colors.card, borderColor: colors.border },
            isLocked && styles.challengeCardLocked,
          ]}
          onLayout={(event) => registerChallengeLayout(challenge.id, event)}
        >
          <View
            style={[
              styles.challengeRewardChip,
              styles.challengeRewardChipFloating,
              { backgroundColor: colors.text },
            ]}
          >
            <HealthRewardTokens
              amount={challenge.rewardHealth}
              color={colors.background}
              iconSize={12}
              maxItems={2}
              textSize={10}
              rowStyle={styles.healthRewardTokenRowCompact}
            />
          </View>
          <View style={styles.challengeHeader}>
            <Text style={styles.challengeEmoji}>{challenge.emoji}</Text>
            <View style={{ flex: 1, gap: 4 }}>
              <Text
                style={[styles.challengeTitle, { color: colors.text }]}
                numberOfLines={2}
                adjustsFontSizeToFit
                minimumFontScale={0.9}
              >
                {challenge.title}
              </Text>
              <Text style={[styles.challengeDesc, { color: colors.muted }]} numberOfLines={3}>
                {challenge.description}
              </Text>
              {challenge.potentialSavingsLabel ? (
                <Text style={[styles.challengePotential, { color: colors.text }]}>
                  {t("challengePotentialSavings", { amount: challenge.potentialSavingsLabel })}
                </Text>
              ) : null}
            </View>
          </View>
          <View style={styles.challengeMetaRow}>
            <Text style={[styles.challengeStatus, { color: colors.muted }]}>{challenge.statusLabel}</Text>
            <Text style={[styles.challengeTimer, { color: colors.muted }]}>{challenge.timerLabel}</Text>
          </View>
          {isCountMetric ? (
            <ChallengeProgressDots total={challenge.targetValue} progress={challenge.progressValue} colors={colors} />
          ) : (
            <View style={[styles.challengeProgressBar, { backgroundColor: colors.border }]}>
              <View
                style={[
                  styles.challengeProgressFill,
                  { width: `${challenge.progressPercent * 100}%`, backgroundColor: colors.text },
                ]}
              />
            </View>
          )}
          <Text style={[styles.challengeProgressLabel, { color: colors.muted }]}>{challenge.progressLabel}</Text>
          {isLocked ? (
            <View style={styles.challengeLockRow}>
              <Text style={[styles.challengeLockText, { color: colors.muted }]}>
                {t("challengeLockedLevel", { level: challenge.unlockLevel || playerLevel })}
              </Text>
            </View>
          ) : (
            <TouchableOpacity
              style={[styles.challengeActionButton, { backgroundColor: actionPalette.background }]}
              activeOpacity={0.9}
              disabled={!isActionEnabled}
              onPress={handleActionPress}
            >
              <Text style={[styles.challengeActionText, { color: actionPalette.text }]}>
                {challenge.actionLabel}
              </Text>
            </TouchableOpacity>
          )}
        </View>
      );
      if (isSwipeEnabled) {
        return (
          <SwipeableChallengeCard
            key={challenge.id}
            colors={colors}
            cancelLabel={t("challengeCancelAction")}
            onCancel={confirmCancel}
            onSwipeOpen={handleChallengeSwipeOpen}
            onSwipeClose={handleChallengeSwipeClose}
          >
            {cardBody}
          </SwipeableChallengeCard>
        );
      }
      return (
        <View key={challenge.id}>
          {cardBody}
        </View>
      );
    },
    [
      colors,
      handleChallengeSwipeClose,
      handleChallengeSwipeOpen,
      onChallengeAccept,
      onChallengeCancel,
      onChallengeClaim,
      playerLevel,
      registerChallengeLayout,
      t,
    ]
  );
  const renderDailyChallengeWidget = useCallback(() => {
    if (!dailyChallenge) return null;
    const progress = Math.min(
      Math.max(Number(dailyChallenge.progress) || 0, 0),
      Number(dailyChallenge.target) || 1
    );
    const target = Math.max(Number(dailyChallenge.target) || 1, 1);
    const rewardLabel = dailyChallengeRewardLabel;
    const rewardAmount = Math.max(
      0,
      Number(dailyChallenge.rewardTotal ?? dailyChallenge.rewardBonus) || 0
    );
    const percent = Math.min(Math.max(progress / target, 0), 1);
    const widgetBackground = isDarkTheme ? "rgba(255,255,255,0.05)" : "#FFF7EA";
    const widgetBorder = isDarkTheme ? "rgba(255,255,255,0.15)" : "rgba(0,0,0,0.06)";
    return (
      <View
        style={[
          styles.dailyChallengeWidget,
          { backgroundColor: widgetBackground, borderColor: widgetBorder },
        ]}
      >
        <View
          style={[
            styles.challengeRewardChip,
            styles.challengeRewardChipFloating,
            { backgroundColor: colors.text },
          ]}
        >
          <HealthRewardTokens
            amount={rewardAmount}
            color={colors.background}
            iconSize={12}
            maxItems={2}
            textSize={10}
            rowStyle={styles.healthRewardTokenRowCompact}
          />
        </View>
        <View style={styles.dailyChallengeWidgetHeader}>
          <View style={[styles.dailyChallengeBadge, { borderColor: widgetBorder }]}>
            <Text style={[styles.dailyChallengeBadgeText, { color: colors.text }]}>
              {t("dailyChallengeWidgetBadge")}
            </Text>
          </View>
        </View>
        <View style={styles.dailyChallengeWidgetBody}>
          <View style={styles.dailyChallengeEmojiPill}>
            <Text style={styles.dailyChallengeEmojiText}>{dailyChallenge.emoji || "âœ¨"}</Text>
          </View>
          <View style={{ flex: 1, gap: 2 }}>
            <Text style={[styles.dailyChallengeWidgetTitle, { color: colors.text }]}>
              {t("dailyChallengeWidgetTitle")}
            </Text>
            <Text style={[styles.dailyChallengeWidgetDesc, { color: colors.muted }]}>
              {t("dailyChallengeWidgetDesc", {
                temptation: dailyChallenge.title,
              })}
            </Text>
          </View>
        </View>
        <View style={{ gap: 6 }}>
          <View style={[styles.dailyChallengeProgressBar, { backgroundColor: widgetBorder }]}>
            <View
              style={[
                styles.dailyChallengeProgressFill,
                { width: `${percent * 100}%`, backgroundColor: colors.text },
              ]}
            />
          </View>
          <View style={styles.dailyChallengeWidgetFooter}>
            <Text style={[styles.dailyChallengeProgressLabel, { color: colors.muted }]}>
              {t("dailyChallengeWidgetProgress", { current: `${progress}`, target: `${target}` })}
            </Text>
            <Text style={[styles.dailyChallengeRewardLabel, { color: colors.text }]}>
              {t("dailyChallengeWidgetReward", { amount: rewardLabel })}
            </Text>
          </View>
        </View>
      </View>
    );
  }, [colors, dailyChallenge, dailyChallengeRewardLabel, isDarkTheme, t]);

  const [activeCategoryId, setActiveCategoryId] = useState(null);
  const [categoryModalVisible, setCategoryModalVisible] = useState(false);
  const categoryModalAnim = useRef(new Animated.Value(0)).current;
  const activeCategoryLabel = useMemo(() => {
    if (!activeCategoryId) return "";
    return getImpulseCategoryLabel(activeCategoryId, language);
  }, [activeCategoryId, language]);
  const formatLocalAmount = useCallback(
    (valueUSD = 0) => formatCurrency(convertToCurrency(valueUSD || 0, currency), currency),
    [currency]
  );
  const resolveHistoryCategoryId = useCallback(
    (entry) => {
      const metaCategory =
        entry?.meta?.category || entry?.meta?.impulseCategory || entry?.meta?.impulseCategoryOverride;
      if (metaCategory && IMPULSE_CATEGORY_DEFS[metaCategory]) return metaCategory;
      const templateId = entry?.meta?.templateId;
      if (!templateId || typeof resolveTemplateCard !== "function" || typeof resolveTemptationCategory !== "function") {
        return DEFAULT_IMPULSE_CATEGORY;
      }
      const template = resolveTemplateCard(templateId);
      if (!template) return DEFAULT_IMPULSE_CATEGORY;
      return resolveTemptationCategory(template);
    },
    [resolveTemplateCard, resolveTemptationCategory]
  );
  const budgetMonthKey = getMonthKey(todayTimestamp);
  const [budgetWidgetMonthKey, setBudgetWidgetMonthKey] = useState(() => budgetMonthKey);
  const availableBudgetMonths = useMemo(() => {
    return collectBudgetMonthKeys(incomeEntries, resolvedHistoryEvents, budgetMonthKey);
  }, [budgetMonthKey, incomeEntries, resolvedHistoryEvents]);
  const budgetMonthLabels = useMemo(() => {
    const locale = getFormatLocale(language);
    return availableBudgetMonths.reduce((acc, key) => {
      acc[key] = getMonthLabelForKey(key, locale) || key;
      return acc;
    }, {});
  }, [availableBudgetMonths, language]);
  const budgetMonthOptions = useMemo(
    () => [...availableBudgetMonths].reverse(),
    [availableBudgetMonths]
  );
  useEffect(() => {
    if (!availableBudgetMonths.length) return;
    const fallbackKey = availableBudgetMonths.includes(budgetMonthKey)
      ? budgetMonthKey
      : availableBudgetMonths[0];
    if (!budgetWidgetMonthKey || !availableBudgetMonths.includes(budgetWidgetMonthKey)) {
      setBudgetWidgetMonthKey(fallbackKey);
    }
  }, [availableBudgetMonths, budgetMonthKey, budgetWidgetMonthKey]);
  const budgetMonthlyStats = useMemo(() => {
    const stats = {};
    const ensure = (key) => {
      if (!key) return null;
      if (!stats[key]) {
        stats[key] = { incomeUSD: 0, spendTotalUSD: 0, spendByCategory: {} };
      }
      return stats[key];
    };
    availableBudgetMonths.forEach((key) => {
      ensure(key);
    });
    availableBudgetMonths.forEach((key) => {
      const target = ensure(key);
      if (!target) return;
      target.incomeUSD = getBudgetIncomeForMonth(incomeEntries, key);
    });
    resolvedHistoryEvents.forEach((entry) => {
      if (!entry || entry.kind !== "spend") return;
      const timestamp = Number(entry?.timestamp) || 0;
      if (!timestamp) return;
      const key = getMonthKey(timestamp);
      if (!key) return;
      const target = ensure(key);
      if (!target) return;
      const amount = Math.max(0, Number(entry?.meta?.amountUSD) || 0);
      if (!amount) return;
      target.spendTotalUSD += amount;
      const categoryId = resolveHistoryCategoryId(entry);
      target.spendByCategory[categoryId] =
        (target.spendByCategory[categoryId] || 0) + amount;
    });
    return stats;
  }, [availableBudgetMonths, incomeEntries, resolvedHistoryEvents, resolveHistoryCategoryId]);
  const budgetMonthlyCarryover = useMemo(() => {
    if (!availableBudgetMonths.length) return {};
    const sorted = [...availableBudgetMonths].sort();
    let running = 0;
    const map = {};
    sorted.forEach((key) => {
      map[key] = running;
      const stats = budgetMonthlyStats[key];
      running += (stats?.incomeUSD || 0) - (stats?.spendTotalUSD || 0);
    });
    return map;
  }, [availableBudgetMonths, budgetMonthlyStats]);
  const monthlyIncomeUSD = useMemo(
    () => getBudgetIncomeForMonth(incomeEntries, budgetMonthKey),
    [incomeEntries, budgetMonthKey]
  );
  const budgetSpendDistribution = useMemo(() => {
    const cutoff = Date.now() - DAY_MS * 30;
    const map = {};
    resolvedHistoryEvents.forEach((entry) => {
      if (!entry || entry.kind !== "spend") return;
      if (!entry.timestamp || entry.timestamp < cutoff) return;
      const impulseCategory = resolveHistoryCategoryId(entry);
      const amount = Math.max(0, Number(entry?.meta?.amountUSD) || 0);
      if (!amount) return;
      map[impulseCategory] = (map[impulseCategory] || 0) + amount;
    });
    return map;
  }, [resolvedHistoryEvents, resolveHistoryCategoryId]);
  const budgetMonthSpend = useMemo(() => {
    const map = {};
    let total = 0;
    resolvedHistoryEvents.forEach((entry) => {
      if (!entry || entry.kind !== "spend") return;
      if (!entry.timestamp) return;
      if (getMonthKey(entry.timestamp) !== budgetMonthKey) return;
      const impulseCategory = resolveHistoryCategoryId(entry);
      const amount = Math.max(0, Number(entry?.meta?.amountUSD) || 0);
      if (!amount) return;
      map[impulseCategory] = (map[impulseCategory] || 0) + amount;
      total += amount;
    });
    return { map, total };
  }, [resolvedHistoryEvents, resolveHistoryCategoryId, budgetMonthKey]);
  const budgetCarryoverUSD = useMemo(() => {
    if (!budgetMonthKey) return 0;
    return budgetMonthlyCarryover[budgetMonthKey] || 0;
  }, [budgetMonthKey, budgetMonthlyCarryover]);
  const budgetPlan = useMemo(
    () =>
      buildBudgetPlan({
        incomeUSD: monthlyIncomeUSD,
        carryoverUSD: budgetCarryoverUSD,
        budgetOverrides,
        spendDistribution: budgetSpendDistribution,
        spendToDateByCategory: budgetMonthSpend.map,
        spendToDateTotalUSD: budgetMonthSpend.total,
        decisionStats,
        baselineMonthlyWasteUSD,
        language,
        monthKey: budgetMonthKey,
        autoAllocationEnabled: budgetAutoEnabled,
      }),
    [
      baselineMonthlyWasteUSD,
      budgetCarryoverUSD,
      budgetOverrides,
      budgetSpendDistribution,
      budgetMonthSpend,
      customCategories,
      decisionStats,
      language,
      monthlyIncomeUSD,
      budgetAutoEnabled,
    ]
  );
  const budgetCurrentHasIncome = (budgetPlan?.incomeUSD || 0) > 0;
  const budgetWidgetActiveMonthKey = budgetWidgetMonthKey || budgetMonthKey;
  const budgetWidgetStats = budgetMonthlyStats[budgetWidgetActiveMonthKey] || null;
  const budgetWidgetMonthSpend = useMemo(() => {
    const stats = budgetWidgetStats || {};
    return {
      map: stats.spendByCategory || {},
      total: stats.spendTotalUSD || 0,
    };
  }, [budgetWidgetStats]);
  const budgetWidgetIncomeUSD = budgetWidgetStats?.incomeUSD || 0;
  const budgetWidgetCarryoverUSD = useMemo(
    () => budgetMonthlyCarryover[budgetWidgetActiveMonthKey] || 0,
    [budgetMonthlyCarryover, budgetWidgetActiveMonthKey]
  );
  const budgetWidgetSpendDistribution = useMemo(() => {
    if (budgetWidgetActiveMonthKey === budgetMonthKey) return budgetSpendDistribution;
    return budgetWidgetStats?.spendByCategory || {};
  }, [budgetMonthKey, budgetSpendDistribution, budgetWidgetActiveMonthKey, budgetWidgetStats]);
  const budgetWidgetPlan = useMemo(
    () =>
      buildBudgetPlan({
        incomeUSD: budgetWidgetIncomeUSD,
        carryoverUSD: budgetWidgetCarryoverUSD,
        budgetOverrides,
        spendDistribution: budgetWidgetSpendDistribution,
        spendToDateByCategory: budgetWidgetMonthSpend.map,
        spendToDateTotalUSD: budgetWidgetMonthSpend.total,
        decisionStats,
        baselineMonthlyWasteUSD,
        language,
        monthKey: budgetWidgetActiveMonthKey,
        autoAllocationEnabled: budgetAutoEnabled,
      }),
    [
      baselineMonthlyWasteUSD,
      budgetOverrides,
      budgetWidgetActiveMonthKey,
      budgetWidgetCarryoverUSD,
      budgetWidgetIncomeUSD,
      budgetWidgetMonthSpend,
      budgetWidgetSpendDistribution,
      decisionStats,
      language,
      budgetAutoEnabled,
    ]
  );
  const isBudgetStatsOnly = budgetWidgetActiveMonthKey !== budgetMonthKey;
  const budgetDisplayCategories = useMemo(
    () => (budgetWidgetPlan?.categories || []).filter((entry) => entry.id !== "savings"),
    [budgetWidgetPlan?.categories]
  );
  const budgetWidgetCategories = useMemo(() => {
    const list = [...budgetDisplayCategories];
    if (list.length < 2) return list;
    const locale = getFormatLocale(language);
    const baseSorted = list.sort((a, b) => {
      const aSpent = Number(a?.spentUSD) || 0;
      const bSpent = Number(b?.spentUSD) || 0;
      if (bSpent !== aSpent) return bSpent - aSpent;
      const aLimit = Number(a?.limitUSD) || 0;
      const bLimit = Number(b?.limitUSD) || 0;
      if (bLimit !== aLimit) return bLimit - aLimit;
      const aLabel = a?.label || "";
      const bLabel = b?.label || "";
      return aLabel.localeCompare(bLabel, locale, { sensitivity: "base" });
    });
    const enriched = baseSorted.map((entry, index) => {
      const limit = Number(entry?.limitUSD) || 0;
      const spent = Number(entry?.spentUSD) || 0;
      const ratio = limit > 0 ? spent / limit : spent > 0 ? 1.5 : 0;
      return { entry, index, ratio };
    });
    const hasProgress = enriched.some((item) => item.ratio > 0);
    if (!hasProgress) return baseSorted;
    enriched.sort((a, b) => {
      if (b.ratio !== a.ratio) return b.ratio - a.ratio;
      return a.index - b.index;
    });
    return enriched.map((item) => item.entry);
  }, [budgetDisplayCategories, language]);
  const budgetHasIncome = (budgetPlan?.incomeUSD || 0) > 0;
  const budgetWidgetShowStats = isBudgetStatsOnly || budgetHasIncome;
  const budgetWidgetShowActions = !isBudgetStatsOnly;
  useEffect(() => {
    if (!resolvedBudgetSpeechDataRef) {
      return;
    }
    if (!budgetCurrentHasIncome) {
      resolvedBudgetSpeechDataRef.current = null;
      return;
    }
    const entries = (budgetPlan?.categories || [])
      .filter((entry) => entry.id !== "savings" && (Number(entry.limitUSD) || 0) > 0)
      .map((entry) => {
        const limit = Number(entry.limitUSD) || 0;
        const spent = Number(entry.spentUSD) || 0;
        const remaining = limit - spent;
        const over = remaining < -0.01;
        const low = !over && limit > 0 && remaining / limit <= BUDGET_SPEECH_LOW_THRESHOLD;
        return {
          id: entry.id,
          label: entry.label || getBudgetCategoryLabel(entry.id, language),
          remainingValue: remaining,
          remainingLabel: formatLocalAmount(Math.max(0, remaining)),
          overLabel: over ? formatLocalAmount(Math.abs(remaining)) : "",
          status: over ? "over" : low ? "low" : "ok",
          essential: BUDGET_SPEECH_ESSENTIAL_IDS.has(entry.id),
        };
      })
      .filter((entry) => entry.label);
    if (!entries.length) {
      resolvedBudgetSpeechDataRef.current = null;
      return;
    }
    const monthRemainingValue = Number(budgetPlan?.remainingUSD) || 0;
    resolvedBudgetSpeechDataRef.current = {
      hasIncome: true,
      monthRemainingValue,
      monthRemainingLabel: formatLocalAmount(Math.max(0, monthRemainingValue)),
      monthOverLabel: formatLocalAmount(Math.abs(Math.min(0, monthRemainingValue))),
      monthLabel: budgetPlan?.monthLabel || "",
      overCategories: entries.filter((entry) => entry.status === "over"),
      lowCategories: entries.filter((entry) => entry.status === "low"),
      okCategories: entries.filter((entry) => entry.status === "ok"),
    };
  }, [budgetCurrentHasIncome, budgetPlan, resolvedBudgetSpeechDataRef, formatLocalAmount, language]);
  const budgetIncomeLabel = useMemo(
    () => formatLocalAmount(budgetWidgetPlan?.incomeUSD || 0),
    [budgetWidgetPlan?.incomeUSD, formatLocalAmount]
  );
  const budgetSavingsBalanceUSD = useMemo(
    () => Math.max(0, Number(savedTotalUSD) || 0),
    [savedTotalUSD]
  );
  const budgetSavingsLabel = useMemo(() => {
    return formatLocalAmount(budgetSavingsBalanceUSD);
  }, [budgetSavingsBalanceUSD, formatLocalAmount]);
  const budgetRemainingLabel = useMemo(
    () => formatLocalAmount(Math.abs(budgetWidgetPlan?.remainingUSD || 0)),
    [budgetWidgetPlan?.remainingUSD, formatLocalAmount]
  );
  const budgetRemainingNegative = (budgetWidgetPlan?.remainingUSD || 0) < -0.01;
  const budgetPlannedUSD = useMemo(
    () => (budgetWidgetPlan?.incomeUSD || 0) - (budgetWidgetPlan?.allocatedTotalUSD || 0),
    [budgetWidgetPlan?.incomeUSD, budgetWidgetPlan?.allocatedTotalUSD]
  );
  const budgetPlannedLabel = useMemo(
    () => formatLocalAmount(Math.abs(budgetPlannedUSD || 0)),
    [budgetPlannedUSD, formatLocalAmount]
  );
  const budgetPlannedNegative = (budgetPlannedUSD || 0) < -0.01;
  const budgetPlannedIsZero = Math.abs(budgetPlannedUSD || 0) < 0.01;
  const handleBudgetWidgetPress = useCallback(() => {
    if (budgetWidgetShowStats) {
      openBudgetModal();
      return;
    }
    onIncomeEntryOpen?.("widget");
  }, [budgetWidgetShowStats, onIncomeEntryOpen, openBudgetModal]);
  const categoryHistoryEntries = useMemo(() => {
    if (!activeCategoryId) return [];
    const filtered = resolvedHistoryEvents.filter((entry) => {
      if (!entry || (entry.kind !== "refuse_spend" && entry.kind !== "spend")) return false;
      if (budgetWidgetActiveMonthKey && getMonthKey(entry.timestamp) !== budgetWidgetActiveMonthKey) {
        return false;
      }
      return resolveHistoryCategoryId(entry) === activeCategoryId;
    });
    return filtered.sort((a, b) => (b?.timestamp || 0) - (a?.timestamp || 0));
  }, [activeCategoryId, budgetWidgetActiveMonthKey, resolvedHistoryEvents, resolveHistoryCategoryId]);
  const locale = useMemo(() => getFormatLocale(language), [language]);
  const describeCategoryHistory = useCallback(
    (entry) => {
      if (!entry) return t("historyUnknown");
      const title = entry?.meta?.title || t("historyUnknown");
      if (entry.kind === "refuse_spend") {
        return t("historyRefuseSpend", { title, amount: formatLocalAmount(entry.meta?.amountUSD) });
      }
      if (entry.kind === "spend") {
        return t("historySpend", { title, amount: formatLocalAmount(entry.meta?.amountUSD) });
      }
      return t("historyUnknown");
    },
    [formatLocalAmount, t]
  );
  const formatCategoryHistoryMeta = useCallback(
    (entry) => {
      if (!entry?.timestamp) return "";
      try {
        const date = new Date(entry.timestamp);
        const dateLabel = date.toLocaleDateString(locale, { day: "numeric", month: "short" });
        const timeLabel = date.toLocaleTimeString(locale, { hour: "2-digit", minute: "2-digit" });
        return t("historyTimestamp", { date: dateLabel, time: timeLabel });
      } catch {
        return "";
      }
    },
    [locale, t]
  );
  const openCategoryHistory = useCallback((categoryId) => {
    if (!categoryId) return;
    setActiveCategoryId(categoryId);
    setCategoryModalVisible(true);
  }, []);
  const closeCategoryHistory = useCallback(() => {
    if (!categoryModalVisible) {
      setActiveCategoryId(null);
      return;
    }
    Animated.timing(categoryModalAnim, {
      toValue: 0,
      duration: 180,
      easing: Easing.in(Easing.cubic),
      useNativeDriver: true,
    }).start(({ finished }) => {
      if (finished) {
        setCategoryModalVisible(false);
        setActiveCategoryId(null);
      }
    });
  }, [categoryModalAnim, categoryModalVisible]);
  const [categoryModalHeight, setCategoryModalHeight] = useState(0);
  const categoryModalOpacity = useMemo(() => {
    const screenHeight = Dimensions.get("window").height || 1;
    const ratio = Math.max(0, Math.min((categoryModalHeight || 0) / screenHeight, 1));
    return Math.min(0.5, Math.max(0.22, 0.18 + ratio * 0.45));
  }, [categoryModalHeight]);
  const categoryModalBackdropOpacity = useMemo(
    () => Animated.multiply(categoryModalAnim, categoryModalOpacity),
    [categoryModalAnim, categoryModalOpacity]
  );
  const categoryModalCardScale = useMemo(
    () => categoryModalAnim.interpolate({ inputRange: [0, 1], outputRange: [0.94, 1] }),
    [categoryModalAnim]
  );
  const categoryModalCardTranslate = useMemo(
    () => categoryModalAnim.interpolate({ inputRange: [0, 1], outputRange: [18, 0] }),
    [categoryModalAnim]
  );
  const [progressAnalyticsExpanded, setProgressAnalyticsExpanded] = useState(false);
  const progressAnalyticsAnim = useRef(new Animated.Value(0)).current;
  const [budgetModalVisible, setBudgetModalVisible] = useState(false);
  const [budgetModalMonthKey, setBudgetModalMonthKey] = useState(
    () => budgetWidgetMonthKey || budgetMonthKey
  );
  const budgetModalAnim = useRef(new Animated.Value(0)).current;
  const [budgetDraft, setBudgetDraft] = useState({});
  const [budgetManualPrompt, setBudgetManualPrompt] = useState({
    visible: false,
    categoryId: null,
    value: "",
    error: false,
  });
  const budgetCommitTimersRef = useRef({});
  const budgetCommitValuesRef = useRef({});
  const budgetDraftRef = useRef(budgetDraft);
  useEffect(() => {
    budgetDraftRef.current = budgetDraft;
  }, [budgetDraft]);
  useEffect(() => {
    if (!availableBudgetMonths.length) return;
    const fallbackKey = availableBudgetMonths.includes(budgetWidgetMonthKey)
      ? budgetWidgetMonthKey
      : availableBudgetMonths.includes(budgetMonthKey)
      ? budgetMonthKey
      : availableBudgetMonths[0];
    if (!budgetModalMonthKey || !availableBudgetMonths.includes(budgetModalMonthKey)) {
      setBudgetModalMonthKey(fallbackKey);
    }
  }, [availableBudgetMonths, budgetModalMonthKey, budgetMonthKey, budgetWidgetMonthKey]);
  const budgetModalActiveMonthKey =
    budgetModalMonthKey || budgetWidgetMonthKey || budgetMonthKey;
  const budgetModalStatsOnly = budgetModalActiveMonthKey !== budgetMonthKey;
  const budgetModalMonthSpend = useMemo(() => {
    const stats = budgetMonthlyStats[budgetModalActiveMonthKey];
    return {
      map: stats?.spendByCategory || {},
      total: stats?.spendTotalUSD || 0,
    };
  }, [budgetModalActiveMonthKey, budgetMonthlyStats]);
  const budgetModalIncomeUSD = useMemo(() => {
    const stats = budgetMonthlyStats[budgetModalActiveMonthKey];
    return stats?.incomeUSD || 0;
  }, [budgetModalActiveMonthKey, budgetMonthlyStats]);
  const budgetModalCarryoverUSD = useMemo(
    () => budgetMonthlyCarryover[budgetModalActiveMonthKey] || 0,
    [budgetModalActiveMonthKey, budgetMonthlyCarryover]
  );
  const budgetModalSpendDistribution = useMemo(() => {
    if (budgetModalActiveMonthKey === budgetMonthKey) return budgetSpendDistribution;
    const stats = budgetMonthlyStats[budgetModalActiveMonthKey];
    return stats?.spendByCategory || {};
  }, [budgetModalActiveMonthKey, budgetMonthKey, budgetMonthlyStats, budgetSpendDistribution]);
  const budgetModalPlan = useMemo(
    () =>
      buildBudgetPlan({
        incomeUSD: budgetModalIncomeUSD,
        carryoverUSD: budgetModalCarryoverUSD,
        budgetOverrides,
        spendDistribution: budgetModalSpendDistribution,
        spendToDateByCategory: budgetModalMonthSpend.map,
        spendToDateTotalUSD: budgetModalMonthSpend.total,
        decisionStats,
        baselineMonthlyWasteUSD,
        language,
        monthKey: budgetModalActiveMonthKey,
        autoAllocationEnabled: budgetAutoEnabled,
      }),
    [
      baselineMonthlyWasteUSD,
      budgetModalActiveMonthKey,
      budgetModalCarryoverUSD,
      budgetModalIncomeUSD,
      budgetModalMonthSpend,
      budgetModalSpendDistribution,
      budgetOverrides,
      decisionStats,
      language,
      budgetAutoEnabled,
    ]
  );
  const budgetModalDisplayCategories = useMemo(
    () => (budgetModalPlan?.categories || []).filter((entry) => entry.id !== "savings"),
    [budgetModalPlan?.categories]
  );
  const budgetModalPlanMap = useMemo(() => {
    const map = {};
    (budgetModalPlan?.categories || []).forEach((entry) => {
      map[entry.id] = entry;
    });
    return map;
  }, [budgetModalPlan?.categories]);
  const budgetModalIncomeLabel = useMemo(
    () => formatLocalAmount(budgetModalPlan?.incomeUSD || 0),
    [budgetModalPlan?.incomeUSD, formatLocalAmount]
  );
  const budgetModalRemainingLabel = useMemo(
    () => formatLocalAmount(Math.abs(budgetModalPlan?.remainingUSD || 0)),
    [budgetModalPlan?.remainingUSD, formatLocalAmount]
  );
  const budgetModalRemainingNegative = (budgetModalPlan?.remainingUSD || 0) < -0.01;
  const budgetModalPlannedUSD = useMemo(
    () => (budgetModalPlan?.incomeUSD || 0) - (budgetModalPlan?.allocatedTotalUSD || 0),
    [budgetModalPlan?.incomeUSD, budgetModalPlan?.allocatedTotalUSD]
  );
  const budgetModalPlannedLabel = useMemo(
    () => formatLocalAmount(Math.abs(budgetModalPlannedUSD || 0)),
    [budgetModalPlannedUSD, formatLocalAmount]
  );
  const budgetModalPlannedNegative = (budgetModalPlannedUSD || 0) < -0.01;
  const budgetModalPlannedIsZero = Math.abs(budgetModalPlannedUSD || 0) < 0.01;
  useEffect(() => {
    if (!budgetModalVisible) return;
    const nextDraft = {};
    budgetModalDisplayCategories.forEach((entry) => {
      nextDraft[entry.id] = entry.limitUSD || 0;
    });
    setBudgetDraft(nextDraft);
  }, [budgetModalDisplayCategories, budgetModalVisible]);
  useEffect(() => {
    return () => {
      Object.values(budgetCommitTimersRef.current || {}).forEach((timer) => clearTimeout(timer));
      budgetCommitTimersRef.current = {};
    };
  }, []);
  const openBudgetModal = useCallback(() => {
    if (!budgetAutoEnabled) {
      onBudgetAutoLocked?.();
    }
    setBudgetModalMonthKey(budgetWidgetMonthKey || budgetMonthKey);
    setBudgetModalVisible(true);
  }, [budgetAutoEnabled, budgetMonthKey, budgetWidgetMonthKey, onBudgetAutoLocked]);
  const closeBudgetModal = useCallback(() => {
    setBudgetModalVisible(false);
    setBudgetManualPrompt((prev) => (prev.visible ? { ...prev, visible: false, error: false } : prev));
  }, []);
  const confirmBudgetModal = useCallback(() => {
    if (budgetModalActiveMonthKey) {
      setBudgetWidgetMonthKey(budgetModalActiveMonthKey);
    }
    closeBudgetModal();
  }, [budgetModalActiveMonthKey, closeBudgetModal]);
  const handleBudgetDraftChange = useCallback((categoryId, valueUSD) => {
    if (!categoryId) return;
    const normalized = Math.max(0, Number(valueUSD) || 0);
    setBudgetDraft((prev) => {
      const next = { ...(prev || {}), [categoryId]: normalized };
      budgetDraftRef.current = next;
      return next;
    });
  }, []);
  const promptBudgetLimitCommit = useCallback(
    (categoryId, valueUSD, source = "budget_modal") => {
      if (!categoryId) return;
      const normalized = Math.max(0, Number(valueUSD) || 0);
      const current = budgetModalPlanMap?.[categoryId]?.limitUSD || 0;
      if (Math.abs(normalized - current) < 0.01) return;
      const label = getBudgetCategoryLabel(categoryId, language);
      const amountLabel = formatLocalAmount(normalized);
      Alert.alert(
        t("budgetApplyTitle"),
        t("budgetApplyMessage", { category: label, amount: amountLabel }),
        [
          {
            text: t("budgetApplyCancel"),
            style: "cancel",
            onPress: () => {
              setBudgetDraft((prev) => {
                const next = { ...(prev || {}) };
                next[categoryId] = current;
                budgetDraftRef.current = next;
                return next;
              });
            },
          },
          {
            text: t("budgetApplyConfirm"),
            style: "default",
            onPress: () => {
              onBudgetOverrideChange(categoryId, normalized);
              logEvent("budget_category_limit_updated", {
                category_id: categoryId,
                limit_usd: normalized,
                previous_limit_usd: current,
                source,
              });
              triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
            },
          },
        ]
      );
    },
    [budgetModalPlanMap, formatLocalAmount, language, logEvent, onBudgetOverrideChange, t]
  );
  const handleBudgetLimitCommit = useCallback(
    (categoryId, valueUSD, options = {}) => {
      if (!categoryId) return;
      const normalized = Math.max(0, Number(valueUSD) || 0);
      const source = options.source || (options.immediate ? "manual_prompt" : "budget_modal");
      if (options.immediate) {
        promptBudgetLimitCommit(categoryId, normalized, source);
        return;
      }
      budgetCommitValuesRef.current[categoryId] = normalized;
      if (budgetCommitTimersRef.current[categoryId]) {
        clearTimeout(budgetCommitTimersRef.current[categoryId]);
      }
      budgetCommitTimersRef.current[categoryId] = setTimeout(() => {
        const pendingValue = budgetCommitValuesRef.current[categoryId];
        promptBudgetLimitCommit(categoryId, pendingValue, source);
      }, 450);
    },
    [promptBudgetLimitCommit]
  );
  const budgetManualCategoryLabel = useMemo(() => {
    if (!budgetManualPrompt.categoryId) return "";
    return getBudgetCategoryLabel(budgetManualPrompt.categoryId, language);
  }, [budgetManualPrompt.categoryId, language]);
  const openBudgetManualPrompt = useCallback(
    (categoryId, currentUSD = 0) => {
      if (!categoryId) return;
      const currencyCode = currency || DEFAULT_PROFILE.currency;
      const localValue = formatNumberInputValue(convertToCurrency(currentUSD || 0, currencyCode));
      setBudgetManualPrompt({
        visible: true,
        categoryId,
        value: localValue,
        error: false,
      });
    },
    [currency]
  );
  const closeBudgetManualPrompt = useCallback(() => {
    setBudgetManualPrompt((prev) => ({ ...prev, visible: false, error: false }));
  }, []);
  const handleBudgetManualChange = useCallback((text) => {
    setBudgetManualPrompt((prev) => ({ ...prev, value: text, error: false }));
  }, []);
  const handleBudgetManualSubmit = useCallback(() => {
    const trimmed = (budgetManualPrompt.value || "").trim();
    const parsedLocal = parseNumberInputValue(trimmed);
    if (!Number.isFinite(parsedLocal) || parsedLocal < 0) {
      setBudgetManualPrompt((prev) => ({ ...prev, error: true }));
      return;
    }
    const categoryId = budgetManualPrompt.categoryId;
    const amountUSD = convertFromCurrency(parsedLocal, currency || DEFAULT_PROFILE.currency);
    closeBudgetManualPrompt();
    if (!categoryId) return;
    handleBudgetDraftChange(categoryId, amountUSD);
    handleBudgetLimitCommit(categoryId, amountUSD, { immediate: true, source: "manual_prompt" });
  }, [
    budgetManualPrompt.categoryId,
    budgetManualPrompt.value,
    closeBudgetManualPrompt,
    currency,
    handleBudgetDraftChange,
    handleBudgetLimitCommit,
  ]);
  const toggleProgressAnalytics = useCallback(() => {
    runLayoutAnimation();
    setProgressAnalyticsExpanded((prev) => {
      const next = !prev;
      Animated.timing(progressAnalyticsAnim, {
        toValue: next ? 1 : 0,
        duration: 200,
        easing: Easing.out(Easing.cubic),
        useNativeDriver: true,
      }).start();
      return next;
    });
  }, [progressAnalyticsAnim]);
  useEffect(() => {
    if (!budgetModalVisible) {
      budgetModalAnim.setValue(0);
      return;
    }
    budgetModalAnim.setValue(0);
    Animated.timing(budgetModalAnim, {
      toValue: 1,
      duration: 220,
      easing: Easing.out(Easing.cubic),
      useNativeDriver: true,
    }).start();
  }, [budgetModalAnim, budgetModalVisible]);
  useEffect(() => {
    if (!categoryModalVisible) {
      categoryModalAnim.setValue(0);
      return;
    }
    categoryModalAnim.setValue(0);
    Animated.timing(categoryModalAnim, {
      toValue: 1,
      duration: 240,
      easing: Easing.out(Easing.cubic),
      useNativeDriver: true,
    }).start();
  }, [categoryModalAnim, categoryModalVisible]);
  const progressAnalyticsTotals = useMemo(() => {
    return categoryData.categories.reduce(
      (acc, entry) => {
        acc.save += entry.save || 0;
        acc.spend += entry.spend || 0;
        return acc;
      },
      { save: 0, spend: 0 }
    );
  }, [categoryData.categories]);

  return (
    <>
      <ScrollView
        ref={scrollRef}
        style={[styles.container, { backgroundColor: colors.background }]}
        contentContainerStyle={{ paddingBottom: 200, gap: 16 }}
        showsVerticalScrollIndicator={false}
        onScrollBeginDrag={closeChallengeSwipe}
      >
      <View>
        <Text style={[styles.header, { color: colors.text }]}>{t("wishlistTitle")}</Text>
        <Text style={[styles.purchasesSubtitle, { color: colors.muted }]}>
          {t("progressTabSubtitle")}
        </Text>
      </View>

      <View
        style={[styles.budgetWidgetCard, { backgroundColor: colors.card, borderColor: colors.border }]}
        onLayout={onBudgetWidgetLayout || undefined}
      >
        <Pressable style={styles.budgetWidgetTap} onPress={handleBudgetWidgetPress}>
          <View style={styles.budgetWidgetHeader}>
            <View style={styles.budgetWidgetTitleBlock}>
              <Text style={[styles.budgetWidgetTitle, { color: colors.text }]}>
                {t("budgetWidgetTitle")}
              </Text>
              <Text style={[styles.budgetWidgetSubtitle, { color: colors.muted }]}>
                {budgetWidgetPlan?.monthLabel
                  ? t("budgetWidgetMonthLabel", { month: budgetWidgetPlan.monthLabel })
                  : t("budgetWidgetSubtitle")}
              </Text>
            </View>
            {budgetWidgetShowActions ? (
              <View
                style={[
                  styles.budgetWidgetEditChip,
                  { borderColor: colors.border, backgroundColor: colors.background },
                ]}
              >
                <Text style={[styles.budgetWidgetEditChipText, { color: colors.muted }]}>
                  {t("budgetEditChip")}
                </Text>
              </View>
            ) : null}
          </View>
          {budgetWidgetShowStats ? (
            <View style={styles.budgetWidgetStatsRow}>
              <View style={styles.budgetWidgetStat}>
                <Text style={[styles.budgetWidgetStatLabel, { color: colors.muted }]}>
                  {t("budgetIncomeLabel")}
                </Text>
                <Text
                  style={[styles.budgetWidgetStatValue, { color: colors.text }]}
                  numberOfLines={1}
                  adjustsFontSizeToFit
                  minimumFontScale={0.85}
                >
                  {budgetIncomeLabel}
                </Text>
              </View>
              <View style={styles.budgetWidgetStat}>
                <Text style={[styles.budgetWidgetStatLabel, { color: colors.muted }]}>
                  {t("budgetSavingsLabel")}
                </Text>
                <Text
                  style={[styles.budgetWidgetStatValue, { color: SAVE_ACTION_COLOR }]}
                  numberOfLines={1}
                  adjustsFontSizeToFit
                  minimumFontScale={0.85}
                >
                  {budgetSavingsLabel}
                </Text>
              </View>
              <View style={styles.budgetWidgetStat}>
                <Text style={[styles.budgetWidgetStatLabel, { color: colors.muted }]}>
                  {t("budgetPlannedLabel")}
                </Text>
                <Text
                  style={[
                    styles.budgetWidgetStatValue,
                    {
                      color: budgetPlannedIsZero
                        ? SAVE_ACTION_COLOR
                        : budgetPlannedNegative
                        ? "#E15555"
                        : colors.text,
                    },
                  ]}
                  numberOfLines={1}
                  adjustsFontSizeToFit
                  minimumFontScale={0.85}
                >
                  {budgetPlannedIsZero
                    ? "âœ“"
                    : budgetPlannedNegative
                    ? `-${budgetPlannedLabel}`
                    : budgetPlannedLabel}
                </Text>
              </View>
              <View style={styles.budgetWidgetStat}>
                <Text style={[styles.budgetWidgetStatLabel, { color: colors.muted }]}>
                  {t("budgetRemainingLabel")}
                </Text>
                <Text
                  style={[
                    styles.budgetWidgetStatValue,
                    { color: budgetRemainingNegative ? "#E15555" : colors.text },
                  ]}
                  numberOfLines={1}
                  adjustsFontSizeToFit
                  minimumFontScale={0.85}
                >
                  {budgetRemainingNegative ? `-${budgetRemainingLabel}` : budgetRemainingLabel}
                </Text>
              </View>
            </View>
          ) : null}
        </Pressable>
        {budgetWidgetShowStats ? (
          <>
            <ScrollView
              style={[styles.budgetWidgetList, { maxHeight: categoryListHeight }]}
              contentContainerStyle={styles.budgetWidgetListContent}
              showsVerticalScrollIndicator={false}
              nestedScrollEnabled
            >
              <View style={styles.budgetWidgetListHeader}>
                <Text
                  style={[styles.budgetWidgetListHeaderText, { color: colors.muted }]}
                  numberOfLines={1}
                >
                  {t("budgetWidgetCanSpendLabel")}
                </Text>
              </View>
              {budgetWidgetCategories.map((entry) => {
                const limitUSD = entry.limitUSD || 0;
                const spentUSD = entry.spentUSD || 0;
                const ratio = limitUSD > 0 ? spentUSD / limitUSD : spentUSD > 0 ? 1.5 : 0;
                const spendPercent = limitUSD > 0 ? Math.min(Math.max(ratio, 0), 1) : spentUSD > 0 ? 1 : 0;
                const overflowPercent = limitUSD > 0 ? Math.min(Math.max(ratio - 1, 0), 1) : spentUSD > 0 ? 1 : 0;
                const remainingUSD = limitUSD - spentUSD;
                const remainingNegative = remainingUSD < -0.01;
                const isLimitLow =
                  limitUSD > 0 && remainingUSD >= 0 && remainingUSD / limitUSD <= BUDGET_CARD_LOW_THRESHOLD;
                return (
                  <TouchableOpacity
                    key={entry.id}
                    style={styles.budgetWidgetRow}
                    activeOpacity={0.86}
                    onPress={() => {
                      logEvent("budget_category_history_opened", { category_id: entry.id });
                      openCategoryHistory(entry.id);
                    }}
                  >
                    <View style={styles.budgetWidgetRowHeader}>
                      <View style={styles.budgetWidgetRowTitle}>
                        <Text style={styles.budgetWidgetRowEmoji}>{entry.emoji}</Text>
                        <Text
                          style={[styles.budgetWidgetRowLabel, { color: colors.text }]}
                          numberOfLines={1}
                        >
                          {entry.label}
                        </Text>
                      </View>
                      <Text
                        style={[
                          styles.budgetWidgetRowValue,
                          { color: remainingNegative ? SPEND_ACTION_COLOR : colors.text },
                        ]}
                      >
                        {formatLocalAmount(remainingUSD)}
                      </Text>
                    </View>
                    <View style={[styles.budgetWidgetRowTrack, { backgroundColor: colors.border }]}>
                      <View
                        style={[
                          styles.budgetWidgetRowFill,
                          {
                            width: `${spendPercent > 0 ? Math.max(6, spendPercent * 100) : 0}%`,
                            backgroundColor: isLimitLow ? budgetLimitWarningColor : SAVE_ACTION_COLOR,
                          },
                        ]}
                      />
                      {overflowPercent > 0 ? (
                        <View
                          style={[
                            styles.budgetWidgetRowOverflow,
                            {
                              width: `${Math.max(6, overflowPercent * 100)}%`,
                              backgroundColor: SPEND_ACTION_COLOR,
                            },
                          ]}
                        />
                      ) : null}
                    </View>
                  </TouchableOpacity>
                );
              })}
            </ScrollView>
            {budgetWidgetShowActions ? (
              <Pressable onPress={handleBudgetWidgetPress}>
                <Text style={[styles.budgetWidgetHint, { color: colors.muted }]}>
                  {t("budgetWidgetHint")}
                </Text>
              </Pressable>
            ) : null}
          </>
        ) : (
          <Pressable style={styles.budgetWidgetEmpty} onPress={handleBudgetWidgetPress}>
            <Text style={[styles.budgetWidgetEmptyTitle, { color: colors.text }]}>
              {t("budgetEmptyTitle")}
            </Text>
            <Text style={[styles.budgetWidgetEmptySubtitle, { color: colors.muted }]}>
              {t("budgetEmptySubtitle")}
            </Text>
            <TouchableOpacity
              style={[styles.budgetWidgetEmptyButton, { backgroundColor: colors.text }]}
              activeOpacity={0.9}
              onPress={() => onIncomeEntryOpen?.("widget")}
            >
              <Text style={[styles.budgetWidgetEmptyButtonText, { color: colors.background }]}>
                {t("budgetAddIncome")}
              </Text>
            </TouchableOpacity>
          </Pressable>
        )}
      </View>

      <View style={styles.progressHeroGrid}>
        <View style={[styles.progressGoalCard, { backgroundColor: colors.card, borderColor: colors.border }]}>
          <View style={styles.progressGoalHeader}>
            <Text style={[styles.progressGoalTitle, { color: colors.text }]}>{t("progressGoalTitle")}</Text>
            <Text style={styles.progressGoalEmoji}>{goalEmoji}</Text>
          </View>
          <Text style={[styles.progressGoalName, { color: colors.text }]} numberOfLines={2}>
            {goalTitle}
          </Text>
          <Text style={[styles.progressGoalMeta, { color: colors.muted }]}>
            {t("progressGoalRemaining", { amount: goalRemainingLabel })}
          </Text>
          <View style={styles.progressGoalRingRow}>
            <View style={styles.progressGoalRingWrap}>
              <ProgressRing
                size={76}
                progress={goalProgress}
                trackColor={isDarkTheme ? "rgba(255,255,255,0.1)" : "rgba(0,0,0,0.08)"}
                progressColor={colors.text}
              />
              <View style={styles.progressGoalRingInner} pointerEvents="none">
                <Text
                  style={[styles.progressGoalTarget, { color: colors.text }]}
                  numberOfLines={1}
                  adjustsFontSizeToFit
                  minimumFontScale={0.6}
                >
                  {goalTargetLabel}
                </Text>
              </View>
            </View>
            <View style={styles.progressGoalRingText}>
              <Text
                style={[styles.progressGoalPercent, { color: colors.text }]}
                numberOfLines={1}
                adjustsFontSizeToFit
                minimumFontScale={0.7}
              >
                {`${Math.round(goalProgress * 100)}%`}
              </Text>
            </View>
          </View>
        </View>
        <View style={[styles.progressCoinCard, { backgroundColor: colors.card, borderColor: colors.border }]}>
          <View style={styles.progressCoinHeader}>
            <Text style={[styles.progressCoinTitle, { color: colors.text }]}>{t("freeDayHealthTitle")}</Text>
            <Text style={styles.progressCoinEmoji}>ðŸª™</Text>
          </View>
          <Text style={[styles.progressCoinValue, { color: colors.text }]}>{healthPoints}</Text>
          <Text style={[styles.progressCoinSubtitle, { color: colors.muted }]}>
            {t("freeDayHealthSubtitle")}
          </Text>
          {hasCoinInventory ? (
            <View style={styles.progressCoinRow}>
              {coinEntries.map((entry) =>
                entry.count ? (
                  <View
                    key={entry.id}
                    style={[
                      styles.progressCoinBadge,
                      { borderColor: colors.border, backgroundColor: colors.background },
                    ]}
                  >
                    <Image source={entry.asset} style={styles.progressCoinImage} />
                    <Text style={[styles.progressCoinCount, { color: colors.text }]}>Ã—{entry.count}</Text>
                  </View>
                ) : null
              )}
            </View>
          ) : null}
        </View>
      </View>

      <WeeklyCardWrap
        style={[
          styles.progressWeeklyCard,
          { backgroundColor: weeklyCardPalette.background, borderColor: weeklyCardPalette.border },
        ]}
        {...(onWeeklySpendPress ? { activeOpacity: 0.9, onPress: onWeeklySpendPress } : {})}
      >
        <Text style={[styles.progressWeeklyTitle, { color: weeklyCardPalette.text }]}>
          {t("heroDailyTitle")}
        </Text>
        {weeklyTrend && (
          <View style={styles.weeklyTrendRow}>
            {weeklyTrend.savings && (
              <View style={styles.weeklyTrendItem}>
                <Text style={[styles.weeklyTrendLabel, { color: weeklyCardPalette.subtext }]}>
                  {t("heroWeeklySavingsDelta")}
                </Text>
                <Text style={[styles.weeklyTrendValue, { color: weeklyTrend.savings.color }]}>
                  {weeklyTrend.savings.symbol} {weeklyTrend.savings.label}
                </Text>
              </View>
            )}
            {weeklyTrend.spending && (
              <View style={styles.weeklyTrendItem}>
                <Text style={[styles.weeklyTrendLabel, { color: weeklyCardPalette.subtext }]}>
                  {t("heroWeeklySpendingDelta")}
                </Text>
                <Text style={[styles.weeklyTrendValue, { color: weeklyTrend.spending.color }]}>
                  {weeklyTrend.spending.symbol} {weeklyTrend.spending.label}
                </Text>
              </View>
            )}
          </View>
        )}
        {weeklyHasData ? (
          <View style={styles.savedHeroBars}>
            {weeklyDailySavings.map((day) => (
              <View key={day.key} style={styles.savedHeroBarItem}>
                <View style={styles.savedHeroBarAmountWrap}>
                  {day.amountValueLabel ? (
                    <View style={styles.savedHeroBarAmountBlock}>
                      <Text
                        style={[styles.savedHeroBarAmount, { color: weeklyCardPalette.text }]}
                        numberOfLines={1}
                      >
                        {day.amountValueLabel}
                        {day.amountCurrencySymbol ? (
                          <Text
                            style={[styles.savedHeroBarCurrency, { color: weeklyCardPalette.text }]}
                          >
                            {"\u00A0"}
                            {day.amountCurrencySymbol}
                          </Text>
                        ) : null}
                      </Text>
                    </View>
                  ) : null}
                  {day.spendValueLabel ? (
                    <View style={styles.savedHeroBarAmountBlock}>
                      <Text
                        style={[styles.savedHeroBarSpend, { color: weeklyCardPalette.spend }]}
                        numberOfLines={1}
                      >
                        {day.spendValueLabel}
                        {day.spendCurrencySymbol ? (
                          <Text
                            style={[styles.savedHeroBarCurrency, { color: weeklyCardPalette.spend }]}
                          >
                            {"\u00A0"}
                            {day.spendCurrencySymbol}
                          </Text>
                        ) : null}
                      </Text>
                    </View>
                  ) : null}
                </View>
                <View style={[styles.savedHeroBarTrack, { backgroundColor: weeklyCardPalette.track }]}>
                  <View
                    style={[
                      styles.savedHeroBarColumn,
                      {
                        height: `${day.percent}%`,
                        backgroundColor: weeklyCardPalette.save,
                      },
                    ]}
                  />
                  {day.spendPercent > 0 ? (
                    <View
                      style={[
                        styles.savedHeroBarColumnSpend,
                        {
                          height: `${day.spendPercent}%`,
                          backgroundColor: weeklyCardPalette.spend,
                          opacity: day.spendOverflow ? 0.95 : 0.8,
                        },
                      ]}
                    />
                  ) : null}
                </View>
                <Text style={[styles.savedHeroBarLabel, { color: weeklyCardPalette.subtext }]}>
                  {day.label}
                </Text>
              </View>
            ))}
          </View>
        ) : (
          <Text style={[styles.savedHeroDailyEmpty, { color: weeklyCardPalette.subtext }]}>
            {t("heroDailyEmpty")}
          </Text>
        )}
      </WeeklyCardWrap>

      <View style={[styles.progressActiveChallenge, { backgroundColor: colors.card, borderColor: colors.border }]}>
        <View style={styles.progressActiveChallengeHeader}>
          <Text style={[styles.progressActiveChallengeTitle, { color: colors.text }]}>
            {t("progressActiveChallengeTitle")}
          </Text>
          {activeChallenge ? (
            <Text style={[styles.progressActiveChallengeMeta, { color: colors.muted }]}>
              {activeChallenge.timerLabel}
            </Text>
          ) : null}
        </View>
        {activeChallenge ? (
          <>
            <View style={styles.progressActiveChallengeRow}>
              <Text style={styles.challengeEmoji}>{activeChallenge.emoji}</Text>
              <View style={{ flex: 1 }}>
                <Text style={[styles.progressActiveChallengeName, { color: colors.text }]} numberOfLines={2}>
                  {activeChallenge.title}
                </Text>
                <Text style={[styles.progressActiveChallengeDesc, { color: colors.muted }]} numberOfLines={2}>
                  {activeChallenge.description}
                </Text>
                {activeChallenge.potentialSavingsLabel ? (
                  <Text style={[styles.challengePotential, { color: colors.text }]}>
                    {t("challengePotentialSavings", { amount: activeChallenge.potentialSavingsLabel })}
                  </Text>
                ) : null}
              </View>
            </View>
            {activeChallengeIsAmount ? (
              <View style={[styles.challengeProgressBar, { backgroundColor: colors.border }]}>
                <View
                  style={[
                    styles.challengeProgressFill,
                    { width: `${activeChallengePercent * 100}%`, backgroundColor: colors.text },
                  ]}
                />
              </View>
            ) : (
              <ChallengeProgressDots
                total={activeChallengeTargetValue}
                progress={activeChallengeProgressValue}
                colors={colors}
              />
            )}
            <Text style={[styles.challengeProgressLabel, { color: colors.muted }]}>
              {activeChallenge.progressLabel}
            </Text>
            <TouchableOpacity
              style={[
                styles.progressActiveChallengeButton,
                { backgroundColor: activeChallengeActionEnabled ? colors.text : colors.border },
              ]}
              activeOpacity={0.9}
              disabled={!activeChallengeActionEnabled}
              onPress={() => {
                if (activeChallenge.canClaim) {
                  onChallengeClaim?.(activeChallenge.id);
                } else if (activeChallenge.canStart) {
                  Alert.alert(
                    t("challengeAcceptConfirmTitle"),
                    t("challengeAcceptConfirmMessage", { title: activeChallenge.title }),
                    [
                      { text: t("challengeAcceptConfirmNo"), style: "cancel" },
                      {
                        text: t("challengeAcceptConfirmYes"),
                        style: "default",
                        onPress: () => onChallengeAccept?.(activeChallenge.id),
                      },
                    ]
                  );
                }
              }}
            >
              <Text
                style={[
                  styles.progressActiveChallengeButtonText,
                  { color: activeChallengeActionEnabled ? colors.background : colors.muted },
                ]}
              >
                {activeChallenge.actionLabel}
              </Text>
            </TouchableOpacity>
          </>
        ) : (
          <Text style={[styles.progressActiveChallengeEmpty, { color: colors.muted }]}>
            {t("progressNoActiveChallenge")}
          </Text>
        )}
      </View>

      <View style={[styles.progressAnalyticsCard, { backgroundColor: colors.card, borderColor: colors.border }]}>
        <Pressable style={styles.progressAnalyticsHeader} onPress={toggleProgressAnalytics}>
          <Text style={[styles.progressAnalyticsTitle, { color: colors.text }]}>
            {t("progressCategoryTitle")}
          </Text>
          <View style={styles.progressAnalyticsHeaderRight}>
            {progressAnalyticsExpanded ? (
              <View style={styles.progressAnalyticsLegend}>
                <View style={styles.progressAnalyticsLegendItem}>
                  <View style={[styles.progressAnalyticsDot, { backgroundColor: SAVE_ACTION_COLOR }]} />
                  <Text style={[styles.progressAnalyticsLegendText, { color: colors.muted }]}>
                    {t("progressCategorySave")}
                  </Text>
                </View>
                <View style={styles.progressAnalyticsLegendItem}>
                  <View style={[styles.progressAnalyticsDot, { backgroundColor: SPEND_ACTION_COLOR }]} />
                  <Text style={[styles.progressAnalyticsLegendText, { color: colors.muted }]}>
                    {t("progressCategorySpend")}
                  </Text>
                </View>
              </View>
            ) : null}
            <Animated.View
              style={[
                styles.progressAnalyticsChevron,
                {
                  transform: [
                    {
                      rotate: progressAnalyticsAnim.interpolate({
                        inputRange: [0, 1],
                        outputRange: ["0deg", "180deg"],
                      }),
                    },
                  ],
                },
              ]}
            >
              <View
                style={[
                  styles.progressAnalyticsChevronLineLeft,
                  { backgroundColor: colors.muted, transform: [{ rotate: "45deg" }] },
                ]}
              />
              <View
                style={[
                  styles.progressAnalyticsChevronLineRight,
                  { backgroundColor: colors.muted, transform: [{ rotate: "-45deg" }] },
                ]}
              />
            </Animated.View>
          </View>
        </Pressable>
        {progressAnalyticsExpanded ? (
          <>
            <Text style={[styles.progressAnalyticsSubtitle, { color: colors.muted }]}>
              {t("progressCategorySubtitle")}
            </Text>
            {challengeBadges.length > 0 && (
              <View style={styles.progressBadgeRow}>
                <Text style={[styles.progressBadgeLabel, { color: colors.muted }]}>
                  {t("progressBadgeTitle")}
                </Text>
                <View style={styles.progressBadgeList}>
                  {challengeBadges.slice(0, 6).map((emoji, index) => (
                    <Text key={`${emoji}-${index}`} style={styles.progressBadgeEmoji}>
                      {emoji}
                    </Text>
                  ))}
                  {challengeBadgeCount > 6 && (
                    <Text style={[styles.progressBadgeCount, { color: colors.muted }]}>
                      +{challengeBadgeCount - 6}
                    </Text>
                  )}
                </View>
              </View>
            )}
            <ScrollView
              style={[styles.progressAnalyticsScroll, { maxHeight: categoryListHeight }]}
              contentContainerStyle={styles.progressAnalyticsList}
              showsVerticalScrollIndicator={false}
              nestedScrollEnabled
            >
              {categoryData.categories.map((entry) => {
                const total = entry.save + entry.spend;
                const hasData = total > 0;
                const totalPercent = hasData ? 100 : 0;
                const savePercent = hasData ? Math.max(0, Math.min((entry.save / total) * 100, 100)) : 0;
                const spendPercent = hasData ? 100 - savePercent : 0;
                return (
                  <TouchableOpacity
                    key={entry.id}
                    style={styles.progressAnalyticsRow}
                    activeOpacity={0.86}
                    onPress={() => {
                      logEvent("progress_analytics_opened", { category_id: entry.id });
                      openCategoryHistory(entry.id);
                    }}
                  >
                    <View style={styles.progressAnalyticsRowHeader}>
                      <Text style={[styles.progressAnalyticsLabel, { color: colors.text }]}>
                        {entry.label}
                      </Text>
                      <Text style={[styles.progressAnalyticsValue, { color: colors.muted }]}>
                        {`${entry.save} / ${entry.spend}`}
                      </Text>
                    </View>
                    <View style={[styles.progressAnalyticsTrack, { backgroundColor: colors.border }]}>
                      <View style={[styles.progressAnalyticsFill, { width: `${totalPercent}%` }]}>
                        {hasData ? (
                          <>
                            <View
                              style={[
                                styles.progressAnalyticsSave,
                                { width: `${savePercent}%`, backgroundColor: SAVE_ACTION_COLOR },
                              ]}
                            />
                            <View
                              style={[
                                styles.progressAnalyticsSpend,
                                { width: `${spendPercent}%`, backgroundColor: SPEND_ACTION_COLOR },
                              ]}
                            />
                          </>
                        ) : null}
                      </View>
                    </View>
                  </TouchableOpacity>
                );
              })}
            </ScrollView>
          </>
        ) : (
          <Pressable style={styles.progressAnalyticsCollapsed} onPress={toggleProgressAnalytics}>
            {(() => {
              const total = progressAnalyticsTotals.save + progressAnalyticsTotals.spend;
              const hasData = total > 0;
              const savePercent = hasData
                ? Math.max(0, Math.min((progressAnalyticsTotals.save / total) * 100, 100))
                : 0;
              const spendPercent = hasData ? 100 - savePercent : 0;
              return (
                <View style={[styles.progressAnalyticsTrack, { backgroundColor: colors.border }]}>
                  <View style={[styles.progressAnalyticsFill, { width: `${hasData ? 100 : 0}%` }]}>
                    {hasData ? (
                      <>
                        <View
                          style={[
                            styles.progressAnalyticsSave,
                            { width: `${savePercent}%`, backgroundColor: SAVE_ACTION_COLOR },
                          ]}
                        />
                        <View
                          style={[
                            styles.progressAnalyticsSpend,
                            { width: `${spendPercent}%`, backgroundColor: SPEND_ACTION_COLOR },
                          ]}
                        />
                      </>
                    ) : null}
                  </View>
                </View>
              );
            })()}
          </Pressable>
        )}
      </View>

      {showImpulseMap ? (
        <ImpulseMapCard
          insights={impulseInsights}
          colors={colors}
          t={t}
          language={language}
          expanded={impulseExpanded}
          onToggle={handleImpulseToggle}
        />
      ) : (
        <TouchableOpacity
          activeOpacity={onImpulseMapLockedPress ? 0.94 : 1}
          onPress={onImpulseMapLockedPress}
          disabled={!onImpulseMapLockedPress}
        >
          <LockedFeatureCard
            variantKey="impulseMap"
            colors={colors}
            t={t}
            style={styles.lockedFeatureCard}
            blurIntensity={10}
            premiumStyle
          />
        </TouchableOpacity>
      )}

      {showFreeDayCard ? (
        <FreeDayCard
          colors={colors}
          t={t}
          canLog={canLogFreeDay}
          onLog={onFreeDayLog}
          freeDayStats={freeDayStats}
          todayKey={todayKey}
          weekDays={weekDays}
          weekCount={weekSuccessCount}
          canRescue={canRescueFreeDay}
          needsRescue={streakNeedsRescue}
          rescueStatus={rescueStatus}
          rescueCost={freeDayRescueCost}
          onRescue={onFreeDayRescue}
          hasRescueHealth={hasRescueHealth}
        />
      ) : (
        <LockedFeatureCard
          variantKey="freeDay"
          colors={colors}
          t={t}
          style={styles.lockedFeatureCard}
          minHeight={182}
          blurIntensity={10}
        />
      )}

      <View style={styles.progressSectionHeader}>
        <Text style={[styles.progressSectionTitle, { color: colors.text }]}>{t("progressGoalsTitle")}</Text>
        <Text style={[styles.progressSectionSubtitle, { color: colors.muted }]}>
          {t("wishlistSummary", { amount: totalTarget })}
        </Text>
      </View>
      <ScrollView
        horizontal
        showsHorizontalScrollIndicator={false}
        contentContainerStyle={styles.progressGoalScroll}
      >
        {listData.map((wish) => {
          const goalId = wish.goalId || wish.id;
          const isActiveGoal = !!activeGoalId && activeGoalId === goalId;
          const isDoneGoal = wish?.status === "done";
          const title = getWishTitleWithoutEmoji(wish);
          const emoji = resolveWishEmoji(wish);
          const cardBackground = isDoneGoal
            ? SAVE_ACTION_COLOR
            : isActiveGoal
              ? colors.text
              : colors.card;
          const cardTextColor = isDoneGoal
            ? "#fff"
            : isActiveGoal
              ? colors.background
              : colors.text;
          const cardMetaColor = isDoneGoal
            ? "rgba(255,255,255,0.85)"
            : isActiveGoal
              ? "rgba(255,255,255,0.75)"
              : colors.muted;
          return (
            <TouchableOpacity
              key={wish.id}
              style={[
                styles.progressGoalMiniCard,
                {
                  borderColor: isActiveGoal ? colors.text : colors.border,
                  backgroundColor: cardBackground,
                },
              ]}
              activeOpacity={0.9}
              onPress={() => {
                if (isDoneGoal) {
                  Alert.alert(t("goalRepeatTitle"), t("goalRepeatMessage"), [
                    { text: t("goalRepeatCancel"), style: "cancel" },
                    {
                      text: t("goalRepeatAction"),
                      onPress: () => onCreateGoal?.(),
                    },
                  ]);
                  return;
                }
                if (!isActiveGoal) {
                  onSetActiveGoal?.(goalId);
                  return;
                }
                onGoalEdit?.(wish);
              }}
              onLongPress={() => onSetActiveGoal?.(goalId)}
            >
              <Text
                style={[styles.progressGoalMiniEmoji, { color: cardTextColor }]}
              >
                {emoji}
              </Text>
              <Text
                style={[styles.progressGoalMiniTitle, { color: cardTextColor }]}
                numberOfLines={2}
              >
                {title}
              </Text>
              <Text
                style={[styles.progressGoalMiniMeta, { color: cardMetaColor }]}
              >
                {isDoneGoal ? t("goalRepeatHint") : isActiveGoal ? t("wishlistActive") : t("wishlistSetActive")}
              </Text>
            </TouchableOpacity>
          );
        })}
        <TouchableOpacity
          style={[
            styles.progressGoalMiniCard,
            styles.progressGoalMiniPlaceholder,
            { borderColor: colors.border },
          ]}
          activeOpacity={0.9}
          onPress={() => onCreateGoal?.()}
        >
          <Text style={[styles.progressGoalMiniPlus, { color: colors.text }]}>+</Text>
          <Text style={[styles.progressGoalMiniMeta, { color: colors.muted, textAlign: "center" }]}>
            {t("goalCustomCreate")}
          </Text>
        </TouchableOpacity>
      </ScrollView>

      <View style={styles.progressSectionHeader}>
        <Text style={[styles.progressSectionTitle, { color: colors.text }]}>
          {t("challengeTabTitle")}
        </Text>
        <Text style={[styles.progressSectionSubtitle, { color: colors.muted }]}>
          {t("progressChallengesSubtitle")}
        </Text>
      </View>

      <View style={{ gap: 16 }}>
        {renderDailyChallengeWidget()}
        {progressChallengeList.map(renderChallengeCard)}
        {!progressChallengeList.length && !dailyChallenge && (
          <Text style={[styles.historyEmpty, { color: colors.muted }]}>
            {t("rewardsEmpty")}
          </Text>
        )}
      </View>
      </ScrollView>
      <Modal
        visible={categoryModalVisible}
        transparent
        animationType="none"
        statusBarTranslucent
        onRequestClose={closeCategoryHistory}
      >
        <View style={styles.progressCategoryModalRoot}>
          <TouchableWithoutFeedback onPress={closeCategoryHistory}>
            <Animated.View
              style={[
                styles.progressCategoryBackdrop,
                { backgroundColor: "#000", opacity: categoryModalBackdropOpacity },
              ]}
            />
          </TouchableWithoutFeedback>
          <View style={styles.progressCategoryModalWrap} pointerEvents="box-none">
            <Animated.View
              style={[
                styles.progressCategoryModalCard,
                { backgroundColor: colors.card, borderColor: colors.border },
                {
                  opacity: categoryModalAnim,
                  transform: [
                    { translateY: categoryModalCardTranslate },
                    { scale: categoryModalCardScale },
                  ],
                },
              ]}
              onLayout={(event) => {
                const nextHeight = event?.nativeEvent?.layout?.height || 0;
                if (nextHeight && nextHeight !== categoryModalHeight) {
                  setCategoryModalHeight(nextHeight);
                }
              }}
            >
              <View style={styles.progressCategoryModalHeader}>
                <Text style={[styles.progressCategoryModalTitle, { color: colors.text }]}>
                  {t("historyTitle")} Â· {activeCategoryLabel}
                </Text>
                <TouchableOpacity onPress={closeCategoryHistory} style={styles.progressCategoryModalClose}>
                  <Text style={[styles.progressCategoryModalCloseText, { color: colors.muted }]}>âœ•</Text>
                </TouchableOpacity>
              </View>
              {categoryHistoryEntries.length === 0 ? (
                <Text style={[styles.historyEmpty, { color: colors.muted }]}>{t("historyEmpty")}</Text>
              ) : (
                <ScrollView
                  style={[styles.progressCategoryModalList, { borderColor: colors.border }]}
                  contentContainerStyle={styles.historyListContent}
                  showsVerticalScrollIndicator
                >
                  {categoryHistoryEntries.map((entry, index) => (
                    <View
                      key={entry.id}
                      style={[
                        styles.historyItem,
                        {
                          borderColor: colors.border,
                          borderBottomWidth:
                            index === categoryHistoryEntries.length - 1 ? 0 : StyleSheet.hairlineWidth,
                        },
                      ]}
                    >
                      <View style={styles.historyRow}>
                        <View style={{ flex: 1 }}>
                          <Text style={[styles.historyItemTitle, { color: colors.text }]}>
                            {describeCategoryHistory(entry)}
                          </Text>
                          <Text style={[styles.historyItemMeta, { color: colors.muted }]}>
                            {formatCategoryHistoryMeta(entry)}
                          </Text>
                        </View>
                      </View>
                    </View>
                  ))}
                </ScrollView>
              )}
            </Animated.View>
          </View>
        </View>
      </Modal>
      <Modal
        visible={budgetModalVisible}
        transparent
        animationType="fade"
        statusBarTranslucent
        onRequestClose={closeBudgetModal}
      >
        <View style={styles.budgetModalRoot}>
          <TouchableWithoutFeedback onPress={closeBudgetModal}>
            <View style={styles.budgetModalBackdrop} />
          </TouchableWithoutFeedback>
          <View style={styles.budgetModalWrap} pointerEvents="box-none">
            <Animated.View
              style={[
                styles.budgetModalCard,
                { backgroundColor: colors.card, borderColor: colors.border },
                {
                  opacity: budgetModalAnim,
                  transform: [
                    {
                      scale: budgetModalAnim.interpolate({
                        inputRange: [0, 1],
                        outputRange: [0.96, 1],
                      }),
                    },
                  ],
                },
              ]}
            >
              <View style={styles.budgetModalHeader}>
                <View style={styles.budgetModalTitleBlock}>
                  <Text style={[styles.budgetModalTitle, { color: colors.text }]}>
                    {t("budgetModalTitle")}
                  </Text>
                  <Text style={[styles.budgetModalSubtitle, { color: colors.muted }]}>
                    {budgetModalPlan?.monthLabel
                      ? t("budgetWidgetMonthLabel", { month: budgetModalPlan.monthLabel })
                      : t("budgetWidgetSubtitle")}
                  </Text>
                </View>
                <TouchableOpacity onPress={closeBudgetModal} style={styles.budgetModalClose}>
                  <Text style={[styles.budgetModalCloseText, { color: colors.muted }]}>âœ•</Text>
                </TouchableOpacity>
              </View>
              {budgetMonthOptions.length > 1 ? (
                <ScrollView
                  horizontal
                  showsHorizontalScrollIndicator={false}
                  style={styles.budgetModalMonthScroll}
                  contentContainerStyle={styles.budgetModalMonthContent}
                >
                  {budgetMonthOptions.map((monthKey) => {
                    const isActive = monthKey === budgetModalActiveMonthKey;
                    const label = budgetMonthLabels[monthKey] || monthKey;
                    return (
                      <TouchableOpacity
                        key={monthKey}
                        style={[
                          styles.budgetModalMonthChip,
                          {
                            borderColor: isActive ? colors.text : colors.border,
                            backgroundColor: isActive ? colors.text : colors.background,
                          },
                        ]}
                        activeOpacity={0.85}
                        onPress={() => setBudgetModalMonthKey(monthKey)}
                      >
                        <Text
                          style={[
                            styles.budgetModalMonthChipText,
                            { color: isActive ? colors.background : colors.text },
                          ]}
                        >
                          {label}
                        </Text>
                      </TouchableOpacity>
                    );
                  })}
                </ScrollView>
              ) : null}
              <View style={styles.budgetModalStatsRow}>
                <View style={styles.budgetModalStat}>
                  <Text style={[styles.budgetModalStatLabel, { color: colors.muted }]}>
                    {t("budgetIncomeLabel")}
                  </Text>
                  <Text style={[styles.budgetModalStatValue, { color: colors.text }]}>
                    {budgetModalIncomeLabel}
                  </Text>
                </View>
                <View style={styles.budgetModalStat}>
                  <Text style={[styles.budgetModalStatLabel, { color: colors.muted }]}>
                    {t("budgetSavingsLabel")}
                  </Text>
                  <Text style={[styles.budgetModalStatValue, { color: SAVE_ACTION_COLOR }]}>
                    {budgetSavingsLabel}
                  </Text>
                </View>
                <View style={styles.budgetModalStat}>
                  <Text style={[styles.budgetModalStatLabel, { color: colors.muted }]}>
                    {t("budgetPlannedLabel")}
                  </Text>
                  <Text
                    style={[
                      styles.budgetModalStatValue,
                      {
                        color: budgetModalPlannedIsZero
                          ? SAVE_ACTION_COLOR
                          : budgetModalPlannedNegative
                          ? "#E15555"
                          : colors.text,
                      },
                    ]}
                  >
                    {budgetModalPlannedIsZero
                      ? "âœ“"
                      : budgetModalPlannedNegative
                      ? `-${budgetModalPlannedLabel}`
                      : budgetModalPlannedLabel}
                  </Text>
                </View>
                <View style={styles.budgetModalStat}>
                  <Text style={[styles.budgetModalStatLabel, { color: colors.muted }]}>
                    {t("budgetRemainingLabel")}
                  </Text>
                  <Text
                    style={[
                      styles.budgetModalStatValue,
                      { color: budgetModalRemainingNegative ? "#E15555" : colors.text },
                    ]}
                  >
                    {budgetModalRemainingNegative
                      ? `-${budgetModalRemainingLabel}`
                      : budgetModalRemainingLabel}
                  </Text>
                </View>
              </View>
              {!budgetModalStatsOnly ? (
                <Text style={[styles.budgetModalHint, { color: colors.muted }]}>
                  {t("budgetEditHint")}
                </Text>
              ) : null}
              <ScrollView
                horizontal
                showsHorizontalScrollIndicator={false}
                contentContainerStyle={styles.budgetModalBars}
              >
                {budgetModalDisplayCategories.map((entry) => (
                  <BudgetBarItem
                    key={entry.id}
                    entry={entry}
                    valueUSD={budgetDraft?.[entry.id] ?? entry.limitUSD}
                    spentUSD={entry.spentUSD || 0}
                    maxHeight={BUDGET_BAR_MAX_HEIGHT}
                    colors={colors}
                    onManualEdit={budgetModalStatsOnly ? null : openBudgetManualPrompt}
                    formatAmount={formatLocalAmount}
                  />
                ))}
              </ScrollView>
              <View style={styles.budgetModalActions}>
                {!budgetModalStatsOnly ? (
                  <TouchableOpacity
                    style={[styles.budgetModalAction, { borderColor: colors.border }]}
                    onPress={() => {
                      closeBudgetModal();
                      onExtraIncomeEntryOpen?.("budget_modal");
                    }}
                  >
                    <Text style={[styles.budgetModalActionText, { color: colors.text }]}>
                      {t("budgetAddIncome")}
                    </Text>
                  </TouchableOpacity>
                ) : null}
                <TouchableOpacity
                  style={[styles.budgetModalActionPrimary, { backgroundColor: colors.text }]}
                  onPress={confirmBudgetModal}
                >
                  <Text style={[styles.budgetModalActionPrimaryText, { color: colors.background }]}>
                    {t("budgetModalClose")}
                  </Text>
                </TouchableOpacity>
              </View>
            </Animated.View>
          </View>
          {budgetManualPrompt.visible && (
            <View style={StyleSheet.absoluteFillObject} pointerEvents="box-none">
              <TouchableWithoutFeedback onPress={closeBudgetManualPrompt}>
                <View style={styles.baselinePromptBackdrop}>
                  <TouchableWithoutFeedback onPress={() => {}}>
                    <View
                      style={[
                        styles.baselinePromptCard,
                        { backgroundColor: colors.card, borderColor: colors.border },
                      ]}
                    >
                      <Text style={[styles.baselinePromptTitle, { color: colors.text }]}>
                        {t("budgetLimitPromptTitle")}
                      </Text>
                      <Text style={[styles.baselinePromptSubtitle, { color: colors.muted }]}>
                        {t("budgetLimitPromptSubtitle", { category: budgetManualCategoryLabel })}
                      </Text>
                      <View style={styles.baselineInputGroup}>
                        <TextInput
                          style={[
                            styles.primaryInput,
                            {
                              borderColor: colors.border,
                              backgroundColor: colors.background,
                              color: colors.text,
                            },
                          ]}
                          value={budgetManualPrompt.value}
                          onChangeText={handleBudgetManualChange}
                          placeholder={t("budgetLimitPromptPlaceholder")}
                          placeholderTextColor={colorWithAlpha(colors.muted, 0.6)}
                          keyboardType={Platform.OS === "ios" ? "numbers-and-punctuation" : "decimal-pad"}
                          returnKeyType="done"
                          onSubmitEditing={handleBudgetManualSubmit}
                        />
                        {budgetManualPrompt.error && (
                          <Text style={[styles.coinEntryError, { color: SPEND_ACTION_COLOR }]}>
                            {t("incomeEntryInvalid")}
                          </Text>
                        )}
                      </View>
                      <TouchableOpacity
                        style={[styles.primaryButton, { backgroundColor: colors.text }]}
                        onPress={handleBudgetManualSubmit}
                      >
                        <Text style={[styles.primaryButtonText, { color: colors.background }]}>
                          {t("budgetLimitPromptConfirm")}
                        </Text>
                      </TouchableOpacity>
                      <TouchableOpacity style={styles.baselinePromptDismiss} onPress={closeBudgetManualPrompt}>
                        <Text style={[styles.baselinePromptDismissText, { color: colors.muted }]}>
                          {t("profileCancel")}
                        </Text>
                      </TouchableOpacity>
                    </View>
                  </TouchableWithoutFeedback>
                </View>
              </TouchableWithoutFeedback>
            </View>
          )}
        </View>
      </Modal>
    </>
  );
});

function SwipeablePendingCard({ children, colors, t, onDelete, itemId, onLayout }) {
  const translateX = useRef(new Animated.Value(0)).current;
  const isDarkTheme = colors.background === THEMES.dark.background;

  const handleSwipeRelease = useCallback(
    (dx = 0) => {
      if (dx < -DELETE_SWIPE_THRESHOLD && onDelete) {
        onDelete();
      }
      Animated.timing(translateX, {
        toValue: 0,
        duration: 160,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }).start();
    },
    [onDelete, translateX]
  );

  const panResponder = useMemo(
    () =>
      PanResponder.create({
        onStartShouldSetPanResponder: () => false,
        onMoveShouldSetPanResponder: (_, gestureState) =>
          Math.abs(gestureState.dx) > Math.abs(gestureState.dy) && Math.abs(gestureState.dx) > 6,
        onPanResponderGrant: () => {
          translateX.stopAnimation();
        },
        onPanResponderMove: (_, gestureState) => {
          const dx = Math.max(Math.min(gestureState.dx, 60), -180);
          translateX.setValue(dx);
        },
        onPanResponderRelease: (_, gestureState) => {
          handleSwipeRelease(gestureState.dx);
        },
        onPanResponderTerminationRequest: () => false,
        onPanResponderTerminate: () => handleSwipeRelease(0),
      }),
    [handleSwipeRelease, translateX]
  );

  useEffect(() => {
    translateX.setValue(0);
  }, [itemId, translateX]);

  return (
    <View style={styles.pendingSwipeWrapper} onLayout={onLayout}>
      <View style={styles.pendingSwipeBackground} pointerEvents="none">
        <View
          style={[
            styles.swipeHint,
            styles.swipeHintRight,
            {
              borderColor: isDarkTheme ? "rgba(255,255,255,0.12)" : colors.border,
              backgroundColor: isDarkTheme ? "rgba(255,87,115,0.15)" : "rgba(233,61,87,0.12)",
            },
          ]}
        >
          <Text style={[styles.swipeHintIcon, { color: "#E15555" }]}>ðŸ—‘ï¸</Text>
          <Text style={[styles.swipeHintText, { color: "#E15555" }]}>{t("goalSwipeDelete")}</Text>
        </View>
      </View>
      <Animated.View style={{ transform: [{ translateX }] }} {...panResponder.panHandlers}>
        {children}
      </Animated.View>
    </View>
  );
}

const FRIDGE_HANDLE_HINT = {
  ru: "Ð¢Ð°Ð¿Ð½Ð¸ Ð¿Ð¾ Ñ€ÑƒÑ‡ÐºÐµ",
  en: "Tap the handle",
  es: "Toca la manija",
  fr: "Touche la poignÃ©e",
};
const FRIDGE_DOOR_COUNTER_LABELS = {
  ru: { items: "Ð¥Ð¾Ñ‚ÐµÐ»Ð¾Ðº", overdue: "ÐŸÑ€Ð¾ÑÑ€Ð¾Ñ‡ÐµÐ½Ð¾", total: "Ð¡ÑƒÐ¼Ð¼Ð°" },
  en: { items: "Temptations", overdue: "Overdue", total: "Total" },
  es: { items: "Tentaciones", overdue: "Atrasadas", total: "Total" },
  fr: { items: "Tentations", overdue: "Ã‰chÃ©ances", total: "Total" },
};

const PendingScreen = React.memo(function PendingScreen({
  items,
  currency,
  t,
  colors,
  onResolve,
  onDelete,
  onExtend,
  language,
  catCuriousSource,
  isPremiumUser = false,
  onPremiumShelvesPress,
  locked = false,
  onItemLayout,
  scrollRef,
  playSound,
}) {
  const isDarkMode = colors.background === THEMES.dark.background;
  const curiousImage = catCuriousSource || CLASSIC_TAMAGOTCHI_ANIMATIONS.curious;
  const [nowTick, setNowTick] = useState(Date.now());
  const [fridgeOpen, setFridgeOpen] = useState(false);
  const doorProgress = useRef(new Animated.Value(0)).current;
  const handlePressAnim = useRef(new Animated.Value(0)).current;
  const handlePulseAnim = useRef(new Animated.Value(0)).current;
  const coldBreathAnim = useRef(new Animated.Value(0)).current;
  const sorted = useMemo(
    () => [...items].sort((a, b) => (a.decisionDue || 0) - (b.decisionDue || 0)),
    [items]
  );
  useEffect(() => {
    if (!sorted.length) return undefined;
    const intervalId = setInterval(() => {
      setNowTick(Date.now());
    }, PENDING_COUNTDOWN_FAST_MS);
    return () => clearInterval(intervalId);
  }, [sorted.length]);
  useEffect(() => {
    Animated.timing(doorProgress, {
      toValue: fridgeOpen ? 1 : 0,
      duration: fridgeOpen ? 640 : 520,
      easing: fridgeOpen ? Easing.out(Easing.cubic) : Easing.inOut(Easing.cubic),
      useNativeDriver: true,
    }).start();
  }, [doorProgress, fridgeOpen]);
  useEffect(() => {
    if (fridgeOpen) {
      handlePulseAnim.stopAnimation();
      handlePulseAnim.setValue(0);
      return undefined;
    }
    const loop = Animated.loop(
      Animated.sequence([
        Animated.timing(handlePulseAnim, {
          toValue: 1,
          duration: 1400,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(handlePulseAnim, {
          toValue: 0,
          duration: 1400,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    loop.start();
    return () => loop.stop();
  }, [fridgeOpen, handlePulseAnim]);
  useEffect(() => {
    if (!fridgeOpen) {
      coldBreathAnim.stopAnimation();
      coldBreathAnim.setValue(0);
      return undefined;
    }
    const loop = Animated.loop(
      Animated.sequence([
        Animated.timing(coldBreathAnim, {
          toValue: 1,
          duration: 2400,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(coldBreathAnim, {
          toValue: 0,
          duration: 2200,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    loop.start();
    return () => loop.stop();
  }, [coldBreathAnim, fridgeOpen]);

  const formatCountdown = useCallback(
    (ms) => {
      if (ms <= 0) return t("pendingExpired");
      const totalSeconds = Math.floor(ms / 1000);
      const days = Math.floor(totalSeconds / 86400);
      const hours = Math.floor((totalSeconds % 86400) / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      const hh = String(hours).padStart(2, "0");
      const mm = String(minutes).padStart(2, "0");
      const ss = String(seconds).padStart(2, "0");
      const daySuffix = resolveLanguageMapValue(PENDING_DAY_SUFFIX, language) || "d";
      return days > 0 ? `${days}${daySuffix} ${hh}:${mm}:${ss}` : `${hh}:${mm}:${ss}`;
    },
    [language, t]
  );

  const handleHint =
    resolveLanguageMapValue(FRIDGE_HANDLE_HINT, language) || FRIDGE_HANDLE_HINT.en;
  const doorLabels = FRIDGE_DOOR_COUNTER_LABELS[language] || FRIDGE_DOOR_COUNTER_LABELS.en;
  const overdueCount = useMemo(
    () => sorted.filter((item) => (item.decisionDue || 0) - nowTick <= 0).length,
    [nowTick, sorted]
  );
  const pendingCount = sorted.length;
  const totalPendingUSD = useMemo(
    () =>
      sorted.reduce(
        (sum, item) => sum + (Number(item.priceUSD) || Number(item.basePriceUSD) || 0),
        0
      ),
    [sorted]
  );
  const totalPendingLabel = formatCurrency(
    convertToCurrency(totalPendingUSD, currency),
    currency,
    { friendly: true }
  );
  const heroTotalFontSize =
    totalPendingLabel.length > 11
      ? 24
      : totalPendingLabel.length > 9
      ? 26
      : totalPendingLabel.length > 7
      ? 28
      : 32;
  const cabinetWidth = Math.max(0, SCREEN_WIDTH - BASE_HORIZONTAL_PADDING * 2);
  const doorWidth = Math.max(0, cabinetWidth - 20);
  const doorOffset = Math.min(doorWidth * 0.98, SCREEN_WIDTH * 0.95);
  const doorTranslateX = doorProgress.interpolate({
    inputRange: [0, 1],
    outputRange: [0, -doorOffset],
  });
  const doorRotate = doorProgress.interpolate({
    inputRange: [0, 1],
    outputRange: ["0deg", "-12deg"],
  });
  const doorScaleX = doorProgress.interpolate({
    inputRange: [0, 1],
    outputRange: [1, 0.88],
  });
  const doorHintOpacity = doorProgress.interpolate({
    inputRange: [0, 0.15],
    outputRange: [1, 0],
  });
  const doorShadowOpacity = doorProgress.interpolate({
    inputRange: [0, 1],
    outputRange: [0.18, 0],
  });
  const interiorOpacity = doorProgress.interpolate({
    inputRange: [0, 0.35, 1],
    outputRange: [0, 0.35, 1],
  });
  const interiorTranslateY = doorProgress.interpolate({
    inputRange: [0, 1],
    outputRange: [18, 0],
  });
  const handlePulseScale = handlePulseAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [1, 1.05],
  });
  const handlePressScale = handlePressAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [1, 0.92],
  });
  const handleScale = Animated.multiply(handlePulseScale, handlePressScale);
  const handleGlowOpacity = handlePulseAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0.35, 0.85],
  });
  const mistOpacity = coldBreathAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0.12, 0.28],
  });
  const mistTranslateY = coldBreathAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [12, -8],
  });
  const fridgeFrameColor = isDarkMode ? "#0C121A" : "#E7F1FF";
  const fridgeDoorColor = isDarkMode ? "#17202B" : "#F5F9FF";
  const fridgeInteriorColor = isDarkMode ? "#0B1119" : "#D9E8FF";
  const fridgeEdgeColor = isDarkMode ? "rgba(255,255,255,0.08)" : "rgba(72,120,200,0.18)";
  const fridgeShelfColor = isDarkMode ? "rgba(255,255,255,0.08)" : "rgba(120,170,255,0.35)";
  const fridgeShelfLipColor = isDarkMode ? "rgba(255,255,255,0.2)" : "rgba(255,255,255,0.7)";
  const fridgeGlowColor = isDarkMode ? "rgba(86,160,255,0.35)" : "rgba(140,210,255,0.45)";
  const handleColor = isDarkMode ? "#C8D2E0" : "#D1DBEA";
  const handleInnerColor = isDarkMode ? "rgba(25,32,45,0.9)" : "rgba(255,255,255,0.9)";
  const badgeBg = isDarkMode ? "rgba(255,255,255,0.08)" : "rgba(255,255,255,0.88)";
  const badgeBorder = isDarkMode ? "rgba(255,255,255,0.2)" : "rgba(0,0,0,0.08)";
  const shelfPlaceholderBg = isDarkMode ? "rgba(255,255,255,0.04)" : "rgba(255,255,255,0.86)";
  const shelfPlaceholderBorder = isDarkMode
    ? "rgba(170,205,255,0.25)"
    : "rgba(120,170,255,0.45)";
  const premiumShelfCardBg = isDarkMode ? "#12223A" : "#F3F8FF";
  const premiumShelfCardBorder = isDarkMode
    ? "rgba(150,202,255,0.42)"
    : "rgba(75,130,215,0.45)";
  const premiumShelfTitleColor = isDarkMode ? "#E8F2FF" : "#1E3353";
  const premiumShelfSubtitleColor = isDarkMode ? "#C2D5EE" : "#4A6388";
  const premiumShelfBadgeBg = isDarkMode ? "rgba(255,255,255,0.18)" : "rgba(44,104,196,0.14)";
  const premiumShelfButtonBg = isDarkMode ? "#67A8FF" : "#2C68C4";

  const handleToggleFridge = useCallback(() => {
    if (locked) return;
    const nextOpen = !fridgeOpen;
    setFridgeOpen(nextOpen);
    if (nextOpen) {
      triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
      logEvent("fridge_door_opened", {
        pending_count: pendingCount,
        overdue_count: overdueCount,
      });
    } else {
      triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    }
    playSound?.("tap");
    Animated.sequence([
      Animated.timing(handlePressAnim, {
        toValue: 1,
        duration: 90,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }),
      Animated.timing(handlePressAnim, {
        toValue: 0,
        duration: 140,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }),
    ]).start();
    if (nextOpen) {
      scrollRef?.current?.scrollTo?.({ y: 0, animated: true });
    }
  }, [fridgeOpen, handlePressAnim, locked, logEvent, overdueCount, pendingCount, playSound, scrollRef]);

  const emptyBody = (
    <View style={styles.fridgeEmptyWrap}>
      <View style={styles.cartEmptyState}>
        <Image source={curiousImage} style={[styles.catImage, styles.catImageLarge]} />
        <Text style={[styles.cartEmptyTitle, { color: colors.text }]}>{t("pendingEmptyTitle")}</Text>
        <Text style={[styles.cartEmptySubtitle, { color: colors.muted }]}>
          {t("pendingEmptySubtitle")}
        </Text>
      </View>
    </View>
  );
  const renderPendingShelf = (item) => {
    const diff = (item.decisionDue || 0) - nowTick;
    const countdownLabel = formatCountdown(diff);
    const overdue = diff <= 0;
    const priceLabel = formatTemptationPriceLabel(item, currency);
    const itemCardBg = isDarkMode ? "#111A26" : "#FFFFFF";
    const itemCardBorder = isDarkMode ? "rgba(120,160,220,0.25)" : "rgba(140,180,235,0.6)";
    const itemCardShadow = isDarkMode ? "rgba(0,0,0,0.45)" : "rgba(100,150,220,0.25)";
    const pillBg = overdue
      ? isDarkMode
        ? "rgba(224,90,90,0.18)"
        : "rgba(255,220,220,0.92)"
      : isDarkMode
      ? "rgba(120,180,255,0.18)"
      : "rgba(255,255,255,0.92)";
    const pillBorder = overdue
      ? isDarkMode
        ? "rgba(255,120,120,0.4)"
        : "rgba(240,120,120,0.45)"
      : isDarkMode
      ? "rgba(120,180,255,0.4)"
      : "rgba(120,180,255,0.4)";
    const pillText = overdue ? "#E66A6A" : isDarkMode ? "#B8D9FF" : "#2C68C4";
    return (
      <View key={item.id} style={styles.fridgeShelfRow}>
        <View style={[styles.fridgeShelfLine, { backgroundColor: fridgeShelfColor }]} />
        <View style={[styles.fridgeShelfLip, { backgroundColor: fridgeShelfLipColor }]} />
        <SwipeablePendingCard
          colors={colors}
          t={t}
          onDelete={onDelete ? () => onDelete(item) : undefined}
          itemId={item.id}
          onLayout={
            onItemLayout
              ? (event) => {
                  onItemLayout(item.id, event.nativeEvent.layout);
                }
              : undefined
          }
        >
          <View
            style={[
              styles.fridgeItemCard,
              {
                backgroundColor: itemCardBg,
                borderColor: itemCardBorder,
                shadowColor: itemCardShadow,
                shadowOpacity: 0.16,
                shadowRadius: 12,
                shadowOffset: { width: 0, height: 8 },
                elevation: 4,
              },
            ]}
          >
            <View style={styles.fridgeItemHeader}>
              <View style={styles.fridgeItemTitleRow}>
                <Text style={[styles.fridgeItemEmoji, { color: colors.text }]}>
                  {item.emoji || "âœ¨"}
                </Text>
                <Text style={[styles.fridgeItemTitle, { color: colors.text }]} numberOfLines={1}>
                  {item.title}
                </Text>
              </View>
              <View style={[styles.fridgeCountdownPill, { backgroundColor: pillBg, borderColor: pillBorder }]}>
                <Text style={[styles.fridgeCountdownText, { color: pillText }]}>{countdownLabel}</Text>
              </View>
            </View>
            <View style={styles.fridgeItemMetaRow}>
              <Text style={[styles.fridgeItemPrice, { color: colors.text }]}>{priceLabel}</Text>
            </View>
            <View style={styles.fridgeActionRow}>
              <TouchableOpacity
                style={[styles.fridgeActionPrimary, { backgroundColor: colors.text }]}
                onPress={() => onResolve(item, "spend")}
              >
                <Text style={[styles.fridgeActionPrimaryText, { color: colors.background }]}>
                  {t("pendingActionWant")}
                </Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.fridgeActionSecondary, { borderColor: colors.border }]}
                onPress={() => onResolve(item, "decline")}
              >
                <Text style={{ color: colors.muted }}>{t("pendingActionDecline")}</Text>
              </TouchableOpacity>
              {overdue && onExtend ? (
                <TouchableOpacity
                  style={[styles.fridgeActionSecondary, { borderColor: colors.border }]}
                  onPress={() => onExtend(item)}
                >
                  <Text style={{ color: colors.muted }}>{t("pendingActionExtend")}</Text>
                </TouchableOpacity>
              ) : null}
            </View>
          </View>
        </SwipeablePendingCard>
      </View>
    );
  };
  const shelfContent = isPremiumUser ? (
    sorted.length ? (
      sorted.map(renderPendingShelf)
    ) : (
      emptyBody
    )
  ) : (
    <>
      {Array.from({ length: FREE_PENDING_LIMIT }, (_, index) => {
        const shelfItem = sorted[index];
        if (shelfItem) {
          return renderPendingShelf(shelfItem);
        }
        return (
          <View key={`empty-shelf-${index}`} style={styles.fridgeShelfRow}>
            <View style={[styles.fridgeShelfLine, { backgroundColor: fridgeShelfColor }]} />
            <View style={[styles.fridgeShelfLip, { backgroundColor: fridgeShelfLipColor }]} />
            <View
              style={[
                styles.fridgeShelfPlaceholderCard,
                {
                  backgroundColor: shelfPlaceholderBg,
                  borderColor: shelfPlaceholderBorder,
                },
              ]}
            >
              <Text style={[styles.fridgeShelfPlaceholderText, { color: colors.muted }]}>
                {t("pendingShelfEmptyLabel", { index: index + 1 })}
              </Text>
            </View>
          </View>
        );
      })}
      <View style={styles.fridgeShelfRow}>
        <View style={[styles.fridgeShelfLine, { backgroundColor: fridgeShelfColor }]} />
        <View style={[styles.fridgeShelfLip, { backgroundColor: fridgeShelfLipColor }]} />
        <View
          style={[
            styles.fridgePremiumShelfCard,
            {
              backgroundColor: premiumShelfCardBg,
              borderColor: premiumShelfCardBorder,
            },
          ]}
        >
          <View style={[styles.fridgePremiumShelfBadge, { backgroundColor: premiumShelfBadgeBg }]}>
            <Text
              style={[
                styles.fridgePremiumShelfBadgeText,
                { color: isDarkMode ? "#FFFFFF" : "#2C68C4" },
              ]}
            >
              Premium
            </Text>
          </View>
          <Text style={[styles.fridgePremiumShelfTitle, { color: premiumShelfTitleColor }]}>
            {t("pendingPremiumShelvesTitle")}
          </Text>
          <Text style={[styles.fridgePremiumShelfSubtitle, { color: premiumShelfSubtitleColor }]}>
            {t("pendingPremiumShelvesSubtitle", { limit: FREE_PENDING_LIMIT })}
          </Text>
          <TouchableOpacity
            style={[
              styles.fridgePremiumShelfButton,
              {
                backgroundColor: premiumShelfButtonBg,
                opacity: onPremiumShelvesPress ? 1 : 0.65,
              },
            ]}
            onPress={onPremiumShelvesPress}
            disabled={!onPremiumShelvesPress}
          >
            <Text style={styles.fridgePremiumShelfButtonText}>{t("pendingPremiumShelvesCta")}</Text>
          </TouchableOpacity>
        </View>
      </View>
      {sorted.slice(FREE_PENDING_LIMIT).map(renderPendingShelf)}
    </>
  );
  const fridgeBody = (
    <View style={styles.fridgeStage}>
      <View style={[styles.fridgeCabinet, { backgroundColor: fridgeFrameColor, borderColor: fridgeEdgeColor }]}>
        <View style={[styles.fridgeAura, { backgroundColor: fridgeGlowColor }]} pointerEvents="none" />
        <View
          style={[
            styles.fridgeInteriorWrap,
            {
              backgroundColor: fridgeInteriorColor,
              borderColor: fridgeEdgeColor,
            },
          ]}
        >
          <Animated.View
            style={[
              styles.fridgeInterior,
              {
                opacity: interiorOpacity,
                transform: [{ translateY: interiorTranslateY }],
              },
            ]}
            pointerEvents={fridgeOpen ? "auto" : "none"}
          >
            <ScrollView
              ref={scrollRef}
              scrollEnabled={fridgeOpen}
              showsVerticalScrollIndicator={false}
              contentContainerStyle={styles.fridgeShelfContent}
              style={styles.fridgeShelfScroll}
            >
              <View style={styles.fridgeInteriorHeader}>
                <Text style={[styles.fridgeInteriorTitle, { color: colors.text }]}>{t("pendingTitle")}</Text>
                <View style={[styles.fridgeInteriorBadge, { backgroundColor: badgeBg, borderColor: badgeBorder }]}>
                  <Text style={[styles.fridgeInteriorBadgeText, { color: colors.text }]}>
                    {sorted.length}
                  </Text>
                </View>
              </View>
              {shelfContent}
            </ScrollView>
            <Animated.View
              pointerEvents="none"
              style={[
                styles.fridgeMist,
                {
                  opacity: mistOpacity,
                  transform: [{ translateY: mistTranslateY }],
                  backgroundColor: fridgeGlowColor,
                },
              ]}
            />
          </Animated.View>
        </View>
        <Animated.View
          pointerEvents={fridgeOpen ? "box-none" : "auto"}
          style={[
            styles.fridgeDoor,
            {
              backgroundColor: fridgeDoorColor,
              borderColor: fridgeEdgeColor,
              transform: [
                { perspective: 900 },
                { translateX: doorTranslateX },
                { rotateY: doorRotate },
                { scaleX: doorScaleX },
              ],
            },
          ]}
        >
          <View style={[styles.fridgeDoorInset, { borderColor: fridgeEdgeColor }]} pointerEvents="none" />
          <View style={styles.fridgeDoorContent} pointerEvents="none">
            <Text style={[styles.fridgeDoorTitleLarge, { color: colors.text }]} numberOfLines={1}>
              {t("pendingTitle")}
            </Text>
            <View style={[styles.fridgeDoorHeroStat, { borderColor: fridgeEdgeColor }]}>
              <Text
                style={[
                  styles.fridgeDoorHeroNumber,
                  { color: colors.text, fontSize: heroTotalFontSize, lineHeight: heroTotalFontSize + 6 },
                ]}
                numberOfLines={1}
              >
                {totalPendingLabel}
              </Text>
              <Text
                style={[styles.fridgeDoorHeroLabel, { color: colors.muted }]}
                numberOfLines={1}
              >
                {doorLabels.total}
              </Text>
            </View>
            <View style={styles.fridgeDoorStatsRow}>
              <View
                style={[
                  styles.fridgeDoorStatCard,
                  { borderColor: fridgeEdgeColor, backgroundColor: badgeBg },
                ]}
              >
                <Text style={[styles.fridgeDoorStatNumber, { color: colors.text }]} numberOfLines={1}>
                  {sorted.length}
                </Text>
                <Text style={[styles.fridgeDoorStatLabel, { color: colors.muted }]} numberOfLines={1}>
                  {doorLabels.items}
                </Text>
              </View>
              <View
                style={[
                  styles.fridgeDoorStatCard,
                  { borderColor: fridgeEdgeColor, backgroundColor: badgeBg },
                ]}
              >
                <Text style={[styles.fridgeDoorStatNumber, { color: colors.text }]} numberOfLines={1}>
                  {overdueCount}
                </Text>
                <Text style={[styles.fridgeDoorStatLabel, { color: colors.muted }]} numberOfLines={1}>
                  {doorLabels.overdue}
                </Text>
              </View>
            </View>
          </View>
          <Animated.Text
            style={[styles.fridgeDoorHint, { color: colors.muted, opacity: doorHintOpacity }]}
            numberOfLines={2}
          >
            {handleHint}
          </Animated.Text>
          <Pressable style={styles.fridgeHandleWrap} onPress={handleToggleFridge} hitSlop={12}>
            <Animated.View style={[styles.fridgeHandle, { backgroundColor: handleColor, transform: [{ scale: handleScale }] }]}>
              <View style={[styles.fridgeHandleInner, { backgroundColor: handleInnerColor }]} />
              <Animated.View style={[styles.fridgeHandleGlow, { opacity: handleGlowOpacity }]} />
            </Animated.View>
          </Pressable>
          <Animated.View
            pointerEvents="none"
            style={[styles.fridgeDoorShadow, { opacity: doorShadowOpacity }]}
          />
        </Animated.View>
      </View>
    </View>
  );

  if (!locked) {
    return <View style={[styles.pendingFridgeScreen, { backgroundColor: colors.background }]}>{fridgeBody}</View>;
  }

  return (
    <View style={[styles.pendingFridgeScreen, { backgroundColor: colors.background }]}>
      <LockedFeatureOverlay
        locked
        variantKey="thinkingList"
        colors={colors}
        t={t}
        style={styles.pendingFridgeLocked}
        contentStyle={styles.pendingFridgeLockedContent}
        borderRadius={0}
        centered
      >
        {fridgeBody}
      </LockedFeatureOverlay>
    </View>
  );
});

const ACHIEVEMENT_METRIC_TYPES = {
  SAVED_AMOUNT: "SAVED_AMOUNT",
  FREE_DAYS_TOTAL: "FREE_DAYS_TOTAL",
  FREE_DAYS_STREAK: "FREE_DAYS_STREAK",
  REFUSE_COUNT: "REFUSE_COUNT",
  FRIDGE_ITEMS_COUNT: "FRIDGE_ITEMS_COUNT",
  FRIDGE_DECISIONS: "FRIDGE_DECISIONS",
  DAILY_CHALLENGE_COMPLETED: "DAILY_CHALLENGE_COMPLETED",
  FOCUS_VICTORY_COUNT: "FOCUS_VICTORY_COUNT",
  CUSTOM_TEMPTATIONS_CREATED: "CUSTOM_TEMPTATIONS_CREATED",
};
const ACHIEVEMENT_CONDITION_MAP = {
  [ACHIEVEMENT_METRIC_TYPES.SAVED_AMOUNT]: "amount_saved",
  [ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_TOTAL]: "streak_days",
  [ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_STREAK]: "streak_days",
  [ACHIEVEMENT_METRIC_TYPES.REFUSE_COUNT]: "saves_count",
  [ACHIEVEMENT_METRIC_TYPES.FRIDGE_ITEMS_COUNT]: "pending_items",
  [ACHIEVEMENT_METRIC_TYPES.FRIDGE_DECISIONS]: "decisions_logged",
  [ACHIEVEMENT_METRIC_TYPES.DAILY_CHALLENGE_COMPLETED]: "daily_challenges_completed",
  [ACHIEVEMENT_METRIC_TYPES.FOCUS_VICTORY_COUNT]: "focus_victories",
  [ACHIEVEMENT_METRIC_TYPES.CUSTOM_TEMPTATIONS_CREATED]: "custom_temptations_created",
};

const ACHIEVEMENT_DEFS = [
  {
    id: "saved_50",
    metricType: ACHIEVEMENT_METRIC_TYPES.SAVED_AMOUNT,
    targetValue: 50,
    emoji: "ðŸ’¾",
    rewardHealth: 50,
    copy: {
      ru: { title: "ÐŸÐµÑ€Ð²Ñ‹Ðµ {{amount}}", desc: "ÐžÑ‚Ð»Ð¾Ð¶ÐµÐ½Ð¾ {{amount}} Ð½Ð° Ð¼Ð¸Ð½Ð¸-Ð¿Ð¾Ð´Ð°Ñ€Ð¾Ðº." },
      en: { title: "First {{amount}}", desc: "Already banked {{amount}} for a mini gift." },
      es: { title: "Primeros {{amount}}", desc: "Ya guardaste {{amount}} para un mini regalo." },
      fr: { title: "Premiers {{amount}}", desc: "DÃ©jÃ  mis de cÃ´tÃ© {{amount}} pour un mini cadeau." },
    },
  },
  {
    id: "saved_500",
    metricType: ACHIEVEMENT_METRIC_TYPES.SAVED_AMOUNT,
    targetValue: 500,
    emoji: "ðŸ’Ž",
    rewardHealth: 200,
    copy: {
      ru: { title: "Ð’ ÐºÐ¾Ð¿Ð¸Ð»ÐºÐµ ÑƒÐ¶Ðµ {{amount}}", desc: "ÐœÐ¾Ð¶Ð½Ð¾ ÑÑ‚Ñ€Ð¾Ð¸Ñ‚ÑŒ Ð¿Ð»Ð°Ð½Ñ‹ Ð½Ð° ÐºÑ€ÑƒÐ¿Ð½ÑƒÑŽ Ñ†ÐµÐ»ÑŒ." },
      en: { title: "{{amount}} saved already", desc: "Time to plan for a bigger goal." },
      es: { title: "Ya van {{amount}}", desc: "Hora de planear una meta mÃ¡s grande." },
      fr: { title: "{{amount}} dÃ©jÃ  Ã©pargnÃ©s", desc: "Il est temps de viser un objectif plus grand." },
    },
  },
  {
    id: "free_total_14",
    metricType: ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_STREAK,
    targetValue: 14,
    emoji: "ðŸ—“ï¸",
    rewardHealth: 70,
    copy: {
      ru: { title: "14 Ð´Ð½ÐµÐ¹ Ð±ÐµÐ· Ð¸Ð¼Ð¿ÑƒÐ»ÑŒÑÐ¾Ð²", desc: "Ð”Ð²Ðµ Ð±ÐµÑÐ¿Ð»Ð°Ñ‚Ð½Ñ‹Ñ… Ð½ÐµÐ´ÐµÐ»Ð¸ Ð¸ ÐºÐ¾ÑˆÐµÐ»Ñ‘Ðº Ð´Ð¾Ð²Ð¾Ð»ÐµÐ½." },
      en: { title: "14 impulse-free days", desc: "Two solid weeks of mindful focus." },
      es: { title: "14 dÃ­as sin impulsos", desc: "Dos semanas completas de enfoque consciente." },
      fr: { title: "14 jours sans impulsion", desc: "Deux semaines pleines de focus conscient." },
    },
  },
  {
    id: "free_streak_7",
    metricType: ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_STREAK,
    targetValue: 7,
    emoji: "âš¡ï¸",
    rewardHealth: 90,
    copy: {
      ru: { title: "Ð¡ÐµÑ€Ð¸Ñ Ð¸Ð· 7 Ð´Ð½ÐµÐ¹", desc: "ÐÐµÐ´ÐµÐ»Ñ Ð±ÐµÐ· Ñ‚Ñ€Ð°Ñ‚, Ñ‚Ñ‹ Ð² Ð¿Ð¾Ñ‚Ð¾ÐºÐµ." },
      en: { title: "7-day streak", desc: "A full week in the mindful zone." },
      es: { title: "Racha de 7 dÃ­as", desc: "Una semana completa en modo consciente." },
      fr: { title: "SÃ©rie de 7 jours", desc: "Une semaine entiÃ¨re en mode mindful." },
    },
  },
  {
    id: "fridge_items_10",
    metricType: ACHIEVEMENT_METRIC_TYPES.FRIDGE_ITEMS_COUNT,
    targetValue: 10,
    emoji: "ðŸ§Š",
    rewardHealth: 40,
    copy: {
      ru: { title: "10 Ñ…Ð¾Ñ‚ÐµÐ»Ð¾Ðº Ð² Â«Ð´ÑƒÐ¼Ð°ÐµÐ¼Â»", desc: "10 Ñ…Ð¾Ñ‚ÐµÐ»Ð¾Ðº Ð² Â«Ð´ÑƒÐ¼Ð°ÐµÐ¼Â»." },
      en: { title: "Thinking stash", desc: "10 temptations parked in Thinking." },
      es: { title: "Reserva en pausa", desc: "10 tentaciones estacionadas en En pausa." },
      fr: { title: "RÃ©serve en pause", desc: "10 tentations garÃ©es dans l'onglet En pause." },
    },
  },
  {
    id: "fridge_decisions_5",
    metricType: ACHIEVEMENT_METRIC_TYPES.FRIDGE_DECISIONS,
    targetValue: 5,
    emoji: "ðŸ¥¶",
    rewardHealth: 70,
    copy: {
      ru: { title: "Ð’Ð·Ð²ÐµÑˆÐµÐ½Ð½Ñ‹Ð¹ Ð²Ñ‹Ð±Ð¾Ñ€", desc: "Ð Ð°Ð·Ð¾Ð±Ñ€Ð°Ð»ÑÑ Ñ 5 Ñ…Ð¾Ñ‚ÐµÐ»ÐºÐ°Ð¼Ð¸ Ð¸Ð· Â«Ð´ÑƒÐ¼Ð°ÐµÐ¼Â»." },
      en: { title: "Clear-headed", desc: "Closed out 5 Thinking decisions with intent." },
      es: { title: "DecisiÃ³n clara", desc: "Resolviste 5 decisiones en En pausa con intenciÃ³n." },
      fr: { title: "Esprit clair", desc: "Tu as tranchÃ© 5 dÃ©cisions de l'onglet En pause en toute intention." },
    },
  },
  {
    id: "daily_challenges_3",
    metricType: ACHIEVEMENT_METRIC_TYPES.DAILY_CHALLENGE_COMPLETED,
    targetValue: 3,
    emoji: "ðŸ“†",
    rewardHealth: 80,
    copy: {
      ru: { title: "3 ÐµÐ¶ÐµÐ´Ð½ÐµÐ²Ð½Ñ‹Ñ… Ñ‡ÐµÐ»Ð»ÐµÐ½Ð´Ð¶Ð°", desc: "Ð’Ñ‹Ð¿Ð¾Ð»Ð½Ð¸ 3 ÐµÐ¶ÐµÐ´Ð½ÐµÐ²Ð½Ñ‹Ñ… Ñ‡ÐµÐ»Ð»ÐµÐ½Ð´Ð¶Ð° Ð¸ Ð·Ð°Ð±ÐµÑ€Ð¸ Ð±Ð¾Ð½ÑƒÑ." },
      en: { title: "3 daily challenges", desc: "Complete 3 daily challenges to build momentum." },
      es: { title: "3 retos diarios", desc: "Completa 3 retos diarios para mantener el ritmo." },
      fr: { title: "3 dÃ©fis quotidiens", desc: "Termine 3 dÃ©fis quotidiens pour garder l'Ã©lan." },
    },
  },
  {
    id: "focus_victory_3",
    metricType: ACHIEVEMENT_METRIC_TYPES.FOCUS_VICTORY_COUNT,
    targetValue: 3,
    emoji: "ðŸŽ¯",
    rewardHealth: 90,
    copy: {
      ru: { title: "Ð¤Ð¾ÐºÑƒÑ Ã—3", desc: "ÐŸÐ¾Ð±ÐµÐ´Ð¸ Ð² Ñ„Ð¾ÐºÑƒÑÐµ 3 Ñ€Ð°Ð·Ð° Ð¸ ÑƒÐºÑ€ÐµÐ¿Ð¸ Ð¿Ñ€Ð¸Ð²Ñ‹Ñ‡ÐºÑƒ." },
      en: { title: "Focus Ã—3", desc: "Win 3 focus victories against a temptation." },
      es: { title: "Enfoque Ã—3", desc: "Gana 3 victorias de enfoque contra una tentaciÃ³n." },
      fr: { title: "Focus Ã—3", desc: "Gagne 3 victoires focus contre une tentation." },
    },
  },
  {
    id: "temptations_added_5",
    metricType: ACHIEVEMENT_METRIC_TYPES.CUSTOM_TEMPTATIONS_CREATED,
    targetValue: 5,
    emoji: "âž•",
    rewardHealth: 60,
    copy: {
      ru: { title: "5 Ð½Ð¾Ð²Ñ‹Ñ… Ð¸ÑÐºÑƒÑˆÐµÐ½Ð¸Ð¹", desc: "Ð”Ð¾Ð±Ð°Ð²ÑŒ 5 Ð½Ð¾Ð²Ñ‹Ñ… Ð¸ÑÐºÑƒÑˆÐµÐ½Ð¸Ð¹, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¾Ñ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ñ‚ÑŒ Ð¸Ñ…." },
      en: { title: "5 new temptations", desc: "Add 5 new temptations to track." },
      es: { title: "5 tentaciones nuevas", desc: "Agrega 5 tentaciones nuevas para llevarles seguimiento." },
      fr: { title: "5 nouvelles tentations", desc: "Ajoute 5 nouvelles tentations Ã  suivre." },
    },
  },
];

const CHALLENGE_METRIC_TYPES = {
  SAVE_COUNT: "SAVE_COUNT",
  SAVE_AMOUNT: "SAVE_AMOUNT",
  FREE_DAY_STREAK: "FREE_DAY_STREAK",
  PENDING_DECISIONS: "PENDING_DECISIONS",
  WISH_ADDED: "WISH_ADDED",
  PENDING_ADDED: "PENDING_ADDED",
  WEEKEND_SAVES: "WEEKEND_SAVES",
  MORNING_FREE_DAY: "MORNING_FREE_DAY",
  HIGH_VALUE_SAVE: "HIGH_VALUE_SAVE",
};

const CHALLENGE_STATUS = {
  IDLE: "idle",
  ACTIVE: "active",
  COMPLETED: "completed",
  CLAIMED: "claimed",
  EXPIRED: "expired",
};

const CHALLENGE_STATUS_ORDER = {
  [CHALLENGE_STATUS.COMPLETED]: 0,
  [CHALLENGE_STATUS.ACTIVE]: 1,
  [CHALLENGE_STATUS.IDLE]: 2,
  [CHALLENGE_STATUS.EXPIRED]: 3,
  [CHALLENGE_STATUS.CLAIMED]: 4,
};
const CHALLENGE_REMINDER_WINDOWS = [
  { hour: 9, minute: 0 },
  { hour: 12, minute: 30 },
  { hour: 16, minute: 0 },
  { hour: 19, minute: 30 },
  { hour: 21, minute: 15 },
];

const hashString = (value = "") => {
  const str = String(value);
  let hash = 0;
  for (let i = 0; i < str.length; i += 1) {
    hash = (hash << 5) - hash + str.charCodeAt(i);
    hash |= 0;
  }
  return Math.abs(hash);
};

const alignReminderSlotTime = (timestamp, slot, jitterMinutes = 0) => {
  if (!slot) return timestamp;
  const slotDate = new Date(timestamp);
  slotDate.setHours(slot.hour, slot.minute || 0, 0, 0);
  if (slotDate.getTime() < timestamp) {
    slotDate.setDate(slotDate.getDate() + 1);
  }
  if (jitterMinutes) {
    slotDate.setMinutes(slotDate.getMinutes() + jitterMinutes);
  }
  return slotDate.getTime();
};

const CHALLENGE_DEFS = [
  {
    id: "micro_detox",
    emoji: "ðŸŒ€",
    metricType: CHALLENGE_METRIC_TYPES.FREE_DAY_STREAK,
    targetValue: 3,
    durationDays: 5,
    unlockLevel: 7,
    rewardHealth: 80,
    reminderOffsetsHours: [24, 72],
    copy: {
      ru: {
        title: "Ð¢Ñ€Ð¸ Ð´Ð½Ñ ÑÑÐ½Ð¾ÑÑ‚Ð¸",
        desc: "Ð¡Ð¾Ð±ÐµÑ€Ð¸ {{count}} Ð±ÐµÑÐ¿Ð»Ð°Ñ‚Ð½Ñ‹Ñ… Ð´Ð½Ñ Ð¿Ð¾Ð´Ñ€ÑÐ´ Ð¸ Ð²ÑÑ‚Ñ€ÑÑ…Ð½Ð¸ Ð±ÑŽÐ´Ð¶ÐµÑ‚.",
      },
      en: {
        title: "Clarity streak",
        desc: "Log {{count}} impulse-free days in a row for a quick reset.",
      },
      es: {
        title: "Racha de claridad",
        desc: "Marca {{count}} dÃ­as sin impulsos seguidos para reiniciar tu enfoque.",
      },
      fr: {
        title: "SÃ©rie clartÃ©",
        desc: "Note {{count}} jours sans impulsion d'affilÃ©e pour un reset express.",
      },
    },
  },
  {
    id: "refuse_sprint",
    emoji: "âš”ï¸",
    metricType: CHALLENGE_METRIC_TYPES.SAVE_COUNT,
    targetValue: 6,
    durationDays: 4,
    unlockLevel: 1,
    rewardHealth: 60,
    reminderOffsetsHours: [24, 72],
    copy: {
      ru: {
        title: "Ð¡Ð¿Ñ€Ð¸Ð½Ñ‚ Ð¾Ñ‚ÐºÐ°Ð·Ð¾Ð²",
        desc: "Ð—Ð°Ñ„Ð¸ÐºÑÐ¸Ñ€ÑƒÐ¹ {{count}} Ð¾ÑÐ¾Ð·Ð½Ð°Ð½Ð½Ñ‹Ñ… Â«Ð½ÐµÑ‚Â» Ð¿Ð¾Ð´Ñ€ÑÐ´ Ð¸ ÑƒÐºÑ€ÐµÐ¿Ð¸ Ð¿Ñ€Ð¸Ð²Ñ‹Ñ‡ÐºÑƒ.",
      },
      en: {
        title: "Decline sprint",
        desc: "Record {{count}} mindful refusals in a row to lock the habit.",
      },
      es: {
        title: "Sprint de rechazos",
        desc: "Registra {{count}} Â«noÂ» conscientes seguidos para afianzar la costumbre.",
      },
      fr: {
        title: "Sprint de refus",
        desc: "Consigne {{count}} refus lucides d'affilÃ©e pour ancrer l'habitude.",
      },
    },
  },
  {
    id: "health_boost",
    emoji: "ðŸ’°",
    metricType: CHALLENGE_METRIC_TYPES.SAVE_AMOUNT,
    targetValue: 80,
    durationDays: 7,
    unlockLevel: 2,
    rewardHealth: 120,
    reminderOffsetsHours: [24, 96],
    copy: {
      ru: {
        title: "Ð£ÑÐºÐ¾Ñ€Ð¸Ñ‚ÐµÐ»ÑŒ Ð½Ð°ÐºÐ¾Ð¿Ð»ÐµÐ½Ð¸Ð¹",
        desc: "ÐÐ°Ð¿Ñ€Ð°Ð²ÑŒ Ð² ÐºÐ¾Ð¿Ð¸Ð»ÐºÑƒ {{amount}} Ð¾Ñ‚ÐºÐ°Ð·Ð°Ð¼Ð¸ Ð²ÑÐµÐ³Ð¾ Ð·Ð° Ð½ÐµÐ´ÐµÐ»ÑŽ.",
      },
      en: {
        title: "Savings boost",
        desc: "Route {{amount}} into savings through refusals this week.",
      },
      es: {
        title: "Impulso de ahorro",
        desc: "EnvÃ­a {{amount}} a la alcancÃ­a con tus rechazos esta semana.",
      },
      fr: {
        title: "Boost d'Ã©pargne",
        desc: "Dirige {{amount}} vers l'Ã©pargne grÃ¢ce Ã  tes refus cette semaine.",
      },
    },
  },
  {
    id: "fridge_cleaner",
    emoji: "ðŸ§Š",
    metricType: CHALLENGE_METRIC_TYPES.PENDING_DECISIONS,
    targetValue: 3,
    durationDays: 6,
    unlockLevel: 3,
    rewardHealth: 80,
    reminderOffsetsHours: [24, 72, 120],
    copy: {
      ru: {
        title: "Ð Ð°Ð·Ð³Ñ€ÑƒÐ·Ð¸ Â«Ð´ÑƒÐ¼Ð°ÐµÐ¼Â»",
        desc: "Ð Ð°Ð·Ñ€ÑƒÐ»Ð¸ {{count}} Ð¾Ñ‚Ð»Ð¾Ð¶ÐµÐ½Ð½Ñ‹Ñ… Ñ€ÐµÑˆÐµÐ½Ð¸Ð¹ Ð¸ Ð¾ÑÐ²Ð¾Ð±Ð¾Ð´Ð¸ Ð³Ð¾Ð»Ð¾Ð²Ñƒ.",
      },
      en: {
        title: "Clear the shelf",
        desc: "Resolve {{count}} items from the thinking list and free up focus.",
      },
      es: {
        title: "Limpia En pausa",
        desc: "Resuelve {{count}} elementos de En pausa y libera espacio mental.",
      },
      fr: {
        title: "Vider l'Ã©tagÃ¨re",
        desc: "RÃ©sous {{count}} Ã©lÃ©ments de la liste En pause et libÃ¨re ton esprit.",
      },
    },
  },
  {
    id: "goal_creator",
    emoji: "ðŸ§­",
    metricType: CHALLENGE_METRIC_TYPES.WISH_ADDED,
    targetValue: 2,
    durationDays: 4,
    unlockLevel: 4,
    rewardHealth: 60,
    reminderOffsetsHours: [24, 48],
    copy: {
      ru: {
        title: "ÐÐ¾Ð²Ð°Ñ ÐºÐ°Ñ€Ñ‚Ð° Ñ†ÐµÐ»ÐµÐ¹",
        desc: "Ð”Ð¾Ð±Ð°Ð²ÑŒ {{count}} ÑÐ²ÐµÐ¶Ð¸Ñ… Ñ†ÐµÐ»ÐµÐ¹ Ð¸ Ð½Ð°Ð¿Ð¾Ð¼Ð½Ð¸ ÑÐµÐ±Ðµ, Ñ€Ð°Ð´Ð¸ Ñ‡ÐµÐ³Ð¾ ÑÐºÐ¾Ð½Ð¾Ð¼Ð¸ÑˆÑŒ.",
      },
      en: {
        title: "Goal-mapping",
        desc: "Add {{count}} new goals to remember why you save.",
      },
      es: {
        title: "Mapa de metas",
        desc: "AÃ±ade {{count}} nuevas metas para recordar por quÃ© ahorras.",
      },
      fr: {
        title: "Carte des objectifs",
        desc: "Ajoute {{count}} nouveaux objectifs pour te rappeler pourquoi tu Ã©pargnes.",
      },
    },
  },
  {
    id: "weekend_focus",
    emoji: "ðŸ›¡ï¸",
    metricType: CHALLENGE_METRIC_TYPES.WEEKEND_SAVES,
    targetValue: 3,
    durationDays: 8,
    unlockLevel: 3,
    rewardHealth: 90,
    reminderOffsetsHours: [48, 96],
    copy: {
      ru: {
        title: "Ð’Ñ‹Ñ…Ð¾Ð´Ð½Ñ‹Ðµ Ð¿Ð¾Ð´ Ð·Ð°Ñ‰Ð¸Ñ‚Ð¾Ð¹",
        desc: "Ð¡Ð´ÐµÐ»Ð°Ð¹ {{count}} Ð¾Ñ‚ÐºÐ°Ð·Ð° Ð¸Ð¼ÐµÐ½Ð½Ð¾ Ð² Ð²Ñ‹Ñ…Ð¾Ð´Ð½Ñ‹Ðµ Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸ ÑÐ¿Ð¾ÐºÐ¾Ð¹ÑÑ‚Ð²Ð¸Ðµ.",
      },
      en: {
        title: "Weekend shield",
        desc: "Log {{count}} refusals during the weekend rush.",
      },
      es: {
        title: "Escudo de fin de semana",
        desc: "Registra {{count}} rechazos durante el rush del fin de semana.",
      },
      fr: {
        title: "Bouclier week-end",
        desc: "Consigne {{count}} refus pendant la folie du week-end.",
      },
    },
  },
  {
    id: "morning_free",
    emoji: "ðŸŒ…",
    metricType: CHALLENGE_METRIC_TYPES.MORNING_FREE_DAY,
    targetValue: 2,
    durationDays: 5,
    unlockLevel: 7,
    rewardHealth: 70,
    reminderOffsetsHours: [12, 48],
    copy: {
      ru: {
        title: "Ð’ÐµÑ‡ÐµÑ€Ð½Ð¸Ð¹ Ñ„Ð¾ÐºÑƒÑ",
        desc: "ÐžÑ‚Ð¼ÐµÑ‡Ð°Ð¹ Ð±ÐµÑÐ¿Ð»Ð°Ñ‚Ð½Ñ‹Ð¹ Ð´ÐµÐ½ÑŒ Ð¿Ð¾ÑÐ»Ðµ 18:00 {{count}} Ñ€Ð°Ð·Ð° - Ð·Ð°ÐºÑ€ÐµÐ¿Ð¸ Ð¿Ð¾Ð±ÐµÐ´Ñƒ Ð´Ð½Ñ.",
      },
      en: {
        title: "Evening focus",
        desc: "Log a free day after 6pm {{count}} times.",
      },
      es: {
        title: "Enfoque nocturno",
        desc: "Marca un dÃ­a gratis despuÃ©s de las 18:00 {{count}} veces.",
      },
      fr: {
        title: "Focus du soir",
        desc: "Note un jour gratuit aprÃ¨s 18 h {{count}} fois.",
      },
    },
  },
  {
    id: "high_roller_shield",
    emoji: "ðŸ’Ž",
    metricType: CHALLENGE_METRIC_TYPES.HIGH_VALUE_SAVE,
    targetValue: 2,
    durationDays: 7,
    unlockLevel: 4,
    rewardHealth: 140,
    minAmountUSD: 35,
    reminderOffsetsHours: [48, 120],
    copy: {
      ru: {
        title: "Ð©Ð¸Ñ‚ Ð¾Ñ‚ Ð±Ð¾Ð»ÑŒÑˆÐ¸Ñ… Ñ‚Ñ€Ð°Ñ‚",
        desc: "ÐžÑ‚ÐºÐ°Ð¶Ð¸ÑÑŒ Ð¾Ñ‚ {{count}} ÐºÑ€ÑƒÐ¿Ð½Ñ‹Ñ… Ð¿Ð¾ÐºÑƒÐ¿Ð¾Ðº (Ð¾Ñ‚ {{limit}}) Ð¸ Ð´ÐµÑ€Ð¶Ð¸ ÐºÑƒÑ€Ñ.",
      },
      en: {
        title: "High-roller shield",
        desc: "Decline {{count}} big spends (over {{limit}}) to stay on track.",
      },
      es: {
        title: "Escudo anti derroche",
        desc: "Rechaza {{count}} compras grandes (mÃ¡s de {{limit}}) para mantener el rumbo.",
      },
      fr: {
        title: "Bouclier anti-gros achats",
        desc: "Dis non Ã  {{count}} grosses dÃ©penses (plus de {{limit}}) pour rester sur la voie.",
      },
    },
  },
  {
    id: "fridge_collector",
    emoji: "ðŸ“¥",
    metricType: CHALLENGE_METRIC_TYPES.PENDING_ADDED,
    targetValue: 3,
    durationDays: 5,
    unlockLevel: 3,
    rewardHealth: 60,
    reminderOffsetsHours: [24, 72],
    copy: {
      ru: {
        title: "ÐšÐ¾Ð»Ð»ÐµÐºÑ†Ð¸Ð¾Ð½ÐµÑ€ Ð¿Ð°ÑƒÐ·",
        desc: "ÐžÑ‚Ð¿Ñ€Ð°Ð²ÑŒ {{count}} Ð¸Ð¼Ð¿ÑƒÐ»ÑŒÑÐ¾Ð² Ð² Â«Ð¿Ð¾Ð´ÑƒÐ¼Ð°Ñ‚ÑŒ Ð¿Ð¾Ð·Ð¶ÐµÂ», Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð²Ñ‹Ð¸Ð³Ñ€Ð°Ñ‚ÑŒ Ð²Ñ€ÐµÐ¼Ñ.",
      },
      en: {
        title: "Pause collector",
        desc: "Park {{count}} temptations into â€œdecide laterâ€ to buy yourself time.",
      },
      es: {
        title: "Coleccionista de pausas",
        desc: "EnvÃ­a {{count}} tentaciones a â€œpensar despuÃ©sâ€ para ganar tiempo.",
      },
      fr: {
        title: "Collectionneur de pauses",
        desc: "Envoie {{count}} tentations dans Â« dÃ©cider plus tard Â» pour gagner du temps.",
      },
    },
  },
];

const CHALLENGE_DEF_MAP = CHALLENGE_DEFS.reduce((acc, def) => {
  acc[def.id] = def;
  return acc;
}, {});
const CHALLENGE_TYPE_LABELS = {
  [CHALLENGE_METRIC_TYPES.FREE_DAY_STREAK]: "no_spend_day",
  [CHALLENGE_METRIC_TYPES.SAVE_COUNT]: "decline_count",
  [CHALLENGE_METRIC_TYPES.SAVE_AMOUNT]: "savings_amount",
};

const CHALLENGE_STATUS_LABELS = {
  [CHALLENGE_STATUS.IDLE]: "challengeStatusAvailable",
  [CHALLENGE_STATUS.ACTIVE]: "challengeStatusActive",
  [CHALLENGE_STATUS.COMPLETED]: "challengeStatusCompleted",
  [CHALLENGE_STATUS.EXPIRED]: "challengeStatusExpired",
  [CHALLENGE_STATUS.CLAIMED]: "challengeStatusClaimed",
};

const getActiveChallengesCount = (state) =>
  Object.values(state || {}).filter((entry) => entry?.status === CHALLENGE_STATUS.ACTIVE).length;

const createChallengeEntry = (id) => ({
  id,
  status: CHALLENGE_STATUS.IDLE,
  progress: 0,
  startedAt: null,
  expiresAt: null,
  completedAt: null,
  claimedAt: null,
  failedAt: null,
  reminderNotificationIds: [],
  extra: {},
});

const createInitialChallengesState = () => {
  const base = {};
  CHALLENGE_DEFS.forEach((def) => {
    base[def.id] = createChallengeEntry(def.id);
  });
  return base;
};

const normalizeChallengesState = (rawState) => {
  const base = createInitialChallengesState();
  if (!rawState || typeof rawState !== "object") return base;
  Object.keys(base).forEach((id) => {
    const entry = rawState[id];
    if (!entry || typeof entry !== "object") return;
    base[id] = {
      ...base[id],
      ...entry,
      id,
      status: entry.status || CHALLENGE_STATUS.IDLE,
      progress: Number(entry.progress) || 0,
      extra: entry.extra && typeof entry.extra === "object" ? entry.extra : {},
      reminderNotificationIds: Array.isArray(entry.reminderNotificationIds)
        ? entry.reminderNotificationIds
        : [],
    };
  });
  return base;
};

const normalizeChallengeBadgeList = (value) => {
  if (!Array.isArray(value)) return [];
  const list = [];
  value.forEach((entry) => {
    if (!entry) return;
    if (typeof entry === "string") {
      const id = entry.trim();
      if (!id) return;
      const emoji = CHALLENGE_DEF_MAP[id]?.emoji || "";
      list.push({ id, emoji });
      return;
    }
    if (typeof entry !== "object") return;
    const id = typeof entry.id === "string" ? entry.id.trim() : "";
    if (!id) return;
    const emoji =
      typeof entry.emoji === "string" ? entry.emoji : CHALLENGE_DEF_MAP[id]?.emoji || "";
    list.push({ id, emoji });
  });
  const seen = new Set();
  return list.filter((entry) => {
    if (!entry?.id) return false;
    if (seen.has(entry.id)) return false;
    seen.add(entry.id);
    return true;
  });
};

const mergeChallengeBadgeLists = (stored, current) => {
  const normalizedStored = normalizeChallengeBadgeList(stored);
  const normalizedCurrent = normalizeChallengeBadgeList(current);
  if (!normalizedStored.length && !normalizedCurrent.length) return [];
  const next = [];
  const indexById = new Map();
  normalizedStored.forEach((entry) => {
    const emoji = CHALLENGE_DEF_MAP[entry.id]?.emoji || entry.emoji || "";
    const nextEntry = { id: entry.id, emoji };
    indexById.set(entry.id, next.length);
    next.push(nextEntry);
  });
  normalizedCurrent.forEach((entry) => {
    const emoji = CHALLENGE_DEF_MAP[entry.id]?.emoji || entry.emoji || "";
    if (indexById.has(entry.id)) {
      const idx = indexById.get(entry.id);
      const existing = next[idx];
      if (existing && existing.emoji !== emoji) {
        next[idx] = { ...existing, emoji };
      }
      return;
    }
    indexById.set(entry.id, next.length);
    next.push({ id: entry.id, emoji });
  });
  return next.filter((entry) => entry?.id && entry?.emoji);
};

const areChallengeBadgeListsEqual = (left, right) => {
  if (left === right) return true;
  if (!Array.isArray(left) || !Array.isArray(right)) return false;
  if (left.length !== right.length) return false;
  for (let i = 0; i < left.length; i += 1) {
    const a = left[i];
    const b = right[i];
    if (a?.id !== b?.id || a?.emoji !== b?.emoji) return false;
  }
  return true;
};

const getChallengeCopy = (def, language = DEFAULT_LANGUAGE) => {
  const locale = getShortLanguageKey(language);
  return def.copy?.[locale] || def.copy?.en || {};
};

const isSaveEvent = (kind) => kind === "refuse_spend" || kind === "pending_to_decline";
const isStatsSaveEvent = (kind) => isSaveEvent(kind) || kind === "income_savings";

const buildGoalCelebrationSummary = (history = [], goalId) => {
  if (!Array.isArray(history)) return null;
  const spendStats = {};
  history.forEach((entry) => {
    if (!entry || !Number.isFinite(entry.timestamp)) return;
    if (entry.kind !== "spend") return;
    const dayKey = getDayKey(entry.timestamp);
    if (!dayKey) return;
    const amount = Math.max(0, Number(entry.meta?.amountUSD) || 0);
    const current = spendStats[dayKey] || { spendUSD: 0, count: 0 };
    spendStats[dayKey] = {
      spendUSD: current.spendUSD + amount,
      count: current.count + 1,
    };
  });
  const collectSaveStats = (predicate) => {
    const dayStats = {};
    const titleTotals = {};
    const titleCounts = {};
    let totalSavedUSD = 0;
    let totalCount = 0;
    history.forEach((entry) => {
      if (!entry || !Number.isFinite(entry.timestamp)) return;
      if (!isSaveEvent(entry.kind)) return;
      if (predicate && !predicate(entry)) return;
      const meta = entry.meta || {};
      const amount = Math.max(0, Number(meta.amountUSD) || 0);
      if (!amount) return;
      const dayKey = getDayKey(entry.timestamp);
      if (!dayKey) return;
      totalSavedUSD += amount;
      totalCount += 1;
      const stats = dayStats[dayKey] || { savedUSD: 0, count: 0, titleTotals: {} };
      stats.savedUSD += amount;
      stats.count += 1;
      const title = typeof meta.title === "string" ? meta.title.trim() : "";
      if (title) {
        stats.titleTotals[title] = (stats.titleTotals[title] || 0) + amount;
        titleTotals[title] = (titleTotals[title] || 0) + amount;
        titleCounts[title] = (titleCounts[title] || 0) + 1;
      }
      dayStats[dayKey] = stats;
    });
    return { dayStats, titleTotals, titleCounts, totalSavedUSD, totalCount };
  };
  const isMatchingGoalId = (entryGoalId, targetGoalId) => {
    if (!entryGoalId || !targetGoalId) return false;
    if (entryGoalId === targetGoalId) return true;
    if (!targetGoalId.startsWith("wish_primary_goal_")) {
      return entryGoalId === getPrimaryGoalWishId(targetGoalId);
    }
    if (!entryGoalId.startsWith("wish_primary_goal_")) {
      return targetGoalId === getPrimaryGoalWishId(entryGoalId);
    }
    return false;
  };
  const goalStats = collectSaveStats((entry) => {
    if (!goalId) return false;
    const meta = entry.meta || {};
    const entryGoalId =
      meta.goalId || meta.goal_id || meta.savingTargetId || meta.saving_target_id || null;
    return isMatchingGoalId(entryGoalId, goalId);
  });
  const allStats = collectSaveStats(() => true);
  const activeStats = goalId ? goalStats : allStats;
  const usingFallback = false;
  const resolveTopTitle = (stats) => {
    if (!stats?.titleTotals) return "";
    let topTitle = "";
    let topValue = 0;
    Object.entries(stats.titleTotals).forEach(([title, value]) => {
      const amount = Number(value) || 0;
      if (amount > topValue) {
        topValue = amount;
        topTitle = title;
      }
    });
    return topTitle;
  };
  const getDayTimestamp = (key) => parseDayKey(key)?.getTime() || 0;
  const dayKeys = Object.keys(activeStats.dayStats || {});
  let strongDay = null;
  dayKeys.forEach((key) => {
    const stats = activeStats.dayStats[key];
    const savedUSD = stats?.savedUSD || 0;
    const dayTs = getDayTimestamp(key);
    if (
      !strongDay ||
      savedUSD > strongDay.savedUSD ||
      (savedUSD === strongDay.savedUSD && dayTs > strongDay.dayTs)
    ) {
      strongDay = {
        dayKey: key,
        dayTs,
        savedUSD,
        count: stats?.count || 0,
        topTitle: resolveTopTitle(stats),
      };
    }
  });
  const hasSpendOnGoalDays = dayKeys.some((key) => (spendStats[key]?.count || 0) > 0);
  let weakDay = null;
  if (hasSpendOnGoalDays) {
    dayKeys.forEach((key) => {
      const spend = spendStats[key];
      if (!spend || spend.count <= 0) return;
      const stats = activeStats.dayStats[key] || {};
      const dayTs = getDayTimestamp(key);
      if (
        !weakDay ||
        spend.count > weakDay.spendCount ||
        (spend.count === weakDay.spendCount && spend.spendUSD > weakDay.spendUSD) ||
        (spend.count === weakDay.spendCount &&
          spend.spendUSD === weakDay.spendUSD &&
          dayTs > weakDay.dayTs)
      ) {
        weakDay = {
          dayKey: key,
          dayTs,
          savedUSD: stats.savedUSD || 0,
          count: stats.count || 0,
          spendCount: spend.count,
          spendUSD: spend.spendUSD || 0,
          topTitle: resolveTopTitle(stats),
        };
      }
    });
  } else {
    dayKeys.forEach((key) => {
      const stats = activeStats.dayStats[key];
      const savedUSD = stats?.savedUSD || 0;
      const dayTs = getDayTimestamp(key);
      if (
        !weakDay ||
        savedUSD < weakDay.savedUSD ||
        (savedUSD === weakDay.savedUSD && dayTs > weakDay.dayTs)
      ) {
        weakDay = {
          dayKey: key,
          dayTs,
          savedUSD,
          count: stats?.count || 0,
          spendCount: 0,
          spendUSD: 0,
          topTitle: resolveTopTitle(stats),
        };
      }
    });
  }
  const now = Date.now();
  const lastSevenDays = [];
  let maxWeekSavedUSD = 0;
  for (let i = 6; i >= 0; i -= 1) {
    const dayKey = getDayKey(now - i * DAY_MS);
    const stats = activeStats.dayStats[dayKey] || {};
    const savedUSD = stats.savedUSD || 0;
    const count = stats.count || 0;
    maxWeekSavedUSD = Math.max(maxWeekSavedUSD, savedUSD);
    lastSevenDays.push({ dayKey, savedUSD, count });
  }
  const breakdown = Object.keys(activeStats.titleTotals || {})
    .map((title) => ({
      title,
      savedUSD: activeStats.titleTotals[title] || 0,
      count: activeStats.titleCounts?.[title] || 0,
    }))
    .sort((a, b) => {
      if (b.savedUSD !== a.savedUSD) return b.savedUSD - a.savedUSD;
      return b.count - a.count;
    })
    .slice(0, 6);
  return {
    totalSavedUSD: activeStats.totalSavedUSD,
    totalCount: activeStats.totalCount,
    daysCount: dayKeys.length,
    strongDay,
    weakDay,
    weakMode: hasSpendOnGoalDays ? "spend" : "low",
    lastSevenDays,
    maxWeekSavedUSD,
    breakdown,
    usingFallback,
  };
};

const getDayIndexFromTimestamp = (timestamp) => {
  const date = new Date(timestamp);
  date.setHours(0, 0, 0, 0);
  return Math.floor(date.getTime() / DAY_MS);
};

const isWeekendTimestamp = (timestamp) => {
  const day = new Date(timestamp).getDay();
  return day === 0 || day === 6;
};

const isEveningTimestamp = (timestamp) => {
  const hours = new Date(timestamp).getHours();
  return hours >= 18;
};

const finalizeChallengeEntry = (entry, def, timestamp) => {
  if ((entry.progress || 0) >= def.targetValue) {
    return {
      ...entry,
      progress: def.targetValue,
      status: CHALLENGE_STATUS.COMPLETED,
      completedAt: timestamp,
    };
  }
  return entry;
};

const applyChallengeEvent = (state = createInitialChallengesState(), event) => {
  if (!event) return state;
  let changed = false;
  const now = event.timestamp || Date.now();
  const nextState = { ...state };
  Object.keys(nextState).forEach((id) => {
    const entry = state[id] || createChallengeEntry(id);
    const def = CHALLENGE_DEF_MAP[id];
    if (!def || entry.status !== CHALLENGE_STATUS.ACTIVE) return;
    if (entry.expiresAt && now > entry.expiresAt) return;
    const updated = processChallengeEvent(entry, def, event, now);
    if (updated !== entry) {
      nextState[id] = updated;
      changed = true;
    }
  });
  return changed ? nextState : state;
};

const processChallengeEvent = (entry, def, event, now) => {
  const timestamp = event.timestamp || now;
  const meta = event.meta || {};
  let delta = 0;
  switch (def.metricType) {
    case CHALLENGE_METRIC_TYPES.SAVE_COUNT:
      if (isSaveEvent(event.kind)) {
        delta = 1;
      }
      break;
    case CHALLENGE_METRIC_TYPES.SAVE_AMOUNT:
      if (isSaveEvent(event.kind)) {
        const amount = Number(meta.amountUSD) || 0;
        if (amount > 0) {
          delta = amount;
        }
      }
      break;
    case CHALLENGE_METRIC_TYPES.PENDING_DECISIONS:
      if (event.kind === "pending_to_decline") {
        delta = 1;
      }
      break;
    case CHALLENGE_METRIC_TYPES.WISH_ADDED:
      if (event.kind === "wish_added") {
        delta = 1;
      }
      break;
    case CHALLENGE_METRIC_TYPES.PENDING_ADDED:
      if (event.kind === "pending_added") {
        delta = 1;
      }
      break;
    case CHALLENGE_METRIC_TYPES.WEEKEND_SAVES:
      if (isSaveEvent(event.kind) && isWeekendTimestamp(timestamp)) {
        delta = 1;
      }
      break;
    case CHALLENGE_METRIC_TYPES.HIGH_VALUE_SAVE:
      if (isSaveEvent(event.kind)) {
        const highAmount = Number(meta.amountUSD) || 0;
        if (highAmount >= (def.minAmountUSD || 0)) {
          delta = 1;
        }
      }
      break;
    case CHALLENGE_METRIC_TYPES.FREE_DAY_STREAK:
      if (event.kind === "free_day") {
        const dayIndex = getDayIndexFromTimestamp(timestamp);
        const lastDay =
          typeof entry.extra?.lastDayIndex === "number" ? entry.extra.lastDayIndex : null;
        const prevStreak = entry.extra?.currentStreak || 0;
        let nextStreak = 1;
        if (lastDay === dayIndex) {
          nextStreak = prevStreak;
        } else if (lastDay === dayIndex - 1) {
          nextStreak = prevStreak + 1;
        }
        const nextExtra = { ...entry.extra, lastDayIndex: dayIndex, currentStreak: nextStreak };
        if (nextStreak === prevStreak && lastDay === dayIndex) {
          return entry;
        }
        return finalizeChallengeEntry(
          {
            ...entry,
            progress: Math.min(def.targetValue, nextStreak),
            extra: nextExtra,
          },
          def,
          now
        );
      }
      break;
    case CHALLENGE_METRIC_TYPES.MORNING_FREE_DAY:
      if (event.kind === "free_day" && isEveningTimestamp(timestamp)) {
        const dayIndex = getDayIndexFromTimestamp(timestamp);
        const seenDays = Array.isArray(entry.extra?.morningDays) ? entry.extra.morningDays : [];
        if (seenDays.includes(dayIndex)) {
          return entry;
        }
        const updatedDays = [...seenDays, dayIndex];
        return finalizeChallengeEntry(
          {
            ...entry,
            progress: Math.min(def.targetValue, (entry.progress || 0) + 1),
            extra: { ...entry.extra, morningDays: updatedDays },
          },
          def,
          now
        );
      }
      break;
    default:
      break;
  }
  if (!delta) return entry;
  return finalizeChallengeEntry(
    {
      ...entry,
      progress: Math.min(def.targetValue, (entry.progress || 0) + delta),
    },
    def,
    now
  );
};

const expireChallenges = (state = createInitialChallengesState(), now = Date.now()) => {
  let changed = false;
  const next = { ...state };
  Object.keys(next).forEach((id) => {
    const entry = next[id];
    if (
      entry?.status === CHALLENGE_STATUS.ACTIVE &&
      entry.expiresAt &&
      now > entry.expiresAt
    ) {
      const failedAt = Number(entry.failedAt || entry.expiresAt || now) || now;
      next[id] = {
        ...entry,
        status: CHALLENGE_STATUS.EXPIRED,
        failedAt,
      };
      changed = true;
    }
  });
  return changed ? next : state;
};

const rebuildChallengeProgressFromHistory = (history = [], state = createInitialChallengesState()) => {
  if (!Array.isArray(history) || !state) return state;
  const sortedEvents = history
    .filter((event) => event && typeof event.timestamp === "number")
    .sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
  if (!sortedEvents.length) return state;
  let changed = false;
  const nextState = { ...state };
  Object.keys(nextState).forEach((id) => {
    const entry = nextState[id];
    const def = CHALLENGE_DEF_MAP[id];
    if (
      !entry ||
      !def ||
      !entry.startedAt ||
      (entry.status !== CHALLENGE_STATUS.ACTIVE && entry.status !== CHALLENGE_STATUS.COMPLETED)
    ) {
      return;
    }
    let rebuilt = {
      ...entry,
      progress: 0,
      completedAt: null,
      status: CHALLENGE_STATUS.ACTIVE,
      extra: {},
    };
    sortedEvents.forEach((event) => {
      if (!event) return;
      const ts = event.timestamp || 0;
      if (ts < entry.startedAt) return;
      if (entry.expiresAt && ts > entry.expiresAt) return;
      rebuilt = processChallengeEvent(rebuilt, def, event, ts);
    });
    const extraChanged =
      JSON.stringify(rebuilt.extra || {}) !== JSON.stringify(entry.extra || {});
    if (
      rebuilt.progress !== entry.progress ||
      rebuilt.status !== entry.status ||
      (rebuilt.completedAt || null) !== (entry.completedAt || null) ||
      extraChanged
    ) {
      nextState[id] = {
        ...entry,
        progress: rebuilt.progress,
        status: rebuilt.status,
        completedAt: rebuilt.completedAt,
        extra: rebuilt.extra,
        claimedAt: rebuilt.status === CHALLENGE_STATUS.COMPLETED ? entry.claimedAt : null,
      };
      changed = true;
    }
  });
  return changed ? nextState : state;
};

const formatChallengeTimeLeft = (ms, t) => {
  if (ms <= 0) return t("challengeTimeExpired");
  const days = Math.floor(ms / DAY_MS);
  const hours = Math.floor((ms % DAY_MS) / (1000 * 60 * 60));
  const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
  if (days > 0) {
    return `${days}${t("challengeTimeDayShort")}${hours > 0 ? ` ${hours}${t("challengeTimeHourShort")}` : ""}`.trim();
  }
  if (hours > 0) {
    return `${hours}${t("challengeTimeHourShort")}${
      minutes > 0 ? ` ${minutes}${t("challengeTimeMinuteShort")}` : ""
    }`.trim();
  }
  return `${Math.max(minutes, 1)}${t("challengeTimeMinuteShort")}`;
};

const getChallengeCooldownRemaining = (entry, now = Date.now()) => {
  if (!entry) return 0;
  if (entry.status === CHALLENGE_STATUS.CLAIMED) {
    const completedAt = Number(entry.completedAt || entry.claimedAt || 0) || 0;
    if (!completedAt) return 0;
    return Math.max(0, completedAt + CHALLENGE_REPEAT_COOLDOWN_MS - now);
  }
  if (entry.status === CHALLENGE_STATUS.EXPIRED) {
    const failedAt = Number(entry.failedAt || entry.expiresAt || 0) || 0;
    if (!failedAt) return 0;
    return Math.max(0, failedAt + CHALLENGE_FAIL_COOLDOWN_MS - now);
  }
  return 0;
};

const getChallengeSortGroup = (challenge) => {
  if (!challenge) return 3;
  if (challenge.status === CHALLENGE_STATUS.ACTIVE) return 0;
  if (challenge.canClaim || challenge.canStart) return 1;
  return 2;
};

const compareChallengesForDisplay = (a, b) => {
  const groupA = getChallengeSortGroup(a);
  const groupB = getChallengeSortGroup(b);
  if (groupA !== groupB) return groupA - groupB;
  const orderA = CHALLENGE_STATUS_ORDER[a.status] ?? 99;
  const orderB = CHALLENGE_STATUS_ORDER[b.status] ?? 99;
  if (orderA !== orderB) return orderA - orderB;
  if (a.unlockLevel !== b.unlockLevel) return a.unlockLevel - b.unlockLevel;
  if (a.durationDays !== b.durationDays) return a.durationDays - b.durationDays;
  if (a.targetValue !== b.targetValue) return a.targetValue - b.targetValue;
  return 0;
};

const sortChallengesForDisplay = (list) => list.sort(compareChallengesForDisplay);

const buildChallengesDisplay = ({
  state,
  currency,
  language,
  t,
  maxActiveChallenges = Infinity,
  averageSaveActionUSD = FALLBACK_SAVE_ACTION_USD,
  playerLevel = 1,
}) => {
  const currencyCode = currency || DEFAULT_PROFILE.currency;
  const now = Date.now();
  const limitThreshold = Number.isFinite(maxActiveChallenges) ? maxActiveChallenges : Infinity;
  const activeCount = getActiveChallengesCount(state);
  const isLimitBlockingNewStart = Number.isFinite(limitThreshold) && activeCount >= limitThreshold;
  const list = CHALLENGE_DEFS.map((def) => {
    const entry = state?.[def.id] || createChallengeEntry(def.id);
    const copy = getChallengeCopy(def, language);
    const progressValue = entry.progress || 0;
    const targetLabel =
      def.metricType === CHALLENGE_METRIC_TYPES.SAVE_AMOUNT
        ? formatCurrency(convertToCurrency(def.targetValue, currencyCode), currencyCode, { friendly: true })
        : `${def.targetValue}`;
    const amountLabel =
      def.metricType === CHALLENGE_METRIC_TYPES.SAVE_AMOUNT
        ? targetLabel
        : "";
    const limitLabel = def.minAmountUSD
      ? formatCurrency(convertToCurrency(def.minAmountUSD, currencyCode), currencyCode, { friendly: true })
      : "";
    const description =
      copy.desc && copy.desc.length
        ? renderTemplateString(copy.desc, {
            count: def.targetValue,
            days: def.durationDays,
            amount: amountLabel,
            limit: limitLabel,
          })
        : "";
    const unlockLevel = def.unlockLevel || 1;
    const isLevelLocked = playerLevel < unlockLevel;
    let timerLabel = t("challengeDurationLabel", { days: def.durationDays });
    const cooldownRemaining = getChallengeCooldownRemaining(entry, now);
    const isFailedCooldown =
      entry.status === CHALLENGE_STATUS.EXPIRED && cooldownRemaining > 0;
    const isRepeatReady =
      cooldownRemaining <= 0 &&
      (entry.status === CHALLENGE_STATUS.CLAIMED || entry.status === CHALLENGE_STATUS.EXPIRED);
    const statusForDisplay = isRepeatReady ? CHALLENGE_STATUS.IDLE : entry.status;
    const displayProgressValue = isRepeatReady ? 0 : progressValue;
    const percent =
      def.targetValue > 0 ? Math.min(1, displayProgressValue / def.targetValue) : 0;
    const progressLabelValue =
      def.metricType === CHALLENGE_METRIC_TYPES.SAVE_AMOUNT
        ? formatCurrency(convertToCurrency(displayProgressValue, currencyCode), currencyCode)
        : `${Math.floor(displayProgressValue)}`;
    const cooldownLabel = cooldownRemaining
      ? t(isFailedCooldown ? "challengeFailCooldownLabel" : "challengeCooldownLabel", {
          time: formatChallengeTimeLeft(cooldownRemaining, t),
        })
      : "";
    if (statusForDisplay === CHALLENGE_STATUS.ACTIVE && entry.expiresAt) {
      timerLabel = t("challengeTimeLeftLabel", {
        time: formatChallengeTimeLeft(Math.max(0, entry.expiresAt - now), t),
      });
    } else if (statusForDisplay === CHALLENGE_STATUS.COMPLETED) {
      timerLabel = t("challengeReadyToClaim");
    } else if (statusForDisplay === CHALLENGE_STATUS.CLAIMED) {
      timerLabel = cooldownLabel || t("challengeRestartHint", { days: def.durationDays });
    } else if (statusForDisplay === CHALLENGE_STATUS.EXPIRED) {
      timerLabel = cooldownLabel || t("challengeRestartHint", { days: def.durationDays });
    }
    const baseCanStart =
      entry.status === CHALLENGE_STATUS.IDLE ||
      entry.status === CHALLENGE_STATUS.EXPIRED ||
      entry.status === CHALLENGE_STATUS.CLAIMED;
    const cooldownBlocksStart =
      (entry.status === CHALLENGE_STATUS.CLAIMED || entry.status === CHALLENGE_STATUS.EXPIRED) &&
      cooldownRemaining > 0;
    const limitBlocksStart = baseCanStart && isLimitBlockingNewStart;
    const canStart = baseCanStart && !limitBlocksStart && !isLevelLocked && !cooldownBlocksStart;
    const canClaim = entry.status === CHALLENGE_STATUS.COMPLETED;
    let actionLabel = t("challengeActiveCta");
    if (isLevelLocked) {
      actionLabel = t("challengeLockedLevel", { level: unlockLevel });
    }
    if (limitBlocksStart) {
      actionLabel = t("challengeLimitReachedAction", { limit: maxActiveChallenges });
    } else if (cooldownBlocksStart) {
      actionLabel = cooldownLabel;
    } else if (canClaim) {
      actionLabel = t("challengeClaimCta");
    } else if (canStart) {
      actionLabel = t("challengeStartCta");
    }
    const scaledReward = getScaledChallengeReward(def.rewardHealth);
    const potentialSavingsUSD =
      def.metricType === CHALLENGE_METRIC_TYPES.SAVE_AMOUNT
        ? def.targetValue
        : def.metricType === CHALLENGE_METRIC_TYPES.SAVE_COUNT
        ? Math.max(1, averageSaveActionUSD) * def.targetValue
        : 0;
    const potentialSavingsLabel =
      potentialSavingsUSD > 0
        ? formatCurrency(convertToCurrency(potentialSavingsUSD, currencyCode), currencyCode)
        : "";
    return {
      id: def.id,
      emoji: def.emoji,
      title: copy.title || "",
      description,
      rewardHealth: scaledReward,
      rewardLabel: formatHealthRewardLabel(scaledReward, language),
      status: entry.status,
      statusLabel: t(
        CHALLENGE_STATUS_LABELS[statusForDisplay] || CHALLENGE_STATUS_LABELS[CHALLENGE_STATUS.IDLE]
      ),
      progressPercent: percent,
      progressValue: displayProgressValue,
      targetValue: def.targetValue,
      durationDays: def.durationDays,
      metricType: def.metricType,
      isCountMetric: def.metricType !== CHALLENGE_METRIC_TYPES.SAVE_AMOUNT,
      progressLabel: t("challengeProgressLabel", {
        current: progressLabelValue,
        target: targetLabel,
      }),
      timerLabel,
      canStart,
      canClaim,
      isLevelLocked,
      unlockLevel,
      actionLabel,
      potentialSavingsLabel,
    };
  });
  return sortChallengesForDisplay(list);
};

const getAchievementRemainingLabel = (metricType, remaining, currency, t) => {
  if (!remaining || remaining <= 0) return "";
  const count = Math.max(1, Math.ceil(remaining));
  switch (metricType) {
    case ACHIEVEMENT_METRIC_TYPES.SAVED_AMOUNT:
      return t("rewardRemainingAmount", {
        amount: formatCurrency(convertToCurrency(remaining, currency), currency, { friendly: true }),
      });
    case ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_TOTAL:
    case ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_STREAK:
      return t("rewardRemainingDays", { count });
    case ACHIEVEMENT_METRIC_TYPES.REFUSE_COUNT:
      return t("rewardRemainingRefuse", { count });
    case ACHIEVEMENT_METRIC_TYPES.FRIDGE_ITEMS_COUNT:
      return t("rewardRemainingFridge", { count });
    case ACHIEVEMENT_METRIC_TYPES.FRIDGE_DECISIONS:
      return t("rewardRemainingDecisions", { count });
    default:
      return t("rewardLockedGeneric", { count });
  }
};

const buildAchievements = ({
  savedTotalUSD,
  declineCount,
  freeDayStats,
  pendingCount,
  decisionStats,
  dailyChallengeCompletedCount = 0,
  focusVictoryCount = 0,
  customTemptationsCreatedCount = 0,
  currency,
  t,
  language,
}) => {
  const fridgeDecisionsResolved =
    (decisionStats?.resolvedToDeclines || 0) + (decisionStats?.resolvedToWishes || 0);
  const metricValues = {
    [ACHIEVEMENT_METRIC_TYPES.SAVED_AMOUNT]: savedTotalUSD,
    [ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_TOTAL]: freeDayStats?.total || 0,
    [ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_STREAK]: freeDayStats?.current || 0,
    [ACHIEVEMENT_METRIC_TYPES.REFUSE_COUNT]: declineCount || 0,
    [ACHIEVEMENT_METRIC_TYPES.FRIDGE_ITEMS_COUNT]: pendingCount,
    [ACHIEVEMENT_METRIC_TYPES.FRIDGE_DECISIONS]: fridgeDecisionsResolved,
    [ACHIEVEMENT_METRIC_TYPES.DAILY_CHALLENGE_COMPLETED]: dailyChallengeCompletedCount,
    [ACHIEVEMENT_METRIC_TYPES.FOCUS_VICTORY_COUNT]: focusVictoryCount,
    [ACHIEVEMENT_METRIC_TYPES.CUSTOM_TEMPTATIONS_CREATED]: customTemptationsCreatedCount,
  };

  return ACHIEVEMENT_DEFS.map((def) => {
    const value = metricValues[def.metricType] || 0;
    const target = def.targetValue || 0;
    const unlocked = target ? value >= target : true;
    const progress = target ? Math.min(value / target, 1) : 1;
    const remaining = target ? Math.max(target - value, 0) : 0;
    const amountLabel =
      def.metricType === ACHIEVEMENT_METRIC_TYPES.SAVED_AMOUNT
        ? formatCurrency(convertToCurrency(def.targetValue || 0, currency), currency, { friendly: true })
        : null;
    const copySource = def.copy[language] || def.copy.en;
    const applyAmount = (text) =>
      typeof text === "string" && amountLabel ? text.replace("{{amount}}", amountLabel) : text || "";
    const remainingLabel = getAchievementRemainingLabel(def.metricType, remaining, currency, t);
    return {
      id: def.id,
      emoji: def.emoji,
      title: applyAmount(copySource.title),
      desc: applyAmount(copySource.desc),
      unlocked,
      progress,
      currentValue: value,
      targetValue: target,
      metricType: def.metricType,
      remainingLabel,
      rewardHealth: def.rewardHealth || HEALTH_PER_REWARD,
    };
  });
};

const RewardsScreen = React.memo(function RewardsScreen({
  achievements = [],
  challenges = [],
  activePane = "challenges",
  onPaneChange = () => {},
  onChallengeAccept = () => {},
  onChallengeClaim = () => {},
  onChallengeCancel = () => {},
  t,
  colors,
  savedTotalUSD = 0,
  currency = DEFAULT_PROFILE.currency,
  onRewardClaim = () => {},
  healthRewardAmount = HEALTH_PER_REWARD,
  language = DEFAULT_LANGUAGE,
  dailyChallenge = null,
  showChallenges = true,
  showDailyChallengeWidget = true,
  rewardsLocked = false,
  challengesLocked = false,
  dailyChallengeLocked = false,
  scrollRef,
}) {
  const rewardList = Array.isArray(achievements) ? achievements.filter(Boolean) : [];
  const displayRewards = rewardsLocked ? rewardList.slice(0, 2) : rewardList;
  const challengeList = useMemo(() => {
    const list = Array.isArray(challenges) ? challenges.filter(Boolean) : [];
    return list
      .map((entry, index) => ({ entry, index }))
      .sort((a, b) => {
        const base = compareChallengesForDisplay(a.entry, b.entry);
        if (base !== 0) return base;
        return a.index - b.index;
      })
      .map((item) => item.entry);
  }, [challenges]);
  const isDarkTheme = colors.background === THEMES.dark.background;
  const pane = activePane === "challenges" ? "challenges" : "rewards";
  const challengeSwipeCloserRef = useRef(null);
  const handleChallengeSwipeOpen = useCallback((closer) => {
    if (challengeSwipeCloserRef.current && challengeSwipeCloserRef.current !== closer) {
      challengeSwipeCloserRef.current();
    }
    challengeSwipeCloserRef.current = closer;
  }, []);
  const handleChallengeSwipeClose = useCallback((closer) => {
    if (!closer || challengeSwipeCloserRef.current === closer) {
      challengeSwipeCloserRef.current = null;
    }
  }, []);
  const formatRewardLabel = useCallback(
    (amount) => formatHealthRewardLabel(amount, language),
    [language]
  );
  const dailyChallengeRewardLabel = useMemo(() => {
    const bonus = Number(dailyChallenge?.rewardBonus) || 0;
    const base = Number(dailyChallenge?.baseReward) || 0;
    const total = Number(dailyChallenge?.rewardTotal) || base + bonus;
    return formatHealthRewardLabel(total, language);
  }, [dailyChallenge?.baseReward, dailyChallenge?.rewardBonus, dailyChallenge?.rewardTotal, language]);

  const renderChallengeCard = (challenge) => {
    const isLocked = challenge.isLevelLocked;
    const actionPalette = challenge.canClaim && !isLocked
      ? { background: SAVE_ACTION_COLOR, text: "#fff" }
      : challenge.canStart && !isLocked
      ? { background: colors.text, text: colors.background }
      : { background: colors.border, text: colors.muted };
    const confirmAccept = () => {
      Alert.alert(
        t("challengeAcceptConfirmTitle"),
        t("challengeAcceptConfirmMessage", { title: challenge.title }),
        [
          { text: t("challengeAcceptConfirmNo"), style: "cancel" },
          {
            text: t("challengeAcceptConfirmYes"),
            style: "default",
            onPress: () => onChallengeAccept?.(challenge.id),
          },
        ]
      );
    };
    const confirmCancel = () => {
      Alert.alert(
        t("challengeCancelConfirmTitle"),
        t("challengeCancelConfirmMessage", { title: challenge.title }),
        [
          { text: t("challengeCancelConfirmNo"), style: "cancel" },
          {
            text: t("challengeCancelConfirmYes"),
            style: "destructive",
            onPress: () => onChallengeCancel?.(challenge.id),
          },
        ]
      );
    };
    const handleActionPress = () => {
      if (challenge.canClaim) {
        onChallengeClaim?.(challenge.id);
      } else if (challenge.canStart) {
        confirmAccept();
      }
    };
    const isActionEnabled = !isLocked && (challenge.canClaim || challenge.canStart);
    const isSwipeEnabled = challenge.status === CHALLENGE_STATUS.ACTIVE;
    const cardBody = (
      <View
        style={[
          styles.challengeCard,
          { backgroundColor: colors.card, borderColor: colors.border },
          isLocked && styles.challengeCardLocked,
        ]}
      >
        <View
          style={[
            styles.challengeRewardChip,
            styles.challengeRewardChipFloating,
            { backgroundColor: colors.text },
          ]}
        >
          <HealthRewardTokens
            amount={challenge.rewardHealth}
            color={colors.background}
            iconSize={12}
            maxItems={2}
            textSize={10}
            rowStyle={styles.healthRewardTokenRowCompact}
          />
        </View>
        <View style={styles.challengeHeader}>
          <Text style={styles.challengeEmoji}>{challenge.emoji}</Text>
            <View style={{ flex: 1, gap: 4 }}>
              <Text
                style={[styles.challengeTitle, { color: colors.text }]}
                numberOfLines={2}
              adjustsFontSizeToFit
              minimumFontScale={0.9}
            >
              {challenge.title}
              </Text>
              <Text style={[styles.challengeDesc, { color: colors.muted }]} numberOfLines={3}>
                {challenge.description}
              </Text>
              {challenge.potentialSavingsLabel ? (
                <Text style={[styles.challengePotential, { color: colors.text }]}>
                  {t("challengePotentialSavings", { amount: challenge.potentialSavingsLabel })}
                </Text>
              ) : null}
            </View>
          </View>
        <View style={styles.challengeMetaRow}>
          <Text style={[styles.challengeStatus, { color: colors.muted }]}>{challenge.statusLabel}</Text>
          <Text style={[styles.challengeTimer, { color: colors.muted }]}>{challenge.timerLabel}</Text>
        </View>
        {challenge.isCountMetric ? (
          <ChallengeProgressDots total={challenge.targetValue} progress={challenge.progressValue} colors={colors} />
        ) : (
          <View style={[styles.challengeProgressBar, { backgroundColor: colors.border }]}>
            <View
              style={[
                styles.challengeProgressFill,
                { width: `${challenge.progressPercent * 100}%`, backgroundColor: colors.text },
              ]}
            />
          </View>
        )}
        <Text style={[styles.challengeProgressLabel, { color: colors.muted }]}>{challenge.progressLabel}</Text>
        {isLocked ? (
          <View style={styles.challengeLockRow}>
            <Text style={[styles.challengeLockText, { color: colors.muted }]}>
              {t("challengeLockedLevel", { level: challenge.unlockLevel })}
            </Text>
          </View>
        ) : (
          <TouchableOpacity
            style={[styles.challengeActionButton, { backgroundColor: actionPalette.background }]}
            activeOpacity={0.9}
            disabled={!isActionEnabled}
            onPress={handleActionPress}
          >
            <Text style={[styles.challengeActionText, { color: actionPalette.text }]}>
              {challenge.actionLabel}
            </Text>
          </TouchableOpacity>
        )}
      </View>
    );
    if (isSwipeEnabled) {
      return (
        <SwipeableChallengeCard
          key={challenge.id}
          colors={colors}
          cancelLabel={t("challengeCancelAction")}
          onCancel={confirmCancel}
          onSwipeOpen={handleChallengeSwipeOpen}
          onSwipeClose={handleChallengeSwipeClose}
        >
          {cardBody}
        </SwipeableChallengeCard>
      );
    }
    return (
      <View key={challenge.id}>
        {cardBody}
      </View>
    );
  };

  const renderRewardCard = (reward) => {
    const rewardPayout = reward.rewardHealth || healthRewardAmount;
    const rewardLabel = formatRewardLabel(rewardPayout);
    const rewardPalette = reward.unlocked
      ? isDarkTheme
        ? {
            background: "rgba(8,48,30,0.9)",
            border: "rgba(74,221,152,0.6)",
            text: "#D6FFE8",
            badgeBg: "rgba(74,221,152,0.2)",
            badgeText: "#82FFC6",
          }
        : {
            background: "#E6F9EE",
            border: "rgba(58,174,120,0.45)",
            text: "#0E512F",
            badgeBg: "rgba(58,174,120,0.15)",
            badgeText: "#0F5C35",
          }
      : {
          background: colors.card,
          border: colors.border,
          text: colors.text,
          badgeBg: colors.text,
          badgeText: colors.background,
        };
    const cardContent = (
      <View
        style={[
          styles.goalCard,
          {
            backgroundColor: rewardPalette.background,
            borderColor: rewardPalette.border,
            borderWidth: reward.unlocked ? 2 : 1,
            shadowOpacity: reward.unlocked ? 0.15 : 0,
            shadowColor: rewardPalette.border,
            shadowOffset: { width: 0, height: reward.unlocked ? 6 : 0 },
            shadowRadius: reward.unlocked ? 12 : 0,
            elevation: reward.unlocked ? 4 : 0,
          },
        ]}
      >
        <View style={styles.rewardHeader}>
          <View style={{ flexDirection: "row", gap: 12, alignItems: "center", flex: 1 }}>
            <Text style={{ fontSize: 28 }}>{reward.emoji}</Text>
            <View style={{ flex: 1 }}>
              <Text style={[styles.goalTitle, { color: rewardPalette.text }]}>{reward.title}</Text>
              <Text style={[styles.goalDesc, { color: colors.muted }]}>{reward.desc}</Text>
            </View>
          </View>
        {reward.unlocked && (
          <View style={styles.rewardBadgeContainer}>
            <View
              style={[
                styles.rewardBadge,
                styles.rewardBadgeFloating,
                { backgroundColor: rewardPalette.badgeBg },
              ]}
            >
              {reward.claimed ? (
                <Text style={[styles.rewardBadgeText, { color: rewardPalette.badgeText }]}>
                  {t("rewardBadgeClaimed")}
                </Text>
              ) : (
                <HealthRewardTokens
                  amount={rewardPayout}
                  color={rewardPalette.badgeText}
                  iconSize={18}
                  maxItems={3}
                />
              )}
            </View>
          </View>
        )}
        </View>
        <View style={[styles.goalProgressBar, { backgroundColor: colors.border }]}>
          <View
            style={[
              styles.goalProgressFill,
              {
                width: `${reward.progress * 100}%`,
                backgroundColor: reward.unlocked ? rewardPalette.badgeText : colors.muted,
              },
            ]}
          />
        </View>
        <Text style={[styles.goalDesc, { color: colors.muted }]}>
          {reward.unlocked
            ? reward.claimed
              ? t("rewardClaimedStatus")
              : t("rewardClaimHint", { amount: rewardLabel })
            : reward.remainingLabel || t("rewardLockedGeneric", { count: 1 })}
        </Text>
        {reward.unlocked && !reward.claimed && (
          <TouchableOpacity
            style={[styles.rewardClaimButton, { backgroundColor: rewardPalette.badgeText }]}
            onPress={(event) => {
              event?.stopPropagation?.();
              onRewardClaim?.(reward);
            }}
          >
            <Text style={[styles.rewardClaimButtonText, { color: rewardPalette.background }]}>
              {t("rewardClaimCta")}
            </Text>
          </TouchableOpacity>
        )}
      </View>
    );
    const isClaimable = reward.unlocked && !reward.claimed;
    return (
      <TouchableOpacity
        key={reward.id}
        activeOpacity={isClaimable ? 0.85 : 1}
        onPress={() => (isClaimable ? onRewardClaim?.(reward) : undefined)}
        disabled={!isClaimable}
      >
        {cardContent}
      </TouchableOpacity>
    );
  };
  const renderDailyChallengeWidget = () => {
    if (dailyChallengeLocked) {
      return (
        <LockedFeatureCard
          variantKey="rewardsDaily"
          colors={colors}
          t={t}
          style={styles.lockedFeatureInlineCard}
        />
      );
    }
    if (!showDailyChallengeWidget || !dailyChallenge) return null;
    const progress = Math.min(
      Math.max(Number(dailyChallenge.progress) || 0, 0),
      Number(dailyChallenge.target) || 1
    );
    const target = Math.max(Number(dailyChallenge.target) || 1, 1);
    const rewardLabel = dailyChallengeRewardLabel;
    const rewardAmount = Math.max(
      0,
      Number(dailyChallenge.rewardTotal ?? dailyChallenge.rewardBonus) || 0
    );
    const percent = Math.min(Math.max(progress / target, 0), 1);
    const widgetBackground = colors.background === THEMES.dark.background ? "rgba(255,255,255,0.05)" : "#FFF7EA";
    const widgetBorder = colors.background === THEMES.dark.background ? "rgba(255,255,255,0.15)" : "rgba(0,0,0,0.06)";
    return (
      <View
        style={[
          styles.dailyChallengeWidget,
          { backgroundColor: widgetBackground, borderColor: widgetBorder },
        ]}
      >
        <View
          style={[
            styles.challengeRewardChip,
            styles.challengeRewardChipFloating,
            { backgroundColor: colors.text },
          ]}
        >
          <HealthRewardTokens
            amount={rewardAmount}
            color={colors.background}
            iconSize={12}
            maxItems={2}
            textSize={10}
            rowStyle={styles.healthRewardTokenRowCompact}
          />
        </View>
        <View style={styles.dailyChallengeWidgetHeader}>
          <View style={[styles.dailyChallengeBadge, { borderColor: widgetBorder }]}>
            <Text style={[styles.dailyChallengeBadgeText, { color: colors.text }]}>
              {t("dailyChallengeWidgetBadge")}
            </Text>
          </View>
        </View>
        <View style={styles.dailyChallengeWidgetBody}>
          <View style={styles.dailyChallengeEmojiPill}>
            <Text style={styles.dailyChallengeEmojiText}>{dailyChallenge.emoji || "âœ¨"}</Text>
          </View>
          <View style={{ flex: 1, gap: 2 }}>
            <Text style={[styles.dailyChallengeWidgetTitle, { color: colors.text }]}>
              {t("dailyChallengeWidgetTitle")}
            </Text>
            <Text style={[styles.dailyChallengeWidgetDesc, { color: colors.muted }]}>
              {t("dailyChallengeWidgetDesc", {
                temptation: dailyChallenge.title,
              })}
            </Text>
          </View>
        </View>
        <View style={{ gap: 6 }}>
          <View style={[styles.dailyChallengeProgressBar, { backgroundColor: widgetBorder }]}>
            <View
              style={[
                styles.dailyChallengeProgressFill,
                { width: `${percent * 100}%`, backgroundColor: colors.text },
              ]}
            />
          </View>
          <View style={styles.dailyChallengeWidgetFooter}>
            <Text style={[styles.dailyChallengeProgressLabel, { color: colors.muted }]}>
              {t("dailyChallengeWidgetProgress", { current: `${progress}`, target: `${target}` })}
            </Text>
            <Text style={[styles.dailyChallengeRewardLabel, { color: colors.text }]}>
              {t("dailyChallengeWidgetReward", { amount: rewardLabel })}
            </Text>
          </View>
        </View>
      </View>
    );
  };

  const tabItems = useMemo(() => {
    const tabs = [{ id: "rewards", label: t("challengeRewardsTabTitle") }];
    if (showChallenges) {
      tabs.unshift({ id: "challenges", label: t("challengeTabTitle") });
    }
    return tabs;
  }, [showChallenges, t]);

  return (
    <ScrollView
      ref={scrollRef}
      style={[styles.container, { backgroundColor: colors.background }]}
      contentContainerStyle={{ paddingBottom: 200, gap: 16 }}
      showsVerticalScrollIndicator={false}
    >
      <View>
        <Text style={[styles.header, { color: colors.text }]}>{t("purchasesTitle")}</Text>
        <Text style={[styles.purchasesSubtitle, { color: colors.muted }]}>
          {t("purchasesSubtitle")}
        </Text>
      </View>
      {tabItems.length > 1 && (
        <View style={styles.rewardsTabs}>
          {tabItems.map((tab) => {
            const isActive = pane === tab.id;
            return (
              <TouchableOpacity
                key={tab.id}
                style={[
                  styles.rewardsTabButton,
                  {
                    backgroundColor: isActive ? colors.text : "transparent",
                    borderColor: isActive ? colors.text : colors.border,
                  },
                ]}
                activeOpacity={0.85}
                onPress={() => {
                  if (tab.id !== pane) {
                    onPaneChange?.(tab.id);
                  }
                }}
              >
                <Text
                  style={[
                    styles.rewardsTabText,
                    { color: isActive ? colors.background : colors.text },
                  ]}
                >
                  {tab.label}
                </Text>
              </TouchableOpacity>
            );
          })}
        </View>
      )}
      {showChallenges && pane === "challenges" ? (
        challengesLocked ? (
          <LockedFeatureOverlay
            locked
            variantKey="rewardsChallenges"
            colors={colors}
            t={t}
            style={styles.lockedFeaturePane}
            contentStyle={styles.lockedFeaturePaneContent}
            centered
          >
            <View style={{ gap: 16 }}>
              {renderDailyChallengeWidget()}
              {challengeList.map(renderChallengeCard)}
              {!challengeList.length && !dailyChallenge && (
                <Text style={[styles.historyEmpty, { color: colors.muted }]}>
                  {t("rewardsEmpty")}
                </Text>
              )}
            </View>
          </LockedFeatureOverlay>
        ) : (
          <View style={{ gap: 16 }}>
            {renderDailyChallengeWidget()}
            {challengeList.map(renderChallengeCard)}
            {!challengeList.length && !dailyChallenge && (
              <Text style={[styles.historyEmpty, { color: colors.muted }]}>
                {t("rewardsEmpty")}
              </Text>
            )}
          </View>
        )
      ) : rewardsLocked ? (
        <LockedFeatureOverlay
          locked
          variantKey="rewardsCustomization"
          colors={colors}
          t={t}
          style={styles.lockedFeaturePane}
          contentStyle={styles.lockedFeaturePaneContent}
          centered
        >
          <View style={{ gap: 16 }}>
            {displayRewards.map(renderRewardCard)}
            {!displayRewards.some((item) => item.unlocked) && (
              <Text style={[styles.historyEmpty, { color: colors.muted }]}>{t("rewardsEmpty")}</Text>
            )}
          </View>
        </LockedFeatureOverlay>
      ) : (
        <View style={{ gap: 16 }}>
          {displayRewards.map(renderRewardCard)}
          {!displayRewards.some((item) => item.unlocked) && (
            <Text style={[styles.historyEmpty, { color: colors.muted }]}>{t("rewardsEmpty")}</Text>
          )}
        </View>
      )}
    </ScrollView>
  );
});

const ProfileScreen = React.memo(function ProfileScreen({
  profile,
  stats,
  editMode = "none",
  onFieldChange,
  onEditPress,
  onSpendEditPress,
  onReportsPress,
  reportsBadgeVisible = false,
  reportsLocked = false,
  reportsUnlockLevel = FEATURE_UNLOCK_LEVELS.reports || 6,
  onCancelEdit,
  onSaveEdit,
  onThemeToggle,
  onLanguageChange,
  onCurrencyChange,
  onIncomeEntryOpen,
  soundEnabled = true,
  onSoundToggle,
  spendReducesSavings = false,
  onSpendReductionToggle,
  onResetData,
  onPickImage,
  onHistoryDelete = () => {},
  theme,
  isPremiumUser = false,
  language,
  currencyValue,
  history = [],
  freeDayStats = INITIAL_FREE_DAY_STATS,
  rewardBadgeCount = 0,
  challengeBadges = [],
  challengeBadgeCount = 0,
  monthlyIncomeUSD = 0,
  t,
  colors,
  moodPreset = null,
  mascotImageSource,
  openAddCategoryModal,
  openManageCategoriesModal,
  scrollRef,
}) {
  const fallbackAvatar = mascotImageSource || CLASSIC_TAMAGOTCHI_ANIMATIONS.idle;
  const resolvedAvatarUri = useMemo(() => resolveAvatarUri(profile?.avatar), [profile?.avatar]);
  const currentCurrency = currencyValue || profile.currency || DEFAULT_PROFILE.currency;
  const isEditingIdentity = editMode === "identity";
  const isEditingSpend = editMode === "spend";
  const isEditing = isEditingIdentity || isEditingSpend;
  const canStartSpendEdit = editMode === "none";
  const isDarkTheme = theme === "dark";
  const normalizedLanguageValue = normalizeLanguage(language || DEFAULT_LANGUAGE);
  const isRomanceLocale = normalizedLanguageValue === "es" || normalizedLanguageValue === "fr";
  const reportsDisabled = !onReportsPress;
  const reportsLockedState = !!reportsLocked;
  const reportsLockLabel = reportsLocked
    ? normalizedLanguageValue === "ru"
      ? "Ð”Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾ Ð² Premium"
      : normalizedLanguageValue === "fr"
      ? "Disponible en Premium"
      : normalizedLanguageValue === "es"
      ? "Disponible en Premium"
      : "Available in Premium"
    : t("featureLockedLevelLabel", { level: reportsUnlockLevel });
  const reportsPremiumAccent = useMemo(() => {
    if (!reportsLockedState) return colors.muted;
    if (theme === PRO_THEME_ID) return "#9BA8FF";
    if (isDarkTheme) return "#8CB8FF";
    return "#4353FF";
  }, [colors.muted, isDarkTheme, reportsLockedState, theme]);
  const reportsPremiumBackground = useMemo(() => {
    if (Platform.OS === "android") {
      return blendColors(colors.card || "#FFFFFF", reportsPremiumAccent, isDarkTheme ? 0.34 : 0.22);
    }
    return colorWithAlpha(reportsPremiumAccent, isDarkTheme ? 0.2 : 0.12);
  }, [colors.card, isDarkTheme, reportsPremiumAccent]);
  const reportsPremiumBorder = useMemo(
    () => colorWithAlpha(reportsPremiumAccent, isDarkTheme ? 0.58 : 0.34),
    [isDarkTheme, reportsPremiumAccent]
  );
  const reportsPremiumPillBackground = useMemo(() => {
    if (Platform.OS === "android") {
      return blendColors(colors.card || "#FFFFFF", reportsPremiumAccent, isDarkTheme ? 0.42 : 0.28);
    }
    return colorWithAlpha(reportsPremiumAccent, isDarkTheme ? 0.24 : 0.16);
  }, [colors.card, isDarkTheme, reportsPremiumAccent]);
  const historyEntries = Array.isArray(history) ? history : [];
  const [historyVisibleWindowMs, setHistoryVisibleWindowMs] = useState(PROFILE_HISTORY_PAGE_WINDOW_MS);
  const visibleHistoryEntries = useMemo(
    () => {
      const cutoffTimestamp = Date.now() - historyVisibleWindowMs;
      return historyEntries.filter((entry) => {
        const timestamp = Number(entry?.timestamp) || 0;
        if (!timestamp) return true;
        return timestamp >= cutoffTimestamp;
      });
    },
    [historyEntries, historyVisibleWindowMs]
  );
  const hasMoreHistoryEntries = useMemo(
    () => {
      const cutoffTimestamp = Date.now() - historyVisibleWindowMs;
      return historyEntries.some((entry) => {
        const timestamp = Number(entry?.timestamp) || 0;
        return timestamp > 0 && timestamp < cutoffTimestamp;
      });
    },
    [historyEntries, historyVisibleWindowMs]
  );
  const historyLastIndex = visibleHistoryEntries.length - 1;
  const locale = getFormatLocale(language);
  const formatLocalAmount = (valueUSD = 0) =>
    formatCurrency(convertToCurrency(valueUSD || 0, currentCurrency), currentCurrency);
  const [baselineInput, setBaselineInput] = useState("");
  const [customSpendInputs, setCustomSpendInputs] = useState({
    title: "",
    amount: "",
    frequency: "",
  });
  const profileEditingRef = useRef(isEditingSpend);
  const profileCurrencyRef = useRef(currentCurrency);
  const profileCurrencyScrollRef = useRef(null);
  const profileCurrencyNudgeRan = useRef(false);
  useEffect(() => {
    if (profileCurrencyNudgeRan.current) return undefined;
    profileCurrencyNudgeRan.current = true;
    let backTimeout;
    const forwardTimeout = setTimeout(() => {
      profileCurrencyScrollRef.current?.scrollTo({ x: 48, animated: true });
      backTimeout = setTimeout(() => {
        profileCurrencyScrollRef.current?.scrollTo({ x: 0, animated: true });
      }, 650);
    }, 900);
    return () => {
      clearTimeout(forwardTimeout);
      if (backTimeout) clearTimeout(backTimeout);
    };
  }, []);
  useEffect(() => {
    const editingJustOpened = isEditingSpend && !profileEditingRef.current;
    const currencyChanged = isEditingSpend && profileCurrencyRef.current !== currentCurrency;
    profileEditingRef.current = isEditingSpend;
    profileCurrencyRef.current = currentCurrency;
    if (!editingJustOpened && !currencyChanged) return;
    const baselineUSD = profile.spendingProfile?.baselineMonthlyWasteUSD || 0;
    setBaselineInput(
      baselineUSD > 0 ? formatNumberInputValue(convertToCurrency(baselineUSD, currentCurrency)) : ""
    );
    const customAmountUSD = resolveCustomPriceUSD(
      profile.customSpend,
      profile.currency || DEFAULT_PROFILE.currency
    );
    const customPrecision =
      typeof profile.customSpend?.pricePrecision === "number" && Number.isFinite(profile.customSpend.pricePrecision)
        ? Math.max(0, Math.min(6, profile.customSpend.pricePrecision))
        : null;
    const customInputPrecision =
      customPrecision !== null ? customPrecision : getCurrencyDisplayPrecision(currentCurrency);
    setCustomSpendInputs({
      title: profile.customSpend?.title || "",
      amount:
        customAmountUSD > 0
          ? formatNumberInputValue(convertToCurrency(customAmountUSD, currentCurrency), customInputPrecision)
          : "",
      frequency: profile.customSpend?.frequencyPerWeek
        ? `${profile.customSpend.frequencyPerWeek}`
        : "",
    });
  }, [
    currentCurrency,
    isEditingSpend,
    profile.currency,
    profile.customSpend,
    profile.spendingProfile?.baselineMonthlyWasteUSD,
  ]);
  const baselineDisplayUSD = profile.spendingProfile?.baselineMonthlyWasteUSD || 0;
  const baselineLocalDisplay = baselineDisplayUSD
    ? formatCurrency(convertToCurrency(baselineDisplayUSD, currentCurrency), currentCurrency)
    : null;
  const monthlyIncomeDisplay =
    Number.isFinite(monthlyIncomeUSD) && monthlyIncomeUSD > 0
      ? formatLocalAmount(monthlyIncomeUSD)
      : null;
  const incomePayday = useMemo(() => {
    const raw = Number(profile?.incomePayday);
    if (Number.isFinite(raw) && raw >= 1 && raw <= 31) return Math.round(raw);
    return DEFAULT_INCOME_PAYDAY;
  }, [profile?.incomePayday]);
  const incomeDayOptions = useMemo(() => Array.from({ length: 31 }, (_, index) => index + 1), []);
  const customSpendAmountUSD = resolveCustomPriceUSD(
    profile.customSpend,
    profile.currency || DEFAULT_PROFILE.currency
  );
  const customSpendAmountDisplay =
    customSpendAmountUSD > 0
      ? formatCurrency(convertToCurrency(customSpendAmountUSD, currentCurrency), currentCurrency)
      : null;
  const customSpendFrequency = profile.customSpend?.frequencyPerWeek || null;
  const customSpendPlaceholderLabel = formatSampleAmount(CUSTOM_SPEND_SAMPLE_USD, currentCurrency);
  const baselinePlaceholderLabel = formatSampleAmount(BASELINE_SAMPLE_USD, currentCurrency);
  const avatarEditBadgeColors = useMemo(
    () => {
      const dark = theme === "dark";
      const pro = theme === PRO_THEME_ID;
      return {
        background: dark ? "rgba(0,0,0,0.6)" : pro ? "#0C0C0C" : "rgba(255,255,255,0.92)",
        border: dark ? "rgba(255,255,255,0.2)" : pro ? "rgba(255,255,255,0.35)" : "rgba(0,0,0,0.08)",
        icon: dark ? colors.card : pro ? "#FFFFFF" : colors.text,
      };
    },
    [theme, colors.card, colors.text]
  );
  const handleBaselineInputChange = useCallback(
    (text) => {
      setBaselineInput(text);
      const trimmed = text.trim();
      const baseProfile = profile.spendingProfile || { ...DEFAULT_PROFILE.spendingProfile };
      if (!trimmed) {
        onFieldChange?.("spendingProfile", {
          ...baseProfile,
          baselineMonthlyWasteUSD: 0,
          baselineStartAt: null,
        });
        return;
      }
      const parsed = parseNumberInputValue(text);
      if (!Number.isFinite(parsed) || parsed <= 0) return;
      onFieldChange?.("spendingProfile", {
        ...baseProfile,
        baselineMonthlyWasteUSD: convertFromCurrency(parsed, currentCurrency),
        baselineStartAt: new Date().toISOString(),
      });
    },
    [currentCurrency, onFieldChange, profile.spendingProfile]
  );
  const applyCustomSpendDraft = useCallback(
    (nextState) => {
      const trimmedTitle = nextState.title.trim();
      const parsedAmount = parseNumberInputValue(nextState.amount);
      const frequencyValue = parseFloat((nextState.frequency || "").replace(",", "."));
      const hasAmount = Number.isFinite(parsedAmount) && parsedAmount > 0;
      const hasFrequency = Number.isFinite(frequencyValue) && frequencyValue > 0;
      if (!trimmedTitle && !hasAmount && !hasFrequency) {
        onFieldChange?.("customSpend", null);
        return;
      }
      const existing = profile.customSpend || {};
      const next = {
        ...existing,
      };
      next.id = next.id || existing.id || "custom_habit";
      if (!next.createdAt) {
        next.createdAt = existing.createdAt || Date.now();
      }
      if (trimmedTitle) {
        next.title = trimmedTitle;
      } else {
        delete next.title;
      }
      if (hasAmount) {
        next.amountUSD = convertFromCurrency(parsedAmount, currentCurrency);
        next.currency = currentCurrency;
        next.pricePrecision = getManualInputPrecision(nextState.amount);
      } else {
        delete next.amountUSD;
        delete next.currency;
        delete next.pricePrecision;
      }
      if (hasFrequency) {
        next.frequencyPerWeek = Math.max(1, Math.round(frequencyValue));
      } else {
        delete next.frequencyPerWeek;
      }
      if (!next.title && !next.amountUSD && !next.frequencyPerWeek) {
        onFieldChange?.("customSpend", null);
        return;
      }
      onFieldChange?.("customSpend", next);
    },
    [currentCurrency, onFieldChange, profile.customSpend]
  );
  const handleCustomSpendInputChange = useCallback(
    (field, value) => {
      setCustomSpendInputs((prev) => {
        const nextState = { ...prev, [field]: value };
        applyCustomSpendDraft(nextState);
        return nextState;
      });
    },
    [applyCustomSpendDraft]
  );
  const describeHistory = (entry) => describeHistoryEntry(entry, { t, formatLocalAmount });
  const formatHistoryMeta = (entry) => formatHistoryEntryMeta(entry, { t, locale });
  const joinDateLabel = useMemo(() => {
    const stamp = profile.joinedAt || profile.spendingProfile?.baselineStartAt;
    if (!stamp) return null;
    try {
      const joinedDate = new Date(stamp);
      const dateLabel = joinedDate.toLocaleDateString(locale, {
        day: "numeric",
        month: "long",
        year: "numeric",
      });
      return t("profileJoinDate", { date: dateLabel });
    } catch {
      return null;
    }
  }, [profile.joinedAt, profile.spendingProfile?.baselineStartAt, locale, t]);
  const profileNamePlaceholder = t("profileNamePlaceholder");
  const profileBioPlaceholder = t("profileBioPlaceholder");
  const profileBioValue = typeof profile?.bio === "string" ? profile.bio : "";
  const profileBioText = useMemo(() => {
    const raw = profileBioValue.trim();
    if (!raw) return "";
    if (PROFILE_BIO_FALLBACK_VALUES.includes(raw)) return "";
    return raw;
  }, [profileBioValue]);
  const profileNameDisplay =
    (profile?.name || "").trim() ||
    [profile?.firstName, profile?.lastName].filter(Boolean).join(" ").trim();
  const profileNameText = profileNameDisplay || profileNamePlaceholder;
  const profileBioDisplay = profileBioText || profileBioPlaceholder;
  const profileBioColor = profileBioText ? colors.muted : colorWithAlpha(colors.muted, 0.7);
  const profileSubtitleAdjustments = useMemo(() => {
    if (!isRomanceLocale) return null;
    return {
      fontSize: PROFILE_SUBTITLE_FONT_SIZE * 0.9,
      lineHeight: PROFILE_SUBTITLE_LINE_HEIGHT * 0.9,
    };
  }, [isRomanceLocale]);
  const profileMoodGradient = useMemo(
    () => applyThemeToMoodGradient(getMoodGradient(moodPreset?.id), theme),
    [moodPreset?.id, theme]
  );
  const handlePrivacyPolicyOpen = useCallback(() => {
    const normalizedLanguage = normalizeLanguage(language);
    const url = PRIVACY_LINKS[normalizedLanguage] || PRIVACY_LINKS.en;
    if (!url) return;
    triggerHaptic();
    Linking.openURL(url).catch((error) => console.warn("privacy policy", error));
  }, [language]);
  const handleManageSubscriptionsOpen = useCallback(() => {
    const fallbackUrl =
      Platform.OS === "ios" ? IOS_MANAGE_SUBSCRIPTIONS_URL : ANDROID_MANAGE_SUBSCRIPTIONS_URL;
    const targetUrl = resolveNonEmptyString(fallbackUrl);
    if (!targetUrl) return;
    triggerHaptic();
    Linking.openURL(targetUrl).catch((error) => console.warn("manage subscriptions link", error));
  }, []);
  const handleSupportPress = useCallback(() => {
    triggerHaptic();
    Linking.openURL(`mailto:${SUPPORT_EMAIL}`).catch((error) => console.warn("support mail", error));
  }, []);
  const handleInstagramPress = useCallback(() => {
    triggerHaptic();
    Linking.openURL(INSTAGRAM_URL).catch((error) => console.warn("instagram link", error));
  }, []);
  const handleSpendEditPress = useCallback(() => {
    if (!canStartSpendEdit) return;
    onSpendEditPress?.();
  }, [canStartSpendEdit, onSpendEditPress]);
  const customSpendSection = (
    <View style={styles.profileSection}>
      <Text style={[styles.settingLabel, { color: colors.muted }]}>{t("customSpendTitle")}</Text>
      {isEditingSpend ? (
        <View style={{ gap: 10 }}>
          <TextInput
            style={[
              styles.profileInput,
              { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
            ]}
            value={customSpendInputs.title}
            onChangeText={(text) => handleCustomSpendInputChange("title", text)}
            placeholder={t("customSpendNamePlaceholder")}
            placeholderTextColor={colors.muted}
          />
          <TextInput
            style={[
              styles.profileInput,
              { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
            ]}
            value={customSpendInputs.amount}
            onChangeText={(text) => handleCustomSpendInputChange("amount", text)}
            placeholder={t("customSpendAmountPlaceholder", { amount: customSpendPlaceholderLabel })}
            keyboardType="decimal-pad"
            placeholderTextColor={colors.muted}
          />
          <TextInput
            style={[
              styles.profileInput,
              { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
            ]}
            value={customSpendInputs.frequency}
            onChangeText={(text) => handleCustomSpendInputChange("frequency", text)}
            placeholder={t("customSpendFrequencyPlaceholder")}
            keyboardType="number-pad"
            placeholderTextColor={colors.muted}
          />
        </View>
      ) : profile.customSpend ? (
        <View style={{ gap: 4 }}>
          <Text style={[styles.profileSettingValue, { color: colors.text }]}>
            {profile.customSpend.title}
          </Text>
          {customSpendAmountDisplay && (
            <Text style={[styles.profileHintText, { color: colors.muted }]}>
              {t("customSpendAmountLabel")}: {customSpendAmountDisplay}
            </Text>
          )}
          {customSpendFrequency ? (
            <Text style={[styles.profileHintText, { color: colors.muted }]}>
              {t("customSpendFrequencyLabel")}: {customSpendFrequency}
            </Text>
          ) : null}
        </View>
      ) : (
        <Text style={[styles.profileHintText, { color: colors.muted }]}>{t("customSpendHint")}</Text>
      )}
    </View>
  );
  const baselineSection = (
    <View style={styles.profileSection}>
      <Text style={[styles.settingLabel, { color: colors.muted }]}>{t("baselineTitle")}</Text>
      <View style={{ gap: 12 }}>
        {isEditingSpend ? (
          <View style={{ gap: 4 }}>
            <Text style={[styles.profileHintText, { color: colors.muted }]}>
              {t("incomeEntryAmountLabel")}
            </Text>
            {monthlyIncomeDisplay ? (
              <Text style={[styles.profileSettingValue, { color: colors.text }]}>
                {monthlyIncomeDisplay}
              </Text>
            ) : (
              <Text style={[styles.profileHintText, { color: colors.muted }]}>
                {t("baselineIncomeHint")}
              </Text>
            )}
          </View>
        ) : canStartSpendEdit ? (
          <Pressable onPress={() => onIncomeEntryOpen?.("profile")}>
            <View style={{ gap: 4 }}>
              <Text style={[styles.profileHintText, { color: colors.muted }]}>
                {t("incomeEntryAmountLabel")}
              </Text>
              {monthlyIncomeDisplay ? (
                <Text style={[styles.profileSettingValue, { color: colors.text }]}>
                  {monthlyIncomeDisplay}
                </Text>
              ) : (
                <Text style={[styles.profileHintText, { color: colors.muted }]}>
                  {t("baselineIncomeHint")}
                </Text>
              )}
            </View>
          </Pressable>
        ) : (
          <View style={{ gap: 4 }}>
            <Text style={[styles.profileHintText, { color: colors.muted }]}>
              {t("incomeEntryAmountLabel")}
            </Text>
            {monthlyIncomeDisplay ? (
              <Text style={[styles.profileSettingValue, { color: colors.text }]}>
                {monthlyIncomeDisplay}
              </Text>
            ) : (
              <Text style={[styles.profileHintText, { color: colors.muted }]}>
                {t("baselineIncomeHint")}
              </Text>
            )}
          </View>
        )}
        {isEditingSpend ? (
          <View style={{ gap: 6 }}>
            <Text style={[styles.profileHintText, { color: colors.muted }]}>
              {t("baselineSpendLabel")}
            </Text>
            <TextInput
              style={[
                styles.profileInput,
                { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
              ]}
              value={baselineInput}
              onChangeText={handleBaselineInputChange}
              placeholder={t("baselinePlaceholder", { amount: baselinePlaceholderLabel })}
              keyboardType="decimal-pad"
              placeholderTextColor={colors.muted}
            />
          </View>
        ) : canStartSpendEdit ? (
          <Pressable onPress={handleSpendEditPress}>
            <View style={{ gap: 4 }}>
              <Text style={[styles.profileHintText, { color: colors.muted }]}>
                {t("baselineSpendLabel")}
              </Text>
              {baselineLocalDisplay ? (
                <Text style={[styles.profileSettingValue, { color: colors.text }]}>
                  {baselineLocalDisplay}
                </Text>
              ) : (
                <Text style={[styles.profileHintText, { color: colors.muted }]}>
                  {t("baselineHint")}
                </Text>
              )}
            </View>
          </Pressable>
        ) : (
          <View style={{ gap: 4 }}>
            <Text style={[styles.profileHintText, { color: colors.muted }]}>
              {t("baselineSpendLabel")}
            </Text>
            {baselineLocalDisplay ? (
              <Text style={[styles.profileSettingValue, { color: colors.text }]}>
                {baselineLocalDisplay}
              </Text>
            ) : (
              <Text style={[styles.profileHintText, { color: colors.muted }]}>
                {t("baselineHint")}
              </Text>
            )}
          </View>
        )}
      </View>
    </View>
  );
  const incomePaydaySection = (
    <View style={styles.profileSection}>
      <Text style={[styles.settingLabel, { color: colors.muted }]}>{t("incomePaydayLabel")}</Text>
      {isEditingSpend ? (
        <>
          <View style={styles.incomeCalendarGrid}>
            {incomeDayOptions.map((day) => {
              const active = incomePayday === day;
              return (
                <TouchableOpacity
                  key={`income-day-${day}`}
                  style={[
                    styles.incomeCalendarDay,
                    {
                      backgroundColor: active ? colors.text : "transparent",
                      borderColor: active ? colors.text : colors.border,
                    },
                  ]}
                  onPress={() => onFieldChange?.("incomePayday", day)}
                  activeOpacity={0.85}
                >
                  <Text
                    style={[
                      styles.incomeCalendarDayText,
                      { color: active ? colors.background : colors.muted },
                    ]}
                  >
                    {day}
                  </Text>
                </TouchableOpacity>
              );
            })}
          </View>
          <Text style={[styles.profileHintText, { color: colors.muted }]}>
            {t("incomePaydayHint")}
          </Text>
        </>
      ) : (
        <Text style={[styles.profileSettingValue, { color: colors.text }]}>
          {t("incomePaydayValue", { day: incomePayday })}
        </Text>
      )}
    </View>
  );
  const renderHistoryItem = useCallback(
    ({ item: entry, index }) => (
      <View
        style={[
          styles.historyItem,
          {
            borderColor: colors.border,
            borderBottomWidth:
              index === historyLastIndex ? 0 : StyleSheet.hairlineWidth,
          },
        ]}
      >
        <View style={styles.historyRow}>
          <View style={{ flex: 1 }}>
            <Text style={[styles.historyItemTitle, { color: colors.text }]}>
              {describeHistory(entry)}
            </Text>
            <Text style={[styles.historyItemMeta, { color: colors.muted }]}>
              {formatHistoryMeta(entry)}
            </Text>
          </View>
          <TouchableOpacity
            style={[styles.historyDeleteBtn, { borderColor: colors.border }]}
            onPress={() => onHistoryDelete?.(entry)}
          >
            <Text style={[styles.historyDeleteText, { color: colors.muted }]}>âœ•</Text>
          </TouchableOpacity>
        </View>
      </View>
    ),
    [
      colors.border,
      colors.muted,
      colors.text,
      describeHistory,
      formatHistoryMeta,
      historyLastIndex,
      onHistoryDelete,
    ]
  );
  const historyItemLayout = useCallback(
    (_, index) => ({
      length: HISTORY_ITEM_HEIGHT,
      offset: HISTORY_ITEM_HEIGHT * index,
      index,
    }),
    []
  );
  const handleHistoryLoadMore = useCallback(() => {
    setHistoryVisibleWindowMs((prev) => prev + PROFILE_HISTORY_PAGE_WINDOW_MS);
  }, []);
  return (
    <View style={[styles.container, { backgroundColor: colors.background }] }>
      <ScrollView
        ref={scrollRef}
        style={{ flex: 1 }}
        contentContainerStyle={styles.profileScrollContent}
        keyboardShouldPersistTaps="handled"
        showsVerticalScrollIndicator={false}
      >
        <View style={[styles.profileCard, { backgroundColor: colors.card }] }>
          <View style={styles.profileMoodAura}>
            <MoodGradientBlock colors={profileMoodGradient} style={styles.profileMoodGradient}>
              <TouchableOpacity
                style={styles.profileAvatarWrap}
                activeOpacity={isEditingIdentity ? 0.85 : 1}
                onPress={() => isEditingIdentity && onPickImage?.()}
              >
                <Image
                  source={resolvedAvatarUri ? { uri: resolvedAvatarUri } : fallbackAvatar}
                  style={styles.profileAvatar}
                  resizeMode="cover"
                />
                {isEditingIdentity && (
                  <View
                    style={[
                      styles.profileAvatarEditBadge,
                      { backgroundColor: avatarEditBadgeColors.background, borderColor: avatarEditBadgeColors.border },
                    ]}
                  >
                    <Text style={[styles.profileAvatarEditIcon, { color: avatarEditBadgeColors.icon }]}>âœï¸Ž</Text>
                  </View>
                )}
              </TouchableOpacity>
            </MoodGradientBlock>
            {isEditingIdentity && (
              <Text style={[styles.profileAvatarHint, { color: colors.muted }]}>{t("photoTapHint")}</Text>
            )}
            {moodPreset?.label && (
              <Text style={[styles.profileMoodStatus, { color: profileMoodGradient.accent }]}>
                {moodPreset.label}
              </Text>
            )}
          </View>
          {isEditingIdentity ? (
            <>
              <View style={styles.inputRow}>
                <TextInput
                  style={[
                    styles.profileInput,
                    styles.profileInputHalf,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  value={profile.firstName || ""}
                  onChangeText={(text) => onFieldChange("firstName", text)}
                  placeholder={t("inputFirstName")}
                  placeholderTextColor={colors.muted}
                />
                <TextInput
                  style={[
                    styles.profileInput,
                    styles.profileInputHalf,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  value={profile.lastName || ""}
                  onChangeText={(text) => onFieldChange("lastName", text)}
                  placeholder={t("inputLastName")}
                  placeholderTextColor={colors.muted}
                />
              </View>
              <TextInput
                style={[
                  styles.profileInput,
                  styles.profileBioInput,
                  { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                ]}
                value={profile.bio || ""}
                onChangeText={(text) => onFieldChange("bio", text)}
                placeholder={t("inputMotto")}
                multiline
                placeholderTextColor={colors.muted}
              />
            </>
          ) : (
            <>
            <View style={styles.profileNameRow}>
              <Text
                style={[
                  styles.profileName,
                  { color: profileNameDisplay ? colors.text : colorWithAlpha(colors.muted, 0.8) },
                ]}
              >
                {profileNameText}
              </Text>
              <View style={styles.profileBadgeRow}>
                {challengeBadgeCount > 0 && (
                  <View style={[styles.profileChallengeBadge, { borderColor: colors.border }]}>
                    <View style={styles.profileChallengeBadgeList}>
                      {challengeBadges.slice(0, 3).map((emoji, index) => (
                        <Text key={`${emoji}-${index}`} style={styles.profileChallengeBadgeEmoji}>
                          {emoji}
                        </Text>
                      ))}
                    </View>
                    <Text style={[styles.profileChallengeBadgeCount, { color: colors.muted }]}>
                      {challengeBadgeCount}
                    </Text>
                  </View>
                )}
              </View>
            </View>
            {joinDateLabel && (
              <Text
                style={[styles.profileSubtitle, { color: colors.muted }, profileSubtitleAdjustments]}
                numberOfLines={1}
                ellipsizeMode="tail"
              >
                {joinDateLabel}
              </Text>
            )}
            <Text style={[styles.profileBio, { color: profileBioColor }]}>
              {profileBioDisplay}
            </Text>
          </>
        )}

          <View style={styles.profileStatsRow}>
            {stats.map((stat) => (
              <View key={stat.label} style={styles.profileStat}>
                <View style={styles.profileStatValueRow}>
                  <Text style={[styles.profileStatValue, { color: colors.text }]}>{stat.value}</Text>
                  {!!stat.suffix && (
                    <Text style={[styles.profileStatValueSuffix, { color: colors.text }]}>
                      {stat.suffix}
                    </Text>
                  )}
                </View>
                <Text style={[styles.profileStatLabel, { color: colors.muted }]} numberOfLines={1}>
                  {stat.label}
                </Text>
              </View>
            ))}
          </View>

          <View style={styles.profileActions}>
            {isEditing ? (
              <>
                <TouchableOpacity
                  style={[styles.profileActionPrimary, { backgroundColor: colors.text }]}
                  onPress={onSaveEdit}
                >
                  <Text style={[styles.profileActionPrimaryText, { color: colors.background }]}>
                    {t("profileSave")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.profileActionSecondary, { borderColor: colors.border }]}
                  onPress={onCancelEdit}
                >
                  <Text style={[styles.profileActionSecondaryText, { color: colors.muted }]}>
                    {t("profileCancel")}
                  </Text>
                </TouchableOpacity>
              </>
            ) : (
              <>
                <TouchableOpacity
                  style={[styles.profileActionPrimary, { backgroundColor: colors.text }]}
                  onPress={onEditPress}
                >
                  <Text style={[styles.profileActionPrimaryText, { color: colors.background }]}>
                    {t("profileEdit")}
                  </Text>
                </TouchableOpacity>
                {onReportsPress ? (
                  <TouchableOpacity
                    style={[
                      styles.profileActionSecondary,
                      reportsLockedState ? styles.profileActionPremiumLocked : null,
                      {
                        borderColor: reportsLockedState ? reportsPremiumBorder : colors.border,
                        backgroundColor: reportsLockedState ? reportsPremiumBackground : "transparent",
                      },
                      reportsDisabled ? { opacity: 0.7 } : null,
                    ]}
                    onPress={onReportsPress}
                    disabled={reportsDisabled}
                    activeOpacity={reportsDisabled ? 1 : 0.85}
                  >
                    <View style={styles.profileActionRow}>
                      <Text
                        style={[
                          styles.profileActionSecondaryText,
                          { color: reportsLockedState ? reportsPremiumAccent : colors.muted },
                        ]}
                      >
                        {t("reportsButton")}
                      </Text>
                      {reportsLockedState && (
                        <View
                          style={[
                            styles.profileActionPremiumPill,
                            {
                              backgroundColor: reportsPremiumPillBackground,
                              borderColor: reportsPremiumBorder,
                            },
                          ]}
                        >
                          <Text
                            style={[
                              styles.profileActionPremiumPillText,
                              { color: reportsPremiumAccent },
                            ]}
                          >
                            PREMIUM
                          </Text>
                        </View>
                      )}
                      {!reportsLockedState && !reportsDisabled && reportsBadgeVisible && (
                        <View style={[styles.reportsBadgeChip, { backgroundColor: colors.text }]}>
                          <Text style={[styles.reportsBadgeText, { color: colors.background }]}>
                            {t("reportsBadgeNew")}
                          </Text>
                        </View>
                      )}
                    </View>
                    {reportsLockedState ? (
                      <Text style={[styles.profileActionLockedLabel, { color: reportsPremiumAccent }]}>
                        {`ðŸ”’ ${reportsLockLabel}`}
                      </Text>
                    ) : null}
                  </TouchableOpacity>
                ) : null}
              </>
            )}
          </View>
        </View>

        <View style={[styles.settingsCard, { backgroundColor: colors.card }] }>
          {canStartSpendEdit ? (
            <Pressable onPress={handleSpendEditPress}>{customSpendSection}</Pressable>
          ) : (
            customSpendSection
          )}
          {baselineSection}
          {canStartSpendEdit ? (
            <Pressable onPress={handleSpendEditPress}>{incomePaydaySection}</Pressable>
          ) : (
            incomePaydaySection
          )}

          <View style={[styles.settingsDivider, { backgroundColor: colors.border }]} />

          <Text style={[styles.settingsTitle, { color: colors.text }]}>{t("settingsTitle")}</Text>
          <>
            <View style={styles.settingRow}>
              <Text style={[styles.settingLabel, { color: colors.muted }]}>{t("themeLabel")}</Text>
              <View style={styles.settingChoices}>
                {[
                  { id: "light", label: t("themeLight"), locked: false },
                  { id: "dark", label: t("themeDark"), locked: false },
                  { id: PRO_THEME_ID, label: t("themePro"), locked: !isPremiumUser },
                ].map((option) => {
                  const active = theme === option.id;
                  const activeProChip = active && option.id === PRO_THEME_ID;
                  return (
                    <TouchableOpacity
                      key={option.id}
                      style={[
                        styles.settingChip,
                        {
                          backgroundColor: active ? (activeProChip ? colors.primary : colors.text) : "transparent",
                          borderColor: colors.border,
                          opacity: option.locked && !active ? 0.7 : 1,
                        },
                      ]}
                      onPress={() => onThemeToggle(option.id)}
                    >
                      <Text
                        style={{
                          color: active ? "#FFFFFF" : colors.muted,
                          fontWeight: "600",
                        }}
                      >
                        {option.label}
                        {option.locked ? " ðŸ”’" : ""}
                      </Text>
                    </TouchableOpacity>
                  );
                })}
              </View>
            </View>
            {!isPremiumUser && (
              <Text style={[styles.profileHintText, { color: colors.muted, marginTop: -6, marginBottom: 8 }]}>
                {t("themeProLockedHint")}
              </Text>
            )}
          </>
        <View style={styles.settingRow}>
          <Text style={[styles.settingLabel, { color: colors.muted }]}>{t("languageLabel")}</Text>
          <View style={styles.settingChoices}>
            {SUPPORTED_LANGUAGES.map((lng) => {
              const active = language === lng;
              return (
                <TouchableOpacity
                  key={lng}
                  style={[
                    styles.settingChip,
                    {
                      backgroundColor: active ? colors.text : "transparent",
                      borderColor: colors.border,
                    },
                  ]}
                  onPress={() => onLanguageChange(lng)}
                >
                  <Text
                    style={{
                      color: active ? colors.background : colors.muted,
                      fontWeight: "600",
                    }}
                  >
                    {t(getLanguageLabelKey(lng))}
                  </Text>
                </TouchableOpacity>
              );
            })}
          </View>
        </View>
        <View style={styles.settingRow}>
          <Text style={[styles.settingLabel, { color: colors.muted }]}>
            {t("currencyLabel")} <Text style={{ fontSize: 16 }}>â†’</Text>
          </Text>
          <View style={styles.settingCurrencyScrollWrapper}>
            <ScrollView
              ref={profileCurrencyScrollRef}
              horizontal
              showsHorizontalScrollIndicator={false}
              style={styles.settingCurrencyScroll}
              contentContainerStyle={styles.settingCurrencyScrollContent}
            >
              {CURRENCIES.map((code) => (
                <TouchableOpacity
                  key={code}
                  style={[
                    styles.settingChip,
                    {
                      backgroundColor: currentCurrency === code ? colors.text : "transparent",
                      borderColor: colors.border,
                    },
                  ]}
                  onPress={() => onCurrencyChange?.(code)}
                >
                  <Text
                    style={{
                      color: currentCurrency === code ? colors.background : colors.muted,
                      fontWeight: "600",
                    }}
                  >
                    {code}
                  </Text>
                </TouchableOpacity>
              ))}
            </ScrollView>
          </View>
        </View>
        <View style={styles.settingRow}>
            <View style={styles.settingRowContent}>
            <View style={{ flex: 1 }}>
              <Text style={[styles.settingLabel, { color: colors.muted }]}>{t("addCategoryLabel")}</Text>
              <Text style={[styles.profileHintText, { color: colors.muted }]}>{t("addCategoryHint")}</Text>
            </View>
            <View style={styles.settingRowActions}>
              <TouchableOpacity
                style={[styles.settingChip, { borderColor: "#000", backgroundColor: "#000" }]}
                onPress={() => openManageCategoriesModal?.()}
              >
                <Text style={{ color: "#fff", fontWeight: "600" }}>
                  {t("manageCategoriesButton")}
                </Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
        <View style={styles.settingRow}>
          <View style={styles.settingRowContent}>
            <View style={{ flex: 1 }}>
              <Text style={[styles.settingLabel, { color: colors.muted }]}>{t("spendReductionLabel")}</Text>
              <Text style={[styles.profileHintText, { color: colors.muted }]}>{t("spendReductionHint")}</Text>
            </View>
            <Pressable
              onPress={() => onSpendReductionToggle?.(!spendReducesSavings)}
              style={[
                styles.settingToggle,
                {
                  backgroundColor: spendReducesSavings
                    ? colors.text
                    : colorWithAlpha(colors.text, 0.15),
                  borderColor: colors.border,
                },
              ]}
            >
              <View
                style={[
                  styles.settingToggleHandle,
                  {
                    backgroundColor: spendReducesSavings ? colors.background : colors.card,
                    transform: [{ translateX: spendReducesSavings ? 20 : 0 }],
                  },
                ]}
              />
            </Pressable>
          </View>
        </View>
        <View style={styles.settingRow}>
          <View style={styles.settingRowContent}>
            <View style={{ flex: 1 }}>
              <Text style={[styles.settingLabel, { color: colors.muted }]}>{t("soundLabel")}</Text>
              <Text style={[styles.profileHintText, { color: colors.muted }]}>{t("soundHint")}</Text>
            </View>
            <Pressable
              onPress={() => onSoundToggle?.(!soundEnabled)}
              style={[
                styles.settingToggle,
                {
                  backgroundColor: soundEnabled
                    ? colors.text
                    : colorWithAlpha(colors.text, 0.15),
                  borderColor: colors.border,
                },
              ]}
            >
              <View
                style={[
                  styles.settingToggleHandle,
                  {
                    backgroundColor: soundEnabled ? colors.background : colors.card,
                    transform: [{ translateX: soundEnabled ? 20 : 0 }],
                  },
                ]}
              />
            </Pressable>
          </View>
        </View>
        <TouchableOpacity
          style={[styles.resetButton, { borderColor: colors.border }]}
          onPress={onResetData}
        >
          <Text style={[styles.resetButtonText, { color: colors.muted }]}>
            {t("developerReset")}
          </Text>
        </TouchableOpacity>
        </View>

        <View style={[styles.historyCard, { backgroundColor: colors.card }] }>
          <Text style={[styles.historyTitle, { color: colors.text }]}>{t("historyTitle")}</Text>
          {visibleHistoryEntries.length === 0 ? (
            <Text style={[styles.historyEmpty, { color: colors.muted }]}>{t("historyEmpty")}</Text>
          ) : (
            <FlatList
              style={[
                styles.historyList,
                {
                  borderColor: colors.border,
                  height: HISTORY_VIEWPORT_HEIGHT,
                },
              ]}
              contentContainerStyle={styles.historyListContent}
              showsVerticalScrollIndicator
              nestedScrollEnabled
              scrollEventThrottle={16}
              data={visibleHistoryEntries}
              keyExtractor={(entry) => entry.id}
              renderItem={renderHistoryItem}
              getItemLayout={historyItemLayout}
              initialNumToRender={HISTORY_VIEWPORT_ROWS}
              maxToRenderPerBatch={HISTORY_VIEWPORT_ROWS}
              windowSize={5}
            />
          )}
          {hasMoreHistoryEntries ? (
            <TouchableOpacity
              style={[styles.historyMoreButton, { borderColor: colors.border }]}
              onPress={handleHistoryLoadMore}
              activeOpacity={0.85}
            >
              <Text style={[styles.historyMoreText, { color: colors.text }]}>{t("historyLoadMore")}</Text>
            </TouchableOpacity>
          ) : null}
        </View>
        <TouchableOpacity
          style={[
            styles.profileLinkButton,
            { borderColor: colors.border, backgroundColor: colors.card },
          ]}
          activeOpacity={0.85}
          onPress={handlePrivacyPolicyOpen}
        >
          <Text style={[styles.profileLinkText, { color: colors.text }]}>{t("privacyPolicyLink")}</Text>
          <Text style={[styles.profileLinkHint, { color: colors.muted }]}>{t("privacyPolicyHint")}</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[
            styles.profileLinkButton,
            { borderColor: colors.border, backgroundColor: colors.card },
          ]}
          activeOpacity={0.85}
          onPress={handleInstagramPress}
        >
          <Text style={[styles.profileLinkText, { color: colors.text }]}>{t("instagramLink")}</Text>
          <Text style={[styles.profileLinkHint, { color: colors.muted }]}>{t("instagramHint")}</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[
            styles.profileLinkButton,
            { borderColor: colors.border, backgroundColor: colors.card },
          ]}
          activeOpacity={0.85}
          onPress={handleSupportPress}
        >
          <Text style={[styles.profileLinkText, { color: colors.text }]}>{t("supportLink")}</Text>
          <Text style={[styles.profileLinkHint, { color: colors.muted }]}>{t("supportHint")}</Text>
        </TouchableOpacity>
      </ScrollView>
    </View>
  );
});

function AppContent() {
  const [fontsLoaded, fontsError] = safeUseFonts({
    Inter_300Light,
    Inter_400Regular,
    Inter_500Medium,
    Inter_600SemiBold,
    Inter_700Bold,
    Inter_800ExtraBold,
    Inter_900Black,
  });
  const soundsRef = useRef({});
  const soundCooldownRef = useRef({});
  const soundModeReadyRef = useRef(false);
  const budgetSpeechDataRef = useRef(null);
  const resolvedBudgetSpeechDataRef =
    typeof budgetSpeechDataRef === "undefined" ? null : budgetSpeechDataRef;
  const [soundEnabled, setSoundEnabled] = useState(true);
  const [soundEnabledHydrated, setSoundEnabledHydrated] = useState(false);
  const resolveInterruptionModeIOS = useCallback(() => {
    return (
      AudioModule?.InterruptionModeIOS?.MixWithOthers ??
      AudioModule?.INTERRUPTION_MODE_IOS_MIX_WITH_OTHERS ??
      2
    );
  }, []);
  const resolveInterruptionModeAndroid = useCallback(() => {
    return (
      AudioModule?.InterruptionModeAndroid?.DuckOthers ??
      AudioModule?.INTERRUPTION_MODE_ANDROID_DUCK_OTHERS ??
      1
    );
  }, []);
  const stopAllSounds = useCallback(() => {
    Object.values(soundsRef.current).forEach((sound) => {
      sound?.stopAsync?.()?.catch?.(() => {});
    });
  }, []);
  const playSound = useCallback(async (key, options = {}) => {
    if (!AudioModule) return;
    if (!key) return;
    if (!soundEnabled) return;
    const now = Date.now();
    const cooldown = SOUND_COOLDOWNS[key] || 0;
    const lastPlayed = soundCooldownRef.current[key] || 0;
    const skipCooldown = !!options?.skipCooldown;
    if (!skipCooldown && cooldown && now - lastPlayed < cooldown) return;
    if (!skipCooldown) {
      soundCooldownRef.current[key] = now;
    }
    if (!soundModeReadyRef.current) {
      const interruptionModeIOS = resolveInterruptionModeIOS();
      const interruptionModeAndroid = resolveInterruptionModeAndroid();
      try {
        await AudioModule.setAudioModeAsync({
          playsInSilentModeIOS: false,
          interruptionModeIOS,
          interruptionModeAndroid,
          shouldDuckAndroid: true,
          staysActiveInBackground: false,
        });
        soundModeReadyRef.current = true;
      } catch (error) {
        console.warn("sound mode", error);
      }
    }
    const volume = SOUND_VOLUMES[key] ?? 0.8;
    let sound = soundsRef.current[key];
    if (!sound && SOUND_FILES[key]) {
      try {
        const loaded = await AudioModule.Sound.createAsync(SOUND_FILES[key], {
          shouldPlay: false,
          volume,
        });
        sound = loaded.sound;
        soundsRef.current[key] = sound;
      } catch (error) {
        console.warn("sound lazy load", error);
        return;
      }
    }
    if (!sound) return;
    try {
      if (sound.setVolumeAsync) {
        await sound.setVolumeAsync(volume);
      }
      await sound.setPositionAsync(0);
      await sound.playAsync();
    } catch (error) {
      console.warn("sound play", error);
    }
  }, [soundEnabled]);
  useEffect(() => {
    let active = true;
    const task = InteractionManager.runAfterInteractions(() => {
      (async () => {
        try {
          if (!AudioModule) return;
          const interruptionModeIOS = resolveInterruptionModeIOS();
          const interruptionModeAndroid = resolveInterruptionModeAndroid();
          try {
            await AudioModule.setAudioModeAsync({
              playsInSilentModeIOS: false,
              interruptionModeIOS,
              interruptionModeAndroid,
              shouldDuckAndroid: true,
              staysActiveInBackground: false,
            });
            soundModeReadyRef.current = true;
          } catch (error) {
            console.warn("sound mode", error);
          }
          const entries = Object.entries(SOUND_FILES).filter(([key]) => PRELOAD_SOUND_KEYS.has(key));
          let loadedCount = 0;
          for (const [key, asset] of entries) {
            const volume = SOUND_VOLUMES[key] ?? 0.8;
            const { sound } = await AudioModule.Sound.createAsync(asset, {
              shouldPlay: false,
              volume,
            });
            if (!active) {
              await sound.unloadAsync();
              continue;
            }
            soundsRef.current[key] = sound;
            loadedCount += 1;
          }
        } catch (error) {
          console.warn("sound init", error);
        }
      })();
    });
    return () => {
      active = false;
      task?.cancel?.();
      Object.values(soundsRef.current).forEach((sound) => {
        sound?.unloadAsync?.()?.catch?.(() => {});
      });
      soundsRef.current = {};
    };
  }, []);
  const [wishes, setWishes] = useState([]);
  const [wishesHydrated, setWishesHydrated] = useState(false);
  const wishesRef = useRef(wishes);
  const [freeDayHydrated, setFreeDayHydrated] = useState(false);
  const [purchases, setPurchases] = useState([]);
  const [purchasesHydrated, setPurchasesHydrated] = useState(false);
  const deferredHydrationPayloadRef = useRef(null);
  const deferredHydrationReadyRef = useRef(false);
  const deferredHydrationInFlightRef = useRef(false);
  const [deferredHydrationReady, setDeferredHydrationReady] = useState(false);
  const [activeTab, setActiveTabState] = useState("feed");
  const [heroCarouselIndex, setHeroCarouselIndex] = useState(0);
  const [heroCarouselLocked, setHeroCarouselLocked] = useState(false);
  const [dailyGoalCoinDropTick, setDailyGoalCoinDropTick] = useState(0);
  const [dailyGoalCollectedKey, setDailyGoalCollectedKey] = useState(null);
  const [dailyGoalCollectModal, setDailyGoalCollectModal] = useState({
    visible: false,
    coins: 0,
  });
  const dailyGoalCollectInFlightRef = useRef(false);
  const [tabHistory, setTabHistoryState] = useState([]);
  const tabHistoryRef = useRef(tabHistory);
  const pendingScrollRef = useRef(null);
  const progressScrollRef = useRef(null);
  const rewardsScrollRef = useRef(null);
  const profileScrollRef = useRef(null);
  const budgetWidgetLayoutRef = useRef(null);
  const [budgetWidgetLayoutTick, setBudgetWidgetLayoutTick] = useState(0);
  const [pendingProgressScrollTarget, setPendingProgressScrollTarget] = useState(null);
  const pendingCardLayoutsRef = useRef(new Map());
  const [pendingFocusId, setPendingFocusId] = useState(null);
  const persistQueueRef = useRef(new Map());
  const persistTimerRef = useRef(null);
  const flushPersistQueue = useCallback(
    (immediate = false) => {
      if (persistTimerRef.current) {
        clearTimeout(persistTimerRef.current);
        persistTimerRef.current = null;
      }
      const entries = Array.from(persistQueueRef.current.entries());
      if (!entries.length) return;
      persistQueueRef.current.clear();
      const write = () => {
        AsyncStorage.multiSet(entries).catch(() => {});
      };
      if (immediate) {
        write();
        return;
      }
      InteractionManager.runAfterInteractions(write);
    },
    []
  );
  const queuePersist = useCallback(
    (key, value) => {
      if (!key || typeof value === "undefined") return;
      const stringValue = typeof value === "string" ? value : String(value);
      persistQueueRef.current.set(key, stringValue);
      if (persistTimerRef.current) {
        clearTimeout(persistTimerRef.current);
      }
      persistTimerRef.current = setTimeout(() => {
        flushPersistQueue(false);
      }, PERSIST_DEBOUNCE_MS);
    },
    [flushPersistQueue]
  );
  useEffect(() => () => flushPersistQueue(true), [flushPersistQueue]);
  const [homeSpeechTrigger, setHomeSpeechTrigger] = useState({ tick: 0, reason: "init" });
  const [speechWarmupTick, setSpeechWarmupTick] = useState(0);
  const homeSpeechReadyRef = useRef(false);
  const homeSpeechBootedRef = useRef(false);
  const triggerHomeSpeech = useCallback((reason = "unknown") => {
    setHomeSpeechTrigger((prev) => ({ tick: prev.tick + 1, reason }));
  }, []);
  const onboardingCompletedRef = useRef(false);
  const [premiumInstallId, setPremiumInstallId] = useState("");
  const [premiumInstallIdHydrated, setPremiumInstallIdHydrated] = useState(false);
  const [premiumSoftPaywallShown, setPremiumSoftPaywallShown] = useState(false);
  const [premiumSoftPaywallPending, setPremiumSoftPaywallPending] = useState(false);
  const [premiumSoftPaywallHydrated, setPremiumSoftPaywallHydrated] = useState(false);
  const [premiumHardPaywallShown, setPremiumHardPaywallShown] = useState(false);
  const [premiumHardPaywallHydrated, setPremiumHardPaywallHydrated] = useState(false);
  const [premiumChallengeClaims, setPremiumChallengeClaims] = useState(0);
  const [premiumChallengeClaimsHydrated, setPremiumChallengeClaimsHydrated] = useState(false);
  const [premiumState, setPremiumState] = useState({
    enabled: false,
    isPremium: false,
    entitlement: null,
    customerInfo: null,
    offerings: null,
    offeringsByPlan: {},
    lastSource: "boot",
    error: null,
  });
  const premiumPaywallTimerRef = useRef(null);
  const premiumSoftPaywallCheckTimerRef = useRef(null);
  const [premiumPaywallState, setPremiumPaywallState] = useState({
    visible: false,
    kind: "soft",
    featureKey: null,
    savedAmountLabel: "",
    trigger: "manual",
  });
  const premiumPaywallDismissedAtRef = useRef(0);
  const premiumPaywallVisibilityRef = useRef(false);
  const premiumPaywallViewIndexRef = useRef(0);
  const premiumPaywallActiveViewRef = useRef(null);
  const [premiumPurchaseLoadingPlan, setPremiumPurchaseLoadingPlan] = useState(null);
  const [premiumRestoreLoading, setPremiumRestoreLoading] = useState(false);
  const showPremiumPaywallRef = useRef(() => false);
  const lastDeclineCountRef = useRef(null);
  const lastCompletedGoalsCountRef = useRef(null);
  const premiumUnlockTransitionRef = useRef(null);
  const premiumUnlockIntentRef = useRef(null);
  const premiumAndroidConfigAlertShownRef = useRef(false);
  useEffect(() => {
    wishesRef.current = wishes;
  }, [wishes]);

  useEffect(() => {
    tabHistoryRef.current = tabHistory;
  }, [tabHistory]);
  const updateTabHistory = useCallback((updater) => {
    setTabHistoryState((prev) => {
      const next = typeof updater === "function" ? updater(prev) : updater;
      tabHistoryRef.current = next;
      return next;
    });
  }, []);
  const goToTab = useCallback(
    (tabKey, { recordHistory = true, resetHistory = false } = {}) => {
      setActiveTabState((current) => {
        if (resetHistory) {
          updateTabHistory([]);
        }
        if (current === tabKey) {
          return current;
        }
        if (recordHistory && current && !resetHistory) {
          updateTabHistory((prev) => {
            const trimmed =
              prev.length >= MAX_TAB_HISTORY ? prev.slice(prev.length - (MAX_TAB_HISTORY - 1)) : prev;
            return [...trimmed, current];
          });
        }
        return tabKey;
      });
    },
    [updateTabHistory]
  );
  const handleProgressBudgetWidgetLayout = useCallback((event) => {
    const layout = event?.nativeEvent?.layout;
    if (!layout) return;
    const previous = budgetWidgetLayoutRef.current;
    if (
      previous &&
      previous.y === layout.y &&
      previous.height === layout.height &&
      previous.width === layout.width
    ) {
      return;
    }
    budgetWidgetLayoutRef.current = layout;
    setBudgetWidgetLayoutTick((tick) => tick + 1);
  }, []);
  const requestProgressBudgetFocus = useCallback(() => {
    if (!premiumState.isPremium) {
      showPremiumPaywallRef.current({
        kind: "feature",
        featureKey: PREMIUM_FEATURE_KEYS.homeWidget,
      });
      return;
    }
    setPendingProgressScrollTarget("budget");
    goToTab("cart");
  }, [goToTab, premiumState.isPremium]);
  const registerPendingCardLayout = useCallback((id, layout) => {
    if (!id || !layout) return;
    pendingCardLayoutsRef.current.set(id, layout.y);
  }, []);
  const handleProgressChallengeOpen = useCallback(
    (challengeId) => {
      if (challengeId) {
        setProgressFocusChallengeId(challengeId);
      }
      goToTab("cart");
    },
    [goToTab]
  );
  useEffect(() => {
    if (activeTab !== "cart") return;
    if (pendingProgressScrollTarget !== "budget") return;
    const scrollView = progressScrollRef.current;
    const layout = budgetWidgetLayoutRef.current;
    if (!scrollView || typeof scrollView.scrollTo !== "function" || !layout || !Number.isFinite(layout.y)) {
      return;
    }
    const targetY = Math.max(layout.y - 12, 0);
    scrollView.scrollTo({ y: targetY, animated: true });
    setPendingProgressScrollTarget(null);
  }, [activeTab, budgetWidgetLayoutTick, pendingProgressScrollTarget]);
  const [catalogOverrides, setCatalogOverrides] = useState({});
  const [catalogHydrated, setCatalogHydrated] = useState(false);
  const [pricePrecisionOverrides, setPricePrecisionOverrides] = useState({});
  const [pricePrecisionOverridesHydrated, setPricePrecisionOverridesHydrated] = useState(false);
  const [titleOverrides, setTitleOverrides] = useState({});
  const [titleOverridesHydrated, setTitleOverridesHydrated] = useState(false);
  const [emojiOverrides, setEmojiOverrides] = useState({});
  const [emojiOverridesHydrated, setEmojiOverridesHydrated] = useState(false);
  const [categoryOverrides, setCategoryOverrides] = useState({});
  const [categoryOverridesHydrated, setCategoryOverridesHydrated] = useState(false);
  const [customCategories, setCustomCategories] = useState([]);
  const [customCategoriesHydrated, setCustomCategoriesHydrated] = useState(false);
  const [removedCategories, setRemovedCategories] = useState([]);
  const [removedCategoriesHydrated, setRemovedCategoriesHydrated] = useState(false);
  const [savingsCategoryOverride, setSavingsCategoryOverride] = useState(null);
  const [savingsCategoryOverrideHydrated, setSavingsCategoryOverrideHydrated] = useState(false);
  const [categoryDefOverrides, setCategoryDefOverrides] = useState({});
  const [categoryDefOverridesHydrated, setCategoryDefOverridesHydrated] = useState(false);
  const [descriptionOverrides, setDescriptionOverrides] = useState({});
  const [descriptionOverridesHydrated, setDescriptionOverridesHydrated] = useState(false);
  const [temptations, setTemptations] = useState(DEFAULT_TEMPTATIONS);
  const [quickTemptations, setQuickTemptations] = useState([]);
  const [quickTemptationsHydrated, setQuickTemptationsHydrated] = useState(false);
  const [customTemptationsCreatedCount, setCustomTemptationsCreatedCount] = useState(0);
  const [customTemptationsCreatedHydrated, setCustomTemptationsCreatedHydrated] = useState(false);
  const [hiddenTemptations, setHiddenTemptations] = useState([]);
  const [hiddenTemptationsHydrated, setHiddenTemptationsHydrated] = useState(false);
  const [archivedTemptations, setArchivedTemptations] = useState([]);
  const [archivedTemptationsHydrated, setArchivedTemptationsHydrated] = useState(false);
  const customTemptationCount = quickTemptations.length;
  const temptationLimitWarningShownRef = useRef(false);
  const [priceEditor, setPriceEditor] = useState({
    item: null,
    value: "",
    title: "",
    emoji: "",
    category: DEFAULT_IMPULSE_CATEGORY,
    description: "",
    frequency: "daily",
    frequencyCustom: null,
  });
  const [customReminderId, setCustomReminderId] = useState(null);
  const [customReminderHydrated, setCustomReminderHydrated] = useState(false);
  const [smartReminders, setSmartReminders] = useState([]);
  const [smartRemindersHydrated, setSmartRemindersHydrated] = useState(false);
  const [potentialPushProgress, setPotentialPushProgress] = useState({
    ...DEFAULT_POTENTIAL_PUSH_STATE,
  });
  const [potentialPushHydrated, setPotentialPushHydrated] = useState(false);
  const [dailyNudgeNotificationIds, setDailyNudgeNotificationIds] = useState({});
  const [dailyNudgesHydrated, setDailyNudgesHydrated] = useState(false);
  const [dailyChallenge, setDailyChallenge] = useState(() => createInitialDailyChallengeState());
  const [dailyChallengeHydrated, setDailyChallengeHydrated] = useState(false);
  const [dailyChallengeCompletedCount, setDailyChallengeCompletedCount] = useState(0);
  const [dailyChallengeCompletedHydrated, setDailyChallengeCompletedHydrated] = useState(false);
  const [savedTotalUSD, setSavedTotalUSD] = useState(0);
  const [savedTotalHydrated, setSavedTotalHydrated] = useState(false);
  const [progressSavedTotalUSD, setProgressSavedTotalUSD] = useState(0);
  const [progressSavedTotalHydrated, setProgressSavedTotalHydrated] = useState(false);
  const [levelProgressOffsetUSD, setLevelProgressOffsetUSD] = useState(0);
  const [levelProgressOffsetHydrated, setLevelProgressOffsetHydrated] = useState(false);
  const tutorialLevelOffsetAppliedRef = useRef(false);
  const [lastCelebratedLevel, setLastCelebratedLevel] = useState(1);
  const [lastCelebratedLevelHydrated, setLastCelebratedLevelHydrated] = useState(false);
  const persistLastCelebratedLevel = useCallback(
    (nextLevel) => {
      const normalized = Math.max(1, Number(nextLevel) || 1);
      setLastCelebratedLevel(normalized);
      AsyncStorage.setItem(
        STORAGE_KEYS.LAST_CELEBRATED_LEVEL,
        String(normalized)
      ).catch(() => {});
    },
    []
  );
  useEffect(() => {
    if (!levelProgressOffsetHydrated) return;
    tutorialLevelOffsetAppliedRef.current = levelProgressOffsetUSD > 0;
  }, [levelProgressOffsetHydrated, levelProgressOffsetUSD]);
  const [lifetimeSavedUSD, setLifetimeSavedUSD] = useState(0);
  const [lifetimeSavedHydrated, setLifetimeSavedHydrated] = useState(false);
  const [progressLifetimeSavedUSD, setProgressLifetimeSavedUSD] = useState(0);
  const [progressLifetimeSavedHydrated, setProgressLifetimeSavedHydrated] = useState(false);
  const [declineCount, setDeclineCount] = useState(0);
  const [declinesHydrated, setDeclinesHydrated] = useState(false);
  const [pendingList, setPendingList] = useState([]);
  const [pendingBadgeTick, setPendingBadgeTick] = useState(0);
  const [pendingHydrated, setPendingHydrated] = useState(false);
  useEffect(() => {
    pendingCardLayoutsRef.current.clear();
  }, [pendingList]);
  const [freeDayStats, setFreeDayStats] = useState({ ...INITIAL_FREE_DAY_STATS });
  const [usageStreak, setUsageStreak] = useState({ ...INITIAL_USAGE_STREAK });
  const [usageStreakHydrated, setUsageStreakHydrated] = useState(false);
  const usageStreakBackfillRef = useRef(false);
  const usageStreakRef = useRef(usageStreak);
  useEffect(() => {
    usageStreakRef.current = usageStreak;
  }, [usageStreak]);
  const [streakPledge, setStreakPledge] = useState({ ...INITIAL_STREAK_PLEDGE });
  const [streakPledgeHydrated, setStreakPledgeHydrated] = useState(false);
  const streakPledgeRef = useRef(streakPledge);
  useEffect(() => {
    streakPledgeRef.current = streakPledge;
  }, [streakPledge]);
  const [healthPoints, setHealthPoints] = useState(0);
  const [healthHydrated, setHealthHydrated] = useState(false);
  const [dailyRewardState, setDailyRewardState] = useState({ ...DEFAULT_DAILY_REWARD_STATE });
  const [dailyRewardHydrated, setDailyRewardHydrated] = useState(false);
  const [dailyRewardModalVisible, setDailyRewardModalVisible] = useState(false);
  const [currentDayKey, setCurrentDayKey] = useState(() => getDayKey(Date.now()));
  const [claimedRewards, setClaimedRewards] = useState({});
  const [claimedRewardsHydrated, setClaimedRewardsHydrated] = useState(false);
  const safeClaimedRewards = useMemo(
    () => (claimedRewards && typeof claimedRewards === "object" ? claimedRewards : {}),
    [claimedRewards]
  );
  const [rewardClaimTotal, setRewardClaimTotal] = useState(0);
  const [rewardTotalHydrated, setRewardTotalHydrated] = useState(false);
  const pruneClaimedRewards = useCallback(() => {
    setClaimedRewards((prev) => {
      const normalized = normalizeClaimedRewardsMap(prev || {});
      if (claimedRewardsEqual(prev || {}, normalized)) {
        return prev;
      }
      return normalized;
    });
  }, []);
  useEffect(() => {
    pruneClaimedRewards();
    const interval = setInterval(pruneClaimedRewards, DAY_MS);
    return () => clearInterval(interval);
  }, [pruneClaimedRewards]);
  const dayRolloverTimerRef = useRef(null);
  useEffect(() => {
    const scheduleNextMidnight = () => {
      if (dayRolloverTimerRef.current) {
        clearTimeout(dayRolloverTimerRef.current);
      }
      const now = Date.now();
      const nextMidnight = new Date(now);
      nextMidnight.setHours(24, 0, 0, 0);
      const delay = Math.max(1000, nextMidnight.getTime() - now);
      dayRolloverTimerRef.current = setTimeout(() => {
        setCurrentDayKey(getDayKey(Date.now()));
        scheduleNextMidnight();
      }, delay);
    };
    scheduleNextMidnight();
    return () => {
      if (dayRolloverTimerRef.current) {
        clearTimeout(dayRolloverTimerRef.current);
      }
    };
  }, []);
  useEffect(() => {
    if (!usageStreakHydrated) return;
    const todayKey = currentDayKey;
    const yesterdayKey = getDayKey(Date.now() - DAY_MS);
    setUsageStreak((prev) => {
      if (!prev?.lastDate) return prev;
      if (prev.lastDate === todayKey || prev.lastDate === yesterdayKey) return prev;
      const prevCount = Math.max(0, Number(prev.current) || 0);
      if (!prevCount) return prev;
      return { ...prev, current: 0, lostCount: prevCount };
    });
  }, [currentDayKey, usageStreakHydrated]);
  const usageStreakLoggedToday = useMemo(
    () => usageStreak?.lastDate === currentDayKey,
    [currentDayKey, usageStreak?.lastDate]
  );
  useEffect(() => {
    if (!streakPledgeHydrated || !usageStreakHydrated) return;
    if (streakPledge.status !== STREAK_PLEDGE_STATUS.ACTIVE) return;
    if (streakPledge.rewardPending) return;
    const targetDays = Math.max(0, Number(streakPledge.targetDays) || 0);
    if (!targetDays) return;
    const startCount = Math.max(1, Number(streakPledge.startCount) || 1);
    const targetCount = startCount + targetDays - 1;
    const currentCount = Math.max(0, Number(usageStreak?.current) || 0);
    const lostCount = Math.max(0, Number(usageStreak?.lostCount) || 0);
    if (lostCount > 0 && currentCount <= 1) {
      setStreakPledge((prev) => ({
        ...prev,
        status: STREAK_PLEDGE_STATUS.FAILED,
        rewardPending: false,
      }));
      logEvent("streak_goal_failed", {
        target_days: targetDays,
        start_count: startCount,
        current_streak: currentCount,
      });
      return;
    }
    if (currentCount >= targetCount) {
      const computed = computeStreakPledgeReward(targetDays);
      const rewardBlueCoins = Math.max(
        0,
        Number(streakPledge.rewardBlueCoins) || computed.blueCoins
      );
      const rewardValue = Math.max(
        0,
        Number(streakPledge.rewardValue) || computed.rewardValue
      );
      if (rewardValue > 0) {
        setHealthPoints((prev) => prev + rewardValue);
      }
      setStreakPledge((prev) => ({
        ...prev,
        status: STREAK_PLEDGE_STATUS.COMPLETED,
        rewardPending: true,
        rewardBlueCoins,
        rewardValue,
      }));
      logEvent("streak_goal_completed", {
        target_days: targetDays,
        reward_blue: rewardBlueCoins,
        reward_value: rewardValue,
        current_streak: currentCount,
        start_count: startCount,
      });
    }
  }, [
    logEvent,
    setHealthPoints,
    streakPledge,
    streakPledgeHydrated,
    usageStreak,
    usageStreakHydrated,
  ]);
  const [challengesState, setChallengesState] = useState(() => createInitialChallengesState());
  const [challengesHydrated, setChallengesHydrated] = useState(false);
  const [challengeBadgeStore, setChallengeBadgeStore] = useState([]);
  const [challengeBadgeStoreHydrated, setChallengeBadgeStoreHydrated] = useState(false);
  const [rewardsPane, setRewardsPane] = useState("rewards");
  useEffect(() => {
    if (challengesUnlocked) return;
    if (rewardsPane !== "rewards") {
      setRewardsPane("rewards");
    }
  }, [challengesUnlocked, rewardsPane]);
  const [decisionStats, setDecisionStats] = useState({ ...INITIAL_DECISION_STATS });
  const [decisionStatsHydrated, setDecisionStatsHydrated] = useState(false);
  const [historyEvents, setHistoryEvents] = useState([]);
  const [historyHydrated, setHistoryHydrated] = useState(false);
  const [incomeEntries, setIncomeEntries] = useState([]);
  const [incomeEntriesHydrated, setIncomeEntriesHydrated] = useState(false);
  const [budgetOverrides, setBudgetOverrides] = useState({});
  const [budgetOverridesHydrated, setBudgetOverridesHydrated] = useState(false);
  const [budgetOverspendMap, setBudgetOverspendMap] = useState({});
  const [budgetOverspendHydrated, setBudgetOverspendHydrated] = useState(false);
  const [incomePromptState, setIncomePromptState] = useState({
    lastPromptMonthKey: null,
    lastPromptAt: 0,
  });
  const [incomePromptHydrated, setIncomePromptHydrated] = useState(false);
  const [incomePromptPending, setIncomePromptPending] = useState(false);
  const [incomeEntryModalVisible, setIncomeEntryModalVisible] = useState(false);
  const [incomeEntryInput, setIncomeEntryInput] = useState({ amount: "" });
  const incomeEntrySourceRef = useRef("manual");
  const incomeEntryModeRef = useRef(INCOME_ENTRY_TYPES.MONTHLY);
  const resolvedHistoryEvents = Array.isArray(historyEvents) ? historyEvents : [];
  const visibleHistoryEvents = useMemo(() => {
    if (premiumState.isPremium) return resolvedHistoryEvents;
    const cutoffTimestamp = Date.now() - FREE_HISTORY_WINDOW_MS;
    return resolvedHistoryEvents.filter((entry) => {
      const timestamp = Number(entry?.timestamp) || 0;
      return timestamp > 0 && timestamp >= cutoffTimestamp;
    });
  }, [premiumState.isPremium, resolvedHistoryEvents]);
  const [progressFocusChallengeId, setProgressFocusChallengeId] = useState(null);
  const levelProgressBaseUSD = Math.max(
    progressSavedTotalUSD || 0,
    progressLifetimeSavedUSD || 0
  );
  const levelProgressUSD = Math.max(0, levelProgressBaseUSD - levelProgressOffsetUSD);
  const profileCurrencyCode = normalizeCurrencyCode(
    profile?.currency || DEFAULT_PROFILE.currency
  );
  const widgetCurrencyCode = normalizeCurrencyCode(activeCurrency || profileCurrencyCode);
  const formatWidgetAmount = useCallback(
    (valueUSD = 0) =>
      formatCurrency(convertToCurrency(valueUSD || 0, widgetCurrencyCode), widgetCurrencyCode),
    [widgetCurrencyCode]
  );
  const fabMainIcon = useMemo(() => {
    if (activeTab === "feed") {
      const label = formatCurrency(0, fabCurrencyCode);
      const parts = splitCurrencyLabel(label, fabCurrencyCode);
      return parts.symbol || "$";
    }
    return "+";
  }, [activeTab, fabCurrencyCode]);
  const playerTierInfo = useMemo(
    () => getTierProgress(levelProgressUSD || 0, profileCurrencyCode),
    [levelProgressUSD, profileCurrencyCode]
  );
  const playerLevel = playerTierInfo.level;
  const premiumActive = premiumState.isPremium;
  const budgetAutoTrialStartTimestamp = useMemo(() => {
    const joinedValue = profile?.joinedAt || profile?.spendingProfile?.baselineStartAt || null;
    if (!joinedValue) return null;
    if (typeof joinedValue === "number" && Number.isFinite(joinedValue)) {
      return joinedValue;
    }
    const parsed = Date.parse(String(joinedValue));
    return Number.isFinite(parsed) ? parsed : null;
  }, [profile?.joinedAt, profile?.spendingProfile?.baselineStartAt]);
  const freeBudgetAutoTrialActive = useMemo(() => {
    if (premiumActive) return false;
    if (!Number.isFinite(budgetAutoTrialStartTimestamp)) return true;
    const elapsedMs = Math.max(0, Date.now() - Number(budgetAutoTrialStartTimestamp));
    return elapsedMs < FREE_BUDGET_AUTO_DAYS * DAY_MS;
  }, [budgetAutoTrialStartTimestamp, currentDayKey, premiumActive]);
  const budgetAutoEnabled = premiumActive || freeBudgetAutoTrialActive;
  const hasSpendHistory = useMemo(
    () => resolvedHistoryEvents.some((entry) => entry.kind === "spend"),
    [resolvedHistoryEvents]
  );
  const reportsUnlockLevel = FEATURE_UNLOCK_LEVELS.reports || 6;
  const reportsUnlocked = premiumActive;
  const dailyChallengeUnlocked = premiumActive || (playerLevel >= 2 && hasSpendHistory);
  const dailyRewardUnlocked = premiumActive || playerLevel >= 2;
  const focusModeUnlocked = premiumActive || playerLevel >= 3;
  const dailySummaryUnlocked = premiumActive || playerLevel >= 3;
  const focusTargetsUnlocked = premiumActive || playerLevel >= 5;
  const catCustomizationUnlocked = premiumActive;
  const rewardsUnlocked = premiumActive || playerLevel >= 5;
  const challengesUnlocked = true;
  const impulseFeaturesUnlocked = premiumActive;
  const freeDayUnlocked = premiumActive || playerLevel >= 7;
  const thinkingUnlocked = premiumActive || playerLevel >= 3;
  const todayKey = currentDayKey;
  const currentMonthKey = useMemo(() => getMonthKey(Date.now()), [currentDayKey]);
  const widgetSavedMonthUSD = useMemo(() => {
    let total = 0;
    resolvedHistoryEvents.forEach((entry) => {
      if (!entry || !HISTORY_SAVED_GAIN_EVENTS.has(entry.kind)) return;
      const timestamp = Number(entry.timestamp) || 0;
      if (!timestamp) return;
      if (getMonthKey(timestamp) !== currentMonthKey) return;
      const amount = Math.max(0, Number(entry?.meta?.amountUSD) || 0);
      if (!amount) return;
      total += amount;
    });
    return total;
  }, [currentMonthKey, resolvedHistoryEvents]);
  const widgetStreakDisplayCount = useMemo(() => {
    const currentCount = Math.max(0, Number(usageStreak?.current) || 0);
    const lostCount = Math.max(0, Number(usageStreak?.lostCount) || 0);
    return currentCount === 0 && lostCount > 0 ? lostCount : currentCount;
  }, [usageStreak]);
  const widgetSavedTodayUSD = useMemo(() => {
    let total = 0;
    resolvedHistoryEvents.forEach((entry) => {
      if (!entry || !HISTORY_SAVED_GAIN_EVENTS.has(entry.kind)) return;
      const timestamp = Number(entry.timestamp) || 0;
      if (!timestamp) return;
      if (getDayKey(timestamp) !== todayKey) return;
      const amount = Math.max(0, Number(entry?.meta?.amountUSD) || 0);
      if (!amount) return;
      total += amount;
    });
    return total;
  }, [resolvedHistoryEvents, todayKey]);
  const widgetMonthlyTargetUSD = useMemo(() => {
    if (widgetSavedMonthUSD <= 0 && widgetSavedTodayUSD <= 0) return 0;
    const baselineFromMonth = widgetSavedMonthUSD > 0 ? widgetSavedMonthUSD * 1.15 : 0;
    const baselineFromToday = widgetSavedTodayUSD > 0 ? widgetSavedTodayUSD * 30 : 0;
    const fallback = Math.max(widgetSavedMonthUSD, widgetSavedTodayUSD * 30);
    return Math.max(baselineFromMonth, baselineFromToday, fallback);
  }, [widgetSavedMonthUSD, widgetSavedTodayUSD]);
  const widgetDailyGoalUSD = useMemo(() => {
    if (widgetMonthlyTargetUSD <= 0) return 0;
    const now = Date.now();
    const date = new Date(now);
    if (Number.isNaN(date.getTime())) return 0;
    const daysInMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
    const dayOfMonth = Math.max(1, date.getDate());
    const daysRemaining = Math.max(1, daysInMonth - dayOfMonth + 1);
    const remaining = Math.max(widgetMonthlyTargetUSD - widgetSavedMonthUSD, 0);
    return remaining / daysRemaining;
  }, [currentDayKey, widgetMonthlyTargetUSD, widgetSavedMonthUSD]);
  const widgetBudgetStats = useMemo(() => {
    const stats = {};
    const ensure = (key) => {
      if (!key) return null;
      if (!stats[key]) {
        stats[key] = { incomeUSD: 0, spendTotalUSD: 0 };
      }
      return stats[key];
    };
    const monthKeys = collectBudgetMonthKeys(incomeEntries, resolvedHistoryEvents, currentMonthKey);
    monthKeys.forEach((key) => {
      const target = ensure(key);
      if (!target) return;
      target.incomeUSD = getBudgetIncomeForMonth(incomeEntries, key);
    });
    resolvedHistoryEvents.forEach((entry) => {
      if (!entry || entry.kind !== "spend") return;
      const timestamp = Number(entry?.timestamp) || 0;
      if (!timestamp) return;
      const key = getMonthKey(timestamp);
      if (!key) return;
      const target = ensure(key);
      if (!target) return;
      const amount = Math.max(0, Number(entry?.meta?.amountUSD) || 0);
      if (!amount) return;
      target.spendTotalUSD += amount;
    });
    return stats;
  }, [currentMonthKey, incomeEntries, resolvedHistoryEvents]);
  const widgetBudgetCarryover = useMemo(() => {
    const keys = Object.keys(widgetBudgetStats);
    if (!keys.length) return {};
    const sorted = [...keys].sort();
    let running = 0;
    const map = {};
    sorted.forEach((key) => {
      map[key] = running;
      const stats = widgetBudgetStats[key];
      running += (stats?.incomeUSD || 0) - (stats?.spendTotalUSD || 0);
    });
    return map;
  }, [widgetBudgetStats]);
  const widgetBudgetMonthStats = widgetBudgetStats[currentMonthKey] || {
    incomeUSD: 0,
    spendTotalUSD: 0,
  };
  const widgetBudgetTotalValue =
    (Number(widgetBudgetMonthStats.incomeUSD) || 0) +
    (Number(widgetBudgetCarryover[currentMonthKey]) || 0);
  const widgetBudgetRemainingValue =
    widgetBudgetTotalValue - (Number(widgetBudgetMonthStats.spendTotalUSD) || 0);
  const widgetBudgetRemainingLabel = formatWidgetAmount(Math.abs(widgetBudgetRemainingValue));
  useEffect(() => {
    if (!canUpdateWidgetStorage()) return;
    if (!profileHydrated || !usageStreakHydrated || !historyHydrated || !savedTotalHydrated) {
      return;
    }
    const savedMonthValue = Math.max(0, Number(widgetSavedMonthUSD) || 0);
    const savedTotalValue = Math.max(0, Number(savedTotalUSD) || 0);
    const monthlyTargetValue = Math.max(0, Number(widgetMonthlyTargetUSD) || 0);
    const savedTodayValue = Math.max(0, Number(widgetSavedTodayUSD) || 0);
    const dailyGoalValue = Math.max(0, Number(widgetDailyGoalUSD) || 0);
    const savedMonthLabel = formatWidgetAmount(savedMonthValue);
    const savedTotalLabel = formatWidgetAmount(savedTotalValue);
    const savedTodayLabel = formatWidgetAmount(savedTodayValue);
    const streakDays = Math.max(0, Number(widgetStreakDisplayCount) || 0);
    const hasData =
      premiumActive &&
      (savedTotalValue > 0 ||
        (Array.isArray(resolvedHistoryEvents) && resolvedHistoryEvents.length > 0) ||
        streakDays > 0);
    const currencyCode = widgetCurrencyCode;
    const prev = widgetDataRef.current || {};
    if (
      prev.currencyCode === currencyCode &&
      prev.savedMonthLabel === savedMonthLabel &&
      prev.savedTotalLabel === savedTotalLabel &&
      prev.savedTodayLabel === savedTodayLabel &&
      prev.streakDays === streakDays &&
      prev.hasData === hasData &&
      prev.savedMonthValue === savedMonthValue &&
      prev.savedTotalValue === savedTotalValue &&
      prev.monthlyTargetValue === monthlyTargetValue &&
      prev.savedTodayValue === savedTodayValue &&
      prev.dailyGoalValue === dailyGoalValue &&
      prev.refreshTick === widgetRefreshTick
    ) {
      return;
    }
    widgetDataRef.current = {
      savedMonthLabel,
      savedTotalLabel,
      savedTodayLabel,
      streakDays,
      hasData,
      savedMonthValue,
      savedTotalValue,
      monthlyTargetValue,
      savedTodayValue,
      dailyGoalValue,
      currencyCode,
      refreshTick: widgetRefreshTick,
    };
    setWidgetDataSafely({
      savedMonthLabel,
      savedTotalLabel,
      savedTodayLabel,
      streakDays,
      hasData,
      savedMonthValue,
      savedTotalValue,
      monthlyTargetValue,
      savedTodayValue,
      dailyGoalValue,
      widgetCurrencyCode: currencyCode,
    });
  }, [
    formatWidgetAmount,
    historyHydrated,
    profileHydrated,
    widgetCurrencyCode,
    resolvedHistoryEvents,
    savedTotalHydrated,
    savedTotalUSD,
    usageStreakHydrated,
    widgetDailyGoalUSD,
    widgetMonthlyTargetUSD,
    widgetSavedMonthUSD,
    widgetSavedTodayUSD,
    widgetStreakDisplayCount,
    premiumActive,
    widgetRefreshTick,
  ]);
  const currentMonthIncomeUSD = useMemo(
    () => getBudgetIncomeForMonth(incomeEntries, currentMonthKey),
    [incomeEntries, currentMonthKey]
  );
  const currentMonthRecurringIncomeUSD = useMemo(
    () => getRecurringIncomeForMonth(incomeEntries, currentMonthKey),
    [incomeEntries, currentMonthKey]
  );
  const hasMonthlyIncomeEntries = useMemo(
    () =>
      (Array.isArray(incomeEntries) ? incomeEntries : []).some(
        (entry) => normalizeIncomeEntryType(entry?.entryType) === INCOME_ENTRY_TYPES.MONTHLY
      ),
    [incomeEntries]
  );
  const currentMonthSpendUSD = useMemo(() => {
    let total = 0;
    resolvedHistoryEvents.forEach((entry) => {
      if (!entry || entry.kind !== "spend") return;
      if (!entry.timestamp) return;
      if (getMonthKey(entry.timestamp) !== currentMonthKey) return;
      const amount = Math.max(0, Number(entry?.meta?.amountUSD) || 0);
      if (!amount) return;
      total += amount;
    });
    return total;
  }, [resolvedHistoryEvents, currentMonthKey]);
  const currentMonthOverspendUSD = useMemo(() => {
    if (!currentMonthIncomeUSD) return 0;
    return Math.max(0, currentMonthSpendUSD - currentMonthIncomeUSD);
  }, [currentMonthIncomeUSD, currentMonthSpendUSD]);
  const baseDailyRewardAmount = useMemo(
    () => (dailyRewardUnlocked ? computeDailyAlmiReward(levelProgressUSD) : 0),
    [dailyRewardUnlocked, levelProgressUSD]
  );
  const dailyRewardLastKey = useMemo(() => {
    if (dailyRewardState.lastKey) return dailyRewardState.lastKey;
    if (Number.isFinite(dailyRewardState.lastClaimAt) && dailyRewardState.lastClaimAt > 0) {
      return getDayKey(dailyRewardState.lastClaimAt);
    }
    return null;
  }, [dailyRewardState.lastClaimAt, dailyRewardState.lastKey]);
  const dailyRewardDay = useMemo(() => {
    if (!dailyRewardHydrated) return 1;
    if (!dailyRewardLastKey) return 1;
    const dayDiff = getDayDiff(dailyRewardLastKey, todayKey);
    const currentStreak = Math.max(1, dailyRewardState.streak || 1);
    const normalizedStreak =
      ((currentStreak - 1) % DAILY_REWARD_STREAK_LENGTH) + 1;
    if (dayDiff === 0) {
      return normalizedStreak;
    }
    if (dayDiff === 1) {
      return (normalizedStreak % DAILY_REWARD_STREAK_LENGTH) + 1;
    }
    return 1;
  }, [dailyRewardHydrated, dailyRewardLastKey, dailyRewardState.streak, todayKey]);
  const dailyRewardAmount = useMemo(
    () => (dailyRewardUnlocked ? getDailyRewardForDay(baseDailyRewardAmount, dailyRewardDay) : 0),
    [baseDailyRewardAmount, dailyRewardDay, dailyRewardUnlocked]
  );
  const dailyRewardReady =
    dailyRewardUnlocked &&
    dailyRewardHydrated &&
    healthHydrated &&
    dailyRewardLastKey !== todayKey &&
    dailyRewardAmount > 0;
  const dailyRewardUnlockLevel = FEATURE_UNLOCK_LEVELS.rewardsDaily || 2;
  const dailyRewardDisplayAmount =
    dailyRewardReady ? dailyRewardAmount : dailyRewardState.lastAmount || dailyRewardAmount || 0;
  const dailyGoalDayLabel = useMemo(() => {
    const locale = getFormatLocale(language);
    const dayDate = parseDayKey(todayKey) || new Date();
    return dayDate.toLocaleDateString(locale, { weekday: "short", day: "numeric" });
  }, [language, todayKey]);
  useEffect(() => {
    if (!dailyRewardHydrated || !dailyRewardLastKey) return;
    const dayDiff = getDayDiff(dailyRewardLastKey, todayKey);
    if (!Number.isFinite(dayDiff) || dayDiff <= 1) return;
    setDailyRewardState((prev) => {
      if (!prev) return prev;
      if (
        (prev.streak || 0) === 0 &&
        (prev.lastAmount || 0) === 0 &&
        !prev.lastKey &&
        !prev.lastClaimAt
      ) {
        return prev;
      }
      return {
        ...prev,
        streak: 0,
        lastAmount: 0,
        lastKey: null,
        lastClaimAt: 0,
      };
    });
  }, [dailyRewardHydrated, dailyRewardLastKey, todayKey]);
  const handleDailyRewardClaim = useCallback(async () => {
    if (!dailyRewardUnlocked || dailyRewardAmount <= 0) return;
    const claimTimestamp = Date.now();
    const claimKey = getDayKey(claimTimestamp);
    const storedRaw = await AsyncStorage.getItem(STORAGE_KEYS.DAILY_REWARD).catch(() => null);
    const storedDayKey = await AsyncStorage.getItem(STORAGE_KEYS.DAILY_REWARD_DAY_KEY).catch(
      () => null
    );
    if (storedDayKey && storedDayKey === claimKey) {
      return;
    }
    if (storedRaw) {
      try {
        const parsed = JSON.parse(storedRaw);
        const storedKey =
          typeof parsed?.lastKey === "string" && parsed.lastKey
            ? parsed.lastKey
            : Number(parsed?.lastClaimAt)
            ? getDayKey(Number(parsed.lastClaimAt))
            : null;
        if (storedKey === claimKey) {
          return;
        }
      } catch (error) {
        console.warn("daily reward claim read", error);
      }
    }
    if (!dailyRewardReady) return;
    const rewardLabel = formatHealthRewardLabel(dailyRewardAmount, language);
    const dayDiff = getDayDiff(dailyRewardLastKey, claimKey);
    const normalizedStreak =
      ((Math.max(1, dailyRewardState.streak || 1) - 1) % DAILY_REWARD_STREAK_LENGTH) + 1;
    const nextStreak = dayDiff === 1 ? (normalizedStreak % DAILY_REWARD_STREAK_LENGTH) + 1 : 1;
    const nextDailyRewardState = {
      lastKey: claimKey,
      lastAmount: dailyRewardAmount,
      lastClaimAt: claimTimestamp,
      streak: nextStreak,
    };
    setDailyRewardState(nextDailyRewardState);
    AsyncStorage.setItem(
      STORAGE_KEYS.DAILY_REWARD,
      JSON.stringify(nextDailyRewardState)
    ).catch(() => {});
    AsyncStorage.setItem(STORAGE_KEYS.DAILY_REWARD_DAY_KEY, claimKey).catch(() => {});
    setHealthPoints((prev) => prev + dailyRewardAmount);
    triggerCoinRewardHaptics();
    ensureOverlayEnvironmentReady();
    triggerOverlayState(
      "daily_reward",
      {
        amount: rewardLabel,
        amountValue: dailyRewardAmount,
        reason: t("dailyRewardReason", { amount: rewardLabel }),
      },
      { force: true }
    );
    logEvent("daily_reward_claimed", {
      coins: dailyRewardAmount,
      level: playerLevel,
      day: nextStreak,
    });
    if (nextStreak >= 1 && nextStreak <= DAILY_REWARD_STREAK_LENGTH) {
      logEvent(`daily_reward_collected_day_${nextStreak}`, {
        coins: dailyRewardAmount,
        level: playerLevel,
      });
    }
  }, [
    dailyRewardAmount,
    dailyRewardReady,
    dailyRewardUnlocked,
    dailyRewardLastKey,
    dailyRewardState.streak,
    ensureOverlayEnvironmentReady,
    language,
    logEvent,
    playSound,
    playerLevel,
    setDailyRewardState,
    setHealthPoints,
    t,
    triggerOverlayState,
  ]);
  const dailyGoalCollectedToday = dailyGoalCollectedKey === todayKey;
  const closeDailyGoalCollectModal = useCallback(() => {
    setDailyGoalCollectModal((prev) =>
      prev?.visible ? { visible: false, coins: 0 } : prev
    );
  }, []);
  const handleDailyGoalCollect = useCallback(
    async (coinCount = 0) => {
      const normalizedCount = Math.max(0, Math.floor(Number(coinCount) || 0));
      if (!normalizedCount) return;
      const claimKey = todayKey || getDayKey(Date.now());
      if (dailyGoalCollectedKey === claimKey) return;
      if (dailyGoalCollectInFlightRef.current) return;
      dailyGoalCollectInFlightRef.current = true;
      try {
        const storedKey = await AsyncStorage.getItem(STORAGE_KEYS.DAILY_GOAL_COLLECTED).catch(
          () => null
        );
        if (storedKey && storedKey === claimKey) {
          setDailyGoalCollectedKey(claimKey);
          return;
        }
        setDailyGoalCollectedKey(claimKey);
        AsyncStorage.setItem(STORAGE_KEYS.DAILY_GOAL_COLLECTED, claimKey).catch(() => {});
        setHealthPoints((prev) => prev + normalizedCount);
        triggerCoinRewardHaptics();
        playSound?.("coin");
        setDailyGoalCollectModal({ visible: true, coins: normalizedCount });
        logEvent("daily_goal_piggy_collected", {
          coins: normalizedCount,
          day: claimKey,
        });
      } finally {
        dailyGoalCollectInFlightRef.current = false;
      }
    },
    [
      dailyGoalCollectedKey,
      logEvent,
      playSound,
      setHealthPoints,
      todayKey,
    ]
  );
  const appTutorialSteps = useMemo(
    () =>
      APP_TUTORIAL_BASE_STEPS.filter((step) => {
        if (step.requiresRewards && !rewardsUnlocked) {
          return false;
        }
        return true;
      }),
    [rewardsUnlocked]
  );
  const priceLimitUSD = getTemptationPriceLimitForLevel(playerLevel);
  const previousPlayerLevelRef = useRef(playerLevel);
  const resetInProgressRef = useRef(false);
  const levelReachedLoggedRef = useRef(0);
  const [levelReachedLoggedHydrated, setLevelReachedLoggedHydrated] = useState(false);
  const [coinEntryVisible, setCoinEntryVisible] = useState(false);
  const [coinEntryPresetAction, setCoinEntryPresetAction] = useState(null);
  const coinEntryContextRef = useRef({ source: null, openedAt: 0, submitted: false });
  const [coinSliderMaxUSD, setCoinSliderMaxUSD] = useState(DEFAULT_COIN_SLIDER_MAX_USD);
  const [coinSliderHydrated, setCoinSliderHydrated] = useState(false);
  const coinSliderMaxOverrideRef = useRef(null);
  const [breakdownVisible, setBreakdownVisible] = useState(false);
  const [breakdownMode, setBreakdownMode] = useState("spend");
  const [spendBreakdownRange, setSpendBreakdownRange] = useState("week");
  const [spendBreakdownOffset, setSpendBreakdownOffset] = useState(0);
  const [saveBreakdownRange, setSaveBreakdownRange] = useState("day");
  const [saveBreakdownOffset, setSaveBreakdownOffset] = useState(0);
  const [reportsModalVisible, setReportsModalVisible] = useState(false);
  const [reportsTab, setReportsTab] = useState("weekly");
  const visibleTemptations = useMemo(
    () => filterTemptationsByPrice(temptations, priceLimitUSD),
    [temptations, priceLimitUSD]
  );
  const archivedTemptationSet = useMemo(
    () => new Set(archivedTemptations),
    [archivedTemptations]
  );
  const hiddenTemptationSet = useMemo(
    () => new Set(hiddenTemptations),
    [hiddenTemptations]
  );
  const products = useMemo(
    () =>
      visibleTemptations.filter((item) => {
        const templateId = item?.id || item?.templateId;
        return !templateId || !archivedTemptationSet.has(templateId);
      }),
    [visibleTemptations, archivedTemptationSet]
  );
  const archivedProducts = useMemo(() => {
    if (!archivedTemptations.length) return [];
    const map = new Map();
    visibleTemptations.forEach((item) => {
      const templateId = item?.id || item?.templateId;
      if (templateId) map.set(templateId, item);
    });
    return archivedTemptations.map((id) => map.get(id)).filter(Boolean);
  }, [archivedTemptations, visibleTemptations]);
  const [profile, setProfile] = useState(() => ({
    ...DEFAULT_PROFILE_PLACEHOLDER,
    joinedAt: new Date().toISOString(),
  }));
  const spendReducesSavings = !!(profile && profile.spendReducesSavings);
  const [profileHydrated, setProfileHydrated] = useState(false);
  const [widgetRefreshTick, setWidgetRefreshTick] = useState(0);
  const triggerWidgetRefresh = useCallback(
    () => setWidgetRefreshTick((prev) => prev + 1),
    []
  );
  const widgetDataRef = useRef({
    savedMonthLabel: null,
    savedTotalLabel: null,
    savedTodayLabel: null,
    streakDays: null,
    hasData: null,
    savedMonthValue: null,
    savedTotalValue: null,
    monthlyTargetValue: null,
    savedTodayValue: null,
    dailyGoalValue: null,
    currencyCode: null,
    refreshTick: null,
  });
  const widgetSupplementRef = useRef({
    goalTargetValue: null,
    goalSavedValue: null,
    budgetRemainingValue: null,
    budgetRemainingLabel: null,
    budgetTotalValue: null,
    recentEventsKey: null,
    currencyCode: null,
    refreshTick: null,
  });
  const widgetMetaRef = useRef({
    language: null,
    currencyCode: null,
    labelsKey: null,
    refreshTick: null,
  });
  const [profileDraft, setProfileDraft] = useState(() => ({
    ...DEFAULT_PROFILE_PLACEHOLDER,
    joinedAt: new Date().toISOString(),
  }));
  const [fabCurrencyCode, setFabCurrencyCode] = useState(
    () => profile?.currency || DEFAULT_PROFILE.currency
  );
  const reportsSnapshot = useMemo(
    () => normalizeProfileReports(profile?.reports),
    [profile?.reports]
  );
  const reportsHaveData = useMemo(
    () => reportsSnapshotHasMeaningfulData(reportsSnapshot),
    [reportsSnapshot]
  );
  const reportsHaveWeeklyData = useMemo(
    () => reportsSnapshotHasWeeklyData(reportsSnapshot),
    [reportsSnapshot]
  );
  const [reportsBadgeVisible, setReportsBadgeVisible] = useState(false);
  const [reportsBadgeHydrated, setReportsBadgeHydrated] = useState(false);
  const [reportsLastAutoWeekKey, setReportsLastAutoWeekKey] = useState(null);
  const [reportsLastAutoWeekHydrated, setReportsLastAutoWeekHydrated] = useState(false);
  const [reportsWeeklyNotificationId, setReportsWeeklyNotificationId] = useState(null);
  const [reportsWeeklyNotificationHydrated, setReportsWeeklyNotificationHydrated] = useState(false);
  const reportsWeeklyNotificationLocaleRef = useRef(null);
  const reportsLastAutoWeekRef = useRef(null);
  const reportsAutoUpdateRef = useRef({ dayKey: null, digest: null });
  const [primaryTemptationPromptState, setPrimaryTemptationPromptState] = useState("done");
  const [primaryTemptationPromptHydrated, setPrimaryTemptationPromptHydrated] = useState(false);
  const markPrimaryTemptationPromptDone = useCallback(() => {
    setPrimaryTemptationPromptState("done");
    AsyncStorage.setItem(STORAGE_KEYS.PRIMARY_TEMPTATION_PROMPT, "done").catch(() => {});
  }, []);
  const schedulePrimaryTemptationPrompt = useCallback(() => {
    setPrimaryTemptationPromptState("pending");
    setPrimaryTemptationPromptHydrated(true);
    setTemptationTutorialCompleted(false);
    setTemptationTutorialStatus("pending");
    setTemptationTutorialSeen(false);
    AsyncStorage.setItem(STORAGE_KEYS.PRIMARY_TEMPTATION_PROMPT, "pending").catch(() => {});
  }, []);
  const [northStarLogged, setNorthStarLogged] = useState(false);
  const [northStarHydrated, setNorthStarHydrated] = useState(false);
  const northStarLoggedRef = useRef(false);
  const [northStar2Logged, setNorthStar2Logged] = useState(false);
  const northStar2LoggedRef = useRef(false);
  const potentialOpenSnapshotRef = useRef(null);
  const potentialGrowthInitialCheckRef = useRef(false);
  const [potentialSnapshotHydrated, setPotentialSnapshotHydrated] = useState(false);
  const [potentialGrowthUSD, setPotentialGrowthUSD] = useState(0);
  const [potentialGrowthVisible, setPotentialGrowthVisible] = useState(false);
  const baselineMonthlyWasteUSD = Math.max(
    0,
    Number(profile?.spendingProfile?.baselineMonthlyWasteUSD) || 0
  );
  const baselineStartAt = profile?.spendingProfile?.baselineStartAt || null;
  const getPotentialSavedNow = useCallback(
    () => calcPotentialSaved(baselineMonthlyWasteUSD, baselineStartAt),
    [baselineMonthlyWasteUSD, baselineStartAt]
  );
  const profileJoinedAt = profile?.joinedAt || null;
  const dayMilestonesLoggedRef = useRef({ day2: false, day3: false });
  const retentionActiveDaysRef = useRef([]);
  const retentionMilestonesLoggedRef = useRef({});
  const [retentionAnalyticsHydrated, setRetentionAnalyticsHydrated] = useState(false);
  useEffect(() => {
    let cancelled = false;
    AsyncStorage.getItem(STORAGE_KEYS.LEVEL_REACHED_LOGGED)
      .then((value) => {
        if (cancelled) return;
        const parsed = Math.max(0, Number(value) || 0);
        levelReachedLoggedRef.current = parsed;
        setLevelReachedLoggedHydrated(true);
      })
      .catch(() => {
        if (cancelled) return;
        setLevelReachedLoggedHydrated(true);
      });
    return () => {
      cancelled = true;
    };
  }, []);
  useEffect(() => {
    let cancelled = false;
    AsyncStorage.multiGet([
      STORAGE_KEYS.DAY_TWO_ACTIVITY,
      STORAGE_KEYS.DAY_THREE_ACTIVITY,
      STORAGE_KEYS.RETENTION_ACTIVE_DAYS,
      STORAGE_KEYS.RETENTION_MILESTONES,
    ])
      .then((entries) => {
        if (cancelled || !Array.isArray(entries)) return;
        const logged = { ...dayMilestonesLoggedRef.current };
        let retentionDays = retentionActiveDaysRef.current;
        const retentionMilestones = { ...retentionMilestonesLoggedRef.current };
        entries.forEach(([key, value]) => {
          if (key === STORAGE_KEYS.DAY_TWO_ACTIVITY && value) {
            logged.day2 = true;
          }
          if (key === STORAGE_KEYS.DAY_THREE_ACTIVITY && value) {
            logged.day3 = true;
          }
          if (key === STORAGE_KEYS.RETENTION_ACTIVE_DAYS && value) {
            try {
              const parsed = JSON.parse(value);
              retentionDays = normalizeRetentionDayKeys(parsed);
            } catch {
              retentionDays = [];
            }
          }
          if (key === STORAGE_KEYS.RETENTION_MILESTONES && value) {
            try {
              const parsed = JSON.parse(value);
              normalizeRetentionMilestoneDays(parsed).forEach((day) => {
                retentionMilestones[day] = true;
              });
            } catch {
              // Ignore malformed legacy data.
            }
          }
        });
        if (logged.day2) {
          retentionMilestones[2] = true;
        }
        if (logged.day3) {
          retentionMilestones[3] = true;
        }
        dayMilestonesLoggedRef.current = logged;
        retentionActiveDaysRef.current = retentionDays;
        retentionMilestonesLoggedRef.current = retentionMilestones;
        setRetentionAnalyticsHydrated(true);
      })
      .catch(() => {
        if (cancelled) return;
        setRetentionAnalyticsHydrated(true);
      });
    return () => {
      cancelled = true;
    };
  }, []);
  useEffect(() => {
    reportsLastAutoWeekRef.current = reportsLastAutoWeekKey;
  }, [reportsLastAutoWeekKey]);
  const maybeLogDayMilestone = useCallback(
    (actionType) => {
      if (actionType !== "save" && actionType !== "spend") return;
      if (!profileJoinedAt) return;
      const joinedAtTimestamp = new Date(profileJoinedAt).getTime();
      if (!Number.isFinite(joinedAtTimestamp)) return;
      const ordinalDay = Math.floor((Date.now() - joinedAtTimestamp) / DAY_MS) + 1;
      if (ordinalDay === 2 && !dayMilestonesLoggedRef.current.day2) {
        dayMilestonesLoggedRef.current = { ...dayMilestonesLoggedRef.current, day2: true };
        AsyncStorage.setItem(STORAGE_KEYS.DAY_TWO_ACTIVITY, "1").catch(() => {});
        logEvent("day_2");
      } else if (ordinalDay === 3 && !dayMilestonesLoggedRef.current.day3) {
        dayMilestonesLoggedRef.current = { ...dayMilestonesLoggedRef.current, day3: true };
        AsyncStorage.setItem(STORAGE_KEYS.DAY_THREE_ACTIVITY, "1").catch(() => {});
        logEvent("day_3");
      }
    },
    [profileJoinedAt, logEvent]
  );
  const potentialBaselineKey =
    baselineMonthlyWasteUSD > 0 && baselineStartAt
      ? `${baselineStartAt}:${baselineMonthlyWasteUSD}`
      : null;
  const dismissPotentialGrowth = useCallback(() => {
    setPotentialGrowthVisible(false);
  }, []);
  const storePotentialSnapshot = useCallback((valueUSD) => {
    const normalized = Number(valueUSD);
    if (!Number.isFinite(normalized)) return;
    potentialOpenSnapshotRef.current = normalized;
    AsyncStorage.setItem(STORAGE_KEYS.POTENTIAL_OPEN_SNAPSHOT, String(normalized)).catch(() => {});
  }, []);
  const maybeShowPotentialGrowth = useCallback(
    (currentUSD) => {
      const normalized = Number(currentUSD);
      if (!Number.isFinite(normalized)) return;
      if (!potentialBaselineKey) {
        storePotentialSnapshot(normalized);
        return;
      }
      const previous = Number(potentialOpenSnapshotRef.current);
      storePotentialSnapshot(normalized);
      if (!Number.isFinite(previous)) return;
      const delta = normalized - previous;
      if (delta <= 0.01) return;
      setPotentialGrowthUSD(delta);
      setPotentialGrowthVisible(true);
    },
    [potentialBaselineKey, storePotentialSnapshot]
  );
  const prevActiveTabRef = useRef(activeTab);
  useEffect(() => {
    if (prevActiveTabRef.current && prevActiveTabRef.current !== activeTab) {
      dismissPotentialGrowth();
    }
    if (activeTab === "feed" && prevActiveTabRef.current && prevActiveTabRef.current !== "feed") {
      triggerHomeSpeech("tab");
    }
    prevActiveTabRef.current = activeTab;
  }, [activeTab, dismissPotentialGrowth, triggerHomeSpeech]);
  const prevOnboardingStepRef = useRef(onboardingStep);
  useEffect(() => {
    if (prevOnboardingStepRef.current && prevOnboardingStepRef.current !== onboardingStep) {
      dismissPotentialGrowth();
    }
    prevOnboardingStepRef.current = onboardingStep;
  }, [dismissPotentialGrowth, onboardingStep]);
  const shouldPromptIncome = useMemo(() => {
    if (!incomeEntriesHydrated || !incomePromptHydrated || !profileHydrated) return false;
    if (onboardingStep !== "done") return false;
    if (fabTutorialState !== FAB_TUTORIAL_STATUS.DONE) return false;
    const monthKey = currentMonthKey || getMonthKey(Date.now());
    if (!monthKey) return false;
    if (incomePromptState?.lastPromptMonthKey === monthKey) return false;
    if (currentMonthRecurringIncomeUSD > 0) return false;
    const paydayRaw = Number(profile?.incomePayday);
    const payday =
      Number.isFinite(paydayRaw) && paydayRaw >= 1 && paydayRaw <= 31
        ? Math.round(paydayRaw)
        : DEFAULT_INCOME_PAYDAY;
    const today = new Date();
    const day = today.getDate();
    const daysInMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0).getDate();
    const effectivePayday = Math.min(payday, daysInMonth);
    const windowEnd = Math.min(effectivePayday + INCOME_PROMPT_GRACE_DAYS, daysInMonth);
    const withinWindow = day >= effectivePayday && day <= windowEnd;
    return (
      withinWindow || (!hasMonthlyIncomeEntries && !incomePromptState?.lastPromptMonthKey)
    );
  }, [
    currentMonthRecurringIncomeUSD,
    currentMonthKey,
    hasMonthlyIncomeEntries,
    incomeEntriesHydrated,
    incomePromptHydrated,
    incomePromptState?.lastPromptMonthKey,
    fabTutorialState,
    onboardingStep,
    profile?.incomePayday,
    profileHydrated,
  ]);
  useEffect(() => {
    if (!shouldPromptIncome) {
      if (incomePromptPending) {
        setIncomePromptPending(false);
      }
      return;
    }
    if (incomePromptPending || incomeEntryModalVisible) return;
    incomeEntrySourceRef.current = "monthly_prompt";
    incomeEntryModeRef.current = INCOME_ENTRY_TYPES.MONTHLY;
    setIncomeEntryInput({ amount: "" });
    setIncomePromptPending(true);
  }, [incomeEntryModalVisible, incomePromptPending, shouldPromptIncome]);
  useEffect(() => {
    if (!budgetOverspendHydrated || !savedTotalHydrated) return;
    if (!incomeEntriesHydrated || !historyHydrated) return;
    if (!currentMonthKey) return;
    const nextApplied = Math.max(0, currentMonthOverspendUSD || 0);
    const prevApplied = Math.max(0, Number(budgetOverspendMap?.[currentMonthKey]) || 0);
    const delta = nextApplied - prevApplied;
    if (Math.abs(delta) < 0.01) return;
    setSavedTotalUSD((prev) => Math.max(0, prev - delta));
    setProgressSavedTotalUSD((prev) => Math.max(0, prev - delta));
    setBudgetOverspendMap((prev) => ({
      ...(prev || {}),
      [currentMonthKey]: nextApplied,
    }));
  }, [
    budgetOverspendHydrated,
    budgetOverspendMap,
    currentMonthKey,
    currentMonthOverspendUSD,
    historyHydrated,
    incomeEntriesHydrated,
    savedTotalHydrated,
    setBudgetOverspendMap,
    setProgressSavedTotalUSD,
    setSavedTotalUSD,
  ]);
  useEffect(() => {
    let cancelled = false;
    AsyncStorage.getItem(STORAGE_KEYS.POTENTIAL_OPEN_SNAPSHOT)
      .then((value) => {
        if (cancelled) return;
        if (typeof value === "string" && value.length > 0) {
          const parsed = Number(value);
          if (Number.isFinite(parsed)) {
            potentialOpenSnapshotRef.current = parsed;
          }
        }
        setPotentialSnapshotHydrated(true);
      })
      .catch(() => {
        setPotentialSnapshotHydrated(true);
      });
    return () => {
      cancelled = true;
    };
  }, []);
  useEffect(() => {
    if (!potentialSnapshotHydrated) return;
    const normalized = Number(getPotentialSavedNow());
    if (!Number.isFinite(normalized)) return;
    if (Number.isFinite(potentialOpenSnapshotRef.current)) return;
    storePotentialSnapshot(normalized);
  }, [getPotentialSavedNow, potentialSnapshotHydrated, storePotentialSnapshot]);
  const [language, setLanguage] = useState(DEFAULT_LANGUAGE);
  const [languageHydrated, setLanguageHydrated] = useState(false);
  const normalizedLanguageValue = normalizeLanguage(language);
  const isRomanceLocale = normalizedLanguageValue === "es" || normalizedLanguageValue === "fr";
  const isCompactAndroid = IS_ANDROID_COMPACT;
  const baseTabFontSize = Platform.OS === "ios" ? 11 : isCompactAndroid ? 10 : 12;
  const tabLabelFontSize = Math.max(10, isRomanceLocale ? baseTabFontSize - 1 : baseTabFontSize);
  const tabOrder = ["feed", "cart", "pending", "purchases", "profile"];
  const [homeLayoutReady, setHomeLayoutReady] = useState(false);
  const [startupHydrated, setStartupHydrated] = useState(false);
  const fontsReady = fontsLoaded || Boolean(fontsError);
  const startupLogoReady = fontsReady && startupHydrated;
  useEffect(() => {
    if (potentialGrowthInitialCheckRef.current) return;
    if (!startupHydrated) return;
    if (!potentialSnapshotHydrated) return;
    const normalized = Number(getPotentialSavedNow());
    if (!Number.isFinite(normalized)) return;
    potentialGrowthInitialCheckRef.current = true;
    maybeShowPotentialGrowth(normalized);
  }, [getPotentialSavedNow, maybeShowPotentialGrowth, potentialSnapshotHydrated, startupHydrated]);
  const primaryTemptationId = profile.customSpend?.id || "custom_habit";
  const primaryTemptationDescription = useMemo(() => {
    const gender = profile?.gender || "none";
    const description = buildCustomTemptationDescription(gender);
    return description?.[language] || description?.en || "";
  }, [language, profile?.gender]);
  const [activeGoalId, setActiveGoalId] = useState(null);
  const [activeGoalHydrated, setActiveGoalHydrated] = useState(false);
  const [profileEditMode, setProfileEditMode] = useState("none");
  const [theme, setTheme] = useState(DEFAULT_THEME);
  const [themeHydrated, setThemeHydrated] = useState(false);
  const [proThemeAccentId, setProThemeAccentId] = useState(DEFAULT_PRO_THEME_ACCENT_ID);
  const [proThemeAccentHydrated, setProThemeAccentHydrated] = useState(false);
  const [proThemeAccentPickerVisible, setProThemeAccentPickerVisible] = useState(false);
  const isAndroid = Platform.OS === "android";
  const androidVersion = isAndroid ? Number(Platform.Version) : null;
  const canSetSystemBarColors =
    isAndroid && typeof androidVersion === "number" && !Number.isNaN(androidVersion) && androidVersion < 35;
  const canToggleNavVisibility =
    isAndroid && typeof androidVersion === "number" && !Number.isNaN(androidVersion) && androidVersion < 35;
  const resolveTemplateCard = useCallback(
    (templateId) => {
      if (!templateId) return null;
      const findInList = (list) => (list || []).find((card) => card?.id === templateId);
      return findInList(quickTemptations) || findInList(temptations) || findTemplateById(templateId) || null;
    },
    [quickTemptations, temptations]
  );
  const isTemplateReminderEligible = useCallback(
    (templateId) => {
      if (!templateId) return false;
      if (hiddenTemptationSet.has(templateId) || archivedTemptationSet.has(templateId)) {
        return false;
      }
      if (templateId === primaryTemptationId) return true;
      return Boolean(resolveTemplateCard(templateId));
    },
    [archivedTemptationSet, hiddenTemptationSet, primaryTemptationId, resolveTemplateCard]
  );
  const focusCandidateIds = useMemo(() => {
    const ids = new Set();
    [...quickTemptations, ...temptations].forEach((card) => {
      if (card?.id) ids.add(card.id);
    });
    if (primaryTemptationId) ids.add(primaryTemptationId);
    return ids;
  }, [primaryTemptationId, quickTemptations, temptations]);
  const isFocusCandidateInFeed = useCallback(
    (templateId) => {
      if (!templateId) return false;
      const normalized = typeof templateId === "string" ? templateId.trim() : templateId;
      if (!normalized) return false;
      return focusCandidateIds.has(normalized);
    },
    [focusCandidateIds]
  );
  const resolveTemplateTitle = useCallback(
    (templateId, fallback = null) => {
      if (!templateId) return fallback;
      const source = resolveTemplateCard(templateId);
      if (!source) return fallback;
      const overrideTitle =
        typeof titleOverrides?.[templateId] === "string" && titleOverrides[templateId].trim()
          ? titleOverrides[templateId].trim()
          : null;
      const rawTitle =
        overrideTitle ||
        source.titleOverride ||
        (typeof source.title === "string"
          ? source.title
          : source.title?.[language] || source.title?.en || source.title?.ru || source.title) ||
        fallback;
      const decorated = `${source.emoji || ""} ${rawTitle || ""}`.trim();
      return decorated || fallback;
    },
    [language, resolveTemplateCard, titleOverrides]
  );
  const [overlay, setOverlay] = useState(null);
  const [pendingGoalCelebration, setPendingGoalCelebration] = useState(null);
  const pendingUsageStreakRef = useRef(null);
  useEffect(() => {
    if (overlay?.type !== "streak_pledge_reward") return;
    if (!streakPledge.rewardPending) return;
    setStreakPledge((prev) => ({
      ...prev,
      rewardPending: false,
      rewardDeliveredAt: Date.now(),
    }));
    logEvent("streak_goal_reward_shown", {
      target_days: Math.max(0, Number(streakPledge.targetDays) || 0),
      reward_blue: Math.max(0, Number(streakPledge.rewardBlueCoins) || 0),
      reward_value: Math.max(0, Number(streakPledge.rewardValue) || 0),
    });
  }, [
    logEvent,
    overlay?.type,
    setStreakPledge,
    streakPledge.rewardBlueCoins,
    streakPledge.rewardPending,
    streakPledge.rewardValue,
    streakPledge.targetDays,
  ]);
  const [confettiKey, setConfettiKey] = useState(0);
  const overlayTimer = useRef(null);
  const overlayRetryTimerRef = useRef(null);
  const feedScreenRef = useRef(null);
  const savingsHeroRef = useRef(null);
  const scrollActiveTabToTop = useCallback(
    (tabKey, { animated = true } = {}) => {
      if (tabKey === "feed") {
        const scroller = feedScreenRef.current;
        if (scroller && typeof scroller.scrollToTop === "function") {
          return scroller.scrollToTop({ animated });
        }
        return false;
      }
      if (tabKey === "cart") {
        progressScrollRef.current?.scrollTo?.({ y: 0, animated });
        return true;
      }
      if (tabKey === "pending") {
        pendingScrollRef.current?.scrollTo?.({ y: 0, animated });
        return true;
      }
      if (tabKey === "purchases") {
        rewardsScrollRef.current?.scrollTo?.({ y: 0, animated });
        return true;
      }
      if (tabKey === "profile") {
        profileScrollRef.current?.scrollTo?.({ y: 0, animated });
        return true;
      }
      return false;
    },
    []
  );

  const overlayQueueRef = useRef([]);
  const overlayActiveRef = useRef(false);
  const lastOverlayDismissedAtRef = useRef(0);
  const lastSaveOverlayDismissedAtRef = useRef(0);
  const pendingLevelCelebrationRef = useRef(null);
  const levelCelebrationQueuedRef = useRef(0);
  const celebrationGapTimerRef = useRef(null);
  const celebrationQueueRef = useRef([]);
  const lastCelebrationAtRef = useRef(0);
  const queueCelebrationOverlayRef = useRef(null);
  const [dailySummaryVisible, setDailySummaryVisible] = useState(false);
  const [dailySummaryData, setDailySummaryData] = useState(null);
  const [dailySummarySeenKey, setDailySummarySeenKey] = useState(null);
  const [pendingDailySummaryData, setPendingDailySummaryData] = useState(null);
  const [dailySummaryHydrated, setDailySummaryHydrated] = useState(false);
  const [dailySummaryOpenToken, setDailySummaryOpenToken] = useState(0);
  const dailySummaryOpenProcessedRef = useRef(0);
  const pendingDailySummaryNotificationRef = useRef(null);
  const queuedModalQueueRef = useRef([]);
  const queuedModalActiveRef = useRef(null);
  const canShowQueuedModalRef = useRef(() => false);
  const tutorialBlockingVisibleRef = useRef(false);
  const [queuedModalType, setQueuedModalType] = useState(null);
  const [queuedModalProcessTick, setQueuedModalProcessTick] = useState(0);
  const markDailySummaryOpen = useCallback(() => {
    setDailySummaryOpenToken((prev) => prev + 1);
  }, []);
  const [focusTemplateId, setFocusTemplateId] = useState(null);
  const [focusStateHydrated, setFocusStateHydrated] = useState(false);
  const [focusDigestSeenKey, setFocusDigestSeenKey] = useState(null);
  const [focusDigestHydrated, setFocusDigestHydrated] = useState(false);
  const [pendingFocusDigest, setPendingFocusDigest] = useState(null);
  const [focusDigestPromptShown, setFocusDigestPromptShown] = useState(false);
  const [focusSaveCount, setFocusSaveCount] = useState(0);
  const [focusVictoryCount, setFocusVictoryCount] = useState(0);
  const [focusVictoryHydrated, setFocusVictoryHydrated] = useState(false);
  const appStateRef = useRef(AppState.currentState || "active");
  const suppressResumeOnceRef = useRef(false);
  const appResumeAtRef = useRef(null);
  const focusLossCountersRef = useRef({});
  const focusPromptActiveRef = useRef(false);
  const homeSessionRef = useRef({
    dateKey: getDayKey(Date.now()),
    sessionCount: 0,
    pendingIndex: null,
  });
  const isDailyChallengeDeferred = useMemo(() => {
    if (!dailyChallenge?.deferUntilKey) return false;
    const deferDate = parseDayKey(dailyChallenge.deferUntilKey);
    const todayDate = parseDayKey(todayKey || getDayKey(Date.now()));
    if (!deferDate || !todayDate) return false;
    return deferDate.getTime() > todayDate.getTime();
  }, [dailyChallenge?.deferUntilKey, todayKey]);
  const isDailyChallengePromptPending =
    dailyChallengeUnlocked &&
    dailyChallenge.status === DAILY_CHALLENGE_STATUS.OFFER &&
    !dailyChallenge.offerDismissed &&
    !isDailyChallengeDeferred;
  const isDailyChallengeCompletePending =
    dailyChallengeUnlocked &&
    dailyChallenge.status === DAILY_CHALLENGE_STATUS.COMPLETED &&
    !dailyChallenge.completionDismissed;
  const [dailyChallengePromptGate, setDailyChallengePromptGate] = useState(false);
  const dailyChallengePromptQueuedRef = useRef(false);
  const dailyChallengePendingRef = useRef(false);
  const dailyChallengeOfferDeferredRef = useRef(false);
  const dailyChallengePendingPrevRef = useRef(false);
  const dailyNudgeIdsRef = useRef({});
  const smartRemindersRef = useRef([]);
  const smartReminderScheduleTailRef = useRef(0);
  const requestQueuedModalProcess = useCallback(() => {
    setQueuedModalProcessTick((prev) => prev + 1);
  }, []);
  const enqueueQueuedModal = useCallback(
    (type) => {
      if (!type) return;
      if (queuedModalActiveRef.current === type) return;
      const queue = queuedModalQueueRef.current;
      if (queue.includes(type)) return;
      queue.push(type);
      requestQueuedModalProcess();
    },
    [requestQueuedModalProcess]
  );
  const refreshQueuedModalsOnResume = useCallback(() => {
    if (dailySummaryUnlocked && pendingDailySummaryData) {
      enqueueQueuedModal(QUEUED_MODAL_TYPES.DAILY_SUMMARY);
    }
    if (dailyChallengePromptAllowed && isDailyChallengePromptPending) {
      dailyChallengeOfferDeferredRef.current = false;
      setDailyChallengePromptGate(true);
      enqueueQueuedModal(QUEUED_MODAL_TYPES.DAILY_CHALLENGE);
    }
    if (dailyChallengePromptAllowed && isDailyChallengeCompletePending) {
      enqueueQueuedModal(QUEUED_MODAL_TYPES.DAILY_CHALLENGE_COMPLETE);
    }
    if (focusModeUnlocked && pendingFocusDigest && !focusDigestPromptShown) {
      enqueueQueuedModal(QUEUED_MODAL_TYPES.FOCUS_DIGEST);
    }
    if (
      fabTutorialState === FAB_TUTORIAL_STATUS.SHOWING &&
      onboardingStep === "done" &&
      tutorialSeen &&
      homeLayoutReady &&
      !startupLogoVisible &&
      !fabTutorialBlocked &&
      activeTab === "feed"
    ) {
      enqueueQueuedModal(QUEUED_MODAL_TYPES.FAB_TUTORIAL);
    }
    if (incomePromptPending) {
      enqueueQueuedModal(QUEUED_MODAL_TYPES.INCOME_PROMPT);
    }
    requestQueuedModalProcess();
  }, [
    activeTab,
    dailyChallengePromptAllowed,
    dailySummaryUnlocked,
    enqueueQueuedModal,
    fabTutorialBlocked,
    fabTutorialState,
    focusDigestPromptShown,
    focusModeUnlocked,
    homeLayoutReady,
    incomePromptPending,
    isDailyChallengePromptPending,
    isDailyChallengeCompletePending,
    onboardingStep,
    pendingDailySummaryData,
    pendingFocusDigest,
    requestQueuedModalProcess,
    startupLogoVisible,
    tutorialSeen,
  ]);
  const clearQueuedModal = useCallback(
    (type) => {
      if (queuedModalActiveRef.current !== type) return;
      queuedModalActiveRef.current = null;
      setQueuedModalType(null);
      requestQueuedModalProcess();
    },
    [requestQueuedModalProcess]
  );
  useEffect(() => {
    if (!incomePromptPending) return;
    enqueueQueuedModal(QUEUED_MODAL_TYPES.INCOME_PROMPT);
  }, [enqueueQueuedModal, incomePromptPending]);
  useEffect(() => {
    if (queuedModalType !== QUEUED_MODAL_TYPES.INCOME_PROMPT) return;
    if (!incomePromptPending || !shouldPromptIncome) {
      clearQueuedModal(QUEUED_MODAL_TYPES.INCOME_PROMPT);
      return;
    }
    incomeEntrySourceRef.current = "monthly_prompt";
    incomeEntryModeRef.current = INCOME_ENTRY_TYPES.MONTHLY;
    setIncomeEntryModalVisible(true);
  }, [clearQueuedModal, incomePromptPending, queuedModalType, shouldPromptIncome]);
  const handleDailySummaryContinue = useCallback(() => {
    setDailySummaryVisible(false);
    clearQueuedModal(QUEUED_MODAL_TYPES.DAILY_SUMMARY);
    const todayKey = dailySummaryData?.todayKey || getDayKey(Date.now());
    if (!todayKey) return;
    setDailySummarySeenKey(todayKey);
    AsyncStorage.setItem(STORAGE_KEYS.DAILY_SUMMARY, todayKey).catch(() => {});
  }, [clearQueuedModal, dailySummaryData]);
  const [tutorialSeen, setTutorialSeen] = useState(false);
  const [tutorialHydrated, setTutorialHydrated] = useState(false);
  const [tutorialVisible, setTutorialVisible] = useState(false);
  const [tutorialStepIndex, setTutorialStepIndex] = useState(0);
  const tutorialCardEntrance = useRef(new Animated.Value(0)).current;
  const tutorialAmbientMotion = useRef(new Animated.Value(0)).current;
  const tutorialPulseMotion = useRef(new Animated.Value(0)).current;
  const [budgetWidgetTutorialSeen, setBudgetWidgetTutorialSeen] = useState(false);
  const [budgetWidgetTutorialHydrated, setBudgetWidgetTutorialHydrated] = useState(false);
  const [budgetWidgetTutorialVisible, setBudgetWidgetTutorialVisible] = useState(false);
  const [temptationTutorialSeen, setTemptationTutorialSeen] = useState(false);
  const [temptationTutorialVisible, setTemptationTutorialVisible] = useState(false);
  const [temptationTutorialStepIndex, setTemptationTutorialStepIndex] = useState(0);
  const [temptationTutorialHydrated, setTemptationTutorialHydrated] = useState(false);
  const [temptationTutorialStatus, setTemptationTutorialStatus] = useState("pending");
  const [temptationTutorialQueued, setTemptationTutorialQueued] = useState(false);
  const [temptationTutorialCompleted, setTemptationTutorialCompleted] = useState(false);
  const tutorialVisiblePrevRef = useRef(false);
  const budgetWidgetTutorialTimerRef = useRef(null);
  const availableTabs = useMemo(() => {
    if (!tutorialVisible) return tabOrder;
    return tabOrder.filter((tab) => {
      if (tab === "pending" && !thinkingUnlocked) return false;
      if (tab === "purchases" && !rewardsUnlocked) return false;
      return true;
    });
  }, [rewardsUnlocked, tabOrder, thinkingUnlocked, tutorialVisible]);
  useEffect(() => {
    if (availableTabs.includes(activeTab)) return;
    if (availableTabs.length) {
      setActiveTabState(availableTabs[0]);
    }
  }, [activeTab, availableTabs]);
  const [tutorialHighlightRect, setTutorialHighlightRect] = useState(null);
  const [tutorialHighlightMeasureTick, setTutorialHighlightMeasureTick] = useState(0);
  const tutorialHighlightMeasureTimerRef = useRef(null);
  const tutorialHighlightAdjustCountRef = useRef(0);
  const tutorialHighlightAlignAttemptsRef = useRef(0);
  const [ratingPromptState, setRatingPromptState] = useState(() => createInitialRatingPromptState());
  const [ratingPromptHydrated, setRatingPromptHydrated] = useState(false);
  const [ratingPromptVisible, setRatingPromptVisible] = useState(false);
  const ratingPromptCompleted =
    ratingPromptState.completed || ratingPromptState.lastAction === "rate";
  const ratingPromptFirstOpenAt = ratingPromptState.firstOpenAt;
  const ratingPromptActionBase = ratingPromptState.actionCountStart;
  const ratingPromptActionCount = Math.max(
    0,
    (Number(ratingPromptState.actionCount) || 0) -
      (Number.isFinite(ratingPromptActionBase) ? ratingPromptActionBase : 0)
  );
  const ratingPromptActionPrompted = ratingPromptState.actionPrompted;
  const ratingPromptLastAction = ratingPromptState.lastAction;
  const ratingPromptRespondedAt = ratingPromptState.respondedAt;
  const ratingPromptCatFloat = useRef(new Animated.Value(0)).current;
  const ratingPromptCatBob = ratingPromptCatFloat.interpolate({
    inputRange: [0, 1],
    outputRange: [0, -8],
  });
  useEffect(() => {
    if (!ratingPromptVisible) {
      ratingPromptCatFloat.setValue(0);
      return;
    }
    const loop = Animated.loop(
      Animated.sequence([
        Animated.timing(ratingPromptCatFloat, {
          toValue: 1,
          duration: 900,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(ratingPromptCatFloat, {
          toValue: 0,
          duration: 900,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    loop.start();
    return () => loop.stop();
  }, [ratingPromptCatFloat, ratingPromptVisible]);
  const [levelShareModal, setLevelShareModal] = useState({ visible: false, level: 1 });
  const [levelShareSharing, setLevelShareSharing] = useState(false);
  const levelShareCardRef = useRef(null);
  const [tabBarHeight, setTabBarHeight] = useState(0);
  const [fabTutorialState, setFabTutorialState] = useState(FAB_TUTORIAL_STATUS.DONE);
  const [fabTutorialVisible, setFabTutorialVisible] = useState(false);
  const fabTutorialStateRef = useRef(FAB_TUTORIAL_STATUS.DONE);
  const fabTutorialLoggedRef = useRef(false);
  const fabButtonWrapperRef = useRef(null);
  const [fabTutorialAnchor, setFabTutorialAnchor] = useState(null);
  const [savingsHeroAnchor, setSavingsHeroAnchor] = useState(null);
  const [fabTutorialEligible, setFabTutorialEligible] = useState(false);
  useEffect(() => {
    if (!appTutorialSteps.length) {
      setTutorialStepIndex(0);
      return;
    }
    if (tutorialStepIndex >= appTutorialSteps.length) {
      setTutorialStepIndex(appTutorialSteps.length - 1);
    }
  }, [appTutorialSteps.length, tutorialStepIndex]);
  const finishTutorial = useCallback(() => {
    setTutorialVisible(false);
    setTutorialSeen(true);
    setHomeLayoutReady(true);
    setTutorialStepIndex(0);
    setTemptationTutorialSeen(false);
    setTemptationTutorialStatus("pending");
    setTemptationTutorialStepIndex(0);
    setTemptationTutorialQueued(true);
    setTemptationTutorialCompleted(false);
    AsyncStorage.setItem(STORAGE_KEYS.TEMPTATION_TUTORIAL, "pending").catch(() => {});
    AsyncStorage.setItem(STORAGE_KEYS.TUTORIAL, "done").catch(() => {});
  }, [setHomeLayoutReady]);
  const handleTutorialNext = useCallback(() => {
    if (appTutorialSteps.length === 0) {
      finishTutorial();
      return;
    }
    if (tutorialStepIndex < appTutorialSteps.length - 1) {
      setTutorialStepIndex((prev) =>
        Math.min(prev + 1, Math.max(appTutorialSteps.length - 1, 0))
      );
      return;
    }
    finishTutorial();
  }, [appTutorialSteps.length, finishTutorial, tutorialStepIndex]);
  const handleTutorialSkip = useCallback(() => {
    finishTutorial();
  }, [finishTutorial]);
  const finishTemptationTutorial = useCallback(() => {
    setTemptationTutorialVisible(false);
    setTemptationTutorialSeen(true);
    setTemptationTutorialStatus("done");
    setTemptationTutorialStepIndex(0);
    setTemptationTutorialQueued(false);
    setTemptationTutorialCompleted(true);
    AsyncStorage.setItem(STORAGE_KEYS.TEMPTATION_TUTORIAL, "done").catch(() => {});
  }, []);
  const handleTemptationTutorialNext = useCallback(() => {
    if (temptationTutorialStepIndex < TEMPTATION_TUTORIAL_STEPS.length - 1) {
      setTemptationTutorialStepIndex((prev) =>
        Math.min(prev + 1, TEMPTATION_TUTORIAL_STEPS.length - 1)
      );
      return;
    }
    finishTemptationTutorial();
  }, [temptationTutorialStepIndex, finishTemptationTutorial]);
  const handleTemptationTutorialSkip = useCallback(() => {
    finishTemptationTutorial();
  }, [finishTemptationTutorial]);
  const dismissBudgetWidgetTutorial = useCallback(
    (source = "dismiss") => {
      setBudgetWidgetTutorialVisible(false);
      if (!budgetWidgetTutorialSeen) {
        setBudgetWidgetTutorialSeen(true);
        AsyncStorage.setItem(STORAGE_KEYS.BUDGET_WIDGET_TUTORIAL, "done").catch(() => {});
      }
      logEvent("budget_widget_tutorial_dismissed", { source });
    },
    [budgetWidgetTutorialSeen, logEvent]
  );
  useEffect(() => {
    if (!tutorialSeen) return;
    AsyncStorage.setItem(STORAGE_KEYS.TUTORIAL, "done").catch(() => {});
  }, [tutorialSeen]);
  useEffect(() => {
    const wasVisible = tutorialVisiblePrevRef.current;
    if (
      wasVisible &&
      !tutorialVisible &&
      tutorialSeen &&
      temptationTutorialHydrated &&
      temptationTutorialStatus === "pending"
    ) {
      setTemptationTutorialQueued(true);
    }
    tutorialVisiblePrevRef.current = tutorialVisible;
  }, [
    temptationTutorialHydrated,
    temptationTutorialStatus,
    tutorialSeen,
    tutorialVisible,
  ]);
  const handleTutorialHighlightLayoutChange = useCallback((rect) => {
    setTutorialHighlightRect(rect);
  }, []);
  const scheduleTutorialHighlightMeasure = useCallback((delay = 0) => {
    if (tutorialHighlightMeasureTimerRef.current) {
      clearTimeout(tutorialHighlightMeasureTimerRef.current);
    }
    tutorialHighlightMeasureTimerRef.current = setTimeout(() => {
      setTutorialHighlightMeasureTick((prev) => prev + 1);
    }, Math.max(0, delay));
  }, []);
  useEffect(() => {
    return () => {
      if (tutorialHighlightMeasureTimerRef.current) {
        clearTimeout(tutorialHighlightMeasureTimerRef.current);
      }
    };
  }, []);
  useEffect(() => {
    return () => {
      if (budgetWidgetTutorialTimerRef.current) {
        clearTimeout(budgetWidgetTutorialTimerRef.current);
        budgetWidgetTutorialTimerRef.current = null;
      }
    };
  }, []);
  const tutorialScrollExtraRef = useRef(0);
  const updateFabAnchor = useCallback(() => {
    const node = fabButtonWrapperRef.current;
    if (!node || typeof node.measureInWindow !== "function") return;
    node.measureInWindow((x, y, width, height) => {
      const centerX = x + width / 2;
      const androidStatusBarOffset = Platform.OS === "android" ? RNStatusBar.currentHeight || 0 : 0;
      const centerY = y + height / 2 + androidStatusBarOffset;
      setFabTutorialAnchor((prev) => {
        if (prev && Math.abs(prev.x - centerX) < 0.5 && Math.abs(prev.y - centerY) < 0.5) {
          return prev;
        }
        return { x: centerX, y: centerY };
      });
    });
  }, []);
  const handleSavingsHeroAnchor = useCallback((next) => {
    if (!next) return;
    setSavingsHeroAnchor((prev) => {
      if (
        prev &&
        Math.abs(prev.x - next.x) < 0.5 &&
        Math.abs(prev.y - next.y) < 0.5 &&
        Math.abs((prev.width || 0) - (next.width || 0)) < 0.5 &&
        Math.abs((prev.height || 0) - (next.height || 0)) < 0.5
      ) {
        return prev;
      }
      return next;
    });
  }, []);
  const handleFabWrapperLayout = useCallback(() => {
    updateFabAnchor();
  }, [updateFabAnchor]);
  const handleTabBarLayout = useCallback((event) => {
    const height = event?.nativeEvent?.layout?.height;
    if (!height || height <= 0) return;
    setTabBarHeight((prev) => (Math.abs(prev - height) < 1 ? prev : height));
  }, []);
  const handleHomeLayout = useCallback(() => {
    setHomeLayoutReady((ready) => (ready ? ready : true));
  }, []);
  const setFabTutorialStateAndPersist = useCallback((nextState) => {
    fabTutorialStateRef.current = nextState;
    setFabTutorialState(nextState);
    AsyncStorage.setItem(STORAGE_KEYS.FAB_TUTORIAL, nextState).catch(() => {});
  }, []);
  const handleFabTutorialDismiss = useCallback(
    (source = "dismiss") => {
      if (fabTutorialStateRef.current !== FAB_TUTORIAL_STATUS.SHOWING) {
        setFabTutorialVisible(false);
        return;
      }
      setFabTutorialVisible(false);
      clearQueuedModal(QUEUED_MODAL_TYPES.FAB_TUTORIAL);
      setFabTutorialStateAndPersist(FAB_TUTORIAL_STATUS.DONE);
      logEvent("fab_tutorial_completed", { source });
    },
    [clearQueuedModal, logEvent, setFabTutorialStateAndPersist]
  );
  const updateRatingPromptState = useCallback((updater) => {
    setRatingPromptState((prev) => {
      const nextState = typeof updater === "function" ? updater(prev) : updater;
      AsyncStorage.setItem(STORAGE_KEYS.RATING_PROMPT, JSON.stringify(nextState)).catch(() => {});
      return nextState;
    });
  }, []);
  const ratingPromptQueuedRef = useRef(false);
  const ratingPromptSourceRef = useRef(null);
  const ratingPromptCheckTimerRef = useRef(null);
  const storeReviewQueuedRef = useRef(false);
  const storeReviewCheckTimerRef = useRef(null);
  const canShowRatingPromptNowRef = useRef(() => false);
  const canTriggerStoreReviewNowRef = useRef(() => false);
  const showRatingPrompt = useCallback(
    (source = "time") => {
      if (ratingPromptVisible) return;
      setRatingPromptVisible(true);
      updateRatingPromptState((prev) => ({
        ...prev,
        lastShownAt: new Date().toISOString(),
        actionPrompted: source === "actions" ? true : prev.actionPrompted,
      }));
    },
    [ratingPromptVisible, updateRatingPromptState]
  );
  const queueRatingPrompt = useCallback(
    (source = "time") => {
      if (ratingPromptQueuedRef.current) {
        if (!ratingPromptSourceRef.current || source === "actions") {
          ratingPromptSourceRef.current = source;
        }
        return;
      }
      ratingPromptQueuedRef.current = true;
      ratingPromptSourceRef.current = source;
      const checkAndShow = () => {
        if (!ratingPromptQueuedRef.current) return;
        if (canShowRatingPromptNowRef.current()) {
          ratingPromptQueuedRef.current = false;
          const resolvedSource = ratingPromptSourceRef.current || source;
          ratingPromptSourceRef.current = null;
          showRatingPrompt(resolvedSource);
          return;
        }
        ratingPromptCheckTimerRef.current = setTimeout(checkAndShow, 250);
      };
      checkAndShow();
    },
    [showRatingPrompt]
  );
  useEffect(() => {
    return () => {
      if (ratingPromptCheckTimerRef.current) {
        clearTimeout(ratingPromptCheckTimerRef.current);
        ratingPromptCheckTimerRef.current = null;
      }
      if (storeReviewCheckTimerRef.current) {
        clearTimeout(storeReviewCheckTimerRef.current);
        storeReviewCheckTimerRef.current = null;
      }
    };
  }, []);
  const triggerStoreReview = useCallback(async (source = "rating_prompt") => {
    const isAndroid = Platform.OS === "android";
    const primaryUrl = isAndroid ? ANDROID_REVIEW_URL : IOS_REVIEW_URL;
    const fallbackUrl = isAndroid ? ANDROID_REVIEW_WEB_URL : IOS_REVIEW_WEB_URL;
    const openStoreReview = async () => {
      if (!primaryUrl && !fallbackUrl) return;
      try {
        if (primaryUrl) {
          const canOpen = await Linking.canOpenURL(primaryUrl);
          if (canOpen) {
            logEvent("store_review_redirect", {
              source,
              platform: isAndroid ? "android" : "ios",
              method: "native",
            });
            if (source === "rating_prompt" || source === "rating_prompt_modal") {
              logEvent("rating_prompt_store_redirect", {
                platform: isAndroid ? "android" : "ios",
                method: "native",
              });
            }
            await Linking.openURL(primaryUrl);
            return;
          }
        }
      } catch (error) {
        console.warn(`${isAndroid ? "android" : "ios"} review intent`, error);
      }
      if (fallbackUrl) {
        logEvent("store_review_redirect", {
          source,
          platform: isAndroid ? "android" : "ios",
          method: "web",
        });
        if (source === "rating_prompt" || source === "rating_prompt_modal") {
          logEvent("rating_prompt_store_redirect", {
            platform: isAndroid ? "android" : "ios",
            method: "web",
          });
        }
        Linking.openURL(fallbackUrl).catch(() => {});
      }
    };
    try {
      if (StoreReview && typeof StoreReview.isAvailableAsync === "function") {
        const available = await StoreReview.isAvailableAsync();
        if (available && typeof StoreReview.requestReview === "function") {
          // Play review can silently no-op; fallback to the store link if it returns too quickly.
          const startedAt = Date.now();
          logEvent("store_review_prompt_requested", {
            source,
            platform: isAndroid ? "android" : "ios",
          });
          await StoreReview.requestReview();
          const elapsedMs = Date.now() - startedAt;
          if (!isAndroid || elapsedMs > 1200) {
            return;
          }
        }
      }
    } catch (error) {
      console.warn("store review prompt", error);
    }
    return openStoreReview();
  }, [logEvent]);
  const requestStoreReviewWhenReady = useCallback(
    (source = "rating_prompt") => {
      if (storeReviewQueuedRef.current) return;
      storeReviewQueuedRef.current = true;
      const checkAndRun = () => {
        if (!storeReviewQueuedRef.current) return;
        if (canTriggerStoreReviewNowRef.current()) {
          storeReviewQueuedRef.current = false;
          InteractionManager.runAfterInteractions(() => {
            triggerStoreReview(source);
          });
          return;
        }
        storeReviewCheckTimerRef.current = setTimeout(checkAndRun, 250);
      };
      checkAndRun();
    },
    [triggerStoreReview]
  );
  const handleRatingPromptLater = useCallback(() => {
    setRatingPromptVisible(false);
    const respondedAt = new Date().toISOString();
    updateRatingPromptState((prev) => ({
      ...prev,
      completed: prev.completed,
      lastAction: "later",
      respondedAt,
    }));
    logEvent("rating_prompt_action", { action: "later" });
  }, [logEvent, updateRatingPromptState]);
  const handleRatingPromptConfirm = useCallback(() => {
    setRatingPromptVisible(false);
    const respondedAt = new Date().toISOString();
    updateRatingPromptState((prev) => ({
      ...prev,
      completed: true,
      lastAction: "rate",
      respondedAt,
    }));
    logEvent("rating_prompt_action", { action: "rate" });
    requestStoreReviewWhenReady("rating_prompt_modal");
  }, [logEvent, requestStoreReviewWhenReady, updateRatingPromptState]);
  const openLevelShareModal = useCallback(
    (level = 1) => {
      setLevelShareModal({ visible: true, level });
      logEvent("level_share_opened", { level });
    },
    [logEvent]
  );
  const closeLevelShareModal = useCallback(() => {
    setLevelShareModal((prev) => ({ ...prev, visible: false }));
  }, []);
  const handleLevelSharePress = useCallback(
    (level) => {
      dismissOverlay();
      openLevelShareModal(level);
    },
    [dismissOverlay, openLevelShareModal]
  );
  const handleLevelShareConfirm = useCallback(async () => {
    if (!levelShareCardRef.current || levelShareSharing) return;
    let cleanupUri = null;
    try {
      setLevelShareSharing(true);
      await new Promise((resolve) => requestAnimationFrame(resolve));
      let sharingAvailable = false;
      if (Sharing && typeof Sharing.isAvailableAsync === "function" && typeof Sharing.shareAsync === "function") {
        try {
          sharingAvailable = await Sharing.isAvailableAsync();
        } catch (availabilityError) {
          console.warn("sharing availability", availabilityError);
          sharingAvailable = false;
        }
      }
      const captureOptions = sharingAvailable
        ? { format: "png", quality: 0.96, result: "tmpfile" }
        : { format: "png", quality: 0.96, result: "base64" };
      const captureResult = await captureViewShotRef(levelShareCardRef, captureOptions);
      if (!captureResult) {
        throw new Error("capture_failed");
      }
      let normalizedUri = captureResult;
      if (captureOptions.result === "base64") {
        const baseDir = FileSystem.cacheDirectory || FileSystem.documentDirectory || "";
        const targetUri = `${baseDir}almost-level-share-${Date.now()}.png`;
        await FileSystem.writeAsStringAsync(targetUri, captureResult, {
          encoding: FileSystem.EncodingType.Base64,
        });
        normalizedUri = targetUri.startsWith("file://") ? targetUri : `file://${targetUri}`;
      } else if (!normalizedUri.startsWith("file://")) {
        normalizedUri = `file://${normalizedUri}`;
      }
      cleanupUri = normalizedUri;
      const shareTitle = `${t("levelShareModalTitle")} Â· ${t("levelShareFooterBrand")}`;
      const message = t("levelShareShareMessage", { level: levelShareModal.level });
      let sharedSuccessfully = false;
      if (sharingAvailable) {
        try {
          await Sharing.shareAsync(normalizedUri, {
            dialogTitle: shareTitle,
            mimeType: "image/png",
            UTI: "public.png",
          });
          sharedSuccessfully = true;
        } catch (sharingError) {
          console.warn("expo sharing failed", sharingError);
        }
      }
      if (!sharedSuccessfully) {
        if (Platform.OS === "ios" && ActionSheetIOS && typeof ActionSheetIOS.showShareActionSheetWithOptions === "function") {
          await new Promise((resolve, reject) => {
            ActionSheetIOS.showShareActionSheetWithOptions(
              {
                url: normalizedUri,
                subject: shareTitle,
              },
              (error) => {
                if (error) {
                  reject(error);
                } else {
                  resolve();
                }
              },
              () => resolve()
            );
          });
        } else {
          let fallbackUri = normalizedUri;
          if (Platform.OS === "android" && typeof FileSystem.getContentUriAsync === "function") {
            fallbackUri = await FileSystem.getContentUriAsync(normalizedUri);
          }
          await Share.share({
            url: fallbackUri,
            message,
            subject: Platform.OS === "ios" ? shareTitle : undefined,
          });
        }
      }
      logEvent("level_share_sent", { level: levelShareModal.level });
      closeLevelShareModal();
    } catch (error) {
      console.warn("level share", error);
      Alert.alert(t("levelShareModalTitle"), t("levelShareError") || "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹ Ð¿Ð¾Ð·Ð¶Ðµ.");
    } finally {
      if (cleanupUri) {
        setTimeout(() => {
          FileSystem.deleteAsync(cleanupUri, { idempotent: true }).catch(() => {});
        }, 3500);
      }
      setLevelShareSharing(false);
    }
  }, [closeLevelShareModal, levelShareModal.level, levelShareSharing, logEvent, t]);
  const clearCompletedPrimaryGoal = useCallback(
    (goalId) => {
      if (!goalId) return;
      setWishes((prev) =>
        prev.filter(
          (w) => !(w.kind === PRIMARY_GOAL_KIND && (w.goalId || w.id) === goalId && w.status === "done")
        )
      );
    },
    [setWishes]
  );
  const ensureActiveGoalForNewWish = useCallback(
    (newWish) => {
      if (!newWish) return;
      const shouldActivate =
        !mainGoalWish ||
        !profile.goal ||
        mainGoalWish.status === "done" ||
        profile.goalCelebrated;
      if (!shouldActivate) return;
      const targetUSD =
        Number.isFinite(newWish.targetUSD) && newWish.targetUSD > 0
          ? newWish.targetUSD
          : getGoalDefaultTargetUSD(newWish.goalId || newWish.id);
      const previousGoalId = activeGoalId || profile.goal;
      clearCompletedPrimaryGoal(previousGoalId);
      setActiveGoalId(newWish.id);
      const newPrimaryEntry = {
        id: newWish.id,
        targetUSD,
        savedUSD: Math.max(0, Number(newWish.savedUSD) || 0),
        status: newWish.status || "active",
        createdAt: newWish.createdAt || Date.now(),
        customTitle: getWishTitleWithoutEmoji(newWish) || newWish.title || "",
        customEmoji: normalizeEmojiValue(newWish.emoji, DEFAULT_GOAL_EMOJI),
      };
      const mergePrimaryGoals = (prevGoals = []) => {
        const dedup = new Map();
        const list = Array.isArray(prevGoals) ? prevGoals : [];
        list.forEach((entry) => {
          if (!entry?.id) return;
          if (dedup.has(entry.id)) return;
          dedup.set(entry.id, { ...entry });
        });
        dedup.set(newPrimaryEntry.id, {
          ...newPrimaryEntry,
          ...(dedup.get(newPrimaryEntry.id) || {}),
        });
        return Array.from(dedup.values());
      };
      setProfile((prev) => ({
        ...prev,
        primaryGoals: mergePrimaryGoals(prev.primaryGoals),
        goal: newWish.id,
        goalTargetUSD: targetUSD,
        goalCelebrated: false,
        goalRenewalPending: false,
      }));
      setProfileDraft((prev) => ({
        ...prev,
        primaryGoals: mergePrimaryGoals(prev.primaryGoals),
        goal: newWish.id,
        goalTargetUSD: targetUSD,
        goalCelebrated: false,
        goalRenewalPending: false,
      }));
      ensurePrimaryGoalWish(mergePrimaryGoals(profile.primaryGoals), language, newWish.id);
      dismissGoalRenewalPrompt();
    },
    [
      activeGoalId,
      clearCompletedPrimaryGoal,
      dismissGoalRenewalPrompt,
      mainGoalWish?.status,
      profile.goal,
      profile.goalCelebrated,
      profile.primaryGoals,
      ensurePrimaryGoalWish,
      language,
    ]
  );
  const ensureGoalManualTracking = useCallback((wishId) => {
    if (!wishId) return;
    setWishes((prev) => {
      let changed = false;
      const next = prev.map((wish) => {
        if (wish.id === wishId && wish.autoManaged !== false) {
          changed = true;
          return { ...wish, autoManaged: false };
        }
        return wish;
      });
      return changed ? next : prev;
    });
  }, []);
  const [mascotOverride, setMascotOverride] = useState(null);
  const mascotQueueRef = useRef([]);
  const mascotBusyRef = useRef(false);
  const [tamagotchiState, setTamagotchiState] = useState({ ...TAMAGOTCHI_START_STATE });
  const [tamagotchiGreetingDayKey, setTamagotchiGreetingDayKey] = useState(null);
  const [tamagotchiGreetingDayHydrated, setTamagotchiGreetingDayHydrated] = useState(false);
  const [tamagotchiVisible, setTamagotchiVisible] = useState(false);
  const [tamagotchiActiveTab, setTamagotchiActiveTab] = useState("food");
  const [tamagotchiSkinId, setTamagotchiSkinId] = useState(DEFAULT_TAMAGOTCHI_SKIN);
  const [tamagotchiSkinHydrated, setTamagotchiSkinHydrated] = useState(false);
  const [skinPickerVisible, setSkinPickerVisible] = useState(false);
  const [tamagotchiSelectedCleanToolId, setTamagotchiSelectedCleanToolId] = useState(
    TAMAGOTCHI_DEFAULT_CLEAN_TOOL_ID
  );
  const [tamagotchiCleaningProgress, setTamagotchiCleaningProgress] = useState(
    createTamagotchiCleaningProgress
  );
  const [tamagotchiToyFlightId, setTamagotchiToyFlightId] = useState(null);
  const tamagotchiToyFlightAnim = useRef(new Animated.Value(0)).current;
  const tamagotchiToyFlightTimerRef = useRef(null);
  const tamagotchiHeartBurstAnim = useRef(new Animated.Value(0)).current;
  const tamagotchiCleanSwipeStateRef = useRef({
    lastX: 0,
    lastY: 0,
    pathDistance: 0,
    lastStrokeAt: 0,
  });
  const [tamagotchiCleanTouchActive, setTamagotchiCleanTouchActive] = useState(false);
  const tamagotchiCleanTouchActiveRef = useRef(false);
  const resolvedTamagotchiSkinId =
    catCustomizationUnlocked && TAMAGOTCHI_SKINS[tamagotchiSkinId]
      ? tamagotchiSkinId
      : DEFAULT_TAMAGOTCHI_SKIN;
  const tamagotchiSkin =
    TAMAGOTCHI_SKINS[resolvedTamagotchiSkinId] || TAMAGOTCHI_SKINS[DEFAULT_TAMAGOTCHI_SKIN];
  const tamagotchiAnimations = tamagotchiSkin.animations;
  const tamagotchiAvatarSource = tamagotchiSkin.avatar;
  const tamagotchiHydratedRef = useRef(false);
  const tamagotchiHungerPrevRef = useRef(
    Math.min(TAMAGOTCHI_MAX_HUNGER, Math.max(0, TAMAGOTCHI_START_STATE.hunger))
  );
  const tamagotchiHungerNotificationIdsRef = useRef([]);
  const tamagotchiHungerDailyCountRef = useRef({
    dayKey: getDayKey(Date.now()),
    count: 0,
  });
  const tamagotchiHungerLastAtRef = useRef(0);
  const tamagotchiModalAnim = useRef(new Animated.Value(0)).current;
  const tamagotchiTabContentAnim = useRef(new Animated.Value(1)).current;
  const tamagotchiTabSwitchingRef = useRef(false);
  const tamagotchiRewardPulseAnim = useRef(new Animated.Value(1)).current;
  const partyGlow = useRef(new Animated.Value(0)).current;
  const [partyActive, setPartyActive] = useState(false);
  const [partyBurstKey, setPartyBurstKey] = useState(0);
  const partyGlowAnimRef = useRef(null);
  const partySoundTimersRef = useRef([]);
  const processTamagotchiDecay = useCallback(
    (timestamp = Date.now()) => {
      setTamagotchiState((prev) => {
        const { state: nextState } = computeTamagotchiDecay(prev, timestamp);
        return nextState;
      });
    },
    [setTamagotchiState]
  );
  const markTamagotchiGreetingDay = useCallback((dayKey) => {
    if (!dayKey) return;
    setTamagotchiGreetingDayKey((prev) => (prev === dayKey ? prev : dayKey));
  }, []);
  const saveActionLogRef = useRef([]);
  const lastSaveActionAtRef = useRef(0);
  const cartBadgeScale = useRef(new Animated.Value(1)).current;
  useEffect(() => {
    const pulse = Animated.loop(
      Animated.sequence([
        Animated.delay(4200),
        Animated.timing(cartBadgeScale, {
          toValue: 1.08,
          duration: 400,
          easing: Easing.out(Easing.ease),
          useNativeDriver: true,
        }),
        Animated.timing(cartBadgeScale, {
          toValue: 1,
          duration: 420,
          easing: Easing.out(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    pulse.start();
    return () => pulse.stop();
  }, [cartBadgeScale]);
  const openSkinPicker = useCallback(() => {
    if (!catCustomizationUnlocked) {
      triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
      playSound("tap");
      setTamagotchiVisible(false);
      setTimeout(() => {
        const opened = showPremiumPaywallRef.current({
          kind: "feature",
          featureKey: PREMIUM_FEATURE_KEYS.catCustomization,
        });
        if (!opened) {
          setPremiumPaywallState({
            visible: true,
            kind: "soft",
            featureKey: PREMIUM_FEATURE_KEYS.catCustomization,
            savedAmountLabel: "",
            trigger: "feature_gate",
          });
        }
      }, 220);
      return;
    }
    triggerHaptic();
    setTamagotchiVisible(false);
    if (tamagotchiToyFlightTimerRef.current) {
      clearTimeout(tamagotchiToyFlightTimerRef.current);
      tamagotchiToyFlightTimerRef.current = null;
    }
    setTamagotchiToyFlightId(null);
    tamagotchiToyFlightAnim.stopAnimation();
    tamagotchiToyFlightAnim.setValue(0);
    tamagotchiHeartBurstAnim.stopAnimation();
    tamagotchiHeartBurstAnim.setValue(0);
    setSkinPickerVisible(true);
  }, [
    catCustomizationUnlocked,
    playSound,
    setPremiumPaywallState,
    tamagotchiHeartBurstAnim,
    tamagotchiToyFlightAnim,
    triggerHaptic,
  ]);
  const closeSkinPicker = useCallback(() => setSkinPickerVisible(false), []);
  const handleSkinSelect = useCallback(
    (skinId) => {
      if (!skinId || !TAMAGOTCHI_SKINS[skinId]) return;
      setTamagotchiSkinId(skinId);
      setSkinPickerVisible(false);
      logEvent("tamagotchi_skin_selected", {
        skin_id: skinId,
        is_pro: premiumActive ? 1 : 0,
      });
    },
    [logEvent, premiumActive]
  );
  const [onboardingStep, setOnboardingStep] = useState("logo");
  const onboardingStepRef = useRef("logo");
  const onboardingHistoryRef = useRef([]);
  const [canGoBackOnboarding, setCanGoBackOnboarding] = useState(false);
  const [onboardingSkipLocked, setOnboardingSkipLocked] = useState(false);
  const onboardingSkippedRef = useRef(false);
  const [registrationData, setRegistrationData] = useState(INITIAL_REGISTRATION);
  const goalTargetFocusRef = useRef(null);
  const [termsModalVisible, setTermsModalVisible] = useState(false);
  const [termsAccepted, setTermsAccepted] = useState(false);
  const [termsContinuePending, setTermsContinuePending] = useState(false);
  const [showImageSourceSheet, setShowImageSourceSheet] = useState(false);
  const [showCustomSpend, setShowCustomSpend] = useState(false);
  const [customSpendSavingsModal, setCustomSpendSavingsModal] = useState({
    visible: false,
    title: "",
    lowLabel: "",
    highLabel: "",
  });
  const [quickSpendDraft, setQuickSpendDraft] = useState({
    title: "",
    amount: "",
    emoji: DEFAULT_TEMPTATION_EMOJI,
    category: null,
    frequency: null,
    customFrequency: null,
  });
  useEffect(() => {
    onboardingStepRef.current = onboardingStep;
  }, [onboardingStep]);
  useEffect(() => {
    if (onboardingStep === "done") {
      if (!onboardingCompletedRef.current) {
        onboardingCompletedRef.current = true;
        goToTab("feed", { recordHistory: false, resetHistory: true });
      }
    } else {
      onboardingCompletedRef.current = false;
    }
  }, [goToTab, onboardingStep]);
  useEffect(() => {
    if (onboardingStep === "done") {
      setOnboardingSkipLocked(false);
    }
  }, [onboardingStep]);
  useEffect(() => {
    if (fontsError) {
      console.warn("Inter font load error", fontsError);
    }
  }, [fontsError]);
  useEffect(() => {
    if (!coinSliderHydrated) return;
    AsyncStorage.setItem(STORAGE_KEYS.COIN_SLIDER_MAX, String(coinSliderMaxUSD)).catch(() => {});
  }, [coinSliderHydrated, coinSliderMaxUSD]);
  useEffect(() => {
    beginHomeSession();
  }, [beginHomeSession]);
  useEffect(() => {
    tryLogHomeOpened();
  }, [tryLogHomeOpened]);
  useEffect(() => {
    if (!fabTutorialVisible) return;
    const timer = setTimeout(updateFabAnchor, 100);
    return () => clearTimeout(timer);
  }, [fabTutorialVisible, updateFabAnchor]);
  const fabTutorialBlocked = Boolean(overlay || dailySummaryVisible || priceEditor.item);
  const fabTutorialReady =
    fabTutorialState === FAB_TUTORIAL_STATUS.SHOWING &&
    onboardingStep === "done" &&
    tutorialSeen &&
    !tutorialOverlayVisible &&
    homeLayoutReady &&
    !startupLogoVisible &&
    !fabTutorialBlocked;
  useEffect(() => {
    if (!fabTutorialReady) return;
    enqueueQueuedModal(QUEUED_MODAL_TYPES.FAB_TUTORIAL);
  }, [enqueueQueuedModal, fabTutorialReady]);
  useEffect(() => {
    if (queuedModalType !== QUEUED_MODAL_TYPES.FAB_TUTORIAL || !fabTutorialReady) {
      fabTutorialLoggedRef.current = false;
      if (fabTutorialVisible) {
        setFabTutorialVisible(false);
      }
      return;
    }
    const shouldShow = activeTab === "feed";
    if (fabTutorialVisible !== shouldShow) {
      setFabTutorialVisible(shouldShow);
    }
    if (shouldShow && !fabTutorialLoggedRef.current) {
      logEvent("fab_tutorial_shown");
      fabTutorialLoggedRef.current = true;
    }
  }, [
    activeTab,
    fabTutorialVisible,
    fabTutorialReady,
    logEvent,
    queuedModalType,
  ]);
  useEffect(() => {
    const handleAppStateChange = (nextState) => {
      const previousState = appStateRef.current;
      const wasBackground = previousState === "background";
      appStateRef.current = nextState;
      if (nextState !== "active") {
        Keyboard.dismiss();
        setKeyboardInset(0);
        setKeyboardVisible(false);
        appResumeAtRef.current = Date.now();
        setFabTutorialVisible(false);
        storePotentialSnapshot(getPotentialSavedNow());
        return;
      }
      if (wasBackground && nextState === "active") {
        soundModeReadyRef.current = false;
        const resumedAt = appResumeAtRef.current || 0;
        appResumeAtRef.current = null;
        const suppressResumeOnce = suppressResumeOnceRef.current;
        if (suppressResumeOnce) {
          suppressResumeOnceRef.current = false;
        }
        const isTransientResume =
          suppressResumeOnce ||
          (resumedAt && Date.now() - resumedAt < APP_RESUME_MODAL_GUARD_MS);
        if (!isTransientResume) {
          if (dailyChallengePromptQueuedRef.current && dailyChallengePendingRef.current) {
            setDailyChallengePromptGate(true);
            dailyChallengeOfferDeferredRef.current = false;
          }
          setCurrentDayKey(getDayKey(Date.now()));
          processTamagotchiDecay();
          beginHomeSession();
          tryLogHomeOpened();
          if (activeTab === "feed") {
            triggerHomeSpeech("resume");
          }
          markDailySummaryOpen();
          maybeShowPotentialGrowth(getPotentialSavedNow());
          if (pendingFocusDigest) {
            setFocusDigestPromptShown(false);
          }
          refreshQueuedModalsOnResume();
          if (!overlayActiveRef.current && !overlay && overlayQueueRef.current.length) {
            processOverlayQueue();
          }
          triggerWidgetRefresh();
        }
      }
    };
    const subscription = AppState.addEventListener("change", handleAppStateChange);
    return () => subscription.remove();
  }, [
    activeTab,
    beginHomeSession,
    getPotentialSavedNow,
    maybeShowPotentialGrowth,
    overlay,
    processOverlayQueue,
    refreshQueuedModalsOnResume,
    storePotentialSnapshot,
    setDailyChallengePromptGate,
    markDailySummaryOpen,
    pendingFocusDigest,
    processTamagotchiDecay,
    setCurrentDayKey,
    triggerHomeSpeech,
    tryLogHomeOpened,
    setFabTutorialVisible,
    setKeyboardInset,
    setKeyboardVisible,
    triggerWidgetRefresh,
  ]);
  useEffect(() => {
    markDailySummaryOpen();
  }, [markDailySummaryOpen]);
  const ratingPromptActionGateReady =
    onboardingStep === "done" && tutorialSeen && temptationTutorialCompleted;
  const ratingPromptActionBaseReady =
    ratingPromptActionGateReady && Number.isFinite(ratingPromptActionBase);
  useEffect(() => {
    if (!ratingPromptHydrated) return;
    if (!ratingPromptActionGateReady) return;
    if (Number.isFinite(ratingPromptActionBase)) return;
    updateRatingPromptState((prev) => {
      if (prev.completed || prev.actionPrompted) return prev;
      const baseline = Math.max(0, Number(prev.actionCount) || 0);
      return { ...prev, actionCountStart: baseline };
    });
  }, [
    ratingPromptActionBase,
    ratingPromptActionGateReady,
    ratingPromptHydrated,
    updateRatingPromptState,
  ]);
  useEffect(() => {
    if (!ratingPromptHydrated) return;
    if (ratingPromptCompleted) return;
    if (ratingPromptVisible) return;
    if (onboardingStep !== "done") return;
    if (!ratingPromptActionGateReady) return;
    const firstOpenDate = new Date(ratingPromptFirstOpenAt || "");
    if (Number.isNaN(firstOpenDate.getTime())) return;
    const day3AtMs = firstOpenDate.getTime() + RATING_PROMPT_DELAY_DAYS * DAY_MS;
    if (ratingPromptLastAction === "later" && ratingPromptRespondedAt) {
      const respondedAtDate = new Date(ratingPromptRespondedAt);
      if (!Number.isNaN(respondedAtDate.getTime()) && respondedAtDate.getTime() >= day3AtMs) {
        return;
      }
    }
    const daysElapsed = Math.floor((Date.now() - firstOpenDate.getTime()) / DAY_MS);
    if (daysElapsed < RATING_PROMPT_DELAY_DAYS) return;
    queueRatingPrompt("time");
  }, [
    onboardingStep,
    ratingPromptHydrated,
    ratingPromptCompleted,
    ratingPromptFirstOpenAt,
    ratingPromptLastAction,
    ratingPromptRespondedAt,
    ratingPromptVisible,
    ratingPromptActionGateReady,
    queueRatingPrompt,
  ]);
  const ratingPromptActionEligible =
    ratingPromptHydrated &&
    ratingPromptActionBaseReady &&
    !ratingPromptCompleted &&
    !ratingPromptVisible &&
    !ratingPromptActionPrompted &&
    ratingPromptActionCount >= RATING_PROMPT_ACTION_THRESHOLD;
  useEffect(() => {
    if (!ratingPromptActionEligible) return;
    queueRatingPrompt("actions");
  }, [queueRatingPrompt, ratingPromptActionEligible]);
  useEffect(() => {
    if (!ratingPromptVisible) return;
    if (!ratingPromptQueuedRef.current) return;
    ratingPromptQueuedRef.current = false;
    ratingPromptSourceRef.current = null;
    if (ratingPromptCheckTimerRef.current) {
      clearTimeout(ratingPromptCheckTimerRef.current);
      ratingPromptCheckTimerRef.current = null;
    }
  }, [ratingPromptVisible]);
  useEffect(() => {
    if (!ratingPromptVisible) return;
    logEvent("rating_prompt_shown");
  }, [logEvent, ratingPromptVisible]);
  useEffect(() => {
    if (!focusStateHydrated) return;
    if (!focusTemplateId) {
      AsyncStorage.removeItem(STORAGE_KEYS.FOCUS_TARGET).catch(() => {});
      return;
    }
    AsyncStorage.setItem(
      STORAGE_KEYS.FOCUS_TARGET,
      JSON.stringify({ templateId: focusTemplateId, saveCount: focusSaveCount, updatedAt: Date.now() })
    ).catch(() => {});
  }, [focusSaveCount, focusStateHydrated, focusTemplateId]);
  useEffect(() => {
    if (!focusDigestHydrated) return;
    if (!focusDigestSeenKey) {
      AsyncStorage.removeItem(STORAGE_KEYS.FOCUS_DIGEST).catch(() => {});
      return;
    }
    AsyncStorage.setItem(STORAGE_KEYS.FOCUS_DIGEST, focusDigestSeenKey).catch(() => {});
  }, [focusDigestSeenKey, focusDigestHydrated]);
  useEffect(() => {
    if (!focusDigestHydrated) return;
    if (!pendingFocusDigest) {
      AsyncStorage.removeItem(STORAGE_KEYS.FOCUS_DIGEST_PENDING).catch(() => {});
      return;
    }
    AsyncStorage.setItem(STORAGE_KEYS.FOCUS_DIGEST_PENDING, JSON.stringify(pendingFocusDigest)).catch(() => {});
  }, [pendingFocusDigest, focusDigestHydrated]);
  const openTamagotchiOverlay = useCallback(() => {
    triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    playSound("tap");
    setTamagotchiActiveTab("food");
    tamagotchiTabContentAnim.setValue(1);
    tamagotchiTabSwitchingRef.current = false;
    setTamagotchiVisible((prev) => {
      if (!prev) {
        logEvent("tamagotchi_pressed");
        logEvent("tamagotchi_opened");
      }
      return true;
    });
  }, [logEvent, playSound, tamagotchiTabContentAnim, triggerHaptic]);
  const closeTamagotchiOverlay = useCallback(() => {
    playSound("tap");
    setTamagotchiVisible(false);
    tamagotchiCleanTouchActiveRef.current = false;
    setTamagotchiCleanTouchActive(false);
    if (tamagotchiToyFlightTimerRef.current) {
      clearTimeout(tamagotchiToyFlightTimerRef.current);
      tamagotchiToyFlightTimerRef.current = null;
    }
    setTamagotchiToyFlightId(null);
    tamagotchiToyFlightAnim.stopAnimation();
    tamagotchiToyFlightAnim.setValue(0);
    tamagotchiHeartBurstAnim.stopAnimation();
    tamagotchiHeartBurstAnim.setValue(0);
    tamagotchiTabContentAnim.setValue(1);
    tamagotchiTabSwitchingRef.current = false;
  }, [
    playSound,
    tamagotchiHeartBurstAnim,
    tamagotchiTabContentAnim,
    tamagotchiToyFlightAnim,
  ]);
  const handleTamagotchiDailyRewardPress = useCallback(() => {
    if (!dailyRewardReady) {
      playSound("tap");
      return;
    }
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    playSound("daily_reward");
    closeTamagotchiOverlay();
    setTimeout(() => {
      savingsHeroRef.current?.openDailyRewardModal?.();
    }, 220);
  }, [closeTamagotchiOverlay, dailyRewardReady, playSound, triggerHaptic]);
  const handleTamagotchiTabPress = useCallback(
    (nextTabId) => {
      if (!nextTabId || nextTabId === tamagotchiActiveTab) return;
      if (tamagotchiTabSwitchingRef.current) return;
      tamagotchiTabSwitchingRef.current = true;
      triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
      playSound("tap");
      Animated.timing(tamagotchiTabContentAnim, {
        toValue: 0,
        duration: 110,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }).start(({ finished }) => {
        if (!finished) {
          tamagotchiTabSwitchingRef.current = false;
          return;
        }
        runLayoutAnimation();
        setTamagotchiActiveTab(nextTabId);
        Animated.spring(tamagotchiTabContentAnim, {
          toValue: 1,
          tension: 170,
          friction: 18,
          useNativeDriver: true,
        }).start(() => {
          tamagotchiTabSwitchingRef.current = false;
        });
      });
    },
    [playSound, tamagotchiActiveTab, tamagotchiTabContentAnim, triggerHaptic]
  );
  useEffect(() => {
    if (tamagotchiVisible && tamagotchiActiveTab === "clean") return;
    tamagotchiCleanTouchActiveRef.current = false;
    setTamagotchiCleanTouchActive(false);
  }, [tamagotchiActiveTab, tamagotchiVisible]);
  const [fabMenuVisible, setFabMenuVisible] = useState(false);
  const fabMenuAnim = useRef(new Animated.Value(0)).current;
  const fabSlideAnim = useRef(new Animated.Value(0)).current;
  const fabScrollHiddenRef = useRef(false);
  const setFabScrollHidden = useCallback(
    (hidden) => {
      if (fabScrollHiddenRef.current === hidden) return;
      fabScrollHiddenRef.current = hidden;
      Animated.timing(fabSlideAnim, {
        toValue: hidden ? 1 : 0,
        duration: hidden ? 140 : 200,
        easing: Easing.out(Easing.cubic),
        useNativeDriver: true,
      }).start();
    },
    [fabSlideAnim]
  );
  const tamagotchiHungerPercent = useMemo(
    () => Math.min(TAMAGOTCHI_MAX_HUNGER, Math.max(0, Number(tamagotchiState.hunger) || 0)),
    [tamagotchiState.hunger]
  );
  const tamagotchiMoodPercent = useMemo(
    () =>
      Math.min(
        TAMAGOTCHI_MAX_STATE_VALUE,
        Math.max(0, Number(tamagotchiState.mood ?? TAMAGOTCHI_START_STATE.mood) || 0)
      ),
    [tamagotchiState.mood]
  );
  const tamagotchiCleanlinessPercent = useMemo(
    () =>
      Math.min(
        TAMAGOTCHI_MAX_STATE_VALUE,
        Math.max(0, Number(tamagotchiState.cleanliness ?? TAMAGOTCHI_START_STATE.cleanliness) || 0)
      ),
    [tamagotchiState.cleanliness]
  );
  const tamagotchiDirtyLevel = useMemo(
    () =>
      Math.max(
        0,
        Math.min(
          1,
          (TAMAGOTCHI_DIRTY_DESAT_THRESHOLD - tamagotchiCleanlinessPercent) /
            Math.max(1, TAMAGOTCHI_DIRTY_DESAT_THRESHOLD)
        )
      ),
    [tamagotchiCleanlinessPercent]
  );
  const tamagotchiNeedsPlay = tamagotchiMoodPercent <= TAMAGOTCHI_LOW_MOOD_THRESHOLD;
  const tamagotchiNeedsCleaning = tamagotchiCleanlinessPercent <= TAMAGOTCHI_LOW_CLEANLINESS_THRESHOLD;
  const tamagotchiMood = useMemo(
    () => getTamagotchiMood(tamagotchiState, language),
    [language, tamagotchiState]
  );
  const beginHomeSession = useCallback(() => {
    const todayKey = getDayKey(Date.now());
    if (homeSessionRef.current.dateKey !== todayKey) {
      homeSessionRef.current.dateKey = todayKey;
      homeSessionRef.current.sessionCount = 0;
    }
    homeSessionRef.current.sessionCount += 1;
    const sessionCount = homeSessionRef.current.sessionCount;
    setFabTutorialEligible((prev) => {
      if (prev) return prev;
      return sessionCount >= FAB_TUTORIAL_MIN_SESSIONS;
    });
    homeSessionRef.current.pendingIndex = homeSessionRef.current.sessionCount;
  }, []);
  const tryLogHomeOpened = useCallback(() => {
    if (activeTab !== "feed") return;
    const pendingIndex = homeSessionRef.current.pendingIndex;
    if (!pendingIndex) return;
    logEvent("home_opened", { session_index: pendingIndex });
    homeSessionRef.current.pendingIndex = null;
  }, [activeTab, logEvent]);
  const isFabTutorialEnvironmentReady = useMemo(
    () =>
      onboardingStep === "done" &&
      tutorialSeen &&
      homeLayoutReady &&
      !tutorialOverlayVisible &&
      !startupLogoVisible,
    [homeLayoutReady, onboardingStep, startupLogoVisible, tutorialOverlayVisible, tutorialSeen]
  );
  useEffect(() => {
    if (
      fabTutorialState === FAB_TUTORIAL_STATUS.PENDING &&
      fabTutorialEligible &&
      isFabTutorialEnvironmentReady
    ) {
      setFabTutorialStateAndPersist(FAB_TUTORIAL_STATUS.SHOWING);
    }
  }, [
    fabTutorialEligible,
    fabTutorialState,
    isFabTutorialEnvironmentReady,
    setFabTutorialStateAndPersist,
  ]);
  const tamagotchiIsFull = tamagotchiHungerPercent >= TAMAGOTCHI_MAX_HUNGER;
  const tamagotchiHungerImmunityUntil = Math.max(
    0,
    Number(tamagotchiState.hungerImmunityUntil) || 0
  );
  const tamagotchiHasHungerImmunity = tamagotchiHungerImmunityUntil > Date.now();
  const [tamagotchiImmunityHintVisible, setTamagotchiImmunityHintVisible] = useState(false);
  const [tamagotchiImmunityHintNow, setTamagotchiImmunityHintNow] = useState(() =>
    Date.now()
  );
  const tamagotchiImmunityHintAnim = useRef(new Animated.Value(0)).current;
  const tamagotchiImmunityHintHideTimerRef = useRef(null);
  const tamagotchiImmunityHintRemainingMs = Math.max(
    0,
    tamagotchiHungerImmunityUntil - tamagotchiImmunityHintNow
  );
  const tamagotchiImmunityHintPalette = useMemo(
    () =>
      isDarkTheme
        ? {
            backgroundColor: "rgba(8,13,24,0.96)",
            borderColor: "rgba(126,178,255,0.42)",
            titleColor: "#DCEAFF",
            textColor: "#9CC4FF",
          }
        : {
            backgroundColor: "rgba(255,255,255,0.98)",
            borderColor: "rgba(62,129,255,0.3)",
            titleColor: "#244A84",
            textColor: "#2F70FF",
          },
    [isDarkTheme]
  );
  const clearTamagotchiImmunityHintTimer = useCallback(() => {
    if (tamagotchiImmunityHintHideTimerRef.current) {
      clearTimeout(tamagotchiImmunityHintHideTimerRef.current);
      tamagotchiImmunityHintHideTimerRef.current = null;
    }
  }, []);
  const hideTamagotchiImmunityHint = useCallback(
    (immediate = false) => {
      clearTamagotchiImmunityHintTimer();
      tamagotchiImmunityHintAnim.stopAnimation();
      if (immediate) {
        tamagotchiImmunityHintAnim.setValue(0);
        setTamagotchiImmunityHintVisible(false);
        return;
      }
      Animated.timing(tamagotchiImmunityHintAnim, {
        toValue: 0,
        duration: 180,
        easing: Easing.in(Easing.quad),
        useNativeDriver: true,
      }).start(({ finished }) => {
        if (finished) {
          setTamagotchiImmunityHintVisible(false);
        }
      });
    },
    [clearTamagotchiImmunityHintTimer, tamagotchiImmunityHintAnim]
  );
  const formatTamagotchiImmunityCountdown = useCallback(
    (ms) => {
      if (ms <= 0) return "00:00:00";
      const totalSeconds = Math.floor(ms / 1000);
      const days = Math.floor(totalSeconds / 86400);
      const hours = Math.floor((totalSeconds % 86400) / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      const hh = String(hours).padStart(2, "0");
      const mm = String(minutes).padStart(2, "0");
      const ss = String(seconds).padStart(2, "0");
      if (days > 0) {
        return `${days}${t("challengeTimeDayShort")} ${hh}:${mm}:${ss}`.trim();
      }
      return `${hh}:${mm}:${ss}`;
    },
    [t]
  );
  const tamagotchiImmunityHintCountdownLabel = useMemo(
    () => formatTamagotchiImmunityCountdown(tamagotchiImmunityHintRemainingMs),
    [formatTamagotchiImmunityCountdown, tamagotchiImmunityHintRemainingMs]
  );
  const showTamagotchiImmunityHint = useCallback(() => {
    if (!tamagotchiHasHungerImmunity || !tamagotchiHungerImmunityUntil) return;
    triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    setTamagotchiImmunityHintNow(Date.now());
    setTamagotchiImmunityHintVisible(true);
    clearTamagotchiImmunityHintTimer();
    tamagotchiImmunityHintAnim.stopAnimation();
    tamagotchiImmunityHintAnim.setValue(0);
    Animated.spring(tamagotchiImmunityHintAnim, {
      toValue: 1,
      tension: 180,
      friction: 16,
      useNativeDriver: true,
    }).start();
    tamagotchiImmunityHintHideTimerRef.current = setTimeout(() => {
      hideTamagotchiImmunityHint();
    }, 3600);
  }, [
    clearTamagotchiImmunityHintTimer,
    hideTamagotchiImmunityHint,
    tamagotchiHasHungerImmunity,
    tamagotchiHungerImmunityUntil,
    tamagotchiImmunityHintAnim,
  ]);
  useEffect(
    () => () => clearTamagotchiImmunityHintTimer(),
    [clearTamagotchiImmunityHintTimer]
  );
  useEffect(() => {
    if (!tamagotchiImmunityHintVisible) return;
    setTamagotchiImmunityHintNow(Date.now());
    const intervalId = setInterval(() => {
      setTamagotchiImmunityHintNow(Date.now());
    }, 1000);
    return () => clearInterval(intervalId);
  }, [tamagotchiImmunityHintVisible]);
  useEffect(() => {
    if (!tamagotchiImmunityHintVisible) return;
    if (tamagotchiImmunityHintRemainingMs > 0) return;
    hideTamagotchiImmunityHint(true);
  }, [
    hideTamagotchiImmunityHint,
    tamagotchiImmunityHintRemainingMs,
    tamagotchiImmunityHintVisible,
  ]);
  const tamagotchiCoins = healthPoints;
  const tamagotchiCoinBreakdown = useMemo(
    () => getHealthCoinBreakdown(tamagotchiCoins),
    [tamagotchiCoins]
  );
  const tamagotchiStickyCoinTokens = useMemo(
    () => [
      {
        id: "blue",
        count: Math.max(0, Number(tamagotchiCoinBreakdown.blue) || 0),
        asset: BLUE_HEALTH_COIN_TIER?.asset || HEALTH_COIN_TIERS[1]?.asset || HEALTH_COIN_TIERS[0].asset,
      },
      {
        id: "green",
        count: Math.max(0, Number(tamagotchiCoinBreakdown.green) || 0),
        asset: GREEN_HEALTH_COIN_TIER?.asset || HEALTH_COIN_TIERS[0].asset,
      },
    ],
    [tamagotchiCoinBreakdown.blue, tamagotchiCoinBreakdown.green]
  );
  const tamagotchiDesiredFood =
    TAMAGOTCHI_FOOD_MAP[tamagotchiState.desiredFoodId] ||
    TAMAGOTCHI_FOOD_MAP[TAMAGOTCHI_DEFAULT_FOOD_ID];
  const tamagotchiDesiredToy =
    TAMAGOTCHI_TOY_MAP[tamagotchiState.desiredToyId] ||
    TAMAGOTCHI_TOY_MAP[TAMAGOTCHI_DEFAULT_TOY_ID];
  const tamagotchiCleanToolSupplies = useMemo(
    () => normalizeTamagotchiToolSupplies(tamagotchiState.cleanToolSupplies),
    [tamagotchiState.cleanToolSupplies]
  );
  const tamagotchiSelectedCleanTool =
    TAMAGOTCHI_CLEAN_TOOL_MAP[tamagotchiSelectedCleanToolId] ||
    TAMAGOTCHI_CLEAN_TOOL_MAP[TAMAGOTCHI_DEFAULT_CLEAN_TOOL_ID];
  const tamagotchiSelectedCleanToolRemaining = Math.max(
    0,
    Number(tamagotchiCleanToolSupplies?.[tamagotchiSelectedCleanTool?.id]) || 0
  );
  const [newPendingModal, setNewPendingModal] = useState({
    visible: false,
    title: "",
    amount: "",
    emoji: DEFAULT_TEMPTATION_EMOJI,
  });
  const [newGoalModal, setNewGoalModal] = useState({
    visible: false,
    name: "",
    target: "",
    emoji: DEFAULT_GOAL_EMOJI,
    makePrimary: false,
    source: "unknown",
  });
  const activeGoalCount = useMemo(() => {
    if (!Array.isArray(wishes)) return 0;
    return wishes.filter((wish) => wish && wish.status !== "done").length;
  }, [wishes]);
  const openNewPendingModal = useCallback(
    () => {
      const activePendingCount = Array.isArray(pendingListRef.current)
        ? pendingListRef.current.length
        : 0;
      if (!premiumState.isPremium && activePendingCount >= FREE_PENDING_LIMIT) {
        const opened = showPremiumPaywallRef.current({
          kind: "feature",
          featureKey: PREMIUM_FEATURE_KEYS.thinkingQueue,
        });
        if (opened) return;
      }
      return setNewPendingModal({
        visible: true,
        title: "",
        amount: "",
        emoji: DEFAULT_TEMPTATION_EMOJI,
      });
    },
    [premiumState.isPremium]
  );
  const openNewGoalModal = useCallback(
    (makePrimary = false, source = "unknown") => {
      const activeGoalLimit = premiumState.isPremium ? MAX_ACTIVE_GOALS : FREE_GOAL_LIMIT;
      if (activeGoalCount >= activeGoalLimit) {
        if (!premiumState.isPremium) {
          showPremiumPaywallRef.current({
            kind: "feature",
            featureKey: PREMIUM_FEATURE_KEYS.multipleGoals,
          });
          return;
        }
        Alert.alert(
          t("goalLimitReachedTitle", { limit: activeGoalLimit }),
          t("goalLimitReachedMessage", { limit: activeGoalLimit })
        );
        return;
      }
      setNewGoalModal({
        visible: true,
        name: "",
        target: "",
        emoji: DEFAULT_GOAL_EMOJI,
        makePrimary,
        source,
      });
      logEvent("goal_creator_opened", {
        source,
        make_primary: makePrimary ? 1 : 0,
      });
    },
    [activeGoalCount, logEvent, premiumState.isPremium, t]
  );
  const handleNewPendingChange = useCallback((field, value) => {
    setNewPendingModal((prev) => ({
      ...prev,
      [field]: field === "emoji" ? limitEmojiInput(value) : value,
    }));
  }, []);
  const handleNewPendingCancel = useCallback(() => {
    setNewPendingModal({ visible: false, title: "", amount: "", emoji: DEFAULT_TEMPTATION_EMOJI });
  }, []);
  const [onboardingGoalModal, setOnboardingGoalModal] = useState({
    visible: false,
    name: "",
    target: "",
    emoji: DEFAULT_GOAL_EMOJI,
  });
  const goalSelectionTouchedRef = useRef(false);
  const openFabMenu = useCallback(() => {
    if (fabMenuVisible) return;
    setFabMenuVisible(true);
    Animated.spring(fabMenuAnim, {
      toValue: 1,
      friction: 7,
      tension: 120,
      useNativeDriver: true,
    }).start();
  }, [fabMenuAnim, fabMenuVisible]);
  const closeFabMenu = useCallback(() => {
    Animated.timing(fabMenuAnim, {
      toValue: 0,
      duration: 160,
      easing: Easing.out(Easing.quad),
      useNativeDriver: true,
    }).start(() => setFabMenuVisible(false));
  }, [fabMenuAnim]);
  const handleFabPress = useCallback(() => {
    Keyboard.dismiss();
    handleFabTutorialDismiss("tap");
    triggerHaptic();
    if (fabMenuVisible) {
      closeFabMenu();
    }
    if (activeTab === "cart") {
      openNewGoalModal(false, "fab_cart");
    } else if (activeTab === "pending") {
      openNewPendingModal();
    } else {
      openCoinEntry(activeTab || "unknown");
    }
  }, [
    activeTab,
    closeFabMenu,
    fabMenuVisible,
    handleFabTutorialDismiss,
    openCoinEntry,
    openNewGoalModal,
    openNewPendingModal,
    triggerHaptic,
  ]);
  const handleFabLongPress = useCallback(() => {
    Keyboard.dismiss();
    handleFabTutorialDismiss("hold");
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    if (fabMenuVisible) {
      closeFabMenu();
    } else {
      openFabMenu();
    }
  }, [closeFabMenu, fabMenuVisible, handleFabTutorialDismiss, openFabMenu, triggerHaptic]);
  const handleFeedScrollActivity = useCallback(
    (isScrolling) => {
      if (activeTab !== "feed") return;
      if (fabMenuVisible || fabTutorialVisible) return;
      setFabScrollHidden(isScrolling);
    },
    [activeTab, fabMenuVisible, fabTutorialVisible, setFabScrollHidden]
  );
  useEffect(() => {
    if (activeTab === "profile" && fabMenuVisible) {
      closeFabMenu();
    }
  }, [activeTab, closeFabMenu, fabMenuVisible]);
  useEffect(() => {
    if (activeTab !== "feed" || fabMenuVisible || fabTutorialVisible) {
      setFabScrollHidden(false);
    }
  }, [activeTab, fabMenuVisible, fabTutorialVisible, setFabScrollHidden]);
  const imagePickerResolver = useRef(null);
  const [refuseStats, setRefuseStats] = useState({});
  const [refuseStatsHydrated, setRefuseStatsHydrated] = useState(false);
  const resolveCardRefuseStats = useCallback(
    (card) => {
      if (!card) return null;
      const directKey = typeof card.id === "string" ? card.id : null;
      if (directKey && refuseStats[directKey]) {
        return refuseStats[directKey];
      }
      const templateKey =
        typeof card.templateId === "string" && card.templateId.trim().length
          ? card.templateId.trim()
          : null;
      if (templateKey && refuseStats[templateKey]) {
        return refuseStats[templateKey];
      }
      if (isCustomTemptation(card)) {
        const isQuickCustom =
          Boolean(
            card.quickTemptation ||
              card.quickCreate ||
              card.origin === "quick_custom" ||
              card.source === "quick_custom"
          ) ||
          (typeof card.id === "string" && card.id.startsWith("custom_habit_"));
        if (!isQuickCustom) {
          const fallbackKeys = [];
          if (profile.customSpend?.id) {
            fallbackKeys.push(profile.customSpend.id);
          }
          fallbackKeys.push("custom_habit", "undefined");
          for (let index = 0; index < fallbackKeys.length; index += 1) {
            const key = fallbackKeys[index];
            if (key && refuseStats[key]) {
              return refuseStats[key];
            }
          }
        }
      }
      return null;
    },
    [profile.customSpend?.id, refuseStats]
  );
  const [temptationInteractions, setTemptationInteractions] = useState({});
  const [temptationInteractionsHydrated, setTemptationInteractionsHydrated] = useState(false);
  const [impulseTracker, setImpulseTracker] = useState({ ...INITIAL_IMPULSE_TRACKER });
  const [impulseTrackerHydrated, setImpulseTrackerHydrated] = useState(false);
  const [moodState, setMoodState] = useState(() => createMoodStateForToday());
  const [cardFeedback, setCardFeedback] = useState({});
  const [moodHydrated, setMoodHydrated] = useState(false);
  const lastVisitAtSnapshotRef = useRef(null);
  const editOverlayAnim = useRef(new Animated.Value(0)).current;
  const [editOverlayVisible, setEditOverlayVisible] = useState(false);
  const cardFeedbackTimers = useRef({});
  const impulseAlertCooldownRef = useRef({});
  const lastInstantNotificationRef = useRef(0);
  const resolveNotificationTriggerTime = useCallback((trigger, nowTs = Date.now()) => {
    if (!trigger) return nowTs;
    if (trigger instanceof Date) return trigger.getTime();
    if (typeof trigger === "number") return trigger;
    if (typeof trigger === "string") {
      const parsed = Date.parse(trigger);
      if (!Number.isNaN(parsed)) return parsed;
    }
    if (typeof trigger === "object") {
      if (typeof trigger.seconds === "number") {
        return nowTs + trigger.seconds * 1000;
      }
      if (typeof trigger.value === "number") return trigger.value;
      if (typeof trigger.value === "string") {
        const parsedValue = Date.parse(trigger.value);
        if (!Number.isNaN(parsedValue)) return parsedValue;
      }
      const calendarSource = trigger.dateComponents || trigger;
      const nowDate = new Date(nowTs);
      if (
        typeof calendarSource.hour === "number" &&
        typeof calendarSource.minute === "number"
      ) {
        const next = new Date(nowDate);
        next.setHours(calendarSource.hour, calendarSource.minute, calendarSource.second || 0, 0);
        if (next.getTime() <= nowTs) {
          next.setDate(next.getDate() + 1);
        }
        return next.getTime();
      }
      if (
        typeof calendarSource.year === "number" ||
        typeof calendarSource.month === "number" ||
        typeof calendarSource.day === "number"
      ) {
        const computed = new Date(
          typeof calendarSource.year === "number" ? calendarSource.year : nowDate.getFullYear(),
          typeof calendarSource.month === "number" ? Math.max(0, calendarSource.month - 1) : nowDate.getMonth(),
          typeof calendarSource.day === "number" ? calendarSource.day : nowDate.getDate(),
          typeof calendarSource.hour === "number" ? calendarSource.hour : 0,
          typeof calendarSource.minute === "number" ? calendarSource.minute : 0,
          typeof calendarSource.second === "number" ? calendarSource.second : 0,
          0
        );
        const ts = computed.getTime();
        return Number.isFinite(ts) ? ts : null;
      }
    }
    return null;
  }, []);
  const readScheduledNotificationTimes = useCallback(async () => {
    try {
      const scheduled = await safeNotifications.getAllScheduledNotificationsAsync();
      const nowTs = Date.now();
      return (Array.isArray(scheduled) ? scheduled : [])
        .map((entry) => resolveNotificationTriggerTime(entry?.trigger, nowTs))
        .filter((value) => Number.isFinite(value) && value >= nowTs)
        .sort((a, b) => a - b);
    } catch (error) {
      console.warn("scheduled notifications read", error);
      return [];
    }
  }, [resolveNotificationTriggerTime]);
  const findScheduledNotificationByDedupeKey = useCallback(
    async (dedupeKey) => {
      if (!dedupeKey) return null;
      try {
        const scheduled = await safeNotifications.getAllScheduledNotificationsAsync();
        const entries = Array.isArray(scheduled) ? scheduled : [];
        for (let idx = 0; idx < entries.length; idx += 1) {
          const entry = entries[idx];
          const entryKey = entry?.content?.data?.dedupeKey;
          if (entryKey && entryKey === dedupeKey) {
            return entry;
          }
        }
      } catch (error) {
        console.warn("scheduled notifications read", error);
      }
      return null;
    },
    []
  );
  const getScheduledTamagotchiHungerCounts = useCallback(async () => {
    try {
      const scheduled = await safeNotifications.getAllScheduledNotificationsAsync();
      const nowTs = Date.now();
      return (Array.isArray(scheduled) ? scheduled : []).reduce((acc, entry) => {
        if (entry?.content?.data?.kind !== "tamagotchi_hunger") return acc;
        const triggerTs = resolveNotificationTriggerTime(entry?.trigger, nowTs);
        if (!Number.isFinite(triggerTs)) return acc;
        const dayKey = getDayKey(triggerTs);
        if (!dayKey) return acc;
        acc[dayKey] = (acc[dayKey] || 0) + 1;
        return acc;
      }, {});
    } catch (error) {
      console.warn("scheduled tamagotchi hunger count", error);
      return {};
    }
  }, [resolveNotificationTriggerTime]);
  const cleanupStaleEventNotifications = useCallback(async () => {
    try {
      const scheduled = await safeNotifications.getAllScheduledNotificationsAsync();
      const nowTs = Date.now();
      const staleIds = (Array.isArray(scheduled) ? scheduled : []).reduce((acc, entry) => {
        const data = entry?.content?.data || {};
        const kind = data.kind;
        if (kind !== "impulse_reminder" && kind !== "smart_insight") return acc;
        let eventTimestamp = Number(data.eventTimestamp) || 0;
        if (!eventTimestamp) {
          const triggerTs = resolveNotificationTriggerTime(entry?.trigger, nowTs);
          if (Number.isFinite(triggerTs)) {
            eventTimestamp =
              kind === "impulse_reminder"
                ? triggerTs - DAY_MS
                : triggerTs - SMART_REMINDER_DELAY_MS;
          }
        }
        if (!eventTimestamp) return acc;
        if (nowTs - eventTimestamp > RECENT_EVENT_NOTIFICATION_WINDOW_MS) {
          const id = entry?.identifier || entry?.id || null;
          if (id) acc.push(id);
        }
        return acc;
      }, []);
      if (!staleIds.length) return;
      await Promise.all(
        staleIds.map((id) => safeNotifications.cancelScheduledNotificationAsync(id))
      );
    } catch (error) {
      console.warn("stale notification cleanup", error);
    }
  }, [resolveNotificationTriggerTime]);
  const cancelScheduledNotificationsForTemplate = useCallback(async (templateId) => {
    if (!templateId) return;
    try {
      const scheduled = await safeNotifications.getAllScheduledNotificationsAsync();
      const matchingIds = (Array.isArray(scheduled) ? scheduled : []).reduce((acc, entry) => {
        const data = entry?.content?.data || {};
        if (data?.templateId !== templateId) return acc;
        const id = entry?.identifier || entry?.id || null;
        if (id) acc.push(id);
        return acc;
      }, []);
      if (!matchingIds.length) return;
      await Promise.all(
        matchingIds.map((id) => safeNotifications.cancelScheduledNotificationAsync(id))
      );
    } catch (error) {
      console.warn("template notification cleanup", error);
    }
  }, []);
  const clearFrequencyReminderStateForTemplate = useCallback((templateId) => {
    if (!templateId) return;
    setTemptationInteractions((prev) => {
      const prevEntry = prev?.[templateId];
      if (!prevEntry) return prev;
      if (
        !prevEntry.frequencyReminderId &&
        !(prevEntry.frequencyReminderIds && prevEntry.frequencyReminderIds.length) &&
        !prevEntry.frequencyReminderScheduledAt &&
        !prevEntry.frequencyReminderLocale &&
        !prevEntry.frequencyReminderPlanKey
      ) {
        return prev;
      }
      return {
        ...(prev || {}),
        [templateId]: {
          ...prevEntry,
          frequencyReminderId: null,
          frequencyReminderIds: [],
          frequencyReminderScheduledAt: null,
          frequencyReminderLocale: null,
          frequencyReminderPlanKey: null,
        },
      };
    });
  }, [setTemptationInteractions]);
  const isNotificationOnCooldown = useCallback(
    async (targetTime = Date.now()) => {
      const lastSent = Number(lastInstantNotificationRef.current) || 0;
      if (lastSent > 0 && targetTime - lastSent < PUSH_NOTIFICATION_COOLDOWN_MS) {
        return true;
      }
      const scheduledTimes = await readScheduledNotificationTimes();
      return scheduledTimes.some(
        (scheduledAt) => Math.abs(scheduledAt - targetTime) < PUSH_NOTIFICATION_COOLDOWN_MS
      );
    },
    [readScheduledNotificationTimes]
  );
  const scheduleNotificationWithCooldown = useCallback(
    async (request) => {
      if (!request?.content) return null;
      const dedupeKey = request?.content?.data?.dedupeKey || null;
      if (dedupeKey) {
        const existing = await findScheduledNotificationByDedupeKey(dedupeKey);
        if (existing) {
          const scheduledFor = resolveNotificationTriggerTime(existing?.trigger);
          return {
            id: existing?.identifier || existing?.id || null,
            scheduledFor: Number.isFinite(scheduledFor) ? scheduledFor : null,
          };
        }
      }
      const triggerInput = request.trigger;
      const repeats = triggerInput && typeof triggerInput === "object" && triggerInput.repeats;
      let finalTrigger = triggerInput ?? null;
      let scheduledFor = resolveNotificationTriggerTime(triggerInput);
      const requestedTime = scheduledFor;
      if (!repeats && Number.isFinite(requestedTime)) {
        const scheduledTimes = await readScheduledNotificationTimes();
        const lastSent = Number(lastInstantNotificationRef.current) || 0;
        let adjustedTime = Math.max(requestedTime, Date.now());
        if (lastSent > 0 && adjustedTime - lastSent < PUSH_NOTIFICATION_COOLDOWN_MS) {
          adjustedTime = lastSent + PUSH_NOTIFICATION_COOLDOWN_MS;
        }
        for (let idx = 0; idx < scheduledTimes.length; idx += 1) {
          const scheduledAt = scheduledTimes[idx];
          if (Math.abs(adjustedTime - scheduledAt) < PUSH_NOTIFICATION_COOLDOWN_MS) {
            adjustedTime = scheduledAt + PUSH_NOTIFICATION_COOLDOWN_MS;
          }
        }
        if (adjustedTime !== requestedTime) {
          finalTrigger = new Date(adjustedTime);
        }
        scheduledFor = adjustedTime;
      }
      const id = await safeNotifications.scheduleNotificationAsync({
        ...request,
        trigger: finalTrigger,
      });
      const resolvedTrigger = resolveNotificationTriggerTime(finalTrigger);
      const finalScheduledFor = Number.isFinite(resolvedTrigger) ? resolvedTrigger : scheduledFor;
      return { id, scheduledFor: finalScheduledFor };
    },
    [findScheduledNotificationByDedupeKey, readScheduledNotificationTimes, resolveNotificationTriggerTime]
  );
  const [notificationPermissionGranted, setNotificationPermissionGranted] = useState(null);
  const [pushOptInHydrated, setPushOptInHydrated] = useState(false);
  const pushOptInLoggedRef = useRef(false);
  const [homeWidgetInstallLoggedHydrated, setHomeWidgetInstallLoggedHydrated] = useState(false);
  const homeWidgetInstallLoggedRef = useRef(false);
  const homeWidgetInstallCheckInFlightRef = useRef(false);
  const [pushDayThreePromptVisible, setPushDayThreePromptVisible] = useState(false);
  const [pushDayThreePromptHydrated, setPushDayThreePromptHydrated] = useState(false);
  const pushDayThreePromptShownRef = useRef(false);
  const [spendLoggingReminderHydrated, setSpendLoggingReminderHydrated] = useState(false);
  const lastSpendLoggingReminderRef = useRef(0);
  const handledNotificationResponseIdsRef = useRef(new Set());
  const notificationActionHandlerRef = useRef(null);
  const notificationDedupeRef = useRef(new Map());
  const pushLocaleRef = useRef(null);
  const pendingListRef = useRef([]);
  const [spendPrompt, setSpendPrompt] = useState({ visible: false, item: null, amountUSD: null });
  const [saveSpamPrompt, setSaveSpamPrompt] = useState({
    visible: false,
    item: null,
    options: null,
    recentCount: 0,
  });
  const [categoryPrompt, setCategoryPrompt] = useState({ visible: false, item: null, action: null, options: null });
  const [categoryPromptSelection, setCategoryPromptSelection] = useState(DEFAULT_IMPULSE_CATEGORY);
  const [addCategoryModalVisible, setAddCategoryModalVisible] = useState(false);
  const [manageCategoriesVisible, setManageCategoriesVisible] = useState(false);
  const [resumeManageCategoriesAfterAdd, setResumeManageCategoriesAfterAdd] = useState(false);
  const [addCategoryName, setAddCategoryName] = useState("");
  const [addCategoryEmoji, setAddCategoryEmoji] = useState("âœ¨");
  const [addCategoryError, setAddCategoryError] = useState(false);
  const [categoryEditId, setCategoryEditId] = useState("savings");
  const [categoryEditName, setCategoryEditName] = useState("");
  const [categoryEditEmoji, setCategoryEditEmoji] = useState(DEFAULT_SAVINGS_CATEGORY_DEF.emoji);
  const [coinValueModalStatus, setCoinValueModalStatus] = useState("none");
  const [coinValueModalHydrated, setCoinValueModalHydrated] = useState(false);
  const [coinValueModalVisible, setCoinValueModalVisible] = useState(false);
  const coinValueModalStatusRef = useRef("none");
  const coinBalancePrevRef = useRef(0);
  const tutorialSeenPrevRef = useRef(false);
  const coinValueModalCheckTimerRef = useRef(null);
  const resetCounterRef = useRef(0);
  const spendPromptLockRef = useRef(false);
  const spendExecutionLockRef = useRef(false);
  const [stormActive, setStormActive] = useState(false);
  const safeAreaInsets = safeUseSafeAreaInsets();
  const iosTabInset = Platform.OS === "ios" ? Math.max((safeAreaInsets.bottom || 0) - 8, 0) : 0;
  const androidNavInset = Platform.OS === "android" ? Math.max(safeAreaInsets.bottom || 0, 0) : 0;
  const tabBarBottomInset = Platform.OS === "ios" ? iosTabInset : androidNavInset;
  const tabBarBaseHeight = isCompactAndroid ? TAB_BAR_BASE_HEIGHT_COMPACT : TAB_BAR_BASE_HEIGHT;
  const resolvedTabBarHeight = tabBarHeight || tabBarBottomInset + tabBarBaseHeight;
  const androidTabBarExtra = isCompactAndroid ? 4 : 12;
  const tabBarTopPadding = isCompactAndroid ? 10 : 18;
  const tabButtonVerticalPadding = isCompactAndroid ? 10 : 14;
  const tabLabelTopMargin = isCompactAndroid ? 4 : 6;
  const tutorialOverlayInset = resolvedTabBarHeight;
  const tutorialCardOffset = resolvedTabBarHeight + (Platform.OS === "ios" ? 64 : 72);
  const topSafeInset =
    Platform.OS === "android" ? RNStatusBar.currentHeight || 24 : safeAreaInsets.top || 0;
  const [keyboardInset, setKeyboardInset] = useState(0);
  const [keyboardVisible, setKeyboardVisible] = useState(false);

  useEffect(() => {
    const showEvent = Platform.OS === "ios" ? "keyboardWillShow" : "keyboardDidShow";
    const hideEvent = Platform.OS === "ios" ? "keyboardWillHide" : "keyboardDidHide";
    const handleKeyboardShow = (event = {}) => {
      const keyboardHeight = event.endCoordinates?.height || 0;
      const safeGap = Math.max(0, keyboardHeight - tabBarBottomInset);
      const buffer = Platform.OS === "ios" ? 12 : 0;
      setKeyboardInset(safeGap ? safeGap + buffer : buffer);
      setKeyboardVisible(true);
    };
    const handleKeyboardHide = () => {
      setKeyboardInset(0);
      setKeyboardVisible(false);
    };
    const showSub = Keyboard.addListener(showEvent, handleKeyboardShow);
    const hideSub = Keyboard.addListener(hideEvent, handleKeyboardHide);
    return () => {
      showSub.remove();
      hideSub.remove();
    };
  }, [tabBarBottomInset]);
  const shouldRenderStatusGlass = topSafeInset > 0;
  const statusBlurAvailable = useMemo(() => {
    if (!shouldRenderStatusGlass) return false;
    return isBlurViewAvailable();
  }, [shouldRenderStatusGlass]);
  const screenKeyboardAdjustmentStyle = useMemo(() => {
    if (Platform.OS === "ios") return null;
    return keyboardInset ? { paddingBottom: keyboardInset } : null;
  }, [keyboardInset]);
  const fabSlideStyle = useMemo(
    () => ({
      transform: [
        {
          translateX: fabSlideAnim.interpolate({
            inputRange: [0, 1],
            outputRange: [0, FAB_HIDE_TRANSLATE],
          }),
        },
      ],
    }),
    [fabSlideAnim]
  );

  const keyboardModalOffset = useMemo(() => {
    if (!keyboardInset) return 0;
    const effectiveInset =
      Platform.OS === "ios" ? keyboardInset * 0.6 : keyboardInset;
    return Math.min(effectiveInset, MAX_MODAL_KEYBOARD_OFFSET);
  }, [keyboardInset]);

  const modalKeyboardPaddingStyle = useMemo(
    () => (keyboardModalOffset ? { paddingBottom: keyboardModalOffset } : null),
    [keyboardModalOffset]
  );
  const handleRootTouchStart = useCallback(
    (event) => {
      if (!keyboardVisible) return;
      const target = event?.target;
      const targetTag =
        event?.nativeEvent?.target ?? (typeof target === "number" ? target : null);
      const focusedField =
        typeof RNTextInput?.State?.currentlyFocusedField === "function"
          ? RNTextInput.State.currentlyFocusedField()
          : null;
      if (focusedField && targetTag === focusedField) {
        return;
      }
      if (
        target &&
        typeof target !== "number" &&
        typeof RNTextInput?.State?.isTextInput === "function" &&
        RNTextInput.State.isTextInput(target)
      ) {
        return;
      }
      Keyboard.dismiss();
    },
    [keyboardVisible]
  );

  const fabTutorialCutout = useMemo(() => {
    const radius = FAB_TUTORIAL_HALO_SIZE / 2;
    const rightSafeInset = Math.max(safeAreaInsets.right || 0, 0);
    const fallbackCenterX =
      SCREEN_WIDTH - FAB_CONTAINER_SIDE - rightSafeInset - FAB_BUTTON_SIZE / 2;
    const androidStatusBarOffset = Platform.OS === "android" ? RNStatusBar.currentHeight || 0 : 0;
    const fallbackCenterY =
      SCREEN_HEIGHT - (tabBarBottomInset + FAB_CONTAINER_BOTTOM + FAB_BUTTON_SIZE / 2) + androidStatusBarOffset;
    const centerX = fabTutorialAnchor?.x ?? fallbackCenterX;
    const centerY = fabTutorialAnchor?.y ?? fallbackCenterY;
    const top = Math.max(0, centerY - radius);
    const bottom = Math.min(SCREEN_HEIGHT, centerY + radius);
    const left = Math.max(0, centerX - radius);
    const right = Math.min(SCREEN_WIDTH, centerX + radius);
    return {
      top,
      bottom,
      left,
      right,
      height: Math.max(0, bottom - top),
      width: Math.max(0, right - left),
      centerX,
      centerY,
    };
  }, [fabTutorialAnchor, safeAreaInsets.right, tabBarBottomInset]);
  const [analyticsOptOut, setAnalyticsOptOutState] = useState(null);
  const [iosTrackingStatus, setIosTrackingStatus] = useState(null);
  const [iosTrackingResolved, setIosTrackingResolved] = useState(Platform.OS !== "ios");
  const iosTrackingBlocked = useMemo(
    () => isTrackingStatusBlocked(iosTrackingStatus),
    [iosTrackingStatus]
  );
  const facebookInitRef = useRef(false);
  const analyticsConsentGateRef = useRef(false);
  const profileSelectionRef = useRef({ gender: null, persona: null });
  useEffect(() => {
    let cancelled = false;
    const loadTrackingStatus = async () => {
      if (Platform.OS !== "ios") {
        setIosTrackingResolved(true);
        return;
      }
      const getter = TrackingTransparency?.getTrackingPermissionsAsync;
      if (typeof getter !== "function") {
        setIosTrackingResolved(true);
        return;
      }
      try {
        const current = await getter();
        if (cancelled) return;
        setIosTrackingStatus(current?.status || null);
      } catch (error) {
        if (!cancelled) {
          console.warn("tracking status", error);
        }
      } finally {
        if (!cancelled) {
          setIosTrackingResolved(true);
        }
      }
    };
    loadTrackingStatus();
    return () => {
      cancelled = true;
    };
  }, []);
  useEffect(() => {
    if (analyticsOptOut === null) return;
    if (Platform.OS === "ios" && !iosTrackingResolved) return;
    bootstrapMonitoring(analyticsOptOut === false && !iosTrackingBlocked);
  }, [analyticsOptOut, iosTrackingBlocked, iosTrackingResolved]);
  useEffect(() => {
    if (Platform.OS !== "ios") return;
    if (!iosTrackingResolved || !iosTrackingBlocked) return;
    if (analyticsOptOut !== false) return;
    setAnalyticsOptOutState(true);
  }, [analyticsOptOut, iosTrackingBlocked, iosTrackingResolved]);
  useEffect(() => {
    if (facebookInitRef.current) return;
    if (__DEV__) return;
    if (analyticsOptOut !== false) return;
    if (Platform.OS === "ios" && !iosTrackingResolved) return;
    if (Platform.OS === "ios" && iosTrackingBlocked) return;
    if (!FacebookSettings || typeof FacebookSettings.initializeSDK !== "function") return;
    facebookInitRef.current = true;
    try {
      if (typeof FacebookSettings.setAppID === "function") {
        FacebookSettings.setAppID(FACEBOOK_APP_ID);
      }
      FacebookSettings.initializeSDK();
      setFacebookSdkReady(true);
      if (typeof FacebookSettings.setAdvertiserTrackingEnabled === "function") {
        const trackingPromise = FacebookSettings.setAdvertiserTrackingEnabled(true);
        if (trackingPromise?.catch) {
          trackingPromise.catch(() => {});
        }
      }
    } catch (error) {
      console.warn("facebook sdk init", error);
    }
  }, [analyticsOptOut, iosTrackingBlocked, iosTrackingResolved]);
  const [startupLogoVisible, setStartupLogoVisible] = useState(false);
  const startupLogoDismissedRef = useRef(false);
  const markStartupLogoDismissed = useCallback(() => {
    startupLogoDismissedRef.current = true;
    setStartupLogoVisible(false);
  }, []);
  const interfaceReady = useMemo(
    () =>
      onboardingStep === "done" &&
      startupHydrated &&
      fontsReady &&
      homeLayoutReady &&
      !startupLogoVisible,
    [fontsReady, homeLayoutReady, onboardingStep, startupHydrated, startupLogoVisible]
  );
  useEffect(() => {
    if (!pendingWidgetActionRef.current) return;
    if (!interfaceReady) return;
    const action = pendingWidgetActionRef.current;
    clearWidgetAction();
    InteractionManager.runAfterInteractions(() => {
      if (!action) return;
      if (!premiumState.isPremium) {
        showPremiumPaywallRef.current?.({
          kind: "feature",
          featureKey: PREMIUM_FEATURE_KEYS.homeWidget,
        });
        return;
      }
      if (action.type === "quick-entry") {
        const preset =
          action.presetAction === "spend" || action.presetAction === "save"
            ? action.presetAction
            : "save";
        openCoinEntry(`widget_${preset}`, preset);
        return;
      }
      if (action.type === "add-temptation") {
        handleFabNewTemptation();
      }
    });
  }, [
    clearWidgetAction,
    handleFabNewTemptation,
    interfaceReady,
    openCoinEntry,
    pendingWidgetAction,
    premiumState.isPremium,
  ]);
  const speechInterfaceReady = useMemo(
    () => onboardingStep === "done" && !startupLogoVisible,
    [onboardingStep, startupLogoVisible]
  );
  const speechAllowed = useMemo(
    () =>
      speechInterfaceReady &&
      activeTab === "feed" &&
      !overlay &&
      !dailySummaryVisible &&
      !tutorialOverlayVisible &&
      !tamagotchiVisible &&
      !skinPickerVisible &&
      !coinEntryVisible &&
      !breakdownVisible &&
      !incomeEntryModalVisible &&
      !editOverlayVisible &&
      !priceEditor.item &&
      !newPendingModal.visible &&
      !newGoalModal.visible &&
      !ratingPromptVisible &&
      !termsModalVisible &&
      !fabMenuVisible &&
      !coinValueModalVisible &&
      !dailyRewardModalVisible &&
      !goalRenewalPromptVisible &&
      !moodDetailsVisible &&
      !potentialDetailsVisible &&
      !addCategoryModalVisible &&
      !pushDayThreePromptVisible &&
      !potentialGrowthVisible &&
      !tutorialVisible &&
      !temptationTutorialVisible &&
      !fabTutorialVisible &&
      !queuedModalType &&
      !levelShareModal.visible &&
      !startupLogoVisible &&
      !keyboardVisible,
    [
      activeTab,
      addCategoryModalVisible,
      coinEntryVisible,
      coinValueModalVisible,
      dailyRewardModalVisible,
      dailySummaryVisible,
      incomeEntryModalVisible,
      editOverlayVisible,
      fabMenuVisible,
      fabTutorialVisible,
      goalRenewalPromptVisible,
      speechInterfaceReady,
      keyboardVisible,
      levelShareModal.visible,
      moodDetailsVisible,
      newGoalModal.visible,
      newPendingModal.visible,
      overlay,
      potentialDetailsVisible,
      potentialGrowthVisible,
      priceEditor.item,
      pushDayThreePromptVisible,
      queuedModalType,
      ratingPromptVisible,
      breakdownVisible,
      skinPickerVisible,
      startupLogoVisible,
      tamagotchiVisible,
      temptationTutorialVisible,
      termsModalVisible,
      tutorialOverlayVisible,
      tutorialVisible,
    ]
  );
  const heroCarouselSecondDayAllowed = useMemo(() => {
    const joinedAtTimestamp = profile?.joinedAt
      ? new Date(profile.joinedAt).getTime()
      : NaN;
    if (!Number.isFinite(joinedAtTimestamp)) return false;
    const todayDate = parseDayKey(currentDayKey) || new Date();
    const ordinalDay = Math.floor((todayDate.getTime() - joinedAtTimestamp) / DAY_MS) + 1;
    return ordinalDay === 2;
  }, [profile?.joinedAt, currentDayKey]);
  const heroCarouselHintAllowed = useMemo(
    () => interfaceReady && speechAllowed && heroCarouselSecondDayAllowed,
    [interfaceReady, speechAllowed, heroCarouselSecondDayAllowed]
  );
  useEffect(() => {
    if (activeTab !== "feed") return;
    if (!speechInterfaceReady) return;
    setSpeechWarmupTick((prev) => prev + 1);
  }, [activeTab, speechInterfaceReady]);
  const pendingHomeSpeechRef = useRef(null);
  const queueHomeSpeech = useCallback(
    (reason = "unknown") => {
      if (!reason) return;
      if (speechAllowed) {
        triggerHomeSpeech(reason);
        return;
      }
      const current = pendingHomeSpeechRef.current;
      if (!current) {
        pendingHomeSpeechRef.current = reason;
        return;
      }
      const currentPriority = TAMAGOTCHI_SPEECH_REASON_PRIORITY[current] || 0;
      const nextPriority = TAMAGOTCHI_SPEECH_REASON_PRIORITY[reason] || 0;
      if (nextPriority >= currentPriority) {
        pendingHomeSpeechRef.current = reason;
      }
    },
    [speechAllowed, triggerHomeSpeech]
  );
  useEffect(() => {
    if (!speechAllowed) return;
    if (!pendingHomeSpeechRef.current) return;
    const reason = pendingHomeSpeechRef.current;
    pendingHomeSpeechRef.current = null;
    triggerHomeSpeech(reason);
  }, [speechAllowed, triggerHomeSpeech]);
  useEffect(() => {
    if (activeTab !== "feed") return;
    if (homeSpeechBootedRef.current) return;
    homeSpeechBootedRef.current = true;
    queueHomeSpeech("ready");
  }, [activeTab, queueHomeSpeech]);
  useEffect(() => {
    if (!speechAllowed) return;
    if (homeSpeechReadyRef.current) return;
    if (homeSpeechTrigger.tick > 0) return;
    const timer = setTimeout(() => {
      if (!speechAllowed) return;
      if (homeSpeechReadyRef.current) return;
      if (homeSpeechTrigger.tick > 0) return;
      homeSpeechReadyRef.current = true;
      queueHomeSpeech("ready");
    }, 200);
    return () => clearTimeout(timer);
  }, [homeSpeechTrigger.tick, queueHomeSpeech, speechAllowed]);
  useEffect(() => {
    coinValueModalStatusRef.current = coinValueModalStatus;
  }, [coinValueModalStatus]);
  const canQueueCoinValueModal = useCallback(() => {
    if (!coinValueModalHydrated) return false;
    if (!tutorialSeen) return false;
    if (declineCount < 2) return false;
    if (coinValueModalStatusRef.current !== "none") return false;
    if (pendingUsageStreakRef.current) return false;
    const currentCoins = Math.max(0, Number(tamagotchiState?.coins) || 0);
    if (currentCoins <= 0) return false;
    const lastSaveAt = Number(lastSaveActionAtRef.current) || 0;
    const lastSaveDismissedAt = Number(lastSaveOverlayDismissedAtRef.current) || 0;
    if (!lastSaveAt || lastSaveDismissedAt < lastSaveAt) return false;
    return true;
  }, [coinValueModalHydrated, declineCount, tamagotchiState?.coins, tutorialSeen]);
  useEffect(() => {
    if (tutorialSeen && !tutorialSeenPrevRef.current) {
      coinBalancePrevRef.current = 0;
    }
    tutorialSeenPrevRef.current = tutorialSeen;
  }, [tutorialSeen]);
  useEffect(() => {
    const currentCoins = Math.max(0, Number(tamagotchiState?.coins) || 0);
    const previousCoins = Math.max(0, Number(coinBalancePrevRef.current) || 0);
    coinBalancePrevRef.current = currentCoins;
    if (!coinValueModalHydrated) return;
    if (!tutorialSeen) return;
    if (previousCoins <= 0 && currentCoins > 0 && canQueueCoinValueModal()) {
      queueCoinValueModal();
    }
  }, [canQueueCoinValueModal, coinValueModalHydrated, queueCoinValueModal, tamagotchiState?.coins, tutorialSeen]);
  useEffect(() => {
    if (!canQueueCoinValueModal()) return;
    queueCoinValueModal();
  }, [canQueueCoinValueModal, queueCoinValueModal, overlay]);
  const overlayEnvironmentReady = interfaceReady && !dailySummaryVisible && !tutorialOverlayVisible;
  const ensureOverlayEnvironmentReady = useCallback(() => {
    if (
      onboardingStep === "done" &&
      !homeLayoutReady &&
      !startupLogoVisible &&
      !dailySummaryVisible
    ) {
      setHomeLayoutReady(true);
    }
  }, [dailySummaryVisible, homeLayoutReady, onboardingStep, startupLogoVisible]);
  useEffect(() => {
    if (onboardingStep !== "done") return;
    if (!primaryTemptationPromptHydrated) return;
    if (primaryTemptationPromptState !== "pending") return;
    if (!profile?.customSpend) return;
    const hasPrimaryGoal = Array.isArray(profile.primaryGoals) && profile.primaryGoals.length > 0;
    const primaryGoalReady = !hasPrimaryGoal || !!mainGoalWish?.id;
    if (!primaryGoalReady) return;
    if (!primaryTemptationId) {
      markPrimaryTemptationPromptDone();
      return;
    }
    if (!tutorialSeen || tutorialVisible) return;
    if (tutorialOverlayVisible) return;
    if (temptationTutorialStatus !== "done") return;
    if (!temptationTutorialCompleted || temptationTutorialVisible) return;
    triggerOverlayState("primary_temptation", { templateId: primaryTemptationId });
    markPrimaryTemptationPromptDone();
  }, [
    markPrimaryTemptationPromptDone,
    onboardingStep,
    primaryTemptationId,
    primaryTemptationPromptHydrated,
    primaryTemptationPromptState,
    mainGoalWish?.id,
    profile?.customSpend,
    profile.primaryGoals,
    temptationTutorialCompleted,
    temptationTutorialStatus,
    temptationTutorialVisible,
    triggerOverlayState,
    tutorialSeen,
    tutorialVisible,
    tutorialOverlayVisible,
  ]);

  const goToOnboardingStep = useCallback(
    (nextStep, { recordHistory = true, resetHistory = false } = {}) => {
      if (resetHistory) {
        onboardingHistoryRef.current = [];
        setCanGoBackOnboarding(false);
      }
      setOnboardingStep((prev) => {
        if (recordHistory && prev && prev !== nextStep) {
          const nextHistory = [...onboardingHistoryRef.current, prev];
          onboardingHistoryRef.current = nextHistory;
          setCanGoBackOnboarding(nextHistory.length > 0);
        }
        return nextStep;
      });
    },
    []
  );

  const handleOnboardingBack = useCallback(() => {
    if (!onboardingHistoryRef.current.length) return;
    const history = [...onboardingHistoryRef.current];
    const prevStep = history.pop();
    onboardingHistoryRef.current = history;
    setCanGoBackOnboarding(history.length > 0);
    setOnboardingStep(prevStep);
  }, []);
  const canShowOnboardingSkip =
    !onboardingSkipLocked &&
    onboardingStep !== "done" &&
    onboardingStep !== "logo" &&
    onboardingStep !== "language" &&
    onboardingStep !== "analytics_consent";
  useEffect(() => {
    if (onboardingStep !== "goal") return;
    if (goalSelectionTouchedRef.current) return;
    setRegistrationData((prev) => {
      const hasSelections = Array.isArray(prev.goalSelections) && prev.goalSelections.length > 0;
      const hasTargets = prev.goalTargetMap && Object.keys(prev.goalTargetMap).length > 0;
      const hasConfirmed =
        Array.isArray(prev.goalTargetConfirmed) && prev.goalTargetConfirmed.length > 0;
      if (!hasSelections && !hasTargets && !hasConfirmed) {
        return prev;
      }
      return {
        ...prev,
        goalSelections: [],
        goalTargetMap: {},
        goalTargetConfirmed: [],
      };
    });
  }, [onboardingStep, setRegistrationData]);
  const stormTimerRef = useRef(null);
  const [rewardCelebratedMap, setRewardCelebratedMap] = useState({});
  const [rewardCelebratedHydrated, setRewardCelebratedHydrated] = useState(false);
  const persistRewardCelebrations = useCallback(
    (updater) => {
      setRewardCelebratedMap((prev) => {
        const source = prev && typeof prev === "object" ? prev : {};
        const next = typeof updater === "function" ? updater(source) : updater || {};
        if (rewardCelebratedHydrated) {
          AsyncStorage.setItem(
            STORAGE_KEYS.REWARDS_CELEBRATED,
            JSON.stringify(next)
          ).catch(() => {});
        }
        return next;
      });
    },
    [rewardCelebratedHydrated]
  );
  const [rewardsReady, setRewardsReady] = useState(false);
  const challengesPrevRef = useRef(challengesState);
  const [temptationGoalMap, setTemptationGoalMap] = useState({});
  const [temptationGoalMapHydrated, setTemptationGoalMapHydrated] = useState(false);
  const [goalLinkPrompt, setGoalLinkPrompt] = useState({
    visible: false,
    item: null,
    intent: null,
    amountUSD: null,
  });
  const [goalTemptationPrompt, setGoalTemptationPrompt] = useState({ visible: false, wish: null });
  const [goalEditorPrompt, setGoalEditorPrompt] = useState({
    visible: false,
    wish: null,
    name: "",
    target: "",
    emoji: DEFAULT_GOAL_EMOJI,
  });
  const [baselinePrompt, setBaselinePrompt] = useState({
    visible: false,
    value: "",
    currency: DEFAULT_PROFILE.currency,
  });
  const [goalRenewalPromptVisible, setGoalRenewalPromptVisible] = useState(false);
  const goalRenewalPromptPendingRef = useRef(false);
  const goalRenewalPromptAfterGoalRef = useRef(false);
  const dismissGoalRenewalPrompt = useCallback(() => {
    goalRenewalPromptPendingRef.current = false;
    setGoalRenewalPromptVisible(false);
  }, []);
  const requestGoalRenewalPrompt = useCallback(() => {
    if (goalRenewalPromptVisible) return;
    if (overlay) {
      goalRenewalPromptPendingRef.current = true;
      return;
    }
    goalRenewalPromptPendingRef.current = false;
    setGoalRenewalPromptVisible(true);
  }, [goalRenewalPromptVisible, overlay]);
  const dailyChallengePromptAllowed = useMemo(
    () =>
      interfaceReady &&
      activeTab === "feed" &&
      !dailySummaryVisible &&
      !tutorialOverlayVisible &&
      !overlay &&
      !tamagotchiVisible &&
      !newGoalModal.visible &&
      !onboardingGoalModal.visible &&
      !goalTemptationPrompt.visible &&
      !goalEditorPrompt.visible &&
      !baselinePrompt.visible &&
      !goalRenewalPromptVisible &&
      !goalLinkPrompt.visible &&
      !skinPickerVisible &&
      !priceEditor.item &&
      !breakdownVisible,
    [
      activeTab,
      baselinePrompt.visible,
      dailySummaryVisible,
      goalEditorPrompt.visible,
      goalLinkPrompt.visible,
      goalRenewalPromptVisible,
      goalTemptationPrompt.visible,
      interfaceReady,
      newGoalModal.visible,
      onboardingGoalModal.visible,
      overlay,
      priceEditor.item,
      breakdownVisible,
      skinPickerVisible,
      tamagotchiVisible,
      tutorialOverlayVisible,
    ]
  );
  const dailyChallengePromptVisible = queuedModalType === QUEUED_MODAL_TYPES.DAILY_CHALLENGE;
  const dailyChallengeCompleteVisible =
    queuedModalType === QUEUED_MODAL_TYPES.DAILY_CHALLENGE_COMPLETE;
  const [dailyChallengeDrawnIndex, setDailyChallengeDrawnIndex] = useState(null);
  const dailyChallengeRevealAnim = useRef(new Animated.Value(0)).current;
  const dailyChallengeSelectAnim = useRef(new Animated.Value(0)).current;
  const dailyChallengeCardIntroAnims = useRef(
    Array.from({ length: DAILY_CHALLENGE_DRAW_COUNT }, () => new Animated.Value(0))
  ).current;
  const dailyChallengeCardFloatAnims = useRef(
    Array.from({ length: DAILY_CHALLENGE_DRAW_COUNT }, () => new Animated.Value(0))
  ).current;
  const dailyChallengeFloatLoopsRef = useRef([]);
  const dailyChallengeCompleteAnim = useRef(new Animated.Value(0)).current;
  const dailyChallengeCardAccents = useMemo(() => {
    const palette = CARD_TEXTURE_ACCENTS.length
      ? CARD_TEXTURE_ACCENTS
      : ["#8AB9FF", "#FFA4C0", "#8CE7CF"];
    const seed = (dailyChallenge?.templateId || "").length;
    return Array.from({ length: DAILY_CHALLENGE_DRAW_COUNT }, (_, index) => {
      const offset = (seed + index) % palette.length;
      return palette[offset] || palette[0];
    });
  }, [dailyChallenge?.templateId]);
  const dailyChallengeDrawn = dailyChallengeDrawnIndex !== null;
  useEffect(() => {
    if (!dailyChallengePromptVisible) return;
    setDailyChallengeDrawnIndex(null);
    dailyChallengeRevealAnim.setValue(0);
    dailyChallengeSelectAnim.setValue(0);
    dailyChallengeCardIntroAnims.forEach((anim) => anim.setValue(0));
    dailyChallengeCardFloatAnims.forEach((anim) => anim.setValue(0));
    const introAnimations = dailyChallengeCardIntroAnims.map((anim) =>
      Animated.spring(anim, {
        toValue: 1,
        useNativeDriver: true,
        friction: 7,
        tension: 80,
      })
    );
    Animated.stagger(120, introAnimations).start();
    dailyChallengeFloatLoopsRef.current.forEach((loop) => loop?.stop?.());
    dailyChallengeFloatLoopsRef.current = dailyChallengeCardFloatAnims.map((anim, index) => {
      const duration = 1700 + index * 140;
      const loop = Animated.loop(
        Animated.sequence([
          Animated.delay(180 + index * 120),
          Animated.timing(anim, {
            toValue: 1,
            duration,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
          Animated.timing(anim, {
            toValue: 0,
            duration,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
        ])
      );
      loop.start();
      return loop;
    });
    return () => {
      dailyChallengeFloatLoopsRef.current.forEach((loop) => loop?.stop?.());
      dailyChallengeFloatLoopsRef.current = [];
    };
  }, [
    dailyChallengeCardFloatAnims,
    dailyChallengeCardIntroAnims,
    dailyChallengePromptVisible,
    dailyChallengeRevealAnim,
    dailyChallengeSelectAnim,
  ]);
  useEffect(() => {
    if (!dailyChallengeCompleteVisible) return;
    dailyChallengeCompleteAnim.setValue(0);
    Animated.timing(dailyChallengeCompleteAnim, {
      toValue: 1,
      duration: 420,
      easing: Easing.out(Easing.exp),
      useNativeDriver: true,
    }).start();
  }, [dailyChallengeCompleteAnim, dailyChallengeCompleteVisible]);
  const handleDailyChallengeDrawSelect = useCallback(
    (index) => {
      setDailyChallengeDrawnIndex((prev) => {
        if (prev !== null) return prev;
        triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
        dailyChallengeRevealAnim.setValue(0);
        dailyChallengeSelectAnim.setValue(0);
        Animated.parallel([
          Animated.timing(dailyChallengeRevealAnim, {
            toValue: 1,
            duration: 520,
            easing: Easing.out(Easing.exp),
            useNativeDriver: true,
          }),
          Animated.spring(dailyChallengeSelectAnim, {
            toValue: 1,
            useNativeDriver: true,
            friction: 6,
            tension: 80,
          }),
        ]).start();
        return index;
      });
    },
    [dailyChallengeRevealAnim, dailyChallengeSelectAnim]
  );
  const coinValueModalAllowed = useMemo(
    () =>
      interfaceReady &&
      onboardingStep === "done" &&
      tutorialSeen &&
      activeTab === "feed" &&
      !dailySummaryVisible &&
      !tutorialOverlayVisible &&
      !overlay &&
      !tamagotchiVisible &&
      !newGoalModal.visible &&
      !onboardingGoalModal.visible &&
      !goalTemptationPrompt.visible &&
      !goalEditorPrompt.visible &&
      !baselinePrompt.visible &&
      !goalRenewalPromptVisible &&
      !goalLinkPrompt.visible &&
      !skinPickerVisible &&
      !priceEditor.item &&
      !breakdownVisible &&
      !spendPrompt.visible &&
      !dailyChallengePromptVisible &&
      !dailyChallengeCompleteVisible,
    [
      activeTab,
      baselinePrompt.visible,
      dailyChallengeCompleteVisible,
      dailyChallengePromptVisible,
      dailySummaryVisible,
      goalEditorPrompt.visible,
      goalLinkPrompt.visible,
      goalRenewalPromptVisible,
      goalTemptationPrompt.visible,
      interfaceReady,
      newGoalModal.visible,
      onboardingGoalModal.visible,
      onboardingStep,
      overlay,
      priceEditor.item,
      breakdownVisible,
      skinPickerVisible,
      spendPrompt.visible,
      tamagotchiVisible,
      tutorialOverlayVisible,
      tutorialSeen,
    ]
  );
  const canShowCoinValueModalNow = useCallback(() => {
    if (!coinValueModalAllowed || coinValueModalVisible) return false;
    if (premiumSoftPaywallPending || premiumPaywallState.visible) return false;
    if (queuedModalType || queuedModalActiveRef.current) return false;
    const hasQueuedModalReady = queuedModalQueueRef.current.some((candidate) =>
      canShowQueuedModalRef.current(candidate)
    );
    if (hasQueuedModalReady) return false;
    if (overlay || overlayActiveRef.current) return false;
    if (pendingUsageStreakRef.current) return false;
    if (overlayQueueRef.current.length) return false;
    if (celebrationQueueRef.current.length) return false;
    if (celebrationGapTimerRef.current) return false;
    if (blockingModalVisible) return false;
    if (tutorialBlockingVisibleRef.current) return false;
    const lastSaveAt = Number(lastSaveActionAtRef.current) || 0;
    const lastSaveDismissedAt = Number(lastSaveOverlayDismissedAtRef.current) || 0;
    if (lastSaveAt > lastSaveDismissedAt && Date.now() - lastSaveAt < 15000) {
      return false;
    }
    const lastDismissedAt = lastOverlayDismissedAtRef.current || 0;
    if (Date.now() - lastDismissedAt < 600) return false;
    if (Date.now() - lastSaveDismissedAt < 900) return false;
    return true;
  }, [
    blockingModalVisible,
    coinValueModalAllowed,
    coinValueModalVisible,
    overlay,
    premiumPaywallState.visible,
    premiumSoftPaywallPending,
    queuedModalType,
  ]);
  useEffect(() => {
    if (!coinValueModalHydrated) return undefined;
    if (coinValueModalStatus !== COIN_VALUE_MODAL_STATUS.PENDING) {
      if (coinValueModalCheckTimerRef.current) {
        clearTimeout(coinValueModalCheckTimerRef.current);
        coinValueModalCheckTimerRef.current = null;
      }
      return undefined;
    }
    const checkAndShow = () => {
      if (canShowCoinValueModalNow()) {
        setCoinValueModalVisible(true);
        coinValueModalCheckTimerRef.current = null;
        return;
      }
      coinValueModalCheckTimerRef.current = setTimeout(checkAndShow, 250);
    };
    checkAndShow();
    return () => {
      if (coinValueModalCheckTimerRef.current) {
        clearTimeout(coinValueModalCheckTimerRef.current);
        coinValueModalCheckTimerRef.current = null;
      }
    };
  }, [canShowCoinValueModalNow, coinValueModalHydrated, coinValueModalStatus]);
  const dismissCoinValueModal = useCallback(() => {
    setCoinValueModalVisible(false);
    if (coinValueModalStatusRef.current === COIN_VALUE_MODAL_STATUS.SHOWN) return;
    coinValueModalStatusRef.current = COIN_VALUE_MODAL_STATUS.SHOWN;
    setCoinValueModalStatus(COIN_VALUE_MODAL_STATUS.SHOWN);
    AsyncStorage.setItem(
      STORAGE_KEYS.COIN_VALUE_MODAL,
      COIN_VALUE_MODAL_STATUS.SHOWN
    ).catch(() => {});
  }, []);
  useEffect(() => {
    if (!coinValueModalVisible) return undefined;
    if (activeTab !== "feed") return undefined;
    const frame = requestAnimationFrame(() => {
      const scroller = feedScreenRef.current;
      if (scroller && typeof scroller.scrollToTop === "function") {
        scroller.scrollToTop({ animated: true });
      }
    });
    return () => {
      cancelAnimationFrame(frame);
    };
  }, [activeTab, coinValueModalVisible]);
  const openBaselinePrompt = useCallback(() => {
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const existingUSD = Math.max(0, Number(profile.spendingProfile?.baselineMonthlyWasteUSD) || 0);
    const existingLocal =
      existingUSD > 0
        ? formatNumberInputValue(convertToCurrency(existingUSD, currencyCode))
        : "";
    setBaselinePrompt({
      visible: true,
      value: existingLocal,
      currency: currencyCode,
    });
  }, [profile.currency, profile.spendingProfile?.baselineMonthlyWasteUSD]);
  const closeBaselinePrompt = useCallback(() => {
    setBaselinePrompt((prev) => ({ ...prev, visible: false }));
  }, []);
  const handleBaselinePromptChange = useCallback((text) => {
    setBaselinePrompt((prev) => ({ ...prev, value: text }));
  }, []);
  const handleBaselinePromptSubmit = useCallback(() => {
    const trimmed = (baselinePrompt.value || "").trim();
    const parsed = parseNumberInputValue(trimmed);
    if (!Number.isFinite(parsed) || parsed <= 0) {
      Alert.alert("Almost", t("baselineInputError"));
      return;
    }
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const baselineMonthlyWasteUSD = convertFromCurrency(parsed, currencyCode);
    const timestamp = new Date().toISOString();
    const nextSpendingProfile = {
      ...(profile.spendingProfile || { ...DEFAULT_PROFILE.spendingProfile }),
      baselineMonthlyWasteUSD,
      baselineStartAt: timestamp,
    };
    const previousBaselineUSD = Math.max(
      0,
      Number(profile.spendingProfile?.baselineMonthlyWasteUSD) || 0
    );
    if (previousBaselineUSD !== baselineMonthlyWasteUSD) {
      logEvent("profile_baseline_updated", {
        previous_usd: previousBaselineUSD,
        baseline_usd: baselineMonthlyWasteUSD,
        currency: currencyCode,
      });
    }
    setProfile((prev) => ({
      ...prev,
      spendingProfile: nextSpendingProfile,
    }));
    setProfileDraft((prev) => ({
      ...prev,
      spendingProfile: nextSpendingProfile,
    }));
    setBaselinePrompt((prev) => ({ ...prev, visible: false }));
  }, [
    baselinePrompt.value,
    logEvent,
    profile.currency,
    profile.spendingProfile,
    setProfile,
    setProfileDraft,
    t,
    focusModeUnlocked,
  ]);
  const [moodDetailsVisible, setMoodDetailsVisible] = useState(false);
  const [potentialDetailsVisible, setPotentialDetailsVisible] = useState(false);
  const [potentialDetailsText, setPotentialDetailsText] = useState("");
  const tutorialBlockingVisible = useMemo(
    () =>
      blockingModalVisible ||
      overlay ||
      dailySummaryVisible ||
      ratingPromptVisible ||
      pushDayThreePromptVisible ||
      levelShareModal.visible ||
      coinEntryVisible ||
      showCustomSpend ||
      newPendingModal.visible ||
      showImageSourceSheet ||
      termsModalVisible ||
      spendPrompt.visible ||
      stormActive ||
      moodDetailsVisible ||
      potentialDetailsVisible ||
      budgetWidgetTutorialVisible ||
      fabMenuVisible ||
      editOverlayVisible,
    [
      blockingModalVisible,
      coinEntryVisible,
      dailySummaryVisible,
      editOverlayVisible,
      fabMenuVisible,
      levelShareModal.visible,
      moodDetailsVisible,
      newPendingModal.visible,
      overlay,
      potentialDetailsVisible,
      budgetWidgetTutorialVisible,
      pushDayThreePromptVisible,
      ratingPromptVisible,
      showCustomSpend,
      showImageSourceSheet,
      spendPrompt.visible,
      stormActive,
      termsModalVisible,
    ]
  );
  useEffect(() => {
    tutorialBlockingVisibleRef.current = tutorialBlockingVisible;
  }, [tutorialBlockingVisible]);
  const proThemeAccentOption = useMemo(
    () => resolveProThemeAccentOption(proThemeAccentId),
    [proThemeAccentId]
  );
  const proThemeAccentColor = proThemeAccentOption.accent;
  const colors = useMemo(
    () => resolveThemeColors(theme, proThemeAccentId),
    [proThemeAccentId, theme]
  );
  const proThemeAccentCopy = useMemo(
    () => PRO_THEME_ACCENT_COPY[normalizeLanguage(language)] || PRO_THEME_ACCENT_COPY.en,
    [language]
  );
  const isDarkTheme = theme === "dark";
  const isProTheme = theme === PRO_THEME_ID;
  const openMoodDetails = useCallback(() => setMoodDetailsVisible(true), []);
  const closeMoodDetails = useCallback(() => setMoodDetailsVisible(false), []);
  const openPotentialDetails = useCallback((description) => {
    setPotentialDetailsText(description);
    setPotentialDetailsVisible(true);
  }, []);
  const closePotentialDetails = useCallback(() => setPotentialDetailsVisible(false), []);
  const switchToSavingsBreakdown = useCallback(() => setBreakdownMode("save"), []);
  const switchToSpendBreakdown = useCallback(() => setBreakdownMode("spend"), []);
  const openSavingsBreakdown = useCallback(() => {
    setBreakdownMode("save");
    setSaveBreakdownRange("day");
    setSaveBreakdownOffset(0);
    setBreakdownVisible(true);
  }, []);
  const openSpendBreakdown = useCallback(() => {
    setBreakdownMode("spend");
    setSpendBreakdownRange("day");
    setSpendBreakdownOffset(0);
    setBreakdownVisible(true);
  }, []);
  const closeBreakdown = useCallback(() => setBreakdownVisible(false), []);
  const closeReportsModal = useCallback(() => setReportsModalVisible(false), []);
  const buildAndStoreReportsSnapshot = useCallback(
    ({ history = resolvedHistoryEvents, now = Date.now() } = {}) => {
      const snapshot = buildReportsSnapshot({
        history,
        language,
        currency: profile.currency || DEFAULT_PROFILE.currency,
        resolveTemplateTitle,
        t,
        now,
        joinedAt: profile.joinedAt,
      });
      setProfile((prev) => {
        if (reportsSnapshotsEquivalent(prev?.reports, snapshot)) {
          return prev;
        }
        return { ...prev, reports: snapshot };
      });
      setProfileDraft((prev) => {
        if (reportsSnapshotsEquivalent(prev?.reports, snapshot)) {
          return prev;
        }
        return { ...prev, reports: snapshot };
      });
      return snapshot;
    },
    [language, profile.currency, profile.joinedAt, resolveTemplateTitle, resolvedHistoryEvents, t]
  );
  const handleReportsPress = useCallback(() => {
    if (!reportsUnlocked) {
      ensurePremiumFeatureAccess(PREMIUM_FEATURE_KEYS.reports);
      return;
    }
    triggerHaptic();
    buildAndStoreReportsSnapshot();
    setReportsTab("weekly");
    setReportsBadgeVisible(false);
    setReportsModalVisible(true);
  }, [buildAndStoreReportsSnapshot, ensurePremiumFeatureAccess, reportsUnlocked, triggerHaptic]);
  const openReportsFromNotification = useCallback(() => {
    if (!reportsUnlocked) {
      ensurePremiumFeatureAccess(PREMIUM_FEATURE_KEYS.reports);
      return;
    }
    buildAndStoreReportsSnapshot();
    setReportsTab("weekly");
    setReportsBadgeVisible(false);
    setReportsModalVisible(true);
    goToTab("profile");
  }, [buildAndStoreReportsSnapshot, ensurePremiumFeatureAccess, goToTab, reportsUnlocked]);
  const reportsHistoryDigest = useMemo(() => {
    const first = resolvedHistoryEvents[0];
    const firstTimestamp = Number(first?.timestamp) || 0;
    return `${resolvedHistoryEvents.length}_${firstTimestamp}`;
  }, [resolvedHistoryEvents]);
  useEffect(() => {
    if (!historyHydrated || !profileHydrated) return;
    const digest = reportsHistoryDigest;
    const dayKey = currentDayKey;
    const prev = reportsAutoUpdateRef.current;
    if (prev.dayKey === dayKey && prev.digest === digest) return;
    reportsAutoUpdateRef.current = { dayKey, digest };
    buildAndStoreReportsSnapshot();
  }, [
    buildAndStoreReportsSnapshot,
    currentDayKey,
    historyHydrated,
    profileHydrated,
    reportsHistoryDigest,
  ]);
  const maybeAutoGenerateWeeklyReport = useCallback(
    (nowTs = Date.now()) => {
      if (!historyHydrated || !profileHydrated) return false;
      const nowDate = new Date(nowTs);
      const weekKey = getReportWeekKey(nowDate);
      if (!weekKey) return false;
      const weekday = nowDate.getDay();
      const isReportDay = weekday === 5 || weekday === 6 || weekday === 0;
      if (!isReportDay) return false;
      if (reportsLastAutoWeekRef.current === weekKey) return false;
      const snapshot = buildAndStoreReportsSnapshot({ now: nowTs });
      if (!reportsSnapshotHasMeaningfulData(snapshot)) {
        setReportsBadgeVisible(false);
        return false;
      }
      reportsLastAutoWeekRef.current = weekKey;
      setReportsLastAutoWeekKey(weekKey);
      setReportsBadgeVisible(true);
      return true;
    },
    [buildAndStoreReportsSnapshot, historyHydrated, profileHydrated]
  );
  useEffect(() => {
    if (!reportsBadgeHydrated || !reportsLastAutoWeekHydrated) return;
    maybeAutoGenerateWeeklyReport(Date.now());
  }, [currentDayKey, maybeAutoGenerateWeeklyReport, reportsBadgeHydrated, reportsLastAutoWeekHydrated]);
  useEffect(() => {
    if (!reportsBadgeHydrated) return;
    if (reportsHaveData) return;
    if (!reportsBadgeVisible) return;
    setReportsBadgeVisible(false);
  }, [reportsBadgeHydrated, reportsBadgeVisible, reportsHaveData]);
  const setBreakdownRangeMode = useCallback(
    (next) => {
      if (breakdownMode === "spend") {
        setSpendBreakdownRange(next);
        setSpendBreakdownOffset(0);
        return;
      }
      setSaveBreakdownRange(next);
      setSaveBreakdownOffset(0);
    },
    [breakdownMode]
  );
  const handleBreakdownPrev = useCallback(() => {
    if (breakdownMode === "spend") {
      setSpendBreakdownOffset((prev) => prev + 1);
      return;
    }
    setSaveBreakdownOffset((prev) => prev + 1);
  }, [breakdownMode]);
  const handleBreakdownNext = useCallback(() => {
    if (breakdownMode === "spend") {
      setSpendBreakdownOffset((prev) => Math.max(0, prev - 1));
      return;
    }
    setSaveBreakdownOffset((prev) => Math.max(0, prev - 1));
  }, [breakdownMode]);
  const activeBreakdownRange = breakdownMode === "spend" ? spendBreakdownRange : saveBreakdownRange;
  const activeBreakdownOffset = breakdownMode === "spend" ? spendBreakdownOffset : saveBreakdownOffset;
  const renderBreakdownModeToggle = useCallback(
    (activeMode) => (
      <View style={[styles.breakdownModeToggle, { backgroundColor: colors.card, borderColor: colors.border }]}>
        {[
          {
            id: "save",
            icon: "shield",
            label: "+",
            color: BREAKDOWN_TOGGLE_SAVE_COLOR,
            onPress: switchToSavingsBreakdown,
          },
          {
            id: "spend",
            label: "-",
            color: BREAKDOWN_TOGGLE_SPEND_COLOR,
            onPress: switchToSpendBreakdown,
          },
        ].map((entry) => {
          const isActive = activeMode === entry.id;
          const iconColor = isActive ? "#FFFFFF" : entry.color;
          return (
            <TouchableOpacity
              key={entry.id}
              onPress={entry.onPress}
              activeOpacity={0.85}
              disabled={isActive}
              style={[
                styles.breakdownModeToggleOption,
                isActive && styles.breakdownModeToggleOptionActive,
                { borderColor: entry.color, backgroundColor: isActive ? entry.color : "transparent" },
              ]}
            >
              {entry.icon === "shield" ? (
                <Svg width={12} height={12} viewBox="0 0 24 24">
                  <SvgPath d={BREAKDOWN_TOGGLE_SHIELD_PATH} fill={iconColor} />
                </Svg>
              ) : (
                <Text style={[styles.breakdownModeToggleText, { color: iconColor }]} numberOfLines={1}>
                  {entry.label}
                </Text>
              )}
            </TouchableOpacity>
          );
        })}
      </View>
    ),
    [colors.border, colors.card, switchToSavingsBreakdown, switchToSpendBreakdown]
  );
  const blockingModalVisible = useMemo(
    () =>
      breakdownVisible ||
      reportsModalVisible ||
      dailyChallengePromptVisible ||
      dailyChallengeCompleteVisible ||
      tamagotchiVisible ||
      levelShareModal.visible ||
      incomeEntryModalVisible ||
      newGoalModal.visible ||
      onboardingGoalModal.visible ||
      goalTemptationPrompt.visible ||
      goalEditorPrompt.visible ||
      baselinePrompt.visible ||
      goalRenewalPromptVisible ||
      goalLinkPrompt.visible ||
      skinPickerVisible ||
      dailyGoalCollectModal.visible ||
      premiumPaywallState.visible ||
      priceEditor.item,
    [
      baselinePrompt.visible,
      dailyChallengePromptVisible,
      dailyChallengeCompleteVisible,
      levelShareModal.visible,
      goalEditorPrompt.visible,
      goalLinkPrompt.visible,
      goalRenewalPromptVisible,
      goalTemptationPrompt.visible,
      newGoalModal.visible,
      onboardingGoalModal.visible,
      priceEditor.item,
      premiumPaywallState.visible,
      breakdownVisible,
      reportsModalVisible,
      incomeEntryModalVisible,
      skinPickerVisible,
      dailyGoalCollectModal.visible,
      tamagotchiVisible,
    ]
  );
  canShowRatingPromptNowRef.current = () => {
    if (onboardingStep !== "done") return false;
    if (!interfaceReady) return false;
    if (tutorialBlockingVisible) return false;
    if (overlayActiveRef.current) return false;
    if (overlayQueueRef.current.length) return false;
    if (celebrationQueueRef.current.length) return false;
    if (celebrationGapTimerRef.current) return false;
    if (overlay?.type === "goal_complete" || pendingGoalCelebration) return false;
    return true;
  };
  canTriggerStoreReviewNowRef.current = () => {
    if (!canShowRatingPromptNowRef.current()) return false;
    return true;
  };
  const canShowQueuedModal = useCallback(
    (type) => {
    if (appStateRef.current !== "active") return false;
    if (!interfaceReady) return false;
    if (tutorialOverlayVisible) return false;
    if (overlay) return false;
    if (coinValueModalVisible) return false;
    if (dailyGoalCollectModal.visible) return false;
    if (tutorialBlockingVisible) return false;
      switch (type) {
        case QUEUED_MODAL_TYPES.DAILY_SUMMARY:
          return dailySummaryUnlocked && !!pendingDailySummaryData;
        case QUEUED_MODAL_TYPES.DAILY_CHALLENGE:
          return (
            dailyChallengePromptAllowed &&
            isDailyChallengePromptPending &&
            dailyChallengePromptGate
          );
        case QUEUED_MODAL_TYPES.DAILY_CHALLENGE_COMPLETE:
          return dailyChallengePromptAllowed && isDailyChallengeCompletePending;
        case QUEUED_MODAL_TYPES.FOCUS_DIGEST:
          return (
            focusModeUnlocked &&
            !!pendingFocusDigest &&
            !focusDigestPromptShown
          );
        case QUEUED_MODAL_TYPES.FAB_TUTORIAL:
          return (
            fabTutorialState === FAB_TUTORIAL_STATUS.SHOWING &&
            onboardingStep === "done" &&
            tutorialSeen &&
            homeLayoutReady &&
            !startupLogoVisible &&
            !fabTutorialBlocked &&
            activeTab === "feed"
          );
        case QUEUED_MODAL_TYPES.INCOME_PROMPT:
          return incomePromptPending && shouldPromptIncome;
        default:
          return false;
      }
    },
    [
      activeTab,
      coinValueModalVisible,
      dailyChallengePromptAllowed,
      dailyChallengePromptGate,
      dailySummaryUnlocked,
      fabTutorialBlocked,
      fabTutorialState,
      focusDigestPromptShown,
      focusModeUnlocked,
      homeLayoutReady,
      incomePromptPending,
      interfaceReady,
      isDailyChallengeCompletePending,
      isDailyChallengePromptPending,
      onboardingStep,
      overlay,
      pendingDailySummaryData,
      pendingFocusDigest,
      shouldPromptIncome,
      startupLogoVisible,
      tutorialBlockingVisible,
      tutorialOverlayVisible,
      tutorialSeen,
    ]
  );
  canShowQueuedModalRef.current = canShowQueuedModal;
  useEffect(() => {
    if (queuedModalActiveRef.current || queuedModalType) return;
    const queue = queuedModalQueueRef.current;
    if (!queue.length) return;
    const nextIndex = queue.findIndex((candidate) => canShowQueuedModal(candidate));
    if (nextIndex < 0) return;
    const [nextType] = queue.splice(nextIndex, 1);
    queuedModalActiveRef.current = nextType;
    setQueuedModalType(nextType);
  }, [canShowQueuedModal, queuedModalProcessTick, queuedModalType]);
  const openGoalLinkPrompt = useCallback((item, intent = "edit") => {
    if (!item) return;
    setGoalLinkPrompt({ visible: true, item, intent, amountUSD: null });
  }, []);
  const [moodGradient, setMoodGradient] = useState(() =>
    applyThemeToMoodGradient(getMoodGradient(), theme)
  );
  const mainGoalWish = useMemo(
    () => selectMainGoalWish(wishes, activeGoalId || profile.goal),
    [wishes, activeGoalId, profile.goal]
  );
  const resolvedHeroGoalId =
    mainGoalWish?.goalId || mainGoalWish?.id || activeGoalId || profile.goal || null;
  useEffect(() => {
    if (mainGoalWish?.id) {
      ensureGoalManualTracking(mainGoalWish.id);
    }
  }, [mainGoalWish?.id, ensureGoalManualTracking]);
  const savingsBreakdown = useMemo(
    () =>
      buildSavingsBreakdown(
        resolvedHistoryEvents,
        profile.currency || DEFAULT_PROFILE.currency,
        resolveTemplateTitle,
        language,
        { range: saveBreakdownRange, offset: saveBreakdownOffset }
      ),
    [
      resolvedHistoryEvents,
      profile.currency,
      resolveTemplateTitle,
      language,
      saveBreakdownRange,
      saveBreakdownOffset,
    ]
  );
  const spendBreakdown = useMemo(
    () =>
      buildSpendingBreakdown(
        resolvedHistoryEvents,
        profile.currency || DEFAULT_PROFILE.currency,
        resolveTemplateTitle,
        language,
        { range: spendBreakdownRange, offset: spendBreakdownOffset }
      ),
    [resolvedHistoryEvents, profile.currency, resolveTemplateTitle, language, spendBreakdownRange, spendBreakdownOffset]
  );
  const breakdownData = useMemo(() => {
    if (breakdownMode === "spend") {
      return spendBreakdown;
    }
    return {
      buckets: savingsBreakdown.buckets || [],
      legend: savingsBreakdown.legend || [],
      formatLocal: savingsBreakdown.formatLocal || ((value) => value),
      rangeTitle: savingsBreakdown.rangeTitle || "",
      averageLabel: savingsBreakdown.averageLabel || "",
    };
  }, [breakdownMode, savingsBreakdown, spendBreakdown]);
  const spendStatsShouldScroll =
    (breakdownData.buckets || []).length > SPEND_STATS_VISIBLE_COLUMNS;
  const spendStatsChartMetrics = useMemo(() => {
    const cardWidth = Math.min(
      SCREEN_WIDTH - BREAKDOWN_OVERLAY_PADDING * 2,
      SPEND_STATS_CARD_MAX_WIDTH
    );
    const chartWidth = Math.max(0, cardWidth - SPEND_STATS_CARD_PADDING * 2);
    const gap = SPEND_STATS_CHART_GAP;
    const visibleCount = SPEND_STATS_VISIBLE_COLUMNS;
    const barWidth = Math.max(
      28,
      (chartWidth - gap * (visibleCount - 1)) / Math.max(visibleCount, 1)
    );
    const bucketCount = Math.max((breakdownData.buckets || []).length, visibleCount);
    const totalWidth = bucketCount * barWidth + gap * Math.max(bucketCount - 1, 0);
    return { chartWidth, barWidth, totalWidth };
  }, [breakdownData.buckets]);
  const spendStatsScrollRef = useRef(null);
  useEffect(() => {
    if (!breakdownVisible) return;
    if (!spendStatsShouldScroll) return;
    const raf = requestAnimationFrame(() => {
      spendStatsScrollRef.current?.scrollToEnd?.({ animated: false });
    });
    return () => cancelAnimationFrame(raf);
  }, [
    breakdownVisible,
    spendStatsShouldScroll,
    activeBreakdownRange,
    activeBreakdownOffset,
    breakdownMode,
    breakdownData.buckets,
  ]);
  const fallbackGoalTargetUSD = useMemo(() => {
    if (Number.isFinite(profile?.goalTargetUSD) && profile.goalTargetUSD > 0) {
      return profile.goalTargetUSD;
    }
    if (profile?.goal) {
      return getGoalDefaultTargetUSD(profile.goal);
    }
    return 0;
  }, [profile?.goalTargetUSD, profile?.goal]);
  const primaryGoalSavedUSD = useMemo(() => {
    const goalId = resolvedHeroGoalId;
    if (!goalId) return 0;
    const entry = Array.isArray(profile.primaryGoals)
      ? profile.primaryGoals.find((goal) => goal?.id === goalId)
      : null;
    return Number.isFinite(entry?.savedUSD) ? entry.savedUSD : 0;
  }, [profile.primaryGoals, resolvedHeroGoalId]);
  const heroGoalTargetUSD = useMemo(() => {
    const wishTarget = mainGoalWish?.targetUSD;
    if (Number.isFinite(wishTarget) && wishTarget > 0) {
      return wishTarget;
    }
    const goalEntry = Array.isArray(profile.primaryGoals)
      ? profile.primaryGoals.find((goal) => goal?.id === resolvedHeroGoalId)
      : null;
    if (goalEntry) {
      const targetUSD =
        Number.isFinite(goalEntry.targetUSD) && goalEntry.targetUSD > 0
          ? goalEntry.targetUSD
          : getGoalDefaultTargetUSD(goalEntry.id);
      return targetUSD;
    }
    return resolvedHeroGoalId ? getGoalDefaultTargetUSD(resolvedHeroGoalId) : fallbackGoalTargetUSD;
  }, [fallbackGoalTargetUSD, mainGoalWish?.targetUSD, profile.primaryGoals, resolvedHeroGoalId]);
  const heroGoalSavedUSD = useMemo(() => {
    const wishSaved = Number.isFinite(mainGoalWish?.savedUSD) ? Math.max(mainGoalWish.savedUSD, 0) : 0;
    const primarySaved = Number.isFinite(primaryGoalSavedUSD) ? Math.max(primaryGoalSavedUSD, 0) : 0;
    return Math.max(wishSaved, primarySaved);
  }, [mainGoalWish?.savedUSD, primaryGoalSavedUSD]);
  const goalCelebrationSummary = useMemo(
    () => buildGoalCelebrationSummary(resolvedHistoryEvents, resolvedHeroGoalId),
    [resolvedHistoryEvents, resolvedHeroGoalId]
  );
  const heroGoalProgressRatio = heroGoalTargetUSD > 0 ? heroGoalSavedUSD / heroGoalTargetUSD : 0;
  const remainingGoalUSD = Math.max(heroGoalTargetUSD - heroGoalSavedUSD, 0);
  const averageSaveActionUSD = useMemo(() => {
    if (!resolvedHistoryEvents.length) return FALLBACK_SAVE_ACTION_USD;
    let total = 0;
    let count = 0;
    resolvedHistoryEvents.forEach((entry) => {
      if (!entry || entry.kind !== "refuse_spend") return;
      const amountUSD = Math.max(0, Number(entry.meta?.amountUSD) || 0);
      if (amountUSD <= 0) return;
      total += amountUSD;
      count += 1;
    });
    if (!count || total <= 0) {
      return FALLBACK_SAVE_ACTION_USD;
    }
    return total / count;
  }, [resolvedHistoryEvents]);
  const remainingGoalActions = useMemo(() => {
    if (remainingGoalUSD <= 0) return 0;
    const divisor = averageSaveActionUSD > 0 ? averageSaveActionUSD : FALLBACK_SAVE_ACTION_USD;
    return Math.max(1, Math.ceil(remainingGoalUSD / divisor));
  }, [averageSaveActionUSD, remainingGoalUSD]);
  const activeGender = profile.gender || registrationData.gender || DEFAULT_PROFILE.gender || "none";
  const safeAppTutorialIndex = Math.min(
    tutorialStepIndex,
    Math.max(appTutorialSteps.length - 1, 0)
  );
  const tutorialContext = tutorialVisible
    ? {
        type: "app",
        steps: appTutorialSteps,
        stepIndex: safeAppTutorialIndex,
      }
    : temptationTutorialVisible
    ? {
        type: "temptation",
        steps: TEMPTATION_TUTORIAL_STEPS,
        stepIndex: temptationTutorialStepIndex,
      }
    : null;
  const tutorialStepCount = tutorialContext?.steps.length || 0;
  const tutorialCurrentIndex = tutorialContext?.stepIndex || 0;
  const tutorialAdvanceHandler =
    tutorialContext?.type === "app" ? handleTutorialNext : handleTemptationTutorialNext;
  const tutorialSkipHandler =
    tutorialContext?.type === "app" ? handleTutorialSkip : handleTemptationTutorialSkip;
  const activeTutorialStep = tutorialContext
    ? tutorialContext.steps[tutorialContext.stepIndex] ||
      tutorialContext.steps[tutorialContext.steps.length - 1] ||
      null
    : null;
  const tutorialIsTemptation = tutorialContext?.type === "temptation";
  const tutorialTemptationStepId = tutorialIsTemptation ? activeTutorialStep?.id || null : null;
  const tutorialBackdropPlacementStyle = tutorialIsTemptation
    ? {
        justifyContent: "flex-end",
        alignItems: "stretch",
        paddingTop: Math.max(topSafeInset + 16, 32),
      }
    : null;
  const tutorialCardPositionStyle = tutorialIsTemptation
    ? {
        alignSelf: "center",
        marginBottom: Platform.OS === "android" ? 56 : 52,
        marginTop: Platform.OS === "android" ? 12 : 0,
      }
    : null;
  // Push the temptation tutorial dialog lower on Android so it doesn't cover the highlighted card.
  const baseTutorialBackdropPaddingBottom = 24 + tutorialCardOffset;
  const androidGestureNav = Platform.OS === "android" && tabBarBottomInset <= 0;
  const temptationTutorialBottomShift = Platform.OS === "android"
    ? androidGestureNav
      ? 0
      : 120
    : 72;
  const tutorialBackdropPaddingBottom = tutorialIsTemptation
    ? Math.max(24, baseTutorialBackdropPaddingBottom - temptationTutorialBottomShift)
    : baseTutorialBackdropPaddingBottom;
  const tutorialBackdropBottomInset = tutorialIsTemptation ? 0 : tutorialOverlayInset;
  const tutorialHighlightTabs = useMemo(() => {
    if (!tutorialContext) return null;
    if (tutorialContext.type !== "app") return null;
    const step = tutorialContext.steps[tutorialContext.stepIndex] || null;
    if (!step?.tabs?.length) return null;
    return new Set(step.tabs);
  }, [tutorialContext]);
  const tutorialHighlightMaskRect = useMemo(() => {
    if (!tutorialIsTemptation || !tutorialHighlightRect) return null;
    const inset = TUTORIAL_HIGHLIGHT_INSET || {};
    const insetX = Number.isFinite(inset.x) ? inset.x : 0;
    const insetY = Number.isFinite(inset.y) ? inset.y : 0;
    const insetTop = Number.isFinite(inset.top) ? inset.top : insetY;
    const insetBottom = Number.isFinite(inset.bottom) ? inset.bottom : insetY;
    const insetLeft = Number.isFinite(inset.left) ? inset.left : insetX;
    const insetRight = Number.isFinite(inset.right) ? inset.right : insetX;
    const width = Math.max(0, tutorialHighlightRect.width - insetLeft - insetRight);
    const height = Math.max(0, tutorialHighlightRect.height - insetTop - insetBottom);
    return {
      x: tutorialHighlightRect.x + insetLeft,
      y: tutorialHighlightRect.y + insetTop,
      width,
      height,
      radius: Math.max(
        0,
        TEMPTATION_CARD_RADIUS - Math.min(insetLeft, insetRight, insetTop, insetBottom)
      ),
    };
  }, [tutorialHighlightRect, tutorialIsTemptation]);
  const tutorialVisualPalette = activeTutorialStep?.palette || {
    primary: "#6FAFFF",
    secondary: "#95E7CE",
    glow: "#7FA9FF",
  };
  const tutorialFeatureKeys = Array.isArray(activeTutorialStep?.featureKeys)
    ? activeTutorialStep.featureKeys
    : [];
  const tutorialBadgeLabelKey =
    tutorialFeatureKeys[0] || activeTutorialStep?.titleKey || "tutorialFeedTitle";
  const tutorialVisualBars = Array.isArray(activeTutorialStep?.visualBars)
    ? activeTutorialStep.visualBars
    : [0.84, 0.56, 0.72, 0.9, 0.63];
  const tutorialIsDarkTheme = theme === "dark";
  const tutorialIsProTheme = theme === PRO_THEME_ID;
  const tutorialCardBackground = tutorialIsDarkTheme ? "#0E1626" : tutorialIsProTheme ? "#EEF1FF" : "#F8FAFF";
  const tutorialCardBorderColor = tutorialIsDarkTheme
    ? "rgba(255,255,255,0.12)"
    : tutorialIsProTheme
    ? colorWithAlpha(proThemeAccentColor, 0.34)
    : "rgba(7,16,35,0.08)";
  const tutorialFeatureBackground = tutorialIsDarkTheme
    ? "rgba(255,255,255,0.08)"
    : tutorialIsProTheme
    ? "rgba(255,255,255,0.96)"
    : "rgba(255,255,255,0.92)";
  const tutorialFeatureBorderColor = tutorialIsDarkTheme
    ? "rgba(255,255,255,0.2)"
    : tutorialIsProTheme
    ? colorWithAlpha(proThemeAccentColor, 0.24)
    : "rgba(18,26,45,0.08)";
  const tutorialFeatureTextColor = tutorialIsDarkTheme ? "#E9F0FF" : tutorialIsProTheme ? "#24347C" : "#17223F";
  const tutorialDotInactiveColor = tutorialIsDarkTheme
    ? "rgba(255,255,255,0.18)"
    : tutorialIsProTheme
    ? colorWithAlpha(proThemeAccentColor, 0.2)
    : "rgba(11,22,48,0.14)";
  const tutorialPrimaryButtonBg = tutorialIsProTheme ? proThemeAccentColor : colors.text;
  const tutorialPrimaryButtonTextColor = tutorialIsProTheme ? "#FFFFFF" : colors.background;
  useEffect(() => {
    if (!tutorialContext || !activeTutorialStep) {
      tutorialCardEntrance.setValue(0);
      return;
    }
    tutorialCardEntrance.setValue(0);
    const enter = Animated.timing(tutorialCardEntrance, {
      toValue: 1,
      duration: 380,
      easing: Easing.out(Easing.cubic),
      useNativeDriver: true,
    });
    enter.start();
    return () => enter.stop();
  }, [activeTutorialStep?.id, tutorialCardEntrance, tutorialContext?.type]);
  useEffect(() => {
    if (!tutorialContext || !activeTutorialStep) {
      tutorialAmbientMotion.setValue(0);
      tutorialPulseMotion.setValue(0);
      return;
    }
    tutorialAmbientMotion.setValue(0);
    tutorialPulseMotion.setValue(0);
    const ambientLoop = Animated.loop(
      Animated.sequence([
        Animated.timing(tutorialAmbientMotion, {
          toValue: 1,
          duration: 1800,
          easing: Easing.inOut(Easing.sin),
          useNativeDriver: true,
        }),
        Animated.timing(tutorialAmbientMotion, {
          toValue: 0,
          duration: 1800,
          easing: Easing.inOut(Easing.sin),
          useNativeDriver: true,
        }),
      ])
    );
    const pulseLoop = Animated.loop(
      Animated.sequence([
        Animated.timing(tutorialPulseMotion, {
          toValue: 1,
          duration: 1300,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(tutorialPulseMotion, {
          toValue: 0,
          duration: 1300,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    ambientLoop.start();
    pulseLoop.start();
    return () => {
      ambientLoop.stop();
      pulseLoop.stop();
    };
  }, [activeTutorialStep?.id, tutorialAmbientMotion, tutorialContext?.type, tutorialPulseMotion]);
  const tutorialCardOpacity = tutorialCardEntrance.interpolate({
    inputRange: [0, 1],
    outputRange: [0, 1],
  });
  const tutorialCardTranslateY = tutorialCardEntrance.interpolate({
    inputRange: [0, 1],
    outputRange: [22, 0],
  });
  const tutorialCardScale = tutorialCardEntrance.interpolate({
    inputRange: [0, 1],
    outputRange: [0.96, 1],
  });
  const tutorialBackdropOpacity = tutorialCardEntrance.interpolate({
    inputRange: [0, 1],
    outputRange: [0.2, 1],
  });
  const tutorialAmbientLift = tutorialAmbientMotion.interpolate({
    inputRange: [0, 1],
    outputRange: [-8, 8],
  });
  const tutorialAmbientDrift = tutorialAmbientMotion.interpolate({
    inputRange: [0, 1],
    outputRange: [-10, 10],
  });
  const tutorialAmbientRotate = tutorialAmbientMotion.interpolate({
    inputRange: [0, 1],
    outputRange: ["-6deg", "6deg"],
  });
  const tutorialPulseScale = tutorialPulseMotion.interpolate({
    inputRange: [0, 1],
    outputRange: [0.9, 1.08],
  });
  const tutorialPulseOpacity = tutorialPulseMotion.interpolate({
    inputRange: [0, 1],
    outputRange: [0.34, 0.08],
  });
  const tutorialBarsOpacity = tutorialCardEntrance.interpolate({
    inputRange: [0, 1],
    outputRange: [0, 1],
  });
  const tutorialBarsTranslateY = tutorialCardEntrance.interpolate({
    inputRange: [0, 1],
    outputRange: [18, 0],
  });
  const fabOverlayColor = theme === "dark"
    ? "rgba(5,7,13,0.78)"
    : theme === PRO_THEME_ID
    ? colorWithAlpha(proThemeAccentColor, 0.42)
    : "rgba(5,7,13,0.55)";
  const resolveTranslationValue = useCallback((key) => {
    const normalizedLanguage = normalizeLanguage(language);
    const override = LANGUAGE_OVERRIDES[normalizedLanguage]?.[key];
    const dictionary = TRANSLATIONS[normalizedLanguage] || {};
    let raw =
      override !== undefined
        ? override
        : dictionary[key] ??
          TRANSLATIONS[FALLBACK_LANGUAGE]?.[key] ??
          TRANSLATIONS[DEFAULT_LANGUAGE]?.[key];
    if (raw && typeof raw === "object" && !Array.isArray(raw)) {
      const genderValue = raw[activeGender];
      if (typeof genderValue === "string") {
        raw = genderValue;
      } else if (typeof raw.none === "string") {
        raw = raw.none;
      } else {
        const fallbackValue = Object.values(raw).find((value) => typeof value === "string");
        raw = fallbackValue !== undefined ? fallbackValue : undefined;
      }
    }
    return raw;
  }, [activeGender, language]);

  const formatTranslationText = useCallback((value, replacements = {}) => {
    let text = value;
    if (text === undefined || text === null) {
      text = "";
    }
    text = String(text);
    Object.entries(replacements).forEach(([token, tokenValue]) => {
      text = text.replace(`{{${token}}}`, tokenValue);
    });
    return text;
  }, []);

  const t = useCallback(
    (key, replacements = {}) => {
      const resolved = resolveTranslationValue(key);
      const base = Array.isArray(resolved) ? resolved[0] : resolved;
      const fallback = base === undefined || base === null ? key : base;
      return formatTranslationText(fallback, replacements);
    },
    [formatTranslationText, resolveTranslationValue]
  );

  const tVariant = useCallback(
    (key, replacements = {}) => {
      const resolved = resolveTranslationValue(key);
      const pool = Array.isArray(resolved)
        ? resolved.filter((value) => typeof value === "string" && value.trim().length > 0)
        : typeof resolved === "string"
        ? [resolved]
        : [];
      const pickSource = pool.length ? pool : [resolved ?? key];
      const choice = pickSource[Math.floor(Math.random() * pickSource.length)] ?? key;
      const fallback = choice === undefined || choice === null ? key : choice;
      return formatTranslationText(fallback, replacements);
    },
    [formatTranslationText, resolveTranslationValue]
  );
  const premiumPlanCards = useMemo(() => {
    const fallbackCurrency = profile.currency || DEFAULT_PROFILE.currency;
    const monetizationLanguage = resolveMonetizationLanguage(language);
    const baseCards = buildDefaultPlanCards(fallbackCurrency);
    const preliminaryCards = baseCards.map((card) => {
      const pkg = premiumState.offeringsByPlan?.[card.id] || null;
      const product = pkg?.product || null;
      const currencyCode =
        typeof product?.currencyCode === "string" && product.currencyCode.trim().length > 0
          ? product.currencyCode.trim().toUpperCase()
          : fallbackCurrency;
      const parsedPriceLocal =
        parseLocalizedPriceValue(product?.price) ??
        parseLocalizedPriceValue(product?.priceString) ??
        parseLocalizedPriceValue(card.priceLabel);
      const chargePriceLabel =
        normalizePaywallPriceLabel(
          product?.priceString ||
            (Number.isFinite(parsedPriceLocal)
              ? formatCurrency(parsedPriceLocal, currencyCode)
              : card.priceLabel),
          currencyCode
        );
      return {
        ...card,
        label: resolvePlanLabel(card.id, language),
        package: pkg,
        available: !!pkg || !premiumState.enabled,
        currencyCode,
        rawPriceLocal: Number.isFinite(parsedPriceLocal) ? Math.max(0, parsedPriceLocal) : null,
        chargePriceLabel,
      };
    });

    const monthlyRawPrice = preliminaryCards.find((card) => card.id === "monthly")?.rawPriceLocal;
    const yearlyRawPrice = preliminaryCards.find((card) => card.id === "yearly")?.rawPriceLocal;
    const yearlyFullPrice =
      Number.isFinite(monthlyRawPrice) && monthlyRawPrice > 0 ? monthlyRawPrice * 12 : null;
    const yearlySavePercent =
      Number.isFinite(yearlyRawPrice) &&
      yearlyRawPrice > 0 &&
      Number.isFinite(yearlyFullPrice) &&
      yearlyFullPrice > yearlyRawPrice
        ? Math.max(1, Math.round((1 - yearlyRawPrice / yearlyFullPrice) * 100))
        : null;

    return preliminaryCards.map((card) => {
      const isYearly = card.id === "yearly";
      const isMonthly = card.id === "monthly";
      const isLifetime = card.id === "lifetime";
      const currencyCode = card.currencyCode || fallbackCurrency;
      const yearSuffix = PAYWALL_YEAR_SUFFIX_BY_LANGUAGE[monetizationLanguage] || PAYWALL_YEAR_SUFFIX_BY_LANGUAGE.en;
      const monthSuffix = PAYWALL_MONTH_SUFFIX_BY_LANGUAGE[monetizationLanguage] || PAYWALL_MONTH_SUFFIX_BY_LANGUAGE.en;
      const amountLocal = Number.isFinite(card.rawPriceLocal) ? Math.max(0, card.rawPriceLocal) : null;

      let priceLabel = card.chargePriceLabel;
      let secondaryLabel = null;
      let secondaryKind = "muted";
      let secondarySubLabel = null;
      let equivalentLabel = null;
      let ctaPriceLabel = card.chargePriceLabel;
      let badge = card.badge;

      if (isYearly && Number.isFinite(amountLocal) && amountLocal > 0) {
        const discountedMonthlyLocal = amountLocal / 12;
        const discountedMonthlyLabel = normalizePaywallPriceLabel(
          `${formatCurrency(discountedMonthlyLocal, currencyCode)}${monthSuffix}`,
          currencyCode
        );
        priceLabel = discountedMonthlyLabel;
        ctaPriceLabel = discountedMonthlyLabel;
        if (Number.isFinite(yearlyFullPrice) && yearlyFullPrice > amountLocal) {
          secondaryLabel = normalizePaywallPriceLabel(
            `${formatCurrency(yearlyFullPrice, currencyCode)}${yearSuffix}`,
            currencyCode
          );
          secondaryKind = "strike";
          secondarySubLabel = normalizePaywallPriceLabel(
            `${formatCurrency(amountLocal, currencyCode)}${yearSuffix}`,
            currencyCode
          );
        } else {
          secondaryLabel = normalizePaywallPriceLabel(
            `${formatCurrency(amountLocal, currencyCode)}${yearSuffix}`,
            currencyCode
          );
        }
        equivalentLabel = buildTemptationEquivalentLine({
          planId: "yearly",
          amountLocal,
          currencyCode,
          language: monetizationLanguage,
        });
        if (yearlySavePercent) {
          badge =
            monetizationLanguage === "ru"
              ? `Ð­ÐºÐ¾Ð½Ð¾Ð¼Ð¸Ñ ${yearlySavePercent}%`
              : `Save ${yearlySavePercent}%`;
        }
      } else if (isMonthly) {
        secondaryLabel =
          PAYWALL_BILLING_LABEL_BY_LANGUAGE.monthly[monetizationLanguage] ||
          PAYWALL_BILLING_LABEL_BY_LANGUAGE.monthly.en;
        if (Number.isFinite(amountLocal) && amountLocal > 0) {
          equivalentLabel = buildTemptationEquivalentLine({
            planId: "monthly",
            amountLocal,
            currencyCode,
            language: monetizationLanguage,
          });
        }
      } else if (isLifetime) {
        secondaryLabel =
          PAYWALL_BILLING_LABEL_BY_LANGUAGE.lifetime[monetizationLanguage] ||
          PAYWALL_BILLING_LABEL_BY_LANGUAGE.lifetime.en;
        if (Number.isFinite(amountLocal) && amountLocal > 0) {
          equivalentLabel = buildTemptationEquivalentLine({
            planId: "lifetime",
            amountLocal,
            currencyCode,
            language: monetizationLanguage,
          });
        }
      }

      return {
        ...card,
        badge,
        priceLabel,
        secondaryLabel: secondaryLabel || null,
        secondaryKind,
        secondarySubLabel: secondarySubLabel || null,
        equivalentLabel,
        ctaPriceLabel,
      };
    });
  }, [language, premiumState.enabled, premiumState.offeringsByPlan, profile.currency]);
  const premiumMonthlyPriceLabel = useMemo(() => {
    const monthlyCard = premiumPlanCards.find((card) => card.id === "monthly");
    if (monthlyCard?.ctaPriceLabel) return monthlyCard.ctaPriceLabel;
    const fallback = resolveFallbackPlanPricing(profile.currency || DEFAULT_PROFILE.currency);
    return fallback?.monthly?.label || "$5.99";
  }, [premiumPlanCards, profile.currency]);
  const premiumCopy = useMemo(
    () =>
      buildPaywallCopy({
        language,
        kind: premiumPaywallState.kind,
        monthlyPriceLabel: premiumMonthlyPriceLabel,
        savedAmountLabel: premiumPaywallState.savedAmountLabel || "",
        featureKey: premiumPaywallState.featureKey,
      }),
    [
      language,
      premiumMonthlyPriceLabel,
      premiumPaywallState.featureKey,
      premiumPaywallState.kind,
      premiumPaywallState.savedAmountLabel,
    ]
  );
  const premiumUnlockFeatureList = useMemo(
    () =>
      (Array.isArray(premiumCopy?.comparisonRows) ? premiumCopy.comparisonRows : [])
        .filter((row) => row?.premium && !row?.free)
        .map((row) => String(row.label || "").trim())
        .filter(Boolean),
    [premiumCopy]
  );
  const getPremiumPaywallContext = useCallback(() => {
    const activeView = premiumPaywallActiveViewRef.current;
    const kind = normalizeMonetizationToken(
      activeView?.kind || premiumPaywallState.kind || "feature",
      "feature"
    );
    const feature = normalizeMonetizationToken(
      activeView?.featureKey || premiumPaywallState.featureKey || "none",
      "none"
    );
    const viewIndex = Math.max(0, Number(activeView?.viewIndex) || 0);
    const openedAt = Number(activeView?.openedAt) || 0;
    const trigger = normalizeMonetizationToken(
      activeView?.trigger || premiumPaywallState.trigger || "manual",
      "manual"
    );
    return {
      kind,
      feature,
      viewIndex,
      openedAt,
      trigger,
    };
  }, [premiumPaywallState.featureKey, premiumPaywallState.kind, premiumPaywallState.trigger]);
  const closePremiumPaywall = useCallback((closeAction = "unknown") => {
    if (premiumPaywallTimerRef.current) {
      clearTimeout(premiumPaywallTimerRef.current);
      premiumPaywallTimerRef.current = null;
    }
    const normalizedCloseAction = normalizeMonetizationToken(closeAction, "unknown");
    const context = getPremiumPaywallContext();
    if (context.viewIndex > 0 && context.openedAt > 0) {
      logEvent("premium_paywall_closed", {
        kind: context.kind,
        feature: context.feature,
        close_action: normalizedCloseAction,
        view_index: context.viewIndex,
        duration_ms: Math.max(0, Date.now() - context.openedAt),
      });
    }
    premiumPaywallActiveViewRef.current = null;
    premiumPaywallDismissedAtRef.current = Date.now();
    setPremiumPaywallState((prev) => ({ ...prev, visible: false }));
  }, [getPremiumPaywallContext, logEvent]);
  const openPremiumPaywall = useCallback(
    ({
      kind = "feature",
      featureKey = null,
      savedAmountUSD = null,
      delayMs = 0,
      trigger = null,
    } = {}) => {
      if (premiumState.isPremium) return false;
      const requestedKind = normalizeMonetizationToken(kind || "feature", "feature");
      const normalizedFeature = featureKey
        ? normalizeMonetizationToken(featureKey, "none")
        : "none";
      const normalizedTrigger = normalizeMonetizationToken(
        trigger ||
          (requestedKind === "soft"
            ? "soft_rule"
            : requestedKind === "hard"
            ? "hard_rule"
            : normalizedFeature !== "none"
            ? "feature_gate"
            : "manual"),
        "manual"
      );
      const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
      const savedValue = Number.isFinite(savedAmountUSD)
        ? Math.max(0, Number(savedAmountUSD) || 0)
        : Math.max(0, Number(savedTotalUSD) || 0);
      const savedAmountLabel = normalizePaywallPriceLabel(
        formatCurrency(convertToCurrency(savedValue, currencyCode), currencyCode),
        currencyCode
      );
      const forceSoftFeaturePaywallOnAndroid =
        Platform.OS === "android" &&
        (normalizedTrigger === "feature_gate" ||
          normalizedFeature !== "none" ||
          requestedKind === "feature");
      const isFeaturePaywallContext =
        normalizedTrigger === "feature_gate" ||
        normalizedFeature !== "none" ||
        requestedKind === "feature";
      const normalizedKind = isFeaturePaywallContext ? "feature" : "soft";
      const effectiveTrigger = forceSoftFeaturePaywallOnAndroid ? "feature_gate" : normalizedTrigger;
      if (premiumPaywallState.visible) {
        if (!forceSoftFeaturePaywallOnAndroid) return false;
        setPremiumPaywallState((prev) => ({
          ...prev,
          visible: true,
          kind: normalizedKind,
          featureKey: normalizedFeature === "none" ? prev.featureKey : normalizedFeature,
          savedAmountLabel,
          trigger: effectiveTrigger,
        }));
        return true;
      }
      const bypassReopenGuard = forceSoftFeaturePaywallOnAndroid;
      const now = Date.now();
      if (
        !bypassReopenGuard &&
        now - (premiumPaywallDismissedAtRef.current || 0) < PREMIUM_PAYWALL_REOPEN_GUARD_MS
      ) {
        return false;
      }
      const show = () => {
        if (premiumState.isPremium) return;
        if (premiumPaywallState.visible) {
          if (!forceSoftFeaturePaywallOnAndroid) return;
          setPremiumPaywallState((prev) => ({
            ...prev,
            visible: true,
            kind: normalizedKind,
            featureKey: normalizedFeature === "none" ? prev.featureKey : normalizedFeature,
            savedAmountLabel,
            trigger: effectiveTrigger,
          }));
          return;
        }
        if (
          !bypassReopenGuard &&
          Date.now() - (premiumPaywallDismissedAtRef.current || 0) <
          PREMIUM_PAYWALL_REOPEN_GUARD_MS
        ) {
          return;
        }
        setPremiumPaywallState({
          visible: true,
          kind: normalizedKind,
          featureKey: normalizedFeature === "none" ? null : normalizedFeature,
          savedAmountLabel,
          trigger: effectiveTrigger,
        });
      };
      if (premiumPaywallTimerRef.current) {
        clearTimeout(premiumPaywallTimerRef.current);
        premiumPaywallTimerRef.current = null;
      }
      if (delayMs > 0) {
        premiumPaywallTimerRef.current = setTimeout(() => {
          premiumPaywallTimerRef.current = null;
          show();
        }, delayMs);
      } else {
        show();
      }
      return true;
    },
    [premiumPaywallState.visible, premiumState.isPremium, profile.currency, savedTotalUSD]
  );
  useEffect(() => {
    showPremiumPaywallRef.current = (options = {}) => openPremiumPaywall(options);
  }, [openPremiumPaywall]);
  useEffect(() => {
    const wasVisible = premiumPaywallVisibilityRef.current;
    const isVisible = !!premiumPaywallState.visible;
    if (isVisible && !wasVisible) {
      const viewIndex = premiumPaywallViewIndexRef.current + 1;
      premiumPaywallViewIndexRef.current = viewIndex;
      const context = {
        viewIndex,
        openedAt: Date.now(),
        kind: normalizeMonetizationToken(premiumPaywallState.kind || "feature", "feature"),
        featureKey: normalizeMonetizationToken(premiumPaywallState.featureKey || "none", "none"),
        trigger: normalizeMonetizationToken(premiumPaywallState.trigger || "manual", "manual"),
      };
      premiumPaywallActiveViewRef.current = context;
      logEvent("premium_paywall_shown", {
        kind: context.kind,
        feature: context.featureKey,
        trigger: context.trigger,
        view_index: viewIndex,
        saved_total_usd: Math.max(0, Number(savedTotalUSD) || 0),
      });
    }
    if (!isVisible && wasVisible) {
      premiumPaywallActiveViewRef.current = null;
    }
    premiumPaywallVisibilityRef.current = isVisible;
  }, [
    logEvent,
    premiumPaywallState.featureKey,
    premiumPaywallState.kind,
    premiumPaywallState.trigger,
    premiumPaywallState.visible,
    savedTotalUSD,
  ]);
  const refreshPremiumState = useCallback(
    async (source = "manual") => {
      if (!isPurchasesAvailable()) {
        setPremiumState((prev) => ({
          ...prev,
          enabled: false,
          isPremium: false,
          entitlement: null,
          customerInfo: null,
          offerings: null,
          offeringsByPlan: {},
        }));
        return { ok: false, reason: "module_unavailable" };
      }
      const [customerInfo, offerings] = await Promise.all([
        getCustomerInfoSafe(),
        getOfferingsSafe(),
      ]);
      const offeringsByPlan = mapOfferingPackagesByPlan(offerings || null);
      const entitlement = getActivePremiumEntitlement(customerInfo);
      const isPremium = isPremiumFromCustomerInfo(customerInfo);
      setPremiumState((prev) => ({
        ...prev,
        enabled: true,
        isPremium,
        entitlement: entitlement || null,
        customerInfo: customerInfo || null,
        offerings: offerings || null,
        offeringsByPlan,
        lastSource: source,
        error: null,
      }));
      if (premiumInstallIdHydrated && premiumInstallId) {
        syncEntitlementSnapshot({
          appUserId: premiumInstallId || null,
          installId: premiumInstallId || null,
          platform: Platform.OS,
          source,
          entitlement,
          customerInfo,
        }).catch(() => {});
      }
      return { ok: true, isPremium, entitlement, offeringsByPlan };
    },
    [premiumInstallId, premiumInstallIdHydrated]
  );
  const attemptBackendPremiumValidation = useCallback(
    async ({ source = "manual", productId = "", purchaseResult = null, customerInfoOverride = null } = {}) => {
      const customerInfo = customerInfoOverride || purchaseResult?.customerInfo || premiumState.customerInfo || null;
      const resolvedProductId = resolvePremiumProductIdentifier({
        purchaseResult,
        customerInfo,
        fallbackProductId: productId,
      });
      const resolvedTransactionIdentifier = resolveStoreTransactionIdentifier({
        purchaseResult,
        customerInfo,
        productId: resolvedProductId,
      });
      const sourceToken = normalizeMonetizationToken(source, "manual");
      const productToken = normalizeMonetizationToken(resolvedProductId || "none", "none");

      if (!premiumInstallIdHydrated || !premiumInstallId) {
        logEvent("premium_backend_validation_result", {
          source: sourceToken,
          product_id: productToken,
          result: "skipped",
          reason: "missing_install_id",
          status: 0,
        });
        return { ok: false, skipped: true, reason: "missing_install_id" };
      }

      const transactionToken = resolveNonEmptyString(resolvedTransactionIdentifier || "");
      const platform = Platform.OS === "android" ? "android" : "ios";
      const validationPayload = {
        appUserId: premiumInstallId,
        installId: premiumInstallId,
        platform,
        productId: resolveNonEmptyString(resolvedProductId || "") || null,
        transactionId: platform === "ios" ? transactionToken || null : null,
        purchaseToken: platform === "android" ? transactionToken || null : null,
        obfuscatedAccountId: premiumInstallId,
      };

      if (
        (platform === "ios" && !validationPayload.transactionId) ||
        (platform === "android" && !validationPayload.purchaseToken)
      ) {
        logEvent("premium_backend_validation_result", {
          source: sourceToken,
          product_id: productToken,
          result: "skipped",
          reason: platform === "ios" ? "missing_transaction_id" : "missing_purchase_token",
          status: 0,
        });
        return {
          ok: false,
          skipped: true,
          reason: platform === "ios" ? "missing_transaction_id" : "missing_purchase_token",
        };
      }

      const validation = await validateStorePurchase(validationPayload);
      const validationReason = validation?.ok
        ? "none"
        : normalizeMonetizationToken(validation?.reason || "validation_failed", "validation_failed");
      logEvent("premium_backend_validation_result", {
        source: sourceToken,
        product_id: productToken,
        result: validation?.ok ? "success" : "failed",
        reason: validationReason,
        status: Math.max(0, Number(validation?.status) || 0),
      });
      return validation;
    },
    [logEvent, premiumInstallId, premiumInstallIdHydrated, premiumState.customerInfo]
  );
  useEffect(() => {
    if (!premiumInstallIdHydrated) return;
    let active = true;
    let unsubscribe = () => {};
    const bootstrapPurchases = async () => {
      if (!isPurchasesAvailable()) {
        setPremiumState((prev) => ({
          ...prev,
          enabled: false,
          isPremium: false,
          offeringsByPlan: {},
          error: "module_unavailable",
        }));
        return;
      }
      const configured = await configurePurchases({ appUserId: premiumInstallId || null });
      if (!active) return;
      if (!configured?.ok) {
        setPremiumState((prev) => ({
          ...prev,
          enabled: false,
          isPremium: false,
          offeringsByPlan: {},
          error: configured?.reason || "configure_failed",
        }));
        return;
      }
      setPurchasesAttributesSafe({
        install_id: premiumInstallId || "",
        app_platform: Platform.OS,
      }).catch(() => {});
      await refreshPremiumState("bootstrap");
      unsubscribe = addCustomerInfoUpdateListener((customerInfo) => {
        if (!active) return;
        const entitlement = getActivePremiumEntitlement(customerInfo);
        const isPremium = isPremiumFromCustomerInfo(customerInfo);
        setPremiumState((prev) => ({
          ...prev,
          enabled: true,
          isPremium,
          entitlement: entitlement || null,
          customerInfo: customerInfo || null,
          lastSource: "listener",
          error: null,
        }));
        if (premiumInstallIdHydrated && premiumInstallId) {
          syncEntitlementSnapshot({
            appUserId: premiumInstallId || null,
            installId: premiumInstallId || null,
            platform: Platform.OS,
            source: "listener",
            entitlement,
            customerInfo,
          }).catch(() => {});
        }
      });
    };
    bootstrapPurchases().catch((error) => {
      console.warn("premium bootstrap", error);
    });
    return () => {
      active = false;
      unsubscribe();
    };
  }, [premiumInstallId, premiumInstallIdHydrated, refreshPremiumState]);
  useEffect(() => {
    if (Platform.OS !== "android") return;
    if (premiumState.error !== "missing_api_key") return;
    if (premiumAndroidConfigAlertShownRef.current) return;
    premiumAndroidConfigAlertShownRef.current = true;
    Alert.alert(
      "Almost",
      language === "ru"
        ? "ÐÐµ Ð½Ð°Ð¹Ð´ÐµÐ½ EXPO_PUBLIC_RC_ANDROID_API_KEY. Ð”Ð¾Ð±Ð°Ð²ÑŒÑ‚Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ Ð² Expo Environment Variables (preview/production), Ð¿ÐµÑ€ÐµÑÐ¾Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð¸ Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€Ð¸Ñ‚Ðµ Ð¿Ð¾Ð¿Ñ‹Ñ‚ÐºÑƒ."
        : "Missing EXPO_PUBLIC_RC_ANDROID_API_KEY. Add it to Expo Environment Variables (preview/production), rebuild the app, and try again."
    );
  }, [language, premiumState.error]);
  const handlePremiumPlanSelected = useCallback(
    (planId) => {
      const targetPlanId = PREMIUM_PLAN_ORDER.includes(planId) ? planId : "yearly";
      const context = getPremiumPaywallContext();
      logEvent("premium_paywall_plan_selected", {
        kind: context.kind,
        feature: context.feature,
        plan: targetPlanId,
        view_index: context.viewIndex,
      });
    },
    [getPremiumPaywallContext, logEvent]
  );
  const handlePremiumPlanPress = useCallback(
    async (planId) => {
      if (premiumPurchaseLoadingPlan || premiumRestoreLoading) return;
      const targetPlanId = PREMIUM_PLAN_ORDER.includes(planId) ? planId : "yearly";
      const selectedCard = premiumPlanCards.find((entry) => entry.id === targetPlanId) || null;
      const selectedPackage = selectedCard?.package || null;
      const productId = String(
        selectedPackage?.product?.identifier || selectedPackage?.identifier || ""
      ).trim();
      const normalizedProductId = productId || "unknown";
      const currencyCode = String(
        selectedCard?.currencyCode || profile.currency || DEFAULT_PROFILE.currency || ""
      ).trim();
      const normalizedCurrencyCode = currencyCode || "USD";
      const priceLocal = Number.isFinite(selectedCard?.rawPriceLocal)
        ? Math.max(0, Number(selectedCard.rawPriceLocal) || 0)
        : null;
      const context = getPremiumPaywallContext();
      const eventMeta = {
        kind: context.kind,
        feature: context.feature,
        plan: targetPlanId,
        view_index: context.viewIndex,
        currency: normalizedCurrencyCode,
        product_id: normalizedProductId,
      };
      if (Number.isFinite(priceLocal)) {
        eventMeta.price_local = priceLocal;
      }
      logEvent("premium_paywall_primary_tapped", eventMeta);
      if (!selectedPackage) {
        logEvent("premium_purchase_result", {
          ...eventMeta,
          result: "failed",
          reason: "package_unavailable",
          error_code: "none",
        });
        Alert.alert(
          "Almost",
          language === "ru"
            ? "ÐŸÐ¾ÐºÑƒÐ¿ÐºÐ° Ð¿Ð¾ÐºÐ° Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð°: Ð¿Ð°ÐºÐµÑ‚ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½ Ð² ÑÑ‚Ð¾Ñ€Ðµ. ÐŸÑ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ RevenueCat Offering."
            : "Purchase is unavailable: package was not found in store offerings."
        );
        return;
      }
      premiumUnlockIntentRef.current = {
        kind: "purchase",
        planId: targetPlanId,
        startedAt: Date.now(),
        paywallKind: context.kind,
        paywallFeature: context.feature,
        paywallViewIndex: context.viewIndex,
      };
      logEvent("premium_purchase_started", eventMeta);
      setPremiumPurchaseLoadingPlan(targetPlanId);
      const result = await purchasePlanPackage(selectedPackage);
      setPremiumPurchaseLoadingPlan(null);
      if (!result.ok) {
        const reason = result.cancelled
          ? "cancelled"
          : normalizeMonetizationToken(result?.reason || "purchase_failed", "purchase_failed");
        const errorCode = normalizeMonetizationToken(result?.error?.code || "none", "none");
        logEvent("premium_purchase_result", {
          ...eventMeta,
          result: result.cancelled ? "cancelled" : "failed",
          reason,
          error_code: errorCode,
        });
        premiumUnlockIntentRef.current = null;
        if (!result.cancelled) {
          Alert.alert(
            "Almost",
            language === "ru"
              ? "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð·Ð°Ð²ÐµÑ€ÑˆÐ¸Ñ‚ÑŒ Ð¿Ð¾ÐºÑƒÐ¿ÐºÑƒ. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ ÑÐ½Ð¾Ð²Ð°."
              : "Could not finish the purchase. Please try again."
          );
        }
        return;
      }
      const purchaseResult = result?.result || null;
      const purchasedProductId = resolvePremiumProductIdentifier({
        purchaseResult,
        fallbackProductId: productId,
      });
      attemptBackendPremiumValidation({
        source: "purchase",
        productId: purchasedProductId,
        purchaseResult,
        customerInfoOverride: purchaseResult?.customerInfo || null,
      }).catch(() => {});
      let refreshed = await refreshPremiumState("purchase");
      if (!refreshed?.isPremium) {
        await new Promise((resolve) => setTimeout(resolve, 900));
        refreshed = await refreshPremiumState("purchase_retry");
      }
      if (!refreshed?.isPremium) {
        const restoreAttempt = await restorePurchasesSafe();
        if (restoreAttempt?.ok) {
          refreshed = await refreshPremiumState("purchase_restore");
        }
      }
      if (!refreshed?.isPremium) {
        logEvent("premium_purchase_result", {
          ...eventMeta,
          result: "pending",
          reason: "activation_pending",
          error_code: "none",
        });
        premiumUnlockIntentRef.current = null;
        Alert.alert("Almost", t("premiumPurchasePendingActivation"));
        return;
      }
      closePremiumPaywall("purchase_success");
      logEvent("premium_purchase_result", {
        ...eventMeta,
        result: "success",
        reason: "none",
        error_code: "none",
      });
      logEvent("premium_purchase_success", eventMeta);
    },
    [
      closePremiumPaywall,
      getPremiumPaywallContext,
      language,
      premiumPlanCards,
      premiumPurchaseLoadingPlan,
      premiumRestoreLoading,
      profile.currency,
      attemptBackendPremiumValidation,
      refreshPremiumState,
      t,
    ]
  );
  const handlePremiumRestore = useCallback(async () => {
    if (premiumPurchaseLoadingPlan || premiumRestoreLoading) return;
    const context = getPremiumPaywallContext();
    const restoreEventMeta = {
      kind: context.kind,
      feature: context.feature,
      view_index: context.viewIndex,
    };
    premiumUnlockIntentRef.current = {
      kind: "restore",
      startedAt: Date.now(),
      paywallKind: context.kind,
      paywallFeature: context.feature,
      paywallViewIndex: context.viewIndex,
    };
    logEvent("premium_restore_started", restoreEventMeta);
    setPremiumRestoreLoading(true);
    const result = await restorePurchasesSafe();
    setPremiumRestoreLoading(false);
    if (!result.ok) {
      logEvent("premium_restore_result", {
        ...restoreEventMeta,
        result: "failed",
        reason: normalizeMonetizationToken(result?.reason || "restore_failed", "restore_failed"),
        error_code: normalizeMonetizationToken(result?.error?.code || "none", "none"),
      });
      premiumUnlockIntentRef.current = null;
      Alert.alert(
        "Almost",
        language === "ru"
          ? "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð²Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð¿Ð¾ÐºÑƒÐ¿ÐºÐ¸."
          : "Could not restore purchases."
      );
      return;
    }
    const restoredCustomerInfo = result?.customerInfo || null;
    const restoredProductId = resolvePremiumProductIdentifier({
      customerInfo: restoredCustomerInfo,
    });
    attemptBackendPremiumValidation({
      source: "restore",
      productId: restoredProductId,
      customerInfoOverride: restoredCustomerInfo,
    }).catch(() => {});
    const refreshed = await refreshPremiumState("restore");
    if (!refreshed?.isPremium) {
      logEvent("premium_restore_result", {
        ...restoreEventMeta,
        result: "failed",
        reason: "no_active_subscription",
        error_code: "none",
      });
      premiumUnlockIntentRef.current = null;
      Alert.alert(
        "Almost",
        language === "ru"
          ? Platform.OS === "ios"
            ? "ÐÐºÑ‚Ð¸Ð²Ð½Ð°Ñ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ° Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð°. ÐŸÑ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ Apple ID Ð² Sandbox Ð¸ Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€Ð¸Ñ‚Ðµ Ð¿Ð¾Ð¿Ñ‹Ñ‚ÐºÑƒ."
            : "ÐÐºÑ‚Ð¸Ð²Ð½Ð°Ñ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ° Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð°. ÐŸÑ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ Google Play Ñ‚ÐµÑÑ‚Ð¾Ð²Ñ‹Ð¹ Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚ Ð¸ Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€Ð¸Ñ‚Ðµ Ð¿Ð¾Ð¿Ñ‹Ñ‚ÐºÑƒ."
          : Platform.OS === "ios"
          ? "No active subscription was found. Verify your Sandbox Apple ID and try again."
          : "No active subscription was found. Verify your Google Play test account and try again."
      );
      return;
    }
    closePremiumPaywall("restore_success");
    logEvent("premium_restore_result", {
      ...restoreEventMeta,
      result: "success",
      reason: "none",
      error_code: "none",
    });
  }, [
    closePremiumPaywall,
    getPremiumPaywallContext,
    language,
    premiumPurchaseLoadingPlan,
    premiumRestoreLoading,
    attemptBackendPremiumValidation,
    refreshPremiumState,
  ]);
  useEffect(() => {
    if (!premiumState.isPremium) return;
    if (!premiumPaywallState.visible) return;
    closePremiumPaywall("premium_activated");
  }, [closePremiumPaywall, premiumPaywallState.visible, premiumState.isPremium]);
  useEffect(() => {
    if (!premiumState.enabled) return;
    if (premiumUnlockTransitionRef.current === null) {
      premiumUnlockTransitionRef.current = premiumState.isPremium;
      return;
    }
    const wasPremium = !!premiumUnlockTransitionRef.current;
    const isPremium = !!premiumState.isPremium;
    premiumUnlockTransitionRef.current = isPremium;
    if (wasPremium || !isPremium) return;
    const source = premiumState.lastSource || "";
    const pendingIntent = premiumUnlockIntentRef.current;
    const hasRecentUnlockIntent =
      !!pendingIntent &&
      Number.isFinite(Number(pendingIntent.startedAt)) &&
      Date.now() - Number(pendingIntent.startedAt) <= 10 * 60 * 1000;
    const activatedViaPurchaseFlow =
      source === "purchase" ||
      source === "purchase_retry" ||
      source === "purchase_restore" ||
      source === "restore";
    const activatedViaListenerPurchase = source === "listener" && hasRecentUnlockIntent;
    if (!activatedViaPurchaseFlow && !activatedViaListenerPurchase) return;
    if (typeof queueCelebrationOverlayRef.current !== "function") return;
    const entitlementProductId = String(
      premiumState.entitlement?.productIdentifier ||
        premiumState.entitlement?.productId ||
        premiumState.entitlement?.product_id ||
        ""
    ).trim();
    const normalizedProductId = entitlementProductId || "unknown";
    const inferredPlanId =
      (PREMIUM_PLAN_ORDER.includes(pendingIntent?.planId) ? pendingIntent?.planId : null) ||
      resolvePlanIdFromProductIdentifier(normalizedProductId) ||
      "unknown";
    const conversionSource = normalizeMonetizationToken(source, "unknown");
    const conversionKind = normalizeMonetizationToken(
      pendingIntent?.paywallKind || premiumPaywallState.kind || "unknown",
      "unknown"
    );
    const conversionFeature = normalizeMonetizationToken(
      pendingIntent?.paywallFeature || premiumPaywallState.featureKey || "none",
      "none"
    );
    const conversionViewIndex = Math.max(0, Number(pendingIntent?.paywallViewIndex) || 0);
    const timeToConvertSec =
      Number.isFinite(Number(pendingIntent?.startedAt)) && Number(pendingIntent?.startedAt) > 0
        ? Math.max(0, Math.round((Date.now() - Number(pendingIntent.startedAt)) / 1000))
        : 0;
    closePremiumPaywall("unlock_overlay");
    queueCelebrationOverlayRef.current(
      "premium_unlock",
      {
        title: t("premiumUnlockTitle"),
        subtitle: t("premiumUnlockSubtitle"),
        cta: t("premiumUnlockContinue"),
        features: premiumUnlockFeatureList,
        accentColor: proThemeAccentColor,
      },
      { duration: null, clearQueueOnDismiss: false }
    );
    premiumUnlockIntentRef.current = null;
    logEvent("premium_conversion", {
      plan: inferredPlanId,
      product_id: normalizedProductId,
      source: conversionSource,
      kind: conversionKind,
      feature: conversionFeature,
      view_index: conversionViewIndex,
      time_to_convert_sec: timeToConvertSec,
    });
    logEvent("premium_unlock_shown", {
      source: conversionSource,
      entitlement: premiumState.entitlement?.identifier || "none",
      plan: inferredPlanId,
      product_id: normalizedProductId,
    });
  }, [
    closePremiumPaywall,
    logEvent,
    premiumState.enabled,
    premiumState.entitlement?.identifier,
    premiumState.entitlement?.productId,
    premiumState.entitlement?.productIdentifier,
    premiumState.entitlement?.product_id,
    premiumState.isPremium,
    premiumState.lastSource,
    premiumPaywallState.featureKey,
    premiumPaywallState.kind,
    proThemeAccentColor,
    premiumUnlockFeatureList,
    t,
  ]);
  const ensurePremiumFeatureAccess = useCallback(
    (featureKey, { kind = "feature", delayMs = 0, savedAmountUSD = null } = {}) => {
      if (premiumState.isPremium) return true;
      const opened = openPremiumPaywall({
        kind,
        featureKey,
        delayMs,
        savedAmountUSD,
        trigger: "feature_gate",
      });
      if (opened) {
        logEvent("premium_gate_blocked", {
          feature: normalizeMonetizationToken(featureKey || "unknown", "unknown"),
          kind: normalizeMonetizationToken(kind || "feature", "feature"),
        });
      }
      return false;
    },
    [openPremiumPaywall, premiumState.isPremium]
  );
  const canShowSoftPaywallNow = useCallback(() => {
    if (premiumState.isPremium || premiumPaywallState.visible) return false;
    if (onboardingStep !== "done" || !interfaceReady) return false;
    if (tutorialBlockingVisible) return false;
    if (queuedModalType || queuedModalActiveRef.current) return false;
    const hasQueuedModalReady = queuedModalQueueRef.current.some((candidate) =>
      canShowQueuedModalRef.current(candidate)
    );
    if (hasQueuedModalReady) return false;
    if (coinValueModalVisible) return false;
    if (overlay || overlayActiveRef.current) return false;
    if (pendingUsageStreakRef.current) return false;
    if (overlayQueueRef.current.length) return false;
    if (celebrationQueueRef.current.length) return false;
    if (celebrationGapTimerRef.current) return false;
    const lastDismissedAt = lastOverlayDismissedAtRef.current || 0;
    if (Date.now() - lastDismissedAt < 600) return false;
    const lastSaveDismissedAt = Number(lastSaveOverlayDismissedAtRef.current) || 0;
    if (lastSaveDismissedAt > 0 && Date.now() - lastSaveDismissedAt < 900) return false;
    return true;
  }, [
    coinValueModalVisible,
    interfaceReady,
    onboardingStep,
    overlay,
    premiumPaywallState.visible,
    premiumState.isPremium,
    queuedModalType,
    tutorialBlockingVisible,
  ]);
  useEffect(() => {
    const previousCount = lastDeclineCountRef.current;
    if (previousCount === null) {
      lastDeclineCountRef.current = declineCount;
      return;
    }
    const reachedFirstSave = previousCount < 1 && declineCount >= 1;
    lastDeclineCountRef.current = declineCount;
    if (!reachedFirstSave) return;
    if (premiumState.isPremium || premiumSoftPaywallShown) return;
    setPremiumSoftPaywallPending(true);
  }, [declineCount, premiumSoftPaywallShown, premiumState.isPremium]);
  useEffect(() => {
    if (!premiumSoftPaywallPending) {
      if (premiumSoftPaywallCheckTimerRef.current) {
        clearTimeout(premiumSoftPaywallCheckTimerRef.current);
        premiumSoftPaywallCheckTimerRef.current = null;
      }
      return undefined;
    }
    if (!premiumSoftPaywallHydrated) return undefined;
    if (premiumState.isPremium || premiumSoftPaywallShown) {
      setPremiumSoftPaywallPending(false);
      return undefined;
    }
    const checkAndShow = () => {
      if (premiumState.isPremium || premiumSoftPaywallShown) {
        setPremiumSoftPaywallPending(false);
        premiumSoftPaywallCheckTimerRef.current = null;
        return;
      }
      if (canShowSoftPaywallNow()) {
        const opened = openPremiumPaywall({
          kind: "soft",
          savedAmountUSD: savedTotalUSD,
          delayMs: 0,
          trigger: "first_save_after_onboarding",
        });
        premiumSoftPaywallCheckTimerRef.current = null;
        if (!opened) {
          setPremiumSoftPaywallPending(false);
          return;
        }
        setPremiumSoftPaywallShown(true);
        setPremiumSoftPaywallPending(false);
        logEvent("premium_soft_paywall_shown", {
          trigger: "first_save_after_onboarding",
        });
        return;
      }
      premiumSoftPaywallCheckTimerRef.current = setTimeout(checkAndShow, 250);
    };
    checkAndShow();
    return () => {
      if (premiumSoftPaywallCheckTimerRef.current) {
        clearTimeout(premiumSoftPaywallCheckTimerRef.current);
        premiumSoftPaywallCheckTimerRef.current = null;
      }
    };
  }, [
    canShowSoftPaywallNow,
    logEvent,
    openPremiumPaywall,
    premiumSoftPaywallHydrated,
    premiumSoftPaywallPending,
    premiumSoftPaywallShown,
    premiumState.isPremium,
    savedTotalUSD,
  ]);
  useEffect(() => {
    const completedCount = (Array.isArray(wishes) ? wishes : []).filter(
      (wish) => wish && wish.status === "done"
    ).length;
    const previousCount = lastCompletedGoalsCountRef.current;
    if (previousCount === null) {
      lastCompletedGoalsCountRef.current = completedCount;
      return;
    }
    const reachedFirstCompletion = previousCount < 1 && completedCount >= 1;
    lastCompletedGoalsCountRef.current = completedCount;
    if (!reachedFirstCompletion) return;
    if (premiumState.isPremium) return;
    if (!premiumHardPaywallHydrated || premiumHardPaywallShown) return;
    if (onboardingStep !== "done") return;
    setPremiumHardPaywallShown(true);
    openPremiumPaywall({
      kind: "hard",
      savedAmountUSD: savedTotalUSD,
      delayMs: HARD_PAYWALL_DELAY_MS,
      trigger: "first_goal_completed",
    });
    logEvent("premium_hard_paywall_shown", {
      trigger: "first_goal_completed",
      saved_total_usd: Math.max(0, Number(savedTotalUSD) || 0),
    });
  }, [
    logEvent,
    onboardingStep,
    openPremiumPaywall,
    premiumHardPaywallHydrated,
    premiumHardPaywallShown,
    premiumState.isPremium,
    savedTotalUSD,
    wishes,
  ]);
  const widgetLabels = useMemo(
    () => ({
      savedMonthLabel: t("homeWidgetSavedMonthLabel"),
      totalLabel: t("homeWidgetTotalLabel"),
      balanceLabel: t("homeWidgetBalanceLabel"),
      todayLabel: t("homeWidgetTodayLabel"),
      goalLabel: t("homeWidgetGoalLabel"),
      monthGoalLabel: t("homeWidgetMonthGoalLabel"),
      budgetRemainingLabel: t("homeWidgetBudgetRemainingLabel"),
      recentLabel: t("homeWidgetRecentLabel"),
      recentEmptyLabel: t("homeWidgetRecentEmptyLabel"),
      emptyStateLabel: premiumActive
        ? t("homeWidgetEmptyStateLabel")
        : t("homeWidgetPremiumLockedLabel"),
      actionSaveLabel: t("homeWidgetActionSave"),
      actionSpendLabel: t("homeWidgetActionSpend"),
      streakLabel: t("homeWidgetStreakLabel"),
      addTemptationLabel: t("quickCustomTitle"),
    }),
    [premiumActive, t]
  );
  useEffect(() => {
    if (!canUpdateWidgetStorage()) return;
    const labelsKey = [
      widgetLabels.savedMonthLabel,
      widgetLabels.totalLabel,
      widgetLabels.balanceLabel,
      widgetLabels.todayLabel,
      widgetLabels.goalLabel,
      widgetLabels.monthGoalLabel,
      widgetLabels.budgetRemainingLabel,
      widgetLabels.recentLabel,
      widgetLabels.recentEmptyLabel,
      widgetLabels.emptyStateLabel,
      widgetLabels.actionSaveLabel,
      widgetLabels.actionSpendLabel,
      widgetLabels.streakLabel,
      widgetLabels.addTemptationLabel,
    ].join("||");
    const prev = widgetMetaRef.current || {};
    if (
      prev.language === normalizedLanguageValue &&
      prev.currencyCode === widgetCurrencyCode &&
      prev.labelsKey === labelsKey &&
      prev.refreshTick === widgetRefreshTick
    ) {
      return;
    }
    widgetMetaRef.current = {
      language: normalizedLanguageValue,
      currencyCode: widgetCurrencyCode,
      labelsKey,
      refreshTick: widgetRefreshTick,
    };
    setWidgetDataSafely({
      widgetLanguage: normalizedLanguageValue,
      widgetCurrencyCode: widgetCurrencyCode,
      widgetLabelSavedMonth: widgetLabels.savedMonthLabel,
      widgetLabelTotal: widgetLabels.totalLabel,
      widgetLabelBalance: widgetLabels.balanceLabel,
      widgetLabelToday: widgetLabels.todayLabel,
      widgetLabelGoal: widgetLabels.goalLabel,
      widgetLabelMonthGoal: widgetLabels.monthGoalLabel,
      widgetLabelBudgetRemaining: widgetLabels.budgetRemainingLabel,
      widgetLabelRecent: widgetLabels.recentLabel,
      widgetLabelRecentEmpty: widgetLabels.recentEmptyLabel,
      widgetLabelEmptyState: widgetLabels.emptyStateLabel,
      widgetActionSave: widgetLabels.actionSaveLabel,
      widgetActionSpend: widgetLabels.actionSpendLabel,
      widgetLabelStreak: widgetLabels.streakLabel,
      widgetLabelAddTemptation: widgetLabels.addTemptationLabel,
    });
  }, [normalizedLanguageValue, widgetCurrencyCode, widgetLabels, widgetRefreshTick]);
  const widgetRecentEvents = useMemo(() => {
    const nowTimestamp = Date.now();
    const cutoffTimestamp = nowTimestamp - HERO_RECENT_HISTORY_WINDOW_MS;
    const filtered = resolvedHistoryEvents.filter(
      (entry) => {
        if (entry?.kind !== "refuse_spend" && entry?.kind !== "spend") return false;
        const timestamp = normalizeTimestampMs(entry?.timestamp);
        return timestamp >= cutoffTimestamp && timestamp <= nowTimestamp;
      }
    );
    filtered.sort((a, b) => normalizeTimestampMs(b?.timestamp) - normalizeTimestampMs(a?.timestamp));
    return filtered.slice(0, 3).map((entry) => {
      const entryTimestamp = normalizeTimestampMs(entry?.timestamp);
      const resolvedTitle =
        resolveTemplateTitle(entry?.meta?.templateId, entry?.meta?.title) ||
        entry?.title ||
        t("defaultDealTitle");
      const timestampLabel = formatLatestSavingTimestamp(entryTimestamp, language);
      const prefix = entry?.kind === "spend" ? "- " : "";
      return `${prefix}${resolvedTitle}${timestampLabel ? ` Â· ${timestampLabel}` : ""}`;
    });
  }, [currentDayKey, language, resolvedHistoryEvents, resolveTemplateTitle, t]);
  const dailyRewardButtonLabel = dailyRewardUnlocked
    ? dailyRewardReady
      ? t("dailyRewardClaimHint")
      : t("dailyRewardCollectedLabel")
    : t("progressHeroLevel", { level: dailyRewardUnlockLevel });
  useEffect(() => {
    if (!canUpdateWidgetStorage()) return;
    if (!profileHydrated || !historyHydrated || !incomeEntriesHydrated || !wishesHydrated) {
      return;
    }
    const goalTargetValue = Math.max(0, Number(heroGoalTargetUSD) || 0);
    const goalSavedValue = Math.max(0, Number(heroGoalSavedUSD) || 0);
    const budgetTotalValue = Number(widgetBudgetTotalValue) || 0;
    const budgetRemainingValue = Number(widgetBudgetRemainingValue) || 0;
    const budgetRemainingLabel = widgetBudgetRemainingLabel || "--";
    const recentEvents = Array.isArray(widgetRecentEvents)
      ? widgetRecentEvents.slice(0, 3)
      : [];
    const recentEventsKey = recentEvents.join("||");
    const currencyCode = widgetCurrencyCode;
    const prev = widgetSupplementRef.current || {};
    if (
      prev.currencyCode === currencyCode &&
      prev.goalTargetValue === goalTargetValue &&
      prev.goalSavedValue === goalSavedValue &&
      prev.budgetTotalValue === budgetTotalValue &&
      prev.budgetRemainingValue === budgetRemainingValue &&
      prev.budgetRemainingLabel === budgetRemainingLabel &&
      prev.recentEventsKey === recentEventsKey &&
      prev.refreshTick === widgetRefreshTick
    ) {
      return;
    }
    widgetSupplementRef.current = {
      goalTargetValue,
      goalSavedValue,
      budgetTotalValue,
      budgetRemainingValue,
      budgetRemainingLabel,
      recentEventsKey,
      currencyCode,
      refreshTick: widgetRefreshTick,
    };
    setWidgetDataSafely({
      goalTargetValue,
      goalSavedValue,
      budgetTotalValue,
      budgetRemainingValue,
      budgetRemainingLabel,
      recentEvents,
      widgetCurrencyCode: currencyCode,
    });
  }, [
    heroGoalSavedUSD,
    heroGoalTargetUSD,
    historyHydrated,
    incomeEntriesHydrated,
    profileHydrated,
    widgetCurrencyCode,
    widgetBudgetRemainingLabel,
    widgetBudgetRemainingValue,
    widgetBudgetTotalValue,
    widgetRecentEvents,
    wishesHydrated,
    widgetRefreshTick,
  ]);
  const formatHealthRewardText = useCallback(
    (amount) => formatHealthRewardLabel(amount, language),
    [language]
  );
  const dailyChallengeTemplate = useMemo(
    () => (dailyChallenge.templateId ? resolveTemplateCard(dailyChallenge.templateId) : null),
    [dailyChallenge.templateId, resolveTemplateCard]
  );
  const dailyChallengeDisplayTitle = useMemo(() => {
    if (dailyChallengeTemplate) {
      return (
        resolveTemptationTitle(
          dailyChallengeTemplate,
          language,
          titleOverrides[dailyChallengeTemplate.id]
        ) || t("defaultDealTitle")
      );
    }
    return (
      dailyChallenge.templateLabel ||
      dailyChallenge.templateTitle ||
      t("defaultDealTitle")
    );
  }, [
    dailyChallenge.templateLabel,
    dailyChallenge.templateTitle,
    dailyChallengeTemplate,
    language,
    t,
    titleOverrides,
  ]);
  const dailyChallengePriceUSD = useMemo(() => {
    if (dailyChallengeTemplate) {
      const currentPrice = getTemptationPrice(dailyChallengeTemplate);
      if (currentPrice > 0) return currentPrice;
    }
    return Number(dailyChallenge.priceUSD) || 0;
  }, [dailyChallenge.priceUSD, dailyChallengeTemplate]);
  const dailyChallengeRewardBonus = useMemo(
    () => computeDailyChallengeBonus(dailyChallengePriceUSD, profile.currency || DEFAULT_PROFILE.currency),
    [dailyChallengePriceUSD, profile.currency]
  );
  const dailyChallengeRewardLabel = useMemo(
    () => formatHealthRewardText(dailyChallengeRewardBonus || 0),
    [dailyChallengeRewardBonus, formatHealthRewardText]
  );
  const dailyChallengeTotalReward = useMemo(() => {
    const base = Number(dailyChallenge.baseReward) || 0;
    const bonus = Number(dailyChallengeRewardBonus) || 0;
    return base + bonus;
  }, [dailyChallenge.baseReward, dailyChallengeRewardBonus]);
  const dailyChallengeTotalRewardLabel = useMemo(
    () => formatHealthRewardText(dailyChallengeTotalReward || 0),
    [dailyChallengeTotalReward, formatHealthRewardText]
  );
  const currentMood = useMemo(
    () => deriveMoodFromState(moodState, pendingList.length),
    [moodState.events, moodState.lastInteractionAt, moodState.lastVisitAt, pendingList.length]
  );
  const moodPreset = useMemo(() => getMoodPreset(currentMood, language), [currentMood, language]);
  useEffect(() => {
    setMoodGradient(applyThemeToMoodGradient(getMoodGradient(moodPreset?.id), theme));
  }, [moodPreset?.id, theme]);
  const moodGoalInfo = useMemo(() => {
    const aggregatedTargetUSD = heroGoalTargetUSD || 0;
    const savedUSD = heroGoalSavedUSD || 0;
    const isComplete = aggregatedTargetUSD > 0 && savedUSD >= aggregatedTargetUSD;
    return { aggregatedTargetUSD, savedUSD, isComplete };
  }, [heroGoalTargetUSD, heroGoalSavedUSD]);
  const moodDescription = useMemo(() => {
    if (!moodPreset) return "";
    const baseLine = moodGoalInfo.isComplete
      ? moodPreset.heroComplete || t("goalWidgetCompleteTagline")
      : moodPreset.hero || t("heroEconomyContinues");
    return moodPreset.motivation ? `${baseLine} ${moodPreset.motivation}` : baseLine;
  }, [moodGoalInfo.isComplete, moodPreset, t]);
  const moodSessionRecordedRef = useRef(false);
  useEffect(() => {
    if (moodSessionRecordedRef.current) return;
    moodSessionRecordedRef.current = true;
    const now = Date.now();
    setMoodState((prev) =>
      evaluateMoodState(
        {
          ...prev,
          lastVisitAt: now,
        },
        { now, pendingCount: pendingList.length }
      )
    );
  }, [pendingList.length]);
  useEffect(() => {
    if (!moodHydrated) return;
    AsyncStorage.setItem(STORAGE_KEYS.MOOD_STATE, JSON.stringify(moodState)).catch(() => {});
  }, [moodState, moodHydrated]);

  useEffect(() => {
    const now = Date.now();
    const mappedEvents = mapHistoryEventsToMoodEvents(resolvedHistoryEvents, now);
    const latestTimestamp = mappedEvents[0]?.timestamp || null;
    setMoodState((prev) =>
      evaluateMoodState(
        {
          ...prev,
          events: mappedEvents,
          lastInteractionAt: latestTimestamp || prev.lastInteractionAt,
        },
        { now, pendingCount: pendingList.length }
      )
    );
  }, [resolvedHistoryEvents, pendingList.length]);

  useEffect(() => {
    setMoodState((prev) =>
      evaluateMoodState(
        { ...prev, pendingSnapshot: pendingList.length },
        { pendingCount: pendingList.length }
      )
    );
  }, [pendingList.length]);

  const refreshMoodForToday = useCallback(() => {
    const todayKey = getDayKey(Date.now());
    setMoodState((prev) => {
      if (prev.dayKey === todayKey) return prev;
      const refreshed = evaluateMoodState(
        createMoodStateForToday({
          pendingSnapshot: pendingList.length,
          lastVisitAt: Date.now(),
          dayKey: todayKey,
        }),
        { pendingCount: pendingList.length }
      );
      return refreshed;
    });
  }, [pendingList.length]);

  useEffect(() => {
    let timer = null;
    const scheduleNextUpdate = () => {
      const now = new Date();
      const nextMidnight = new Date(now);
      nextMidnight.setHours(24, 0, 0, 0);
      const delay = Math.max(nextMidnight.getTime() - now.getTime() + 1000, 60 * 1000);
      timer = setTimeout(() => {
        refreshMoodForToday();
        scheduleNextUpdate();
      }, delay);
    };
    refreshMoodForToday();
    scheduleNextUpdate();
    return () => {
      if (timer) {
        clearTimeout(timer);
      }
    };
  }, [refreshMoodForToday]);
  const ensureNotificationPermission = useCallback(async ({ request = true } = {}) => {
    try {
      const provisionalStatus = Notifications?.IosAuthorizationStatus?.PROVISIONAL;
      let settings = (await safeNotifications.getPermissionsAsync()) || {};
      let granted =
        settings.granted ||
        (provisionalStatus && settings.ios?.status === provisionalStatus);
      if (!granted && request) {
        suppressResumeOnceRef.current = true;
        settings = (await safeNotifications.requestPermissionsAsync()) || {};
        if (appStateRef.current === "active") {
          suppressResumeOnceRef.current = false;
        }
        granted =
          settings.granted ||
          (provisionalStatus && settings.ios?.status === provisionalStatus);
      }
      setNotificationPermissionGranted(granted);
      return granted;
    } catch (error) {
      console.warn("notifications", error);
      setNotificationPermissionGranted(false);
      return false;
    }
  }, []);

  useEffect(() => {
    if (!dailySummaryUnlocked) return;
    if (onboardingStep !== "done") return;
    const task = InteractionManager.runAfterInteractions(() => {
      ensureNotificationPermission({ request: false });
    });
    return () => {
      task?.cancel?.();
    };
  }, [ensureNotificationPermission, onboardingStep]);
  const getReminderAnalyticsPayload = useCallback((notification) => {
    const data = notification?.request?.content?.data || {};
    const reminderType = typeof data.kind === "string" && data.kind.trim() ? data.kind : "generic";
    const targetScreen =
      typeof data.targetScreen === "string" && data.targetScreen.trim()
        ? data.targetScreen
        : typeof data.target_screen === "string" && data.target_screen.trim()
        ? data.target_screen
        : null;
    return { reminder_type: reminderType, target_screen: targetScreen || undefined };
  }, []);
  const resolveDailySummaryPayloadFromData = useCallback(
    (data) => {
      if (!data || typeof data !== "object") return null;
      const summarySource =
        data.summary && typeof data.summary === "object" ? data.summary : data;
      const hasPayload =
        summarySource.todayKey != null ||
        summarySource.today_key != null ||
        summarySource.savedUSD != null ||
        summarySource.saved_usd != null ||
        summarySource.declines != null ||
        summarySource.spends != null;
      const rawKey =
        typeof summarySource.todayKey === "string" && summarySource.todayKey.trim()
          ? summarySource.todayKey.trim()
          : typeof summarySource.today_key === "string" && summarySource.today_key.trim()
          ? summarySource.today_key.trim()
          : typeof data.todayKey === "string" && data.todayKey.trim()
          ? data.todayKey.trim()
          : typeof data.today_key === "string" && data.today_key.trim()
          ? data.today_key.trim()
          : null;
      const todayKey = rawKey || getDayKey(Date.now());
      if (!todayKey) return null;
      if (hasPayload) {
        const savedUSD = Math.max(
          0,
          Number(
            summarySource.savedUSD ??
              summarySource.saved_usd ??
              summarySource.saved ??
              summarySource.amountUSD ??
              summarySource.amount
          ) || 0
        );
        const declines = Math.max(0, Number(summarySource.declines) || 0);
        const spends = Math.max(0, Number(summarySource.spends) || 0);
        return { savedUSD, declines, spends, todayKey };
      }
      if (!historyHydrated) return null;
      const hour = new Date().getHours();
      if (hour < 20) return null;
      const todayEvents = resolvedHistoryEvents.filter((e) => getDayKey(e.timestamp) === todayKey);
      if (!todayEvents.length) return null;
      const saves = todayEvents.filter((e) => e.kind === "refuse_spend");
      const spends = todayEvents.filter((e) => e.kind === "spend");
      const savedUSD = saves.reduce((sum, e) => sum + (Number(e.meta?.amountUSD) || 0), 0);
      const declines = saves.length;
      if (declines < 3) return null;
      const spendCount = spends.length;
      return { savedUSD, declines, spends: spendCount, todayKey };
    },
    [getDayKey, historyHydrated, resolvedHistoryEvents]
  );
  const applyDailySummaryFromNotification = useCallback(
    (data) => {
      if (!data || typeof data !== "object") return false;
      const summaryPayload = resolveDailySummaryPayloadFromData(data);
      if (!summaryPayload) return false;
      if (dailySummarySeenKey === summaryPayload.todayKey) return false;
      setPendingDailySummaryData((prev) =>
        prev?.todayKey === summaryPayload.todayKey ? prev : summaryPayload
      );
      enqueueQueuedModal(QUEUED_MODAL_TYPES.DAILY_SUMMARY);
      return true;
    },
    [dailySummarySeenKey, enqueueQueuedModal, resolveDailySummaryPayloadFromData]
  );
  const handleDailySummaryNotificationOpen = useCallback(
    (data) => {
      if (!data || typeof data !== "object") return false;
      if (!dailySummaryUnlocked || !dailySummaryHydrated) {
        pendingDailySummaryNotificationRef.current = data;
        return false;
      }
      const applied = applyDailySummaryFromNotification(data);
      if (!applied && !historyHydrated) {
        pendingDailySummaryNotificationRef.current = data;
      }
      return applied;
    },
    [
      applyDailySummaryFromNotification,
      dailySummaryHydrated,
      dailySummaryUnlocked,
      historyHydrated,
    ]
  );
  const flushPendingDailySummaryNotification = useCallback(() => {
    const pending = pendingDailySummaryNotificationRef.current;
    if (!pending) return;
    if (!dailySummaryUnlocked || !dailySummaryHydrated) return;
    const applied = applyDailySummaryFromNotification(pending);
    if (applied || historyHydrated) {
      pendingDailySummaryNotificationRef.current = null;
    }
  }, [
    applyDailySummaryFromNotification,
    dailySummaryHydrated,
    dailySummaryUnlocked,
    historyHydrated,
  ]);
  useEffect(() => {
    flushPendingDailySummaryNotification();
  }, [flushPendingDailySummaryNotification]);
  const handleNotificationOpenFromPush = useCallback(
    (response) => {
      if (!response?.notification?.request) return;
      const identifier = response.notification.request.identifier;
      if (identifier && handledNotificationResponseIdsRef.current.has(identifier)) return;
      if (identifier) {
        handledNotificationResponseIdsRef.current.add(identifier);
      }
      const actionIdentifier = response?.actionIdentifier;
      const isDefaultTap =
        !actionIdentifier || actionIdentifier === DEFAULT_NOTIFICATION_ACTION_IDENTIFIER;
      if (!isDefaultTap) {
        notificationActionHandlerRef.current?.({
          actionIdentifier,
          notification: response.notification,
        });
      }
      if (isDefaultTap) {
        const data = response.notification.request.content?.data || {};
        const targetScreen =
          typeof data.targetScreen === "string" && data.targetScreen.trim()
            ? data.targetScreen.trim()
            : typeof data.target_screen === "string" && data.target_screen.trim()
            ? data.target_screen.trim()
            : null;
        const pendingId = typeof data.pendingId === "string" ? data.pendingId : null;
        if (data.kind === "daily_summary" || targetScreen === "daily_summary") {
          handleDailySummaryNotificationOpen(data);
        } else if (data.kind === "weekly_report" || targetScreen === "reports") {
          openReportsFromNotification();
        } else if ((targetScreen === "pending" || data.kind === "pending_decision") && pendingId) {
          setPendingFocusId(pendingId);
          goToTab("pending");
        }
      }
      const reminderPayload = getReminderAnalyticsPayload(response.notification);
      logEvent("push_notification_open");
      logEvent("reminder_clicked", reminderPayload);
    },
    [
      getReminderAnalyticsPayload,
      goToTab,
      handleDailySummaryNotificationOpen,
      logEvent,
      openReportsFromNotification,
    ]
  );
  useEffect(() => {
    let isMounted = true;
    safeNotifications
      .getLastNotificationResponseAsync()
      .then((response) => {
        if (!isMounted) return;
        if (!response) return;
        handleNotificationOpenFromPush(response);
      })
      .catch(() => {});
    const subscription = safeNotifications.addNotificationResponseReceivedListener(
      handleNotificationOpenFromPush
    );
    return () => {
      isMounted = false;
      if (subscription?.remove) {
        subscription.remove();
      }
    };
  }, [handleNotificationOpenFromPush]);
  useEffect(() => {
    const subscription = safeNotifications.addNotificationReceivedListener((notification) => {
      const now = Date.now();
      lastInstantNotificationRef.current = now;
      AsyncStorage.setItem(STORAGE_KEYS.LAST_NOTIFICATION_AT, String(now)).catch(() => {});
      const kind = notification?.request?.content?.data?.kind;
      if (kind === "weekly_report") {
        setReportsBadgeVisible(true);
      }
      if (kind === "tamagotchi_hunger") {
        tamagotchiHungerLastAtRef.current = now;
        AsyncStorage.setItem(STORAGE_KEYS.TAMAGOTCHI_HUNGER_LAST_AT, String(now)).catch(() => {});
      }
      const reminderPayload = getReminderAnalyticsPayload(notification);
      logEvent("reminder_shown", reminderPayload);
    });
    return () => {
      if (subscription?.remove) {
        subscription.remove();
      }
    };
  }, [getReminderAnalyticsPayload, logEvent]);
  useEffect(() => {
    let cancelled = false;
    AsyncStorage.getItem(STORAGE_KEYS.PUSH_NOTIFICATIONS_ENABLED_LOGGED)
      .then((value) => {
        if (cancelled) return;
        pushOptInLoggedRef.current = value === "1";
        setPushOptInHydrated(true);
      })
      .catch(() => {
        if (cancelled) return;
        setPushOptInHydrated(true);
      });
    return () => {
      cancelled = true;
    };
  }, []);
  useEffect(() => {
    let cancelled = false;
    AsyncStorage.getItem(STORAGE_KEYS.PUSH_DAY_THREE_PROMPT)
      .then((value) => {
        if (cancelled) return;
        pushDayThreePromptShownRef.current = value === "1";
        setPushDayThreePromptHydrated(true);
      })
      .catch(() => {
        if (cancelled) return;
        setPushDayThreePromptHydrated(true);
      });
    return () => {
      cancelled = true;
    };
  }, []);
  useEffect(() => {
    let cancelled = false;
    AsyncStorage.getItem(STORAGE_KEYS.SPEND_LOGGING_REMINDER)
      .then((value) => {
        if (cancelled) return;
        lastSpendLoggingReminderRef.current = Number(value) || 0;
        setSpendLoggingReminderHydrated(true);
      })
      .catch(() => {
        if (cancelled) return;
        setSpendLoggingReminderHydrated(true);
      });
    return () => {
      cancelled = true;
    };
  }, []);
  useEffect(() => {
    let cancelled = false;
    AsyncStorage.getItem(STORAGE_KEYS.LAST_NOTIFICATION_AT)
      .then((value) => {
        if (cancelled) return;
        const parsed = Number(value) || 0;
        if (parsed > 0) {
          lastInstantNotificationRef.current = parsed;
        }
      })
      .catch(() => {});
    return () => {
      cancelled = true;
    };
  }, []);
  useEffect(() => {
    if (Platform.OS !== "ios" && Platform.OS !== "android") {
      setHomeWidgetInstallLoggedHydrated(true);
      return;
    }
    let cancelled = false;
    AsyncStorage.getItem(STORAGE_KEYS.HOME_WIDGET_INSTALLED_LOGGED)
      .then((value) => {
        if (cancelled) return;
        homeWidgetInstallLoggedRef.current = value === "1";
        setHomeWidgetInstallLoggedHydrated(true);
      })
      .catch(() => {
        if (cancelled) return;
        setHomeWidgetInstallLoggedHydrated(true);
      });
    return () => {
      cancelled = true;
    };
  }, []);
  const checkAndLogHomeWidgetInstall = useCallback(async () => {
    if (Platform.OS !== "ios" && Platform.OS !== "android") return;
    if (homeWidgetInstallLoggedRef.current) return;
    if (homeWidgetInstallCheckInFlightRef.current) return;
    homeWidgetInstallCheckInFlightRef.current = true;
    try {
      const installed = await hasInstalledHomeWidget();
      if (!installed) return;
      homeWidgetInstallLoggedRef.current = true;
      AsyncStorage.setItem(STORAGE_KEYS.HOME_WIDGET_INSTALLED_LOGGED, "1").catch(() => {});
      logEvent("home_widget_installed");
    } finally {
      homeWidgetInstallCheckInFlightRef.current = false;
    }
  }, [logEvent]);
  useEffect(() => {
    if (Platform.OS !== "ios" && Platform.OS !== "android") return;
    if (analyticsOptOut !== false) return;
    if (!homeWidgetInstallLoggedHydrated) return;
    checkAndLogHomeWidgetInstall();
  }, [analyticsOptOut, checkAndLogHomeWidgetInstall, homeWidgetInstallLoggedHydrated]);
  useEffect(() => {
    if (Platform.OS !== "ios" && Platform.OS !== "android") return;
    if (analyticsOptOut !== false) return;
    if (!homeWidgetInstallLoggedHydrated) return;
    const subscription = AppState.addEventListener("change", (nextState) => {
      if (nextState === "active") {
        checkAndLogHomeWidgetInstall();
      }
    });
    return () => subscription.remove();
  }, [analyticsOptOut, checkAndLogHomeWidgetInstall, homeWidgetInstallLoggedHydrated]);
  useEffect(() => {
    if (!pushOptInHydrated) return;
    if (notificationPermissionGranted !== true) return;
    if (pushOptInLoggedRef.current) return;
    pushOptInLoggedRef.current = true;
    AsyncStorage.setItem(STORAGE_KEYS.PUSH_NOTIFICATIONS_ENABLED_LOGGED, "1").catch(() => {});
    logEvent("push_notifications_enabled");
  }, [notificationPermissionGranted, pushOptInHydrated]);
  useEffect(() => {
    if (notificationPermissionGranted === null) return;
    cleanupStaleEventNotifications();
  }, [cleanupStaleEventNotifications, notificationPermissionGranted]);
  useEffect(() => {
    if (!pushDayThreePromptHydrated) return;
    if (pushDayThreePromptShownRef.current) return;
    if (notificationPermissionGranted !== false) return;
    if (!profileHydrated) return;
    if (!profileJoinedAt) return;
    if (onboardingStep !== "done") return;
    const joinedAtTimestamp = new Date(profileJoinedAt).getTime();
    if (!Number.isFinite(joinedAtTimestamp)) return;
    const ordinalDay = Math.floor((Date.now() - joinedAtTimestamp) / DAY_MS) + 1;
    if (ordinalDay < 3) return;
    pushDayThreePromptShownRef.current = true;
    AsyncStorage.setItem(STORAGE_KEYS.PUSH_DAY_THREE_PROMPT, "1").catch(() => {});
    setPushDayThreePromptVisible(true);
  }, [
    notificationPermissionGranted,
    dailySummaryUnlocked,
    onboardingStep,
    profileHydrated,
    profileJoinedAt,
    pushDayThreePromptHydrated,
  ]);
  const handlePushDayThreePromptLater = useCallback(() => {
    setPushDayThreePromptVisible(false);
  }, []);
  const handlePushDayThreePromptEnable = useCallback(async () => {
    setPushDayThreePromptVisible(false);
    await ensureNotificationPermission();
  }, [ensureNotificationPermission]);

  const sendImmediateNotification = useCallback(
    async (content, options = {}) => {
      if (!content) return false;
      const now = Date.now();
      const dedupeKey = options?.dedupeKey || content?.data?.dedupeKey || null;
      const dedupeWindowMs = Number(options?.dedupeWindowMs) || PUSH_DEDUPE_WINDOW_MS;
      if (dedupeKey) {
        const lastSent = Number(notificationDedupeRef.current.get(dedupeKey)) || 0;
        if (lastSent > 0 && now - lastSent < dedupeWindowMs) {
          return false;
        }
      }
      const blocked = await isNotificationOnCooldown(now);
      if (blocked) {
        return false;
      }
      const allowed = await ensureNotificationPermission({ request: false });
      if (!allowed) return false;
      try {
        await safeNotifications.scheduleNotificationAsync({
          content,
          trigger: null,
        });
        lastInstantNotificationRef.current = now;
        if (dedupeKey) {
          notificationDedupeRef.current.set(dedupeKey, now);
        }
        AsyncStorage.setItem(STORAGE_KEYS.LAST_NOTIFICATION_AT, String(now)).catch(() => {});
        return true;
      } catch (error) {
        console.warn("immediate notification", error);
        return false;
      }
    },
    [ensureNotificationPermission, isNotificationOnCooldown]
  );

  useEffect(() => {
    if (Platform.OS !== "android") return;
    const importance =
      Notifications?.AndroidImportance?.HIGH ?? Notifications?.AndroidImportance?.DEFAULT ?? 4;
    const visibility =
      Notifications?.AndroidNotificationVisibility?.PUBLIC ??
      Notifications?.AndroidNotificationVisibility?.PRIVATE;
    safeNotifications.setNotificationChannelAsync(ANDROID_DAILY_NUDGE_CHANNEL_ID, {
      name: "Daily nudges",
      importance,
      sound: true,
      vibrationPattern: [250, 250, 250],
      lockscreenVisibility: visibility,
    });
    safeNotifications.setNotificationChannelAsync(ANDROID_TAMAGOTCHI_CHANNEL_ID, {
      name: "Tamagotchi hunger",
      importance,
      sound: true,
      vibrationPattern: [250, 250, 250],
      lockscreenVisibility: visibility,
    });
    safeNotifications.setNotificationChannelAsync(ANDROID_REPORTS_CHANNEL_ID, {
      name: "Weekly reports",
      importance,
      sound: true,
      vibrationPattern: [250, 250, 250],
      lockscreenVisibility: visibility,
    });
  }, []);
  useEffect(() => {
    const actions = [
      {
        identifier: NOTIFICATION_ACTION_SAVE,
        buttonTitle: t("pushActionSave"),
        options: { opensAppToForeground: true },
      },
      {
        identifier: NOTIFICATION_ACTION_SPEND,
        buttonTitle: t("pushActionSpend"),
        options: { opensAppToForeground: true },
      },
    ];
    safeNotifications.setNotificationCategoryAsync(ACTIONABLE_NOTIFICATION_CATEGORY_ID, actions);
  }, [t]);

  useEffect(() => {
    dailyNudgeIdsRef.current = dailyNudgeNotificationIds || {};
  }, [dailyNudgeNotificationIds]);
  useEffect(() => {
    pendingListRef.current =
      pendingList && typeof pendingList.length === "number" ? pendingList : [];
  }, [pendingList]);
  const pendingListLength =
    pendingList && typeof pendingList.length === "number" ? pendingList.length : 0;
  useEffect(() => {
    try {
      if (Platform.OS !== "ios") return undefined;
      const canSchedule = typeof setInterval === "function" && typeof clearInterval === "function";
      const canSetTick = typeof setPendingBadgeTick === "function";
      if (!pendingListLength || !canSchedule || !canSetTick) {
        if (canSetTick) {
          setPendingBadgeTick(0);
        }
        return undefined;
      }
      const intervalId = setInterval(() => {
        try {
          setPendingBadgeTick((prev) => prev + 1);
        } catch (error) {
          console.warn("pending badge tick", error);
        }
      }, PENDING_BADGE_TICK_MS);
      return () => clearInterval(intervalId);
    } catch (error) {
      console.warn("pending badge effect", error);
      return undefined;
    }
  }, [pendingListLength]);
  const pendingActionCount = useMemo(() => {
    const now = Date.now();
    const list = pendingList && typeof pendingList.length === "number" ? pendingList : [];
    return list.reduce((count, item) => {
      const dueAt = Number(item?.decisionDue) || 0;
      if (dueAt > 0 && dueAt <= now) return count + 1;
      return count;
    }, 0);
  }, [pendingBadgeTick, pendingList]);
  useEffect(() => {
    if (Platform.OS !== "ios") return;
    const count = Math.max(0, pendingActionCount || 0);
    safeNotifications.setBadgeCountAsync(count);
  }, [pendingActionCount]);

  useEffect(() => {
    smartRemindersRef.current = smartReminders || [];
    const now = Date.now();
    const lastFutureReminder = (smartReminders || []).reduce((latest, reminder) => {
      const scheduledAt = Number(reminder?.scheduledAt) || 0;
      return scheduledAt > now ? Math.max(latest, scheduledAt) : latest;
    }, 0);
    smartReminderScheduleTailRef.current = lastFutureReminder;
  }, [smartReminders]);

  useEffect(() => {
    if (!potentialPushHydrated) return;
    const currencyForStep = profile?.currency || DEFAULT_PROFILE.currency;
    const stepUSD = resolvePotentialPushStepUSD(currencyForStep);
    if (!Number.isFinite(stepUSD) || stepUSD <= 0) return;
    if (!potentialBaselineKey) {
      if (
        potentialPushProgress.baselineKey ||
        potentialPushProgress.lastStep ||
        potentialPushProgress.lastStatus ||
        potentialPushProgress.stepMultiplier !== 1 ||
        potentialPushProgress.lastNotifiedAt
      ) {
        setPotentialPushProgress({ ...DEFAULT_POTENTIAL_PUSH_STATE });
      }
      return;
    }
    const resolvedPotential = Number(getPotentialSavedNow()) || 0;
    const currentStep = Math.max(0, Math.floor(resolvedPotential / stepUSD));
    const lastStep = Math.max(0, Number(potentialPushProgress.lastStep) || 0);
    const now = Date.now();
    const lastNotifiedAt = Number(potentialPushProgress.lastNotifiedAt) || 0;
    const rawMultiplier = Math.max(1, Number(potentialPushProgress.stepMultiplier) || 1);
    const cooledDown =
      rawMultiplier > 1 &&
      lastNotifiedAt > 0 &&
      now - lastNotifiedAt > POTENTIAL_PUSH_COOLDOWN_WINDOW_MS;
    const stepMultiplier = cooledDown
      ? 1
      : Math.min(rawMultiplier, POTENTIAL_PUSH_MAX_MULTIPLIER);
    if (cooledDown) {
      setPotentialPushProgress((prev) => {
        if (prev.baselineKey !== potentialBaselineKey || prev.stepMultiplier <= 1) return prev;
        return { ...prev, stepMultiplier: 1 };
      });
    }
    if (potentialPushProgress.baselineKey !== potentialBaselineKey) {
      setPotentialPushProgress({
        ...DEFAULT_POTENTIAL_PUSH_STATE,
        lastStep: currentStep,
        baselineKey: potentialBaselineKey,
      });
      return;
    }
    if (currentStep < lastStep) {
      setPotentialPushProgress((prev) => ({
        ...prev,
        lastStep: currentStep,
      }));
      return;
    }
    if (!profileHydrated || !savedTotalHydrated) return;
    if (currentStep <= 0 || currentStep <= lastStep) return;
    const stepGap = currentStep - lastStep;
    const requiredGap = stepMultiplier;
    if (stepGap < requiredGap) return;
    const fastGain =
      lastNotifiedAt > 0 && now - lastNotifiedAt < POTENTIAL_PUSH_FAST_GAIN_WINDOW_MS;
    if (fastGain && stepMultiplier < POTENTIAL_PUSH_MAX_MULTIPLIER) {
      setPotentialPushProgress((prev) => {
        if (prev.baselineKey !== potentialBaselineKey) return prev;
        if (prev.stepMultiplier >= POTENTIAL_PUSH_MAX_MULTIPLIER) return prev;
        return { ...prev, stepMultiplier: POTENTIAL_PUSH_MAX_MULTIPLIER };
      });
      return;
    }
    let cancelled = false;
    const notify = async () => {
      const ahead = savedTotalUSD >= resolvedPotential && savedTotalUSD > 0;
      const status = ahead ? "ahead" : "behind";
      const formatLocal = (valueUSD = 0) =>
        formatCurrency(convertToCurrency(Math.max(valueUSD, 0), currencyForStep), currencyForStep);
      const replacements = {
        potential: formatLocal(resolvedPotential),
        actual: formatLocal(savedTotalUSD),
        shortfall: formatLocal(Math.max(resolvedPotential - savedTotalUSD, 0)),
      };
      const dedupeKey = `potential:${potentialBaselineKey}:${status}:${currentStep}`;
      await sendImmediateNotification(
        {
          title: t(
            status === "ahead" ? "potentialPushAheadTitle" : "potentialPushBehindTitle",
            replacements
          ),
          body: t(
            status === "ahead" ? "potentialPushAheadBody" : "potentialPushBehindBody",
            replacements
          ),
          data: { kind: "potential_push", status, dedupeKey },
        },
        { dedupeKey, dedupeWindowMs: POTENTIAL_PUSH_COOLDOWN_WINDOW_MS }
      );
      if (cancelled) return;
      setPotentialPushProgress({
        lastStep: currentStep,
        lastStatus: status,
        baselineKey: potentialBaselineKey,
        stepMultiplier,
        lastNotifiedAt: now,
      });
    };
    notify().catch(() => {});
    return () => {
      cancelled = true;
    };
  }, [
    potentialBaselineKey,
    potentialPushHydrated,
    potentialPushProgress.baselineKey,
    potentialPushProgress.lastNotifiedAt,
    potentialPushProgress.lastStatus,
    potentialPushProgress.lastStep,
    potentialPushProgress.stepMultiplier,
    getPotentialSavedNow,
    profile?.currency,
    profileHydrated,
    savedTotalHydrated,
    savedTotalUSD,
    sendImmediateNotification,
    t,
  ]);

  useEffect(() => {
    if (!profileHydrated || !customReminderHydrated) return;
    schedulePersonalTemptationReminder(profile.customSpend);
  }, [
    customReminderHydrated,
    notificationPermissionGranted,
    profile.customSpend,
    profileHydrated,
    schedulePersonalTemptationReminder,
  ]);

  useEffect(() => {
    const tick = () => {
      setChallengesState((prev) => expireChallenges(prev));
    };
    tick();
    const interval = setInterval(tick, 60000);
    return () => clearInterval(interval);
  }, []);

  useEffect(() => {
    const staleEntries = Object.values(challengesState).filter(
      (entry) => entry?.reminderNotificationIds?.length && entry.status !== CHALLENGE_STATUS.ACTIVE
    );
    if (!staleEntries.length) return;
    staleEntries.forEach((entry) => {
      entry.reminderNotificationIds.forEach((id) => {
        safeNotifications.cancelScheduledNotificationAsync(id);
      });
    });
    setChallengesState((prev) => {
      let changed = false;
      const next = { ...prev };
      staleEntries.forEach((entry) => {
        if (next[entry.id]?.reminderNotificationIds?.length) {
          next[entry.id] = { ...next[entry.id], reminderNotificationIds: [] };
          changed = true;
        }
      });
      return changed ? next : prev;
    });
  }, [challengesState]);

  useEffect(() => {
    const prev = challengesPrevRef.current || {};
    const completedIds = [];
    const expiredIds = [];
    const allowSpeech = challengesHydrated;
    let progressBumped = false;
    Object.keys(challengesState).forEach((id) => {
      const previousStatus = prev[id]?.status;
      const nextStatus = challengesState[id]?.status;
      const previousProgress = Number(prev[id]?.progress) || 0;
      const nextProgress = Number(challengesState[id]?.progress) || 0;
      if (nextStatus === CHALLENGE_STATUS.COMPLETED && previousStatus !== CHALLENGE_STATUS.COMPLETED) {
        completedIds.push(id);
      } else if (
        nextStatus === CHALLENGE_STATUS.EXPIRED &&
        previousStatus === CHALLENGE_STATUS.ACTIVE
      ) {
        expiredIds.push(id);
      } else if (
        nextStatus === CHALLENGE_STATUS.ACTIVE &&
        nextProgress > previousProgress
      ) {
        progressBumped = true;
      }
    });
    completedIds.forEach((challengeId) => {
      const def = CHALLENGE_DEF_MAP[challengeId];
      if (!def) return;
      const copy = getChallengeCopy(def, language);
      const title = copy.title || challengeId;
      triggerOverlayState("reward", t("challengeCompletedOverlay", { title }));
      logEvent("challenge_completed", { challenge_id: challengeId, success: true });
    });
    expiredIds.forEach((challengeId) => {
      logEvent("challenge_completed", { challenge_id: challengeId, success: false });
    });
    if (allowSpeech && progressBumped) {
      queueHomeSpeech("challenge_progress");
    }
    challengesPrevRef.current = challengesState;
  }, [
    challengesHydrated,
    challengesState,
    language,
    logEvent,
    queueHomeSpeech,
    t,
    triggerOverlayState,
  ]);

  useEffect(() => {
    impulseAlertCooldownRef.current = impulseTracker.lastAlerts || {};
  }, [impulseTracker.lastAlerts]);


  useEffect(() => {
    return () => {
      if (stormTimerRef.current) {
        clearTimeout(stormTimerRef.current);
        stormTimerRef.current = null;
      }
    };
  }, []);

  const schedulePendingReminder = useCallback(
    async (title, dueDate, meta = {}) => {
      try {
        const allowed = await ensureNotificationPermission({ request: false });
        if (!allowed) return null;
        const dueTimestamp = Number(dueDate);
        if (!Number.isFinite(dueTimestamp)) return null;
        const now = Date.now();
        const latestAllowed = dueTimestamp + PENDING_REMINDER_GRACE_MS;
        if (now > latestAllowed) return null;
        const triggerAt = Math.max(dueTimestamp - PENDING_REMINDER_LEAD_MS, now);
        if (triggerAt > latestAllowed) return null;
        const trigger = triggerAt <= now + 1000 ? null : new Date(triggerAt);
        const pendingTitle =
          moodPreset?.pushPendingTitle && moodPreset.pushPendingTitle.trim()
            ? renderTemplateString(moodPreset.pushPendingTitle, { title })
            : t("pendingNotificationTitle");
        const pendingBody =
          moodPreset?.pushPendingBody && moodPreset.pushPendingBody.trim()
            ? renderTemplateString(moodPreset.pushPendingBody, { title })
            : t("pendingNotificationBody", { title });
        const dedupeKey =
          meta?.dedupeKey ||
          (typeof meta?.pendingId === "string" && meta.pendingId
            ? `pending:${meta.pendingId}`
            : null);
        const scheduledId = await safeNotifications.scheduleNotificationAsync({
          content: {
            title: pendingTitle,
            body: pendingBody,
            data: {
              kind: "pending_decision",
              pendingId: meta?.pendingId || null,
              templateId: meta?.templateId || null,
              title: meta?.title || title,
              emoji: meta?.emoji || null,
              amountUSD: Number(meta?.amountUSD) || null,
              targetScreen: "pending",
              dedupeKey,
            },
            categoryIdentifier: ACTIONABLE_NOTIFICATION_CATEGORY_ID,
          },
          trigger,
        });
        return scheduledId || null;
      } catch (error) {
        console.warn("pending reminder", error);
        return null;
      }
    },
    [ensureNotificationPermission, t, moodPreset]
  );

  const scheduleChallengeReminders = useCallback(
    async (challengeId, def, startAt, expiresAt) => {
      if (!def?.reminderOffsetsHours?.length) return [];
      const permitted = await ensureNotificationPermission({ request: false });
      if (!permitted) return [];
      const copy = getChallengeCopy(def, language);
      const title = t("challengeReminderTitle", { title: copy.title || challengeId });
      const body = t("challengeReminderBody", { title: copy.title || challengeId });
      const scheduled = [];
      const challengeHash = hashString(challengeId || "");
      const jitterMinutes = challengeHash % 11;
      const windows =
        CHALLENGE_REMINDER_WINDOWS.length > 0
          ? [
              ...CHALLENGE_REMINDER_WINDOWS.slice(challengeHash % CHALLENGE_REMINDER_WINDOWS.length),
              ...CHALLENGE_REMINDER_WINDOWS.slice(0, challengeHash % CHALLENGE_REMINDER_WINDOWS.length),
            ]
          : [];
      for (let index = 0; index < def.reminderOffsetsHours.length; index += 1) {
        const offsetHours = def.reminderOffsetsHours[index];
        const triggerTime = startAt + offsetHours * 60 * 60 * 1000;
        if (!Number.isFinite(triggerTime) || triggerTime <= Date.now()) continue;
        if (expiresAt && triggerTime >= expiresAt) continue;
        const slot = windows[index % (windows.length || 1)];
        let scheduledTime = alignReminderSlotTime(triggerTime, slot, jitterMinutes);
        if (expiresAt && scheduledTime >= expiresAt) {
          scheduledTime = triggerTime + jitterMinutes * 60 * 1000;
        }
        if (!Number.isFinite(scheduledTime)) continue;
        if (expiresAt && scheduledTime >= expiresAt) continue;
        try {
          const scheduledEntry = await scheduleNotificationWithCooldown({
            content: { title, body },
            trigger: new Date(scheduledTime),
          });
          const notificationId = scheduledEntry?.id;
          if (notificationId) {
            scheduled.push(notificationId);
          }
        } catch (error) {
          console.warn("challenge reminder", error);
        }
      }
      return scheduled;
    },
    [ensureNotificationPermission, language, scheduleNotificationWithCooldown, t]
  );

  const customGoalMap = useMemo(() => {
    const entries = registrationData.customGoals || [];
    return entries.reduce((acc, goal) => {
      acc[goal.id] = goal;
      return acc;
    }, {});
  }, [registrationData.customGoals]);

  const overlayDimColor = isDarkTheme ? "rgba(0,0,0,0.65)" : "rgba(5,6,15,0.2)";
  const overlaySystemColor = useMemo(
    () => blendHexColors(colors.background, isDarkTheme ? "#000000" : "#05060F", isDarkTheme ? 0.5 : 0.15),
    [colors.background, isDarkTheme]
  );
  const overlayCardBackground = isDarkTheme ? lightenColor(colors.card, 0.18) : colors.card;
  const overlayBorderColor = isDarkTheme ? lightenColor(colors.border, 0.25) : colors.border;
  const impulseAlertPayload = useMemo(() => {
    if (overlay?.type !== "impulse_alert") return null;
    if (overlay?.message && typeof overlay.message === "object") {
      return overlay.message;
    }
    if (!overlay?.message) return null;
    return { body: overlay.message };
  }, [overlay]);
  const isFeatureUnlockOverlay =
    overlay?.type === "cart" && overlay?.message && typeof overlay.message === "object" && overlay.message.featureUnlock;
  const systemOverlayActive = Boolean(overlay || fabMenuVisible);

  useEffect(() => {
    if (!isAndroid || !canSetSystemBarColors) return;
    const targetNavColor = systemOverlayActive ? overlaySystemColor : colors.card;
    const targetButtonStyle = systemOverlayActive ? "light" : isDarkTheme ? "light" : "dark";
    const targetStatusColor = systemOverlayActive ? overlaySystemColor : colors.background;
    const targetNavVisibility = systemOverlayActive ? "hidden" : "visible";
    const applyNav = async () => {
      try {
        await NavigationBar.setBackgroundColorAsync(targetNavColor);
        await NavigationBar.setButtonStyleAsync(targetButtonStyle);
        if (canToggleNavVisibility) {
          await NavigationBar.setVisibilityAsync(targetNavVisibility);
        }
      } catch (err) {
        console.warn("navigation bar color", err);
      }
    };
    applyNav();
    RNStatusBar.setBackgroundColor(targetStatusColor, true);
  }, [
    canSetSystemBarColors,
    canToggleNavVisibility,
    colors.card,
    colors.background,
    isAndroid,
    isDarkTheme,
    overlayDimColor,
    overlaySystemColor,
    systemOverlayActive,
  ]);
  const saveOverlayPayload =
    overlay?.type === "save"
      ? typeof overlay.message === "object" && overlay.message !== null
        ? overlay.message
        : { title: overlay.message }
      : null;
  const saveCelebrationRef = useRef(null);
  const saveOverlayShownAtRef = useRef(0);
  useEffect(() => {
    if (overlay?.type !== "save") return;
    saveOverlayShownAtRef.current = Date.now();
  }, [overlay?.type]);
  const overlaySoundKeyRef = useRef(null);
  const overlaySoundTimersRef = useRef([]);
  const clearOverlaySoundTimers = useCallback(() => {
    if (!overlaySoundTimersRef.current.length) return;
    overlaySoundTimersRef.current.forEach((timerId) => clearTimeout(timerId));
    overlaySoundTimersRef.current = [];
  }, []);
  useEffect(() => {
    if (!overlay?.type) {
      overlaySoundKeyRef.current = null;
      clearOverlaySoundTimers();
      return undefined;
    }
    const message = overlay.message;
    const soundKey = (() => {
      if (overlay.type === "level") return `level:${message ?? ""}`;
      if (overlay.type === "health") return `health:${message?.amount ?? ""}:${message?.displayCoins ?? ""}`;
      if (overlay.type === "daily_reward") return `daily_reward:${message?.amount ?? ""}`;
      if (typeof message === "string") return `${overlay.type}:${message.slice(0, 32)}`;
      return overlay.type;
    })();
    if (overlaySoundKeyRef.current === soundKey) {
      return undefined;
    }
    overlaySoundKeyRef.current = soundKey;
    clearOverlaySoundTimers();
    const scheduleSound = (delay, key, options = undefined) => {
      if (!key) return;
      const timerId = setTimeout(() => {
        playSound(key, options);
      }, Math.max(0, delay));
      overlaySoundTimersRef.current.push(timerId);
    };
    if (overlay.type === "level") {
      scheduleSound(140, "level_up", { skipCooldown: true });
    } else if (overlay.type === "reward") {
      scheduleSound(180, "reward");
    } else if (overlay.type === "daily_reward") {
      scheduleSound(180, "daily_reward");
      scheduleSound(300, "coin");
    } else if (overlay.type === "usage_streak_weekly_reward") {
      scheduleSound(160, "reward");
      scheduleSound(320, "coin");
    } else if (overlay.type === "streak_pledge_reward") {
      scheduleSound(160, "reward");
      scheduleSound(320, "coin");
    } else if (overlay.type === "premium_unlock") {
      scheduleSound(140, "level_up");
      scheduleSound(320, "reward", { skipCooldown: true });
    } else if (overlay.type === "health") {
      scheduleSound(140, "coin");
    } else if (overlay.type === "goal_complete") {
      scheduleSound(220, "level_up");
    }
    return () => {
      clearOverlaySoundTimers();
    };
  }, [clearOverlaySoundTimers, overlay, playSound]);
  const triggerOverlayStateRef = useRef(null);
  const queueStreakPledgeFollowUpsRef = useRef(null);
  const queueStreakPledgeFollowUps = useCallback(
    (payload, { allowPrompt = true } = {}) => {
      const trigger = triggerOverlayStateRef.current;
      if (typeof trigger !== "function") return false;
      const snapshot = streakPledgeRef.current || INITIAL_STREAK_PLEDGE;
      const todayKey = getDayKey(Date.now());
      if (snapshot.rewardPending) {
        const computed = computeStreakPledgeReward(snapshot.targetDays);
        const rewardBlueCoins = Math.max(0, Number(snapshot.rewardBlueCoins) || computed.blueCoins);
        const rewardValue = Math.max(0, Number(snapshot.rewardValue) || computed.rewardValue);
        trigger("streak_pledge_reward", {
          targetDays: Math.max(0, Number(snapshot.targetDays) || 0),
          rewardBlueCoins,
          rewardValue,
        });
        return true;
      }
      if (!allowPrompt) return false;
      if (!streakPledgeHydrated) return false;
      if (snapshot.status !== STREAK_PLEDGE_STATUS.IDLE) return false;
      const streakCount = Math.max(
        1,
        Number(payload?.count) || Number(usageStreakRef.current?.current) || 1
      );
      trigger("streak_pledge", {
        streakCount,
        dayKey: typeof payload?.dayKey === "string" ? payload.dayKey : todayKey,
      });
      setStreakPledge((prev) => ({
        ...prev,
        introSeen: true,
        lastPromptDayKey: todayKey,
      }));
      logEvent("streak_goal_prompt_shown", {
        streak_count: streakCount,
      });
      return true;
    },
    [logEvent, setStreakPledge, streakPledgeHydrated]
  );
  queueStreakPledgeFollowUpsRef.current = queueStreakPledgeFollowUps;
  const queueUsageStreakOverlay = useCallback(
    (source = null) => {
      const pending = pendingUsageStreakRef.current;
      if (!pending) return false;
      if (source && pending.source && pending.source !== source) return false;
      const trigger = triggerOverlayStateRef.current;
      if (typeof trigger !== "function") return false;
      pendingUsageStreakRef.current = null;
      trigger("usage_streak", pending.payload);
      if (queueStreakPledgeFollowUpsRef.current) {
        queueStreakPledgeFollowUpsRef.current(pending.payload);
      }
      return true;
    },
    []
  );
  useEffect(() => {
    const pending = pendingUsageStreakRef.current;
    if (!pending || pending.source !== "save") return;
    const hasSaveOverlay =
      overlay?.type === "save" ||
      overlayQueueRef.current.some((entry) => entry?.type === "save");
    if (hasSaveOverlay) return;
    const hasStreakOverlay =
      overlay?.type === "usage_streak" ||
      overlayQueueRef.current.some((entry) => entry?.type === "usage_streak");
    if (hasStreakOverlay) return;
    queueUsageStreakOverlay("save");
  }, [overlay?.type, queueUsageStreakOverlay, usageStreak?.lastDate]);
  const handleSaveOverlayPress = useCallback(() => {
    if (overlay?.type === "save" && Date.now() - saveOverlayShownAtRef.current < 350) {
      return;
    }
    const triggerPendingLevelCelebrate = () => {
      const queuedLevel = levelCelebrationQueuedRef.current || 0;
      const celebratedLevel = Math.max(1, Number(lastCelebratedLevel) || 1);
      if (
        !pendingLevelCelebrationRef.current &&
        playerLevel <= Math.max(queuedLevel, celebratedLevel)
      ) {
        return;
      }
      if (!pendingLevelCelebrationRef.current) {
        const baseLevel = Math.max(
          1,
          Number(lastCelebratedLevel) || 1,
          levelCelebrationQueuedRef.current || 0
        );
        if (playerLevel > baseLevel) {
          pendingLevelCelebrationRef.current = {
            level: playerLevel,
            levelsEarned: playerLevel - baseLevel,
          };
          levelCelebrationQueuedRef.current = Math.max(
            levelCelebrationQueuedRef.current || 0,
            playerLevel
          );
        }
      }
      const pending = pendingLevelCelebrationRef.current;
      if (pending && pending.level > Math.max(1, Number(lastCelebratedLevel) || 1)) {
        persistLastCelebratedLevel(pending.level);
        previousPlayerLevelRef.current = Math.max(
          previousPlayerLevelRef.current || 1,
          pending.level
        );
      }
      runPendingLevelCelebration();
    };
    if (saveCelebrationRef.current?.skipToCountdown?.()) {
      return;
    }
    if (saveCelebrationRef.current?.skipCountdownAnimation?.()) {
      return;
    }
    if (
      saveCelebrationRef.current?.isCountdownActive?.() &&
      !saveCelebrationRef.current?.isCountdownReady?.()
    ) {
      return;
    }
    const hasPendingLevel = !!pendingLevelCelebrationRef.current;
    dismissOverlay({ clearQueue: hasPendingLevel ? false : true });
    queueUsageStreakOverlay("save");
    triggerPendingLevelCelebrate();
  }, [
    dismissOverlay,
    lastCelebratedLevel,
    overlay,
    persistLastCelebratedLevel,
    playerLevel,
    queueUsageStreakOverlay,
    runPendingLevelCelebration,
  ]);
  const assignableGoals = useMemo(
    () => (wishes || []).filter((wish) => wish.status !== "done"),
    [wishes]
  );
  const assignableGoalsCount = assignableGoals.length;
  const handlePrimaryTemptationOverlayAction = useCallback(
    async (type, sourceItem = null, extraOptions = {}) => {
      const targetItem = sourceItem || primaryTemptationOverlayItem;
      if (!targetItem) return;
      let activePrimaryGoalId = null;
      if (typeof activeGoalId === "string" && activeGoalId.startsWith("wish_primary_goal_")) {
        activePrimaryGoalId = activeGoalId.replace("wish_primary_goal_", "");
      } else if (
        typeof activeGoalId === "string" &&
        Array.isArray(profile.primaryGoals) &&
        profile.primaryGoals.some((goal) => goal?.id === activeGoalId)
      ) {
        activePrimaryGoalId = activeGoalId;
      } else if (profile.goal) {
        activePrimaryGoalId = profile.goal;
      } else if (Array.isArray(profile.primaryGoals) && profile.primaryGoals[0]?.id) {
        activePrimaryGoalId = profile.primaryGoals[0].id;
      } else {
        activePrimaryGoalId = DEFAULT_PROFILE.goal;
      }
      const forcedGoalId =
        activePrimaryGoalId && !activePrimaryGoalId.startsWith("wish_primary_goal_")
          ? getPrimaryGoalWishId(activePrimaryGoalId)
          : activePrimaryGoalId;
      const actionOptions =
        type === "save"
          ? {
              skipPrompt: true,
              goalId: forcedGoalId,
              shouldAssign: true,
              forcePrimaryGoal: true,
              forceOverlay: true,
            }
          : {};
      const mergedOptions = { ...actionOptions, ...(extraOptions || {}) };
      dismissOverlay({ clearQueue: false });
      await new Promise((resolve) => {
        InteractionManager.runAfterInteractions(() => {
          setTimeout(resolve, 140);
        });
      });
      await handleTemptationAction(type, targetItem, mergedOptions);
    },
    [
      activeGoalId,
      dismissOverlay,
      handleTemptationAction,
      primaryTemptationOverlayItem,
      profile.goal,
      profile.primaryGoals,
    ]
  );
  const hasPendingGoals = assignableGoalsCount > 0;
  const resolveTemptationGoalId = useCallback(
    (templateId) => {
      if (!templateId) return null;
      const assigned = temptationGoalMap[templateId];
      if (!assigned) return null;
      const assignedWish = wishes.find((wish) => wish.id === assigned);
      if (assignedWish && assignedWish.status !== "done") {
        return assignedWish.id;
      }
      return null;
    },
    [temptationGoalMap, wishes]
  );
  const getFallbackGoalId = useCallback(() => {
    if (assignableGoals.length > 0) return assignableGoals[0].id;
    return wishes[0]?.id || null;
  }, [assignableGoals, wishes]);
  const primaryTemptationOverlayItem = useMemo(() => {
    if (overlay?.type !== "primary_temptation") return null;
    const payload = overlay?.message;
    let templateId = null;
    if (payload && typeof payload === "object") {
      if (payload.templateId) {
        templateId = payload.templateId;
      } else if (payload.id) {
        templateId = payload.id;
      }
    } else if (typeof payload === "string") {
      templateId = payload;
    }
    const resolvedTemplateId = templateId || primaryTemptationId;
    const resolved = resolveTemplateCard(resolvedTemplateId);
    if (resolved) return resolved;
    if (profile.customSpend) {
      return createCustomHabitTemptation(
        profile.customSpend,
        profile.currency || DEFAULT_PROFILE.currency,
        profile.gender || "none"
      );
    }
    return null;
  }, [
    overlay,
    primaryTemptationId,
    profile.customSpend,
    profile.currency,
    profile.gender,
    resolveTemplateCard,
  ]);
  const primaryTemptationOverlayGoalLabel = useMemo(() => {
    if (!primaryTemptationOverlayItem) return null;
    const assignedGoalId = resolveTemptationGoalId(primaryTemptationOverlayItem.id);
    if (!assignedGoalId) return null;
    const assignedWish = (wishes || []).find((wish) => wish.id === assignedGoalId);
    return assignedWish ? getWishTitleWithoutEmoji(assignedWish) : null;
  }, [primaryTemptationOverlayItem, resolveTemptationGoalId, wishes]);
  const primaryTemptationOverlayStats = useMemo(
    () =>
      primaryTemptationOverlayItem ? resolveCardRefuseStats(primaryTemptationOverlayItem) : null,
    [primaryTemptationOverlayItem, resolveCardRefuseStats]
  );
  const primaryTemptationOverlayDescription = primaryTemptationOverlayItem
    ? descriptionOverrides[primaryTemptationOverlayItem.id] ||
      (primaryTemptationOverlayItem.id === primaryTemptationId ? primaryTemptationDescription : null)
    : null;
  const primaryTemptationOverlayTitle = primaryTemptationOverlayItem
    ? titleOverrides[primaryTemptationOverlayItem.id]
    : null;
  useEffect(() => {
    const activeGoalIds = new Set(
      (wishes || [])
        .filter((wish) => wish.status !== "done")
        .map((wish) => wish.id)
    );
    let changed = false;
    const nextMap = {};
    Object.entries(temptationGoalMap || {}).forEach(([templateId, goalId]) => {
      if (goalId && activeGoalIds.has(goalId)) {
        nextMap[templateId] = goalId;
      } else {
        changed = true;
      }
    });
    if (changed) {
      setTemptationGoalMap(nextMap);
    }
  }, [temptationGoalMap, wishes]);
  const syncPrimaryGoalProgress = useCallback(
    (goalId, savedUSD, status = "active") => {
      if (!goalId) return;
      const normalizedSaved = Number.isFinite(savedUSD) ? Math.max(savedUSD, 0) : 0;
      const fallbackTargetUSD =
        profile.goal === goalId &&
        Number.isFinite(profile.goalTargetUSD) &&
        profile.goalTargetUSD > 0
          ? profile.goalTargetUSD
          : getGoalDefaultTargetUSD(goalId);
      const updateEntry = (profileState = {}) => {
        const goals = Array.isArray(profileState.primaryGoals) ? profileState.primaryGoals : [];
        let changed = false;
        let hasMatch = false;
        const nextGoals = goals.map((entry) => {
          if (entry.id !== goalId) return entry;
          hasMatch = true;
          const nextEntry = { ...entry };
          if (nextEntry.savedUSD !== normalizedSaved) {
            nextEntry.savedUSD = normalizedSaved;
            changed = true;
          }
          if (status && nextEntry.status !== status) {
            nextEntry.status = status;
            changed = true;
          }
          return nextEntry;
        });
        if (!hasMatch) {
          const primaryWish =
            Array.isArray(wishesRef.current) &&
            wishesRef.current.find(
              (wish) =>
                wish?.kind === PRIMARY_GOAL_KIND &&
                (wish.goalId === goalId || wish.id === getPrimaryGoalWishId(goalId))
            );
          const targetUSD =
            primaryWish && Number.isFinite(primaryWish.targetUSD) && primaryWish.targetUSD > 0
              ? primaryWish.targetUSD
              : fallbackTargetUSD;
          nextGoals.unshift({
            id: goalId,
            targetUSD,
            savedUSD: normalizedSaved,
            status: status || "active",
            createdAt: primaryWish?.createdAt || Date.now(),
          });
          changed = true;
        }
        return changed ? { ...profileState, primaryGoals: nextGoals } : profileState;
      };
      setProfile((prev) => updateEntry(prev));
      setProfileDraft((prev) => updateEntry(prev));
      setWishes((prev) => {
        const targetWishId = getPrimaryGoalWishId(goalId);
        let changed = false;
        const next = prev.map((wish) => {
          if (!wish) return wish;
          if (wish.id !== targetWishId && wish.goalId !== goalId) return wish;
          const updated = { ...wish };
          if (updated.savedUSD !== normalizedSaved) {
            updated.savedUSD = normalizedSaved;
            changed = true;
          }
          if (status && updated.status !== status) {
            updated.status = status;
            changed = true;
          }
          if (updated.goalId !== goalId) {
            updated.goalId = goalId;
            changed = true;
          }
          if (updated.kind !== PRIMARY_GOAL_KIND) {
            updated.kind = PRIMARY_GOAL_KIND;
            changed = true;
          }
          return updated;
        });
        if (!next.some((wish) => wish?.id === targetWishId)) {
          return next;
        }
        return changed ? next : prev;
      });
    },
    [language, profile.goal, profile.goalTargetUSD, setProfile, setProfileDraft, setWishes]
  );

  const assignTemptationGoal = useCallback(
    (templateId, wishId = null) => {
      if (!templateId) return;
      setTemptationGoalMap((prev) => {
        const currentAssignment = prev[templateId];
        if (wishId && currentAssignment === wishId) {
          return prev;
        }
        if (!wishId && !currentAssignment) {
          return prev;
        }
        const next = { ...prev };
        if (wishId) {
          next[templateId] = wishId;
        } else {
          delete next[templateId];
        }
        return next;
      });
    },
    []
  );

  const applySavingsToWish = useCallback(
    (wishId, amountUSD) => {
      if (!wishId || !Number.isFinite(amountUSD) || amountUSD <= 0) return 0;
      let applied = 0;
      let goalSyncMeta = null;
      let completedGoalMeta = null;
      const normalizedGoalId =
        typeof wishId === "string" && wishId.startsWith("wish_primary_goal_")
          ? wishId.replace("wish_primary_goal_", "")
          : null;
      const buildPrimaryGoalWishFromId = (targetWishId) => {
        if (!targetWishId || typeof targetWishId !== "string") return null;
        if (!targetWishId.startsWith("wish_primary_goal_")) return null;
        const goalId = targetWishId.replace("wish_primary_goal_", "");
        const primaryEntries = Array.isArray(profile.primaryGoals) ? profile.primaryGoals : [];
        const primaryEntry = primaryEntries.find((entry) => entry?.id === goalId);
        const canFallbackToProfileGoal = profile.goal === goalId;
        if (!primaryEntry && !canFallbackToProfileGoal) return null;
        const fallbackTargetUSD =
          profile.goal === goalId &&
          Number.isFinite(profile.goalTargetUSD) &&
          profile.goalTargetUSD > 0
            ? profile.goalTargetUSD
            : getGoalDefaultTargetUSD(goalId);
        const ensuredEntry =
          primaryEntry || {
            id: goalId,
            targetUSD: fallbackTargetUSD,
            savedUSD: 0,
            status: "active",
            createdAt: Date.now(),
          };
        const goalPreset = getGoalPreset(goalId);
        const languageKey = language || "en";
        const customTitle =
          typeof ensuredEntry?.customTitle === "string" ? ensuredEntry.customTitle.trim() : "";
        const hasCustomTitle = !!customTitle;
        const customEmoji = ensuredEntry?.customEmoji
          ? normalizeEmojiValue(ensuredEntry.customEmoji, DEFAULT_GOAL_EMOJI)
          : null;
        const resolvedEmoji =
          hasCustomTitle ? customEmoji || DEFAULT_GOAL_EMOJI : goalPreset?.emoji || DEFAULT_GOAL_EMOJI;
        const presetLabel = goalPreset?.[languageKey] || goalPreset?.en || goalId;
        const resolvedLabel = hasCustomTitle ? customTitle : presetLabel || goalId;
        const title = `${resolvedEmoji} ${resolvedLabel}`.trim();
        const targetUSD =
          Number.isFinite(ensuredEntry?.targetUSD) && ensuredEntry.targetUSD > 0
            ? ensuredEntry.targetUSD
            : getGoalDefaultTargetUSD(goalId);
        const createdAt = ensuredEntry?.createdAt || Date.now();
        return {
          id: targetWishId,
          templateId: `goal_${goalId}`,
          title,
          emoji: resolvedEmoji,
          targetUSD,
          savedUSD: 0,
          status: "active",
          createdAt,
          autoManaged: true,
          kind: PRIMARY_GOAL_KIND,
          goalId,
        };
      };
      setWishes((prev) => {
        let changed = false;
        let found = false;
        const next = prev.map((wish) => {
          const isMatchById = wish.id === wishId;
          const isMatchByGoal =
            normalizedGoalId &&
            (wish.goalId === normalizedGoalId ||
              (wish.kind === PRIMARY_GOAL_KIND && wish.id === PRIMARY_GOAL_WISH_ID_LEGACY));
          if (!isMatchById && !isMatchByGoal) return wish;
          found = true;
          const current = wish.savedUSD || 0;
          const target = wish.targetUSD || 0;
          const desired = current + amountUSD;
          const capTarget = target > 0 ? target : Number.POSITIVE_INFINITY;
          const nextSaved = Math.min(desired, capTarget);
          applied = nextSaved - current;
          const status = target > 0 && nextSaved >= target ? "done" : "active";
          const becameDone = status === "done" && wish.status !== "done";
          const hasPrimaryWishId =
            typeof wish.id === "string" && wish.id.startsWith("wish_primary_goal_");
          const derivedGoalId =
            wish.goalId || (hasPrimaryWishId ? wish.id.replace("wish_primary_goal_", "") : null);
          if (
            nextSaved !== current ||
            wish.status !== status ||
            wish.autoManaged !== false ||
            (!!derivedGoalId && derivedGoalId !== wish.goalId) ||
            (hasPrimaryWishId && wish.kind !== PRIMARY_GOAL_KIND)
          ) {
            changed = true;
            if (derivedGoalId) {
              goalSyncMeta = { goalId: derivedGoalId, savedUSD: nextSaved, status };
            }
          if (becameDone) {
            completedGoalMeta = {
              goalId: wish.goalId || wish.id,
              wishId: wish.id,
              templateId: wish.templateId || null,
              targetUSD: target,
              createdAt: wish.createdAt || wish.metaCreatedAt || null,
            };
          }
            const updatedWish = {
              ...wish,
              savedUSD: nextSaved,
              status,
              autoManaged: false,
              ...(derivedGoalId ? { goalId: derivedGoalId } : {}),
              ...(hasPrimaryWishId ? { kind: PRIMARY_GOAL_KIND } : {}),
            };
            if (__DEV__ && wishId.startsWith("wish_primary_goal_")) {
              console.warn("primary_temptation_goal_update", {
                wishId,
                current,
                nextSaved,
                targetUSD: target,
                applied,
              });
            }
            return updatedWish;
          }
          return wish;
        });
        if (!found) {
          const created = buildPrimaryGoalWishFromId(wishId);
          if (created) {
            const target = created.targetUSD || 0;
            const capTarget = target > 0 ? target : Number.POSITIVE_INFINITY;
            const nextSaved = Math.min(Math.max(amountUSD, 0), capTarget);
            applied = nextSaved;
            const status = target > 0 && nextSaved >= target ? "done" : "active";
            const becameDone = status === "done";
            const nextCreated = {
              ...created,
              savedUSD: nextSaved,
              status,
            };
            if (__DEV__ && wishId.startsWith("wish_primary_goal_")) {
              console.warn("primary_temptation_goal_created", {
                wishId,
                nextSaved,
                targetUSD: target,
                applied,
              });
            }
            changed = true;
            if (nextCreated.kind === PRIMARY_GOAL_KIND && nextCreated.goalId) {
              goalSyncMeta = {
                goalId: nextCreated.goalId,
                savedUSD: nextSaved,
                status,
              };
            }
            if (becameDone) {
              completedGoalMeta = {
                goalId: nextCreated.goalId || nextCreated.id,
                wishId: nextCreated.id,
                templateId: nextCreated.templateId || null,
                targetUSD: target,
                createdAt: nextCreated.createdAt || null,
              };
            }
            return [nextCreated, ...prev];
          }
        }
        if (__DEV__ && (wishId.startsWith("wish_primary_goal_") || normalizedGoalId)) {
          const trackedWish =
            next.find((w) => w?.id === wishId) ||
            (normalizedGoalId
              ? next.find((w) => w?.goalId === normalizedGoalId || w?.id === PRIMARY_GOAL_WISH_ID_LEGACY)
              : null);
          if (trackedWish) {
            console.warn("primary_temptation_goal_state", {
              wishId,
              goalId: normalizedGoalId,
              savedUSD: trackedWish.savedUSD,
              targetUSD: trackedWish.targetUSD,
              status: trackedWish.status,
            });
          } else {
            console.warn("primary_temptation_goal_state", {
              wishId,
              goalId: normalizedGoalId,
              savedUSD: null,
              targetUSD: null,
              status: null,
              note: "not found in wishes",
            });
          }
        }
        return changed ? next : prev;
      });
      if (goalSyncMeta) {
        syncPrimaryGoalProgress(goalSyncMeta.goalId, goalSyncMeta.savedUSD, goalSyncMeta.status);
      }
      if (completedGoalMeta) {
        const targetAmountLocal = convertToCurrency(
          completedGoalMeta.targetUSD || 0,
          profile.currency || DEFAULT_PROFILE.currency
        );
        let daysToComplete = null;
        if (completedGoalMeta.createdAt) {
          const createdAtTs = new Date(completedGoalMeta.createdAt).getTime();
          if (Number.isFinite(createdAtTs)) {
            daysToComplete = Math.max(1, Math.round((Date.now() - createdAtTs) / DAY_MS));
          }
        }
        logEvent("goal_completed", {
          goal_id: completedGoalMeta.goalId,
          target_amount: targetAmountLocal,
          days_to_complete: daysToComplete,
        });
      }
      return applied;
    },
    [
      language,
      logEvent,
      profile.currency,
      profile.goal,
      profile.goalTargetUSD,
      profile.primaryGoals,
      syncPrimaryGoalProgress,
    ]
  );
  const getWishTitleById = useCallback(
    (wishId) => wishes.find((wish) => wish.id === wishId)?.title || "",
    [wishes]
  );
  const goalSelectionList = useMemo(
    () => (assignableGoals.length > 0 ? assignableGoals : wishes),
    [assignableGoals, wishes]
  );
  const currentGoalTitle = useMemo(() => {
    if (saveOverlayPayload?.goalTitle) {
      return saveOverlayPayload.goalTitle;
    }
    if (assignableGoals.length > 0) {
      const primaryGoal = assignableGoals[0];
      const baseTitle =
        (primaryGoal && getWishTitleWithoutEmoji(primaryGoal)) ||
        getWishTitleById(assignableGoals[0].id);
      return (baseTitle || "").trim();
    }
    return null;
  }, [assignableGoals, getWishTitleById, saveOverlayPayload]);
  const saveOverlayGoalText =
    currentGoalTitle && saveOverlayPayload?.goalComplete
      ? t("saveGoalComplete", { goal: currentGoalTitle })
      : currentGoalTitle;
  const saveOverlayGoalPrefix =
    currentGoalTitle &&
    !saveOverlayPayload?.goalComplete &&
    Number.isFinite(saveOverlayPayload?.remainingTemptations) &&
    saveOverlayPayload?.remainingTemptations > 0
      ? t("saveGoalRemaining")
      : null;
  const achievements = useMemo(() => {
    const built = buildAchievements({
      savedTotalUSD: progressSavedTotalUSD,
      declineCount,
      freeDayStats,
      pendingCount: pendingList.length,
      decisionStats,
      dailyChallengeCompletedCount,
      focusVictoryCount,
      customTemptationsCreatedCount,
      currency: profile.currency || DEFAULT_PROFILE.currency,
      t,
      language,
    });
    const normalizedList = Array.isArray(built) ? built.filter(Boolean) : [];
    const withClaim = normalizedList.map((reward, index) => ({
      ...reward,
      claimed: !!safeClaimedRewards[reward.id],
      _order: index,
    }));
    return withClaim
      .sort((a, b) => {
        const aTier = a.unlocked ? (a.claimed ? 1 : 0) : 2;
        const bTier = b.unlocked ? (b.claimed ? 1 : 0) : 2;
        if (aTier !== bTier) return aTier - bTier;
        return a._order - b._order;
      })
      .map(({ _order, ...reward }) => reward);
  }, [
    progressSavedTotalUSD,
    declineCount,
    freeDayStats,
    pendingList.length,
    decisionStats,
    dailyChallengeCompletedCount,
    focusVictoryCount,
    customTemptationsCreatedCount,
    profile.currency,
    t,
    language,
    safeClaimedRewards,
  ]);


  const challengeList = useMemo(
    () =>
      buildChallengesDisplay({
        state: challengesState,
        currency: profile.currency || DEFAULT_PROFILE.currency,
        language,
        t,
        maxActiveChallenges: MAX_ACTIVE_CHALLENGES,
        averageSaveActionUSD,
        playerLevel,
      }),
    [challengesState, profile.currency, language, t, averageSaveActionUSD, playerLevel]
  );
  const currentChallengeBadges = useMemo(
    () =>
      challengeList
        .filter(
          (challenge) =>
            challenge.status === CHALLENGE_STATUS.COMPLETED || challenge.status === CHALLENGE_STATUS.CLAIMED
        )
        .map((challenge) => ({
          id: challenge.id,
          emoji: challenge.emoji || CHALLENGE_DEF_MAP[challenge.id]?.emoji || "",
        }))
        .filter((entry) => entry.id && entry.emoji),
    [challengeList]
  );
  const mergedChallengeBadges = useMemo(
    () =>
      mergeChallengeBadgeLists(
        challengeBadgeStoreHydrated ? challengeBadgeStore : [],
        currentChallengeBadges
      ),
    [challengeBadgeStore, challengeBadgeStoreHydrated, currentChallengeBadges]
  );
  useEffect(() => {
    if (!challengeBadgeStoreHydrated) return;
    if (areChallengeBadgeListsEqual(mergedChallengeBadges, challengeBadgeStore)) return;
    setChallengeBadgeStore(mergedChallengeBadges);
  }, [
    challengeBadgeStore,
    challengeBadgeStoreHydrated,
    mergedChallengeBadges,
    setChallengeBadgeStore,
  ]);
  const challengeBadgeEmojis = useMemo(
    () => mergedChallengeBadges.map((entry) => entry.emoji).filter(Boolean),
    [mergedChallengeBadges]
  );
  const challengeBadgeCount = challengeBadgeEmojis.length;
  const activeChallenge = useMemo(() => {
    const activeChallenges = challengeList.filter(
      (challenge) => challenge.status === CHALLENGE_STATUS.ACTIVE
    );
    if (!activeChallenges.length) return null;
    return activeChallenges.reduce((best, current) => {
      if (!best) return current;
      if ((current.progressPercent || 0) > (best.progressPercent || 0)) return current;
      if ((current.progressPercent || 0) < (best.progressPercent || 0)) return best;
      return (current.progressValue || 0) >= (best.progressValue || 0) ? current : best;
    }, null);
  }, [challengeList]);
  const rewardsBadgeCount = useMemo(() => {
    if (!rewardsReady || !rewardsUnlocked) return 0;
    return achievements.filter((reward) => reward.unlocked && !reward.claimed).length;
  }, [achievements, rewardsReady, rewardsUnlocked]);
  const challengeRewardsBadgeCount = useMemo(() => {
    if (!rewardsReady || !challengesUnlocked) return 0;
    return challengeList.filter((challenge) => challenge.canClaim).length;
  }, [challengeList, rewardsReady, challengesUnlocked]);
  const activeDailyChallenge = useMemo(() => {
    if (dailyChallenge.status !== DAILY_CHALLENGE_STATUS.ACTIVE) return null;
    const targetValue = dailyChallenge.target || 1;
    const rewardBonus = dailyChallengeRewardBonus || ECONOMY_RULES.minSaveReward;
    const baseReward = Number(dailyChallenge.baseReward) || 0;
    return {
      id: dailyChallenge.id,
      emoji: dailyChallengeTemplate?.emoji || dailyChallenge.emoji || "âœ¨",
      title: dailyChallengeDisplayTitle,
      rewardBonus,
      baseReward,
      rewardTotal: baseReward + rewardBonus,
      progress: Math.min(dailyChallenge.progress || 0, targetValue),
      target: targetValue,
    };
  }, [
    dailyChallenge,
    dailyChallengeDisplayTitle,
    dailyChallengeRewardBonus,
    dailyChallengeTemplate,
  ]);
  const resolvedDailyChallenge = dailyChallengeUnlocked ? activeDailyChallenge : null;

  const profileStats = useMemo(() => {
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const totalSavedConverted = formatCurrency(
      convertToCurrency(savedTotalUSD, currencyCode),
      currencyCode
    );
    const spendCount = purchases.length;
    return [
      { label: t("statsSaved"), value: totalSavedConverted },
      { label: t("statsDeclines"), value: `${declineCount}` },
      { label: t("statsSpends"), value: `${spendCount}` },
      { label: t("statsFreeDays"), value: `${freeDayStats.current}`, suffix: "ðŸ”¥" },
    ];
  }, [savedTotalUSD, declineCount, freeDayStats.current, purchases.length, t, profile.currency]);

  const analyticsStats = useMemo(
    () => [
      { label: t("analyticsPendingToBuy"), value: `${wishes.length}` },
      { label: t("analyticsPendingToDecline"), value: `${declineCount}` },
      { label: t("analyticsFridgeCount"), value: `${purchases.length}` },
    ],
    [wishes.length, declineCount, purchases.length, t]
  );
  const impulseEventsForInsights = useMemo(
    () =>
      (impulseTracker.events || []).filter(
        (event) => !isEssentialImpulseCategory(event?.category)
      ),
    [impulseTracker.events]
  );
  const quickCategoryRecency = useMemo(() => {
    const map = new Map();
    resolvedHistoryEvents.forEach((entry) => {
      if (!entry?.timestamp) return;
      if (
        entry.kind !== "spend" &&
        entry.kind !== "refuse_spend" &&
        entry.kind !== "pending_to_decline"
      ) {
        return;
      }
      const categoryId = entry?.meta?.category;
      if (!categoryId || !IMPULSE_CATEGORY_DEFS[categoryId]) return;
      const timestamp = Number(entry.timestamp) || 0;
      if (!Number.isFinite(timestamp)) return;
      const prev = map.get(categoryId) || 0;
      if (timestamp > prev) {
        map.set(categoryId, timestamp);
      }
    });
    return map;
  }, [resolvedHistoryEvents]);
  const impulseInsights = useMemo(() => {
    const raw = buildImpulseInsights(impulseEventsForInsights);
    if (!raw) return raw;
    const resolveTitle = (templateId, fallbackTitle) => {
      if (!templateId) return fallbackTitle || "";
      const template = resolveTemplateCard(templateId);
      if (!template) return fallbackTitle || "";
      return (
        resolveTemptationTitle(template, language, titleOverrides[template.id]) ||
        fallbackTitle ||
        ""
      );
    };
    const resolveEmoji = (templateId, fallbackEmoji) => {
      if (!templateId) return fallbackEmoji || "";
      const template = resolveTemplateCard(templateId);
      return template?.emoji || fallbackEmoji || "";
    };
    const resolveAmountUSD = (templateId, fallbackAmount) => {
      if (!templateId) return fallbackAmount;
      const template = resolveTemplateCard(templateId);
      const price = template ? getTemptationPrice(template) : null;
      return Number.isFinite(price) && price > 0 ? price : fallbackAmount;
    };
    const resolveHotItem = (item) => {
      if (!item) return null;
      return {
        ...item,
        title: resolveTitle(item.templateId, item.title),
        emoji: resolveEmoji(item.templateId, item.emoji),
      };
    };
    const resolveSequence = (entry) => {
      if (!entry) return null;
      return {
        ...entry,
        fromTitle: resolveTitle(entry.fromTemplateId, entry.fromTitle),
        toTitle: resolveTitle(entry.toTemplateId, entry.toTitle),
      };
    };
    const activeRisk = raw.activeRisk
      ? {
          ...raw.activeRisk,
          title: resolveTitle(raw.activeRisk.templateId, raw.activeRisk.title),
          emoji: resolveEmoji(raw.activeRisk.templateId, raw.activeRisk.emoji),
          amountUSD: resolveAmountUSD(raw.activeRisk.templateId, raw.activeRisk.amountUSD),
        }
      : null;
    return {
      ...raw,
      hotLose: resolveHotItem(raw.hotLose),
      hotWin: resolveHotItem(raw.hotWin),
      activeRisk,
      sequenceHotspots: {
        slip: resolveSequence(raw.sequenceHotspots?.slip),
        rebound: resolveSequence(raw.sequenceHotspots?.rebound),
      },
    };
  }, [impulseEventsForInsights, language, resolveTemplateCard, titleOverrides]);
  const focusRecentSpends = useMemo(() => {
    const now = Date.now();
    const cutoff = now - FOCUS_RECENT_WINDOW_MS;
    const recentMap = new Map();
    impulseEventsForInsights.forEach((event) => {
      if (!event || event.action !== "spend" || !event.templateId) return;
      const templateId =
        typeof event.templateId === "string" ? event.templateId.trim() : event.templateId;
      if (!templateId || !isFocusCandidateInFeed(templateId)) return;
      const timestamp = Number(event.timestamp);
      if (!Number.isFinite(timestamp) || timestamp < cutoff) return;
      const existing = recentMap.get(templateId) || {
        templateId,
        count: 0,
        lastTimestamp: 0,
        eventTitle: "",
        eventEmoji: "",
      };
      const next = { ...existing, count: existing.count + 1 };
      if (timestamp >= existing.lastTimestamp) {
        next.lastTimestamp = timestamp;
        next.eventTitle = event.title;
        next.eventEmoji = event.emoji;
      }
      recentMap.set(templateId, next);
    });
    if (!recentMap.size) return [];
    const resolved = Array.from(recentMap.values())
      .filter((entry) => entry.count >= FOCUS_RECENT_MIN_SPEND_COUNT)
      .map((entry) => {
        const template = resolveTemplateCard(entry.templateId);
        const templateLabel =
          (typeof template?.title === "string"
            ? template.title
            : template?.title?.[language] || template?.title?.en || template?.title?.ru || "") ||
          "";
        const resolvedTitle =
          resolveTemplateTitle(entry.templateId, templateLabel) ||
          templateLabel ||
          entry.eventTitle ||
          t("defaultDealTitle");
        const resolvedEmoji = template?.emoji || entry.eventEmoji || "âœ¨";
        return { ...entry, title: resolvedTitle, emoji: resolvedEmoji };
      });
    if (!resolved.length) return [];
    resolved.sort((a, b) => {
      if (b.count !== a.count) return b.count - a.count;
      return (b.lastTimestamp || 0) - (a.lastTimestamp || 0);
    });
    return resolved;
  }, [
    impulseEventsForInsights,
    isFocusCandidateInFeed,
    language,
    resolveTemplateCard,
    resolveTemplateTitle,
    t,
  ]);
  const dailyChallengePressure = useMemo(() => {
    const cutoff = Date.now() - DAILY_CHALLENGE_LOOKBACK_MS;
    const recentEvents = impulseEventsForInsights.filter((event) => {
      const timestamp = Number(event?.timestamp);
      return Number.isFinite(timestamp) && timestamp >= cutoff;
    });
    return buildTemptationPressureMap(recentEvents);
  }, [impulseEventsForInsights, todayKey]);
  const dailyChallengeRecentSaveIds = useMemo(() => {
    const cutoff = Date.now() - DAILY_CHALLENGE_POSITIVE_COOLDOWN_MS;
    const ids = new Set();
    impulseEventsForInsights.forEach((event) => {
      if (!event || event.action !== "save") return;
      const timestamp = Number(event.timestamp);
      if (!Number.isFinite(timestamp) || timestamp < cutoff) return;
      if (typeof event.templateId === "string" && event.templateId.trim()) {
        ids.add(event.templateId.trim());
      }
    });
    return ids;
  }, [impulseEventsForInsights, todayKey]);

  useEffect(() => {
    if (!impulseFeaturesUnlocked) return;
    if (!impulseInsights.activeRisk) return;
    notifyImpulseRisk(impulseInsights.activeRisk);
  }, [impulseFeaturesUnlocked, impulseInsights.activeRisk, notifyImpulseRisk]);
  useEffect(() => {
    if (!focusDigestHydrated) return;
    if (!focusModeUnlocked) return;
    const todayKey = getDayKey(Date.now());
    if (focusDigestSeenKey === todayKey) return;
    if (pendingFocusDigest?.dateKey === todayKey) return;
    if (!impulseInsights || (impulseInsights.eventCount || 0) < 1) return;
    if (!purchases.length) return;
    if (!focusRecentSpends.length) return;
    const strong = impulseInsights.hotWin || null;
    const eligibleStrong =
      strong?.templateId && isFocusCandidateInFeed(strong.templateId) ? strong : null;
    const weak = eligibleStrong?.templateId
      ? focusRecentSpends.find((entry) => entry.templateId !== eligibleStrong.templateId) || null
      : focusRecentSpends[0] || null;
    if (!weak) return;
    const positive =
      !!eligibleStrong &&
      (impulseInsights.totalSpendCount || 0) <= (impulseInsights.totalSaveCount || 0);
    const strongTitle = keepEmojiWithText(eligibleStrong?.title || t("focusDigestMissing"));
    const weakTitle = keepEmojiWithText(weak?.title || t("focusDigestMissing"));
    const payload = {
      title: positive ? t("focusDigestPositiveTitle") : t("focusDigestNegativeTitle"),
      body: positive
        ? t("focusDigestPositiveBody", { strong: strongTitle, weak: weakTitle })
        : t("focusDigestNegativeBody", { weak: weakTitle }),
      strong: eligibleStrong ? { ...eligibleStrong, title: strongTitle } : eligibleStrong,
      weak: weak ? { ...weak, title: weakTitle } : weak,
      positive,
      targetId: weak?.templateId || eligibleStrong?.templateId || null,
    };
    setPendingFocusDigest({ dateKey: todayKey, payload });
    setFocusDigestPromptShown(false);
  }, [
    focusDigestHydrated,
    focusDigestSeenKey,
    focusModeUnlocked,
    focusRecentSpends,
    isFocusCandidateInFeed,
    impulseInsights,
    pendingFocusDigest,
    purchases.length,
    t,
  ]);

  useEffect(() => {
    if (!pendingFocusDigest) return;
    const targetId = pendingFocusDigest?.payload?.targetId;
    if (targetId && !isFocusCandidateInFeed(targetId)) {
      setPendingFocusDigest(null);
      setFocusDigestPromptShown(false);
      AsyncStorage.removeItem(STORAGE_KEYS.FOCUS_DIGEST_PENDING).catch(() => {});
      return;
    }
    if (focusDigestPromptShown) return;
    if (!focusModeUnlocked) return;
    enqueueQueuedModal(QUEUED_MODAL_TYPES.FOCUS_DIGEST);
  }, [
    enqueueQueuedModal,
    focusModeUnlocked,
    isFocusCandidateInFeed,
    pendingFocusDigest,
    focusDigestPromptShown,
  ]);
  useEffect(() => {
    if (queuedModalType !== QUEUED_MODAL_TYPES.FOCUS_DIGEST) return;
    if (!pendingFocusDigest || !focusModeUnlocked) {
      clearQueuedModal(QUEUED_MODAL_TYPES.FOCUS_DIGEST);
      return;
    }
    triggerOverlayState("focus_digest", pendingFocusDigest.payload);
    setFocusDigestPromptShown(true);
  }, [
    clearQueuedModal,
    focusModeUnlocked,
    pendingFocusDigest,
    queuedModalType,
    triggerOverlayState,
  ]);
  useEffect(() => {
    if (focusModeUnlocked) return;
    setPendingFocusDigest(null);
    setFocusDigestPromptShown(false);
  }, [focusModeUnlocked]);
  useEffect(() => {
    if (!dailyChallengeHydrated) return;
    if (!dailyChallengeUnlocked) return;
    const resolvedTodayKey = todayKey || getDayKey(Date.now());
    const todayDate = parseDayKey(resolvedTodayKey);
    const resolveDailyChallengeFrequencyId = (templateId, template = null) => {
      const normalizedTemplateId =
        typeof templateId === "string" ? templateId.trim() : templateId;
      const interactionFrequency = normalizeFrequencyId(
        normalizedTemplateId ? temptationInteractions?.[normalizedTemplateId]?.frequency : null
      );
      const templateFrequency = normalizeFrequencyId(template?.frequency);
      return interactionFrequency || templateFrequency || "daily";
    };
    const deferDate = dailyChallenge.deferUntilKey
      ? parseDayKey(dailyChallenge.deferUntilKey)
      : null;
    const preservedDeferUntilKey =
      deferDate && todayDate && deferDate.getTime() > todayDate.getTime()
        ? dailyChallenge.deferUntilKey
        : null;
    const existingTemplate = dailyChallenge.templateId
      ? resolveTemplateCard(dailyChallenge.templateId)
      : null;
    const existingCategory =
      existingTemplate && typeof resolveTemptationCategory === "function"
        ? resolveTemptationCategory(existingTemplate)
        : null;
    const existingTemplateFrequency =
      dailyChallenge.templateId && existingTemplate
        ? resolveDailyChallengeFrequencyId(dailyChallenge.templateId, existingTemplate)
        : null;
    const existingTemplateIsDaily = existingTemplateFrequency === "daily";
    if (isEssentialImpulseCategory(existingCategory)) {
      setDailyChallenge({
        ...createInitialDailyChallengeState(),
        dateKey: resolvedTodayKey,
        status: DAILY_CHALLENGE_STATUS.IDLE,
        deferUntilKey: preservedDeferUntilKey,
      });
      return;
    }
    if (
      dailyChallenge.dateKey === resolvedTodayKey &&
      dailyChallenge.templateId &&
      existingTemplateIsDaily
    ) {
      return;
    }
    if (
      dailyChallenge.dateKey === resolvedTodayKey &&
      dailyChallenge.templateId &&
      !existingTemplateIsDaily &&
      dailyChallenge.status !== DAILY_CHALLENGE_STATUS.OFFER &&
      dailyChallenge.status !== DAILY_CHALLENGE_STATUS.IDLE
    ) {
      return;
    }
    const targetId = resolveDailyChallengeTemplateId(dailyChallengePressure, 1, (templateId) => {
      const normalizedTemplateId =
        typeof templateId === "string" ? templateId.trim() : templateId;
      if (!normalizedTemplateId) return false;
      if (dailyChallengeRecentSaveIds.has(normalizedTemplateId)) return false;
      const template = resolveTemplateCard(normalizedTemplateId);
      if (!template) return false;
      const frequencyId = resolveDailyChallengeFrequencyId(normalizedTemplateId, template);
      if (frequencyId !== "daily") return false;
      if (typeof resolveTemptationCategory === "function") {
        const categoryId = resolveTemptationCategory(template);
        if (isEssentialImpulseCategory(categoryId)) return false;
      }
      if (!isDailyChallengePopularTemplate(template)) return false;
      const rawTitle =
        template.titleOverride ||
        (typeof template.title === "string"
          ? template.title
          : template.title?.[language] || template.title?.en || template.title?.ru || template.title);
      return typeof rawTitle === "string" && rawTitle.trim().length > 0;
    });
    if (!targetId) {
      setDailyChallenge((prev) => ({
        ...createInitialDailyChallengeState(),
        dateKey: resolvedTodayKey,
        status: DAILY_CHALLENGE_STATUS.IDLE,
        deferUntilKey: preservedDeferUntilKey,
      }));
      return;
    }
    const template = resolveTemplateCard(targetId);
    const priceUSD = template?.priceUSD || template?.basePriceUSD || 0;
    const templateLabel =
      (typeof template?.title === "string"
        ? template.title
        : template?.title?.[language] || template?.title?.en || template?.title?.ru || "") || "";
    const templateTitle = resolveTemplateTitle(targetId, templateLabel) || templateLabel;
    const baseReward = computeRefuseCoinReward(priceUSD, profile.currency || DEFAULT_PROFILE.currency);
    const rewardBonus = computeDailyChallengeBonus(priceUSD, profile.currency || DEFAULT_PROFILE.currency);
    setDailyChallenge({
      ...createInitialDailyChallengeState(),
      id: `daily-${resolvedTodayKey}-${targetId}`,
      dateKey: resolvedTodayKey,
      templateId: targetId,
      templateTitle,
      templateLabel,
      emoji: template?.emoji || "âœ¨",
      priceUSD,
      baseReward,
      rewardBonus,
      status: DAILY_CHALLENGE_STATUS.OFFER,
      offerDismissed: false,
      deferUntilKey: preservedDeferUntilKey,
    });
  }, [
    dailyChallenge.dateKey,
    dailyChallenge.templateId,
    dailyChallenge.deferUntilKey,
    dailyChallenge.status,
    dailyChallengeHydrated,
    language,
    dailyChallengePressure,
    profile.currency,
    temptationInteractions,
    resolveTemptationCategory,
    resolveTemplateCard,
    resolveTemplateTitle,
    todayKey,
    dailyChallengeRecentSaveIds,
  ]);
  useEffect(() => {
    if (!dailyChallengeHydrated) return;
    if (!historyHydrated) return;
    if (dailyChallengeUnlocked) return;
    if (
      dailyChallenge.status === DAILY_CHALLENGE_STATUS.IDLE &&
      !dailyChallenge.templateId
    ) {
      return;
    }
    setDailyChallenge(createInitialDailyChallengeState());
  }, [
    dailyChallenge.status,
    dailyChallenge.templateId,
    dailyChallengeHydrated,
    dailyChallengeUnlocked,
    historyHydrated,
  ]);
  const handleDailyChallengeAccept = useCallback(() => {
    if (!dailyChallengeUnlocked) return;
    if (!dailyChallenge.templateId) return;
    setDailyChallenge((prev) => {
      if (!prev || prev.status !== DAILY_CHALLENGE_STATUS.OFFER) return prev;
      return {
        ...prev,
        status: DAILY_CHALLENGE_STATUS.ACTIVE,
        acceptedAt: Date.now(),
        offerDismissed: true,
        deferUntilKey: null,
      };
    });
    clearQueuedModal(QUEUED_MODAL_TYPES.DAILY_CHALLENGE);
    logEvent("daily_challenge_accepted", { template_id: dailyChallenge.templateId });
  }, [clearQueuedModal, dailyChallenge.templateId, dailyChallengeUnlocked, logEvent]);
  const handleDailyChallengeDismiss = useCallback(() => {
    if (!dailyChallengeUnlocked) return;
    dailyChallengeOfferDeferredRef.current = true;
    setDailyChallengePromptGate(false);
    clearQueuedModal(QUEUED_MODAL_TYPES.DAILY_CHALLENGE);
  }, [clearQueuedModal, dailyChallengeUnlocked, setDailyChallengePromptGate]);
  const deferDailyChallenge = useCallback(
    (days) => {
      if (!dailyChallengeUnlocked) return;
      const normalizedDays = Math.max(0, Math.floor(Number(days) || 0));
      if (!normalizedDays) return;
      const deferUntilKey = getDayKey(Date.now() + normalizedDays * DAY_MS);
      setDailyChallenge((prev) => {
        const next = prev || createInitialDailyChallengeState();
        return {
          ...next,
          deferUntilKey,
          offerDismissed: true,
        };
      });
      clearQueuedModal(QUEUED_MODAL_TYPES.DAILY_CHALLENGE);
    },
    [clearQueuedModal, dailyChallengeUnlocked]
  );
  const handleDailyChallengeLater = useCallback(() => {
    if (!dailyChallengeUnlocked) return;
    Alert.alert(
      t("dailyChallengeSkipTitle"),
      t("dailyChallengeSkipMessage"),
      [
        {
          text: t("dailyChallengeSkipOption1"),
          onPress: () => deferDailyChallenge(1),
        },
        {
          text: t("dailyChallengeSkipOption3"),
          onPress: () => deferDailyChallenge(3),
        },
        {
          text: t("dailyChallengeSkipOption5"),
          onPress: () => deferDailyChallenge(5),
        },
        {
          text: t("dailyChallengeSkipOption7"),
          onPress: () => deferDailyChallenge(7),
        },
        { text: t("dailyChallengeSkipCancel"), style: "cancel" },
      ]
    );
  }, [dailyChallengeUnlocked, deferDailyChallenge, t]);
  const handleDailyChallengeCompleteClose = useCallback(() => {
    setDailyChallenge((prev) => {
      if (!prev || prev.status !== DAILY_CHALLENGE_STATUS.COMPLETED) return prev;
      if (prev.completionDismissed) return prev;
      return { ...prev, completionDismissed: true };
    });
    clearQueuedModal(QUEUED_MODAL_TYPES.DAILY_CHALLENGE_COMPLETE);
  }, [clearQueuedModal]);
  const completeDailyChallenge = useCallback(() => {
    if (!dailyChallengeUnlocked) return;
    if (!dailyChallenge.templateId) return;
    if (dailyChallenge.status !== DAILY_CHALLENGE_STATUS.ACTIVE) return;
    const rewardBonus = dailyChallengeRewardBonus || 0;
    setDailyChallenge((prev) => {
      if (!prev || prev.status !== DAILY_CHALLENGE_STATUS.ACTIVE) return prev;
      return {
        ...prev,
        status: DAILY_CHALLENGE_STATUS.COMPLETED,
        progress: prev.target,
        completedAt: Date.now(),
        rewardGranted: true,
        rewardBonus,
        completionDismissed: false,
      };
    });
    setDailyChallengeCompletedCount((prev) => Math.max(0, Number(prev) || 0) + 1);
    enqueueQueuedModal(QUEUED_MODAL_TYPES.DAILY_CHALLENGE_COMPLETE);
    if (rewardBonus > 0) {
      setHealthPoints((coins) => coins + rewardBonus);
      playSound("reward");
    }
    sendImmediateNotification({
      title: t("dailyChallengeRewardNotificationTitle"),
      body: t("dailyChallengeRewardNotificationBody", {
        temptation: dailyChallengeDisplayTitle || t("defaultDealTitle"),
        amount: dailyChallengeRewardLabel,
      }),
    });
    logEvent("daily_challenge_completed", {
      template_id: dailyChallenge.templateId,
      reward_bonus: rewardBonus,
    });
  }, [
    dailyChallengeUnlocked,
    dailyChallengeDisplayTitle,
    dailyChallengeRewardBonus,
    dailyChallenge.templateId,
    dailyChallenge.status,
    dailyChallengeRewardLabel,
    enqueueQueuedModal,
    sendImmediateNotification,
    logEvent,
    playSound,
    setHealthPoints,
    t,
  ]);
  const failDailyChallenge = useCallback(() => {
    if (!dailyChallengeUnlocked) return;
    if (!dailyChallenge.templateId) return;
    setDailyChallenge((prev) => {
      if (!prev || prev.status !== DAILY_CHALLENGE_STATUS.ACTIVE) return prev;
      return {
        ...prev,
        status: DAILY_CHALLENGE_STATUS.FAILED,
        failedAt: Date.now(),
      };
    });
    triggerOverlayState(
      "cancel",
      t("dailyChallengeFailedText", { temptation: dailyChallengeDisplayTitle })
    );
    logEvent("daily_challenge_failed", { template_id: dailyChallenge.templateId });
  }, [
    dailyChallengeUnlocked,
    dailyChallenge.templateId,
    dailyChallengeDisplayTitle,
    logEvent,
    t,
    triggerOverlayState,
  ]);
  useEffect(() => {
    if (!dailyChallengeHydrated) return;
    if (!dailyChallengeUnlocked) return;
    if (dailyChallenge.status !== DAILY_CHALLENGE_STATUS.ACTIVE) return;
    if (!dailyChallenge.templateId || !dailyChallenge.dateKey) return;
    const acceptedAt = dailyChallenge.acceptedAt || 0;
    const hasRefuse = resolvedHistoryEvents.some((entry) => {
      if (entry.kind !== "refuse_spend") return false;
      if (entry.meta?.templateId !== dailyChallenge.templateId) return false;
      if (getDayKey(entry.timestamp) !== dailyChallenge.dateKey) return false;
      if (acceptedAt && entry.timestamp < acceptedAt) return false;
      return true;
    });
    if (hasRefuse) {
      completeDailyChallenge();
    }
  }, [
    completeDailyChallenge,
    dailyChallengeUnlocked,
    dailyChallenge.acceptedAt,
    dailyChallenge.dateKey,
    dailyChallenge.status,
    dailyChallenge.templateId,
    dailyChallengeHydrated,
    resolvedHistoryEvents,
  ]);
  useEffect(() => {
    if (!dailyChallengeHydrated) return;
    if (!dailyChallengeUnlocked) return;
    if (dailyChallenge.status !== DAILY_CHALLENGE_STATUS.ACTIVE) return;
    if (!dailyChallenge.templateId || !dailyChallenge.dateKey) return;
    const acceptedAt = dailyChallenge.acceptedAt || 0;
    const lost = impulseEventsForInsights.some((event) => {
      if (event.action !== "spend") return false;
      if (event.templateId !== dailyChallenge.templateId) return false;
      if (getDayKey(event.timestamp) !== dailyChallenge.dateKey) return false;
      if (acceptedAt && event.timestamp < acceptedAt) return false;
      return true;
    });
    if (lost) {
      failDailyChallenge();
    }
  }, [
    dailyChallenge.acceptedAt,
    dailyChallenge.dateKey,
    dailyChallenge.status,
    dailyChallenge.templateId,
    dailyChallengeHydrated,
    dailyChallengeUnlocked,
    failDailyChallenge,
    impulseEventsForInsights,
  ]);

  const persistCustomReminderId = useCallback(
    (id) => {
      setCustomReminderId(id);
      if (id) {
        AsyncStorage.setItem(STORAGE_KEYS.CUSTOM_REMINDER, id).catch(() => {});
      } else {
        AsyncStorage.removeItem(STORAGE_KEYS.CUSTOM_REMINDER).catch(() => {});
      }
    },
    []
  );

  const schedulePersonalTemptationReminder = useCallback(
    async (customSpend) => {
      if (
        !customSpend?.title ||
        !Number.isFinite(customSpend.frequencyPerWeek) ||
        customSpend.frequencyPerWeek <= 0
      ) {
        if (customReminderId) {
          safeNotifications.cancelScheduledNotificationAsync(customReminderId);
          persistCustomReminderId(null);
        }
        return;
      }
      const permitted = await ensureNotificationPermission({ request: false });
      if (!permitted) return;
      if (customReminderId) {
        await safeNotifications.cancelScheduledNotificationAsync(customReminderId);
      }
      const frequency = Math.max(1, customSpend.frequencyPerWeek);
      const intervalDays = Math.max(1, Math.round(7 / frequency));
      const seconds = Math.max(6 * 60 * 60, intervalDays * 24 * 60 * 60);
      const title = tVariant("smartReminderTitle", { temptation: customSpend.title });
      const body = tVariant("smartReminderBody", { temptation: customSpend.title });
      try {
        const scheduled = await scheduleNotificationWithCooldown({
          content: { title, body },
          trigger: { seconds, repeats: true },
        });
        persistCustomReminderId(scheduled?.id || null);
      } catch (error) {
        console.warn("custom reminder", error);
        persistCustomReminderId(null);
      }
    },
    [customReminderId, ensureNotificationPermission, persistCustomReminderId, scheduleNotificationWithCooldown, tVariant]
  );
  const clearLegacyDailyNudges = useCallback(async () => {
    try {
      const scheduled = await safeNotifications.getAllScheduledNotificationsAsync();
      if (!Array.isArray(scheduled) || !scheduled.length) return;
      const identifiers = scheduled
        .filter((entry) => isKnownDailyNudgeNotification(entry?.content))
        .map((entry) => entry?.identifier)
        .filter(Boolean);
      if (!identifiers.length) return;
      await Promise.all(
        identifiers.map((id) => safeNotifications.cancelScheduledNotificationAsync(id))
      );
    } catch (error) {
      console.warn("daily nudge cleanup", error);
    }
  }, []);

  const rescheduleDailyNudgeNotifications = useCallback(async ({ force = false } = {}) => {
    if (!dailyNudgesHydrated || !DAILY_NUDGE_REMINDERS.length) return;
    const signatureVersion = "v1";
    const signaturePayload = {
      version: signatureVersion,
      language,
      reminders: DAILY_NUDGE_REMINDERS.map((def) => ({
        id: def.id,
        hour: def.hour,
        minute: def.minute,
        titleKey: def.titleKey,
        bodyKey: def.bodyKey,
      })),
    };
    const signature = JSON.stringify(signaturePayload);
    const existingIds = Object.values(dailyNudgeIdsRef.current || {}).filter(Boolean);
    const storedSignature = await AsyncStorage.getItem(
      STORAGE_KEYS.DAILY_NUDGE_SCHEDULE_SIGNATURE
    ).catch(() => null);
    if (!force && storedSignature === signature && existingIds.length) {
      return;
    }
    const permitted = await ensureNotificationPermission({ request: false });
    if (!permitted) return;
    const existing = Object.values(dailyNudgeIdsRef.current || {});
    if (existing.length) {
      await Promise.all(
        existing.map((notificationId) =>
          safeNotifications.cancelScheduledNotificationAsync(notificationId)
        )
      );
    }
    await clearLegacyDailyNudges();
    const nextMap = {};
    for (const def of DAILY_NUDGE_REMINDERS) {
      try {
        const isStreakNudge = typeof def.id === "string" && def.id.startsWith("streak_");
        if (isStreakNudge && usageStreakLoggedToday) {
          continue;
        }
        const trigger = isStreakNudge
          ? buildDailyNudgeTrigger(def.hour, def.minute, { repeats: false, allowPast: false })
          : buildDailyNudgeTrigger(def.hour, def.minute);
        if (!trigger) continue;
        const scheduledEntry = await scheduleNotificationWithCooldown({
          content: {
            title: tVariant(def.titleKey),
            body: tVariant(def.bodyKey),
            data: { type: DAILY_NUDGE_NOTIFICATION_TAG, locale: language },
            ...(Platform.OS === "android" ? { channelId: ANDROID_DAILY_NUDGE_CHANNEL_ID } : null),
          },
          trigger,
        });
        if (scheduledEntry?.id) {
          nextMap[def.id] = scheduledEntry.id;
        }
      } catch (error) {
        console.warn("daily nudge schedule", error);
      }
    }
    setDailyNudgeNotificationIds(nextMap);
    AsyncStorage.setItem(STORAGE_KEYS.DAILY_NUDGE_SCHEDULE_SIGNATURE, signature).catch(() => {});
  }, [
    clearLegacyDailyNudges,
    dailyNudgesHydrated,
    ensureNotificationPermission,
    language,
    scheduleNotificationWithCooldown,
    tVariant,
    usageStreakLoggedToday,
  ]);

  useEffect(() => {
    if (!dailyNudgesHydrated) return;
    rescheduleDailyNudgeNotifications();
  }, [
    dailyNudgesHydrated,
    language,
    notificationPermissionGranted,
    rescheduleDailyNudgeNotifications,
    tVariant,
  ]);
  useEffect(() => {
    if (!dailyNudgesHydrated) return;
    if (notificationPermissionGranted !== true) return;
    rescheduleDailyNudgeNotifications({ force: true });
  }, [
    currentDayKey,
    dailyNudgesHydrated,
    notificationPermissionGranted,
    rescheduleDailyNudgeNotifications,
    usageStreakLoggedToday,
  ]);

  const scheduleWeeklyReportNotification = useCallback(
    async ({ force = false } = {}) => {
      if (!reportsUnlocked || !reportsHaveWeeklyData) {
        if (reportsWeeklyNotificationId) {
          try {
            await safeNotifications.cancelScheduledNotificationAsync(reportsWeeklyNotificationId);
          } catch (error) {
            console.warn("weekly report cancel", error);
          }
          setReportsWeeklyNotificationId(null);
        }
        reportsWeeklyNotificationLocaleRef.current = null;
        return;
      }
      const permitted = await ensureNotificationPermission({ request: false });
      if (!permitted) return;
      const normalizedLanguage = normalizeLanguage(language);
      const shouldReschedule =
        force ||
        !reportsWeeklyNotificationId ||
        reportsWeeklyNotificationLocaleRef.current !== normalizedLanguage;
      if (!shouldReschedule && reportsWeeklyNotificationId) return;
      try {
        const trigger = {
          weekday: WEEKLY_REPORT_WEEKDAY,
          hour: WEEKLY_REPORT_HOUR,
          minute: WEEKLY_REPORT_MINUTE,
          repeats: true,
        };
        const scheduledId = await safeNotifications.scheduleNotificationAsync({
          content: {
            title: t("reportsWeeklyNotificationTitle"),
            body: t("reportsWeeklyNotificationBody"),
            data: {
              kind: "weekly_report",
              targetScreen: "reports",
              dedupeKey: REPORTS_WEEKLY_NOTIFICATION_DEDUPE,
            },
            ...(Platform.OS === "android" ? { channelId: ANDROID_REPORTS_CHANNEL_ID } : null),
          },
          trigger,
        });
        if (!scheduledId) return;
        if (reportsWeeklyNotificationId && reportsWeeklyNotificationId !== scheduledId) {
          await safeNotifications.cancelScheduledNotificationAsync(reportsWeeklyNotificationId);
        }
        setReportsWeeklyNotificationId(scheduledId);
        reportsWeeklyNotificationLocaleRef.current = normalizedLanguage;
      } catch (error) {
        console.warn("weekly report schedule", error);
      }
    },
    [
      ensureNotificationPermission,
      language,
      reportsHaveWeeklyData,
      reportsUnlocked,
      reportsWeeklyNotificationId,
      t,
    ]
  );

  useEffect(() => {
    if (!reportsWeeklyNotificationHydrated) return;
    if (notificationPermissionGranted !== true) return;
    if (!reportsUnlocked) return;
    if (!reportsHaveWeeklyData) return;
    scheduleWeeklyReportNotification();
  }, [
    notificationPermissionGranted,
    reportsHaveWeeklyData,
    reportsUnlocked,
    reportsWeeklyNotificationHydrated,
    scheduleWeeklyReportNotification,
  ]);

  useEffect(() => {
    if (!reportsWeeklyNotificationHydrated) return;
    if (notificationPermissionGranted !== true) return;
    if (reportsUnlocked && reportsHaveWeeklyData) return;
    if (!reportsWeeklyNotificationId) return;
    safeNotifications.cancelScheduledNotificationAsync(reportsWeeklyNotificationId);
    setReportsWeeklyNotificationId(null);
    reportsWeeklyNotificationLocaleRef.current = null;
  }, [
    notificationPermissionGranted,
    reportsHaveWeeklyData,
    reportsUnlocked,
    reportsWeeklyNotificationHydrated,
    reportsWeeklyNotificationId,
  ]);

  useEffect(() => {
    if (!reportsWeeklyNotificationHydrated) return;
    if (notificationPermissionGranted !== false) return;
    if (!reportsWeeklyNotificationId) return;
    safeNotifications.cancelScheduledNotificationAsync(reportsWeeklyNotificationId);
    setReportsWeeklyNotificationId(null);
  }, [notificationPermissionGranted, reportsWeeklyNotificationHydrated, reportsWeeklyNotificationId]);

  const runDeferredHydration = useCallback(() => {
      if (deferredHydrationReadyRef.current || deferredHydrationInFlightRef.current) return;
      const payload = deferredHydrationPayloadRef.current;
      if (!payload) return;
      deferredHydrationInFlightRef.current = true;
      try {
        const { decisionStatsRaw } = payload;
        if (decisionStatsRaw) {
          try {
            setDecisionStats({ ...INITIAL_DECISION_STATS, ...JSON.parse(decisionStatsRaw) });
          } catch (error) {
            console.warn("decision stats parse", error);
            setDecisionStats({ ...INITIAL_DECISION_STATS });
          }
        } else {
          setDecisionStats({ ...INITIAL_DECISION_STATS });
        }
        setDecisionStatsHydrated(true);
      } finally {
        deferredHydrationPayloadRef.current = null;
        deferredHydrationInFlightRef.current = false;
        deferredHydrationReadyRef.current = true;
        setDeferredHydrationReady(true);
      }
  }, []);

  const loadStoredData = async () => {
    const resetCounterAtStart = resetCounterRef.current;
    let resolvedHealthPoints = null;
    let tutorialRaw = null;
    let temptationTutorialRaw = null;
    try {
      tutorialRaw = await AsyncStorage.getItem(STORAGE_KEYS.TUTORIAL);
    } catch (error) {
      console.warn("tutorial hydrate", error);
    }
    try {
      temptationTutorialRaw = await AsyncStorage.getItem(STORAGE_KEYS.TEMPTATION_TUTORIAL);
    } catch (error) {
      console.warn("temptation tutorial hydrate", error);
    }
    setTutorialSeen((prev) => prev || tutorialRaw === "done");
    setTutorialHydrated(true);
    const normalizedTemptationTutorial =
      temptationTutorialRaw === "done" ? "done" : "pending";
    setTemptationTutorialStatus((prev) =>
      prev === "done" ? prev : normalizedTemptationTutorial
    );
    setTemptationTutorialSeen((prev) => prev || normalizedTemptationTutorial === "done");
    setTemptationTutorialCompleted(normalizedTemptationTutorial === "done");
    if (normalizedTemptationTutorial !== temptationTutorialRaw) {
      AsyncStorage.setItem(
        STORAGE_KEYS.TEMPTATION_TUTORIAL,
        normalizedTemptationTutorial
      ).catch(() => {});
    }
    setTemptationTutorialHydrated(true);
    try {
      const hydrationKeys = [
        STORAGE_KEYS.WISHES,
        STORAGE_KEYS.PENDING,
        STORAGE_KEYS.PURCHASES,
        STORAGE_KEYS.PROFILE,
        STORAGE_KEYS.THEME,
        STORAGE_KEYS.PRO_THEME_ACCENT,
        STORAGE_KEYS.LANGUAGE,
        STORAGE_KEYS.SOUND_ENABLED,
        STORAGE_KEYS.ONBOARDING,
        STORAGE_KEYS.CATALOG,
        STORAGE_KEYS.PRICE_PRECISION_OVERRIDES,
        STORAGE_KEYS.TITLE_OVERRIDES,
        STORAGE_KEYS.EMOJI_OVERRIDES,
        STORAGE_KEYS.CATEGORY_OVERRIDES,
        STORAGE_KEYS.CUSTOM_CATEGORIES,
        STORAGE_KEYS.REMOVED_CATEGORIES,
        STORAGE_KEYS.SAVINGS_CATEGORY_OVERRIDE,
        STORAGE_KEYS.CATEGORY_DEF_OVERRIDES,
        STORAGE_KEYS.DESCRIPTION_OVERRIDES,
        STORAGE_KEYS.SAVED_TOTAL,
        STORAGE_KEYS.SAVED_TOTAL_PROGRESS,
        STORAGE_KEYS.LEVEL_PROGRESS_OFFSET,
        STORAGE_KEYS.DECLINES,
        STORAGE_KEYS.FREE_DAY,
        STORAGE_KEYS.USAGE_STREAK,
        STORAGE_KEYS.STREAK_PLEDGE,
        STORAGE_KEYS.DECISION_STATS,
        STORAGE_KEYS.HISTORY,
        STORAGE_KEYS.REFUSE_STATS,
        STORAGE_KEYS.TEMPTATION_INTERACTIONS,
        STORAGE_KEYS.REWARDS_CELEBRATED,
        STORAGE_KEYS.ANALYTICS_OPT_OUT,
        STORAGE_KEYS.TEMPTATION_GOALS,
        STORAGE_KEYS.CUSTOM_TEMPTATIONS,
        STORAGE_KEYS.CUSTOM_TEMPTATIONS_CREATED,
        STORAGE_KEYS.HIDDEN_TEMPTATIONS,
        STORAGE_KEYS.ARCHIVED_TEMPTATIONS,
        STORAGE_KEYS.HEALTH,
        STORAGE_KEYS.CLAIMED_REWARDS,
        STORAGE_KEYS.REWARD_TOTAL,
        STORAGE_KEYS.INCOME_ENTRIES,
        STORAGE_KEYS.BUDGET_LIMITS,
        STORAGE_KEYS.BUDGET_OVERSPEND,
        STORAGE_KEYS.INCOME_PROMPT,
        STORAGE_KEYS.IMPULSE_TRACKER,
        STORAGE_KEYS.MOOD_STATE,
        STORAGE_KEYS.CHALLENGES,
        STORAGE_KEYS.CHALLENGE_BADGES,
        STORAGE_KEYS.CUSTOM_REMINDER,
        STORAGE_KEYS.DAILY_NUDGES,
        STORAGE_KEYS.SMART_REMINDERS,
        STORAGE_KEYS.POTENTIAL_PUSH_PROGRESS,
        STORAGE_KEYS.TAMAGOTCHI,
        STORAGE_KEYS.TAMAGOTCHI_GREETING_DAY,
        STORAGE_KEYS.TAMAGOTCHI_HUNGER_NOTIFICATIONS,
        STORAGE_KEYS.TAMAGOTCHI_HUNGER_DAILY_COUNT,
        STORAGE_KEYS.TAMAGOTCHI_HUNGER_LAST_AT,
        STORAGE_KEYS.DAILY_CHALLENGE,
        STORAGE_KEYS.DAILY_CHALLENGE_COMPLETED_TOTAL,
        STORAGE_KEYS.DAILY_REWARD,
        STORAGE_KEYS.DAILY_REWARD_DAY_KEY,
        STORAGE_KEYS.DAILY_GOAL_COLLECTED,
        STORAGE_KEYS.DAILY_SUMMARY,
        STORAGE_KEYS.TERMS_ACCEPTED,
        STORAGE_KEYS.FOCUS_TARGET,
        STORAGE_KEYS.FOCUS_DIGEST,
        STORAGE_KEYS.FOCUS_VICTORY_TOTAL,
        STORAGE_KEYS.FOCUS_DIGEST_PENDING,
        STORAGE_KEYS.TAMAGOTCHI_SKIN,
        STORAGE_KEYS.SAVED_TOTAL_PEAK,
        STORAGE_KEYS.SAVED_TOTAL_PROGRESS_PEAK,
        STORAGE_KEYS.LAST_CELEBRATED_LEVEL,
        STORAGE_KEYS.ACTIVE_GOAL,
        STORAGE_KEYS.COIN_SLIDER_MAX,
        STORAGE_KEYS.FAB_TUTORIAL,
        STORAGE_KEYS.BUDGET_WIDGET_TUTORIAL,
        STORAGE_KEYS.NORTH_STAR_METRIC,
        STORAGE_KEYS.PRIMARY_TEMPTATION_PROMPT,
        STORAGE_KEYS.COIN_VALUE_MODAL,
        STORAGE_KEYS.RATING_PROMPT,
        STORAGE_KEYS.REPORTS_BADGE,
        STORAGE_KEYS.REPORTS_LAST_AUTO_WEEK,
        STORAGE_KEYS.REPORTS_WEEKLY_NOTIFICATION,
        STORAGE_KEYS.PREMIUM_INSTALL_ID,
        STORAGE_KEYS.PREMIUM_SOFT_PAYWALL_SHOWN,
        STORAGE_KEYS.PREMIUM_HARD_PAYWALL_SHOWN,
        STORAGE_KEYS.PREMIUM_CHALLENGE_CLAIMS,
      ];
      const storedPairs = await AsyncStorage.multiGet(hydrationKeys);
      const storedMap = Object.fromEntries(storedPairs || []);
      const wishesRaw = storedMap[STORAGE_KEYS.WISHES] ?? null;
      const pendingRaw = storedMap[STORAGE_KEYS.PENDING] ?? null;
      const purchasesRaw = storedMap[STORAGE_KEYS.PURCHASES] ?? null;
      const profileRaw = storedMap[STORAGE_KEYS.PROFILE] ?? null;
      const themeRaw = storedMap[STORAGE_KEYS.THEME] ?? null;
      const proThemeAccentRaw = storedMap[STORAGE_KEYS.PRO_THEME_ACCENT] ?? null;
      const languageRaw = storedMap[STORAGE_KEYS.LANGUAGE] ?? null;
      const soundEnabledRaw = storedMap[STORAGE_KEYS.SOUND_ENABLED] ?? null;
      const onboardingRaw = storedMap[STORAGE_KEYS.ONBOARDING] ?? null;
      const catalogRaw = storedMap[STORAGE_KEYS.CATALOG] ?? null;
      const pricePrecisionRaw = storedMap[STORAGE_KEYS.PRICE_PRECISION_OVERRIDES] ?? null;
      const titleRaw = storedMap[STORAGE_KEYS.TITLE_OVERRIDES] ?? null;
      const emojiOverridesRaw = storedMap[STORAGE_KEYS.EMOJI_OVERRIDES] ?? null;
      const categoryOverridesRaw = storedMap[STORAGE_KEYS.CATEGORY_OVERRIDES] ?? null;
      const customCategoriesRaw = storedMap[STORAGE_KEYS.CUSTOM_CATEGORIES] ?? null;
      const removedCategoriesRaw = storedMap[STORAGE_KEYS.REMOVED_CATEGORIES] ?? null;
      const savingsCategoryOverrideRaw = storedMap[STORAGE_KEYS.SAVINGS_CATEGORY_OVERRIDE] ?? null;
      const categoryDefOverridesRaw = storedMap[STORAGE_KEYS.CATEGORY_DEF_OVERRIDES] ?? null;
      const descriptionOverridesRaw = storedMap[STORAGE_KEYS.DESCRIPTION_OVERRIDES] ?? null;
      const savedTotalRaw = storedMap[STORAGE_KEYS.SAVED_TOTAL] ?? null;
      const progressSavedTotalRaw = storedMap[STORAGE_KEYS.SAVED_TOTAL_PROGRESS] ?? null;
      const levelProgressOffsetRaw = storedMap[STORAGE_KEYS.LEVEL_PROGRESS_OFFSET] ?? null;
      const declinesRaw = storedMap[STORAGE_KEYS.DECLINES] ?? null;
      const freeDayRaw = storedMap[STORAGE_KEYS.FREE_DAY] ?? null;
      const usageStreakRaw = storedMap[STORAGE_KEYS.USAGE_STREAK] ?? null;
      const streakPledgeRaw = storedMap[STORAGE_KEYS.STREAK_PLEDGE] ?? null;
      const decisionStatsRaw = storedMap[STORAGE_KEYS.DECISION_STATS] ?? null;
      const historyRaw = storedMap[STORAGE_KEYS.HISTORY] ?? null;
      const refuseStatsRaw = storedMap[STORAGE_KEYS.REFUSE_STATS] ?? null;
      const temptationInteractionsRaw = storedMap[STORAGE_KEYS.TEMPTATION_INTERACTIONS] ?? null;
      const rewardsCelebratedRaw = storedMap[STORAGE_KEYS.REWARDS_CELEBRATED] ?? null;
      const analyticsOptOutRaw = storedMap[STORAGE_KEYS.ANALYTICS_OPT_OUT] ?? null;
      const goalMapRaw = storedMap[STORAGE_KEYS.TEMPTATION_GOALS] ?? null;
      const customTemptationsRaw = storedMap[STORAGE_KEYS.CUSTOM_TEMPTATIONS] ?? null;
      const customTemptationsCreatedRaw =
        storedMap[STORAGE_KEYS.CUSTOM_TEMPTATIONS_CREATED] ?? null;
      const hiddenTemptationsRaw = storedMap[STORAGE_KEYS.HIDDEN_TEMPTATIONS] ?? null;
      const archivedTemptationsRaw = storedMap[STORAGE_KEYS.ARCHIVED_TEMPTATIONS] ?? null;
      const healthRaw = storedMap[STORAGE_KEYS.HEALTH] ?? null;
      const claimedRewardsRaw = storedMap[STORAGE_KEYS.CLAIMED_REWARDS] ?? null;
      const rewardTotalRaw = storedMap[STORAGE_KEYS.REWARD_TOTAL] ?? null;
      const incomeEntriesRaw = storedMap[STORAGE_KEYS.INCOME_ENTRIES] ?? null;
      const budgetLimitsRaw = storedMap[STORAGE_KEYS.BUDGET_LIMITS] ?? null;
      const incomePromptRaw = storedMap[STORAGE_KEYS.INCOME_PROMPT] ?? null;
      const budgetOverspendRaw = storedMap[STORAGE_KEYS.BUDGET_OVERSPEND] ?? null;
      const impulseTrackerRaw = storedMap[STORAGE_KEYS.IMPULSE_TRACKER] ?? null;
      const moodRaw = storedMap[STORAGE_KEYS.MOOD_STATE] ?? null;
      const challengesRaw = storedMap[STORAGE_KEYS.CHALLENGES] ?? null;
      const challengeBadgesRaw = storedMap[STORAGE_KEYS.CHALLENGE_BADGES] ?? null;
      const customReminderRaw = storedMap[STORAGE_KEYS.CUSTOM_REMINDER] ?? null;
      const dailyNudgesRaw = storedMap[STORAGE_KEYS.DAILY_NUDGES] ?? null;
      const smartRemindersRaw = storedMap[STORAGE_KEYS.SMART_REMINDERS] ?? null;
      const potentialPushProgressRaw = storedMap[STORAGE_KEYS.POTENTIAL_PUSH_PROGRESS] ?? null;
      const tamagotchiRaw = storedMap[STORAGE_KEYS.TAMAGOTCHI] ?? null;
      const tamagotchiGreetingDayRaw = storedMap[STORAGE_KEYS.TAMAGOTCHI_GREETING_DAY] ?? null;
      const tamagotchiHungerNotificationsRaw = storedMap[STORAGE_KEYS.TAMAGOTCHI_HUNGER_NOTIFICATIONS] ?? null;
      const tamagotchiHungerDailyCountRaw = storedMap[STORAGE_KEYS.TAMAGOTCHI_HUNGER_DAILY_COUNT] ?? null;
      const tamagotchiHungerLastAtRaw = storedMap[STORAGE_KEYS.TAMAGOTCHI_HUNGER_LAST_AT] ?? null;
      const dailyChallengeRaw = storedMap[STORAGE_KEYS.DAILY_CHALLENGE] ?? null;
      const dailyChallengeCompletedRaw =
        storedMap[STORAGE_KEYS.DAILY_CHALLENGE_COMPLETED_TOTAL] ?? null;
      const dailyRewardRaw = storedMap[STORAGE_KEYS.DAILY_REWARD] ?? null;
      const dailyRewardDayKeyRaw = storedMap[STORAGE_KEYS.DAILY_REWARD_DAY_KEY] ?? null;
      const dailyGoalCollectedRaw = storedMap[STORAGE_KEYS.DAILY_GOAL_COLLECTED] ?? null;
      const dailySummaryRaw = storedMap[STORAGE_KEYS.DAILY_SUMMARY] ?? null;
      const termsAcceptedRaw = storedMap[STORAGE_KEYS.TERMS_ACCEPTED] ?? null;
      const focusTargetRaw = storedMap[STORAGE_KEYS.FOCUS_TARGET] ?? null;
      const focusDigestRaw = storedMap[STORAGE_KEYS.FOCUS_DIGEST] ?? null;
      const focusVictoryRaw = storedMap[STORAGE_KEYS.FOCUS_VICTORY_TOTAL] ?? null;
      const focusDigestPendingRaw = storedMap[STORAGE_KEYS.FOCUS_DIGEST_PENDING] ?? null;
      const tamagotchiSkinRaw = storedMap[STORAGE_KEYS.TAMAGOTCHI_SKIN] ?? null;
      const savedPeakRaw = storedMap[STORAGE_KEYS.SAVED_TOTAL_PEAK] ?? null;
      const progressSavedPeakRaw = storedMap[STORAGE_KEYS.SAVED_TOTAL_PROGRESS_PEAK] ?? null;
      const lastCelebratedLevelRaw = storedMap[STORAGE_KEYS.LAST_CELEBRATED_LEVEL] ?? null;
      const activeGoalRaw = storedMap[STORAGE_KEYS.ACTIVE_GOAL] ?? null;
      const coinSliderMaxRaw = storedMap[STORAGE_KEYS.COIN_SLIDER_MAX] ?? null;
      const fabTutorialRaw = storedMap[STORAGE_KEYS.FAB_TUTORIAL] ?? null;
      const budgetWidgetTutorialRaw = storedMap[STORAGE_KEYS.BUDGET_WIDGET_TUTORIAL] ?? null;
      const northStarMetricRaw = storedMap[STORAGE_KEYS.NORTH_STAR_METRIC] ?? null;
      const primaryTemptationPromptRaw = storedMap[STORAGE_KEYS.PRIMARY_TEMPTATION_PROMPT] ?? null;
      const coinValueModalRaw = storedMap[STORAGE_KEYS.COIN_VALUE_MODAL] ?? null;
      const ratingPromptRaw = storedMap[STORAGE_KEYS.RATING_PROMPT] ?? null;
      const reportsBadgeRaw = storedMap[STORAGE_KEYS.REPORTS_BADGE] ?? null;
      const reportsLastAutoWeekRaw = storedMap[STORAGE_KEYS.REPORTS_LAST_AUTO_WEEK] ?? null;
      const reportsWeeklyNotificationRaw =
        storedMap[STORAGE_KEYS.REPORTS_WEEKLY_NOTIFICATION] ?? null;
      const premiumInstallIdRaw = storedMap[STORAGE_KEYS.PREMIUM_INSTALL_ID] ?? null;
      const premiumSoftPaywallRaw = storedMap[STORAGE_KEYS.PREMIUM_SOFT_PAYWALL_SHOWN] ?? null;
      const premiumHardPaywallRaw = storedMap[STORAGE_KEYS.PREMIUM_HARD_PAYWALL_SHOWN] ?? null;
      const premiumChallengeClaimsRaw = storedMap[STORAGE_KEYS.PREMIUM_CHALLENGE_CLAIMS] ?? null;
      const deferWishesHydration = shouldDeferLargeParse(wishesRaw);
      const hydrateWishes = () => {
        try {
          if (wishesRaw) {
            setWishes(JSON.parse(wishesRaw));
          } else {
            setWishes([]);
          }
        } catch (error) {
          console.warn("wishes parse", error);
          setWishes([]);
        } finally {
          setWishesHydrated(true);
        }
      };
      if (deferWishesHydration) {
        setWishes([]);
        deferNonFeedHydration(hydrateWishes);
      } else {
        hydrateWishes();
      }
      const hydratePending = () => {
        try {
          if (pendingRaw) {
            setPendingList(JSON.parse(pendingRaw));
          } else {
            setPendingList([]);
          }
        } catch (error) {
          console.warn("pending parse", error);
          setPendingList([]);
        } finally {
          setPendingHydrated(true);
        }
      };
      deferNonFeedHydration(hydratePending);
      deferredHydrationPayloadRef.current = { decisionStatsRaw };
      deferredHydrationReadyRef.current = false;
      setDeferredHydrationReady(false);
      const hydratePurchases = () => {
        try {
          if (purchasesRaw) {
            setPurchases(JSON.parse(purchasesRaw));
          } else {
            setPurchases([]);
          }
        } catch (error) {
          console.warn("purchases parse", error);
          setPurchases([]);
        } finally {
          setPurchasesHydrated(true);
        }
      };
      setPurchases([]);
      deferNonFeedHydration(hydratePurchases);
      let parsedProfile = null;
      const storedActiveGoalId = activeGoalRaw || null;
      let hydratedGoalId = storedActiveGoalId;
      if (profileRaw) {
        const rawProfile = JSON.parse(profileRaw);
        parsedProfile = { ...DEFAULT_PROFILE, ...rawProfile };
        if (!Object.prototype.hasOwnProperty.call(rawProfile, "goal")) {
          parsedProfile.goal = null;
        }
        if (!Object.prototype.hasOwnProperty.call(rawProfile, "primaryGoals")) {
          parsedProfile.primaryGoals = [];
        }
        if (!Object.prototype.hasOwnProperty.call(rawProfile, "goalTargetUSD")) {
          parsedProfile.goalTargetUSD = 0;
        }
        const trimmedFirstName = (parsedProfile.firstName || "").trim();
        const trimmedLastName = (parsedProfile.lastName || "").trim();
        const trimmedName = (parsedProfile.name || "").trim();
        if (!trimmedFirstName && !trimmedLastName && trimmedName === DEFAULT_PROFILE.name) {
          parsedProfile.name = "";
        } else if (!trimmedName) {
          parsedProfile.name = [trimmedFirstName, trimmedLastName].filter(Boolean).join(" ").trim();
        } else {
          parsedProfile.name = trimmedName;
        }
        const trimmedBio = (parsedProfile.bio || "").trim();
        if (!trimmedBio || PROFILE_BIO_FALLBACK_VALUES.includes(trimmedBio)) {
          parsedProfile.bio = "";
        } else {
          parsedProfile.bio = trimmedBio;
        }
        const rawIncomePayday = Number(parsedProfile.incomePayday);
        parsedProfile.incomePayday =
          Number.isFinite(rawIncomePayday) && rawIncomePayday >= 1 && rawIncomePayday <= 31
            ? Math.round(rawIncomePayday)
            : DEFAULT_INCOME_PAYDAY;
        const normalizedPrimaryGoals = Array.isArray(parsedProfile.primaryGoals)
          ? parsedProfile.primaryGoals
              .map((entry) => {
                const goalId = entry?.id || parsedProfile.goal || DEFAULT_PROFILE.goal;
                if (!goalId) return null;
                const targetUSD =
                  Number.isFinite(entry?.targetUSD) && entry.targetUSD > 0
                    ? entry.targetUSD
                    : getGoalDefaultTargetUSD(goalId);
                const normalized = {
                  id: goalId,
                  targetUSD,
                  savedUSD: Number.isFinite(entry?.savedUSD) ? entry.savedUSD : 0,
                  status: entry?.status && entry.status !== "done" ? entry.status : "active",
                  createdAt: entry?.createdAt || null,
                };
                const customTitle =
                  typeof entry?.customTitle === "string" ? entry.customTitle.trim() : "";
                if (customTitle) {
                  normalized.customTitle = customTitle;
                }
                if (entry?.customEmoji) {
                  normalized.customEmoji = normalizeEmojiValue(entry.customEmoji, DEFAULT_GOAL_EMOJI);
                }
                return normalized;
              })
              .filter((entry) => {
                if (!entry?.id) return false;
                const customTitle =
                  typeof entry.customTitle === "string" ? entry.customTitle.trim() : "";
                return !!customTitle || !!getGoalPreset(entry.id);
              })
          : [];
        const hasPrimaryGoals = normalizedPrimaryGoals.length > 0;
        const storedGoalId = hasPrimaryGoals ? activeGoalRaw || parsedProfile.goal || null : null;
        const activeGoalEntry =
          hasPrimaryGoals && storedGoalId
            ? normalizedPrimaryGoals.find((goal) => goal.id === storedGoalId)
            : null;
        const orderedPrimaryGoals = hasPrimaryGoals
          ? activeGoalEntry
            ? [activeGoalEntry, ...normalizedPrimaryGoals.filter((goal) => goal.id !== activeGoalEntry.id)]
            : normalizedPrimaryGoals
          : [];
        if (orderedPrimaryGoals.length) {
          const profileGoalId = activeGoalEntry?.id || orderedPrimaryGoals[0]?.id || null;
          hydratedGoalId = profileGoalId;
          parsedProfile.primaryGoals = orderedPrimaryGoals;
          parsedProfile.goal = profileGoalId;
          const activeTargetEntry =
            orderedPrimaryGoals.find((goal) => goal.id === profileGoalId) || orderedPrimaryGoals[0];
          const activeTargetUSD =
            Number.isFinite(activeTargetEntry?.targetUSD) && activeTargetEntry.targetUSD > 0
              ? activeTargetEntry.targetUSD
              : parsedProfile.goalTargetUSD ||
                getGoalDefaultTargetUSD(profileGoalId || activeTargetEntry?.id || DEFAULT_PROFILE.goal);
          parsedProfile.goalTargetUSD = activeTargetUSD;
        } else {
          const fallbackGoalId = parsedProfile.goal || storedActiveGoalId || null;
          hydratedGoalId = fallbackGoalId;
          parsedProfile.primaryGoals = [];
          parsedProfile.goal = fallbackGoalId;
          parsedProfile.goalTargetUSD =
            Number.isFinite(parsedProfile.goalTargetUSD) && parsedProfile.goalTargetUSD > 0
              ? parsedProfile.goalTargetUSD
              : 0;
        }
        parsedProfile.goalCelebrated = !!parsedProfile.goalCelebrated;
        parsedProfile.spendingProfile = {
          baselineMonthlyWasteUSD: Math.max(
            0,
            Number(parsedProfile.spendingProfile?.baselineMonthlyWasteUSD) || 0
          ),
          baselineStartAt: parsedProfile.spendingProfile?.baselineStartAt || null,
        };
        if (!parsedProfile.joinedAt) {
          parsedProfile.joinedAt =
            parsedProfile.spendingProfile?.baselineStartAt || new Date().toISOString();
        }
        parsedProfile.reports = normalizeProfileReports(parsedProfile.reports);
        parsedProfile.avatar = normalizeAvatarStorageValue(parsedProfile.avatar);
        setProfile(parsedProfile);
        setProfileDraft(parsedProfile);
        setRegistrationData((prev) => ({
          ...prev,
          firstName: parsedProfile.firstName || prev.firstName,
          lastName: parsedProfile.lastName || prev.lastName,
          motto: parsedProfile.motto || parsedProfile.subtitle || prev.motto,
          avatar: parsedProfile.avatar || prev.avatar,
          currency: parsedProfile.currency || prev.currency,
          gender: parsedProfile.gender || prev.gender,
          persona: parsedProfile.persona || prev.persona,
        }));
        setActiveCurrency(parsedProfile.currency || DEFAULT_PROFILE.currency);
      } else {
        const freshProfile = { ...DEFAULT_PROFILE_PLACEHOLDER, joinedAt: new Date().toISOString() };
        setProfile(freshProfile);
        setProfileDraft(freshProfile);
        setActiveCurrency(DEFAULT_PROFILE.currency);
      }
      if (customReminderRaw) {
        setCustomReminderId(customReminderRaw);
      } else {
        setCustomReminderId(null);
      }
      setCustomReminderHydrated(true);
      if (dailyNudgesRaw) {
        try {
          const parsed = JSON.parse(dailyNudgesRaw);
          if (parsed && typeof parsed === "object") {
            setDailyNudgeNotificationIds(parsed);
            dailyNudgeIdsRef.current = parsed;
          } else {
            setDailyNudgeNotificationIds({});
            dailyNudgeIdsRef.current = {};
          }
        } catch (err) {
          console.warn("daily nudges parse", err);
          setDailyNudgeNotificationIds({});
          dailyNudgeIdsRef.current = {};
        }
      } else {
        setDailyNudgeNotificationIds({});
        dailyNudgeIdsRef.current = {};
      }
      if (smartRemindersRaw) {
        try {
          const parsed = JSON.parse(smartRemindersRaw);
          setSmartReminders((prev) =>
            normalizeSmartReminderEntries([
              ...(Array.isArray(parsed) ? parsed : []),
              ...prev,
            ])
          );
        } catch (err) {
          console.warn("smart reminders parse", err);
          setSmartReminders((prev) => normalizeSmartReminderEntries(prev));
        }
      }
      if (potentialPushProgressRaw) {
        try {
          const parsed = JSON.parse(potentialPushProgressRaw);
          setPotentialPushProgress({
            lastStep: Math.max(0, Number(parsed?.lastStep) || 0),
            lastStatus:
              parsed?.lastStatus === "ahead" || parsed?.lastStatus === "behind"
                ? parsed.lastStatus
                : null,
            baselineKey:
              typeof parsed?.baselineKey === "string" && parsed.baselineKey.trim()
                ? parsed.baselineKey
                : null,
            stepMultiplier: Math.min(
              POTENTIAL_PUSH_MAX_MULTIPLIER,
              Math.max(1, Number(parsed?.stepMultiplier) || 1)
            ),
            lastNotifiedAt:
              Number.isFinite(Number(parsed?.lastNotifiedAt)) && Number(parsed?.lastNotifiedAt) > 0
                ? Number(parsed.lastNotifiedAt)
                : 0,
          });
        } catch (err) {
          console.warn("potential push progress parse", err);
          setPotentialPushProgress({ ...DEFAULT_POTENTIAL_PUSH_STATE });
        }
      } else {
        setPotentialPushProgress({ ...DEFAULT_POTENTIAL_PUSH_STATE });
      }
      setPotentialPushHydrated(true);
      if (tamagotchiRaw) {
        try {
          const parsed = JSON.parse(tamagotchiRaw);
          const parsedHunger = Math.min(
            TAMAGOTCHI_MAX_HUNGER,
            Math.max(0, Number(parsed?.hunger) || 0)
          );
          const parsedCoins = Math.max(
            0,
            Math.floor(Number(parsed?.coins) || TAMAGOTCHI_START_STATE.coins)
          );
          const baseState = {
            ...TAMAGOTCHI_START_STATE,
            ...parsed,
            hunger: parsedHunger,
            coins: parsedCoins,
            lastDecayAt:
              typeof parsed?.lastDecayAt === "number" && Number.isFinite(parsed.lastDecayAt)
                ? parsed.lastDecayAt
                : Number(parsed?.lastDecayAt) || Date.now(),
            coinTick: Math.max(0, Number(parsed?.coinTick) || 0),
          };
          const { state: hydratedState } = computeTamagotchiDecay(baseState);
          setTamagotchiState(hydratedState);
          tamagotchiHungerPrevRef.current = hydratedState.hunger;
          tamagotchiHydratedRef.current = true;
          if (!healthRaw && resolvedHealthPoints === null) {
            resolvedHealthPoints = hydratedState.coins;
          }
        } catch (err) {
          setTamagotchiState({ ...TAMAGOTCHI_START_STATE });
          tamagotchiHungerPrevRef.current = TAMAGOTCHI_START_STATE.hunger;
          tamagotchiHydratedRef.current = true;
        }
      } else {
        tamagotchiHungerPrevRef.current = TAMAGOTCHI_START_STATE.hunger;
        tamagotchiHydratedRef.current = true;
      }
      if (tamagotchiHungerNotificationsRaw) {
        try {
          const parsedIds = JSON.parse(tamagotchiHungerNotificationsRaw);
          tamagotchiHungerNotificationIdsRef.current = Array.isArray(parsedIds) ? parsedIds : [];
        } catch (err) {
          tamagotchiHungerNotificationIdsRef.current = [];
        }
      } else {
        tamagotchiHungerNotificationIdsRef.current = [];
      }
      const todayKey = getDayKey(Date.now());
      if (tamagotchiHungerDailyCountRaw) {
        try {
          const parsed = JSON.parse(tamagotchiHungerDailyCountRaw);
          const storedDayKey = typeof parsed?.dayKey === "string" ? parsed.dayKey : "";
          const storedCount = Math.max(0, Number(parsed?.count) || 0);
          if (storedDayKey === todayKey) {
            tamagotchiHungerDailyCountRef.current = {
              dayKey: storedDayKey,
              count: Math.min(TAMAGOTCHI_HUNGER_NOTIFICATION_DAILY_LIMIT, storedCount),
            };
          } else {
            tamagotchiHungerDailyCountRef.current = { dayKey: todayKey, count: 0 };
          }
        } catch (err) {
          tamagotchiHungerDailyCountRef.current = { dayKey: todayKey, count: 0 };
        }
      } else {
        tamagotchiHungerDailyCountRef.current = { dayKey: todayKey, count: 0 };
      }
      if (tamagotchiHungerLastAtRaw) {
        const parsedLastAt = Number(tamagotchiHungerLastAtRaw) || 0;
        tamagotchiHungerLastAtRef.current = parsedLastAt > 0 ? parsedLastAt : 0;
      } else {
        tamagotchiHungerLastAtRef.current = 0;
      }
      const rawGreetingDayKey =
        typeof tamagotchiGreetingDayRaw === "string" ? tamagotchiGreetingDayRaw.trim() : "";
      if (rawGreetingDayKey && parseDayKey(rawGreetingDayKey)) {
        setTamagotchiGreetingDayKey(rawGreetingDayKey);
      } else {
        setTamagotchiGreetingDayKey(null);
      }
      setTamagotchiGreetingDayHydrated(true);
      if (dailyChallengeRaw) {
        try {
          const parsed = JSON.parse(dailyChallengeRaw);
          setDailyChallenge({
            ...createInitialDailyChallengeState(),
            ...(parsed && typeof parsed === "object" ? parsed : {}),
          });
        } catch (err) {
          console.warn("daily challenge parse", err);
          setDailyChallenge(createInitialDailyChallengeState());
        }
      } else {
        setDailyChallenge(createInitialDailyChallengeState());
      }
      setDailyChallengeHydrated(true);
      if (dailyRewardRaw || dailyRewardDayKeyRaw) {
        try {
          const parsed = dailyRewardRaw ? JSON.parse(dailyRewardRaw) : null;
          const parsedLastClaimAt = Number(parsed?.lastClaimAt) || 0;
          const parsedLastKey = typeof parsed?.lastKey === "string" ? parsed.lastKey : null;
          const fallbackDayKey =
            typeof dailyRewardDayKeyRaw === "string" && dailyRewardDayKeyRaw.trim()
              ? dailyRewardDayKeyRaw.trim()
              : null;
          setDailyRewardState({
            lastKey:
              parsedLastKey ||
              (parsedLastClaimAt ? getDayKey(parsedLastClaimAt) : null) ||
              fallbackDayKey,
            lastAmount: Math.max(0, Number(parsed?.lastAmount) || 0),
            lastClaimAt: parsedLastClaimAt,
            streak: Math.max(0, Number(parsed?.streak) || 0),
          });
        } catch (err) {
          console.warn("daily reward parse", err);
          const fallbackDayKey =
            typeof dailyRewardDayKeyRaw === "string" && dailyRewardDayKeyRaw.trim()
              ? dailyRewardDayKeyRaw.trim()
              : null;
          setDailyRewardState({
            ...DEFAULT_DAILY_REWARD_STATE,
            lastKey: fallbackDayKey || null,
          });
        }
      } else {
        setDailyRewardState({ ...DEFAULT_DAILY_REWARD_STATE });
      }
      setDailyRewardHydrated(true);
      if (typeof dailyGoalCollectedRaw === "string" && dailyGoalCollectedRaw.trim()) {
        setDailyGoalCollectedKey(dailyGoalCollectedRaw.trim());
      } else {
        setDailyGoalCollectedKey(null);
      }
      if (themeRaw) {
        setTheme(normalizeThemeId(themeRaw));
      } else {
        setTheme(DEFAULT_THEME);
      }
      setThemeHydrated(true);
      if (proThemeAccentRaw) {
        setProThemeAccentId(normalizeProThemeAccentId(proThemeAccentRaw));
      } else {
        setProThemeAccentId(DEFAULT_PRO_THEME_ACCENT_ID);
      }
      setProThemeAccentHydrated(true);
      if (languageRaw) {
        setLanguage(normalizeLanguage(languageRaw));
      } else {
        setLanguage(DEFAULT_LANGUAGE);
      }
      setLanguageHydrated(true);
      if (soundEnabledRaw === "0") {
        setSoundEnabled(false);
      } else {
        setSoundEnabled(true);
      }
      setSoundEnabledHydrated(true);
      if (coinSliderMaxRaw) {
        const parsedSliderMax = parseFloat(coinSliderMaxRaw);
        if (Number.isFinite(parsedSliderMax) && parsedSliderMax > 0) {
          setCoinSliderMaxUSD(parsedSliderMax);
        }
      } else {
        setCoinSliderMaxUSD(DEFAULT_COIN_SLIDER_MAX_USD);
      }
      setCoinSliderHydrated(true);
      const normalizedCoinValueModal =
        coinValueModalRaw === COIN_VALUE_MODAL_STATUS.SHOWN
          ? COIN_VALUE_MODAL_STATUS.SHOWN
          : coinValueModalRaw === COIN_VALUE_MODAL_STATUS.PENDING
          ? COIN_VALUE_MODAL_STATUS.PENDING
          : "none";
      setCoinValueModalStatus(normalizedCoinValueModal);
      coinValueModalStatusRef.current = normalizedCoinValueModal;
      setCoinValueModalHydrated(true);
      setReportsBadgeVisible(reportsBadgeRaw === "1");
      setReportsBadgeHydrated(true);
      const normalizedReportsLastWeek =
        typeof reportsLastAutoWeekRaw === "string" && reportsLastAutoWeekRaw.trim()
          ? reportsLastAutoWeekRaw.trim()
          : null;
      setReportsLastAutoWeekKey(normalizedReportsLastWeek);
      setReportsLastAutoWeekHydrated(true);
      setReportsWeeklyNotificationId(
        typeof reportsWeeklyNotificationRaw === "string" && reportsWeeklyNotificationRaw.trim()
          ? reportsWeeklyNotificationRaw.trim()
          : null
      );
      setReportsWeeklyNotificationHydrated(true);
      const normalizedPremiumInstallId =
        typeof premiumInstallIdRaw === "string" && premiumInstallIdRaw.trim().length
          ? premiumInstallIdRaw.trim()
          : createMonetizationInstallId();
      setPremiumInstallId(normalizedPremiumInstallId);
      setPremiumInstallIdHydrated(true);
      setPremiumSoftPaywallShown(premiumSoftPaywallRaw === "1");
      setPremiumSoftPaywallHydrated(true);
      setPremiumHardPaywallShown(premiumHardPaywallRaw === "1");
      setPremiumHardPaywallHydrated(true);
      const parsedPremiumChallengeClaims = Math.max(0, Number(premiumChallengeClaimsRaw) || 0);
      setPremiumChallengeClaims(parsedPremiumChallengeClaims);
      setPremiumChallengeClaimsHydrated(true);
      let normalizedRatingPrompt = createInitialRatingPromptState();
      let ratingPromptNeedsRewrite = false;
      if (ratingPromptRaw) {
        try {
          const parsed = JSON.parse(ratingPromptRaw);
          const fallback = createInitialRatingPromptState();
          const parsedLastAction = typeof parsed?.lastAction === "string" ? parsed.lastAction : null;
          const normalizedCompleted = parsedLastAction
            ? parsedLastAction === "rate"
            : Boolean(parsed?.completed);
          const rawActionCountStart = parsed?.actionCountStart;
          const parsedActionCountStart =
            rawActionCountStart === null || rawActionCountStart === undefined
              ? null
              : Number(rawActionCountStart);
          const normalizedActionCountStart =
            parsedActionCountStart !== null &&
            Number.isFinite(parsedActionCountStart) &&
            parsedActionCountStart >= 0
              ? parsedActionCountStart
              : null;
          normalizedRatingPrompt = {
            firstOpenAt:
              typeof parsed?.firstOpenAt === "string" ? parsed.firstOpenAt : fallback.firstOpenAt,
            completed: normalizedCompleted,
            lastShownAt: typeof parsed?.lastShownAt === "string" ? parsed.lastShownAt : null,
            lastAction: parsedLastAction,
            respondedAt: typeof parsed?.respondedAt === "string" ? parsed.respondedAt : null,
            actionCount: Math.max(0, Number(parsed?.actionCount) || 0),
            actionCountStart: normalizedActionCountStart,
            actionPrompted: Boolean(parsed?.actionPrompted),
          };
          ratingPromptNeedsRewrite =
            normalizedRatingPrompt.firstOpenAt !== parsed?.firstOpenAt ||
            normalizedRatingPrompt.lastShownAt !== parsed?.lastShownAt ||
            normalizedRatingPrompt.lastAction !== parsed?.lastAction ||
            normalizedRatingPrompt.respondedAt !== parsed?.respondedAt ||
            normalizedRatingPrompt.completed !== Boolean(parsed?.completed) ||
            normalizedRatingPrompt.actionCount !== Math.max(0, Number(parsed?.actionCount) || 0) ||
            normalizedRatingPrompt.actionCountStart !== rawActionCountStart ||
            normalizedRatingPrompt.actionPrompted !== Boolean(parsed?.actionPrompted);
        } catch (error) {
          console.warn("rating prompt hydrate", error);
          normalizedRatingPrompt = createInitialRatingPromptState();
          ratingPromptNeedsRewrite = true;
        }
      } else {
        ratingPromptNeedsRewrite = true;
      }
      setRatingPromptState(normalizedRatingPrompt);
      if (ratingPromptNeedsRewrite) {
        AsyncStorage.setItem(
          STORAGE_KEYS.RATING_PROMPT,
          JSON.stringify(normalizedRatingPrompt)
        ).catch(() => {});
      }
      setRatingPromptHydrated(true);
      if (
        fabTutorialRaw === FAB_TUTORIAL_STATUS.PENDING ||
        fabTutorialRaw === FAB_TUTORIAL_STATUS.SHOWING
      ) {
        setFabTutorialState(fabTutorialRaw);
        fabTutorialStateRef.current = fabTutorialRaw;
      } else {
        setFabTutorialState(FAB_TUTORIAL_STATUS.DONE);
        fabTutorialStateRef.current = FAB_TUTORIAL_STATUS.DONE;
      }
      setBudgetWidgetTutorialSeen(budgetWidgetTutorialRaw === "done");
      setBudgetWidgetTutorialHydrated(true);
      if (northStarMetricRaw) {
        let logged = false;
        let northStar2Logged = false;
        try {
          const parsedNorthStar = JSON.parse(northStarMetricRaw);
          logged = !!parsedNorthStar?.logged;
          northStar2Logged = !!parsedNorthStar?.northStar2Logged;
        } catch (error) {
          logged = northStarMetricRaw === "1";
        }
        setNorthStarLogged(logged);
        northStarLoggedRef.current = logged;
        setNorthStar2Logged(northStar2Logged);
        northStar2LoggedRef.current = northStar2Logged;
      } else {
        setNorthStarLogged(false);
        northStarLoggedRef.current = false;
        setNorthStar2Logged(false);
        northStar2LoggedRef.current = false;
      }
      setNorthStarHydrated(true);
      if (primaryTemptationPromptRaw === "pending") {
        setPrimaryTemptationPromptState("pending");
      } else {
        setPrimaryTemptationPromptState("done");
      }
      setPrimaryTemptationPromptHydrated(true);
      if (dailySummaryRaw) setDailySummarySeenKey(dailySummaryRaw);
      setDailySummaryHydrated(true);
      if (termsAcceptedRaw === "1") {
        setTermsAccepted(true);
      }
      if (focusTargetRaw) {
        try {
          const parsedFocus = JSON.parse(focusTargetRaw);
          if (parsedFocus && typeof parsedFocus === "object" && typeof parsedFocus.templateId === "string") {
            setFocusTemplateId(parsedFocus.templateId);
            setFocusSaveCount(Math.max(0, Number(parsedFocus.saveCount) || 0));
          } else {
            setFocusTemplateId(null);
            setFocusSaveCount(0);
          }
        } catch (error) {
          setFocusTemplateId(null);
          setFocusSaveCount(0);
        }
      } else {
        setFocusTemplateId(null);
        setFocusSaveCount(0);
      }
      setFocusStateHydrated(true);
      if (focusDigestRaw) {
        setFocusDigestSeenKey(focusDigestRaw || null);
      } else {
        setFocusDigestSeenKey(null);
      }
      setFocusDigestHydrated(true);
      if (focusDigestPendingRaw) {
        try {
          const parsedPending = JSON.parse(focusDigestPendingRaw);
          if (parsedPending && typeof parsedPending === "object" && parsedPending.payload) {
            setPendingFocusDigest(parsedPending);
          } else {
            setPendingFocusDigest(null);
          }
        } catch (error) {
          setPendingFocusDigest(null);
        }
      } else {
        setPendingFocusDigest(null);
      }
      if (tamagotchiSkinRaw && TAMAGOTCHI_SKINS[tamagotchiSkinRaw]) {
        setTamagotchiSkinId(tamagotchiSkinRaw);
      } else {
        setTamagotchiSkinId(DEFAULT_TAMAGOTCHI_SKIN);
      }
      setTamagotchiSkinHydrated(true);
      setActiveGoalId(hydratedGoalId);
      setActiveGoalHydrated(true);
      if (catalogRaw) {
        try {
          setCatalogOverrides(JSON.parse(catalogRaw));
        } catch (error) {
          console.warn("catalog overrides parse", error);
          setCatalogOverrides({});
        }
      } else {
        setCatalogOverrides({});
      }
      setCatalogHydrated(true);
      if (pricePrecisionRaw) {
        try {
          setPricePrecisionOverrides(JSON.parse(pricePrecisionRaw));
        } catch (error) {
          console.warn("price precision overrides parse", error);
          setPricePrecisionOverrides({});
        }
      } else {
        setPricePrecisionOverrides({});
      }
      setPricePrecisionOverridesHydrated(true);
      if (titleRaw) {
        try {
          setTitleOverrides(JSON.parse(titleRaw));
        } catch (error) {
          console.warn("title overrides parse", error);
          setTitleOverrides({});
        }
      } else {
        setTitleOverrides({});
      }
      setTitleOverridesHydrated(true);
      if (emojiOverridesRaw) {
        try {
          setEmojiOverrides(JSON.parse(emojiOverridesRaw));
        } catch (error) {
          console.warn("emoji overrides parse", error);
          setEmojiOverrides({});
        }
      } else {
        setEmojiOverrides({});
      }
      setEmojiOverridesHydrated(true);
      if (categoryOverridesRaw) {
        try {
          setCategoryOverrides(JSON.parse(categoryOverridesRaw));
        } catch (error) {
          console.warn("category overrides parse", error);
          setCategoryOverrides({});
        }
      } else {
        setCategoryOverrides({});
      }
      setCategoryOverridesHydrated(true);
      if (customCategoriesRaw) {
        try {
          const parsed = JSON.parse(customCategoriesRaw);
          const normalizedList = Array.isArray(parsed) ? parsed : [];
          const registered = normalizedList
            .map((entry) => registerCustomCategory(entry))
            .filter(Boolean);
          setCustomCategories(registered);
        } catch (error) {
          console.warn("custom categories parse", error);
          setCustomCategories([]);
        }
      } else {
        setCustomCategories([]);
      }
      setCustomCategoriesHydrated(true);
      if (removedCategoriesRaw) {
        try {
          const parsed = JSON.parse(removedCategoriesRaw);
          const normalized = applyRemovedCategories(parsed);
          setRemovedCategories(normalized);
        } catch (error) {
          console.warn("removed categories parse", error);
          setRemovedCategories([]);
        }
      } else {
        setRemovedCategories([]);
      }
      setRemovedCategoriesHydrated(true);
      if (savingsCategoryOverrideRaw) {
        try {
          const parsed = JSON.parse(savingsCategoryOverrideRaw);
          applySavingsCategoryOverride(parsed);
          setSavingsCategoryOverride(parsed);
        } catch (error) {
          console.warn("savings category override parse", error);
          applySavingsCategoryOverride(null);
          setSavingsCategoryOverride(null);
        }
      } else {
        applySavingsCategoryOverride(null);
        setSavingsCategoryOverride(null);
      }
      setSavingsCategoryOverrideHydrated(true);
      if (categoryDefOverridesRaw) {
        try {
          const parsed = JSON.parse(categoryDefOverridesRaw);
          const normalized = parsed && typeof parsed === "object" ? parsed : {};
          applyCategoryDefOverrides(normalized);
          setCategoryDefOverrides(normalized);
        } catch (error) {
          console.warn("category def overrides parse", error);
          setCategoryDefOverrides({});
        }
      } else {
        setCategoryDefOverrides({});
      }
      setCategoryDefOverridesHydrated(true);
      if (descriptionOverridesRaw) {
        try {
          setDescriptionOverrides(JSON.parse(descriptionOverridesRaw));
        } catch (error) {
          console.warn("description overrides parse", error);
          setDescriptionOverrides({});
        }
      } else {
        setDescriptionOverrides({});
      }
      setDescriptionOverridesHydrated(true);
      let resolvedSavedTotal = 0;
      if (savedTotalRaw) {
        resolvedSavedTotal = Number(savedTotalRaw) || 0;
        setSavedTotalUSD(resolvedSavedTotal);
      } else {
        setSavedTotalUSD(0);
      }
      setSavedTotalHydrated(true);
      let resolvedProgressSavedTotal = 0;
      if (progressSavedTotalRaw) {
        resolvedProgressSavedTotal = Number(progressSavedTotalRaw) || 0;
      } else {
        resolvedProgressSavedTotal = resolvedSavedTotal;
      }
      setProgressSavedTotalUSD(resolvedProgressSavedTotal);
      setProgressSavedTotalHydrated(true);
      const resolvedLevelProgressOffset = Math.max(0, Number(levelProgressOffsetRaw) || 0);
      setLevelProgressOffsetUSD(resolvedLevelProgressOffset);
      setLevelProgressOffsetHydrated(true);
      const parsedPeak = savedPeakRaw ? Number(savedPeakRaw) || 0 : Math.max(0, resolvedSavedTotal);
      const resolvedPeakValue = Math.max(parsedPeak, resolvedSavedTotal);
      setLifetimeSavedUSD(resolvedPeakValue);
      setLifetimeSavedHydrated(true);
      const parsedProgressPeak = progressSavedPeakRaw
        ? Number(progressSavedPeakRaw) || 0
        : Math.max(0, resolvedProgressSavedTotal);
      const resolvedProgressPeakValue = Math.max(parsedProgressPeak, resolvedProgressSavedTotal);
      setProgressLifetimeSavedUSD(resolvedProgressPeakValue);
      setProgressLifetimeSavedHydrated(true);
      const levelBaselineCurrency =
        typeof parsedProfile?.currency === "string" && parsedProfile.currency.trim()
          ? parsedProfile.currency
          : DEFAULT_PROFILE.currency;
      const resolvedLevelBaseline = getTierProgress(
        Math.max(0, resolvedProgressPeakValue - resolvedLevelProgressOffset),
        levelBaselineCurrency
      ).level;
      const storedCelebratedLevel =
        lastCelebratedLevelRaw !== null && lastCelebratedLevelRaw !== undefined
          ? Math.max(1, Number(lastCelebratedLevelRaw) || 1)
          : Math.max(1, resolvedLevelBaseline);
      const syncedCelebratedLevel =
        storedCelebratedLevel < resolvedLevelBaseline
          ? Math.max(1, resolvedLevelBaseline)
          : storedCelebratedLevel;
      if (syncedCelebratedLevel !== storedCelebratedLevel) {
        AsyncStorage.setItem(
          STORAGE_KEYS.LAST_CELEBRATED_LEVEL,
          String(syncedCelebratedLevel)
        ).catch(() => {});
      }
      setLastCelebratedLevel(syncedCelebratedLevel);
      previousPlayerLevelRef.current = syncedCelebratedLevel;
      setLastCelebratedLevelHydrated(true);
      if (declinesRaw) {
        setDeclineCount(Number(declinesRaw) || 0);
      } else {
        setDeclineCount(0);
      }
      setDeclinesHydrated(true);
      const parsedDailyChallengeCompleted = Number(dailyChallengeCompletedRaw);
      if (Number.isFinite(parsedDailyChallengeCompleted)) {
        setDailyChallengeCompletedCount(Math.max(0, parsedDailyChallengeCompleted));
      } else {
        setDailyChallengeCompletedCount(0);
      }
      setDailyChallengeCompletedHydrated(true);
      const parsedFocusVictory = Number(focusVictoryRaw);
      if (Number.isFinite(parsedFocusVictory)) {
        setFocusVictoryCount(Math.max(0, parsedFocusVictory));
      } else {
        setFocusVictoryCount(0);
      }
      setFocusVictoryHydrated(true);
      if (freeDayRaw) {
        setFreeDayStats({ ...INITIAL_FREE_DAY_STATS, ...JSON.parse(freeDayRaw) });
      }
      if (usageStreakRaw) {
        try {
          const parsedUsage = JSON.parse(usageStreakRaw);
          setUsageStreak({ ...INITIAL_USAGE_STREAK, ...parsedUsage });
        } catch (error) {
          console.warn("usage streak parse", error);
          setUsageStreak({ ...INITIAL_USAGE_STREAK });
          usageStreakBackfillRef.current = true;
        }
      } else {
        setUsageStreak({ ...INITIAL_USAGE_STREAK });
        usageStreakBackfillRef.current = true;
      }
      setUsageStreakHydrated(true);
      if (streakPledgeRaw) {
        try {
          const parsedPledge = JSON.parse(streakPledgeRaw);
          setStreakPledge(normalizeStreakPledgeState(parsedPledge));
        } catch (error) {
          console.warn("streak pledge parse", error);
          setStreakPledge({ ...INITIAL_STREAK_PLEDGE });
        }
      } else {
        setStreakPledge({ ...INITIAL_STREAK_PLEDGE });
      }
      setStreakPledgeHydrated(true);
      const deferHistoryHydration = shouldDeferLargeParse(historyRaw);
      const hydrateHistory = () => {
        try {
          if (historyRaw) {
            const parsedHistory = JSON.parse(historyRaw);
            const now = Date.now();
            const filteredHistory = (Array.isArray(parsedHistory) ? parsedHistory : [])
              .map((entry) => {
                if (!entry || typeof entry !== "object") return null;
                const timestamp = normalizeTimestampMs(entry.timestamp);
                if (!timestamp) return null;
                return timestamp === entry.timestamp ? entry : { ...entry, timestamp };
              })
              .filter((entry) => {
                if (!entry?.timestamp) return false;
                // Ignore events with broken future timestamps.
                if (entry.timestamp > now + DAY_MS) return false;
                return now - entry.timestamp <= HISTORY_RETENTION_MS;
              })
              .slice(0, MAX_HISTORY_EVENTS);
            setHistoryEvents(filteredHistory);
          } else {
            setHistoryEvents([]);
          }
        } catch (err) {
          console.warn("history parse", err);
          setHistoryEvents([]);
        } finally {
          setHistoryHydrated(true);
        }
      };
      if (deferHistoryHydration) {
        setHistoryEvents([]);
        InteractionManager.runAfterInteractions(hydrateHistory);
      } else {
        hydrateHistory();
      }
      if (refuseStatsRaw) {
        setRefuseStats(JSON.parse(refuseStatsRaw));
      } else {
        setRefuseStats({});
      }
      setRefuseStatsHydrated(true);
      if (temptationInteractionsRaw) {
        try {
          const parsedInteractions = JSON.parse(temptationInteractionsRaw);
          setTemptationInteractions((prev) =>
            mergeInteractionStatMaps(parsedInteractions || {}, prev || {})
          );
        } catch (err) {
          console.warn("temptation interactions parse", err);
        }
      }
      setTemptationInteractionsHydrated(true);
      if (rewardsCelebratedRaw) {
        try {
          const parsedCelebrated = JSON.parse(rewardsCelebratedRaw);
          setRewardCelebratedMap(parsedCelebrated && typeof parsedCelebrated === "object" ? parsedCelebrated : {});
        } catch (err) {
          console.warn("rewards celebrated parse", err);
          setRewardCelebratedMap({});
        }
      } else {
        setRewardCelebratedMap({});
      }
      setRewardCelebratedHydrated(true);
      const hasAnalyticsConsent =
        analyticsOptOutRaw === "1" ||
        analyticsOptOutRaw === "0" ||
        analyticsOptOutRaw === "true" ||
        analyticsOptOutRaw === "false";
      if (hasAnalyticsConsent) {
        setAnalyticsOptOutState(analyticsOptOutRaw === "1" || analyticsOptOutRaw === "true");
      } else {
        setAnalyticsOptOutState(null);
      }
      if (goalMapRaw) {
        try {
          setTemptationGoalMap(JSON.parse(goalMapRaw));
        } catch (err) {
          console.warn("goal map parse", err);
          setTemptationGoalMap({});
        }
      } else {
        setTemptationGoalMap({});
      }
      setTemptationGoalMapHydrated(true);
      const parsedCustomTemptationsCreated = Number(customTemptationsCreatedRaw);
      const storedCustomTemptationsCreated = Number.isFinite(parsedCustomTemptationsCreated)
        ? Math.max(0, parsedCustomTemptationsCreated)
        : null;
      if (customTemptationsRaw) {
        try {
          const parsedCustom = JSON.parse(customTemptationsRaw);
          const fallbackCurrency = parsedProfile?.currency || DEFAULT_PROFILE.currency;
          const normalizedCustom = (Array.isArray(parsedCustom) ? parsedCustom : [parsedCustom])
            .map((entry) => normalizeCustomTemptationEntry(entry, fallbackCurrency))
            .filter(Boolean);
          setQuickTemptations(normalizedCustom);
          const normalizedCount = normalizedCustom.length;
          const nextCustomCreated =
            storedCustomTemptationsCreated === null
              ? normalizedCount
              : Math.max(storedCustomTemptationsCreated, normalizedCount);
          setCustomTemptationsCreatedCount(nextCustomCreated);
        } catch (err) {
          console.warn("custom temptations parse", err);
          setCustomTemptationsCreatedCount(storedCustomTemptationsCreated ?? 0);
        }
      } else {
        setCustomTemptationsCreatedCount(storedCustomTemptationsCreated ?? 0);
      }
      setCustomTemptationsCreatedHydrated(true);
      const deferHiddenHydration = shouldDeferLargeParse(hiddenTemptationsRaw);
      const hydrateHiddenTemptations = () => {
        if (hiddenTemptationsRaw) {
          try {
            setHiddenTemptations(JSON.parse(hiddenTemptationsRaw) || []);
          } catch (err) {
            console.warn("hidden temptations parse", err);
            setHiddenTemptations([]);
          }
        } else {
          setHiddenTemptations([]);
        }
        setHiddenTemptationsHydrated(true);
      };
      if (deferHiddenHydration) {
        setHiddenTemptations([]);
        InteractionManager.runAfterInteractions(hydrateHiddenTemptations);
      } else {
        hydrateHiddenTemptations();
      }
      const deferArchivedHydration = shouldDeferLargeParse(archivedTemptationsRaw);
      const hydrateArchivedTemptations = () => {
        if (archivedTemptationsRaw) {
          try {
            const parsed = JSON.parse(archivedTemptationsRaw);
            setArchivedTemptations(Array.isArray(parsed) ? parsed : []);
          } catch (err) {
            console.warn("archived temptations parse", err);
            setArchivedTemptations([]);
          }
        } else {
          setArchivedTemptations([]);
        }
        setArchivedTemptationsHydrated(true);
      };
      if (deferArchivedHydration) {
        setArchivedTemptations([]);
        InteractionManager.runAfterInteractions(hydrateArchivedTemptations);
      } else {
        hydrateArchivedTemptations();
      }
      if (healthRaw) {
        const parsedHealth = Number(healthRaw) || 0;
        resolvedHealthPoints = Math.max(0, parsedHealth);
      } else if (resolvedHealthPoints === null) {
        resolvedHealthPoints = 0;
      }
      let initialClaimedCount = 0;
      if (claimedRewardsRaw) {
        try {
          const parsedClaimed = JSON.parse(claimedRewardsRaw);
          const normalizedClaimed = normalizeClaimedRewardsMap(parsedClaimed);
          initialClaimedCount = Object.keys(normalizedClaimed).length;
          setClaimedRewards(normalizedClaimed);
        } catch (err) {
          console.warn("claimed rewards parse", err);
          setClaimedRewards({});
        }
      } else {
        setClaimedRewards({});
      }
      setClaimedRewardsHydrated(true);
      if (rewardTotalRaw) {
        const parsedRewardTotal = Number(rewardTotalRaw);
        setRewardClaimTotal(Number.isFinite(parsedRewardTotal) ? Math.max(parsedRewardTotal, 0) : 0);
      } else {
        setRewardClaimTotal(initialClaimedCount);
      }
      setRewardTotalHydrated(true);
      if (incomeEntriesRaw) {
        try {
          const parsedIncome = JSON.parse(incomeEntriesRaw);
          setIncomeEntries(normalizeIncomeEntries(parsedIncome));
        } catch (err) {
          console.warn("income entries parse", err);
          setIncomeEntries([]);
        }
      } else {
        setIncomeEntries([]);
      }
      setIncomeEntriesHydrated(true);
      if (budgetLimitsRaw) {
        try {
          const parsedLimits = JSON.parse(budgetLimitsRaw);
          setBudgetOverrides(normalizeBudgetOverrides(parsedLimits));
        } catch (err) {
          console.warn("budget limits parse", err);
          setBudgetOverrides({});
        }
      } else {
        setBudgetOverrides({});
      }
      setBudgetOverridesHydrated(true);
      if (incomePromptRaw) {
        try {
          const parsedPrompt = JSON.parse(incomePromptRaw);
          setIncomePromptState({
            lastPromptMonthKey:
              typeof parsedPrompt?.lastPromptMonthKey === "string"
                ? parsedPrompt.lastPromptMonthKey
                : null,
            lastPromptAt: Number(parsedPrompt?.lastPromptAt) || 0,
          });
        } catch (err) {
          setIncomePromptState({
            lastPromptMonthKey: typeof incomePromptRaw === "string" ? incomePromptRaw : null,
            lastPromptAt: 0,
          });
        }
      } else {
        setIncomePromptState({ lastPromptMonthKey: null, lastPromptAt: 0 });
      }
      setIncomePromptHydrated(true);
      if (budgetOverspendRaw) {
        try {
          const parsedOverspend = JSON.parse(budgetOverspendRaw);
          setBudgetOverspendMap(parsedOverspend && typeof parsedOverspend === "object" ? parsedOverspend : {});
        } catch (err) {
          console.warn("budget overspend parse", err);
          setBudgetOverspendMap({});
        }
      } else {
        setBudgetOverspendMap({});
      }
      setBudgetOverspendHydrated(true);
      const hydrateImpulseTracker = () => {
        if (impulseTrackerRaw) {
          try {
            const parsed = JSON.parse(impulseTrackerRaw);
            const normalizedEvents = Array.isArray(parsed?.events)
              ? parsed.events.slice(0, MAX_IMPULSE_EVENTS).map((event) => {
                  if (!event) return event;
                  const normalizedCategory = normalizeImpulseCategoryId(event.category);
                  if (!normalizedCategory) return event;
                  if (event.category === normalizedCategory) return event;
                  return { ...event, category: normalizedCategory };
                })
              : [];
            setImpulseTracker({
              ...INITIAL_IMPULSE_TRACKER,
              ...parsed,
              events: normalizedEvents,
              lastAlerts: parsed?.lastAlerts || {},
            });
          } catch (err) {
            console.warn("impulse tracker parse", err);
            setImpulseTracker({ ...INITIAL_IMPULSE_TRACKER });
          }
        } else {
          setImpulseTracker({ ...INITIAL_IMPULSE_TRACKER });
        }
        setImpulseTrackerHydrated(true);
      };
      const hydrateChallenges = () => {
        if (challengesRaw) {
          try {
            const parsed = JSON.parse(challengesRaw);
            const normalized = normalizeChallengesState(parsed);
            challengesPrevRef.current = normalized;
            setChallengesState(normalized);
          } catch (err) {
            console.warn("challenges parse", err);
            const fallback = createInitialChallengesState();
            challengesPrevRef.current = fallback;
            setChallengesState(fallback);
          }
        } else {
          const fallback = createInitialChallengesState();
          challengesPrevRef.current = fallback;
          setChallengesState(fallback);
        }
        setChallengesHydrated(true);
      };
      const hydrateChallengeBadges = () => {
        if (challengeBadgesRaw) {
          try {
            const parsed = JSON.parse(challengeBadgesRaw);
            setChallengeBadgeStore(normalizeChallengeBadgeList(parsed));
          } catch (err) {
            console.warn("challenge badges parse", err);
            setChallengeBadgeStore([]);
          }
        } else {
          setChallengeBadgeStore([]);
        }
        setChallengeBadgeStoreHydrated(true);
      };
      deferNonFeedHydration(hydrateImpulseTracker);
      deferNonFeedHydration(hydrateChallenges);
      deferNonFeedHydration(hydrateChallengeBadges);
      if (moodRaw) {
        try {
          const parsed = JSON.parse(moodRaw);
          lastVisitAtSnapshotRef.current = parsed?.lastVisitAt || null;
          const normalizedEvents = Array.isArray(parsed?.events)
            ? parsed.events.slice(0, MOOD_MAX_EVENTS)
            : [];
          const todayKey = getDayKey(Date.now());
          if (parsed?.dayKey === todayKey) {
            setMoodState({
              ...parsed,
              dayKey: todayKey,
              events: normalizedEvents,
              current: parsed.current || MOOD_IDS.NEUTRAL,
              pendingSnapshot:
                typeof parsed.pendingSnapshot === "number" ? parsed.pendingSnapshot : pendingList.length,
            });
          } else {
            setMoodState(createMoodStateForToday());
          }
        } catch (err) {
          console.warn("mood state parse", err);
          lastVisitAtSnapshotRef.current = null;
        }
      } else {
        lastVisitAtSnapshotRef.current = null;
      }
      if (onboardingRaw === "done") {
        if (hasAnalyticsConsent) {
          goToOnboardingStep("done", { recordHistory: false, resetHistory: true });
        } else {
          analyticsConsentGateRef.current = true;
          goToOnboardingStep("analytics_consent", { recordHistory: false, resetHistory: true });
        }
      } else {
        const placeholderProfile = { ...DEFAULT_PROFILE_PLACEHOLDER, joinedAt: new Date().toISOString() };
        setProfile(placeholderProfile);
        setProfileDraft(placeholderProfile);
        setActiveGoalId(null);
        setRegistrationData((prev) => ({
          ...prev,
          firstName: "",
          lastName: "",
          motto: "",
          avatar: "",
          currency: placeholderProfile.currency,
          gender: placeholderProfile.gender,
        }));
        setActiveCurrency(DEFAULT_PROFILE.currency);
        goToOnboardingStep("logo", { recordHistory: false, resetHistory: true });
        setOnboardingStep("logo");
        setActiveGoalHydrated(true);
      }
      setProfileHydrated(true);
    } catch (error) {
      console.warn("load error", error);
      setAnalyticsOptOutState((prev) => (prev === null ? null : prev));
      setRatingPromptState(createInitialRatingPromptState());
      setTamagotchiGreetingDayKey(null);
      setTutorialHydrated(true);
      setClaimedRewardsHydrated(true);
      setChallengesHydrated(true);
      setChallengeBadgeStore([]);
      setChallengeBadgeStoreHydrated(true);
      setDailyChallengeCompletedCount(0);
      setDailyChallengeCompletedHydrated(true);
      setFocusVictoryCount(0);
      setFocusVictoryHydrated(true);
      setCustomTemptationsCreatedCount(0);
      setCustomTemptationsCreatedHydrated(true);
      setPendingList([]);
      setPendingHydrated(true);
      setDecisionStats({ ...INITIAL_DECISION_STATS });
      setDecisionStatsHydrated(true);
      setPurchases([]);
      setPurchasesHydrated(true);
      setTemptationGoalMap({});
      setTemptationGoalMapHydrated(true);
      deferredHydrationPayloadRef.current = null;
      deferredHydrationReadyRef.current = true;
      setDeferredHydrationReady(true);
    } finally {
      setHistoryHydrated(true);
      const safeHealthPoints =
        typeof resolvedHealthPoints === "number" && !Number.isNaN(resolvedHealthPoints)
          ? resolvedHealthPoints
          : 0;
      if (resetCounterRef.current === resetCounterAtStart) {
        setHealthPoints((prev) => (prev === safeHealthPoints ? prev : safeHealthPoints));
      }
      setHealthHydrated(true);
      setNorthStarHydrated(true);
      setWishesHydrated(true);
      setSavedTotalHydrated(true);
      setLevelProgressOffsetHydrated(true);
      setRewardsReady(true);
      setMoodHydrated(true);
      setFreeDayHydrated(true);
      setCustomReminderHydrated(true);
      setPotentialPushHydrated(true);
      setSmartRemindersHydrated(true);
      setDailyNudgesHydrated(true);
      setIncomeEntriesHydrated(true);
      setBudgetOverridesHydrated(true);
      setIncomePromptHydrated(true);
      setBudgetOverspendHydrated(true);
      setCatalogHydrated(true);
      setTitleOverridesHydrated(true);
      setEmojiOverridesHydrated(true);
      setCategoryOverridesHydrated(true);
      setDescriptionOverridesHydrated(true);
      setTamagotchiGreetingDayHydrated(true);
      setTamagotchiSkinHydrated(true);
      setLifetimeSavedHydrated(true);
      setTemptationTutorialHydrated(true);
      setProfileHydrated(true);
      setPrimaryTemptationPromptHydrated(true);
      setRatingPromptHydrated(true);
      setClaimedRewardsHydrated(true);
      setChallengesHydrated(true);
      setRefuseStatsHydrated(true);
      setQuickTemptationsHydrated(true);
      setStartupHydrated(true);
    }
  };

  useEffect(() => {
    let cancelled = false;
    const task = InteractionManager.runAfterInteractions(() => {
      if (!cancelled) {
        loadStoredData();
      }
    });
    return () => {
      cancelled = true;
      task?.cancel?.();
    };
  }, []);
  useEffect(() => {
    if (!startupHydrated) return;
    let cancelled = false;
    const task = InteractionManager.runAfterInteractions(() => {
      if (!cancelled) {
        runDeferredHydration();
      }
    });
    return () => {
      cancelled = true;
      task?.cancel?.();
    };
  }, [runDeferredHydration, startupHydrated]);
  useEffect(() => {
    if (activeTab === "feed") return;
    runDeferredHydration();
  }, [activeTab, runDeferredHydration]);
  useEffect(() => {
    northStarLoggedRef.current = northStarLogged;
  }, [northStarLogged]);
  useEffect(() => {
    northStar2LoggedRef.current = northStar2Logged;
  }, [northStar2Logged]);
  useEffect(() => {
    if (onboardingStep !== "done") {
      setHomeLayoutReady(false);
      setTutorialVisible(false);
    }
  }, [onboardingStep]);

  useEffect(() => {
    if (
      onboardingStep === "done" &&
      startupLogoReady &&
      !startupLogoDismissedRef.current &&
      !onboardingSkippedRef.current
    ) {
      setStartupLogoVisible(true);
    }
  }, [onboardingStep, startupLogoReady]);

  const handleStartupLogoComplete = useCallback(() => {
    markStartupLogoDismissed();
  }, [markStartupLogoDismissed]);

  const handleOnboardingLogoComplete = useCallback(() => {
    markStartupLogoDismissed();
    goToOnboardingStep("language", { recordHistory: false });
  }, [goToOnboardingStep, markStartupLogoDismissed]);

  const persistTamagotchiHungerNotificationIds = useCallback((ids = []) => {
    tamagotchiHungerNotificationIdsRef.current = ids;
    AsyncStorage.setItem(
      STORAGE_KEYS.TAMAGOTCHI_HUNGER_NOTIFICATIONS,
      JSON.stringify(ids)
    ).catch(() => {});
  }, []);

  const persistTamagotchiHungerDailyCount = useCallback((dayKey, count) => {
    tamagotchiHungerDailyCountRef.current = { dayKey, count };
    AsyncStorage.setItem(
      STORAGE_KEYS.TAMAGOTCHI_HUNGER_DAILY_COUNT,
      JSON.stringify({ dayKey, count })
    ).catch(() => {});
  }, []);

  const persistTamagotchiHungerLastAt = useCallback((timestamp) => {
    const normalized = Number(timestamp) || 0;
    tamagotchiHungerLastAtRef.current = normalized > 0 ? normalized : 0;
    AsyncStorage.setItem(
      STORAGE_KEYS.TAMAGOTCHI_HUNGER_LAST_AT,
      String(tamagotchiHungerLastAtRef.current)
    ).catch(() => {});
  }, []);

  const getTamagotchiHungerLastAt = useCallback(() => {
    return Number(tamagotchiHungerLastAtRef.current) || 0;
  }, []);

  const getTamagotchiHungerDailyCount = useCallback((timestamp = Date.now()) => {
    const dayKey = getDayKey(timestamp);
    const stored = tamagotchiHungerDailyCountRef.current || {};
    const count =
      stored.dayKey === dayKey ? Math.max(0, Number(stored.count) || 0) : 0;
    return { dayKey, count };
  }, []);

  const bumpTamagotchiHungerDailyCount = useCallback(
    (timestamp = Date.now()) => {
      const { dayKey, count } = getTamagotchiHungerDailyCount(timestamp);
      const nextCount = Math.min(TAMAGOTCHI_HUNGER_NOTIFICATION_DAILY_LIMIT, count + 1);
      persistTamagotchiHungerDailyCount(dayKey, nextCount);
      return nextCount;
    },
    [getTamagotchiHungerDailyCount, persistTamagotchiHungerDailyCount]
  );

  const cancelTamagotchiHungerNotifications = useCallback(async () => {
    const ids = Array.isArray(tamagotchiHungerNotificationIdsRef.current)
      ? tamagotchiHungerNotificationIdsRef.current
      : [];
    if (!ids.length) return;
    await Promise.all(
      ids.map((notificationId) =>
        safeNotifications.cancelScheduledNotificationAsync(notificationId)
      )
    );
    persistTamagotchiHungerNotificationIds([]);
  }, [persistTamagotchiHungerNotificationIds]);

  const scheduleTamagotchiHungerNotifications = useCallback(async () => {
    if (notificationPermissionGranted !== true) {
      await cancelTamagotchiHungerNotifications();
      return;
    }
    const immunityUntil = Math.max(0, Number(tamagotchiState.hungerImmunityUntil) || 0);
    if (immunityUntil > Date.now()) {
      await cancelTamagotchiHungerNotifications();
      return;
    }
    const currentHunger = Math.min(
      TAMAGOTCHI_MAX_HUNGER,
      Math.max(0, Number(tamagotchiState.hunger) || 0)
    );
    if (currentHunger <= 0) {
      await cancelTamagotchiHungerNotifications();
      return;
    }
    const nowTs = Date.now();
    const lastSentAt = getTamagotchiHungerLastAt();
    const nextAllowedAt =
      lastSentAt > 0 ? lastSentAt + TAMAGOTCHI_HUNGER_NOTIFICATION_WINDOW_MS : nowTs;
    await cancelTamagotchiHungerNotifications();
    const copy = TAMAGOTCHI_NOTIFICATION_COPY[language] || TAMAGOTCHI_NOTIFICATION_COPY.ru;
    const candidates = [];
    if (currentHunger > TAMAGOTCHI_HUNGER_LOW_THRESHOLD) {
      const stepsToLow = Math.ceil(
        (currentHunger - TAMAGOTCHI_HUNGER_LOW_THRESHOLD) / TAMAGOTCHI_DECAY_STEP
      );
      const lowAt = nowTs + stepsToLow * TAMAGOTCHI_DECAY_INTERVAL_MS;
      candidates.push({ at: lowAt, body: copy.low });
    }
    const stepsToStarving = Math.ceil(currentHunger / TAMAGOTCHI_DECAY_STEP);
    const starvingAt = nowTs + stepsToStarving * TAMAGOTCHI_DECAY_INTERVAL_MS;
    candidates.push({ at: starvingAt, body: copy.starving });
    const nextCandidate = candidates
      .filter((entry) => Number.isFinite(entry.at) && entry.at >= nextAllowedAt && entry.body)
      .sort((a, b) => a.at - b.at)[0];
    if (!nextCandidate) {
      persistTamagotchiHungerNotificationIds([]);
      return;
    }
    const safeTimestamp = Math.max(nowTs, nextCandidate.at);
    const scheduledEntry = await scheduleNotificationWithCooldown({
      content: {
        title: t("tamagotchiName"),
        body: nextCandidate.body,
        data: { kind: "tamagotchi_hunger" },
        ...(Platform.OS === "android" ? { channelId: ANDROID_TAMAGOTCHI_CHANNEL_ID } : null),
      },
      trigger: new Date(safeTimestamp),
    });
    const ids = scheduledEntry?.id ? [scheduledEntry.id] : [];
    persistTamagotchiHungerNotificationIds(ids);
  }, [
    cancelTamagotchiHungerNotifications,
    getTamagotchiHungerLastAt,
    language,
    notificationPermissionGranted,
    persistTamagotchiHungerNotificationIds,
    scheduleNotificationWithCooldown,
    t,
    tamagotchiState.hunger,
    tamagotchiState.hungerImmunityUntil,
  ]);

  const sendTamagotchiHungerNotification = useCallback(
    async (kind) => {
      const copy = TAMAGOTCHI_NOTIFICATION_COPY[language] || TAMAGOTCHI_NOTIFICATION_COPY.ru;
      const body = copy[kind];
      if (!body) return;
      const immunityUntil = Math.max(0, Number(tamagotchiState.hungerImmunityUntil) || 0);
      if (immunityUntil > Date.now()) return;
      const nowTs = Date.now();
      const lastSentAt = getTamagotchiHungerLastAt();
      const nextAllowedAt =
        lastSentAt > 0 ? lastSentAt + TAMAGOTCHI_HUNGER_NOTIFICATION_WINDOW_MS : 0;
      if (nextAllowedAt && nowTs < nextAllowedAt) return;
      const sent = await sendImmediateNotification({
        title: t("tamagotchiName"),
        body,
        data: { kind: "tamagotchi_hunger" },
        ...(Platform.OS === "android" ? { channelId: ANDROID_TAMAGOTCHI_CHANNEL_ID } : null),
      });
      if (sent) {
        persistTamagotchiHungerLastAt(nowTs);
        cancelTamagotchiHungerNotifications();
      }
    },
    [
      cancelTamagotchiHungerNotifications,
      getTamagotchiHungerLastAt,
      language,
      persistTamagotchiHungerLastAt,
      sendImmediateNotification,
      t,
      tamagotchiState.hungerImmunityUntil,
    ]
  );
  const notifyDailySummaryReady = useCallback(
    async (summary) => {
      if (!summary) return;
      const todayKey =
        typeof summary.todayKey === "string" && summary.todayKey.trim()
          ? summary.todayKey.trim()
          : getDayKey(Date.now());
      if (!todayKey) return;
      const savedUSD = Math.max(0, Number(summary.savedUSD) || 0);
      const declines = Math.max(0, Number(summary.declines) || 0);
      if (declines < 3) return;
      const spends = Math.max(0, Number(summary.spends) || 0);
      const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
      const savedLabel = formatCurrency(
        convertToCurrency(savedUSD, currencyCode),
        currencyCode
      );
      const permitted = await ensureNotificationPermission({ request: false });
      if (!permitted) return;
      const baseDate = parseDayKey(todayKey) || new Date();
      const triggerAt = new Date(baseDate);
      triggerAt.setHours(20, 0, 0, 0);
      try {
        await scheduleNotificationWithCooldown({
          content: {
            title: t("dailySummaryNotificationTitle"),
            body: t("dailySummaryNotificationBody", {
              saved: savedLabel,
              declines,
            }),
            data: {
              kind: "daily_summary",
              targetScreen: "daily_summary",
              dedupeKey: `daily_summary_${todayKey}`,
              todayKey,
              savedUSD,
              declines,
              spends,
            },
          },
          trigger: triggerAt,
        });
      } catch (error) {
        console.warn("daily summary schedule", error);
      }
    },
    [ensureNotificationPermission, getDayKey, profile.currency, scheduleNotificationWithCooldown, t]
  );

  useEffect(() => {
    const currentHunger = Math.min(
      TAMAGOTCHI_MAX_HUNGER,
      Math.max(0, Number(tamagotchiState.hunger) || 0)
    );
    const immunityUntil = Math.max(0, Number(tamagotchiState.hungerImmunityUntil) || 0);
    if (immunityUntil > Date.now()) {
      tamagotchiHungerPrevRef.current = currentHunger;
      return;
    }
    if (!tamagotchiHydratedRef.current) {
      tamagotchiHungerPrevRef.current = currentHunger;
      return;
    }
    const previousHunger = Math.min(
      TAMAGOTCHI_MAX_HUNGER,
      Math.max(0, Number(tamagotchiHungerPrevRef.current) || 0)
    );
    if (currentHunger <= 0 && previousHunger > 0) {
      sendTamagotchiHungerNotification("starving");
    } else if (
      currentHunger <= TAMAGOTCHI_HUNGER_LOW_THRESHOLD &&
      previousHunger > TAMAGOTCHI_HUNGER_LOW_THRESHOLD
    ) {
      sendTamagotchiHungerNotification("low");
    }
    tamagotchiHungerPrevRef.current = currentHunger;
  }, [sendTamagotchiHungerNotification, tamagotchiState.hunger, tamagotchiState.hungerImmunityUntil]);

  useEffect(() => {
    if (!tamagotchiHydratedRef.current) return;
    scheduleTamagotchiHungerNotifications();
  }, [scheduleTamagotchiHungerNotifications, tamagotchiState.hunger]);

  const tutorialOverlayVisible = tutorialVisible || temptationTutorialVisible;
  const canShowTutorialNow = useCallback(() => {
    if (overlay || overlayActiveRef.current) return false;
    if (overlayQueueRef.current.length) return false;
    if (celebrationQueueRef.current.length) return false;
    if (celebrationGapTimerRef.current) return false;
    if (blockingModalVisible) return false;
    const lastDismissedAt = lastOverlayDismissedAtRef.current || 0;
    if (Date.now() - lastDismissedAt < 600) return false;
    return true;
  }, [blockingModalVisible, overlay]);
  const shouldShowTutorial =
    onboardingStep === "done" &&
    tutorialHydrated &&
    !tutorialSeen &&
    !tutorialVisible &&
    canShowTutorialNow();
  const shouldShowTemptationTutorial =
    onboardingStep === "done" &&
    tutorialSeen &&
    temptationTutorialStatus === "pending" &&
    temptationTutorialQueued &&
    !tutorialOverlayVisible &&
    homeLayoutReady &&
    !startupLogoVisible &&
    !dailySummaryVisible &&
    canShowTutorialNow();
  const budgetWidgetTutorialEligible =
    interfaceReady &&
    activeTab === "cart" &&
    budgetWidgetTutorialHydrated &&
    !budgetWidgetTutorialSeen &&
    !budgetWidgetTutorialVisible &&
    !tutorialOverlayVisible &&
    !tutorialBlockingVisible;

  useEffect(() => {
    if (!shouldShowTutorial) return;
    if (!appTutorialSteps.length) return;
    if (!homeLayoutReady) return;
    if (startupLogoVisible) return;
    if (!canShowTutorialNow()) return;
    setTutorialStepIndex(0);
    setTutorialVisible(true);
  }, [appTutorialSteps.length, canShowTutorialNow, homeLayoutReady, shouldShowTutorial, startupLogoVisible]);

  useEffect(() => {
    if (!shouldShowTutorial) return;
    if (!appTutorialSteps.length) return;
    const fallbackTimer = setTimeout(() => {
      if (!canShowTutorialNow()) return;
      setTutorialStepIndex(0);
      setTutorialVisible(true);
    }, 1600);
    return () => clearTimeout(fallbackTimer);
  }, [appTutorialSteps.length, canShowTutorialNow, shouldShowTutorial]);
  useEffect(() => {
    if (!budgetWidgetTutorialEligible) return;
    if (budgetWidgetTutorialTimerRef.current) return;
    budgetWidgetTutorialTimerRef.current = setTimeout(() => {
      budgetWidgetTutorialTimerRef.current = null;
      setBudgetWidgetTutorialVisible(true);
    }, 360);
    return () => {
      if (budgetWidgetTutorialTimerRef.current) {
        clearTimeout(budgetWidgetTutorialTimerRef.current);
        budgetWidgetTutorialTimerRef.current = null;
      }
    };
  }, [budgetWidgetTutorialEligible]);
  useEffect(() => {
    if (!budgetWidgetTutorialVisible) return;
    logEvent("budget_widget_tutorial_shown", { source: "progress" });
  }, [budgetWidgetTutorialVisible, logEvent]);
  useEffect(() => {
    dailyChallengePendingRef.current = isDailyChallengePromptPending;
    const wasPending = dailyChallengePendingPrevRef.current;
    dailyChallengePendingPrevRef.current = isDailyChallengePromptPending;
    if (!isDailyChallengePromptPending) {
      dailyChallengePromptQueuedRef.current = false;
      dailyChallengeOfferDeferredRef.current = false;
      setDailyChallengePromptGate(false);
      return;
    }
    if (!dailyChallengePromptQueuedRef.current) {
      dailyChallengePromptQueuedRef.current = true;
      setDailyChallengePromptGate(false);
    }
    if (!wasPending) {
      const sessionCount = homeSessionRef.current?.sessionCount || 0;
      dailyChallengeOfferDeferredRef.current = sessionCount > 1;
      setDailyChallengePromptGate(false);
    }
  }, [isDailyChallengePromptPending]);
  useEffect(() => {
    if (!dailyChallengePromptAllowed) return;
    if (!isDailyChallengePromptPending) return;
    if (dailyChallengePromptGate) return;
    if (dailyChallengeOfferDeferredRef.current) return;
    setDailyChallengePromptGate(true);
  }, [
    dailyChallengePromptAllowed,
    dailyChallengePromptGate,
    isDailyChallengePromptPending,
  ]);
  useEffect(() => {
    if (!dailyChallengePromptGate) return;
    if (!isDailyChallengePromptPending) return;
    enqueueQueuedModal(QUEUED_MODAL_TYPES.DAILY_CHALLENGE);
  }, [dailyChallengePromptGate, enqueueQueuedModal, isDailyChallengePromptPending]);
  useEffect(() => {
    if (queuedModalType !== QUEUED_MODAL_TYPES.DAILY_CHALLENGE) return;
    if (isDailyChallengePromptPending) return;
    clearQueuedModal(QUEUED_MODAL_TYPES.DAILY_CHALLENGE);
  }, [clearQueuedModal, isDailyChallengePromptPending, queuedModalType]);
  useEffect(() => {
    if (!shouldShowTemptationTutorial) return;
    if (activeTab !== "feed") {
      goToTab("feed", { recordHistory: false });
    }
    const timer = setTimeout(() => {
      if (!canShowTutorialNow()) return;
      setTemptationTutorialStepIndex(0);
      setTemptationTutorialCompleted(false);
      setTemptationTutorialVisible(true);
      setTemptationTutorialSeen(true);
      setTemptationTutorialQueued(false);
    }, 260);
    return () => clearTimeout(timer);
  }, [activeTab, canShowTutorialNow, goToTab, shouldShowTemptationTutorial]);
  useEffect(() => {
    if (!tutorialOverlayVisible) {
      setTutorialHighlightRect(null);
    }
  }, [tutorialOverlayVisible]);
  useEffect(() => {
    if (!temptationTutorialVisible) return;
    tutorialHighlightAdjustCountRef.current = 0;
    tutorialHighlightAlignAttemptsRef.current = 0;
    tutorialScrollExtraRef.current = IS_SHORT_DEVICE ? -24 : -12;
    const attemptScroll = () => {
      const scroller = feedScreenRef.current;
      if (scroller && typeof scroller.scrollToTemptations === "function") {
        const didScroll = scroller.scrollToTemptations({
          animated: true,
          extraOffset: tutorialScrollExtraRef.current,
        });
        if (didScroll) {
          scheduleTutorialHighlightMeasure(360);
        }
        return didScroll;
      }
      return false;
    };
    if (attemptScroll()) return;
    const timer = setTimeout(attemptScroll, 350);
    return () => clearTimeout(timer);
  }, [scheduleTutorialHighlightMeasure, temptationTutorialVisible]);
  // Align tutorial highlight without Android-specific adjustments: mirror iOS behavior.
  useEffect(() => {
    if (Platform.OS !== "android") return;
    if (!temptationTutorialVisible) {
      tutorialHighlightAlignAttemptsRef.current = 0;
    }
  }, [temptationTutorialVisible]);

  useEffect(() => {
    if (dailySummaryOpenToken === dailySummaryOpenProcessedRef.current) return;
    if (!historyHydrated) return;
    dailySummaryOpenProcessedRef.current = dailySummaryOpenToken;
    if (onboardingStep !== "done") return;
    if (!dailySummaryUnlocked) return;
    const hour = new Date().getHours();
    const todayKey = getDayKey(Date.now());
    if (dailySummarySeenKey === todayKey) return;
    if (pendingDailySummaryData?.todayKey === todayKey) return;
    const todayEvents = resolvedHistoryEvents.filter((e) => getDayKey(e.timestamp) === todayKey);
    if (!todayEvents.length) return;
    const saves = todayEvents.filter((e) => e.kind === "refuse_spend");
    const spends = todayEvents.filter((e) => e.kind === "spend");
    const savedUSD = saves.reduce((sum, e) => sum + (Number(e.meta?.amountUSD) || 0), 0);
    const declines = saves.length;
    if (declines < 3) return;
    const spendCount = spends.length;
    const summaryPayload = { savedUSD, declines, spends: spendCount, todayKey };
    notifyDailySummaryReady(summaryPayload);
    if (hour < 20) return;
    setPendingDailySummaryData(summaryPayload);
  }, [
    dailySummaryOpenToken,
    dailySummarySeenKey,
    dailySummaryUnlocked,
    historyHydrated,
    notifyDailySummaryReady,
    onboardingStep,
    pendingDailySummaryData?.todayKey,
    resolvedHistoryEvents,
  ]);

  useEffect(() => {
    if (!dailySummaryUnlocked) return;
    if (!pendingDailySummaryData) return;
    if (!interfaceReady) return;
    enqueueQueuedModal(QUEUED_MODAL_TYPES.DAILY_SUMMARY);
  }, [dailySummaryUnlocked, enqueueQueuedModal, interfaceReady, pendingDailySummaryData]);
  useEffect(() => {
    if (queuedModalType !== QUEUED_MODAL_TYPES.DAILY_SUMMARY) return;
    if (!pendingDailySummaryData) {
      clearQueuedModal(QUEUED_MODAL_TYPES.DAILY_SUMMARY);
      return;
    }
    setDailySummaryData(pendingDailySummaryData);
    setDailySummaryVisible(true);
    const todayKey = pendingDailySummaryData.todayKey || getDayKey(Date.now());
    setDailySummarySeenKey(todayKey);
    AsyncStorage.setItem(STORAGE_KEYS.DAILY_SUMMARY, todayKey).catch(() => {});
    setPendingDailySummaryData(null);
  }, [clearQueuedModal, pendingDailySummaryData, queuedModalType]);
  useEffect(() => {
    if (!spendLoggingReminderHydrated) return;
    if (onboardingStep !== "done") return;
    const now = Date.now();
    const todayKey = getDayKey(now);
    const hasActionToday = resolvedHistoryEvents.some((entry) => {
      if (!entry?.timestamp) return false;
      if (getDayKey(entry.timestamp) !== todayKey) return false;
      return [
        "refuse_spend",
        "spend",
        "pending_added",
        "pending_to_wish",
        "pending_to_decline",
      ].includes(entry.kind);
    });
    if (hasActionToday) return;
    const lastSpendTimestamp = resolvedHistoryEvents.reduce((max, entry) => {
      if (entry?.kind !== "spend") return max;
      const ts = Number(entry.timestamp) || 0;
      return ts > max ? ts : max;
    }, 0);
    const joinedAtTimestamp = profileJoinedAt ? new Date(profileJoinedAt).getTime() : 0;
    const lastTrackedSpendAt = lastSpendTimestamp || joinedAtTimestamp;
    if (!lastTrackedSpendAt) return;
    if (now - lastTrackedSpendAt < SPEND_LOGGING_REMINDER_DELAY_MS) return;
    const lastReminderAt = Number(lastSpendLoggingReminderRef.current) || 0;
    if (lastReminderAt && now - lastReminderAt < SPEND_LOGGING_REMINDER_COOLDOWN_MS) return;
    lastSpendLoggingReminderRef.current = now;
    AsyncStorage.setItem(STORAGE_KEYS.SPEND_LOGGING_REMINDER, String(now)).catch(() => {});
    const dedupeKey = `spend_logging:${todayKey}`;
    sendImmediateNotification(
      {
        title: t("spendLoggingReminderTitle"),
        body: t("spendLoggingReminderBody"),
        data: { kind: "spend_logging", dedupeKey },
      },
      { dedupeKey }
    );
  }, [
    onboardingStep,
    profileJoinedAt,
    resolvedHistoryEvents,
    sendImmediateNotification,
    spendLoggingReminderHydrated,
    t,
  ]);

  useEffect(() => {
    processTamagotchiDecay();
    const interval = setInterval(() => {
      processTamagotchiDecay();
    }, 60 * 1000);
    return () => clearInterval(interval);
  }, [processTamagotchiDecay]);

  useEffect(() => {
    setTamagotchiState((prev) =>
      prev.coins === healthPoints ? prev : { ...prev, coins: healthPoints }
    );
  }, [healthPoints]);

  useEffect(() => {
    if (tamagotchiVisible) {
      Animated.timing(tamagotchiModalAnim, {
        toValue: 1,
        duration: 220,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }).start();
    } else {
      Animated.timing(tamagotchiModalAnim, {
        toValue: 0,
        duration: 160,
        easing: Easing.in(Easing.quad),
        useNativeDriver: true,
      }).start();
    }
  }, [tamagotchiVisible, tamagotchiModalAnim]);
  useEffect(() => {
    if (!tamagotchiVisible || !dailyRewardReady) {
      tamagotchiRewardPulseAnim.setValue(1);
      return;
    }
    const pulse = Animated.loop(
      Animated.sequence([
        Animated.timing(tamagotchiRewardPulseAnim, {
          toValue: 1.06,
          duration: 420,
          easing: Easing.out(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(tamagotchiRewardPulseAnim, {
          toValue: 1,
          duration: 520,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    pulse.start();
    return () => pulse.stop();
  }, [dailyRewardReady, tamagotchiRewardPulseAnim, tamagotchiVisible]);

  useEffect(() => {
    if (onboardingStep === "done" && (profile.primaryGoals || []).length) {
      ensurePrimaryGoalWish(profile.primaryGoals, language, activeGoalId || profile.goal);
    }
  }, [ensurePrimaryGoalWish, onboardingStep, profile.primaryGoals, activeGoalId, profile.goal, language]);

  useEffect(() => {
    const targetUSD = heroGoalTargetUSD > 0 ? heroGoalTargetUSD : 0;
    const hasMetGoal = targetUSD > 0 && heroGoalSavedUSD >= targetUSD;
    if (hasMetGoal && !profile.goalCelebrated) {
      const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
      const targetLabel = formatCurrency(convertToCurrency(targetUSD, currencyCode), currencyCode);
      const rewardCoins = GOAL_COMPLETION_REWARD_COINS;
      const rewardAmount = GOAL_COMPLETION_REWARD_VALUE;
      setProfile((prev) => ({
        ...prev,
        goalCelebrated: true,
        goalRenewalPending: true,
      }));
      setProfileDraft((prev) => ({
        ...prev,
        goalCelebrated: true,
        goalRenewalPending: true,
      }));
      setHealthPoints((prev) => prev + rewardAmount);
      setPendingGoalCelebration({
        payload: {
          title: t("goalCelebrationTitle"),
          subtitle: t("goalCelebrationSubtitle"),
          targetLabel: t("goalCelebrationTarget", { amount: targetLabel }),
          summary: goalCelebrationSummary,
          fallbackTotalUSD: heroGoalSavedUSD,
          currency: profile.currency || DEFAULT_PROFILE.currency,
          language,
          rewardCoins,
          rewardAmount,
          rewardAsset: GOAL_COMPLETION_REWARD_TIER?.asset || null,
        },
        config: { duration: 0 },
      });
      if (!hasPendingGoals) {
        goalRenewalPromptPendingRef.current = true;
        goalRenewalPromptAfterGoalRef.current = true;
      }
    }
  }, [
    heroGoalTargetUSD,
    profile.goalCelebrated,
    profile.currency,
    heroGoalSavedUSD,
    hasPendingGoals,
    goalCelebrationSummary,
    language,
    setHealthPoints,
    t,
  ]);

  useEffect(() => {
    const targetUSD = heroGoalTargetUSD > 0 ? heroGoalTargetUSD : 0;
    const hasMetGoal = targetUSD > 0 && heroGoalSavedUSD >= targetUSD;
    if (profile.goalCelebrated && !hasMetGoal) {
      setProfile((prev) => ({ ...prev, goalCelebrated: false, goalRenewalPending: false }));
      setProfileDraft((prev) => ({ ...prev, goalCelebrated: false, goalRenewalPending: false }));
      goalRenewalPromptPendingRef.current = false;
    }
  }, [heroGoalTargetUSD, profile.goalCelebrated, heroGoalSavedUSD, setProfile]);

  useEffect(() => {
    if (!wishesHydrated) return;
    queuePersist(STORAGE_KEYS.WISHES, JSON.stringify(wishes));
  }, [queuePersist, wishes, wishesHydrated]);

  useEffect(() => {
    if (!temptationGoalMapHydrated) return;
    queuePersist(STORAGE_KEYS.TEMPTATION_GOALS, JSON.stringify(temptationGoalMap));
  }, [queuePersist, temptationGoalMap, temptationGoalMapHydrated]);

  useEffect(() => {
    if (!purchasesHydrated) return;
    queuePersist(STORAGE_KEYS.PURCHASES, JSON.stringify(purchases));
  }, [queuePersist, purchases, purchasesHydrated]);

  useEffect(() => {
    if (!profileHydrated) return;
    queuePersist(STORAGE_KEYS.PROFILE, JSON.stringify(profile));
  }, [queuePersist, profile, profileHydrated]);

  useEffect(() => {
    if (!activeGoalHydrated) return;
    const value = activeGoalId || "";
    queuePersist(STORAGE_KEYS.ACTIVE_GOAL, value);
  }, [queuePersist, activeGoalHydrated, activeGoalId]);

  // Ensure we always have an active goal selected once profile is loaded.
  useEffect(() => {
    if (!activeGoalHydrated) return;
    if (activeGoalId) return;
    if (profile.goal) {
      setActiveGoalId(profile.goal);
    } else if (Array.isArray(profile.primaryGoals) && profile.primaryGoals[0]?.id) {
      setActiveGoalId(profile.primaryGoals[0].id);
    }
  }, [activeGoalHydrated, activeGoalId, profile.goal, profile.primaryGoals]);

  useEffect(() => {
    if (!profile.goalRenewalPending) {
      goalRenewalPromptPendingRef.current = false;
      goalRenewalPromptAfterGoalRef.current = false;
      return;
    }
    if (profile.goalCelebrated) {
      goalRenewalPromptPendingRef.current = true;
      goalRenewalPromptAfterGoalRef.current = true;
      return;
    }
    if (hasPendingGoals) return;
    requestGoalRenewalPrompt();
  }, [hasPendingGoals, profile.goalCelebrated, profile.goalRenewalPending, requestGoalRenewalPrompt]);

  useEffect(() => {
    setActiveCurrency(profile.currency || DEFAULT_PROFILE.currency);
  }, [profile.currency]);
  useEffect(() => {
    const nextCurrency = profile?.currency || DEFAULT_PROFILE.currency;
    setFabCurrencyCode((prev) => (prev === nextCurrency ? prev : nextCurrency));
  }, [profile?.currency]);

  useEffect(() => {
    if (!themeHydrated) return;
    queuePersist(STORAGE_KEYS.THEME, theme);
  }, [queuePersist, theme, themeHydrated]);
  useEffect(() => {
    if (!proThemeAccentHydrated) return;
    queuePersist(STORAGE_KEYS.PRO_THEME_ACCENT, proThemeAccentId);
  }, [proThemeAccentHydrated, proThemeAccentId, queuePersist]);

  useEffect(() => {
    if (!languageHydrated) return;
    queuePersist(STORAGE_KEYS.LANGUAGE, language);
  }, [queuePersist, language, languageHydrated]);
  useEffect(() => {
    if (!reportsBadgeHydrated) return;
    AsyncStorage.setItem(STORAGE_KEYS.REPORTS_BADGE, reportsBadgeVisible ? "1" : "0").catch(() => {});
  }, [reportsBadgeHydrated, reportsBadgeVisible]);
  useEffect(() => {
    if (!reportsLastAutoWeekHydrated) return;
    if (reportsLastAutoWeekKey) {
      AsyncStorage.setItem(STORAGE_KEYS.REPORTS_LAST_AUTO_WEEK, reportsLastAutoWeekKey).catch(() => {});
    } else {
      AsyncStorage.removeItem(STORAGE_KEYS.REPORTS_LAST_AUTO_WEEK).catch(() => {});
    }
  }, [reportsLastAutoWeekHydrated, reportsLastAutoWeekKey]);
  useEffect(() => {
    if (!reportsWeeklyNotificationHydrated) return;
    if (reportsWeeklyNotificationId) {
      AsyncStorage.setItem(STORAGE_KEYS.REPORTS_WEEKLY_NOTIFICATION, reportsWeeklyNotificationId).catch(() => {});
    } else {
      AsyncStorage.removeItem(STORAGE_KEYS.REPORTS_WEEKLY_NOTIFICATION).catch(() => {});
    }
  }, [reportsWeeklyNotificationHydrated, reportsWeeklyNotificationId]);
  useEffect(() => {
    if (!premiumInstallIdHydrated) return;
    const normalized = premiumInstallId || createMonetizationInstallId();
    if (normalized !== premiumInstallId) {
      setPremiumInstallId(normalized);
      return;
    }
    queuePersist(STORAGE_KEYS.PREMIUM_INSTALL_ID, normalized);
  }, [premiumInstallId, premiumInstallIdHydrated, queuePersist]);
  useEffect(() => {
    if (!premiumSoftPaywallHydrated) return;
    queuePersist(STORAGE_KEYS.PREMIUM_SOFT_PAYWALL_SHOWN, premiumSoftPaywallShown ? "1" : "0");
  }, [premiumSoftPaywallHydrated, premiumSoftPaywallShown, queuePersist]);
  useEffect(() => {
    if (!premiumHardPaywallHydrated) return;
    queuePersist(STORAGE_KEYS.PREMIUM_HARD_PAYWALL_SHOWN, premiumHardPaywallShown ? "1" : "0");
  }, [premiumHardPaywallHydrated, premiumHardPaywallShown, queuePersist]);
  useEffect(() => {
    if (!premiumChallengeClaimsHydrated) return;
    queuePersist(
      STORAGE_KEYS.PREMIUM_CHALLENGE_CLAIMS,
      String(Math.max(0, Number(premiumChallengeClaims) || 0))
    );
  }, [premiumChallengeClaims, premiumChallengeClaimsHydrated, queuePersist]);

  useEffect(() => {
    if (!healthHydrated) return;
    queuePersist(STORAGE_KEYS.HEALTH, String(healthPoints));
  }, [queuePersist, healthHydrated, healthPoints]);
  useEffect(() => {
    if (!dailyRewardHydrated) return;
    queuePersist(STORAGE_KEYS.DAILY_REWARD, JSON.stringify(dailyRewardState));
  }, [queuePersist, dailyRewardHydrated, dailyRewardState]);

  useEffect(() => {
    if (!claimedRewardsHydrated) return;
    queuePersist(STORAGE_KEYS.CLAIMED_REWARDS, JSON.stringify(claimedRewards));
  }, [queuePersist, claimedRewards, claimedRewardsHydrated]);
  useEffect(() => {
    if (!rewardTotalHydrated || !Number.isFinite(rewardClaimTotal)) return;
    queuePersist(STORAGE_KEYS.REWARD_TOTAL, String(Math.max(0, rewardClaimTotal)));
  }, [queuePersist, rewardClaimTotal, rewardTotalHydrated]);

  useEffect(() => {
    if (!challengesHydrated) return;
    queuePersist(STORAGE_KEYS.CHALLENGES, JSON.stringify(challengesState));
  }, [queuePersist, challengesState, challengesHydrated]);
  useEffect(() => {
    if (!challengeBadgeStoreHydrated) return;
    queuePersist(STORAGE_KEYS.CHALLENGE_BADGES, JSON.stringify(challengeBadgeStore));
  }, [queuePersist, challengeBadgeStore, challengeBadgeStoreHydrated]);
  useEffect(() => {
    if (!dailyChallengeHydrated) return;
    queuePersist(STORAGE_KEYS.DAILY_CHALLENGE, JSON.stringify(dailyChallenge));
  }, [queuePersist, dailyChallenge, dailyChallengeHydrated]);
  useEffect(() => {
    if (!dailyChallengeCompletedHydrated) return;
    queuePersist(
      STORAGE_KEYS.DAILY_CHALLENGE_COMPLETED_TOTAL,
      String(Math.max(0, Number(dailyChallengeCompletedCount) || 0))
    );
  }, [queuePersist, dailyChallengeCompletedCount, dailyChallengeCompletedHydrated]);
  useEffect(() => {
    if (!focusVictoryHydrated) return;
    queuePersist(
      STORAGE_KEYS.FOCUS_VICTORY_TOTAL,
      String(Math.max(0, Number(focusVictoryCount) || 0))
    );
  }, [queuePersist, focusVictoryCount, focusVictoryHydrated]);

useEffect(() => {
  if (!tamagotchiHydratedRef.current) return;
  queuePersist(STORAGE_KEYS.TAMAGOTCHI, JSON.stringify(tamagotchiState));
}, [queuePersist, tamagotchiState]);

useEffect(() => {
  if (!tamagotchiGreetingDayHydrated) return;
  queuePersist(STORAGE_KEYS.TAMAGOTCHI_GREETING_DAY, tamagotchiGreetingDayKey || "");
}, [queuePersist, tamagotchiGreetingDayHydrated, tamagotchiGreetingDayKey]);

  useEffect(() => {
    if (!tamagotchiSkinHydrated) return;
    queuePersist(STORAGE_KEYS.TAMAGOTCHI_SKIN, tamagotchiSkinId);
  }, [queuePersist, tamagotchiSkinHydrated, tamagotchiSkinId]);

  useEffect(() => {
    if (!catalogHydrated) return;
    queuePersist(STORAGE_KEYS.CATALOG, JSON.stringify(catalogOverrides));
  }, [queuePersist, catalogOverrides, catalogHydrated]);
  useEffect(() => {
    if (!pricePrecisionOverridesHydrated) return;
    queuePersist(
      STORAGE_KEYS.PRICE_PRECISION_OVERRIDES,
      JSON.stringify(pricePrecisionOverrides)
    );
  }, [queuePersist, pricePrecisionOverrides, pricePrecisionOverridesHydrated]);

  useEffect(() => {
    if (!titleOverridesHydrated) return;
    queuePersist(STORAGE_KEYS.TITLE_OVERRIDES, JSON.stringify(titleOverrides));
  }, [queuePersist, titleOverrides, titleOverridesHydrated]);

  useEffect(() => {
    if (!emojiOverridesHydrated) return;
    queuePersist(STORAGE_KEYS.EMOJI_OVERRIDES, JSON.stringify(emojiOverrides));
  }, [queuePersist, emojiOverrides, emojiOverridesHydrated]);
  useEffect(() => {
    if (!categoryOverridesHydrated) return;
    queuePersist(STORAGE_KEYS.CATEGORY_OVERRIDES, JSON.stringify(categoryOverrides));
  }, [queuePersist, categoryOverrides, categoryOverridesHydrated]);

  useEffect(() => {
    if (!customCategoriesHydrated) return;
    queuePersist(STORAGE_KEYS.CUSTOM_CATEGORIES, JSON.stringify(customCategories));
  }, [queuePersist, customCategories, customCategoriesHydrated]);

  useEffect(() => {
    if (!removedCategoriesHydrated) return;
    queuePersist(STORAGE_KEYS.REMOVED_CATEGORIES, JSON.stringify(removedCategories));
  }, [queuePersist, removedCategories, removedCategoriesHydrated]);

  useEffect(() => {
    if (!savingsCategoryOverrideHydrated) return;
    queuePersist(
      STORAGE_KEYS.SAVINGS_CATEGORY_OVERRIDE,
      JSON.stringify(savingsCategoryOverride)
    );
  }, [queuePersist, savingsCategoryOverride, savingsCategoryOverrideHydrated]);

  useEffect(() => {
    if (!categoryDefOverridesHydrated) return;
    queuePersist(STORAGE_KEYS.CATEGORY_DEF_OVERRIDES, JSON.stringify(categoryDefOverrides));
  }, [queuePersist, categoryDefOverrides, categoryDefOverridesHydrated]);

  useEffect(() => {
    if (!savingsCategoryOverrideHydrated) return;
    applySavingsCategoryOverride(savingsCategoryOverride);
  }, [savingsCategoryOverride, savingsCategoryOverrideHydrated]);

  useEffect(() => {
    if (!categoryDefOverridesHydrated) return;
    applyCategoryDefOverrides(categoryDefOverrides);
  }, [categoryDefOverrides, categoryDefOverridesHydrated]);

  useEffect(() => {
    if (!descriptionOverridesHydrated) return;
    queuePersist(STORAGE_KEYS.DESCRIPTION_OVERRIDES, JSON.stringify(descriptionOverrides));
  }, [queuePersist, descriptionOverrides, descriptionOverridesHydrated]);

  useEffect(() => {
    if (!incomeEntriesHydrated) return;
    queuePersist(STORAGE_KEYS.INCOME_ENTRIES, JSON.stringify(incomeEntries));
  }, [queuePersist, incomeEntries, incomeEntriesHydrated]);

  useEffect(() => {
    if (!budgetOverridesHydrated) return;
    queuePersist(STORAGE_KEYS.BUDGET_LIMITS, JSON.stringify(budgetOverrides));
  }, [queuePersist, budgetOverrides, budgetOverridesHydrated]);

  useEffect(() => {
    if (!budgetOverspendHydrated) return;
    queuePersist(STORAGE_KEYS.BUDGET_OVERSPEND, JSON.stringify(budgetOverspendMap));
  }, [queuePersist, budgetOverspendHydrated, budgetOverspendMap]);

  useEffect(() => {
    if (!incomePromptHydrated) return;
    queuePersist(STORAGE_KEYS.INCOME_PROMPT, JSON.stringify(incomePromptState));
  }, [queuePersist, incomePromptHydrated, incomePromptState]);

  useEffect(() => {
    if (!savedTotalHydrated) return;
    queuePersist(STORAGE_KEYS.SAVED_TOTAL, String(savedTotalUSD));
  }, [queuePersist, savedTotalUSD, savedTotalHydrated]);

  useEffect(() => {
    if (!progressSavedTotalHydrated) return;
    queuePersist(STORAGE_KEYS.SAVED_TOTAL_PROGRESS, String(progressSavedTotalUSD));
  }, [queuePersist, progressSavedTotalUSD, progressSavedTotalHydrated]);

  useEffect(() => {
    if (!levelProgressOffsetHydrated) return;
    queuePersist(
      STORAGE_KEYS.LEVEL_PROGRESS_OFFSET,
      String(Math.max(0, Number(levelProgressOffsetUSD) || 0))
    );
  }, [queuePersist, levelProgressOffsetHydrated, levelProgressOffsetUSD]);

  useEffect(() => {
    if (!lastCelebratedLevelHydrated) return;
    queuePersist(
      STORAGE_KEYS.LAST_CELEBRATED_LEVEL,
      String(Math.max(1, Number(lastCelebratedLevel) || 1))
    );
  }, [queuePersist, lastCelebratedLevel, lastCelebratedLevelHydrated]);

  useEffect(() => {
    if (!savedTotalHydrated || !lifetimeSavedHydrated) return;
    setLifetimeSavedUSD((prev) => (savedTotalUSD > prev ? savedTotalUSD : prev));
  }, [savedTotalUSD, savedTotalHydrated, lifetimeSavedHydrated]);

  useEffect(() => {
    if (!progressSavedTotalHydrated || !progressLifetimeSavedHydrated) return;
    setProgressLifetimeSavedUSD((prev) =>
      progressSavedTotalUSD > prev ? progressSavedTotalUSD : prev
    );
  }, [progressSavedTotalUSD, progressSavedTotalHydrated, progressLifetimeSavedHydrated]);

  useEffect(() => {
    if (!lifetimeSavedHydrated) return;
    queuePersist(STORAGE_KEYS.SAVED_TOTAL_PEAK, String(lifetimeSavedUSD));
  }, [queuePersist, lifetimeSavedUSD, lifetimeSavedHydrated]);

  useEffect(() => {
    if (!progressLifetimeSavedHydrated) return;
    queuePersist(STORAGE_KEYS.SAVED_TOTAL_PROGRESS_PEAK, String(progressLifetimeSavedUSD));
  }, [queuePersist, progressLifetimeSavedUSD, progressLifetimeSavedHydrated]);

  useEffect(() => {
    if (!declinesHydrated) return;
    queuePersist(STORAGE_KEYS.DECLINES, String(declineCount));
  }, [queuePersist, declineCount, declinesHydrated]);

  useEffect(() => {
    if (onboardingStep !== "done") return;
    if (!profileHydrated) return;
    if (
      !historyHydrated ||
      !savedTotalHydrated ||
      !lifetimeSavedHydrated ||
      !progressSavedTotalHydrated ||
      !progressLifetimeSavedHydrated ||
      !declinesHydrated
    )
      return;
    if (savedTotalUSD <= 0 && lifetimeSavedUSD <= 0) return;
    const joinedAtTimestamp = profile?.joinedAt ? new Date(profile.joinedAt).getTime() : 0;
    if (!Number.isFinite(joinedAtTimestamp) || joinedAtTimestamp <= 0) return;
    if (Date.now() - joinedAtTimestamp > DAY_MS * 2) return;
    const hasSavingsHistory = resolvedHistoryEvents.some(
      (entry) =>
        entry &&
        (HISTORY_SAVED_GAIN_EVENTS.has(entry.kind) ||
          (spendReducesSavings && HISTORY_SAVED_LOSS_EVENTS.has(entry.kind)))
    );
    if (hasSavingsHistory || declineCount > 0) return;
    const recentSaveAt = lastSaveActionAtRef.current || 0;
    if (recentSaveAt && Date.now() - recentSaveAt < SAVED_TOTAL_RESET_GRACE_MS) return;
    setSavedTotalUSD(0);
    setLifetimeSavedUSD(0);
    setProgressSavedTotalUSD(0);
    setProgressLifetimeSavedUSD(0);
    setLevelProgressOffsetUSD(0);
    tutorialLevelOffsetAppliedRef.current = false;
    setLastCelebratedLevel(1);
    previousPlayerLevelRef.current = 1;
    persistLastCelebratedLevel(1);
    AsyncStorage.multiSet([
      [STORAGE_KEYS.SAVED_TOTAL, "0"],
      [STORAGE_KEYS.SAVED_TOTAL_PEAK, "0"],
      [STORAGE_KEYS.SAVED_TOTAL_PROGRESS, "0"],
      [STORAGE_KEYS.SAVED_TOTAL_PROGRESS_PEAK, "0"],
      [STORAGE_KEYS.LEVEL_PROGRESS_OFFSET, "0"],
      [STORAGE_KEYS.LAST_CELEBRATED_LEVEL, "1"],
    ]).catch(() => {});
  }, [
    declineCount,
    declinesHydrated,
    historyHydrated,
    lifetimeSavedHydrated,
    onboardingStep,
    progressLifetimeSavedHydrated,
    progressSavedTotalHydrated,
    persistLastCelebratedLevel,
    profile?.joinedAt,
    profileHydrated,
    progressLifetimeSavedUSD,
    progressSavedTotalUSD,
    resolvedHistoryEvents,
    savedTotalHydrated,
    savedTotalUSD,
    lifetimeSavedUSD,
    spendReducesSavings,
  ]);

  useEffect(() => {
    if (!dailyNudgesHydrated) return;
    queuePersist(STORAGE_KEYS.DAILY_NUDGES, JSON.stringify(dailyNudgeNotificationIds));
  }, [queuePersist, dailyNudgeNotificationIds, dailyNudgesHydrated]);

  useEffect(() => {
    if (!smartRemindersHydrated) return;
    queuePersist(STORAGE_KEYS.SMART_REMINDERS, JSON.stringify(smartReminders));
  }, [queuePersist, smartReminders, smartRemindersHydrated]);
  useEffect(() => {
    if (!potentialPushHydrated) return;
    queuePersist(
      STORAGE_KEYS.POTENTIAL_PUSH_PROGRESS,
      JSON.stringify({
        lastStep: Math.max(0, Number(potentialPushProgress.lastStep) || 0),
        lastStatus:
          potentialPushProgress.lastStatus === "ahead" || potentialPushProgress.lastStatus === "behind"
            ? potentialPushProgress.lastStatus
            : null,
        baselineKey: potentialPushProgress.baselineKey || null,
        stepMultiplier: Math.min(
          POTENTIAL_PUSH_MAX_MULTIPLIER,
          Math.max(1, Number(potentialPushProgress.stepMultiplier) || 1)
        ),
        lastNotifiedAt:
          Number.isFinite(Number(potentialPushProgress.lastNotifiedAt)) &&
          Number(potentialPushProgress.lastNotifiedAt) > 0
            ? Number(potentialPushProgress.lastNotifiedAt)
            : 0,
      })
    );
  }, [queuePersist, potentialPushHydrated, potentialPushProgress]);

  useEffect(() => {
    if (!pendingHydrated) return;
    queuePersist(STORAGE_KEYS.PENDING, JSON.stringify(pendingList));
  }, [queuePersist, pendingList, pendingHydrated]);

  useEffect(() => {
    if (!freeDayHydrated) return;
    queuePersist(STORAGE_KEYS.FREE_DAY, JSON.stringify(freeDayStats));
  }, [queuePersist, freeDayStats, freeDayHydrated]);

  useEffect(() => {
    if (!usageStreakHydrated) return;
    queuePersist(STORAGE_KEYS.USAGE_STREAK, JSON.stringify(usageStreak));
  }, [queuePersist, usageStreak, usageStreakHydrated]);
  useEffect(() => {
    if (!streakPledgeHydrated) return;
    queuePersist(STORAGE_KEYS.STREAK_PLEDGE, JSON.stringify(streakPledge));
  }, [queuePersist, streakPledge, streakPledgeHydrated]);

  useEffect(() => {
    if (!refuseStatsHydrated) return;
    queuePersist(STORAGE_KEYS.REFUSE_STATS, JSON.stringify(refuseStats));
  }, [queuePersist, refuseStats, refuseStatsHydrated]);

  useEffect(() => {
    if (!temptationInteractionsHydrated) return;
    queuePersist(STORAGE_KEYS.TEMPTATION_INTERACTIONS, JSON.stringify(temptationInteractions));
  }, [queuePersist, temptationInteractions, temptationInteractionsHydrated]);
  useEffect(() => {
    if (!temptationInteractionsHydrated) return;
    const now = Date.now();
    const updates = {};
    Object.entries(temptationInteractions || {}).forEach(([templateId, entry]) => {
      if (!entry?.frequency) return;
      const desiredIntervalMs = getFrequencyIntervalMs(entry.frequency);
      const intervalMs = desiredIntervalMs || entry.intervalMs || null;
      const lastInteractionAt = Number(entry.lastInteractionAt) || 0;
      const baseNextCheckAt =
        Number(entry.nextCheckAt) ||
        (intervalMs && lastInteractionAt ? lastInteractionAt + intervalMs : null);
      if (!intervalMs || !baseNextCheckAt) return;
      const shouldUpdateInterval =
        Number.isFinite(desiredIntervalMs) && entry.intervalMs !== desiredIntervalMs;
      if (baseNextCheckAt > now && !shouldUpdateInterval && entry.nextCheckAt) return;
      if (baseNextCheckAt > now) {
        updates[templateId] = {
          nextCheckAt: baseNextCheckAt,
          intervalMs,
          missedCyclesDelta: 0,
        };
        return;
      }
      const cyclesMissed = Math.max(
        1,
        Math.floor((now - baseNextCheckAt) / intervalMs) + 1
      );
      updates[templateId] = {
        nextCheckAt: baseNextCheckAt + cyclesMissed * intervalMs,
        intervalMs,
        missedCyclesDelta: cyclesMissed,
      };
    });
    const templateIds = Object.keys(updates);
    if (!templateIds.length) return;
    setTemptationInteractions((prev) => {
      const source = prev || {};
      let changed = false;
      const next = { ...source };
      templateIds.forEach((templateId) => {
        const prevEntry = source[templateId];
        if (!prevEntry) return;
        const update = updates[templateId];
        const nextMissedCycles = (prevEntry.missedCycles || 0) + update.missedCyclesDelta;
        if (
          prevEntry.nextCheckAt === update.nextCheckAt &&
          prevEntry.lastTimerResetAt === now &&
          prevEntry.missedCycles === nextMissedCycles
        ) {
          return;
        }
        next[templateId] = {
          ...prevEntry,
          nextCheckAt: update.nextCheckAt,
          intervalMs: update.intervalMs || prevEntry.intervalMs || null,
          lastTimerResetAt: now,
          missedCycles: nextMissedCycles,
          frequencyReminderScheduledAt: null,
          frequencyReminderLocale: null,
        };
        changed = true;
      });
      return changed ? next : prev;
    });
  }, [
    setTemptationInteractions,
    temptationInteractions,
    temptationInteractionsHydrated,
  ]);
  useEffect(() => {
    if (!temptationInteractionsHydrated) return;
    if (notificationPermissionGranted !== true) return;
    const normalizedLanguage = normalizeLanguage(language);
    let cancelled = false;
    const cancelAndClearReminders = async (templateId, reminderValue) => {
      const ids = Array.isArray(reminderValue)
        ? reminderValue
        : reminderValue
        ? [reminderValue]
        : [];
      if (ids.length) {
        await Promise.all(
          ids.map((reminderId) =>
            safeNotifications.cancelScheduledNotificationAsync(reminderId)
          )
        );
      }
      if (cancelled) return;
      setTemptationInteractions((prev) => {
        const prevEntry = prev?.[templateId];
        if (!prevEntry) return prev;
        if (
          !prevEntry.frequencyReminderId &&
          !(prevEntry.frequencyReminderIds && prevEntry.frequencyReminderIds.length) &&
          !prevEntry.frequencyReminderScheduledAt &&
          !prevEntry.frequencyReminderLocale &&
          !prevEntry.frequencyReminderPlanKey
        ) {
          return prev;
        }
        return {
          ...(prev || {}),
          [templateId]: {
            ...prevEntry,
            frequencyReminderId: null,
            frequencyReminderIds: [],
            frequencyReminderScheduledAt: null,
            frequencyReminderLocale: null,
            frequencyReminderPlanKey: null,
          },
        };
      });
    };
    const ensureReminders = async () => {
      const entries = Object.entries(temptationInteractions || {});
      for (let index = 0; index < entries.length; index += 1) {
        if (cancelled) return;
        const [templateId, entry] = entries[index];
        if (!entry) continue;
        const frequency = entry.frequency;
        const nextCheckAt = entry.nextCheckAt;
        const existingReminderIds = Array.isArray(entry.frequencyReminderIds)
          ? entry.frequencyReminderIds
          : entry.frequencyReminderId
          ? [entry.frequencyReminderId]
          : [];
        const hasInteractions =
          (Number(entry.saveCount) || 0) + (Number(entry.spendCount) || 0) > 0 ||
          Number(entry.lastInteractionAt) > 0;
        if (!hasInteractions || !isTemplateReminderEligible(templateId)) {
          if (existingReminderIds.length) {
            await cancelAndClearReminders(templateId, existingReminderIds);
          }
          continue;
        }
        const hasFrequency = !!frequency && Number.isFinite(nextCheckAt);
        if (!hasFrequency) {
          if (existingReminderIds.length) {
            await cancelAndClearReminders(templateId, existingReminderIds);
          }
          continue;
        }
        const scheduleTriggers = buildFrequencyReminderSchedule(nextCheckAt);
        if (!scheduleTriggers.length) {
          if (existingReminderIds.length) {
            await cancelAndClearReminders(templateId, existingReminderIds);
          }
          continue;
        }
        const planKey = `${normalizedLanguage}:${scheduleTriggers.join(",")}`;
        if (
          entry.frequencyReminderPlanKey === planKey &&
          existingReminderIds.length === scheduleTriggers.length
        ) {
          continue;
        }
        if (existingReminderIds.length) {
          await cancelAndClearReminders(templateId, existingReminderIds);
          if (cancelled) return;
        }
        const label = entry.templateTitle || t("defaultDealTitle");
          const reminderIds = [];
        for (let idx = 0; idx < scheduleTriggers.length; idx += 1) {
          if (cancelled) break;
          const triggerTime = scheduleTriggers[idx];
          try {
            const dedupeKey = `frequency:${templateId}:${triggerTime}`;
            const scheduledEntry = await scheduleNotificationWithCooldown({
              content: {
                title: t("frequencyReminderTitle", { temptation: label }),
                body: t("frequencyReminderBody", { temptation: label }),
                sound: false,
                data: {
                  kind: "frequency_reminder",
                  templateId,
                  dedupeKey,
                },
              },
              trigger: new Date(triggerTime),
            });
            if (scheduledEntry?.id) {
              reminderIds.push(scheduledEntry.id);
            }
          } catch (error) {
            console.warn("frequency reminder schedule", error);
          }
        }
        if (cancelled) {
          if (reminderIds.length) {
            reminderIds.forEach((reminderId) =>
              safeNotifications.cancelScheduledNotificationAsync(reminderId)
            );
          }
          return;
        }
        if (!reminderIds.length) {
          continue;
        }
        setTemptationInteractions((prev) => {
          const prevEntry = prev?.[templateId];
          if (!prevEntry) return prev;
          return {
            ...(prev || {}),
            [templateId]: {
              ...prevEntry,
              frequencyReminderId: null,
              frequencyReminderIds: reminderIds,
              frequencyReminderPlanKey: planKey,
              frequencyReminderScheduledAt: null,
              frequencyReminderLocale: normalizedLanguage,
            },
          };
        });
      }
    };
    ensureReminders();
    return () => {
      cancelled = true;
    };
  }, [
    language,
    isTemplateReminderEligible,
    notificationPermissionGranted,
    scheduleNotificationWithCooldown,
    setTemptationInteractions,
    t,
    temptationInteractions,
    temptationInteractionsHydrated,
  ]);

  useEffect(() => {
    if (analyticsOptOut === null) return;
    if (Platform.OS === "ios" && !iosTrackingResolved) return;
    const effectiveOptOut =
      Platform.OS === "ios" && iosTrackingBlocked ? true : analyticsOptOut;
    setAnalyticsOptOutFlag(effectiveOptOut);
    queuePersist(STORAGE_KEYS.ANALYTICS_OPT_OUT, effectiveOptOut ? "1" : "0");
  }, [queuePersist, analyticsOptOut, iosTrackingBlocked, iosTrackingResolved]);

  useEffect(() => {
    if (!rewardCelebratedHydrated) return;
    queuePersist(STORAGE_KEYS.REWARDS_CELEBRATED, JSON.stringify(rewardCelebratedMap));
  }, [queuePersist, rewardCelebratedHydrated, rewardCelebratedMap]);
  useEffect(() => {
    if (analyticsOptOut !== false) return;
    if (!profileHydrated) return;
    if (notificationPermissionGranted === null) return;
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const hasGoalProperty =
      (Array.isArray(profile.primaryGoals) && profile.primaryGoals.length > 0) ||
      (wishes || []).some((wish) => wish.kind === PRIMARY_GOAL_KIND);
    const totalDecisions =
      (decisionStats?.resolvedToDeclines || 0) + (decisionStats?.resolvedToWishes || 0);
    let savingStyle = "balanced";
    if (totalDecisions > 0) {
      const declineShare = (decisionStats.resolvedToDeclines || 0) / totalDecisions;
      if (declineShare >= 0.7) {
        savingStyle = "aggressive";
      } else if (declineShare <= 0.4) {
        savingStyle = "relaxed";
      }
    }
    const personaType = profile.persona || DEFAULT_PERSONA_ID;
    const genderValue = profile.gender || "none";
    const notificationsAllowed = notificationPermissionGranted === true;
    setUserProperties({
      has_goal: !!hasGoalProperty,
      preferred_currency: currencyCode,
      saving_style: savingStyle,
      locale: language,
      is_premium: premiumState.isPremium,
      gender: genderValue,
      persona_type: personaType,
      notifications_allowed: notificationsAllowed,
      current_level: String(Math.max(1, Number(playerLevel) || 1)),
      analytics_consent: "enabled",
    });
  }, [
    analyticsOptOut,
    decisionStats?.resolvedToDeclines,
    decisionStats?.resolvedToWishes,
    language,
    notificationPermissionGranted,
    playerLevel,
    profile.currency,
    profile.gender,
    profile.persona,
    profile.primaryGoals,
    profileHydrated,
    premiumState.isPremium,
    wishes,
  ]);
  const trackRetentionActivityForToday = useCallback(() => {
    if (analyticsOptOut !== false) return;
    if (!profileHydrated) return;
    if (!retentionAnalyticsHydrated) return;
    const dayKey = currentDayKey || getDayKey(Date.now());
    if (!dayKey) return;
    const knownDays = normalizeRetentionDayKeys(retentionActiveDaysRef.current);
    if (knownDays.includes(dayKey)) return;
    const nextDays = normalizeRetentionDayKeys([...knownDays, dayKey]);
    retentionActiveDaysRef.current = nextDays;
    AsyncStorage.setItem(STORAGE_KEYS.RETENTION_ACTIVE_DAYS, JSON.stringify(nextDays)).catch(() => {});
    const activeDaysTotal = Math.max(1, nextDays.length);
    const activeStreak = Math.max(1, getConsecutiveActiveDays(nextDays));
    const previousDayKey = nextDays.length > 1 ? nextDays[nextDays.length - 2] : null;
    const gapDays = previousDayKey ? getDayDiff(previousDayKey, dayKey) : null;
    const missedDays = Number.isFinite(gapDays) ? Math.max(0, gapDays - 1) : 0;
    let lifetimeDay = activeDaysTotal;
    const joinedAtTimestamp = profileJoinedAt ? new Date(profileJoinedAt).getTime() : NaN;
    if (Number.isFinite(joinedAtTimestamp)) {
      const joinedDayKey = getDayKey(joinedAtTimestamp);
      const dayDiff = getDayDiff(joinedDayKey, dayKey);
      if (Number.isFinite(dayDiff)) {
        lifetimeDay = Math.max(1, dayDiff + 1);
      }
    }
    logEvent("retention_day_active", {
      lifetime_day: lifetimeDay,
      active_days_total: activeDaysTotal,
      active_streak: activeStreak,
      missed_days: missedDays,
    });
    setUserProperties({
      lifetime_days: String(lifetimeDay),
      active_days_total: String(activeDaysTotal),
      active_days_streak: String(activeStreak),
    });
    if (!RETENTION_MILESTONE_DAYS.has(lifetimeDay)) return;
    if (retentionMilestonesLoggedRef.current[lifetimeDay]) return;
    const nextMilestones = { ...retentionMilestonesLoggedRef.current, [lifetimeDay]: true };
    retentionMilestonesLoggedRef.current = nextMilestones;
    const persistedMilestones = normalizeRetentionMilestoneDays(
      Object.keys(nextMilestones).map((key) => Number(key))
    );
    AsyncStorage.setItem(STORAGE_KEYS.RETENTION_MILESTONES, JSON.stringify(persistedMilestones)).catch(() => {});
    logEvent("retention_day_milestone", {
      day: lifetimeDay,
      active_days_total: activeDaysTotal,
      active_streak: activeStreak,
    });
    if (lifetimeDay === 2 && !dayMilestonesLoggedRef.current.day2) {
      dayMilestonesLoggedRef.current = { ...dayMilestonesLoggedRef.current, day2: true };
      AsyncStorage.setItem(STORAGE_KEYS.DAY_TWO_ACTIVITY, "1").catch(() => {});
      logEvent("day_2");
    } else if (lifetimeDay === 3 && !dayMilestonesLoggedRef.current.day3) {
      dayMilestonesLoggedRef.current = { ...dayMilestonesLoggedRef.current, day3: true };
      AsyncStorage.setItem(STORAGE_KEYS.DAY_THREE_ACTIVITY, "1").catch(() => {});
      logEvent("day_3");
    }
  }, [
    analyticsOptOut,
    currentDayKey,
    logEvent,
    profileHydrated,
    profileJoinedAt,
    retentionAnalyticsHydrated,
    setUserProperties,
  ]);
  useEffect(() => {
    trackRetentionActivityForToday();
  }, [trackRetentionActivityForToday]);
  useEffect(() => {
    if (analyticsOptOut !== false) return;
    if (!soundEnabledHydrated) return;
    logEvent(soundEnabled ? "sound_setting_enabled" : "sound_setting_disabled");
  }, [analyticsOptOut, logEvent, soundEnabled, soundEnabledHydrated]);
  useEffect(() => {
    if (!profileHydrated) return;
    const nextGender = profile.gender || "none";
    const nextPersona = profile.persona || DEFAULT_PERSONA_ID;
    const previousSelection = profileSelectionRef.current;
    const isFirstSync = previousSelection.gender === null && previousSelection.persona === null;
    if (isFirstSync) {
      profileSelectionRef.current = { gender: nextGender, persona: nextPersona };
      return;
    }
    if (onboardingStep !== "done") {
      profileSelectionRef.current = { gender: nextGender, persona: nextPersona };
      return;
    }
    if (previousSelection.gender !== nextGender) {
      const genderEvent = getGenderSelectedEvent(nextGender);
      if (genderEvent) {
        logEvent(genderEvent);
      }
    }
    if (previousSelection.persona !== nextPersona) {
      const personaEvent = getPersonaSelectedEvent(nextPersona);
      if (personaEvent) {
        logEvent(personaEvent);
      }
    }
    profileSelectionRef.current = { gender: nextGender, persona: nextPersona };
  }, [onboardingStep, profile.gender, profile.persona, profileHydrated, logEvent]);

  useEffect(() => {
    if (!rewardsUnlocked) return;
    if (!rewardsReady || !rewardCelebratedHydrated || !achievements.length) return;
    const newlyUnlocked = achievements.filter(
      (reward) => reward.unlocked && !rewardCelebratedMap[reward.id]
    );
    if (!newlyUnlocked.length) return;
    newlyUnlocked.forEach((reward) => {
      logEvent("reward_unlocked", {
        reward_id: reward.id,
        type: "badge",
        condition: ACHIEVEMENT_CONDITION_MAP[reward.metricType] || reward.metricType || "unknown",
      });
    });
    persistRewardCelebrations((prev) => {
      const next = { ...(prev || {}) };
      newlyUnlocked.forEach((reward) => {
        next[reward.id] = true;
      });
      return next;
    });
    triggerOverlayState("reward", newlyUnlocked[0].title, { force: true });
  }, [
    achievements,
    logEvent,
    persistRewardCelebrations,
    rewardCelebratedHydrated,
    rewardCelebratedMap,
    rewardsReady,
    rewardsUnlocked,
  ]);

  const rebalanceWishesFromSavedTotal = useCallback(
    () => {
      if (!wishesHydrated || !savedTotalHydrated) return;
      const primaryGoalId = mainGoalWish?.goalId || activeGoalId || profile.goal || null;
      const { targetUSD: primaryTargetUSD, savedUSD: primaryCurrentSaved } = (() => {
        if (!primaryGoalId) return { targetUSD: 0, savedUSD: 0 };
        const entry = Array.isArray(profile.primaryGoals)
          ? profile.primaryGoals.find((goal) => goal?.id === primaryGoalId)
          : null;
        const target =
          Number.isFinite(entry?.targetUSD) && entry.targetUSD > 0
            ? entry.targetUSD
            : getGoalDefaultTargetUSD(primaryGoalId);
        const savedFromProfile = Number.isFinite(entry?.savedUSD) ? Math.max(entry.savedUSD, 0) : 0;
        const wishSnapshot = Array.isArray(wishesRef.current)
          ? wishesRef.current.find(
              (wish) =>
                (wish?.kind === PRIMARY_GOAL_KIND &&
                  (wish.goalId === primaryGoalId || wish.id === getPrimaryGoalWishId(primaryGoalId))) ||
                wish?.id === primaryGoalId
            )
          : null;
        const savedFromWish = Number.isFinite(wishSnapshot?.savedUSD)
          ? Math.max(wishSnapshot.savedUSD, 0)
          : 0;
        return { targetUSD: target, savedUSD: Math.max(savedFromProfile, savedFromWish) };
      })();
      const desiredPrimaryStatus =
        primaryGoalId && primaryTargetUSD > 0 && primaryCurrentSaved >= primaryTargetUSD
          ? "done"
          : "active";

      setWishes((prev) => {
        if (!prev.length) return prev;
        let changed = false;
        const next = prev.map((wish) => {
          const isPrimary = wish.kind === PRIMARY_GOAL_KIND && (wish.goalId || wish.id) === primaryGoalId;
          if (isPrimary) {
            if (wish.savedUSD !== primaryCurrentSaved || wish.status !== desiredPrimaryStatus) {
              changed = true;
              return { ...wish, savedUSD: primaryCurrentSaved, status: desiredPrimaryStatus };
            }
            return wish;
          }
          const status = (wish.savedUSD || 0) >= (wish.targetUSD || 0) ? "done" : "active";
          if (wish.status !== status) {
            changed = true;
            return { ...wish, status };
          }
          return wish;
        });
        return changed ? next : prev;
      });

      if (primaryGoalId) {
        syncPrimaryGoalProgress(primaryGoalId, primaryCurrentSaved, desiredPrimaryStatus);
      }
    },
    [
      activeGoalId,
      mainGoalWish?.goalId,
      profile.goal,
      profile.primaryGoals,
      savedTotalHydrated,
      syncPrimaryGoalProgress,
      wishesHydrated,
      setWishes,
    ]
  );

  useEffect(() => {
    rebalanceWishesFromSavedTotal();
  }, [rebalanceWishesFromSavedTotal, savedTotalUSD]);

  useEffect(() => {
    if (!decisionStatsHydrated) return;
    queuePersist(STORAGE_KEYS.DECISION_STATS, JSON.stringify(decisionStats));
  }, [queuePersist, decisionStats, decisionStatsHydrated]);

  useEffect(() => {
    if (!historyHydrated) return;
    queuePersist(STORAGE_KEYS.HISTORY, JSON.stringify(resolvedHistoryEvents));
  }, [queuePersist, historyHydrated, resolvedHistoryEvents]);

  useEffect(() => {
    if (!quickTemptationsHydrated) return;
    queuePersist(STORAGE_KEYS.CUSTOM_TEMPTATIONS, JSON.stringify(quickTemptations));
  }, [queuePersist, quickTemptations, quickTemptationsHydrated]);
  useEffect(() => {
    if (!customTemptationsCreatedHydrated) return;
    queuePersist(
      STORAGE_KEYS.CUSTOM_TEMPTATIONS_CREATED,
      String(Math.max(0, Number(customTemptationsCreatedCount) || 0))
    );
  }, [queuePersist, customTemptationsCreatedCount, customTemptationsCreatedHydrated]);

  useEffect(() => {
    if (!hiddenTemptationsHydrated) return;
    queuePersist(STORAGE_KEYS.HIDDEN_TEMPTATIONS, JSON.stringify(hiddenTemptations));
  }, [queuePersist, hiddenTemptations, hiddenTemptationsHydrated]);

  useEffect(() => {
    if (!archivedTemptationsHydrated) return;
    queuePersist(STORAGE_KEYS.ARCHIVED_TEMPTATIONS, JSON.stringify(archivedTemptations));
  }, [queuePersist, archivedTemptations, archivedTemptationsHydrated]);

  useEffect(() => {
    if (!impulseTrackerHydrated) return;
    queuePersist(STORAGE_KEYS.IMPULSE_TRACKER, JSON.stringify(impulseTracker));
  }, [queuePersist, impulseTracker, impulseTrackerHydrated]);

  useEffect(() => {
    const applyOverrides = (card) => {
      if (!card) return null;
      const overrideCategory = categoryOverrides[card.id];
      const normalizedCategory =
        overrideCategory && IMPULSE_CATEGORY_DEFS[overrideCategory] ? overrideCategory : null;
      const precisionOverride = pricePrecisionOverrides[card.id];
      const normalizedPrecision =
        typeof precisionOverride === "number" && Number.isFinite(precisionOverride) && precisionOverride >= 0
          ? precisionOverride
          : card.pricePrecision ?? null;
      return {
        ...card,
        priceUSD: catalogOverrides[card.id] ?? card.priceUSD ?? card.basePriceUSD,
        pricePrecision: normalizedPrecision,
        titleOverride: titleOverrides[card.id] ?? card.titleOverride ?? null,
        emoji: emojiOverrides[card.id] || card.emoji,
        impulseCategoryOverride: normalizedCategory || card.impulseCategoryOverride || null,
        descriptionOverride: descriptionOverrides[card.id] ?? card.descriptionOverride ?? null,
      };
    };
    const nextList = DEFAULT_TEMPTATIONS.map(applyOverrides).sort(
      (a, b) =>
        (a.priceUSD ?? a.basePriceUSD ?? 0) - (b.priceUSD ?? b.basePriceUSD ?? 0)
    );
    const primaryTemplateId = profile.customSpend?.id || "custom_habit";
    const personalized = buildPersonalizedTemptations(profile, nextList).map(applyOverrides);
    const hiddenSet = new Set(hiddenTemptations);
    const personalizedVisible = personalized.filter(
      (card) => card && (card.id === primaryTemplateId || !hiddenSet.has(card.id))
    );
    const personalizedIds = new Set(personalizedVisible.map((c) => c.id));
    const quickAdjusted = quickTemptations
      .map(applyOverrides)
      .filter(
        (card) =>
          card &&
          (card.id === primaryTemplateId || (!hiddenSet.has(card.id) && !personalizedIds.has(card.id)))
      );
    const primaryCard =
      personalizedVisible.find((card) => card.id === primaryTemplateId) ||
      quickAdjusted.find((card) => card.id === primaryTemplateId) ||
      applyOverrides(nextList.find((card) => card?.id === primaryTemplateId));
    // Ð‘Ñ‹ÑÑ‚Ñ€Ð°Ñ ÐºÐ°ÑÑ‚Ð¾Ð¼Ð½Ð°Ñ ÐºÐ°Ñ€Ñ‚Ð° Ð²ÑÐµÐ³Ð´Ð° Ñ€ÐµÐ½Ð´ÐµÑ€Ð¸Ñ‚ÑÑ Ð¿ÐµÑ€Ð²Ð¾Ð¹, Ð·Ð°Ñ‚ÐµÐ¼ Ð¸Ð´Ñ‘Ñ‚ Ð¿ÐµÑ€ÑÐ¾Ð½Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ð¿Ð¾Ñ€ÑÐ´Ð¾Ðº.
    const combined = [...quickAdjusted, ...personalizedVisible];
    if (primaryCard && !combined.some((card) => card?.id === primaryTemplateId)) {
      combined.unshift(primaryCard);
    }

    setTemptations(combined);
  }, [
    catalogOverrides,
    pricePrecisionOverrides,
    profile,
    titleOverrides,
    emojiOverrides,
    categoryOverrides,
    descriptionOverrides,
    quickTemptations,
    hiddenTemptations,
    onboardingStep,
  ]);

  useEffect(() => {
    return () => {
      if (overlayTimer.current) clearTimeout(overlayTimer.current);
      Object.values(cardFeedbackTimers.current).forEach((timer) => clearTimeout(timer));
    };
  }, []);

  useEffect(() => {
    if (!focusTemplateId) return;
    const exists =
      [...quickTemptations, ...temptations].some((card) => card?.id === focusTemplateId) ||
      focusTemplateId === primaryTemptationId;
    if (!exists) {
      setFocusTemplateId(null);
      setFocusSaveCount(0);
    }
  }, [focusTemplateId, primaryTemptationId, quickTemptations, temptations]);

  const handleTabChange = (tabKey) => {
    triggerHaptic();
    if (tabKey === activeTab) {
      scrollActiveTabToTop(tabKey, { animated: true });
      return;
    }
    if (tabKey === "cart") {
      logEvent("menu_progress_opened");
    }
    goToTab(tabKey);
  };

  const handleTabHistoryBack = useCallback(() => {
    const history = tabHistoryRef.current;
    if (!history.length) return false;
    const previousTab = history[history.length - 1];
    const nextHistory = history.slice(0, -1);
    updateTabHistory(nextHistory);
    goToTab(previousTab, { recordHistory: false });
    return true;
  }, [goToTab, updateTabHistory]);

  const handleAppBack = useCallback(() => {
    if (onboardingStep !== "done") {
      if (canGoBackOnboarding) {
        handleOnboardingBack();
        return true;
      }
      return false;
    }
    return handleTabHistoryBack();
  }, [canGoBackOnboarding, handleOnboardingBack, handleTabHistoryBack, onboardingStep]);

  const canUseBackGesture = onboardingStep !== "done" ? canGoBackOnboarding : tabHistory.length > 0;

  const backGestureResponder = useMemo(() => {
    if (!canUseBackGesture) return null;
    let handled = false;
    const tryHandleBack = (gestureState) => {
      if (
        handled ||
        gestureState.dx > -BACK_GESTURE_TRIGGER_DISTANCE ||
        Math.abs(gestureState.dy) >= BACK_GESTURE_VERTICAL_SLOP
      ) {
        return;
      }
      handled = true;
      handleAppBack();
    };
    return PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: (_, gestureState) =>
        Math.abs(gestureState.dx) > Math.abs(gestureState.dy) && gestureState.dx < -10,
      onPanResponderRelease: (_, gestureState) => {
        tryHandleBack(gestureState);
      },
      onPanResponderTerminate: (_, gestureState) => {
        tryHandleBack(gestureState);
      },
      onPanResponderTerminationRequest: () => true,
    });
  }, [canUseBackGesture, handleAppBack]);

  const handleThemeToggle = (mode) => {
    const nextTheme = normalizeThemeId(mode);
    if (nextTheme === PRO_THEME_ID && !premiumState.isPremium) {
      ensurePremiumFeatureAccess(PREMIUM_FEATURE_KEYS.proTheme, { kind: "feature" });
      return;
    }
    triggerHaptic();
    if (nextTheme === PRO_THEME_ID) {
      setProThemeAccentPickerVisible(true);
    } else {
      setProThemeAccentPickerVisible(false);
    }
    setTheme(nextTheme);
    if (nextTheme !== theme) {
      logEvent(
        "theme_selected",
        buildThemeSelectedEventPayload(nextTheme, proThemeAccentId, "theme_toggle")
      );
    }
  };
  const handleProThemeAccentSelect = useCallback(
    (accentId, { close = true } = {}) => {
      const normalizedAccentId = normalizeProThemeAccentId(accentId);
      triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
      setProThemeAccentId(normalizedAccentId);
      if (close) {
        setProThemeAccentPickerVisible(false);
      }
      logEvent(
        "theme_selected",
        buildThemeSelectedEventPayload(PRO_THEME_ID, normalizedAccentId, "pro_accent_picker")
      );
    },
    [logEvent, triggerHaptic]
  );
  const closeProThemeAccentPicker = useCallback(() => {
    setProThemeAccentPickerVisible(false);
  }, []);

  useEffect(() => {
    if (theme !== PRO_THEME_ID) return;
    const premiumStateResolved = premiumState.enabled || !!premiumState.error;
    if (!premiumStateResolved) return;
    if (premiumState.isPremium) return;
    setTheme(DEFAULT_THEME);
    setProThemeAccentPickerVisible(false);
  }, [premiumState.enabled, premiumState.error, premiumState.isPremium, theme]);
  useEffect(() => {
    if (theme === PRO_THEME_ID) return;
    if (!proThemeAccentPickerVisible) return;
    setProThemeAccentPickerVisible(false);
  }, [proThemeAccentPickerVisible, theme]);

  const handleLanguageChange = (lng) => {
    const nextLanguage = normalizeLanguage(lng);
    triggerHaptic();
    if (nextLanguage !== language) {
      setLanguage(nextLanguage);
      triggerWidgetRefresh();
    }
    const languageEvent = getLanguageSelectedEvent(nextLanguage);
    if (languageEvent) {
      logEvent(languageEvent);
    }
  };

  const handleTermsOpen = () => {
    triggerHaptic();
    setTermsContinuePending(false);
    setTermsModalVisible(true);
  };

  const handleTermsCancel = () => {
    triggerHaptic();
    setTermsContinuePending(false);
    setTermsModalVisible(false);
  };

  const handleTermsLinkOpen = () => {
    const normalizedLanguage = normalizeLanguage(language);
    const url = TERMS_LINKS[normalizedLanguage] || TERMS_LINKS.en;
    if (!url) return;
    triggerHaptic();
    Linking.openURL(url).catch((error) => console.warn("terms link", error));
  };
  const handlePrivacyPolicyOpen = useCallback(() => {
    const normalizedLanguage = normalizeLanguage(language);
    const url = PRIVACY_LINKS[normalizedLanguage] || PRIVACY_LINKS.en;
    if (!url) return;
    triggerHaptic();
    Linking.openURL(url).catch((error) => console.warn("privacy policy", error));
  }, [language]);
  const handleManageSubscriptionsOpen = useCallback(() => {
    const fallbackUrl =
      Platform.OS === "ios" ? IOS_MANAGE_SUBSCRIPTIONS_URL : ANDROID_MANAGE_SUBSCRIPTIONS_URL;
    const targetUrl = resolveNonEmptyString(fallbackUrl);
    if (!targetUrl) return;
    triggerHaptic();
    Linking.openURL(targetUrl).catch((error) => console.warn("manage subscriptions link", error));
  }, []);

  const handleTermsAccept = () => {
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    const shouldAdvance = termsContinuePending;
    setTermsAccepted(true);
    setTermsModalVisible(false);
    setTermsContinuePending(false);
    AsyncStorage.setItem(STORAGE_KEYS.TERMS_ACCEPTED, "1").catch(() => {});
    logEvent("onboarding_terms_accepted", { language });
    logEvent("consent_terms_accepted", { language });
    if (shouldAdvance) {
      goToOnboardingStep("analytics_consent");
    }
  };

  const handleProfileCurrencyChange = (code) => {
    if (!CURRENCIES.includes(code) || profile.currency === code) return;
    triggerHaptic();
    setProfile((prev) => ({ ...prev, currency: code }));
    setProfileDraft((prev) => ({ ...prev, currency: code }));
    setRegistrationData((prev) => ({ ...prev, currency: code }));
    setActiveCurrency(code);
    setFabCurrencyCode(code);
    triggerWidgetRefresh();
    const currencyEvent = getCurrencySelectedEvent(code);
    if (currencyEvent) {
      logEvent(currencyEvent);
    }
  };

  const openIncomeEntryModal = useCallback(
    (source = "manual") => {
      incomeEntrySourceRef.current = source;
      incomeEntryModeRef.current = INCOME_ENTRY_TYPES.MONTHLY;
      setIncomeEntryInput({ amount: "" });
      setIncomeEntryModalVisible(true);
    },
    []
  );

  const openExtraIncomeEntryModal = useCallback(
    (source = "manual") => {
      incomeEntrySourceRef.current = source;
      incomeEntryModeRef.current = INCOME_ENTRY_TYPES.EXTRA;
      setIncomeEntryInput({ amount: "" });
      setIncomeEntryModalVisible(true);
    },
    []
  );

  const closeIncomeEntryModal = useCallback(() => {
    setIncomeEntryModalVisible(false);
  }, []);

  const addIncomeEntry = useCallback(
    ({
      amountText = "",
      note = "",
      receivedAt = Date.now(),
      currencyCode,
      entryType = INCOME_ENTRY_TYPES.MONTHLY,
    } = {}) => {
      const parsed = parseNumberInputValue(amountText);
      if (!Number.isFinite(parsed) || parsed <= 0) {
        Alert.alert("Almost", t("incomeEntryInvalid"));
        return null;
      }
      const resolvedCurrency = currencyCode || profile.currency || DEFAULT_PROFILE.currency;
      const amountUSD = convertFromCurrency(parsed, resolvedCurrency);
      const entry = normalizeIncomeEntry({ amountUSD, receivedAt, note, entryType });
      if (!entry) {
        Alert.alert("Almost", t("incomeEntryInvalid"));
        return null;
      }
      setIncomeEntries((prev) => {
        const next = [entry, ...(Array.isArray(prev) ? prev : [])];
        return next.slice(0, MAX_INCOME_ENTRIES);
      });
      return amountUSD;
    },
    [profile.currency, t]
  );

  const handleBudgetOverrideChange = useCallback((categoryId, valueUSD) => {
    if (!categoryId) return;
    const normalized = Number(valueUSD);
    if (!Number.isFinite(normalized) || normalized < 0) return;
    setBudgetOverrides((prev) => ({
      ...(prev || {}),
      [categoryId]: normalized,
    }));
  }, []);

  const formatLocalIncomeAmount = useCallback(
    (valueUSD = 0) => {
      const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
      return formatCurrency(convertToCurrency(valueUSD || 0, currencyCode), currencyCode);
    },
    [profile.currency]
  );

  const handleIncomeEntrySkip = useCallback(() => {
    const monthKey = getMonthKey(Date.now());
    const entryType = incomeEntryModeRef.current || INCOME_ENTRY_TYPES.MONTHLY;
    if (entryType !== INCOME_ENTRY_TYPES.MONTHLY) {
      setIncomeEntryModalVisible(false);
      logEvent("income_entry_skipped", {
        source: incomeEntrySourceRef.current || "manual",
        month_key: monthKey,
        entry_type: entryType,
      });
      return;
    }
    setIncomePromptState({ lastPromptMonthKey: monthKey, lastPromptAt: Date.now() });
    setIncomeEntryModalVisible(false);
    setIncomePromptPending(false);
    clearQueuedModal(QUEUED_MODAL_TYPES.INCOME_PROMPT);
    logEvent("income_entry_skipped", {
      source: incomeEntrySourceRef.current || "monthly_prompt",
      month_key: monthKey,
      entry_type: entryType,
    });
  }, [clearQueuedModal, logEvent]);
  const handleIncomeEntryDismiss = useCallback(() => {
    if (incomeEntrySourceRef.current === "monthly_prompt") {
      handleIncomeEntrySkip();
      return;
    }
    closeIncomeEntryModal();
  }, [closeIncomeEntryModal, handleIncomeEntrySkip]);

  const handleActiveGoalSelect = useCallback(
    (goalId) => {
      if (!goalId) return;
      triggerHaptic();
      const previousGoalId = activeGoalId || profile.goal;
      clearCompletedPrimaryGoal(previousGoalId);
      setActiveGoalId(goalId);
      setProfile((prev) => ({
        ...prev,
        goal: goalId,
        goalCelebrated: false,
        goalRenewalPending: false,
      }));
      setProfileDraft((prev) => ({
        ...prev,
        goal: goalId,
        goalCelebrated: false,
        goalRenewalPending: false,
      }));
      dismissGoalRenewalPrompt();
    },
    [dismissGoalRenewalPrompt, triggerHaptic, activeGoalId, profile.goal, clearCompletedPrimaryGoal]
  );

  const handleLanguageContinue = () => {
    triggerHaptic();
    if (!termsAccepted) {
      setTermsModalVisible(true);
      setTermsContinuePending(true);
      return;
    }
    goToOnboardingStep("analytics_consent");
  };

  const handleGuideContinue = () => {
    triggerHaptic();
    goToOnboardingStep("persona");
  };

  const updateRegistrationData = (field, value) => {
    if (field === "currency") {
      const raw = typeof value === "string" ? value.trim().toUpperCase() : "";
      const normalized = CURRENCIES.includes(raw) ? raw : DEFAULT_PROFILE.currency;
      setActiveCurrency(normalized);
      setProfile((prev) =>
        prev?.currency === normalized ? prev : { ...prev, currency: normalized }
      );
      setProfileDraft((prev) =>
        prev?.currency === normalized ? prev : { ...prev, currency: normalized }
      );
      triggerWidgetRefresh();
      const currencyEvent = getCurrencySelectedEvent(normalized);
      if (currencyEvent) {
        logEvent(currencyEvent);
      }
      setRegistrationData((prev) => ({ ...prev, [field]: normalized }));
      return;
    }
    if (field === "gender" && onboardingStep !== "done") {
      const genderValue = value || "none";
      const genderEvent = getGenderSelectedEvent(genderValue);
      if (genderEvent) {
        logEvent(genderEvent);
      }
    }
    if (field === "persona" && onboardingStep !== "done") {
      const personaEvent = getPersonaSelectedEvent(value);
      if (personaEvent) {
        logEvent(personaEvent);
      }
    }
    setRegistrationData((prev) => ({ ...prev, [field]: value }));
  };

  const ensurePrimaryGoalWish = useCallback(
    (goalEntries = [], lng, activeGoal = null) => {
      const entries = Array.isArray(goalEntries) ? goalEntries : [];
      const trimmedEntries = entries.filter((entry) => entry?.id);
      const validEntries = trimmedEntries.filter((entry) => {
        const customTitle = typeof entry?.customTitle === "string" ? entry.customTitle.trim() : "";
        return !!customTitle || !!getGoalPreset(entry.id);
      });
      const activeEntry =
        activeGoal && validEntries.length
          ? validEntries.find((entry) => entry?.id === activeGoal)
          : null;
      const orderedEntries = activeEntry
        ? [activeEntry, ...validEntries.filter((entry) => entry?.id !== activeEntry.id)]
        : validEntries;
      if (!orderedEntries.length) return;
      const languageKey = lng || "en";
      const primaryGoalIds = new Set(orderedEntries.map((entry) => entry.id));
      setWishes((prev) => {
        const existingMap = new Map();
        prev.forEach((wish) => {
          if (
            wish.kind === PRIMARY_GOAL_KIND ||
            wish.id === PRIMARY_GOAL_WISH_ID_LEGACY ||
            (typeof wish.id === "string" && wish.id.startsWith("wish_primary_goal_"))
          ) {
            let key = null;
            if (wish.goalId) {
              key = wish.goalId;
            } else if (typeof wish.id === "string" && wish.id.startsWith("wish_primary_goal_")) {
              key = wish.id.replace("wish_primary_goal_", "");
            } else if (wish.id === PRIMARY_GOAL_WISH_ID_LEGACY && activeGoal) {
              key = activeGoal;
            } else {
              key = "legacy";
            }
            const existing = existingMap.get(key);
            if (!existing) {
              existingMap.set(key, wish);
              return;
            }
            const existingSaved = Number(existing.savedUSD) || 0;
            const candidateSaved = Number(wish.savedUSD) || 0;
            const existingIsNew =
              typeof existing.id === "string" && existing.id.startsWith("wish_primary_goal_");
            const candidateIsNew =
              typeof wish.id === "string" && wish.id.startsWith("wish_primary_goal_");
            const shouldReplace =
              candidateSaved > existingSaved ||
              (candidateSaved === existingSaved && candidateIsNew && !existingIsNew);
            if (shouldReplace) {
              existingMap.set(key, wish);
            }
          }
        });
        const nonPrimary = prev.filter(
          (wish) =>
            wish.kind !== PRIMARY_GOAL_KIND &&
            wish.id !== PRIMARY_GOAL_WISH_ID_LEGACY &&
            !(typeof wish.id === "string" && wish.id.startsWith("wish_primary_goal_")) &&
            !primaryGoalIds.has(wish.id)
        );
        const nextPrimary = orderedEntries.map((entry) => {
          const goalPreset = getGoalPreset(entry.id);
          const customTitle = typeof entry?.customTitle === "string" ? entry.customTitle.trim() : "";
          const hasCustomTitle = !!customTitle;
          const customEmoji = entry?.customEmoji
            ? normalizeEmojiValue(entry.customEmoji, DEFAULT_GOAL_EMOJI)
            : null;
          const resolvedEmoji = hasCustomTitle
            ? customEmoji || DEFAULT_GOAL_EMOJI
            : goalPreset?.emoji || DEFAULT_GOAL_EMOJI;
          const presetLabel = goalPreset?.[languageKey] || goalPreset?.en || entry.id;
          const resolvedLabel = hasCustomTitle ? customTitle : presetLabel || entry.id;
          const title = `${resolvedEmoji} ${resolvedLabel}`.trim();
          const targetUSD =
            Number.isFinite(entry.targetUSD) && entry.targetUSD > 0
              ? entry.targetUSD
              : getGoalDefaultTargetUSD(entry.id);
          const existing = existingMap.get(entry.id);
          const entrySavedUSD = Number.isFinite(entry.savedUSD) ? entry.savedUSD : 0;
          const existingSavedUSD = Number.isFinite(existing?.savedUSD) ? existing.savedUSD : 0;
          const nextSavedUSD = Math.max(entrySavedUSD, existingSavedUSD);
          const inferredStatus =
            targetUSD > 0 && nextSavedUSD >= targetUSD
              ? "done"
              : existing?.status && existing.status !== "done"
              ? existing.status
              : entry?.status && entry.status !== "done"
              ? entry.status
              : "active";
          return {
            id: getPrimaryGoalWishId(entry.id),
            templateId: `goal_${entry.id}`,
            title,
            emoji: resolvedEmoji,
            targetUSD,
            savedUSD: nextSavedUSD,
            status: inferredStatus,
            createdAt: existing?.createdAt || entry?.createdAt || Date.now(),
            autoManaged: true,
            kind: PRIMARY_GOAL_KIND,
            goalId: entry.id,
          };
        });
        return [...nextPrimary, ...nonPrimary];
      });
    },
    [setWishes]
  );

  const openImagePickerSheet = (resolver) => {
    imagePickerResolver.current = resolver;
    setShowImageSourceSheet(true);
  };

  const closeImagePickerSheet = () => {
    setShowImageSourceSheet(false);
    imagePickerResolver.current = null;
  };

  const handleImageSourceChoice = async (source) => {
    const resolver = imagePickerResolver.current;
    closeImagePickerSheet();
    if (!resolver) return;
    if (Platform.OS === "ios") {
      // Avoid presenting the picker while the modal sheet is still dismissing.
      await new Promise((resolve) => setTimeout(resolve, 250));
    }
    await pickImage(source, (uri) => {
      if (!uri) return;
      resolver(uri);
    });
  };

  const handlePickImage = () => {
    openImagePickerSheet((uri) =>
      setProfileDraft((prev) => ({
        ...prev,
        avatar: uri,
      }))
    );
  };

  const handleRegistrationPickImage = () => {
    openImagePickerSheet((uri) =>
      setRegistrationData((prev) => ({
        ...prev,
        avatar: uri,
      }))
    );
  };

  const handleRegistrationSubmit = () => {
    if (!registrationData.currency) {
      Alert.alert("Almost", t("currencyLabel"));
      return;
    }
    handleGoalComplete(null);
  };

  const handleCoinSliderMaxUpdate = useCallback((nextUSD) => {
    if (!Number.isFinite(nextUSD) || nextUSD <= 0) return;
    coinSliderMaxOverrideRef.current = nextUSD;
    setCoinSliderMaxUSD(nextUSD);
  }, []);
  const adjustCoinSliderMaxFromEntry = useCallback((amountUSD) => {
    if (!Number.isFinite(amountUSD) || amountUSD <= 0) return;
    const override = coinSliderMaxOverrideRef.current;
    if (Number.isFinite(override) && override > 0) {
      coinSliderMaxOverrideRef.current = null;
    }
    setCoinSliderMaxUSD((prev) => {
      const baseValue = Number.isFinite(override) && override > 0 ? override : prev;
      const currentMax = Number(baseValue) || 0;
      if (!Number.isFinite(currentMax) || currentMax <= 0) return amountUSD;
      const ratio = Math.min(1, amountUSD / currentMax);
      const weight = 0.2 + 0.3 * ratio;
      return currentMax + (amountUSD - currentMax) * weight;
    });
  }, []);
  const openCoinEntry = useCallback(
    (source = "unknown", presetAction = null) => {
      coinEntryContextRef.current = {
        source,
        openedAt: Date.now(),
        submitted: false,
      };
      setCoinEntryPresetAction(presetAction);
      setCoinEntryVisible(true);
      logEvent("coin_entry_opened", { source, preset_action: presetAction || "none" });
    },
    [logEvent]
  );
  const handleCoinEntryClose = useCallback(() => {
    const context = coinEntryContextRef.current;
    if (context?.source) {
      logEvent("coin_entry_closed", {
        source: context.source,
        result: context.submitted ? "submitted" : "dismissed",
        duration_ms: Math.max(0, Date.now() - (context.openedAt || 0)),
      });
    }
    coinEntryContextRef.current = { source: null, openedAt: 0, submitted: false };
    setCoinEntryPresetAction(null);
    setCoinEntryVisible(false);
  }, [logEvent]);

  const handleQuickCustomChange = (field, value) => {
    setQuickSpendDraft((prev) => ({
      ...prev,
      [field]:
        field === "emoji"
          ? limitEmojiInput(value)
          : field === "category"
          ? (IMPULSE_CATEGORY_DEFS[value] ? value : null)
          : field === "frequency"
          ? value === null
            ? null
            : normalizeFrequencyId(value) || prev.frequency
          : field === "customFrequency"
          ? value === null
            ? null
            : normalizeCustomFrequency(value) || prev.customFrequency
          : value,
    }));
  };

  const resolveTemptationCategory = useCallback(
    (item) => {
      if (!item) return DEFAULT_IMPULSE_CATEGORY;
      const override = categoryOverrides[item.id];
      if (override && IMPULSE_CATEGORY_DEFS[override]) {
        return override;
      }
      if (item.impulseCategoryOverride && IMPULSE_CATEGORY_DEFS[item.impulseCategoryOverride]) {
        return item.impulseCategoryOverride;
      }
      if (Array.isArray(item.categories)) {
        const match = IMPULSE_CATEGORY_ORDER.find((slug) => item.categories.includes(slug));
        if (match) return match;
      }
      const inferred = resolveImpulseCategory(item);
      return IMPULSE_CATEGORY_DEFS[inferred] ? inferred : DEFAULT_IMPULSE_CATEGORY;
    },
    [categoryOverrides]
  );

  const shouldPromptCategory = useCallback(
    (item, action, options = {}) => {
      if (options?.skipCategoryPrompt) return false;
      if (action !== "save" && action !== "spend") return false;
      if (!categoryOverridesHydrated) return false;
      if (!isCustomTemptation(item)) return false;
      const templateId = resolveTemptationTemplateId(item);
      if (!templateId) return false;
      const override = categoryOverrides?.[templateId];
      if (override && IMPULSE_CATEGORY_DEFS[override]) return false;
      if (item?.impulseCategoryOverride && IMPULSE_CATEGORY_DEFS[item.impulseCategoryOverride] && !item?.quickTemptation) {
        return false;
      }
      return true;
    },
    [categoryOverrides, categoryOverridesHydrated, resolveTemptationTemplateId]
  );

  const openCategoryPrompt = useCallback(
    (item, action, options = {}) => {
      if (!item) return;
      const inferred = resolveTemptationCategory(item) || DEFAULT_IMPULSE_CATEGORY;
      setCategoryPromptSelection(inferred);
      setCategoryPrompt({ visible: true, item, action, options });
    },
    [resolveTemptationCategory]
  );

  const closeCategoryPrompt = useCallback(() => {
    setCategoryPrompt({ visible: false, item: null, action: null, options: null });
  }, []);

  const showTemptationSoftLimit = useCallback(() => {
    Alert.alert(
      t("temptationSoftLimitTitle"),
      t("temptationSoftLimitMessage", { limit: String(TEMPTATION_SOFT_LIMIT) }),
      [{ text: t("temptationSoftLimitAction"), style: "default" }]
    );
  }, [t]);
  const showTemptationHardLimit = useCallback(() => {
    Alert.alert(
      t("temptationLimitReachedTitle"),
      t("temptationLimitReachedMessage", { limit: String(TEMPTATION_HARD_LIMIT) }),
      [{ text: t("temptationLimitReachedAction"), style: "default" }]
    );
  }, [t]);
  const ensureTemptationCapacity = useCallback(
    ({ showSoft = true } = {}) => {
      if (customTemptationCount >= TEMPTATION_HARD_LIMIT) {
        showTemptationHardLimit();
        return false;
      }
      if (
        showSoft &&
        customTemptationCount >= TEMPTATION_SOFT_LIMIT &&
        !temptationLimitWarningShownRef.current
      ) {
        temptationLimitWarningShownRef.current = true;
        showTemptationSoftLimit();
      }
      return true;
    },
    [customTemptationCount, showTemptationHardLimit, showTemptationSoftLimit]
  );

  const handleQuickCustomSubmit = (customData) => {
    if (!premiumState.isPremium && customTemptationCount >= FREE_CUSTOM_TEMPTATION_LIMIT) {
      ensurePremiumFeatureAccess(PREMIUM_FEATURE_KEYS.customTemptationCards);
      return;
    }
    if (!ensureTemptationCapacity({ showSoft: false })) return;
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    if (!customData.title?.trim()) {
      Alert.alert("Almost", t("quickCustomErrorName"));
      return;
    }
    const parsedAmount = parseNumberInputValue(customData.amount || "");
    if (!Number.isFinite(parsedAmount) || parsedAmount <= 0) {
      Alert.alert("Almost", t("quickCustomErrorAmount"));
      return;
    }
    if (!customData.category || !IMPULSE_CATEGORY_DEFS[customData.category]) {
      Alert.alert("Almost", t("quickCustomErrorCategory"));
      return;
    }
    const resolvedFrequency = normalizeFrequencyId(customData.frequency);
    if (!resolvedFrequency) {
      Alert.alert("Almost", t("quickCustomErrorFrequency"));
      return;
    }
    if (
      resolvedFrequency === "custom" &&
      !normalizeCustomFrequency(customData.customFrequency)
    ) {
      Alert.alert("Almost", t("quickCustomErrorCustomFrequency"));
      return;
    }
    const amountUSD = convertFromCurrency(parsedAmount, currencyCode);
    const manualPrecision = getManualInputPrecision(customData.amount || "");
    const ownerGender = profile.gender || "none";
    const emojiValue = normalizeEmojiValue(customData.emoji, DEFAULT_TEMPTATION_EMOJI);
    const category =
      customData.category && IMPULSE_CATEGORY_DEFS[customData.category]
        ? customData.category
        : DEFAULT_IMPULSE_CATEGORY;
    let frequency = normalizeFrequencyId(customData.frequency) || "daily";
    let frequencyCustom = normalizeCustomFrequency(customData.customFrequency) || null;
    if (frequency === "biweekly") {
      frequency = "custom";
      frequencyCustom = { ...DEFAULT_CUSTOM_FREQUENCY };
    }
    if (frequency === "custom" && !frequencyCustom) {
      frequencyCustom = { ...DEFAULT_CUSTOM_FREQUENCY };
    }
    if (frequency !== "custom") {
      frequencyCustom = null;
    }
    const frequencyIntervalMs = resolveFrequencyIntervalMs(frequency, frequencyCustom);
    const createdAt = Date.now();
    const newCustom = {
      title: customData.title.trim(),
      amountUSD,
      pricePrecision: manualPrecision,
      currency: currencyCode,
      emoji: emojiValue,
      id: customData.id || `custom_habit_${createdAt}`,
      gender: ownerGender,
      impulseCategory: category,
      createdAt,
      frequency,
      frequencyCustom,
      frequencyIntervalMs: frequency === "custom" ? frequencyIntervalMs || null : null,
    };
    const card = createCustomHabitTemptation(newCustom, currencyCode, ownerGender);
    if (card) {
      card.gender = ownerGender;
      card.quickTemptation = true;
      card.frequency = frequency;
      card.frequencyCustom = frequency === "custom" ? frequencyCustom || null : null;
      card.frequencyIntervalMs = frequency === "custom" ? frequencyIntervalMs || null : null;
      setQuickTemptations((prev) => {
        if (prev.length >= TEMPTATION_HARD_LIMIT) return prev;
        return [card, ...prev];
      });
      setCustomTemptationsCreatedCount((prev) => Math.max(0, Number(prev) || 0) + 1);
    }
    applyFrequencySelectionToTemplate(newCustom.id, frequency, frequencyCustom, newCustom.title);
    setCategoryOverrides((prev) => ({ ...prev, [newCustom.id]: category }));
    logEvent("temptation_created", {
      temptation_id: newCustom.id,
      is_custom: true,
      category,
      price: convertToCurrency(amountUSD, currencyCode),
      frequency,
    });
    setQuickSpendDraft({
      title: "",
      amount: "",
      emoji: DEFAULT_TEMPTATION_EMOJI,
      category: null,
      frequency: null,
      customFrequency: null,
    });
    setShowCustomSpend(false);
    triggerOverlayState("custom_temptation", newCustom.title);
  };

  const handleQuickCustomCancel = () => {
    setQuickSpendDraft({
      title: "",
      amount: "",
      emoji: DEFAULT_TEMPTATION_EMOJI,
      category: null,
      frequency: null,
      customFrequency: null,
    });
    setShowCustomSpend(false);
  };
  const [pendingWidgetAction, setPendingWidgetAction] = useState(null);
  const pendingWidgetActionRef = useRef(null);
  const queueWidgetAction = useCallback((action) => {
    if (!action) return;
    pendingWidgetActionRef.current = action;
    setPendingWidgetAction(action);
  }, []);
  const clearWidgetAction = useCallback(() => {
    pendingWidgetActionRef.current = null;
    setPendingWidgetAction(null);
  }, []);

  const handleCoinEntrySubmit = useCallback(
    async ({ amountUSD, category, direction }) => {
      if (!Number.isFinite(amountUSD) || amountUSD <= 0) return;
      if (!category || !IMPULSE_CATEGORY_DEFS[category]) return;
      const action = direction === "save" ? "save" : "spend";
      adjustCoinSliderMaxFromEntry(amountUSD);
      const entryId = `coin_entry_${Date.now()}`;
      const categoryDef = IMPULSE_CATEGORY_DEFS[category];
      const categoryLabelKey = getShortLanguageKey(language);
      const title =
        categoryDef?.[categoryLabelKey] ||
        categoryDef?.en ||
        categoryDef?.ru ||
        categoryDef?.es ||
        categoryDef?.fr ||
        category;
      const virtualItem = {
        id: entryId,
        title,
        emoji: categoryDef.emoji || "âœ¨",
        priceUSD: amountUSD,
        basePriceUSD: amountUSD,
        categories: [category],
        impulseCategoryOverride: category,
      };
      const entryContext = coinEntryContextRef.current || {};
      const entrySource = entryContext.source || "unknown";
      logEvent("coin_entry_submit", {
        source: entrySource,
        direction: action,
        amount_usd: amountUSD,
        category,
      });
      coinEntryContextRef.current = {
        source: entrySource,
        openedAt: entryContext.openedAt || Date.now(),
        submitted: true,
      };
      handleCoinEntryClose();
      if (action === "save") {
        const fallbackGoal =
          activeGoalId ||
          profile.goal ||
          mainGoalWish?.id ||
          (Array.isArray(profile.primaryGoals) ? profile.primaryGoals[0]?.id : null) ||
          getFallbackGoalId();
        await handleTemptationAction("save", virtualItem, {
          skipPrompt: true,
          goalId: fallbackGoal,
          shouldAssign: false,
          forcePrimaryGoal: true,
          forceOverlay: true,
        });
      } else {
        await handleTemptationAction("spend", virtualItem, {
          bypassSpendPrompt: true,
        });
      }
    },
    [
      activeGoalId,
      adjustCoinSliderMaxFromEntry,
      getFallbackGoalId,
      handleCoinEntryClose,
      handleTemptationAction,
      logEvent,
      language,
      mainGoalWish?.id,
      profile.goal,
      profile.primaryGoals,
    ]
  );

  const handleFabNewTemptation = useCallback(() => {
    if (!ensureTemptationCapacity({ showSoft: true })) return;
    triggerHaptic();
    closeFabMenu();
    setQuickSpendDraft({
      title: "",
      amount: "",
      emoji: DEFAULT_TEMPTATION_EMOJI,
      category: null,
      frequency: null,
      customFrequency: null,
    });
    setShowCustomSpend(true);
  }, [closeFabMenu, ensureTemptationCapacity, triggerHaptic]);

  const parseWidgetDeepLink = useCallback((url) => {
    if (!url || typeof url !== "string") return null;
    const normalized = url.trim();
    const parts = normalized.split("://");
    if (parts.length < 2) return null;
    const remainder = parts.slice(1).join("://");
    const [pathPart, queryPart] = remainder.split("?");
    const pathSegments = (pathPart || "").split("/").filter(Boolean);
    const route = (pathSegments[0] || "").toLowerCase();
    const params = {};
    if (queryPart) {
      const searchParams = new URLSearchParams(queryPart);
      searchParams.forEach((value, key) => {
        params[key] = value;
      });
    }
    return { route, params };
  }, []);

  const handleWidgetDeepLink = useCallback(
    (url) => {
      const parsed = parseWidgetDeepLink(url);
      if (!parsed?.route) return;
      if (parsed.route === "home" || parsed.route === "feed") {
        goToTab("feed", { recordHistory: false });
        if (!premiumState.isPremium) {
          ensurePremiumFeatureAccess(PREMIUM_FEATURE_KEYS.homeWidget);
        }
        return;
      }
      if (parsed.route === "add-temptation" || parsed.route === "add") {
        if (!ensurePremiumFeatureAccess(PREMIUM_FEATURE_KEYS.homeWidget)) {
          goToTab("feed", { recordHistory: false });
          return;
        }
        goToTab("feed", { recordHistory: false });
        if (interfaceReady) {
          InteractionManager.runAfterInteractions(() => {
            handleFabNewTemptation();
          });
        } else {
          queueWidgetAction({ type: "add-temptation" });
        }
        return;
      }
      if (parsed.route === "quick-entry" || parsed.route === "quick") {
        if (!ensurePremiumFeatureAccess(PREMIUM_FEATURE_KEYS.homeWidget)) {
          goToTab("feed", { recordHistory: false });
          return;
        }
        const type = typeof parsed.params?.type === "string" ? parsed.params.type.toLowerCase() : "";
        const presetAction = type === "spend" ? "spend" : "save";
        goToTab("feed", { recordHistory: false });
        if (interfaceReady) {
          InteractionManager.runAfterInteractions(() => {
            openCoinEntry(`widget_${presetAction}`, presetAction);
          });
        } else {
          queueWidgetAction({ type: "quick-entry", presetAction });
        }
        return;
      }
      if (parsed.route === "progress" || parsed.route === "cart") {
        goToTab("cart", { recordHistory: false });
      }
    },
    [
      ensurePremiumFeatureAccess,
      goToTab,
      handleFabNewTemptation,
      interfaceReady,
      openCoinEntry,
      parseWidgetDeepLink,
      premiumState.isPremium,
      queueWidgetAction,
    ]
  );

  useEffect(() => {
    const handleUrlEvent = (event) => {
      handleWidgetDeepLink(event?.url);
    };
    const subscription = Linking.addEventListener("url", handleUrlEvent);
    Linking.getInitialURL()
      .then((url) => {
        if (url) {
          handleWidgetDeepLink(url);
        }
      })
      .catch(() => {});
    return () => subscription?.remove?.();
  }, [handleWidgetDeepLink]);

  const handleFabNewGoal = useCallback(() => {
    triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    closeFabMenu();
    openNewGoalModal(false, "fab_menu");
  }, [closeFabMenu, openNewGoalModal, triggerHaptic]);

  const handleNewGoalChange = useCallback((field, value) => {
    setNewGoalModal((prev) => ({
      ...prev,
      [field]: field === "emoji" ? limitEmojiInput(value) : value,
    }));
  }, []);

  const handleNewGoalCancel = useCallback(() => {
    if (newGoalModal.visible) {
      logEvent("goal_creator_cancelled", {
        source: newGoalModal.source || "unknown",
        make_primary: newGoalModal.makePrimary ? 1 : 0,
      });
    }
    setNewGoalModal({
      visible: false,
      name: "",
      target: "",
      emoji: DEFAULT_GOAL_EMOJI,
      makePrimary: false,
      source: "unknown",
    });
  }, [logEvent, newGoalModal]);


  const handleNewGoalSubmit = useCallback(() => {
    const trimmedName = (newGoalModal.name || "").trim();
    if (!trimmedName) {
      Alert.alert("Almost", t("goalEditNameError"));
      return;
    }
    const parsedLocal = parseNumberInputValue(newGoalModal.target);
    if (!Number.isFinite(parsedLocal) || parsedLocal <= 0) {
      Alert.alert("Almost", t("goalEditTargetError"));
      return;
    }
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const targetUSD = convertFromCurrency(parsedLocal, currencyCode);
    const emoji = normalizeEmojiValue(newGoalModal.emoji, DEFAULT_GOAL_EMOJI);
    if (newGoalModal.makePrimary) {
      const goalId = `custom_goal_${Date.now()}`;
      const goalEntry = {
        id: goalId,
        targetUSD,
        customTitle: trimmedName,
        customEmoji: emoji,
        savedUSD: 0,
        status: "active",
        createdAt: Date.now(),
      };
      const existingGoals = Array.isArray(profile.primaryGoals) ? profile.primaryGoals : [];
      const nextPrimaryGoals = [
        goalEntry,
        ...existingGoals.filter((entry) => entry?.id && entry.id !== goalId),
      ];
      const activeTargetUSD = targetUSD > 0 ? targetUSD : getGoalDefaultTargetUSD(goalId);
      setProfile((prev) => ({
        ...prev,
        primaryGoals: nextPrimaryGoals,
        goal: goalId,
        goalTargetUSD: activeTargetUSD,
        goalCelebrated: false,
        goalRenewalPending: false,
      }));
      setProfileDraft((prev) => ({
        ...prev,
        primaryGoals: nextPrimaryGoals,
        goal: goalId,
        goalTargetUSD: activeTargetUSD,
        goalCelebrated: false,
        goalRenewalPending: false,
      }));
      setActiveGoalId(goalId);
      ensurePrimaryGoalWish(nextPrimaryGoals, language, goalId);
      logHistoryEvent("wish_added", {
        title: trimmedName,
        targetUSD,
        templateId: "manual_primary_goal",
        wishId: getPrimaryGoalWishId(goalId),
      });
      logEvent("goal_manual_created", {
        title_hash: hashAnalyticsText(trimmedName),
        target_usd: targetUSD,
        currency: currencyCode,
        is_primary: 1,
      });
      logEvent("goal_created", {
        goal_id: goalId,
        goal_type: resolveGoalTypeFromTarget(targetUSD),
        target_amount: convertToCurrency(targetUSD, currencyCode),
      });
    } else {
      const newWish = {
        id: `wish-manual-${Date.now()}`,
        templateId: null,
        title: trimmedName,
        targetUSD,
        savedUSD: 0,
        status: "active",
        createdAt: Date.now(),
        autoManaged: false,
        emoji,
      };
      setWishes((prev) => insertWishAfterPrimary(prev, newWish));
      ensureActiveGoalForNewWish(newWish);
      logHistoryEvent("wish_added", { title: trimmedName, targetUSD, templateId: "manual_goal", wishId: newWish.id });
      logEvent("goal_manual_created", {
        title_hash: hashAnalyticsText(trimmedName),
        target_usd: targetUSD,
        currency: currencyCode,
      });
      logEvent("goal_created", {
        goal_id: newWish.id,
        goal_type: resolveGoalTypeFromTarget(targetUSD),
        target_amount: convertToCurrency(targetUSD, currencyCode),
      });
    }
    triggerOverlayState("purchase", t("wishAdded", { title: trimmedName }));
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    dismissGoalRenewalPrompt();
    setNewGoalModal({
      visible: false,
      name: "",
      target: "",
      emoji: DEFAULT_GOAL_EMOJI,
      makePrimary: false,
      source: "unknown",
    });
  }, [
    dismissGoalRenewalPrompt,
    ensureActiveGoalForNewWish,
    ensurePrimaryGoalWish,
    language,
    logEvent,
    logHistoryEvent,
    newGoalModal,
    profile.primaryGoals,
    profile.currency,
    setProfile,
    setProfileDraft,
    setWishes,
    t,
    triggerHaptic,
    triggerOverlayState,
  ]);

  const openOnboardingGoalModal = useCallback(() => {
    triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    setOnboardingGoalModal({ visible: true, name: "", target: "", emoji: DEFAULT_GOAL_EMOJI });
  }, [triggerHaptic]);

  const handleOnboardingGoalChange = useCallback((field, value) => {
    setOnboardingGoalModal((prev) => ({
      ...prev,
      [field]: field === "emoji" ? limitEmojiInput(value) : value,
    }));
  }, []);

  const handleOnboardingGoalCancel = useCallback(() => {
    setOnboardingGoalModal({ visible: false, name: "", target: "", emoji: DEFAULT_GOAL_EMOJI });
  }, []);

  const handleOnboardingGoalSubmit = useCallback(() => {
    const trimmedName = (onboardingGoalModal.name || "").trim();
    if (!trimmedName) {
      Alert.alert("Almost", t("goalEditNameError"));
      return;
    }
    const parsedLocal = parseNumberInputValue(onboardingGoalModal.target);
    if (!Number.isFinite(parsedLocal) || parsedLocal <= 0) {
      Alert.alert("Almost", t("goalEditTargetError"));
      return;
    }
    const currencyCode = registrationData.currency || DEFAULT_PROFILE.currency;
    const targetUSD = convertFromCurrency(parsedLocal, currencyCode);
    const emoji = normalizeEmojiValue(onboardingGoalModal.emoji, DEFAULT_GOAL_EMOJI);
    const id = `custom_goal_${Date.now()}`;
    const formattedLocal = formatNumberInputValue(parsedLocal);
    goalSelectionTouchedRef.current = true;
    setRegistrationData((prev) => {
      const selections = prev.goalSelections || [];
      const nextSelections = selections.includes(id) ? selections : [...selections, id];
      return {
        ...prev,
        customGoals: [
          ...(prev.customGoals || []),
          { id, title: trimmedName, emoji, targetUSD, targetLocal: formattedLocal },
        ],
        goalSelections: nextSelections,
        goalTargetMap: {
          ...(prev.goalTargetMap || {}),
          [id]: formattedLocal,
        },
      };
    });
    logEvent("onboarding_goal_custom_created", {
      title_hash: hashAnalyticsText(trimmedName),
      target_usd: targetUSD,
      currency: currencyCode,
    });
    logEvent("goal_created", {
      goal_id: id,
      goal_type: resolveGoalTypeFromTarget(targetUSD),
      target_amount: convertToCurrency(targetUSD, currencyCode),
    });
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    setOnboardingGoalModal({ visible: false, name: "", target: "", emoji: DEFAULT_GOAL_EMOJI });
  }, [onboardingGoalModal, registrationData.currency, setRegistrationData, t, triggerHaptic]);

  const handlePersonaSubmit = () => {
    if (!registrationData.persona) {
      Alert.alert("Almost", t("personaHabitLabel"));
      return;
    }
    triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    goToOnboardingStep("habit");
  };

  const handleCustomSpendSavingsContinue = useCallback(() => {
    setCustomSpendSavingsModal((prev) => ({ ...prev, visible: false }));
    goToOnboardingStep("baseline");
  }, [goToOnboardingStep]);

  const handleHabitSubmit = (skip = false) => {
    let sanitizedFrequency = null;
    if (!skip) {
      if (!registrationData.customSpendTitle.trim()) {
        Alert.alert("Almost", t("customSpendTitle"));
        return;
      }
      const parsed = parseNumberInputValue(registrationData.customSpendAmount || "");
      if (!Number.isFinite(parsed) || parsed <= 0) {
        Alert.alert("Almost", t("customSpendAmountLabel"));
        return;
      }
      const frequencyValue = parseFloat(
        (registrationData.customSpendFrequency || "").replace(",", ".")
      );
      if (!Number.isFinite(frequencyValue) || frequencyValue <= 0) {
        Alert.alert("Almost", t("customSpendFrequencyLabel"));
        return;
      }
      sanitizedFrequency = Math.max(1, Math.round(frequencyValue));
      setRegistrationData((prev) => ({
        ...prev,
        customSpendFrequency: `${sanitizedFrequency}`,
      }));
    } else {
      setRegistrationData((prev) => ({
        ...prev,
        customSpendTitle: "",
        customSpendAmount: "",
        customSpendFrequency: "",
        customSpendCategory: DEFAULT_IMPULSE_CATEGORY,
      }));
    }
    const customAmountLocal = parseNumberInputValue(registrationData.customSpendAmount || "");
    const hasCustom =
      !skip &&
      registrationData.customSpendTitle.trim() &&
      Number.isFinite(customAmountLocal) &&
      customAmountLocal > 0;
    const customAmountUSD = hasCustom
      ? convertFromCurrency(customAmountLocal, registrationData.currency || DEFAULT_PROFILE.currency)
      : 0;
    const frequencyPerWeek = hasCustom ? sanitizedFrequency || 0 : 0;
    logEvent("onboarding_custom_spend", {
      has_custom: !!hasCustom,
      price_usd: customAmountUSD || 0,
      frequency_per_week: frequencyPerWeek,
    });
    triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    if (!skip && hasCustom && Number.isFinite(customAmountLocal) && Number.isFinite(frequencyPerWeek)) {
      const currencyCode = registrationData.currency || DEFAULT_PROFILE.currency;
      const monthlyBase = Math.max(0, customAmountLocal) * Math.max(0, frequencyPerWeek) * CUSTOM_SPEND_MONTHLY_WEEKS;
      if (monthlyBase > 0) {
        const lowEstimate = monthlyBase * CUSTOM_SPEND_SAVINGS_RANGE.low;
        const highEstimate = monthlyBase * CUSTOM_SPEND_SAVINGS_RANGE.high;
        setCustomSpendSavingsModal({
          visible: true,
          title: registrationData.customSpendTitle.trim(),
          lowLabel: formatCurrency(lowEstimate, currencyCode, { friendly: true }),
          highLabel: formatCurrency(highEstimate, currencyCode, { friendly: true }),
        });
        return;
      }
    }
    goToOnboardingStep("baseline");
  };

  const handleBaselineSubmit = () => {
    const currencyCode =
      registrationData.currency || profile.currency || DEFAULT_PROFILE.currency;
    const parsedLocal = parseNumberInputValue(registrationData.baselineMonthlyWaste || "");
    if (!Number.isFinite(parsedLocal) || parsedLocal <= 0) {
      Alert.alert("Almost", t("baselineInputError"));
      return;
    }
    const incomeRaw = (registrationData.incomeMonthlyAmount || "").trim();
    const parsedIncome = incomeRaw ? parseNumberInputValue(incomeRaw) : null;
    if (incomeRaw && (!Number.isFinite(parsedIncome) || parsedIncome <= 0)) {
      Alert.alert("Almost", t("baselineIncomeInputError"));
      return;
    }
    triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    const timestamp = new Date().toISOString();
    setRegistrationData((prev) => ({
      ...prev,
      baselineMonthlyWaste: formatNumberInputValue(parsedLocal),
      baselineCapturedAt: timestamp,
      incomeMonthlyAmount:
        Number.isFinite(parsedIncome) && parsedIncome > 0
          ? formatNumberInputValue(parsedIncome)
          : "",
    }));
    const monthKey = getMonthKey(Date.now());
    setIncomePromptState({ lastPromptMonthKey: monthKey, lastPromptAt: Date.now() });
    if (Number.isFinite(parsedIncome) && parsedIncome > 0) {
      const amountUSD = addIncomeEntry({
        amountText: formatNumberInputValue(parsedIncome),
        receivedAt: Date.now(),
        currencyCode,
      });
      if (Number.isFinite(amountUSD) && amountUSD > 0) {
        logEvent("income_entry_added", {
          source: "onboarding",
          month_key: monthKey,
          amount_usd: amountUSD,
          currency: currencyCode,
        });
      }
    } else {
      logEvent("income_entry_skipped", { source: "onboarding", month_key: monthKey });
    }
    goToOnboardingStep("goal");
  };

  const handleBaselineSkip = () => {
    triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    const monthKey = getMonthKey(Date.now());
    setIncomePromptState({ lastPromptMonthKey: monthKey, lastPromptAt: Date.now() });
    logEvent("income_entry_skipped", { source: "onboarding", month_key: monthKey });
    setRegistrationData((prev) => ({
      ...prev,
      baselineMonthlyWaste: "",
      baselineCapturedAt: null,
      incomeMonthlyAmount: "",
    }));
    goToOnboardingStep("goal");
  };

  const handleBaselineSetupPrompt = () => {
    triggerHaptic();
    if (onboardingStep === "done") {
      openBaselinePrompt();
      return;
    }
    setRegistrationData((prev) => ({
      ...prev,
      currency: profile.currency || prev.currency || DEFAULT_PROFILE.currency,
      baselineMonthlyWaste: "",
      baselineCapturedAt: null,
      incomeMonthlyAmount: prev.incomeMonthlyAmount || "",
    }));
    setOnboardingSkipLocked(true);
    goToOnboardingStep("baseline");
  };

  const handleGoalToggle = (goalId) => {
    triggerHaptic();
    goalSelectionTouchedRef.current = true;
    const currentSelections = registrationData.goalSelections || [];
    const wasSelected = currentSelections.includes(goalId);
    const preset = getGoalPreset(goalId);
    const customGoal = customGoalMap[goalId];
    setRegistrationData((prev) => {
      const selections = prev.goalSelections || [];
      const nextSelections = selections.includes(goalId)
        ? selections.filter((id) => id !== goalId)
        : [...selections, goalId];
      const currencyCode = prev.currency || DEFAULT_PROFILE.currency;
      const nextTargetMap = { ...(prev.goalTargetMap || {}) };
      if (selections.includes(goalId)) {
        delete nextTargetMap[goalId];
      } else {
        let defaultLocal = "";
        if (customGoal?.targetLocal) {
          defaultLocal = customGoal.targetLocal;
        } else if (Number.isFinite(customGoal?.targetUSD) && customGoal.targetUSD > 0) {
          defaultLocal = formatNumberInputValue(
            convertToCurrency(customGoal.targetUSD, currencyCode)
          );
        }
        if (!(goalId in nextTargetMap)) {
          nextTargetMap[goalId] = defaultLocal;
        }
      }
      const confirmed = (prev.goalTargetConfirmed || []).filter((id) => id !== goalId);
      return {
        ...prev,
        goalSelections: nextSelections,
        goalTargetMap: nextTargetMap,
        goalTargetConfirmed: confirmed,
      };
    });
    if (!wasSelected && onboardingStep !== "done") {
      logEvent("onboarding_goal_chosen", {
        goal_id: goalId,
        target_usd: customGoal?.targetUSD || 0,
      });
    }
  };

  const handleGoalTargetSubmit = async () => {
    const selections = registrationData.goalSelections || [];
    if (!selections.length) {
      logEvent("onboarding_goal_skipped", { method: "target_step_empty" });
      setRegistrationData((prev) => ({
        ...prev,
        goalTargetConfirmed: [],
      }));
      goToOnboardingStep("register");
      return;
    }
    const currencyCode = registrationData.currency || DEFAULT_PROFILE.currency;
    const targets = [];
    for (const goalId of selections) {
      const draftValue = registrationData.goalTargetMap?.[goalId];
      const parsedLocal = parseNumberInputValue(draftValue || "");
      if (!Number.isFinite(parsedLocal) || parsedLocal <= 0) {
        Alert.alert("Almost", t("goalTargetError"));
        return;
      }
      targets.push({
        id: goalId,
        usd: convertFromCurrency(parsedLocal, currencyCode),
      });
    }
    setRegistrationData((prev) => ({
      ...prev,
      goalTargetConfirmed: selections.slice(),
    }));
    goToOnboardingStep("register");
  };

  const handleGoalTargetDraftChange = (goalId, value) => {
    setRegistrationData((prev) => ({
      ...prev,
      goalTargetMap: {
        ...(prev.goalTargetMap || {}),
        [goalId]: value,
      },
    }));
  };

  const handleGoalStageContinue = async () => {
    const selections = registrationData.goalSelections || [];
    if (!selections.length) {
      triggerHaptic();
      logEvent("onboarding_goal_skipped", { method: "empty_selection" });
      goToOnboardingStep("register");
      return;
    }
    const currentMap = registrationData.goalTargetMap || {};
    let patchedMap = null;
    let hasInvalidTarget = false;
    let firstInvalidGoalId = null;
    const currencyCode = registrationData.currency || DEFAULT_PROFILE.currency;
    const targets = [];
    for (const goalId of selections) {
      const workingMap = patchedMap || currentMap;
      const draftValue = workingMap[goalId];
      let parsedValue = parseNumberInputValue(draftValue || "");
      if (!Number.isFinite(parsedValue) || parsedValue <= 0) {
        const customGoal = customGoalMap[goalId];
        const fallbackValue = customGoal?.targetLocal || "";
        const fallbackParsed = parseNumberInputValue(fallbackValue || "");
        if (Number.isFinite(fallbackParsed) && fallbackParsed > 0) {
          if (!patchedMap) {
            patchedMap = { ...currentMap };
          }
          patchedMap[goalId] = fallbackValue;
          parsedValue = fallbackParsed;
        }
      }
      if (!Number.isFinite(parsedValue) || parsedValue <= 0) {
        if (!firstInvalidGoalId) {
          firstInvalidGoalId = goalId;
        }
        hasInvalidTarget = true;
        continue;
      }
      targets.push({
        id: goalId,
        usd: convertFromCurrency(parsedValue, currencyCode),
      });
    }
    if (hasInvalidTarget) {
      if (firstInvalidGoalId) {
        goalTargetFocusRef.current?.(firstInvalidGoalId);
      }
      Alert.alert("Almost", t("goalTargetError"));
      return;
    }
    triggerHaptic();
    setRegistrationData((prev) => ({
      ...prev,
      goalTargetMap: patchedMap
        ? {
            ...(prev.goalTargetMap || {}),
            ...patchedMap,
          }
        : prev.goalTargetMap || {},
      goalTargetConfirmed: selections.slice(),
    }));
    goToOnboardingStep("register");
  };
  const handleGoalStageSkip = async () => {
    triggerHaptic();
    logEvent("onboarding_goal_skipped", { method: "skip_button" });
    goalSelectionTouchedRef.current = false;
    setRegistrationData((prev) => ({
      ...prev,
      goalSelections: [],
      goalTargetMap: {},
      goalTargetConfirmed: [],
    }));
    goToOnboardingStep("register");
  };

  const handleGoalComplete = async (targetsOverride = null) => {
    const selections = registrationData.goalSelections || [];
    const currencyCode = registrationData.currency || DEFAULT_PROFILE.currency;
    const isValidGoalSelection = (goalId) => {
      if (!goalId) return false;
      if (getGoalPreset(goalId)) return true;
      const customGoal = customGoalMap[goalId];
      const customTitle = typeof customGoal?.title === "string" ? customGoal.title.trim() : "";
      return !!customTitle;
    };
    const dedupeTargetsById = (list = []) => {
      const map = new Map();
      list.forEach((entry) => {
        if (entry?.id && !map.has(entry.id)) {
          map.set(entry.id, entry);
        }
      });
      return Array.from(map.values());
    };
    let targets = [];
    if (Array.isArray(targetsOverride)) {
      targets = targetsOverride.filter((entry) => isValidGoalSelection(entry?.id));
    } else if (selections.length) {
      targets = selections.map((goalId) => {
        if (!isValidGoalSelection(goalId)) return null;
        const draftValue = registrationData.goalTargetMap?.[goalId];
        const parsedLocal = parseNumberInputValue(draftValue || "");
        const usd = Number.isFinite(parsedLocal) && parsedLocal > 0
          ? convertFromCurrency(parsedLocal, currencyCode)
          : getGoalDefaultTargetUSD(goalId);
        return { id: goalId, usd };
      }).filter(Boolean);
    }
    targets = dedupeTargetsById(targets).filter((entry) => isValidGoalSelection(entry?.id));
    const primaryGoals = targets.map((entry) => {
      const goalId = entry.id;
      const targetUSD = entry.usd > 0 ? entry.usd : getGoalDefaultTargetUSD(goalId);
      const customGoal = customGoalMap[goalId];
      const customTitle = typeof customGoal?.title === "string" ? customGoal.title.trim() : "";
      const base = {
        id: goalId,
        targetUSD,
        savedUSD: 0,
        status: "active",
        createdAt: Date.now(),
      };
      if (customTitle) {
        base.customTitle = customTitle;
      }
      if (customGoal?.emoji) {
        base.customEmoji = normalizeEmojiValue(customGoal.emoji, DEFAULT_GOAL_EMOJI);
      }
      return base;
    });
    const hasPrimaryGoal = primaryGoals.length > 0;
    const activeGoalTargetUSD =
      hasPrimaryGoal && Number.isFinite(primaryGoals[0]?.targetUSD) && primaryGoals[0].targetUSD > 0
        ? primaryGoals[0].targetUSD
        : 0;
    const firstNameValue = (registrationData.firstName || "").trim();
    const lastNameValue = (registrationData.lastName || "").trim();
    const mottoValue = (registrationData.motto || "").trim();
    const displayName = `${firstNameValue} ${lastNameValue}`.trim() || firstNameValue || "";
    const personaId = registrationData.persona || DEFAULT_PERSONA_ID;
    const gender = registrationData.gender || "none";
    logEvent("onboarding_profile_fields", {
      first_name_entered: firstNameValue.length > 0,
      last_name_entered: lastNameValue.length > 0,
      motto_entered: mottoValue.length > 0,
    });
    let customSpend = null;
    const customName = registrationData.customSpendTitle?.trim();
    const customAmount = parseNumberInputValue(registrationData.customSpendAmount || "");
    const customFrequency = parseFloat(
      (registrationData.customSpendFrequency || "").replace(",", ".")
    );
    if (customName && Number.isFinite(customAmount) && customAmount > 0) {
      const amountUSD = convertFromCurrency(customAmount, registrationData.currency);
      const manualPrecision = getManualInputPrecision(registrationData.customSpendAmount || "");
      const categoryValue =
        registrationData.customSpendCategory && IMPULSE_CATEGORY_DEFS[registrationData.customSpendCategory]
          ? registrationData.customSpendCategory
          : DEFAULT_IMPULSE_CATEGORY;
      customSpend = {
        title: customName,
        amountUSD,
        pricePrecision: manualPrecision,
        currency: registrationData.currency,
        frequencyPerWeek:
          Number.isFinite(customFrequency) && customFrequency > 0
            ? Math.round(customFrequency)
            : 0,
        impulseCategory: categoryValue,
        createdAt: Date.now(),
      };
      logEvent("temptation_created", {
        temptation_id: profile.customSpend?.id || "custom_habit",
        is_custom: true,
        category: categoryValue,
        price: customAmount,
      });
    }
    if (customSpend) {
      schedulePrimaryTemptationPrompt();
    } else {
      markPrimaryTemptationPromptDone();
    }
    let spendingProfile = profile.spendingProfile || { ...DEFAULT_PROFILE.spendingProfile };
    const baselineLocal = parseNumberInputValue(registrationData.baselineMonthlyWaste || "");
    if (Number.isFinite(baselineLocal) && baselineLocal > 0) {
      spendingProfile = {
        ...spendingProfile,
        baselineMonthlyWasteUSD: convertFromCurrency(baselineLocal, currencyCode),
        baselineStartAt: registrationData.baselineCapturedAt || new Date().toISOString(),
      };
    }
    const updatedProfile = {
      ...profile,
      name: displayName,
      firstName: registrationData.firstName,
      lastName: registrationData.lastName,
      subtitle: mottoValue || profile.subtitle,
      motto: mottoValue || profile.motto,
      avatar: registrationData.avatar || profile.avatar,
      currency: registrationData.currency,
      goal: hasPrimaryGoal ? primaryGoals[0]?.id : null,
      primaryGoals,
      goalTargetUSD: activeGoalTargetUSD,
      goalCelebrated: false,
      persona: personaId,
      gender,
      customSpend,
      spendingProfile,
      joinedAt: profile.joinedAt || new Date().toISOString(),
      goalRenewalPending: false,
    };
    setProfile(updatedProfile);
    setProfileDraft(updatedProfile);
    setActiveGoalId(updatedProfile.goal);
    await AsyncStorage.setItem(STORAGE_KEYS.PROFILE, JSON.stringify(updatedProfile)).catch(() => {});
    await AsyncStorage.setItem(STORAGE_KEYS.ONBOARDING, "done").catch(() => {});
    setSavedTotalUSD(0);
    setLifetimeSavedUSD(0);
    setProgressSavedTotalUSD(0);
    setProgressLifetimeSavedUSD(0);
    setLevelProgressOffsetUSD(0);
    tutorialLevelOffsetAppliedRef.current = false;
    setLastCelebratedLevel(1);
    previousPlayerLevelRef.current = 1;
    setHistoryEvents([]);
    setDeclineCount(0);
    setDecisionStats({ ...INITIAL_DECISION_STATS });
    setRefuseStats({});
    AsyncStorage.multiSet([
      [STORAGE_KEYS.SAVED_TOTAL, "0"],
      [STORAGE_KEYS.SAVED_TOTAL_PEAK, "0"],
      [STORAGE_KEYS.SAVED_TOTAL_PROGRESS, "0"],
      [STORAGE_KEYS.SAVED_TOTAL_PROGRESS_PEAK, "0"],
      [STORAGE_KEYS.LEVEL_PROGRESS_OFFSET, "0"],
      [STORAGE_KEYS.LAST_CELEBRATED_LEVEL, "1"],
      [STORAGE_KEYS.HISTORY, "[]"],
      [STORAGE_KEYS.DECLINES, "0"],
      [STORAGE_KEYS.DECISION_STATS, JSON.stringify({ ...INITIAL_DECISION_STATS })],
      [STORAGE_KEYS.REFUSE_STATS, "{}"],
    ]).catch(() => {});
    await AsyncStorage.setItem(STORAGE_KEYS.TUTORIAL, "pending").catch(() => {});
    await AsyncStorage.setItem(STORAGE_KEYS.TEMPTATION_TUTORIAL, "pending").catch(() => {});
    setTutorialSeen(false);
    setTemptationTutorialSeen(false);
    setTemptationTutorialStatus("pending");
    setTemptationTutorialVisible(false);
    setTemptationTutorialStepIndex(0);
    setTemptationTutorialQueued(true);
    setTemptationTutorialCompleted(false);
    setFabTutorialVisible(false);
    setFabTutorialStateAndPersist(FAB_TUTORIAL_STATUS.PENDING);
    setFabTutorialEligible(false);
    homeSessionRef.current.sessionCount = 0;
    homeSessionRef.current.pendingIndex = null;
    homeSessionRef.current.dateKey = getDayKey(Date.now());
    setActiveCurrency(updatedProfile.currency);
    ensurePrimaryGoalWish(primaryGoals, language, updatedProfile.goal);
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    const startBalanceLocal = convertToCurrency(
      savedTotalUSD || 0,
      updatedProfile.currency || DEFAULT_PROFILE.currency
    );
    logEvent("onboarding_completed", {
      persona_id: personaId,
      goal_id: primaryGoals[0]?.id || "none",
      has_goal: hasPrimaryGoal,
      start_balance: startBalanceLocal,
      skipped: onboardingSkippedRef.current ? 1 : 0,
    });
    setTimeout(() => {
      if (analyticsOptOut === null) {
        analyticsConsentGateRef.current = true;
        goToOnboardingStep("analytics_consent", { recordHistory: false, resetHistory: true });
      } else {
        goToOnboardingStep("push_optin", { recordHistory: false, resetHistory: true });
      }
      setRegistrationData(INITIAL_REGISTRATION);
      goalSelectionTouchedRef.current = false;
      onboardingSkippedRef.current = false;
    }, 500);
  };

  const requestTrackingTransparencyIfNeeded = useCallback(async () => {
    if (Platform.OS !== "ios") return null;
    if (!TrackingTransparency) return null;
    const getter = TrackingTransparency.getTrackingPermissionsAsync;
    const requester = TrackingTransparency.requestTrackingPermissionsAsync;
    if (typeof getter !== "function" || typeof requester !== "function") return null;
    try {
      const current = await getter();
      const status = current?.status;
      if (status && status !== "undetermined" && status !== "not-determined") {
        setIosTrackingStatus(status || null);
        setIosTrackingResolved(true);
        return status;
      }
      const result = await requester();
      const nextStatus = result?.status || status || null;
      setIosTrackingStatus(nextStatus);
      setIosTrackingResolved(true);
      return nextStatus;
    } catch (error) {
      console.warn("tracking transparency", error);
      setIosTrackingResolved(true);
      return null;
    }
  }, []);

  const handleAnalyticsConsentComplete = async (allowAnalytics) => {
    markStartupLogoDismissed();
    const trackingStatus = await requestTrackingTransparencyIfNeeded();
    const trackingBlocked = Platform.OS === "ios" && isTrackingStatusBlocked(trackingStatus);
    const optOut = !allowAnalytics || trackingBlocked;
    setAnalyticsOptOutState(optOut);
    setAnalyticsOptOutFlag(optOut);
    AsyncStorage.setItem(
      STORAGE_KEYS.ANALYTICS_OPT_OUT,
      optOut ? "1" : "0"
    ).catch(() => {});
    if (!optOut) {
      logEvent("consent_analytics_enabled", { enabled: allowAnalytics, source: "onboarding" });
    }
    if (analyticsConsentGateRef.current) {
      analyticsConsentGateRef.current = false;
      goToOnboardingStep("push_optin", { recordHistory: false, resetHistory: true });
      return;
    }
    goToOnboardingStep("guide");
  };

  const handleOnboardingNotificationsContinue = async () => {
    triggerHaptic();
    await ensureNotificationPermission();
    goToOnboardingStep("done", { recordHistory: false, resetHistory: true });
  };

  const handleOnboardingSkip = useCallback(async () => {
    if (!canShowOnboardingSkip) return;
    Alert.alert(
      t("onboardingSkipConfirmTitle"),
      t("onboardingSkipConfirmBody"),
      [
        { text: t("onboardingSkipConfirmCancel"), style: "cancel" },
        {
          text: t("onboardingSkipConfirmConfirm"),
          style: "destructive",
          onPress: async () => {
            onboardingSkippedRef.current = true;
            logEvent("onboarding_skipped", { from_step: onboardingStep });
            await handleGoalComplete(null);
          },
        },
      ]
    );
  }, [canShowOnboardingSkip, handleGoalComplete, logEvent, onboardingStep, t]);

  const ensureMediaPermission = async (type) => {
    if (type === "library" && Platform.OS === "android") {
      return true;
    }
    const getter =
      type === "camera"
        ? ImagePicker.getCameraPermissionsAsync
        : ImagePicker.getMediaLibraryPermissionsAsync;
    const requester =
      type === "camera"
        ? ImagePicker.requestCameraPermissionsAsync
        : ImagePicker.requestMediaLibraryPermissionsAsync;

    const current = await getter();
    if (current?.granted) return true;
    const requestResult = await requester();
    if (requestResult?.granted) return true;

    Alert.alert(
      "Almost",
      requestResult?.canAskAgain ? t("photoPermissionDenied") : t("photoPermissionSettings"),
      [
        {
          text: t("profileCancel"),
          style: "cancel",
        },
        !requestResult?.canAskAgain
          ? {
              text: t("openSettings"),
              onPress: () => Linking.openSettings?.(),
            }
          : null,
      ].filter(Boolean)
    );
    return false;
  };

  const persistAvatarUri = useCallback(async (uri, fileName) => {
    if (!uri || typeof uri !== "string") return uri;
    const documentDir = FileSystem.documentDirectory;
    if (!documentDir) return uri;
    if (uri.startsWith(documentDir)) return normalizeAvatarStorageValue(uri);
    const isFileUri = uri.startsWith("file://");
    const isContentUri = uri.startsWith("content://");
    if (!isFileUri && !isContentUri) return uri;
    if (isFileUri) {
      const fileInfo = await FileSystem.getInfoAsync(uri).catch(() => null);
      if (!fileInfo?.exists) return uri;
    }
    const targetDir = `${documentDir}${AVATAR_STORAGE_DIR}`;
    await FileSystem.makeDirectoryAsync(targetDir, { intermediates: true }).catch(() => {});
    const cleanedUri = uri.split("?")[0];
    const cleanedName = typeof fileName === "string" ? fileName.split("?")[0] : "";
    const fileNameMatch = cleanedName.match(/\.([a-zA-Z0-9]+)$/);
    const extensionMatch = cleanedUri.match(/\.([a-zA-Z0-9]+)$/);
    const extension = (fileNameMatch?.[1] || extensionMatch?.[1] || "jpg").toLowerCase();
    const generatedName = `avatar-${Date.now()}-${Math.random().toString(16).slice(2)}.${extension}`;
    const targetUri = `${targetDir}${generatedName}`;
    const storedValue = `${AVATAR_STORAGE_DIR}${generatedName}`;
    try {
      await FileSystem.copyAsync({ from: uri, to: targetUri });
      return storedValue;
    } catch (error) {
      try {
        const base64 = await FileSystem.readAsStringAsync(uri, {
          encoding: FileSystem.EncodingType.Base64,
        });
        await FileSystem.writeAsStringAsync(targetUri, base64, {
          encoding: FileSystem.EncodingType.Base64,
        });
        return storedValue;
      } catch (fallbackError) {
        console.warn("avatar persist", error);
        console.warn("avatar persist fallback", fallbackError);
        return uri;
      }
    }
  }, []);

  useEffect(() => {
    if (!profileHydrated) return;
    let cancelled = false;
    const migrateAvatar = async () => {
      const currentAvatar = profile?.avatar;
      if (!currentAvatar || typeof currentAvatar !== "string") return;
      const normalizedAvatar = normalizeAvatarStorageValue(currentAvatar);
      if (normalizedAvatar !== currentAvatar) {
        if (cancelled) return;
        setProfile((prev) => (prev?.avatar === currentAvatar ? { ...prev, avatar: normalizedAvatar } : prev));
        setProfileDraft((prev) =>
          prev?.avatar === currentAvatar ? { ...prev, avatar: normalizedAvatar } : prev
        );
        setRegistrationData((prev) =>
          prev?.avatar === currentAvatar ? { ...prev, avatar: normalizedAvatar } : prev
        );
        return;
      }
      const resolvedUri = resolveAvatarUri(normalizedAvatar);
      if (!resolvedUri) return;
      const documentDir = FileSystem.documentDirectory;
      if (!documentDir || resolvedUri.startsWith(documentDir)) return;
      if (!resolvedUri.startsWith("file://") && !resolvedUri.startsWith("content://")) return;
      if (resolvedUri.startsWith("file://")) {
        const info = await FileSystem.getInfoAsync(resolvedUri).catch(() => null);
        if (!info?.exists) return;
      }
      const persistedValue = await persistAvatarUri(resolvedUri);
      if (!persistedValue || persistedValue === normalizedAvatar || cancelled) return;
      setProfile((prev) => (prev?.avatar === currentAvatar ? { ...prev, avatar: persistedValue } : prev));
      setProfileDraft((prev) => (prev?.avatar === currentAvatar ? { ...prev, avatar: persistedValue } : prev));
      setRegistrationData((prev) =>
        prev?.avatar === currentAvatar ? { ...prev, avatar: persistedValue } : prev
      );
    };
    migrateAvatar();
    return () => {
      cancelled = true;
    };
  }, [profileHydrated, profile?.avatar, persistAvatarUri]);

  const pickImage = async (source = "library", onPicked) => {
    try {
      triggerHaptic();
      const type = source === "camera" ? "camera" : "library";
      const permitted = await ensureMediaPermission(type);
      if (!permitted) return;
      const pickerOptions = {
        mediaTypes: ["images"],
        quality: 0.8,
        ...(SHOULD_USE_ANDROID_LEGACY_MEDIA_PICKER ? { legacy: true } : {}),
      };
      const result =
        source === "camera"
          ? await ImagePicker.launchCameraAsync(pickerOptions)
          : await ImagePicker.launchImageLibraryAsync(pickerOptions);
      if (!result.canceled && result.assets?.length) {
        const asset = result.assets[0];
        const persistedUri = await persistAvatarUri(asset.uri, asset.fileName);
        onPicked?.(persistedUri);
      }
    } catch (error) {
      const errorMessage =
        error?.message && error.message.includes("canceled")
          ? null
          : `${t("photoPickerError")}\n${error?.message || ""}`.trim();
      if (errorMessage) {
        Alert.alert("Almost", errorMessage);
      }
      console.warn("image picker", error);
    }
  };

  const registerSmartReminder = useCallback(
    async (entry) => {
      if (!entry) return;
      if (!["refuse_spend", "pending_to_decline", "spend"].includes(entry.kind)) return;
      const rawTimestamp = Number(entry.timestamp);
      const timestamp = Number.isFinite(rawTimestamp) ? rawTimestamp : Date.now();
      const now = Date.now();
      if (now - timestamp > RECENT_EVENT_NOTIFICATION_WINDOW_MS) return;
      const baseTriggerTime = timestamp + SMART_REMINDER_DELAY_MS;
      if (!Number.isFinite(baseTriggerTime) || baseTriggerTime <= now) return;
      // Space reminders so Android does not deliver multiple notifications at once.
      const futureReminders = (smartRemindersRef.current || []).filter((reminder) => {
        const scheduledAt = Number(reminder?.scheduledAt);
        return Number.isFinite(scheduledAt) && scheduledAt > now;
      });
      const lastScheduledFromState = futureReminders.reduce(
        (latest, reminder) => Math.max(latest, Number(reminder.scheduledAt) || 0),
        0
      );
      const inferredTail =
        smartReminderScheduleTailRef.current > now ? smartReminderScheduleTailRef.current : 0;
      const lastScheduledAt = Math.max(lastScheduledFromState, inferredTail);
      const triggerTime =
        lastScheduledAt > 0
          ? Math.max(baseTriggerTime, lastScheduledAt + SMART_REMINDER_MIN_INTERVAL_MS)
          : baseTriggerTime;
      const permitted = await ensureNotificationPermission({ request: false });
      if (!permitted) return;
      const templateId = entry.meta?.templateId || entry.meta?.id || entry.meta?.template_id;
      if (!templateId || !isTemplateReminderEligible(templateId)) return;
      let categoryId =
        entry?.meta?.category || entry?.meta?.impulseCategory || entry?.meta?.impulseCategoryOverride || null;
      if (!categoryId && templateId && typeof resolveTemptationCategory === "function") {
        const template = findTemplateById(templateId);
        if (template) {
          categoryId = resolveTemptationCategory(template);
        }
      }
      if (isEssentialImpulseCategory(categoryId)) return;
      const metaTitle =
        (typeof entry.meta?.title === "string" && entry.meta.title.trim()) ||
        resolveTemplateTitle(templateId, "") ||
        "";
      const title = metaTitle || t("defaultDealTitle");
      const isSpendEvent = entry.kind === "spend";
      const normalizedLanguage = normalizeLanguage(language);
      const dayLabel =
        formatRelativeDayLabel(timestamp, triggerTime, normalizedLanguage) ||
        formatRelativeDayLabel(timestamp, now, normalizedLanguage) ||
        (normalizedLanguage === "ru"
          ? "Ð²Ñ‡ÐµÑ€Ð°"
          : normalizedLanguage === "es"
          ? "ayer"
          : normalizedLanguage === "fr"
          ? "hier"
          : "yesterday");
      const dedupeKey = `smart:${entry.id || timestamp}`;
      try {
        const scheduledEntry = await scheduleNotificationWithCooldown({
          content: {
            title: isSpendEvent
              ? t("smartInsightSpendTitle", { temptation: title, dayLabel })
              : t("smartInsightDeclineTitle", { temptation: title, dayLabel }),
            body: isSpendEvent
              ? t("smartInsightSpendBody", { temptation: title })
            : t("smartInsightDeclineBody", { temptation: title }),
            data: {
              kind: "smart_insight",
              templateId: templateId || null,
              eventTimestamp: timestamp,
              dedupeKey,
            },
          },
          trigger: new Date(triggerTime),
        });
        const notificationId = scheduledEntry?.id || null;
        const scheduledFor = Number(scheduledEntry?.scheduledFor) || triggerTime;
        if (notificationId) {
          smartReminderScheduleTailRef.current = scheduledFor;
          const payload = {
            id: `smart-${entry.id}`,
            eventId: entry.id,
            kind: entry.kind,
            title,
            timestamp,
            scheduledAt: scheduledFor,
            notificationId,
            templateId: templateId || null,
          };
          setSmartReminders((prev) => normalizeSmartReminderEntries([payload, ...prev]));
        }
      } catch (error) {
        console.warn("smart reminder schedule", error);
      }
    },
    [
      ensureNotificationPermission,
      isTemplateReminderEligible,
      language,
      resolveTemptationCategory,
      resolveTemplateTitle,
      scheduleNotificationWithCooldown,
      setSmartReminders,
      t,
    ]
  );

  const cancelSameDaySmartReminders = useCallback(
    async (templateId, dayKey) => {
      if (!templateId || !dayKey) return;
      const reminders = Array.isArray(smartRemindersRef.current) ? smartRemindersRef.current : [];
      const keep = [];
      const toCancel = [];
      reminders.forEach((reminder) => {
        const reminderDay =
          reminder?.scheduledAt && Number.isFinite(reminder.scheduledAt)
            ? getDayKey(reminder.scheduledAt)
            : null;
        if (reminder?.templateId === templateId && reminderDay === dayKey) {
          if (reminder.notificationId) {
            toCancel.push(reminder.notificationId);
          }
        } else {
          keep.push(reminder);
        }
      });
      if (toCancel.length) {
        await Promise.all(
          toCancel.map((id) => safeNotifications.cancelScheduledNotificationAsync(id))
        );
      }
      if (toCancel.length) {
        setSmartReminders(normalizeSmartReminderEntries(keep));
      }
    },
    [setSmartReminders]
  );

  const logHistoryEvent = useCallback(
    (kind, meta = {}) => {
      const timestamp = Date.now();
      const templateId =
        meta?.templateId || meta?.template_id || meta?.id || meta?.template || meta?.templateId;
      const dayKey = getDayKey(timestamp);
      if (templateId) {
        cancelSameDaySmartReminders(templateId, dayKey);
      }
      const normalizedMeta =
        templateId && !meta.templateId && !meta.template_id ? { ...meta, templateId } : meta;
      const entry = {
        id: `history-${timestamp}-${Math.random().toString(16).slice(2, 6)}`,
        kind,
        meta: normalizedMeta,
        timestamp,
      };
      setHistoryEvents((prev) => {
        const next = [entry, ...prev].filter((item) => {
          if (!item?.timestamp) return false;
          return timestamp - item.timestamp <= HISTORY_RETENTION_MS;
        });
        return next.slice(0, MAX_HISTORY_EVENTS);
      });
      setChallengesState((prev) => applyChallengeEvent(prev, entry));
      registerSmartReminder(entry);
    },
    [cancelSameDaySmartReminders, registerSmartReminder, setChallengesState]
  );

  const registerUsageStreakAction = useCallback((actionType = "save", timestamp = Date.now()) => {
    const dayKey = getDayKey(timestamp);
    if (!dayKey) return;
    const normalizedAction = actionType === "spend" ? "spend" : "save";
    const prev = usageStreakRef.current || INITIAL_USAGE_STREAK;
    const lastDate = prev?.lastDate || null;
    if (lastDate === dayKey) return;
    const yesterdayKey = getDayKey(timestamp - DAY_MS);
    const previousCount = Math.max(0, Number(prev?.current) || 0);
    const prevLostCount = Math.max(0, Number(prev?.lostCount) || 0);
    const lossCount = previousCount > 0 ? previousCount : prevLostCount;
    const missed = Boolean(lastDate && lastDate !== yesterdayKey && lossCount > 0);
    const continues = lastDate === yesterdayKey;
    const nextCurrent = continues ? Math.max(1, previousCount + 1) : 1;
    const nextBest = Math.max(prev.best || 0, nextCurrent);
    const nextTotal = Math.max(0, prev.total || 0) + 1;
    const nextSnapshot = {
      ...prev,
      current: nextCurrent,
      best: nextBest,
      total: nextTotal,
      lastDate: dayKey,
      lostCount: missed ? lossCount : 0,
    };
    const weeklyReward = computeUsageStreakWeeklyBonus(nextSnapshot.current);
    if (weeklyReward) {
      setHealthPoints((prevPoints) => prevPoints + weeklyReward.rewardValue);
      logEvent("usage_streak_weekly_reward", {
        current_streak: nextSnapshot.current,
        reward_blue: weeklyReward.rewardBlueCoins,
        reward_value: weeklyReward.rewardValue,
        week_index: weeklyReward.weekIndex,
      });
    }
    usageStreakRef.current = nextSnapshot;
    setUsageStreak(nextSnapshot);
    usageStreakBackfillRef.current = false;
    const streakEndDayKey =
      missed && typeof lastDate === "string" && lastDate ? lastDate : nextSnapshot.lastDate;
    const missedDayKey =
      missed && streakEndDayKey
        ? getDayKey((parseDayKey(streakEndDayKey)?.getTime() || timestamp) + DAY_MS)
        : null;
    const missedDays = missed ? getMissedUsageStreakDays(streakEndDayKey, dayKey) : 0;
    const streakPayload = {
      count: nextSnapshot.current,
      dayKey: nextSnapshot.lastDate,
      streakEndDayKey,
      timestamp,
      missed,
      previousCount,
      missedDayKey,
      missedDays,
      lostCount: lossCount,
    };
    if (weeklyReward) {
      streakPayload.weeklyReward = weeklyReward;
    }
    pendingUsageStreakRef.current = {
      source: normalizedAction,
      payload: streakPayload,
    };
    logEvent("usage_streak_logged", {
      current_streak: nextSnapshot.current,
      previous_streak: previousCount,
      best_streak: nextSnapshot.best,
      total: nextSnapshot.total,
      action: normalizedAction,
      missed: missed ? 1 : 0,
    });
  }, [logEvent, setHealthPoints]);

  const promptIncomeSavingsTransfer = useCallback(
    (amountUSD = 0) => {
      const depositUSD = Math.max(0, Number(amountUSD) || 0) * INCOME_SAVINGS_SHARE;
      if (!Number.isFinite(depositUSD) || depositUSD <= 0) return;
      const percent = Math.round(INCOME_SAVINGS_SHARE * 100);
      const amountLabel = formatLocalIncomeAmount(depositUSD);
      Alert.alert(
        t("incomeSavingsPromptTitle"),
        t("incomeSavingsPromptMessage", { amount: amountLabel, percent }),
        [
          {
            text: t("incomeSavingsPromptSkip"),
            style: "cancel",
            onPress: () => {
              logEvent("income_savings_skipped", {
                amount_usd: depositUSD,
                percent,
                reason: "prompt_skip",
              });
            },
          },
          {
            text: t("incomeSavingsPromptConfirm"),
            style: "default",
            onPress: () => {
              Alert.alert(
                t("incomeSavingsConfirmTitle"),
                t("incomeSavingsConfirmMessage", { amount: amountLabel }),
                [
                  {
                    text: t("incomeSavingsConfirmCancel"),
                    style: "cancel",
                    onPress: () => {
                      logEvent("income_savings_skipped", {
                        amount_usd: depositUSD,
                        percent,
                        reason: "confirm_cancel",
                      });
                    },
                  },
                  {
                    text: t("incomeSavingsConfirmYes"),
                    style: "default",
                    onPress: () => {
                      setSavedTotalUSD((prev) => Math.max(0, prev + depositUSD));
                      logHistoryEvent("income_savings", { amountUSD: depositUSD });
                      logEvent("income_savings_confirmed", { amount_usd: depositUSD, percent });
                      triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
                    },
                  },
                ]
              );
            },
          },
        ]
      );
    },
    [formatLocalIncomeAmount, logEvent, logHistoryEvent, setSavedTotalUSD, t]
  );

  const handleIncomeEntrySubmit = useCallback(() => {
    const entryType = incomeEntryModeRef.current || INCOME_ENTRY_TYPES.MONTHLY;
    const amountUSD = addIncomeEntry({
      amountText: incomeEntryInput.amount,
      receivedAt: Date.now(),
      entryType,
    });
    if (!Number.isFinite(amountUSD) || amountUSD <= 0) return;
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const monthKey = getMonthKey(Date.now());
    setIncomeEntryModalVisible(false);
    if (entryType === INCOME_ENTRY_TYPES.MONTHLY) {
      setIncomePromptState({ lastPromptMonthKey: monthKey, lastPromptAt: Date.now() });
      setIncomePromptPending(false);
      clearQueuedModal(QUEUED_MODAL_TYPES.INCOME_PROMPT);
    }
    logEvent("income_entry_added", {
      source: incomeEntrySourceRef.current || "manual",
      month_key: monthKey,
      amount_usd: amountUSD,
      currency: currencyCode,
      entry_type: entryType,
    });
    promptIncomeSavingsTransfer(amountUSD);
  }, [
    addIncomeEntry,
    incomeEntryInput.amount,
    clearQueuedModal,
    logEvent,
    profile.currency,
    promptIncomeSavingsTransfer,
  ]);

  const recomputeHistoryAggregates = useCallback(
    (list) => {
      let nextDeclines = 0;
      let resolvedToWishes = 0;
      let resolvedToDeclines = 0;
      const nextRefuseStats = {};
      (list || []).forEach((entry) => {
        if (!entry) return;
        if (entry.kind === "refuse_spend") {
          const amount = Math.max(0, Number(entry.meta?.amountUSD) || 0);
          nextDeclines += 1;
          const templateId =
            entry.meta?.templateId || entry.meta?.id || entry.meta?.title || "unknown";
          const current = nextRefuseStats[templateId] || {
            count: 0,
            totalUSD: 0,
            lastSavedAt: 0,
            lastSavedAmountUSD: 0,
          };
          current.count += 1;
          current.totalUSD += amount;
          if (!current.lastSavedAt || (entry.timestamp || 0) > current.lastSavedAt) {
            current.lastSavedAt = entry.timestamp || 0;
            current.lastSavedAmountUSD = amount;
          }
          nextRefuseStats[templateId] = current;
        } else if (entry.kind === "pending_to_wish") {
          resolvedToWishes += 1;
        } else if (entry.kind === "pending_to_decline") {
          resolvedToDeclines += 1;
        }
      });
      setDeclineCount(nextDeclines);
      setRefuseStats(nextRefuseStats);
      setDecisionStats((prev) => ({
        ...prev,
        resolvedToWishes,
        resolvedToDeclines,
      }));
    },
    [setDeclineCount, setDecisionStats, setRefuseStats, setSavedTotalUSD]
  );

  const computeSavingsTotals = useCallback(
    (list, { shouldReduceSpends = spendReducesSavings, includeIncomeSavings = true } = {}) => {
      const normalized = Array.isArray(list) ? list.filter(Boolean) : [];
      if (!normalized.length) {
        return { running: 0, peak: 0 };
      }
      const gainEvents = includeIncomeSavings ? HISTORY_SAVED_GAIN_EVENTS : HISTORY_PROGRESS_GAIN_EVENTS;
      const sorted = normalized.slice().sort((a, b) => {
        const aStamp = typeof a?.timestamp === "number" ? a.timestamp : 0;
        const bStamp = typeof b?.timestamp === "number" ? b.timestamp : 0;
        return aStamp - bStamp;
      });
      let running = 0;
      let peak = 0;
      sorted.forEach((entry) => {
        if (!entry?.kind) return;
        const amount = Math.max(0, Number(entry?.meta?.amountUSD) || 0);
        if (!amount) return;
        if (gainEvents.has(entry.kind)) {
          running += amount;
        } else if (shouldReduceSpends && HISTORY_SAVED_LOSS_EVENTS.has(entry.kind)) {
          running -= amount;
        }
        if (running < 0) running = 0;
        if (running > peak) peak = running;
      });
      return { running, peak };
    },
    [spendReducesSavings]
  );

  const rebuildSavingsFromHistory = useCallback(
    (list, shouldReduceSpends = spendReducesSavings) => {
      const { running, peak } = computeSavingsTotals(list, { shouldReduceSpends, includeIncomeSavings: true });
      const { running: progressRunning, peak: progressPeak } = computeSavingsTotals(list, {
        shouldReduceSpends,
        includeIncomeSavings: false,
      });
      setSavedTotalUSD(running);
      setLifetimeSavedUSD(peak);
      setProgressSavedTotalUSD(progressRunning);
      setProgressLifetimeSavedUSD(progressPeak);
      const levelProgressUSD = Math.max(
        0,
        Math.max(progressRunning, progressPeak) - levelProgressOffsetUSD
      );
      const currentLevel = getTierProgress(
        levelProgressUSD,
        profile.currency || DEFAULT_PROFILE.currency
      ).level;
      persistLastCelebratedLevel(currentLevel);
      previousPlayerLevelRef.current = currentLevel;
      return { running, peak, progressRunning, progressPeak };
    },
    [
      computeSavingsTotals,
      levelProgressOffsetUSD,
      persistLastCelebratedLevel,
      profile.currency,
      setLifetimeSavedUSD,
      setProgressLifetimeSavedUSD,
      setProgressSavedTotalUSD,
      setSavedTotalUSD,
      spendReducesSavings,
    ]
  );

  const handleSpendImpactToggle = useCallback(
    (enabled) => {
      const nextValue = !!enabled;
      triggerHaptic();
      setProfile((prev) => ({ ...prev, spendReducesSavings: nextValue }));
      setProfileDraft((prev) => ({ ...prev, spendReducesSavings: nextValue }));
      const totals = rebuildSavingsFromHistory(resolvedHistoryEvents, nextValue);
      if (totals && typeof totals.running === "number") {
        rebalanceWishesFromSavedTotal();
      }
      logEvent("spend_impact_toggle", { enabled: nextValue ? 1 : 0 });
    },
    [logEvent, rebuildSavingsFromHistory, rebalanceWishesFromSavedTotal, resolvedHistoryEvents, triggerHaptic]
  );
  const handleSoundToggle = useCallback(
    (enabled) => {
      const nextValue = !!enabled;
      triggerHaptic();
      setSoundEnabled(nextValue);
      if (!nextValue) {
        stopAllSounds();
      }
      AsyncStorage.setItem(STORAGE_KEYS.SOUND_ENABLED, nextValue ? "1" : "0").catch(() => {});
    },
    [stopAllSounds, triggerHaptic]
  );

  const normalizeHistoryGoalId = useCallback(
    (goalId) => {
      if (!goalId || typeof goalId !== "string") return null;
      if (goalId.startsWith("wish_primary_goal_")) return goalId;
      const isPrimary =
        (Array.isArray(profile.primaryGoals) &&
          profile.primaryGoals.some((goal) => goal?.id === goalId)) ||
        profile.goal === goalId;
      return isPrimary ? getPrimaryGoalWishId(goalId) : goalId;
    },
    [profile.goal, profile.primaryGoals]
  );

  const applyHistoryGoalDelta = useCallback(
    (rawGoalId, deltaUSD) => {
      if (!rawGoalId || !Number.isFinite(deltaUSD) || deltaUSD === 0) return;
      const normalizedGoalId = normalizeHistoryGoalId(rawGoalId);
      if (!normalizedGoalId) return;
      if (normalizedGoalId.startsWith("wish_primary_goal_")) {
        const goalId = normalizedGoalId.replace("wish_primary_goal_", "");
        const primaryEntry = Array.isArray(profile.primaryGoals)
          ? profile.primaryGoals.find((goal) => goal?.id === goalId)
          : null;
        const primaryWish =
          Array.isArray(wishesRef.current) &&
          wishesRef.current.find(
            (wish) => wish?.id === normalizedGoalId || wish?.goalId === goalId
          );
        const currentSaved = Number.isFinite(primaryEntry?.savedUSD)
          ? primaryEntry.savedUSD
          : Number.isFinite(primaryWish?.savedUSD)
          ? primaryWish.savedUSD
          : 0;
        const targetUSD =
          Number.isFinite(primaryEntry?.targetUSD) && primaryEntry.targetUSD > 0
            ? primaryEntry.targetUSD
            : Number.isFinite(primaryWish?.targetUSD) && primaryWish.targetUSD > 0
            ? primaryWish.targetUSD
            : profile.goal === goalId &&
              Number.isFinite(profile.goalTargetUSD) &&
              profile.goalTargetUSD > 0
            ? profile.goalTargetUSD
            : getGoalDefaultTargetUSD(goalId);
        const nextSaved = Math.max(0, currentSaved + deltaUSD);
        const nextStatus = targetUSD > 0 && nextSaved >= targetUSD ? "done" : "active";
        syncPrimaryGoalProgress(goalId, nextSaved, nextStatus);
        return;
      }
      setWishes((prev) => {
        let changed = false;
        const next = prev.map((wish) => {
          if (!wish) return wish;
          if (wish.id !== normalizedGoalId && wish.goalId !== normalizedGoalId) return wish;
          const targetUSD =
            Number.isFinite(wish.targetUSD) && wish.targetUSD > 0
              ? wish.targetUSD
              : getGoalDefaultTargetUSD(wish.goalId || wish.id);
          const previousSaved = Number.isFinite(wish.savedUSD) ? wish.savedUSD : 0;
          const nextSaved = Math.max(0, previousSaved + deltaUSD);
          const nextStatus = targetUSD > 0 && nextSaved >= targetUSD ? "done" : "active";
          if (nextSaved !== previousSaved || nextStatus !== wish.status) {
            changed = true;
            return { ...wish, savedUSD: nextSaved, status: nextStatus };
          }
          return wish;
        });
        return changed ? next : prev;
      });
    },
    [
      normalizeHistoryGoalId,
      profile.goal,
      profile.goalTargetUSD,
      profile.primaryGoals,
      setWishes,
      syncPrimaryGoalProgress,
    ]
  );

  const handleHistoryDelete = useCallback(
    (entry) => {
      if (!entry) return;
      const entryId = entry.id;
      const amountUSD = Math.max(0, Number(entry.meta?.amountUSD) || 0);
      const resolveHistoryGoalId = () => {
        const meta = entry.meta || {};
        const storedGoalId =
          meta.goalId || meta.goal_id || meta.savingTargetId || meta.saving_target_id || null;
        if (storedGoalId) return storedGoalId;
        const templateId = meta.templateId || meta.id || null;
        return templateId ? resolveTemptationGoalId(templateId) : null;
      };
      if (entry.kind === "refuse_spend") {
        const metaCoinReward = Math.max(0, Number(entry.meta?.coinReward) || 0);
        const resolvedCurrency = entry.meta?.currency || profile.currency || DEFAULT_PROFILE.currency;
        const coinRefund = metaCoinReward > 0
          ? metaCoinReward
          : computeRefuseCoinReward(amountUSD, resolvedCurrency);
        if (coinRefund > 0) {
          setHealthPoints((prev) => Math.max(0, prev - coinRefund));
        }
        const targetGoalId = resolveHistoryGoalId();
        if (targetGoalId) {
          applyHistoryGoalDelta(targetGoalId, -amountUSD);
        }
      }
      if (amountUSD > 0) {
        if (entry.kind === "refuse_spend") {
          setSavedTotalUSD((prev) => Math.max(0, prev - amountUSD));
          setProgressSavedTotalUSD((prev) => Math.max(0, prev - amountUSD));
        } else if (entry.kind === "spend" && spendReducesSavings) {
          setSavedTotalUSD((prev) => Math.max(0, prev + amountUSD));
          setProgressSavedTotalUSD((prev) => Math.max(0, prev + amountUSD));
        }
      }
      setHistoryEvents((prev) => {
        const next = prev.filter((h) => h.id !== entryId);
        AsyncStorage.setItem(STORAGE_KEYS.HISTORY, JSON.stringify(next)).catch(() => {});
        setChallengesState((prevState) => rebuildChallengeProgressFromHistory(next, prevState));
        return next;
      });
      if (entry.kind === "pending_added" && entry.meta?.pendingId) {
        setPendingList((prev) => prev.filter((p) => p.id !== entry.meta.pendingId));
      }
      if (entry.kind === "wish_added" && entry.meta?.wishId) {
        setWishes((prev) => prev.filter((w) => w.id !== entry.meta.wishId));
      }
    },
    [
      applyHistoryGoalDelta,
      profile.currency,
      resolveTemptationGoalId,
      setPendingList,
      setWishes,
      setHealthPoints,
      setProgressSavedTotalUSD,
      setSavedTotalUSD,
      setChallengesState,
      spendReducesSavings,
    ]
  );

  useEffect(() => {
    recomputeHistoryAggregates(resolvedHistoryEvents);
  }, [resolvedHistoryEvents, recomputeHistoryAggregates]);
  useEffect(() => {
    if (!usageStreakHydrated || !historyHydrated) return;
    if (!usageStreakBackfillRef.current) return;
    const computed = computeUsageStreakFromHistory(resolvedHistoryEvents, Date.now());
    setUsageStreak((prev) => ({
      ...prev,
      current: computed.current,
      lastDate: computed.lastDate,
      total: Math.max(prev.total || 0, computed.total || 0),
      best: Math.max(prev.best || 0, computed.best || 0),
    }));
    usageStreakBackfillRef.current = false;
  }, [historyHydrated, resolvedHistoryEvents, usageStreakHydrated]);
  const maybeTriggerNorthStarMetric = useCallback(() => {
    if (!northStarHydrated || !profileHydrated || northStarLoggedRef.current) return;
    if (!profileJoinedAt) return;
    const joinedAtTimestamp = new Date(profileJoinedAt).getTime();
    if (!Number.isFinite(joinedAtTimestamp)) return;
    const windowEnd = joinedAtTimestamp + NORTH_STAR_WINDOW_MS;
    let savesInWindow = 0;
    resolvedHistoryEvents.forEach((entry) => {
      if (entry?.kind !== "refuse_spend") return;
      const eventTimestamp = typeof entry.timestamp === "number" ? entry.timestamp : 0;
      if (!eventTimestamp) return;
      if (eventTimestamp >= joinedAtTimestamp && eventTimestamp <= windowEnd) {
        savesInWindow += 1;
      }
    });
    if (savesInWindow < NORTH_STAR_SAVE_THRESHOLD) return;
    const hoursSinceJoinRaw = Math.max(0, (Date.now() - joinedAtTimestamp) / (1000 * 60 * 60));
    const hoursSinceJoin = Math.min(24, Math.round(hoursSinceJoinRaw * 10) / 10);
    setNorthStarLogged(true);
    northStarLoggedRef.current = true;
    AsyncStorage.setItem(
      STORAGE_KEYS.NORTH_STAR_METRIC,
      JSON.stringify({
        logged: true,
        loggedAt: new Date().toISOString(),
        savesInWindow,
        northStar2Logged: northStar2LoggedRef.current,
      })
    ).catch(() => {});
    logEvent("north_star_two_saves", {
      saves_in_window: savesInWindow,
      hours_since_join: hoursSinceJoin,
    });
  }, [logEvent, northStarHydrated, profileHydrated, profileJoinedAt, resolvedHistoryEvents]);
  useEffect(() => {
    maybeTriggerNorthStarMetric();
  }, [maybeTriggerNorthStarMetric]);

  const maybeTriggerNorthStar2 = useCallback(() => {
    if (!northStarHydrated || !profileHydrated || northStar2LoggedRef.current) return;
    const decisionKinds = new Set([
      "refuse_spend",
      "spend",
      "pending_added",
      "pending_to_wish",
      "pending_to_decline",
    ]);
    const dayKeys = new Set();
    let decisionsTotal = 0;
    resolvedHistoryEvents.forEach((entry) => {
      if (!entry || !decisionKinds.has(entry.kind)) return;
      const ts = Number(entry.timestamp) || 0;
      if (!ts) return;
      const dayKey = getDayKey(ts);
      if (!dayKey) return;
      dayKeys.add(dayKey);
      decisionsTotal += 1;
    });
    if (dayKeys.size < 2) return;
    setNorthStar2Logged(true);
    northStar2LoggedRef.current = true;
    AsyncStorage.setItem(
      STORAGE_KEYS.NORTH_STAR_METRIC,
      JSON.stringify({
        logged: northStarLoggedRef.current,
        loggedAt: northStarLoggedRef.current ? new Date().toISOString() : null,
        northStar2Logged: true,
        northStar2LoggedAt: new Date().toISOString(),
        decisionsTotal,
        decisionDays: dayKeys.size,
      })
    ).catch(() => {});
    logEvent("north_star2", {
      decision_days: dayKeys.size,
      decisions_total: decisionsTotal,
    });
  }, [logEvent, northStarHydrated, profileHydrated, resolvedHistoryEvents]);
  useEffect(() => {
    maybeTriggerNorthStar2();
  }, [maybeTriggerNorthStar2]);

  const triggerCardFeedback = useCallback((templateId) => {
    if (!templateId) return;
    const burstKey = Date.now();
    setCardFeedback((prev) => ({
      ...prev,
      [templateId]: {
        ...(prev[templateId] || {}),
        message: true,
        burstKey,
      },
    }));
    if (cardFeedbackTimers.current[templateId]) {
      clearTimeout(cardFeedbackTimers.current[templateId]);
    }
    cardFeedbackTimers.current[templateId] = setTimeout(() => {
      setCardFeedback((prev) => {
        const entry = prev[templateId];
        if (!entry) return prev;
        return {
          ...prev,
          [templateId]: {
            ...entry,
            message: false,
          },
        };
      });
      delete cardFeedbackTimers.current[templateId];
    }, 2000);
  }, []);

  const triggerCoinHaptics = useCallback(() => {
    triggerCoinRewardHaptics();
  }, []);

  const closeSpendPrompt = useCallback(() => {
    spendPromptLockRef.current = false;
    setSpendPrompt({ visible: false, item: null, amountUSD: null });
  }, []);
  const closeSaveSpamPrompt = useCallback(() => {
    setSaveSpamPrompt({ visible: false, item: null, options: null, recentCount: 0 });
  }, []);

  const processMascotQueue = useCallback(() => {
    if (overlay || mascotBusyRef.current) return;
    if (!mascotQueueRef.current.length) return;
    const next = mascotQueueRef.current.shift();
    if (!next) return;
    mascotBusyRef.current = true;
    setMascotOverride({ ...next, key: Date.now() });
  }, [overlay]);

  useEffect(() => {
    if (!overlay) {
      processMascotQueue();
    }
  }, [overlay, processMascotQueue]);

  const requestMascotAnimation = useCallback(
    (type, duration) => {
      const resolvedDuration = duration || TAMAGOTCHI_REACTION_DURATION[type] || 3200;
      mascotQueueRef.current.push({ type, duration: resolvedDuration });
      processMascotQueue();
      playSound("cat");
    },
    [playSound, processMascotQueue]
  );

  const feedTamagotchi = useCallback(
    (foodId = TAMAGOTCHI_DEFAULT_FOOD_ID) => {
      const food = TAMAGOTCHI_FOOD_MAP[foodId] || TAMAGOTCHI_FOOD_MAP[TAMAGOTCHI_DEFAULT_FOOD_ID];
      if (!food) return;
      if (tamagotchiState.hunger >= TAMAGOTCHI_MAX_HUNGER) {
        Alert.alert(t("tamagotchiName"), t("tamagotchiFullMessage"));
        return;
      }
      if (tamagotchiCoins < food.cost) {
        const hint = t("tamagotchiEarnCoinsHint");
        const displayCost = getHealthCoinDisplayCount(food.cost);
        const needText = t("tamagotchiNeedCoinsMessage", { cost: displayCost, emoji: food.emoji });
        Alert.alert(t("tamagotchiName"), `${needText}\n\n${hint}`);
        return;
      }
      let hungerBefore = tamagotchiState.hunger;
      let hungerAfter = tamagotchiState.hunger;
      setTamagotchiState((prev) => {
        const prevHunger = Math.max(0, Number(prev.hunger) || 0);
        const nextHunger = Math.min(TAMAGOTCHI_MAX_HUNGER, prevHunger + food.hungerBoost);
        const prevMood = normalizeTamagotchiStateValue(prev.mood, TAMAGOTCHI_START_STATE.mood);
        const moodGain = Math.max(4, Math.round(food.hungerBoost * 0.18));
        const nextMood = Math.min(TAMAGOTCHI_MAX_STATE_VALUE, prevMood + moodGain);
        hungerBefore = prevHunger;
        hungerAfter = nextHunger;
        const nextFoodId = resolveNextTamagotchiFoodId(nextHunger, food.id, true);
        return {
          ...prev,
          hunger: nextHunger,
          mood: Math.round(nextMood),
          lastFedAt: new Date().toISOString(),
          desiredFoodId: nextFoodId,
        };
      });
      const coinsAfter = Math.max(0, tamagotchiCoins - food.cost);
      logEvent("tamagotchi_feed", {
        food_id: food.id,
        food_cost: food.cost,
        hunger_before: hungerBefore,
        hunger_after: hungerAfter,
        coins_before: tamagotchiCoins,
        coins_after: coinsAfter,
      });
      triggerHaptic(Haptics.ImpactFeedbackStyle.Heavy);
      setHealthPoints((coins) => Math.max(0, coins - food.cost));
      requestMascotAnimation("happy", 3600);
      queueHomeSpeech("feed");
    },
    [
      logEvent,
      queueHomeSpeech,
      requestMascotAnimation,
      setHealthPoints,
      t,
      tamagotchiCoins,
      tamagotchiState.hunger,
    ]
  );

  const clearTamagotchiToyFlightTimer = useCallback(() => {
    if (tamagotchiToyFlightTimerRef.current) {
      clearTimeout(tamagotchiToyFlightTimerRef.current);
      tamagotchiToyFlightTimerRef.current = null;
    }
  }, []);
  useEffect(
    () => () => {
      clearTamagotchiToyFlightTimer();
      tamagotchiToyFlightAnim.stopAnimation();
      tamagotchiHeartBurstAnim.stopAnimation();
    },
    [clearTamagotchiToyFlightTimer, tamagotchiHeartBurstAnim, tamagotchiToyFlightAnim]
  );
  const runTamagotchiToyFlight = useCallback(
    (toyId) => {
      if (!toyId) return;
      clearTamagotchiToyFlightTimer();
      setTamagotchiToyFlightId(toyId);
      tamagotchiToyFlightAnim.stopAnimation();
      tamagotchiToyFlightAnim.setValue(0);
      tamagotchiHeartBurstAnim.stopAnimation();
      tamagotchiHeartBurstAnim.setValue(0);
      Animated.timing(tamagotchiToyFlightAnim, {
        toValue: 1,
        duration: 1800,
        easing: Easing.inOut(Easing.sin),
        useNativeDriver: true,
      }).start(() => {
        setTamagotchiToyFlightId((prev) => (prev === toyId ? null : prev));
      });
      Animated.timing(tamagotchiHeartBurstAnim, {
        toValue: 1,
        duration: 1400,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }).start(() => {
        tamagotchiHeartBurstAnim.setValue(0);
      });
      tamagotchiToyFlightTimerRef.current = setTimeout(() => {
        setTamagotchiToyFlightId(null);
        tamagotchiToyFlightTimerRef.current = null;
      }, 2100);
    },
    [clearTamagotchiToyFlightTimer, tamagotchiHeartBurstAnim, tamagotchiToyFlightAnim]
  );
  const playWithTamagotchiToy = useCallback(
    (toyId = TAMAGOTCHI_DEFAULT_TOY_ID) => {
      const toy = TAMAGOTCHI_TOY_MAP[toyId] || TAMAGOTCHI_TOY_MAP[TAMAGOTCHI_DEFAULT_TOY_ID];
      if (!toy) return;
      if (tamagotchiCoins < toy.cost) {
        const hint = t("tamagotchiEarnCoinsHint");
        const needText = t("tamagotchiNeedCoinsMessage", { cost: toy.cost, emoji: toy.emoji });
        Alert.alert(t("tamagotchiName"), `${needText}\n\n${hint}`);
        return;
      }
      const isDesired = tamagotchiDesiredToy?.id === toy.id;
      const moodBoost = isDesired ? toy.moodBoost + 6 : Math.max(8, toy.moodBoost - 4);
      const cleanPenalty = Math.max(1, toy.cleanPenalty + (isDesired ? 1 : 0));
      setTamagotchiState((prev) => {
        const prevMood = normalizeTamagotchiStateValue(prev.mood, TAMAGOTCHI_START_STATE.mood);
        const prevClean = normalizeTamagotchiStateValue(
          prev.cleanliness,
          TAMAGOTCHI_START_STATE.cleanliness
        );
        const nextMood = Math.min(TAMAGOTCHI_MAX_STATE_VALUE, prevMood + moodBoost);
        const nextClean = Math.max(0, prevClean - cleanPenalty);
        const nextToyId = resolveNextTamagotchiToyId(nextMood, toy.id, true);
        return {
          ...prev,
          mood: Math.round(nextMood),
          cleanliness: Math.round(nextClean),
          desiredToyId: nextToyId,
          lastPlayedAt: new Date().toISOString(),
        };
      });
      runTamagotchiToyFlight(toy.id);
      triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
      setHealthPoints((coins) => Math.max(0, coins - toy.cost));
      requestMascotAnimation("happy", 2600);
      queueHomeSpeech("play");
      logEvent("tamagotchi_play", {
        toy_id: toy.id,
        toy_cost: toy.cost,
        coins_before: tamagotchiCoins,
        coins_after: Math.max(0, tamagotchiCoins - toy.cost),
        wanted_toy: isDesired ? 1 : 0,
        mood_boost: moodBoost,
        cleanliness_drop: cleanPenalty,
      });
    },
    [
      logEvent,
      queueHomeSpeech,
      requestMascotAnimation,
      runTamagotchiToyFlight,
      setHealthPoints,
      t,
      tamagotchiCoins,
      tamagotchiDesiredToy?.id,
    ]
  );
  const buyTamagotchiCleanTool = useCallback(
    (toolId = TAMAGOTCHI_DEFAULT_CLEAN_TOOL_ID) => {
      const tool =
        TAMAGOTCHI_CLEAN_TOOL_MAP[toolId] ||
        TAMAGOTCHI_CLEAN_TOOL_MAP[TAMAGOTCHI_DEFAULT_CLEAN_TOOL_ID];
      if (!tool) return false;
      if (tamagotchiCoins < tool.cost) {
        const hint = t("tamagotchiEarnCoinsHint");
        const needText = t("tamagotchiNeedCoinsMessage", { cost: tool.cost, emoji: tool.emoji });
        Alert.alert(t("tamagotchiName"), `${needText}\n\n${hint}`);
        return false;
      }
      setHealthPoints((coins) => Math.max(0, coins - tool.cost));
      setTamagotchiState((prev) => {
        const supplies = normalizeTamagotchiToolSupplies(prev.cleanToolSupplies);
        return {
          ...prev,
          cleanToolSupplies: {
            ...supplies,
            [tool.id]: Math.max(1, Number(tool.maxUses) || 1),
          },
        };
      });
      setTamagotchiSelectedCleanToolId(tool.id);
      triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
      logEvent("tamagotchi_clean_tool_bought", {
        tool_id: tool.id,
        tool_cost: tool.cost,
        coins_before: tamagotchiCoins,
        coins_after: Math.max(0, tamagotchiCoins - tool.cost),
      });
      return true;
    },
    [logEvent, setHealthPoints, t, tamagotchiCoins]
  );
  const setTamagotchiCleanTouchLock = useCallback((value) => {
    const next = !!value;
    if (tamagotchiCleanTouchActiveRef.current === next) return;
    tamagotchiCleanTouchActiveRef.current = next;
    setTamagotchiCleanTouchActive(next);
  }, []);
  const handleTamagotchiCleanStroke = useCallback(() => {
    if (tamagotchiActiveTab !== "clean") return;
    const tool =
      TAMAGOTCHI_CLEAN_TOOL_MAP[tamagotchiSelectedCleanToolId] ||
      TAMAGOTCHI_CLEAN_TOOL_MAP[TAMAGOTCHI_DEFAULT_CLEAN_TOOL_ID];
    if (!tool) return;
    const remainingUses = Math.max(
      0,
      Number(tamagotchiCleanToolSupplies?.[tool.id]) || 0
    );
    if (remainingUses <= 0) {
      triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
      requestMascotAnimation("sad", 1400);
      playSound("tap");
      return;
    }
    const progress = tamagotchiCleaningProgress || createTamagotchiCleaningProgress();
    const expectedType = progress.stage === "brush" ? "brush" : "soap";
    if (tool.type !== expectedType) {
      triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
      requestMascotAnimation("sad", 1500);
      playSound("tap");
      return;
    }
    const nextSoapHits = Math.min(
      TAMAGOTCHI_CLEAN_SOAP_TARGET,
      progress.soapHits + (expectedType === "soap" ? 1 : 0)
    );
    const nextBrushHits = Math.min(
      TAMAGOTCHI_CLEAN_BRUSH_TARGET,
      progress.brushHits + (expectedType === "brush" ? 1 : 0)
    );
    const soapDone = nextSoapHits >= TAMAGOTCHI_CLEAN_SOAP_TARGET;
    const brushDone = nextBrushHits >= TAMAGOTCHI_CLEAN_BRUSH_TARGET;
    const cycleCompleted = soapDone && brushDone;
    setTamagotchiCleaningProgress(
      cycleCompleted
        ? createTamagotchiCleaningProgress()
        : {
            stage: soapDone ? "brush" : "soap",
            soapHits: nextSoapHits,
            brushHits: nextBrushHits,
          }
    );
    setTamagotchiState((prev) => {
      const prevClean = normalizeTamagotchiStateValue(
        prev.cleanliness,
        TAMAGOTCHI_START_STATE.cleanliness
      );
      const prevMood = normalizeTamagotchiStateValue(prev.mood, TAMAGOTCHI_START_STATE.mood);
      const immediateCleanGain = Math.max(1, Number(tool.cleanBoost) || 0);
      const immediateMoodGain = Math.max(0, Number(tool.moodBoost) || 0);
      const completionCleanBonus = cycleCompleted ? 16 : 0;
      const completionMoodBonus = cycleCompleted ? 10 : 0;
      const nextMood = Math.min(
        TAMAGOTCHI_MAX_STATE_VALUE,
        prevMood + immediateMoodGain + completionMoodBonus
      );
      const nextToyId = resolveNextTamagotchiToyId(
        nextMood,
        prev?.desiredToyId || TAMAGOTCHI_DEFAULT_TOY_ID,
        cycleCompleted
      );
      const supplies = normalizeTamagotchiToolSupplies(prev.cleanToolSupplies);
      const prevSupply = Math.max(0, Number(supplies[tool.id]) || 0);
      return {
        ...prev,
        cleanliness: Math.round(
          Math.min(
            TAMAGOTCHI_MAX_STATE_VALUE,
            prevClean + immediateCleanGain + completionCleanBonus
          )
        ),
        mood: Math.round(nextMood),
        desiredToyId: nextToyId,
        cleanToolSupplies: {
          ...supplies,
          [tool.id]: Math.max(0, prevSupply - 1),
        },
        lastCleanedAt: cycleCompleted ? new Date().toISOString() : prev.lastCleanedAt,
      };
    });
    triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    playSound("tap");
    if (cycleCompleted) {
      requestMascotAnimation("happyHeadshake", 2800);
      playSound("reward");
      queueHomeSpeech("clean");
      logEvent("tamagotchi_clean_cycle", {
        tool_id: tool.id,
        soap_hits: nextSoapHits,
        brush_hits: nextBrushHits,
      });
    }
  }, [
    logEvent,
    queueHomeSpeech,
    requestMascotAnimation,
    playSound,
    tamagotchiActiveTab,
    tamagotchiCleaningProgress,
    tamagotchiCleanToolSupplies,
    tamagotchiSelectedCleanToolId,
  ]);
  const tamagotchiCleanPanResponder = useMemo(
    () =>
      PanResponder.create({
        onStartShouldSetPanResponder: () =>
          tamagotchiActiveTab === "clean" && tamagotchiSelectedCleanToolRemaining > 0,
        onMoveShouldSetPanResponder: (_, gestureState) =>
          tamagotchiActiveTab === "clean" &&
          tamagotchiSelectedCleanToolRemaining > 0 &&
          (Math.abs(gestureState.dx) > 6 || Math.abs(gestureState.dy) > 6),
        onPanResponderGrant: (_, gestureState) => {
          setTamagotchiCleanTouchLock(true);
          tamagotchiCleanSwipeStateRef.current.lastX = Number(gestureState?.x0) || 0;
          tamagotchiCleanSwipeStateRef.current.lastY = Number(gestureState?.y0) || 0;
          tamagotchiCleanSwipeStateRef.current.pathDistance = 0;
        },
        onPanResponderMove: (_, gestureState) => {
          if (tamagotchiActiveTab !== "clean") return;
          const state = tamagotchiCleanSwipeStateRef.current;
          const moveX = Number(gestureState?.moveX) || state.lastX || 0;
          const moveY = Number(gestureState?.moveY) || state.lastY || 0;
          const dx = moveX - (state.lastX || 0);
          const dy = moveY - (state.lastY || 0);
          state.lastX = moveX;
          state.lastY = moveY;
          state.pathDistance += Math.sqrt(dx * dx + dy * dy);
          while (state.pathDistance >= TAMAGOTCHI_CLEAN_SWIPE_DISTANCE_PX) {
            const now = Date.now();
            if (now - (state.lastStrokeAt || 0) >= TAMAGOTCHI_CLEAN_SWIPE_STROKE_COOLDOWN_MS) {
              handleTamagotchiCleanStroke();
              state.lastStrokeAt = now;
            }
            state.pathDistance -= TAMAGOTCHI_CLEAN_SWIPE_DISTANCE_PX;
          }
        },
        onPanResponderRelease: () => {
          tamagotchiCleanSwipeStateRef.current.pathDistance = 0;
          setTamagotchiCleanTouchLock(false);
        },
        onPanResponderTerminate: () => {
          tamagotchiCleanSwipeStateRef.current.pathDistance = 0;
          setTamagotchiCleanTouchLock(false);
        },
        onPanResponderTerminationRequest: () => false,
      }),
    [
      handleTamagotchiCleanStroke,
      setTamagotchiCleanTouchLock,
      tamagotchiActiveTab,
      tamagotchiSelectedCleanToolRemaining,
    ]
  );
  const tamagotchiCloseSwipeResponder = useMemo(() => {
    let handled = false;
    const canHandleGesture = () => !tamagotchiCleanTouchActiveRef.current;
    const tryClose = (gestureState = {}) => {
      if (handled) return;
      if (!canHandleGesture()) return;
      const dx = Number(gestureState.dx) || 0;
      const dy = Number(gestureState.dy) || 0;
      if (dx < TAMAGOTCHI_CLOSE_SWIPE_DISTANCE || Math.abs(dy) > TAMAGOTCHI_CLOSE_VERTICAL_SLOP) {
        return;
      }
      handled = true;
      closeTamagotchiOverlay();
    };
    return PanResponder.create({
      onStartShouldSetPanResponder: () => canHandleGesture(),
      onMoveShouldSetPanResponder: (_, gestureState) =>
        canHandleGesture() &&
        Math.abs(gestureState.dx) > Math.abs(gestureState.dy) &&
        gestureState.dx > 6,
      onPanResponderGrant: () => {
        handled = false;
      },
      onPanResponderRelease: (_, gestureState) => {
        tryClose(gestureState);
      },
      onPanResponderTerminate: (_, gestureState) => {
        tryClose(gestureState);
      },
      onPanResponderTerminationRequest: () => !tamagotchiCleanTouchActiveRef.current,
    });
  }, [closeTamagotchiOverlay]);

  const clearPartySoundTimers = useCallback(() => {
    if (!partySoundTimersRef.current.length) return;
    partySoundTimersRef.current.forEach((timerId) => clearTimeout(timerId));
    partySoundTimersRef.current = [];
  }, []);

  const runPartySounds = useCallback(
    (loops = 2) => {
      clearPartySoundTimers();
      const sequence = Array.isArray(PARTY_SOUND_SEQUENCE) ? PARTY_SOUND_SEQUENCE : [];
      if (!sequence.length) return;
      const loopCount = Math.max(1, Number(loops) || 1);
      for (let loopIndex = 0; loopIndex < loopCount; loopIndex += 1) {
        const baseDelay = loopIndex * PARTY_SOUND_LOOP_MS;
        sequence.forEach(({ at, key }) => {
          if (!key) return;
          const timerId = setTimeout(() => {
            playSound(key, { skipCooldown: true });
          }, Math.max(0, baseDelay + (Number(at) || 0)));
          partySoundTimersRef.current.push(timerId);
        });
      }
    },
    [clearPartySoundTimers, playSound]
  );

  const stopPartyEffects = useCallback(() => {
    if (partyGlowAnimRef.current) {
      partyGlowAnimRef.current.stop();
      partyGlowAnimRef.current = null;
    }
    partyGlow.setValue(0);
    setPartyActive(false);
    clearPartySoundTimers();
  }, [clearPartySoundTimers, partyGlow]);

  const runPartyEffects = useCallback(
    (cyclesLeft = 3) => {
      const executeCycle = (remaining) => {
        if (remaining <= 0) {
          stopPartyEffects();
          return;
        }
        setPartyBurstKey((prev) => prev + 1);
        const glowPulse = Animated.sequence([
          Animated.timing(partyGlow, {
            toValue: 1,
            duration: 400,
            easing: Easing.out(Easing.quad),
            useNativeDriver: true,
          }),
          Animated.timing(partyGlow, {
            toValue: 0,
            duration: 400,
            easing: Easing.in(Easing.quad),
            useNativeDriver: true,
          }),
          Animated.delay(320),
        ]);
        partyGlowAnimRef.current = glowPulse;
        glowPulse.start(() => executeCycle(remaining - 1));
      };
      executeCycle(cyclesLeft);
    },
    [partyGlow, stopPartyEffects]
  );

  useEffect(() => {
    return () => {
      stopPartyEffects();
    };
  }, [stopPartyEffects]);


  const startParty = useCallback(() => {
    playSound("tap");
    if (tamagotchiCoins < TAMAGOTCHI_PARTY_COST) {
      const hint = t("tamagotchiEarnCoinsHint");
      const needText = t("tamagotchiPartyNeedCoinsMessage", {
        amount: TAMAGOTCHI_PARTY_BLUE_COST,
      });
      Alert.alert(t("tamagotchiName"), `${needText}\n\n${hint}`);
      return;
    }
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    const coinsAfter = Math.max(0, tamagotchiCoins - TAMAGOTCHI_PARTY_COST);
    logEvent("tamagotchi_party_started", {
      party_cost: TAMAGOTCHI_PARTY_COST,
      coins_before: tamagotchiCoins,
      coins_after: coinsAfter,
    });
    setHealthPoints((coins) => Math.max(0, coins - TAMAGOTCHI_PARTY_COST));
    const immunityUntil = Date.now() + TAMAGOTCHI_PARTY_IMMUNITY_MS;
    setTamagotchiState((prev) => ({
      ...prev,
      hungerImmunityUntil: Math.max(Number(prev.hungerImmunityUntil) || 0, immunityUntil),
    }));
    stopPartyEffects();
    setPartyActive(true);
    runPartyEffects(3);
    runPartySounds(2);
    requestMascotAnimation("happyHeadshake", 3600);
  }, [
    logEvent,
    playSound,
    requestMascotAnimation,
    runPartyEffects,
    runPartySounds,
    setHealthPoints,
    stopPartyEffects,
    t,
    tamagotchiCoins,
    triggerHaptic,
  ]);

  const renderTamagotchiFoodList = () => {
    const buttons = TAMAGOTCHI_FOOD_OPTIONS.map((food, index) => {
      const label = food.label[language] || food.label.en;
      const coinTier = getHealthCoinTierForAmount(food.cost);
      const displayCost = getHealthCoinDisplayCount(food.cost);
      const affordable = tamagotchiCoins >= food.cost;
      const isDesired = tamagotchiDesiredFood?.id === food.id;
      const isLast = index === TAMAGOTCHI_FOOD_OPTIONS.length - 1;
      return (
        <TouchableOpacity
          key={food.id}
          style={[
            styles.tamagotchiFoodButton,
            { borderColor: colors.border, backgroundColor: colors.card },
            isDesired && [
              styles.tamagotchiFoodButtonWanted,
              {
                borderColor: "#F6A553",
                backgroundColor:
                  Platform.OS === "android"
                    ? blendColors(
                        colors.card || "#FFFFFF",
                        isDarkTheme ? "#F6A553" : "#FFCF95",
                        isDarkTheme ? 0.34 : 0.4
                      )
                    : colorWithAlpha(isDarkTheme ? "#F6A553" : "#FFCF95", isDarkTheme ? 0.2 : 0.28),
                shadowColor: "#F6A553",
              },
            ],
            tamagotchiIsFull && styles.tamagotchiFoodButtonDisabled,
            isLast && styles.tamagotchiFoodButtonLast,
          ]}
          activeOpacity={0.9}
          onPress={() => {
            playSound("tap");
            feedTamagotchi(food.id);
          }}
          disabled={tamagotchiIsFull}
        >
          <Text style={styles.tamagotchiFoodEmoji}>{food.emoji}</Text>
          <View style={styles.tamagotchiFoodInfo}>
            <Text style={[styles.tamagotchiFoodLabel, { color: colors.text }]}>{label}</Text>
            <Text style={[styles.tamagotchiFoodBoost, { color: colors.muted }]}>
              {t("tamagotchiFoodBoostLabel", { percent: food.hungerBoost })}
            </Text>
          </View>
          <View style={styles.tamagotchiFoodCost}>
            <Image source={coinTier.asset} style={styles.tamagotchiFoodCostIcon} />
            <Text
              style={[
                styles.tamagotchiFoodCostText,
                { color: colors.text, opacity: affordable ? 1 : 0.5 },
              ]}
            >
              Ã—{displayCost}
            </Text>
          </View>
          {isDesired && (
            <View style={[styles.tamagotchiFoodBadge, { backgroundColor: colors.text }]}>
              <Text style={[styles.tamagotchiFoodBadgeText, { color: colors.background }]} numberOfLines={2}>
                {t("tamagotchiFoodWantLabel")}
              </Text>
            </View>
          )}
        </TouchableOpacity>
      );
    });
    return (
      <ScrollView
        style={styles.tamagotchiFoodScroll}
        contentContainerStyle={styles.tamagotchiFoodList}
        scrollEnabled
        nestedScrollEnabled
        keyboardShouldPersistTaps="handled"
        showsVerticalScrollIndicator
        bounces
      >
        {buttons}
      </ScrollView>
    );
  };
  const renderTamagotchiToyList = () => {
    const buttons = TAMAGOTCHI_TOY_OPTIONS.map((toy, index) => {
      const label = toy.label[language] || toy.label.en;
      const isDesired = tamagotchiDesiredToy?.id === toy.id;
      const affordable = tamagotchiCoins >= toy.cost;
      const coinTier = getHealthCoinTierForAmount(toy.cost);
      const isLast = index === TAMAGOTCHI_TOY_OPTIONS.length - 1;
      return (
        <TouchableOpacity
          key={toy.id}
          style={[
            styles.tamagotchiFoodButton,
            { borderColor: colors.border, backgroundColor: colors.card },
            isDesired && [
              styles.tamagotchiFoodButtonWanted,
              {
                borderColor: "#F472B6",
                backgroundColor:
                  Platform.OS === "android"
                    ? blendColors(
                        colors.card || "#FFFFFF",
                        isDarkTheme ? "#F472B6" : "#FFC6E0",
                        isDarkTheme ? 0.34 : 0.4
                      )
                    : colorWithAlpha(isDarkTheme ? "#F472B6" : "#FFC6E0", isDarkTheme ? 0.2 : 0.28),
                shadowColor: "#F472B6",
              },
            ],
            isLast && styles.tamagotchiFoodButtonLast,
          ]}
          activeOpacity={0.9}
          onPress={() => {
            playSound("tap");
            playWithTamagotchiToy(toy.id);
          }}
        >
          <Text style={styles.tamagotchiFoodEmoji}>{toy.emoji}</Text>
          <View style={styles.tamagotchiFoodInfo}>
            <Text style={[styles.tamagotchiFoodLabel, { color: colors.text }]}>{label}</Text>
            <Text style={[styles.tamagotchiFoodBoost, { color: colors.muted }]}>
              {t("tamagotchiPlayBoostLabel", { percent: toy.moodBoost })}
            </Text>
          </View>
          <View style={styles.tamagotchiToyMetaWrap}>
            <View style={styles.tamagotchiFoodCost}>
              <Image source={coinTier.asset} style={styles.tamagotchiFoodCostIcon} />
              <Text
                style={[
                  styles.tamagotchiFoodCostText,
                  { color: colors.text, opacity: affordable ? 1 : 0.5 },
                ]}
              >
                Ã—{toy.cost}
              </Text>
            </View>
            <Text style={[styles.tamagotchiToyPenaltyText, { color: colors.muted }]}>
              -{toy.cleanPenalty}%
            </Text>
            <Text style={[styles.tamagotchiToyPenaltySub, { color: colors.muted }]}>
              {t("tamagotchiCleanlinessLabel")}
            </Text>
          </View>
          {isDesired && (
            <View style={[styles.tamagotchiFoodBadge, { backgroundColor: colors.text }]}>
              <Text style={[styles.tamagotchiFoodBadgeText, { color: colors.background }]} numberOfLines={2}>
                {t("tamagotchiPlayWantLabel")}
              </Text>
            </View>
          )}
        </TouchableOpacity>
      );
    });
    return (
      <ScrollView
        style={styles.tamagotchiFoodScroll}
        contentContainerStyle={styles.tamagotchiFoodList}
        scrollEnabled
        nestedScrollEnabled
        keyboardShouldPersistTaps="handled"
        showsVerticalScrollIndicator
        bounces
      >
        {buttons}
      </ScrollView>
    );
  };
  const tamagotchiSoapProgressPercent = Math.min(
    100,
    (Math.max(0, Number(tamagotchiCleaningProgress?.soapHits) || 0) / TAMAGOTCHI_CLEAN_SOAP_TARGET) * 100
  );
  const tamagotchiBrushProgressPercent = Math.min(
    100,
    (Math.max(0, Number(tamagotchiCleaningProgress?.brushHits) || 0) / TAMAGOTCHI_CLEAN_BRUSH_TARGET) * 100
  );
  const tamagotchiCleaningNeedsBrush = tamagotchiCleaningProgress?.stage === "brush";
  const tamagotchiCleanNeedEmoji = tamagotchiCleaningNeedsBrush
    ? TAMAGOTCHI_CLEAN_TOOLS.find((tool) => tool.type === "brush")?.emoji || "ðŸª¥"
    : TAMAGOTCHI_CLEAN_TOOLS.find((tool) => tool.type === "soap")?.emoji || "ðŸ§¼";
  const renderTamagotchiCleanPanel = () => {
    return (
      <ScrollView
        style={styles.tamagotchiFoodScroll}
        contentContainerStyle={styles.tamagotchiFoodList}
        scrollEnabled
        nestedScrollEnabled
        keyboardShouldPersistTaps="handled"
        showsVerticalScrollIndicator
        bounces
      >
        <View style={styles.tamagotchiCleanPanel}>
          <Text style={[styles.tamagotchiCleanHint, { color: colors.muted }]}>
            {tamagotchiCleaningNeedsBrush
              ? t("tamagotchiCleanStageBrush")
              : t("tamagotchiCleanStageSoap")}
          </Text>
          <Text style={[styles.tamagotchiCleanTapHint, { color: colors.text }]}>
            {t("tamagotchiCleanSwipeHint")}
          </Text>
          <View style={styles.tamagotchiCleanToolsRow}>
            {TAMAGOTCHI_CLEAN_TOOLS.map((tool) => {
              const label = tool.label[language] || tool.label.en;
              const selected = tamagotchiSelectedCleanTool?.id === tool.id;
              const remaining = Math.max(0, Number(tamagotchiCleanToolSupplies?.[tool.id]) || 0);
              const maxUses = Math.max(1, Number(tool.maxUses) || 1);
              const remainingPercent = Math.min(100, Math.max(0, (remaining / maxUses) * 100));
              const hasSupply = remaining > 0;
              const coinTier = getHealthCoinTierForAmount(tool.cost);
              return (
                <View
                  key={tool.id}
                  style={[
                    styles.tamagotchiCleanToolButton,
                    {
                      borderColor: selected ? colors.text : colors.border,
                      backgroundColor: selected
                        ? lightenColor(colors.card, isDarkTheme ? 0.1 : 0.2)
                        : colors.card,
                    },
                  ]}
                >
                  <TouchableOpacity
                    style={styles.tamagotchiCleanToolTop}
                    onPress={() => {
                      playSound("tap");
                      if (hasSupply) {
                        setTamagotchiSelectedCleanToolId(tool.id);
                        return;
                      }
                      buyTamagotchiCleanTool(tool.id);
                    }}
                    activeOpacity={0.9}
                  >
                    <Text style={styles.tamagotchiCleanToolEmoji}>{tool.emoji}</Text>
                    <Text
                      style={[
                        styles.tamagotchiCleanToolLabel,
                        { color: colors.text, opacity: selected ? 1 : 0.8 },
                      ]}
                      numberOfLines={1}
                    >
                      {label}
                    </Text>
                  </TouchableOpacity>
                  <View style={styles.tamagotchiCleanToolBarWrap}>
                    <View
                      style={[
                        styles.tamagotchiCleanToolBarTrack,
                        { backgroundColor: colorWithAlpha(colors.border, 0.9) },
                      ]}
                    >
                      <View
                        style={[
                          styles.tamagotchiCleanToolBarFill,
                          {
                            width: `${Math.max(hasSupply ? 8 : 0, remainingPercent)}%`,
                            backgroundColor: hasSupply ? "#6DC9FF" : colorWithAlpha(colors.muted, 0.4),
                          },
                        ]}
                      />
                    </View>
                    <Text style={[styles.tamagotchiCleanToolAmountText, { color: colors.muted }]}>
                      {t("tamagotchiToolUsesLeftLabel", { current: remaining, total: maxUses })}
                    </Text>
                  </View>
                  <TouchableOpacity
                    style={[
                      styles.tamagotchiCleanToolActionButton,
                      {
                        borderColor: colors.border,
                        backgroundColor: hasSupply
                          ? lightenColor(colors.card, isDarkTheme ? 0.08 : 0.18)
                          : colors.card,
                        opacity: hasSupply ? 0.96 : 1,
                      },
                    ]}
                    onPress={() => {
                      playSound("tap");
                      if (hasSupply) {
                        setTamagotchiSelectedCleanToolId(tool.id);
                        return;
                      }
                      buyTamagotchiCleanTool(tool.id);
                    }}
                    activeOpacity={0.9}
                  >
                    {hasSupply ? (
                      <Text style={[styles.tamagotchiCleanToolActionText, { color: colors.text }]}>
                        {selected ? t("tamagotchiToolSelectedLabel") : t("tamagotchiToolSelectLabel")}
                      </Text>
                    ) : (
                      <View style={styles.tamagotchiCleanToolBuyWrap}>
                        <Image source={coinTier.asset} style={styles.tamagotchiFoodCostIcon} />
                        <Text style={[styles.tamagotchiCleanToolActionText, { color: colors.text }]}>
                          {t("tamagotchiToolBuyLabel", { cost: tool.cost })}
                        </Text>
                      </View>
                    )}
                  </TouchableOpacity>
                </View>
              );
            })}
          </View>
          {!tamagotchiSelectedCleanToolRemaining && (
            <Text style={[styles.tamagotchiCleanSupplyHint, { color: colors.muted }]}>
              {t("tamagotchiToolNeedRefillHint")}
            </Text>
          )}
          <View style={styles.tamagotchiCleanProgressGroup}>
            <View style={styles.tamagotchiCleanProgressRow}>
              <Text style={[styles.tamagotchiCleanProgressLabel, { color: colors.muted }]}>
                {t("tamagotchiCleanStageSoap")}
              </Text>
              <Text style={[styles.tamagotchiCleanProgressValue, { color: colors.text }]}>
                {Math.round(tamagotchiSoapProgressPercent)}%
              </Text>
            </View>
            <View style={[styles.tamagotchiProgress, { backgroundColor: colors.border }]}>
              <View
                style={[
                  styles.tamagotchiProgressFill,
                  {
                    width: `${Math.max(8, tamagotchiSoapProgressPercent)}%`,
                    backgroundColor: "#7CC7FF",
                  },
                ]}
              />
            </View>
            <View style={styles.tamagotchiCleanProgressRow}>
              <Text style={[styles.tamagotchiCleanProgressLabel, { color: colors.muted }]}>
                {t("tamagotchiCleanStageBrush")}
              </Text>
              <Text style={[styles.tamagotchiCleanProgressValue, { color: colors.text }]}>
                {Math.round(tamagotchiBrushProgressPercent)}%
              </Text>
            </View>
            <View style={[styles.tamagotchiProgress, { backgroundColor: colors.border }]}>
              <View
                style={[
                  styles.tamagotchiProgressFill,
                  {
                    width: `${Math.max(8, tamagotchiBrushProgressPercent)}%`,
                    backgroundColor: "#99E18E",
                  },
                ]}
              />
            </View>
          </View>
        </View>
      </ScrollView>
    );
  };
  const tamagotchiTabItems = useMemo(
    () => [
      { id: "food", label: t("tamagotchiTabFood"), title: t("tamagotchiFoodMenuTitle") },
      { id: "games", label: t("tamagotchiTabPlay"), title: t("tamagotchiPlayMenuTitle") },
      { id: "clean", label: t("tamagotchiTabClean"), title: t("tamagotchiCleanMenuTitle") },
    ],
    [t]
  );
  const activeTamagotchiTabTitle =
    tamagotchiTabItems.find((tab) => tab.id === tamagotchiActiveTab)?.title ||
    t("tamagotchiFoodMenuTitle");
  const renderTamagotchiTabContent = () => {
    if (tamagotchiActiveTab === "games") return renderTamagotchiToyList();
    if (tamagotchiActiveTab === "clean") return renderTamagotchiCleanPanel();
    return renderTamagotchiFoodList();
  };

  const handleMascotAnimationComplete = useCallback(() => {
    mascotBusyRef.current = false;
    if (!overlay && mascotQueueRef.current.length) {
      const next = mascotQueueRef.current.shift();
      if (next) {
        mascotBusyRef.current = true;
        setMascotOverride({ ...next, key: Date.now() });
        return;
      }
    }
    setMascotOverride(null);
  }, [overlay]);

  const dismissStormEffect = useCallback(() => {
    if (stormTimerRef.current) {
      clearTimeout(stormTimerRef.current);
      stormTimerRef.current = null;
    }
    setStormActive(false);
  }, []);
  const triggerStormEffect = useCallback(() => {
    if (stormTimerRef.current) {
      clearTimeout(stormTimerRef.current);
    }
    setStormActive(true);
    setTimeout(() => playSound("thunder"), 120);
    stormTimerRef.current = setTimeout(() => {
      stormTimerRef.current = null;
      setStormActive(false);
    }, STORM_OVERLAY_DURATION_MS);
  }, [playSound]);
  const stormActivePrevRef = useRef(false);
  useEffect(() => {
    const wasActive = stormActivePrevRef.current;
    if (wasActive && !stormActive) {
      queueUsageStreakOverlay("spend");
    }
    stormActivePrevRef.current = stormActive;
  }, [queueUsageStreakOverlay, stormActive]);
  const recordTemptationInteraction = useCallback(
    (templateId, actionType, item = null, amountUSD = null) => {
      if (!templateId && !item?.id && !item?.templateId) return;
      if (actionType !== "save" && actionType !== "spend") return;
      dismissPotentialGrowth();
      const resolvedTitle = item
        ? resolveTemptationTitle(item, language)
        : null;
      setTemptationInteractions((prev) => {
        const baseKey = normalizeTemplateKey(templateId);
        const itemIdKey = normalizeTemplateKey(item?.id);
        const itemTemplateKey = normalizeTemplateKey(item?.templateId);
        const candidateKeys = [baseKey, itemIdKey, itemTemplateKey].filter(Boolean);
        if (!candidateKeys.length) return prev;
        const primaryKey = candidateKeys[0];
        const prevEntry = prev?.[primaryKey] || {};
        const now = Date.now();
        const lastInteractionAt = prevEntry.lastInteractionAt || null;
        const priorInteractionAt = prevEntry.previousInteractionAt || null;
        const secondPriorInteractionAt = prevEntry.secondPreviousInteractionAt || null;
        const detectedIntervalMs = prevEntry.detectedIntervalMs || null;
        let frequency = normalizeFrequencyId(prevEntry.frequency) || null;
        let frequencyCustom = normalizeCustomFrequency(prevEntry.frequencyCustom) || null;
        const itemFrequency = normalizeFrequencyId(item?.frequency) || null;
        const itemCustomFrequency = normalizeCustomFrequency(item?.frequencyCustom || item?.customFrequency) || null;
        if (!frequency && itemFrequency) {
          frequency = itemFrequency;
        }
        if (frequency === "biweekly") {
          frequency = "custom";
          frequencyCustom = { count: 2, unit: "week" };
        }
        if (frequency === "custom" && !frequencyCustom && itemCustomFrequency) {
          frequencyCustom = itemCustomFrequency;
        }
        const previousIntervalValue =
          Number.isFinite(prevEntry.intervalMs) && prevEntry.intervalMs > 0 ? prevEntry.intervalMs : null;
        const customIntervalMs =
          frequency === "custom" ? getCustomFrequencyIntervalMs(frequencyCustom) : null;
        const frequencyIntervalMs =
          frequency && frequency !== "custom" ? getFrequencyIntervalMs(frequency) : null;
        const resolvedIntervalMs =
          (Number.isFinite(customIntervalMs) && customIntervalMs > 0
            ? customIntervalMs
            : Number.isFinite(frequencyIntervalMs) && frequencyIntervalMs > 0
            ? frequencyIntervalMs
            : previousIntervalValue || DAILY_FREQUENCY_INTERVAL_MS);
        const intervalMs = frequency === "custom" ? customIntervalMs || previousIntervalValue || null : null;
        const nextCheckAt = Number.isFinite(resolvedIntervalMs) ? now + resolvedIntervalMs : null;
        const normalizedAmount = Number(amountUSD);
        const resolvedAmount =
          Number.isFinite(normalizedAmount) && normalizedAmount > 0
            ? normalizedAmount
            : Number.isFinite(Number(prevEntry.lastAmountUSD)) && Number(prevEntry.lastAmountUSD) > 0
            ? Number(prevEntry.lastAmountUSD)
            : null;
        const nextEntry = {
          ...(prevEntry || {}),
          saveCount: (prevEntry.saveCount || 0) + (actionType === "save" ? 1 : 0),
          spendCount: (prevEntry.spendCount || 0) + (actionType === "spend" ? 1 : 0),
          lastInteractionAt: now,
          previousInteractionAt: lastInteractionAt || priorInteractionAt || null,
          secondPreviousInteractionAt: priorInteractionAt || secondPriorInteractionAt || null,
          detectedIntervalMs,
          frequency: frequency || null,
          frequencyCustom: frequency === "custom" ? frequencyCustom || null : null,
          intervalMs: intervalMs || null,
          nextCheckAt: nextCheckAt || null,
          lastTimerResetAt: now,
          missedCycles: 0,
          templateTitle: resolvedTitle || prevEntry.templateTitle || null,
          lastAmountUSD: resolvedAmount,
        };
        if (frequency && nextCheckAt) {
          nextEntry.frequencyReminderScheduledAt = null;
          nextEntry.frequencyReminderLocale = null;
          nextEntry.frequencyReminderId = null;
          nextEntry.frequencyReminderIds = [];
          nextEntry.frequencyReminderPlanKey = null;
        } else if (!frequency) {
          nextEntry.frequencyReminderScheduledAt = null;
          nextEntry.frequencyReminderLocale = null;
          nextEntry.frequencyReminderId = null;
          nextEntry.frequencyReminderIds = [];
          nextEntry.frequencyReminderPlanKey = null;
        } else {
          nextEntry.frequencyReminderScheduledAt = prevEntry.frequencyReminderScheduledAt || null;
          nextEntry.frequencyReminderLocale = prevEntry.frequencyReminderLocale || null;
        }
        const nextMap = { ...(prev || {}) };
        candidateKeys.forEach((key) => {
          nextMap[key] = nextEntry;
        });
        return nextMap;
      });
    },
    [dismissPotentialGrowth, language]
  );
  const normalizeTemplateKey = (value) => {
    if (typeof value === "number" && Number.isFinite(value)) {
      return String(value);
    }
    if (typeof value !== "string") return null;
    const trimmed = value.trim();
    return trimmed.length ? trimmed : null;
  };
  const resolveTemptationTemplateId = useCallback(
    (item, fallbackId = null) => {
      const fallback = normalizeTemplateKey(fallbackId);
      if (fallback) return fallback;
      const templateProp = normalizeTemplateKey(item?.templateId);
      if (templateProp) return templateProp;
      const itemId = normalizeTemplateKey(item?.id);
      if (itemId) return itemId;
      if (isCustomTemptation(item)) {
        const customId = normalizeTemplateKey(profile.customSpend?.id);
        return customId || "custom_habit";
      }
      return null;
    },
    [profile.customSpend]
  );
  const buildLegacyTemplateKeys = useCallback(
    (templateId, item = null) => {
      const keys = [];
      const pushKey = (value) => {
        if (typeof value !== "string") return;
        const normalized = value.trim();
        if (!normalized || keys.includes(normalized)) return;
        keys.push(normalized);
      };
      const normalizedTemplateId = normalizeTemplateKey(templateId);
      const normalizedItemId = normalizeTemplateKey(item?.id);
      const normalizedItemTemplateId = normalizeTemplateKey(item?.templateId);
      const candidateIds = [normalizedTemplateId, normalizedItemId, normalizedItemTemplateId].filter(Boolean);
      const idLooksCustom = candidateIds.some(
        (value) => typeof value === "string" && value.startsWith("custom_habit_")
      );
      const quickCustom = Boolean(
        item &&
          (item.quickTemptation ||
            item.quickCreate ||
            item.origin === "quick_custom" ||
            item.source === "quick_custom")
      );
      const isQuickCustom = quickCustom || idLooksCustom;
      if (typeof templateId === "string" && templateId.trim()) {
        pushKey(templateId);
      }
      if (item?.templateId) {
        pushKey(item.templateId);
      }
      if (item?.id && item.id !== templateId) {
        pushKey(item.id);
      }
      if (isCustomTemptation(item) && !isQuickCustom) {
        const primaryCustomId = normalizeTemplateKey(profile.customSpend?.id);
        const matchesPrimary =
          primaryCustomId && candidateIds.some((value) => value === primaryCustomId);
        const matchesDefaultLegacy =
          !primaryCustomId &&
          candidateIds.some(
            (value) => value === "custom_habit" || value === "custom" || value === "custom_temptation"
          );
        if (matchesPrimary || matchesDefaultLegacy) {
          if (primaryCustomId) {
            pushKey(primaryCustomId);
          }
          pushKey("custom_habit");
          pushKey("undefined");
        }
      }
      return keys;
    },
    [profile.customSpend]
  );
      const ensureGoalWishExists = useCallback(
        (wishId) => {
          if (!wishId || typeof wishId !== "string") return false;
          if (!wishId.startsWith("wish_primary_goal_")) return false;
          const goalId = wishId.replace("wish_primary_goal_", "");
          const primaryEntries = Array.isArray(profile.primaryGoals) ? profile.primaryGoals : [];
          const primaryEntry = primaryEntries.find((entry) => entry?.id === goalId);
          const canFallbackToProfileGoal = profile.goal === goalId;
          if (!primaryEntry && !canFallbackToProfileGoal) return false;
          const fallbackTargetUSD =
            profile.goal === goalId &&
            Number.isFinite(profile.goalTargetUSD) &&
            profile.goalTargetUSD > 0
              ? profile.goalTargetUSD
              : getGoalDefaultTargetUSD(goalId);
          const ensuredEntry =
            primaryEntry || {
              id: goalId,
              targetUSD: fallbackTargetUSD,
              savedUSD: 0,
              status: "active",
              createdAt: Date.now(),
            };
          setWishes((prev) => {
            if (prev.some((wish) => wish?.id === wishId)) return prev;
            const goalPreset = getGoalPreset(goalId);
            const languageKey = language || "en";
            const customTitle =
          typeof ensuredEntry?.customTitle === "string" ? ensuredEntry.customTitle.trim() : "";
        const hasCustomTitle = !!customTitle;
        const customEmoji = ensuredEntry?.customEmoji
          ? normalizeEmojiValue(ensuredEntry.customEmoji, DEFAULT_GOAL_EMOJI)
          : null;
        const resolvedEmoji =
          hasCustomTitle ? customEmoji || DEFAULT_GOAL_EMOJI : goalPreset?.emoji || DEFAULT_GOAL_EMOJI;
        const presetLabel = goalPreset?.[languageKey] || goalPreset?.en || goalId;
        const resolvedLabel = hasCustomTitle ? customTitle : presetLabel || goalId;
        const title = `${resolvedEmoji} ${resolvedLabel}`.trim();
        const targetUSD =
          Number.isFinite(ensuredEntry?.targetUSD) && ensuredEntry.targetUSD > 0
            ? ensuredEntry.targetUSD
            : getGoalDefaultTargetUSD(goalId);
        const createdAt = ensuredEntry?.createdAt || Date.now();
        const nextWish = {
          id: wishId,
          templateId: `goal_${goalId}`,
          title,
          emoji: resolvedEmoji,
          targetUSD,
          savedUSD: 0,
          status: "active",
          createdAt,
          autoManaged: true,
          kind: PRIMARY_GOAL_KIND,
          goalId,
        };
        return [nextWish, ...prev];
      });
      return true;
    },
    [language, profile.goal, profile.goalTargetUSD, profile.primaryGoals, setWishes]
  );
  const getLegacyRefuseStatsEntry = useCallback(
    (stats, templateId, item = null) => {
      if (!stats || typeof stats !== "object") {
        return { entry: null, key: templateId || null };
      }
      const keysToCheck = buildLegacyTemplateKeys(templateId, item);
      for (let index = 0; index < keysToCheck.length; index += 1) {
        const key = keysToCheck[index];
        if (!key) continue;
        if (Object.prototype.hasOwnProperty.call(stats, key)) {
          return { entry: stats[key], key };
        }
      }
      return { entry: null, key: templateId || null };
    },
    [buildLegacyTemplateKeys]
  );
  const queueCoinValueModal = useCallback(() => {
    const currentStatus = coinValueModalStatusRef.current;
    if (
      currentStatus === COIN_VALUE_MODAL_STATUS.SHOWN ||
      currentStatus === COIN_VALUE_MODAL_STATUS.PENDING
    ) {
      return;
    }
    coinValueModalStatusRef.current = COIN_VALUE_MODAL_STATUS.PENDING;
    setCoinValueModalStatus(COIN_VALUE_MODAL_STATUS.PENDING);
    AsyncStorage.setItem(
      STORAGE_KEYS.COIN_VALUE_MODAL,
      COIN_VALUE_MODAL_STATUS.PENDING
    ).catch(() => {});
  }, []);
  const priceEditorTemplateId = priceEditor.item ? resolveTemptationTemplateId(priceEditor.item) : null;
  const priceEditorAssignedGoalId = priceEditorTemplateId
    ? resolveTemptationGoalId(priceEditorTemplateId)
    : null;
  const priceEditorAssignedGoal =
    priceEditorAssignedGoalId &&
    (wishes || []).find((wish) => wish.id === priceEditorAssignedGoalId);
  const priceEditorAssignedGoalTitle = priceEditorAssignedGoal
    ? getWishTitleWithoutEmoji(priceEditorAssignedGoal)
    : "";
  const goalLinkTemplateId = goalLinkPrompt.item ? resolveTemptationTemplateId(goalLinkPrompt.item) : null;
  const goalLinkCurrentGoalId = goalLinkTemplateId ? resolveTemptationGoalId(goalLinkTemplateId) : null;
  const executeSpend = useCallback(
    (item, overrideAmountUSD = null) => {
      if (!item) return;
      const templateId = resolveTemptationTemplateId(item);
      const overrideAmount = parseAmountValue(overrideAmountUSD);
      const rawPriceUSD =
        item?.priceUSD ??
        item?.basePriceUSD ??
        item?.amountUSD ??
        item?.amount ??
        item?.amountLocal ??
        0;
      const normalizedPriceUSD = parseAmountValue(rawPriceUSD);
      let priceUSD =
        normalizedPriceUSD > 0
          ? normalizedPriceUSD
          : isCustomTemptation(item)
          ? resolveCustomPriceUSD(item, profile.currency || DEFAULT_PROFILE.currency)
          : 0;
      if (priceUSD <= 0 && isCustomTemptation(item) && profile.customSpend) {
        priceUSD = resolveCustomPriceUSD(
          profile.customSpend,
          profile.currency || DEFAULT_PROFILE.currency
        );
      }
      if (overrideAmount > 0) {
        priceUSD = overrideAmount;
      }
      const title = `${item.emoji || "âœ¨"} ${
        item.title?.[language] || item.title?.en || item.title || "goal"
      }`;
      const spendCategory = resolveTemptationCategory(item);
      const isEssentialSpendCategory = isEssentialImpulseCategory(spendCategory);
      if (!isEssentialSpendCategory) {
        registerFocusLoss(item);
      }
      handleFocusSpend(item);
      logHistoryEvent("spend", {
        title,
        amountUSD: priceUSD,
        templateId: templateId || item.id,
        category: spendCategory,
      });
      registerUsageStreakAction("spend", Date.now());
      triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
      if (spendReducesSavings) {
        setSavedTotalUSD((prev) => Math.max(prev - priceUSD, 0));
        setProgressSavedTotalUSD((prev) => Math.max(prev - priceUSD, 0));
      }
      setPurchases((prev) => [
        {
          id: `spend-${item.id}-${Date.now()}`,
          title,
          price: priceUSD,
          paidAmount: priceUSD,
          createdAt: Date.now(),
        },
        ...prev,
      ]);
      setFreeDayStats((prev) => {
        const todayKey = getDayKey(Date.now());
        if (!prev) {
          return { ...INITIAL_FREE_DAY_STATS, blockedDate: todayKey };
        }
        if (prev.blockedDate === todayKey && prev.current === 0) {
          return prev;
        }
        const next = {
          ...prev,
          current: 0,
          blockedDate: todayKey,
        };
        return next;
      });
      if (!isEssentialSpendCategory) {
        logImpulseEvent("spend", item, priceUSD, title);
        requestMascotAnimation(Math.random() > 0.5 ? "sad" : "ohno");
      }
      recordTemptationInteraction(templateId || item.id, "spend", item, priceUSD);
      if (!isEssentialSpendCategory) {
        queueHomeSpeech("spend");
      }
    },
    [
      handleFocusSpend,
      language,
      queueHomeSpeech,
      resolveTemptationTemplateId,
      logHistoryEvent,
      logImpulseEvent,
      recordTemptationInteraction,
      registerFocusLoss,
      registerUsageStreakAction,
      requestMascotAnimation,
      setFreeDayStats,
      setSavedTotalUSD,
      setProgressSavedTotalUSD,
      resolveTemptationCategory,
      spendReducesSavings,
    ]
  );

  const handleSpendConfirm = useCallback(() => {
    if (!spendPrompt.item || spendExecutionLockRef.current) return;
    const item = spendPrompt.item;
    const amountUSD = spendPrompt.amountUSD;
    spendExecutionLockRef.current = true;
    closeSpendPrompt();
    triggerStormEffect();
    try {
      executeSpend(item, amountUSD);
    } finally {
      spendExecutionLockRef.current = false;
    }
  }, [closeSpendPrompt, executeSpend, spendPrompt.amountUSD, spendPrompt.item, triggerStormEffect]);

  const buildTemptationPayload = useCallback(
    (item, extra = {}) => {
      const priceUSD = Number(item.priceUSD ?? item.basePriceUSD ?? 0) || 0;
      return {
        item_id: item.id,
        price_usd: priceUSD,
        categories: (item.categories || []).join(","),
        persona: profile.persona || "unknown",
        currency: profile.currency || DEFAULT_PROFILE.currency,
        ...extra,
      };
    },
    [profile.currency, profile.persona]
  );

  const recordRatingPromptAction = useCallback(
    (action) => {
      if (!ratingPromptHydrated) return;
      if (!RATING_PROMPT_ACTION_TYPES.has(action)) return;
      updateRatingPromptState((prev) => {
        if (prev.completed || prev.actionPrompted) return prev;
        const nextCount = Math.max(0, Number(prev.actionCount) || 0) + 1;
        const hasBase = Number.isFinite(prev.actionCountStart);
        const nextBase = hasBase
          ? prev.actionCountStart
          : ratingPromptActionGateReady
          ? Math.max(0, Number(prev.actionCount) || 0)
          : prev.actionCountStart;
        return { ...prev, actionCount: nextCount, actionCountStart: nextBase };
      });
    },
    [ratingPromptActionGateReady, ratingPromptHydrated, updateRatingPromptState]
  );

  const logTemptationAction = useCallback(
    (action, item, extra = {}) => {
      if (!item || !action) return;
      recordRatingPromptAction(action);
      maybeLogDayMilestone(action);
      logEvent("temptation_action", buildTemptationPayload(item, { action, ...extra }));
    },
    [buildTemptationPayload, maybeLogDayMilestone, recordRatingPromptAction]
  );

  const scheduleImpulseReminder = useCallback(
    async (event) => {
      if (!event || !event.timestamp) return;
      const now = Date.now();
      const eventTimestamp = Number(event.timestamp);
      if (!Number.isFinite(eventTimestamp)) return;
      if (isEssentialImpulseCategory(event.category)) return;
      if (now - eventTimestamp > RECENT_EVENT_NOTIFICATION_WINDOW_MS) return;
      const triggerAt = getImpulseReminderTimestamp(eventTimestamp);
      if (!triggerAt) return;
      if (triggerAt - now < IMPULSE_REMINDER_MIN_DELAY_MS) return;
      const allowed = await ensureNotificationPermission({ request: false });
      if (!allowed) return;
      const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
      const amountLabel = formatCurrency(
        convertToCurrency(Math.max(event.amountUSD || 0, 0), currencyCode),
        currencyCode
      );
      const resolvedTemplateTitle = event.templateId
        ? resolveTemplateTitle(event.templateId, event.title || t("defaultDealTitle"))
        : event.title || t("defaultDealTitle");
      const templateTitle = resolvedTemplateTitle || t("defaultDealTitle");
      const dedupeKey = `impulse_reminder:${event.id || event.templateId || Date.now()}`;
      const dayLabel =
        formatRelativeDayLabel(eventTimestamp, triggerAt, language) ||
        formatRelativeDayLabel(eventTimestamp, now, language) ||
        (normalizeLanguage(language) === "ru"
          ? "Ð²Ñ‡ÐµÑ€Ð°"
          : normalizeLanguage(language) === "es"
          ? "ayer"
          : normalizeLanguage(language) === "fr"
          ? "hier"
          : "yesterday");
      const content =
        event.action === "save"
          ? {
              title: t("impulseReminderWinTitle", { temptation: templateTitle }),
              body: t("impulseReminderWinBody", { amount: amountLabel, dayLabel }),
            }
          : {
              title: t("impulseReminderLoseTitle", { temptation: templateTitle, dayLabel }),
              body: t("impulseReminderLoseBody", { amount: amountLabel }),
            };
      try {
        await scheduleNotificationWithCooldown({
          content: {
            ...content,
            data: {
              kind: "impulse_reminder",
              templateId: event.templateId || null,
              title: templateTitle,
              emoji: event.emoji || "âœ¨",
              amountUSD: Number(event.amountUSD) || 0,
              eventTimestamp,
              dedupeKey,
            },
            categoryIdentifier: ACTIONABLE_NOTIFICATION_CATEGORY_ID,
          },
          trigger: new Date(triggerAt),
        });
      } catch (error) {
        console.warn("impulse reminder schedule", error);
      }
    },
    [ensureNotificationPermission, profile.currency, resolveTemplateTitle, scheduleNotificationWithCooldown, t]
  );

  const logImpulseEvent = useCallback(
    (action, item, amountUSD = 0, overrideTitle = null) => {
      if (!item || (action !== "save" && action !== "spend")) return;
      const category = resolveImpulseCategory(item);
      if (isEssentialImpulseCategory(category)) return;
      const timestamp = Date.now();
      const entryTitle =
        overrideTitle ||
        `${item.emoji || "âœ¨"} ${
          item.title?.[language] || item.title?.en || item.title || t("defaultDealTitle")
        }`;
      const eventTemplateId = resolveTemptationTemplateId(item) || item.id;
      const event = {
        id: `impulse-${timestamp}-${Math.random().toString(16).slice(2, 6)}`,
        templateId: eventTemplateId,
        title: entryTitle,
        emoji: item.emoji || "âœ¨",
        category,
        action,
        amountUSD: amountUSD || item.priceUSD || item.basePriceUSD || 0,
        timestamp,
        hour: new Date(timestamp).getHours(),
      };
      setImpulseTracker((prev) => {
        const nextEvents = [event, ...(prev?.events || [])].slice(0, MAX_IMPULSE_EVENTS);
        return {
          ...(prev || INITIAL_IMPULSE_TRACKER),
          events: nextEvents,
        };
      });
      scheduleImpulseReminder(event);
    },
    [language, resolveTemptationTemplateId, scheduleImpulseReminder, t]
  );

  const resyncPushNotificationsForLanguage = useCallback(
    async () => {
      if (notificationPermissionGranted !== true) return;
      if (pendingHydrated) {
        const pendingItems = Array.isArray(pendingListRef.current) ? pendingListRef.current : [];
        if (pendingItems.length) {
          const updates = new Map();
          for (const item of pendingItems) {
            if (!item?.id) continue;
            if (item?.notificationId) {
              try {
                await safeNotifications.cancelScheduledNotificationAsync(item.notificationId);
              } catch (error) {
                console.warn("pending reminder cancel", error);
              }
            }
            const dueTimestamp = Number(item?.decisionDue) || 0;
            if (!Number.isFinite(dueTimestamp) || dueTimestamp <= Date.now()) {
              updates.set(item.id, null);
              continue;
            }
            const template = item?.templateId ? findTemplateById(item.templateId) : null;
            const resolvedTitle =
              resolveTemplateTitle(item?.templateId, item?.title || t("defaultDealTitle")) ||
              item?.title ||
              t("defaultDealTitle");
            const reminderId = await schedulePendingReminder(resolvedTitle, dueTimestamp, {
              pendingId: item.id,
              templateId: item?.templateId || null,
              title: resolvedTitle,
              emoji: item?.emoji || template?.emoji || DEFAULT_TEMPTATION_EMOJI,
              amountUSD: Number(item?.priceUSD) || Number(template?.basePriceUSD) || 0,
            });
            updates.set(item.id, reminderId || null);
          }
          if (updates.size) {
            setPendingList((prev) =>
              (Array.isArray(prev) ? prev : []).map((entry) =>
                updates.has(entry.id)
                  ? { ...entry, notificationId: updates.get(entry.id) }
                  : entry
              )
            );
          }
        }
      }

      if (challengesHydrated) {
        const updates = new Map();
        const entries = Object.entries(challengesState || {});
        for (const [challengeId, entry] of entries) {
          if (!entry || entry.status !== CHALLENGE_STATUS.ACTIVE) continue;
          const def = CHALLENGE_DEF_MAP[challengeId];
          if (!def) continue;
          const existingIds = Array.isArray(entry.reminderNotificationIds)
            ? entry.reminderNotificationIds
            : [];
          if (existingIds.length) {
            await Promise.all(
              existingIds.map((id) =>
                safeNotifications.cancelScheduledNotificationAsync(id).catch(() => {})
              )
            );
          }
          const reminderIds = await scheduleChallengeReminders(
            challengeId,
            def,
            entry.startedAt,
            entry.expiresAt
          );
          updates.set(challengeId, reminderIds);
        }
        if (updates.size) {
          setChallengesState((prev) => {
            const next = { ...(prev || {}) };
            updates.forEach((ids, challengeId) => {
              if (!next[challengeId]) return;
              next[challengeId] = {
                ...next[challengeId],
                reminderNotificationIds: ids,
              };
            });
            return next;
          });
        }
      }

      if (smartRemindersHydrated) {
        const reminders = Array.isArray(smartRemindersRef.current) ? smartRemindersRef.current : [];
        if (reminders.length) {
          for (const reminder of reminders) {
            if (!reminder?.notificationId) continue;
            try {
              await safeNotifications.cancelScheduledNotificationAsync(reminder.notificationId);
            } catch (error) {
              console.warn("smart reminder cancel", error);
            }
          }
          const now = Date.now();
          const updates = new Map();
          const sorted = reminders
            .slice()
            .sort((a, b) => (Number(a.scheduledAt) || 0) - (Number(b.scheduledAt) || 0));
          for (const reminder of sorted) {
            if (!reminder?.id) continue;
            const scheduledAt = Number(reminder.scheduledAt);
            if (!Number.isFinite(scheduledAt) || scheduledAt <= now) {
              updates.set(reminder.id, null);
              continue;
            }
            const resolvedTitle =
              resolveTemplateTitle(reminder.templateId, reminder.title || t("defaultDealTitle")) ||
              reminder.title ||
              t("defaultDealTitle");
            const isSpendEvent = reminder.kind === "spend";
            const reminderTimestamp = Number(reminder.timestamp);
            const normalizedLanguage = normalizeLanguage(language);
            const dayLabel =
              formatRelativeDayLabel(reminderTimestamp, scheduledAt, normalizedLanguage) ||
              formatRelativeDayLabel(reminderTimestamp, now, normalizedLanguage) ||
              (normalizedLanguage === "ru"
                ? "Ð²Ñ‡ÐµÑ€Ð°"
                : normalizedLanguage === "es"
                ? "ayer"
                : normalizedLanguage === "fr"
                ? "hier"
                : "yesterday");
            const dedupeKey = `smart:${reminder.eventId || reminder.id}`;
            try {
              const scheduledId = await safeNotifications.scheduleNotificationAsync({
                content: {
                  title: isSpendEvent
                    ? t("smartInsightSpendTitle", { temptation: resolvedTitle, dayLabel })
                    : t("smartInsightDeclineTitle", { temptation: resolvedTitle, dayLabel }),
                  body: isSpendEvent
                    ? t("smartInsightSpendBody", { temptation: resolvedTitle })
                    : t("smartInsightDeclineBody", { temptation: resolvedTitle }),
                  data: {
                    kind: "smart_insight",
                    templateId: reminder.templateId || null,
                    eventTimestamp: Number(reminder.timestamp) || 0,
                    dedupeKey,
                  },
                },
                trigger: new Date(scheduledAt),
              });
              updates.set(reminder.id, scheduledId || null);
            } catch (error) {
              console.warn("smart reminder reschedule", error);
              updates.set(reminder.id, null);
            }
          }
          if (updates.size) {
            setSmartReminders((prev) =>
              normalizeSmartReminderEntries(
                (Array.isArray(prev) ? prev : []).map((entry) =>
                  updates.has(entry.id)
                    ? { ...entry, notificationId: updates.get(entry.id) }
                    : entry
                )
              )
            );
          }
        }
      }

      const shouldScanScheduled = impulseTrackerHydrated || dailySummaryUnlocked;
      let scheduled = [];
      if (shouldScanScheduled) {
        try {
          const list = await safeNotifications.getAllScheduledNotificationsAsync();
          scheduled = Array.isArray(list) ? list : [];
        } catch (error) {
          console.warn("scheduled notifications resync", error);
        }
      }

      if (impulseTrackerHydrated) {
        const impulseIds = scheduled
          .filter((entry) => entry?.content?.data?.kind === "impulse_reminder")
          .map((entry) => entry?.identifier || entry?.id)
          .filter(Boolean);
        if (impulseIds.length) {
          await Promise.all(
            impulseIds.map((id) =>
              safeNotifications.cancelScheduledNotificationAsync(id).catch(() => {})
            )
          );
        }
        const events = Array.isArray(impulseTracker?.events)
          ? impulseTracker.events.slice()
          : [];
        events.sort((a, b) => (Number(a.timestamp) || 0) - (Number(b.timestamp) || 0));
        for (const event of events) {
          await scheduleImpulseReminder(event);
        }
      }

      if (dailySummaryUnlocked && scheduled.length) {
        const summaryEntries = scheduled.filter(
          (entry) => entry?.content?.data?.kind === "daily_summary"
        );
        for (const entry of summaryEntries) {
          const entryId = entry?.identifier || entry?.id;
          if (entryId) {
            try {
              await safeNotifications.cancelScheduledNotificationAsync(entryId);
            } catch (error) {
              console.warn("daily summary cancel", error);
            }
          }
          const data = entry?.content?.data || {};
          const trigger = entry?.trigger || null;
          const scheduledAt = resolveNotificationTriggerTime(trigger);
          if (!Number.isFinite(scheduledAt) || scheduledAt <= Date.now()) {
            continue;
          }
          const todayKey = typeof data.todayKey === "string" ? data.todayKey : null;
          if (!todayKey) continue;
          const savedUSD = Math.max(0, Number(data.savedUSD) || 0);
          const declines = Math.max(0, Number(data.declines) || 0);
          const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
          const savedLabel = formatCurrency(
            convertToCurrency(savedUSD, currencyCode),
            currencyCode
          );
          try {
            await safeNotifications.scheduleNotificationAsync({
              content: {
                title: t("dailySummaryNotificationTitle"),
                body: t("dailySummaryNotificationBody", { saved: savedLabel, declines }),
                data: {
                  ...data,
                  kind: "daily_summary",
                  targetScreen: "daily_summary",
                  dedupeKey: data.dedupeKey || `daily_summary_${todayKey}`,
                },
              },
              trigger,
            });
          } catch (error) {
            console.warn("daily summary reschedule", error);
          }
        }
      }
    },
    [
      challengesHydrated,
      challengesState,
      dailySummaryUnlocked,
      convertToCurrency,
      findTemplateById,
      formatCurrency,
      impulseTracker,
      impulseTrackerHydrated,
      language,
      notificationPermissionGranted,
      normalizeSmartReminderEntries,
      pendingHydrated,
      profile.currency,
      resolveNotificationTriggerTime,
      resolveTemplateTitle,
      scheduleChallengeReminders,
      scheduleImpulseReminder,
      schedulePendingReminder,
      setChallengesState,
      setPendingList,
      setSmartReminders,
      smartRemindersHydrated,
      t,
    ]
  );

  useEffect(() => {
    if (!languageHydrated) return;
    const normalizedLanguage = normalizeLanguage(language);
    if (pushLocaleRef.current === null) {
      pushLocaleRef.current = normalizedLanguage;
      return;
    }
    if (pushLocaleRef.current === normalizedLanguage) return;
    pushLocaleRef.current = normalizedLanguage;
    resyncPushNotificationsForLanguage().catch((error) => {
      console.warn("push locale resync", error);
    });
  }, [language, languageHydrated, resyncPushNotificationsForLanguage]);

  const buildPrimaryGoalWishSnapshot = useCallback(
    (wishId) => {
      if (!wishId || typeof wishId !== "string") return null;
      const existing = wishes.find((wish) => wish?.id === wishId);
      if (existing) return existing;
      if (!wishId.startsWith("wish_primary_goal_")) return null;
      const goalId = wishId.replace("wish_primary_goal_", "");
      const primaryEntry = Array.isArray(profile.primaryGoals)
        ? profile.primaryGoals.find((entry) => entry?.id === goalId)
        : null;
      const preset = getGoalPreset(goalId);
      const customTitle =
        typeof primaryEntry?.customTitle === "string" ? primaryEntry.customTitle.trim() : "";
      const customEmoji = primaryEntry?.customEmoji
        ? normalizeEmojiValue(primaryEntry.customEmoji, DEFAULT_GOAL_EMOJI)
        : null;
      const label = customTitle || preset?.[language] || preset?.en || goalId;
      const emoji = customTitle
        ? customEmoji || DEFAULT_GOAL_EMOJI
        : preset?.emoji || DEFAULT_GOAL_EMOJI;
      const targetUSD =
        Number.isFinite(primaryEntry?.targetUSD) && primaryEntry.targetUSD > 0
          ? primaryEntry.targetUSD
          : profile.goal === goalId &&
            Number.isFinite(profile.goalTargetUSD) &&
            profile.goalTargetUSD > 0
          ? profile.goalTargetUSD
          : getGoalDefaultTargetUSD(goalId);
      const savedUSD = Number.isFinite(primaryEntry?.savedUSD) ? primaryEntry.savedUSD : 0;
      return {
        id: wishId,
        title: `${emoji} ${label}`.trim(),
        targetUSD,
        savedUSD,
        status: primaryEntry?.status || "active",
        kind: PRIMARY_GOAL_KIND,
        goalId,
      };
    },
    [language, profile.goal, profile.goalTargetUSD, profile.primaryGoals, wishes]
  );

  const handleTemptationAction = useCallback(
    async (type, item, options = {}) => {
      const {
        skipPrompt = false,
        goalId: forcedGoalId = null,
        shouldAssign = false,
        pinnedBy = null,
        bypassSpendPrompt = false,
        forcePrimaryGoal = false,
        amountUSD: overrideAmountUSD = null,
        skipSaveSpamCheck = false,
      } = options || {};
      playSound("tap");
      let resolvedForcedGoalId = forcedGoalId;
      if (
        typeof resolvedForcedGoalId === "string" &&
        !resolvedForcedGoalId.startsWith("wish_primary_goal_") &&
        Array.isArray(profile.primaryGoals) &&
        profile.primaryGoals.some((goal) => goal?.id === resolvedForcedGoalId)
      ) {
        resolvedForcedGoalId = getPrimaryGoalWishId(resolvedForcedGoalId);
      }
      const normalizeTargetGoalId = (goalId) => {
        if (
          typeof goalId === "string" &&
          !goalId.startsWith("wish_primary_goal_") &&
          Array.isArray(profile.primaryGoals) &&
          profile.primaryGoals.some((goal) => goal?.id === goalId)
        ) {
          return getPrimaryGoalWishId(goalId);
        }
        if (
          typeof goalId === "string" &&
          !goalId.startsWith("wish_primary_goal_") &&
          profile.goal === goalId
        ) {
          return getPrimaryGoalWishId(goalId);
        }
        return goalId;
      };
      const templateId = resolveTemptationTemplateId(item);
      const normalizedOverrideAmountUSD = parseAmountValue(overrideAmountUSD);
      const hasOverrideAmount =
        Number.isFinite(normalizedOverrideAmountUSD) && normalizedOverrideAmountUSD > 0;
      const rawPriceUSD =
        hasOverrideAmount
          ? normalizedOverrideAmountUSD
          : item?.priceUSD ??
            item?.basePriceUSD ??
            item?.amountUSD ??
            item?.amount ??
            item?.amountLocal ??
            0;
      const normalizedPriceUSD = parseAmountValue(rawPriceUSD);
      let priceUSD = normalizedPriceUSD > 0 ? normalizedPriceUSD : 0;
      if (priceUSD <= 0 && !hasOverrideAmount && isCustomTemptation(item)) {
        priceUSD = resolveCustomPriceUSD(item, profile.currency || DEFAULT_PROFILE.currency);
        if (priceUSD <= 0 && profile.customSpend) {
          priceUSD = resolveCustomPriceUSD(
            profile.customSpend,
            profile.currency || DEFAULT_PROFILE.currency
          );
        }
      }
      const title = `${item.emoji || "âœ¨"} ${
        item.title?.[language] || item.title?.en || item.title || "goal"
      }`;
      const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
      const priceLocal = convertToCurrency(priceUSD, currencyCode);
      const balanceLocal = convertToCurrency(savedTotalUSD, currencyCode);
      if (type === "maybe" && !thinkingUnlocked) {
        Alert.alert("Almost", t("thinkingLockedMessage"));
        return;
      }
      if (shouldPromptCategory(item, type, options)) {
        openCategoryPrompt(item, type, options);
        return;
      }
      if (type === "spend") {
        if (bypassSpendPrompt) {
          if (spendExecutionLockRef.current) return;
          spendExecutionLockRef.current = true;
        } else if (spendPromptLockRef.current) {
          return;
        } else {
          spendPromptLockRef.current = true;
        }
        dismissStormEffect();
        try {
          logTemptationAction("spend", item, { price_usd: priceUSD });
          logEvent(
            "temptation_spend",
            buildTemptationPayload(item, { total_saved_usd: savedTotalUSD, price_usd: priceUSD })
          );
          logEvent("temptation_decision", {
            temptation_id: templateId || item.id,
            decision: "spend",
            price: priceLocal,
            balance_before: balanceLocal,
          });
          if (bypassSpendPrompt) {
            triggerStormEffect();
            executeSpend(item, priceUSD);
          } else {
            setSpendPrompt({ visible: true, item, amountUSD: priceUSD });
          }
        } catch (error) {
          if (bypassSpendPrompt) {
            spendExecutionLockRef.current = false;
          } else {
            spendPromptLockRef.current = false;
          }
          throw error;
        }
        if (bypassSpendPrompt) {
          spendExecutionLockRef.current = false;
        }
        return;
      }
      if (type === "want") {
        logTemptationAction("wish", item);
        logEvent("temptation_want", buildTemptationPayload(item));
        const wishTemplateId = templateId || item.id || `custom_${Date.now()}`;
        const newWish = {
          id: `wish-${wishTemplateId}-${Date.now()}`,
          templateId: wishTemplateId,
          title,
          targetUSD: priceUSD,
          savedUSD: 0,
          status: "active",
          createdAt: Date.now(),
          autoManaged: false,
          emoji: item.emoji || DEFAULT_GOAL_EMOJI,
          pinnedSource: pinnedBy,
        };
        setWishes((prev) => insertWishAfterPrimary(prev, newWish));
        logHistoryEvent("wish_added", {
          title,
          targetUSD: priceUSD,
          templateId: wishTemplateId,
          wishId: newWish.id,
        });
        triggerOverlayState("purchase", t("wishAdded", { title }));
        triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
        return;
      }
      if (type === "save") {
        const { entry: resolvedRefuseStats } = getLegacyRefuseStatsEntry(refuseStats, templateId, item);
        const refuseStatsEntry = resolvedRefuseStats || {};
        const nextRefuseCount = (refuseStatsEntry.count || 0) + 1;
        const saveTimestamp = Date.now();
        const recentSaves = (Array.isArray(saveActionLogRef.current) ? saveActionLogRef.current : []).filter(
          (entry) => saveTimestamp - (Number(entry?.timestamp) || 0) <= SAVE_SPAM_WINDOW_MS
        );
        const nextSaveCount = recentSaves.length + 1;
        if (!skipSaveSpamCheck && nextSaveCount >= SAVE_SPAM_GLOBAL_LIMIT) {
          setSaveSpamPrompt({
            visible: true,
            item,
            options: {
              ...options,
              skipSaveSpamCheck: true,
            },
            recentCount: nextSaveCount,
          });
          logEvent("save_guard_triggered", {
            temptation_id: templateId || item?.id || null,
            save_count_5m: nextSaveCount,
            save_window_ms: SAVE_SPAM_WINDOW_MS,
          });
          triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
          playSound("tap", { skipCooldown: true });
          return;
        }
        const storedGoalId = resolveTemptationGoalId(templateId);
        let primaryGoalWishId = null;
        if (overlay?.type === "primary_temptation" || forcePrimaryGoal) {
          if (typeof activeGoalId === "string" && activeGoalId.startsWith("wish_primary_goal_")) {
            primaryGoalWishId = activeGoalId;
          } else if (
            typeof activeGoalId === "string" &&
            Array.isArray(profile.primaryGoals) &&
            profile.primaryGoals.some((goal) => goal?.id === activeGoalId)
          ) {
            primaryGoalWishId = getPrimaryGoalWishId(activeGoalId);
          } else if (mainGoalWish?.goalId) {
            primaryGoalWishId = getPrimaryGoalWishId(mainGoalWish.goalId);
          } else if (profile.goal) {
            primaryGoalWishId = getPrimaryGoalWishId(profile.goal);
          }
        }
        const normalizedStoredGoalId = normalizeTargetGoalId(storedGoalId);
        const desiredGoalId = normalizeTargetGoalId(
          resolvedForcedGoalId || primaryGoalWishId || normalizedStoredGoalId
        );
        const shouldPrompt =
          !skipPrompt && assignableGoals.length > 1 && !desiredGoalId;
        if (shouldPrompt) {
          setGoalLinkPrompt({
            visible: true,
            item,
            intent: "save",
            amountUSD: priceUSD,
          });
          return;
        }
        const activeFallbackGoalId = activeGoalId || profile.goal || null;
        let targetGoalId =
          desiredGoalId || normalizeTargetGoalId(activeFallbackGoalId) || getFallbackGoalId();
        if (!targetGoalId && assignableGoals.length === 0 && wishes.length > 0) {
          targetGoalId = wishes[0].id;
        }
        if (!targetGoalId) {
          const fallbackGoal = activeGoalId || profile.goal || null;
          if (fallbackGoal) {
            targetGoalId = normalizeTargetGoalId(fallbackGoal);
          }
        }
        // Always normalize to primary-goal wish ids when applicable and ensure target exists.
        let normalizedTargetGoalId = targetGoalId ? normalizeTargetGoalId(targetGoalId) : null;
        const resolveExistingGoalId = () => {
          const primaryActiveId =
            (profile.goal &&
              Array.isArray(profile.primaryGoals) &&
              profile.primaryGoals.some((g) => g?.id === profile.goal) &&
              getPrimaryGoalWishId(profile.goal)) ||
            null;
          const singleAssignableId =
            assignableGoals.length === 1 && assignableGoals[0]?.id ? assignableGoals[0].id : null;
          const candidates = [
            normalizedTargetGoalId,
            primaryActiveId,
            activeGoalId,
            mainGoalWish?.id,
            singleAssignableId,
            (wishes || []).find((wish) => wish.status !== "done")?.id,
            wishes?.[0]?.id,
          ].filter(Boolean);
          for (const candidate of candidates) {
            const matchesWish = wishes.some((wish) => wish?.id === candidate);
            const matchedPrimary =
              Array.isArray(profile.primaryGoals) &&
              profile.primaryGoals.find(
                (goal) =>
                  normalizeTargetGoalId(goal.id) === candidate || getPrimaryGoalWishId(goal.id) === candidate
              );
            if (matchesWish) {
              return candidate;
            }
            if (matchedPrimary) {
              return getPrimaryGoalWishId(matchedPrimary.id);
            }
            if (candidate.startsWith("wish_primary_goal_")) {
              return candidate;
            }
          }
          return null;
        };
        normalizedTargetGoalId = resolveExistingGoalId();
        if (
          normalizedTargetGoalId &&
          normalizedTargetGoalId.startsWith("wish_primary_goal_") &&
          !ensureGoalWishExists(normalizedTargetGoalId)
        ) {
          normalizedTargetGoalId = null;
        }
        if (!normalizedTargetGoalId) {
          const fallbackWishId =
            (wishes || []).find((wish) => wish.status !== "done")?.id || wishes?.[0]?.id || null;
          normalizedTargetGoalId = fallbackWishId ? normalizeTargetGoalId(fallbackWishId) : null;
          if (!normalizedTargetGoalId) {
            const primaryFallbackId =
              profile.goal || (Array.isArray(profile.primaryGoals) ? profile.primaryGoals[0]?.id : null) || null;
            if (primaryFallbackId) {
              const primaryWishId = getPrimaryGoalWishId(primaryFallbackId);
              if (ensureGoalWishExists(primaryWishId)) {
                normalizedTargetGoalId = primaryWishId;
              }
            }
          }
          if (!normalizedTargetGoalId) {
            const mainWishId = mainGoalWish?.id || null;
            if (mainWishId) {
              const normalizedMainWishId = normalizeTargetGoalId(mainWishId);
              if (
                normalizedMainWishId &&
                (!normalizedMainWishId.startsWith("wish_primary_goal_") ||
                  ensureGoalWishExists(normalizedMainWishId))
              ) {
                normalizedTargetGoalId = normalizedMainWishId;
              }
            }
          }
        }
        if (overlay?.type === "primary_temptation") {
          const activePrimaryId =
            profile.goal ||
            (Array.isArray(profile.primaryGoals) && profile.primaryGoals[0]?.id) ||
            null;
          const activePrimaryWishId = activePrimaryId ? getPrimaryGoalWishId(activePrimaryId) : null;
          if (activePrimaryWishId && normalizedTargetGoalId !== activePrimaryWishId) {
            normalizedTargetGoalId = activePrimaryWishId;
            ensureGoalWishExists(normalizedTargetGoalId);
            setActiveGoalId(activePrimaryId);
          }
        }
        if (
          __DEV__ &&
          type === "save" &&
          (overlay?.type === "primary_temptation" || isCustomTemptation(item))
        ) {
          console.warn("primary_temptation_save_debug", {
            priceUSD,
            targetGoalId,
            itemId: item?.id,
            templateId,
            hasWishMatch: wishes.some((wish) => wish?.id === targetGoalId),
            savedTotalUSD,
            heroGoalSavedUSD,
            heroGoalTargetUSD,
            overlayType: overlay?.type || null,
          });
        }
        const autoAssignSingleGoal =
          !storedGoalId && !resolvedForcedGoalId && assignableGoals.length === 1;
        const normalizedActiveFallbackGoalId = activeFallbackGoalId
          ? normalizeTargetGoalId(activeFallbackGoalId)
          : null;
        const shouldStoreGoal =
          normalizedTargetGoalId &&
          (shouldAssign ||
            !!primaryGoalWishId ||
            autoAssignSingleGoal ||
            (!storedGoalId &&
              !resolvedForcedGoalId &&
              normalizedActiveFallbackGoalId &&
              normalizedTargetGoalId === normalizedActiveFallbackGoalId) ||
            (!storedGoalId &&
              !resolvedForcedGoalId &&
              mainGoalWish?.id &&
              normalizedTargetGoalId === mainGoalWish.id));
        if (shouldStoreGoal) {
          assignTemptationGoal(templateId || item.id, normalizedTargetGoalId);
        }
        const targetWish = normalizedTargetGoalId
          ? wishes.find((wish) => wish.id === normalizedTargetGoalId)
          : null;
        const targetWishSnapshot = targetWish || buildPrimaryGoalWishSnapshot(normalizedTargetGoalId);
        logEvent("temptation_decision", {
          temptation_id: templateId || item.id,
          decision: "save",
          price: priceLocal,
          balance_before: balanceLocal,
          saving_target_id: normalizedTargetGoalId || null,
        });
        let appliedAmount = 0;
        if (normalizedTargetGoalId) {
          appliedAmount = applySavingsToWish(normalizedTargetGoalId, priceUSD);
        }
        if (appliedAmount > 0 && normalizedTargetGoalId) {
          setWishes((prev) => {
            let changed = false;
            let found = false;
            const next = prev.map((wish) => {
              if (!wish) return wish;
              if (wish.id !== normalizedTargetGoalId) return wish;
              found = true;
              const targetUSD =
                Number.isFinite(wish.targetUSD) && wish.targetUSD > 0
                  ? wish.targetUSD
                  : getGoalDefaultTargetUSD(wish.goalId || wish.id);
              const previousSaved = Number.isFinite(wish.savedUSD) ? wish.savedUSD : 0;
              const nextSaved = Math.min(previousSaved + appliedAmount, targetUSD || Number.POSITIVE_INFINITY);
              const nextStatus = targetUSD > 0 && nextSaved >= targetUSD ? "done" : "active";
              if (nextSaved !== previousSaved || nextStatus !== wish.status) {
                changed = true;
                return { ...wish, savedUSD: nextSaved, status: nextStatus };
              }
              return wish;
            });
            if (!found) return prev;
            return changed ? next : prev;
          });
        }
        if (
          appliedAmount > 0 &&
          typeof normalizedTargetGoalId === "string" &&
          normalizedTargetGoalId.startsWith("wish_primary_goal_")
        ) {
          const goalId = normalizedTargetGoalId.replace("wish_primary_goal_", "");
          const currentGoalEntry = Array.isArray(profile.primaryGoals)
            ? profile.primaryGoals.find((goal) => goal?.id === goalId)
            : null;
          const currentSaved = Number.isFinite(currentGoalEntry?.savedUSD)
            ? currentGoalEntry.savedUSD
            : 0;
          const targetUSD =
            Number.isFinite(currentGoalEntry?.targetUSD) && currentGoalEntry.targetUSD > 0
              ? currentGoalEntry.targetUSD
              : getGoalDefaultTargetUSD(goalId);
          const nextSaved = Math.max(0, currentSaved + appliedAmount);
          const nextStatus = targetUSD > 0 && nextSaved >= targetUSD ? "done" : "active";
          setActiveGoalId(goalId);
          syncPrimaryGoalProgress(goalId, nextSaved, nextStatus);
          setProfile((prev) => {
            const existingGoals = Array.isArray(prev.primaryGoals) ? prev.primaryGoals : [];
            const updatedGoals = [];
            let found = false;
            existingGoals.forEach((entry) => {
              if (entry?.id !== goalId) {
                updatedGoals.push(entry);
                return;
              }
              found = true;
              updatedGoals.push({
                ...entry,
                targetUSD: targetUSD,
                savedUSD: Math.max(Number(entry.savedUSD) || 0, nextSaved),
                status: nextStatus,
              });
            });
            if (!found) {
              updatedGoals.unshift({
                id: goalId,
                targetUSD,
                savedUSD: nextSaved,
                status: nextStatus,
                createdAt: Date.now(),
              });
            }
            return {
              ...prev,
              goal: goalId,
              goalTargetUSD: targetUSD,
              primaryGoals: updatedGoals,
            };
          });
          setProfileDraft((prev) => {
            const existingGoals = Array.isArray(prev.primaryGoals) ? prev.primaryGoals : [];
            const updatedGoals = [];
            let found = false;
            existingGoals.forEach((entry) => {
              if (entry?.id !== goalId) {
                updatedGoals.push(entry);
                return;
              }
              found = true;
              updatedGoals.push({
                ...entry,
                targetUSD: targetUSD,
                savedUSD: Math.max(Number(entry.savedUSD) || 0, nextSaved),
                status: nextStatus,
              });
            });
            if (!found) {
              updatedGoals.unshift({
                id: goalId,
                targetUSD,
                savedUSD: nextSaved,
                status: nextStatus,
                createdAt: Date.now(),
              });
            }
            return {
              ...prev,
              goal: goalId,
              goalTargetUSD: targetUSD,
              primaryGoals: updatedGoals,
            };
          });
          setWishes((prev) => {
            const existing = prev.find((wish) => wish?.id === normalizedTargetGoalId);
            if (existing) {
              const updated = {
                ...existing,
                kind: PRIMARY_GOAL_KIND,
                goalId: goalId,
                targetUSD: existing.targetUSD || targetUSD,
                savedUSD: Math.max(existing.savedUSD || 0, nextSaved),
                status: nextStatus,
                autoManaged: false,
              };
              return prev.map((wish) => (wish?.id === normalizedTargetGoalId ? updated : wish));
            }
            const preset = getGoalPreset(goalId);
            const label = preset?.[language] || preset?.en || goalId;
            const emoji = preset?.emoji || DEFAULT_GOAL_EMOJI;
            const title = `${emoji} ${label}`.trim();
            const nextWish = {
              id: normalizedTargetGoalId,
              templateId: `goal_${goalId}`,
              title,
              emoji,
              targetUSD,
              savedUSD: nextSaved,
              status: nextStatus,
              createdAt: Date.now(),
              autoManaged: false,
              kind: PRIMARY_GOAL_KIND,
              goalId,
            };
            return [nextWish, ...prev];
          });
        }
        const totalSavedForCardUSD = Math.max(0, (refuseStatsEntry.totalUSD || 0) + priceUSD);
        const totalSavedForCardLocal = convertToCurrency(totalSavedForCardUSD, currencyCode);
        const savedAmountLabel = formatCurrency(totalSavedForCardLocal, currencyCode);
        let saveOverlayPayload = {
          title,
          moodLine: moodPreset?.saveOverlay || null,
          savedAmountUSD: priceUSD,
          savedAmountLabel,
          saveCount: nextRefuseCount,
        };
        if (targetWishSnapshot && targetWishSnapshot.targetUSD > 0 && priceUSD > 0) {
          const previousSavedUSD = targetWishSnapshot.savedUSD || 0;
          const targetUSD = targetWishSnapshot.targetUSD || 0;
          const nextSavedUSD = Math.min(previousSavedUSD + appliedAmount, targetUSD);
          const remainingUSD = Math.max(targetUSD - nextSavedUSD, 0);
          const remainingTemptations = Math.max(Math.ceil(remainingUSD / priceUSD), 0);
          const progressStartValue = targetUSD > 0 ? previousSavedUSD / targetUSD : 0;
          const progressEndValue = targetUSD > 0 ? nextSavedUSD / targetUSD : progressStartValue;
          saveOverlayPayload = {
            ...saveOverlayPayload,
            goalTitle: targetWishSnapshot.title || "",
            remainingTemptations,
            goalComplete: remainingUSD <= 0,
            progressStart: progressStartValue,
            progressEnd: progressEndValue,
          };
          const progressPercent =
            targetUSD > 0 ? Math.min((nextSavedUSD / targetUSD) * 100, 100) : 0;
          if (normalizedTargetGoalId && appliedAmount > 0) {
            logEvent("saving_progress_updated", {
              target_id: normalizedTargetGoalId,
              amount_added: convertToCurrency(appliedAmount, currencyCode),
              new_progress: progressPercent,
            });
          }
        }
        if (
          (!Number.isFinite(saveOverlayPayload.progressStart) ||
            !Number.isFinite(saveOverlayPayload.progressEnd)) &&
          heroGoalTargetUSD > 0 &&
          priceUSD > 0
        ) {
          const heroStartValue = Math.min(
            1,
            Math.max(0, heroGoalTargetUSD > 0 ? heroGoalSavedUSD / heroGoalTargetUSD : 0)
          );
          const heroDeltaUSD = appliedAmount > 0 ? appliedAmount : priceUSD;
          const heroEndValue = Math.min(
            1,
            heroGoalTargetUSD > 0
              ? (heroGoalSavedUSD + heroDeltaUSD) / heroGoalTargetUSD
              : heroStartValue
          );
          if (heroEndValue > heroStartValue) {
            saveOverlayPayload = {
              ...saveOverlayPayload,
              progressStart: heroStartValue,
              progressEnd: heroEndValue,
            };
          }
        }
        const primaryTemptationKey = normalizeTemplateKey(primaryTemptationId);
        const shouldIgnoreLevelProgress =
          !tutorialLevelOffsetAppliedRef.current &&
          temptationTutorialStatus === "pending" &&
          !!profile.customSpend &&
          priceUSD > 0 &&
          primaryTemptationKey &&
          normalizeTemplateKey(templateId) === primaryTemptationKey;
        const nextLevelProgressOffsetUSD = shouldIgnoreLevelProgress
          ? levelProgressOffsetUSD + priceUSD
          : levelProgressOffsetUSD;
        const timestamp = saveTimestamp;
        const baseLevel = Math.max(
          1,
          Number(lastCelebratedLevel) || 1,
          levelCelebrationQueuedRef.current || 0
        );
        const projectedProgressTotal = progressSavedTotalUSD + priceUSD;
        const projectedLevelProgressUSD = Math.max(
          0,
          Math.max(projectedProgressTotal, progressLifetimeSavedUSD || 0) - nextLevelProgressOffsetUSD
        );
        const projectedLevel = getTierProgress(
          projectedLevelProgressUSD,
          profile.currency || DEFAULT_PROFILE.currency
        ).level;
        if (projectedLevel > baseLevel) {
          pendingLevelCelebrationRef.current = {
            level: projectedLevel,
            levelsEarned: projectedLevel - baseLevel,
          };
          levelCelebrationQueuedRef.current = Math.max(
            levelCelebrationQueuedRef.current || 0,
            projectedLevel
          );
        }
        if (shouldIgnoreLevelProgress) {
          tutorialLevelOffsetAppliedRef.current = true;
          setLevelProgressOffsetUSD((prev) => (prev > 0 ? prev : Math.max(0, prev + priceUSD)));
        }
        const shouldDebugPrimarySave =
          __DEV__ && (overlay?.type === "primary_temptation" || isCustomTemptation(item));
        lastSaveActionAtRef.current = saveTimestamp;
        setSavedTotalUSD((prev) => {
          const nextValue = prev + priceUSD;
          if (shouldDebugPrimarySave) {
            console.warn("primary_temptation_saved_total_update", {
              prev,
              next: nextValue,
              priceUSD,
              itemId: item?.id,
              templateId,
            });
          }
          return nextValue;
        });
        setProgressSavedTotalUSD((prev) => Math.max(0, prev + priceUSD));
        setDeclineCount((prev) => prev + 1);
        const coinReward = priceUSD
          ? computeRefuseCoinReward(priceUSD, profile.currency || DEFAULT_PROFILE.currency)
          : 0;
        if (coinReward > 0) {
          setHealthPoints((prev) => prev + coinReward);
        }
        const saveOverlayPayloadWithReward = {
          ...saveOverlayPayload,
          coinReward,
        };
        const resolvedCategory = resolveTemptationCategory(item);
        const isEssentialSaveCategory = isEssentialImpulseCategory(resolvedCategory);
        setRefuseStats((prev) => {
          if (!templateId) return prev;
          const { entry: currentEntry, key: legacyKey } = getLegacyRefuseStatsEntry(prev, templateId, item);
          const current = currentEntry || {};
          const count = (current.count || 0) + 1;
          const totalUSD = (current.totalUSD || 0) + priceUSD;
          const next = {
            ...prev,
            [templateId]: {
              ...current,
              count,
              totalUSD,
              lastSavedAt: saveTimestamp,
              lastSavedAmountUSD: priceUSD,
            },
          };
          if (legacyKey && legacyKey !== templateId) {
            delete next[legacyKey];
          }
          return next;
        });
        logHistoryEvent("refuse_spend", {
          title,
          amountUSD: priceUSD,
          templateId: templateId || item.id,
          goalId: normalizedTargetGoalId || null,
          coinReward,
          currency: profile.currency || DEFAULT_PROFILE.currency,
          category: resolvedCategory,
        });
        registerUsageStreakAction("save", saveTimestamp);
        logEvent(
          "temptation_save",
          buildTemptationPayload(item, {
            total_saved_usd: savedTotalUSD + priceUSD,
            refuse_count_for_item: (refuseStatsEntry.count || 0) + 1,
            price_usd: priceUSD,
          })
        );
        logTemptationAction("save", item, {
          goal_id: normalizedTargetGoalId || null,
          price_usd: priceUSD,
        });
        if (!isEssentialSaveCategory) {
          logImpulseEvent("save", item, priceUSD, title);
        }
        triggerCardFeedback(templateId || item.id);
        triggerCoinHaptics();
        if (priceUSD > 0) {
          setDailyGoalCoinDropTick((prev) => prev + 1);
        }
        handleFocusSaveProgress(item);
        ensureOverlayEnvironmentReady();
        triggerOverlayState("save", saveOverlayPayloadWithReward);
        lastSaveOverlayDismissedAtRef.current = saveTimestamp;
        if (!isEssentialSaveCategory) {
          requestMascotAnimation("happy");
        }
        saveActionLogRef.current = [...recentSaves, { itemId: templateId || item.id, timestamp: saveTimestamp }];
        recordTemptationInteraction(templateId || item.id, "save", item, priceUSD);
        if (!isEssentialSaveCategory) {
          queueHomeSpeech("save");
        }
        return;
      }
      if (type === "maybe") {
        const activePendingCount = Array.isArray(pendingListRef.current)
          ? pendingListRef.current.length
          : 0;
        if (!premiumState.isPremium && activePendingCount >= FREE_PENDING_LIMIT) {
          ensurePremiumFeatureAccess(PREMIUM_FEATURE_KEYS.thinkingQueue);
          return;
        }
        logEvent(
          "temptation_think_later",
          buildTemptationPayload(item, { reminder_days: REMINDER_DAYS })
        );
        logTemptationAction("pending", item);
        const now = Date.now();
        const pendingEntry = {
          id: `pending-${item.id}-${now}`,
          templateId: templateId || item.id,
          title,
          priceUSD,
          pricePrecision: getTemptationPricePrecision(item),
          createdAt: now,
          decisionDue: now + REMINDER_MS,
          notificationId: null,
        };
        logEvent(
          "pending_added",
          buildTemptationPayload(item, {
            remind_at: pendingEntry.decisionDue,
          })
        );
        const reminderId = await schedulePendingReminder(title, pendingEntry.decisionDue, {
          pendingId: pendingEntry.id,
          templateId: pendingEntry.templateId,
          title,
          emoji: item?.emoji || "âœ¨",
          amountUSD: priceUSD,
        });
        if (reminderId) pendingEntry.notificationId = reminderId;
        setPendingList((prev) => [pendingEntry, ...prev]);
        logHistoryEvent("pending_added", { title, amountUSD: priceUSD, pendingId: pendingEntry.id });
        triggerOverlayState("cart", t("pendingAdded"));
        triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
        return;
      }
      Alert.alert("Almost", t("actionSoon"));
    },
    [
      language,
      t,
      thinkingUnlocked,
      schedulePendingReminder,
      logHistoryEvent,
      registerUsageStreakAction,
      triggerCardFeedback,
      triggerCoinHaptics,
      buildTemptationPayload,
      buildPrimaryGoalWishSnapshot,
      levelProgressOffsetUSD,
      savedTotalUSD,
      progressSavedTotalUSD,
      refuseStats,
      logImpulseEvent,
      logTemptationAction,
      resolveTemptationGoalId,
      assignableGoals.length,
      assignTemptationGoal,
      applySavingsToWish,
      syncPrimaryGoalProgress,
      setProfile,
      setProfileDraft,
      setWishes,
      setGoalLinkPrompt,
      getFallbackGoalId,
      wishes,
      moodPreset,
      requestMascotAnimation,
      handleFocusSaveProgress,
      setDailyGoalCoinDropTick,
      ensureOverlayEnvironmentReady,
      logEvent,
      primaryTemptationId,
      profile.currency,
      profile.customSpend,
      profile.primaryGoals,
      setLevelProgressOffsetUSD,
      executeSpend,
      triggerStormEffect,
      recordTemptationInteraction,
      triggerOverlayState,
      getLegacyRefuseStatsEntry,
      queueHomeSpeech,
      queueUsageStreakOverlay,
      lastCelebratedLevel,
      lifetimeSavedUSD,
      progressLifetimeSavedUSD,
      healthPoints,
      setHealthPoints,
      setProgressSavedTotalUSD,
      resolveTemptationCategory,
      resolveTemptationTemplateId,
      dismissStormEffect,
      activeGoalId,
      mainGoalWish,
      profile.goal,
      profile.primaryGoals,
      overlay,
      temptationTutorialStatus,
      openCategoryPrompt,
      shouldPromptCategory,
      ensurePremiumFeatureAccess,
      premiumState.isPremium,
    ]
  );

  const handleSaveSpamPromptConfirm = useCallback(() => {
    const item = saveSpamPrompt.item;
    if (!item) {
      closeSaveSpamPrompt();
      return;
    }
    const nextOptions = saveSpamPrompt.options || {};
    logEvent("save_guard_confirmed", {
      temptation_id: resolveTemptationTemplateId(item) || item?.id || null,
      save_count_5m: saveSpamPrompt.recentCount || 0,
    });
    closeSaveSpamPrompt();
    handleTemptationAction("save", item, { ...nextOptions, skipSaveSpamCheck: true });
  }, [
    closeSaveSpamPrompt,
    handleTemptationAction,
    logEvent,
    resolveTemptationTemplateId,
    saveSpamPrompt.item,
    saveSpamPrompt.options,
    saveSpamPrompt.recentCount,
  ]);

  const handleSaveSpamPromptCancel = useCallback(() => {
    const item = saveSpamPrompt.item;
    logEvent("save_guard_cancelled", {
      temptation_id: resolveTemptationTemplateId(item) || item?.id || null,
      save_count_5m: saveSpamPrompt.recentCount || 0,
    });
    closeSaveSpamPrompt();
    triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
  }, [
    closeSaveSpamPrompt,
    logEvent,
    resolveTemptationTemplateId,
    saveSpamPrompt.item,
    saveSpamPrompt.recentCount,
  ]);

  const handleCategoryPromptConfirm = useCallback(() => {
    const item = categoryPrompt.item;
    if (!item) {
      closeCategoryPrompt();
      return;
    }
    const templateId = resolveTemptationTemplateId(item) || item.id;
    const selected =
      categoryPromptSelection && IMPULSE_CATEGORY_DEFS[categoryPromptSelection]
        ? categoryPromptSelection
        : resolveTemptationCategory(item);
    if (templateId && selected && IMPULSE_CATEGORY_DEFS[selected]) {
      setCategoryOverrides((prev) => ({ ...prev, [templateId]: selected }));
    }
    const nextAction = categoryPrompt.action;
    const nextOptions = categoryPrompt.options || {};
    closeCategoryPrompt();
    if (nextAction) {
      handleTemptationAction(nextAction, item, { ...nextOptions, skipCategoryPrompt: true });
    }
  }, [
    categoryPrompt.action,
    categoryPrompt.item,
    categoryPrompt.options,
    categoryPromptSelection,
    closeCategoryPrompt,
    handleTemptationAction,
    resolveTemptationCategory,
    resolveTemptationTemplateId,
    setCategoryOverrides,
  ]);

  const openAddCategoryModal = useCallback(() => {
    if (!ensurePremiumFeatureAccess(PREMIUM_FEATURE_KEYS.customCategories)) return;
    setAddCategoryName("");
    setAddCategoryEmoji("âœ¨");
    setAddCategoryError(false);
    setResumeManageCategoriesAfterAdd(manageCategoriesVisible);
    if (manageCategoriesVisible) {
      setManageCategoriesVisible(false);
    }
    setAddCategoryModalVisible(true);
  }, [ensurePremiumFeatureAccess, manageCategoriesVisible]);

  const closeAddCategoryModal = useCallback(() => {
    setAddCategoryModalVisible(false);
    setAddCategoryError(false);
    if (resumeManageCategoriesAfterAdd) {
      setResumeManageCategoriesAfterAdd(false);
      setManageCategoriesVisible(true);
    }
  }, [resumeManageCategoriesAfterAdd]);

  const handleAddCategorySave = useCallback(() => {
    if (!ensurePremiumFeatureAccess(PREMIUM_FEATURE_KEYS.customCategories)) return;
    const trimmed = (addCategoryName || "").trim();
    if (!trimmed) {
      setAddCategoryError(true);
      return;
    }
    const emoji = limitEmojiInput(addCategoryEmoji) || "âœ¨";
    const def = registerCustomCategory({
      id: trimmed,
      ru: trimmed,
      en: trimmed,
      es: trimmed,
      fr: trimmed,
      emoji,
    });
    if (def) {
      setCustomCategories((prev) => {
        const next = [...prev, def];
        logEvent("custom_category_created", { count: next.length, category_id: def.id });
        return next;
      });
    }
    closeAddCategoryModal();
  }, [
    addCategoryEmoji,
    addCategoryName,
    closeAddCategoryModal,
    ensurePremiumFeatureAccess,
    logEvent,
  ]);

  const openManageCategoriesModal = useCallback(() => {
    if (!ensurePremiumFeatureAccess(PREMIUM_FEATURE_KEYS.customCategories)) return;
    setManageCategoriesVisible(true);
  }, [ensurePremiumFeatureAccess]);

  const closeManageCategoriesModal = useCallback(() => {
    setManageCategoriesVisible(false);
  }, []);

  const categoryManagerList = useMemo(() => {
    const order = getBudgetCategoryOrder();
    if (customCategories.length) {
      customCategories.forEach((entry) => {
        const id = entry?.id;
        if (id && !order.includes(id)) {
          order.push(id);
        }
      });
    }
    const seen = new Set();
    return order.reduce((acc, id) => {
      if (!id || seen.has(id)) return acc;
      seen.add(id);
      if (id === "savings") {
        acc.push({
          id,
          label: getBudgetCategoryLabel(id, language),
          emoji: getBudgetCategoryEmoji(id),
          custom: false,
          deletable: false,
        });
        return acc;
      }
      const def = IMPULSE_CATEGORY_DEFS[id];
      if (!def) return acc;
      acc.push({
        id,
        label: getImpulseCategoryName(id, language),
        emoji: def.emoji || "âœ¨",
        custom: !!def.custom,
        deletable: true,
      });
      return acc;
    }, []);
  }, [customCategories, language, removedCategories, savingsCategoryOverride, categoryDefOverrides]);

  const categoryManagerListHeight = useMemo(() => {
    const rowHeight = 52;
    const maxVisible = 6;
    const visibleCount = Math.max(1, Math.min(categoryManagerList.length, maxVisible));
    return Math.min(rowHeight * visibleCount, SCREEN_HEIGHT * 0.4);
  }, [categoryManagerList.length]);

  const resolveCategoryEditLabel = useCallback(
    (categoryId) => {
      if (!categoryId) return "";
      if (categoryId === "savings") {
        return getBudgetCategoryLabel("savings", language);
      }
      return getImpulseCategoryName(categoryId, language);
    },
    [language]
  );

  const resolveCategoryEditEmoji = useCallback((categoryId) => {
    if (!categoryId) return "";
    if (categoryId === "savings") {
      return getBudgetCategoryEmoji("savings");
    }
    return IMPULSE_CATEGORY_DEFS[categoryId]?.emoji || "âœ¨";
  }, []);

  const syncCategoryEditor = useCallback(
    (categoryId) => {
      if (!categoryId) return;
      setCategoryEditName(resolveCategoryEditLabel(categoryId));
      setCategoryEditEmoji(resolveCategoryEditEmoji(categoryId));
    },
    [resolveCategoryEditEmoji, resolveCategoryEditLabel]
  );

  const handleCategorySelect = useCallback(
    (categoryId) => {
      if (!categoryId || categoryId === categoryEditId) return;
      setCategoryEditId(categoryId);
      syncCategoryEditor(categoryId);
    },
    [categoryEditId, syncCategoryEditor]
  );

  useEffect(() => {
    if (!manageCategoriesVisible) return;
    const fallbackId =
      categoryEditId && (categoryEditId === "savings" || IMPULSE_CATEGORY_DEFS[categoryEditId])
        ? categoryEditId
        : "savings";
    if (fallbackId !== categoryEditId) {
      setCategoryEditId(fallbackId);
    }
    syncCategoryEditor(fallbackId);
  }, [categoryEditId, manageCategoriesVisible, syncCategoryEditor]);

  const handleCategoryEditCancel = useCallback(() => {
    syncCategoryEditor(categoryEditId || "savings");
  }, [categoryEditId, syncCategoryEditor]);

  const handleCategoryEditSave = useCallback(() => {
    const activeId = categoryEditId || "savings";
    if (activeId === "savings") {
      const trimmed = (categoryEditName || "").trim();
      const emoji = limitEmojiInput(categoryEditEmoji);
      const nextOverride =
        trimmed || emoji
          ? {
              label: trimmed || null,
              emoji: emoji || null,
            }
          : null;
      setSavingsCategoryOverride(nextOverride);
      applySavingsCategoryOverride(nextOverride);
      syncCategoryEditor(activeId);
      return;
    }
    const def = IMPULSE_CATEGORY_DEFS[activeId];
    if (!def) return;
    const trimmed = (categoryEditName || "").trim();
    const emoji = limitEmojiInput(categoryEditEmoji);
    if (def.custom) {
      setCustomCategories((prev) =>
        (prev || []).map((entry) => {
          if (entry?.id !== activeId) return entry;
          return {
            ...entry,
            ru: trimmed || entry.ru,
            en: trimmed || entry.en,
            es: trimmed || entry.es,
            fr: trimmed || entry.fr,
            emoji: emoji || entry.emoji,
          };
        })
      );
      if (trimmed) {
        def.ru = trimmed;
        def.en = trimmed;
        def.es = trimmed;
        def.fr = trimmed;
      }
      if (emoji) {
        def.emoji = emoji;
      }
      syncCategoryEditor(activeId);
      return;
    }
    const nextOverride =
      trimmed || emoji
        ? {
            label: trimmed || null,
            emoji: emoji || null,
          }
        : null;
    setCategoryDefOverrides((prev) => {
      const next = { ...(prev || {}) };
      if (nextOverride) {
        next[activeId] = nextOverride;
      } else {
        delete next[activeId];
      }
      return next;
    });
    resetImpulseCategoryDef(activeId);
    if (nextOverride) {
      applyCategoryDefOverrides({ [activeId]: nextOverride });
    }
    syncCategoryEditor(activeId);
  }, [
    categoryEditEmoji,
    categoryEditId,
    categoryEditName,
    setCategoryDefOverrides,
    setCustomCategories,
    setSavingsCategoryOverride,
    syncCategoryEditor,
  ]);

  const removeCategory = useCallback((categoryId) => {
    if (!categoryId || categoryId === "savings") return;
    const def = IMPULSE_CATEGORY_DEFS[categoryId];
    if (!def) return;
    const isCustom = !!def.custom;
    if (isCustom) {
      setCustomCategories((prev) => prev.filter((entry) => entry?.id !== categoryId));
    } else {
      setRemovedCategories((prev) => {
        const normalized = Array.isArray(prev) ? prev : [];
        const next = normalized.includes(categoryId) ? normalized : [...normalized, categoryId];
        applyRemovedCategories(next);
        return next;
      });
      setCategoryDefOverrides((prev) => {
        if (!prev || !prev[categoryId]) return prev;
        const next = { ...prev };
        delete next[categoryId];
        return next;
      });
    }
    removeCategoryFromRuntime(categoryId);
    setCategoryOverrides((prev) => {
      if (!prev || typeof prev !== "object") return prev;
      let changed = false;
      const next = { ...prev };
      Object.keys(next).forEach((key) => {
        if (next[key] === categoryId) {
          delete next[key];
          changed = true;
        }
      });
      return changed ? next : prev;
    });
    setQuickTemptations((prev) =>
      (prev || []).map((card) => {
        if (!card || card.impulseCategoryOverride !== categoryId) return card;
        return { ...card, impulseCategoryOverride: null };
      })
    );
    const clearCustomSpendCategory = (state) => {
      if (!state?.customSpend?.impulseCategory) return state;
      if (state.customSpend.impulseCategory !== categoryId) return state;
      return {
        ...state,
        customSpend: {
          ...state.customSpend,
          impulseCategory: null,
        },
      };
    };
    setProfile((prev) => clearCustomSpendCategory(prev));
    setProfileDraft((prev) => clearCustomSpendCategory(prev));
    if (categoryEditId === categoryId) {
      setCategoryEditId("savings");
      syncCategoryEditor("savings");
    }
  }, [
    categoryEditId,
    setCategoryDefOverrides,
    setCategoryOverrides,
    setCustomCategories,
    setProfile,
    setProfileDraft,
    setQuickTemptations,
    setRemovedCategories,
    syncCategoryEditor,
  ]);

  const confirmCategoryDelete = useCallback(
    (categoryId) => {
      if (!categoryId || categoryId === "savings") return;
      const def = IMPULSE_CATEGORY_DEFS[categoryId];
      if (!def) return;
      const label = getImpulseCategoryName(categoryId, language);
      Alert.alert("Almost", t("manageCategoriesDeleteConfirm", { category: label }), [
        { text: t("profileCancel"), style: "cancel" },
        {
          text: t("cartRemove"),
          style: "destructive",
          onPress: () => removeCategory(categoryId),
        },
      ]);
    },
    [language, removeCategory, t]
  );

  const closeGoalLinkPrompt = useCallback(() => {
    setGoalLinkPrompt({
      visible: false,
      item: null,
      intent: null,
      amountUSD: null,
    });
  }, []);

  const handleGoalLinkSelect = useCallback(
    (wishId) => {
      const sourceItem = goalLinkPrompt.item;
      const intent = goalLinkPrompt.intent;
      const amountUSD = goalLinkPrompt.amountUSD;
      const templateId = resolveTemptationTemplateId(sourceItem);
      closeGoalLinkPrompt();
      if (!wishId || !sourceItem) return;
      if (intent === "save") {
        handleTemptationAction("save", sourceItem, {
          skipPrompt: true,
          goalId: wishId,
          shouldAssign: true,
          amountUSD,
        });
        return;
      }
      assignTemptationGoal(templateId || sourceItem.id, wishId);
    },
    [
      assignTemptationGoal,
      closeGoalLinkPrompt,
      goalLinkPrompt,
      handleTemptationAction,
      resolveTemptationTemplateId,
    ]
  );

  const handleGoalLongPress = useCallback(
    (wish) => {
      if (!wish) return;
      triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
      setGoalTemptationPrompt({ visible: true, wish });
    },
    [triggerHaptic]
  );

  const closeGoalTemptationPrompt = useCallback(() => {
    setGoalTemptationPrompt({ visible: false, wish: null });
  }, []);

  const handleGoalTemptationAssign = useCallback(
    (templateId) => {
      const targetWish = goalTemptationPrompt.wish;
      closeGoalTemptationPrompt();
      if (!templateId || !targetWish) return;
      assignTemptationGoal(templateId, targetWish.id);
    },
    [assignTemptationGoal, closeGoalTemptationPrompt, goalTemptationPrompt]
  );

  const handleNewPendingSubmit = useCallback(async () => {
    const trimmedTitle = (newPendingModal.title || "").trim();
    if (!trimmedTitle) {
      Alert.alert("Almost", t("pendingCustomError"));
      return;
    }
    const parsedLocal = parseNumberInputValue(newPendingModal.amount);
    if (!Number.isFinite(parsedLocal) || parsedLocal <= 0) {
      Alert.alert("Almost", t("pendingCustomError"));
      return;
    }
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const amountUSD = convertFromCurrency(parsedLocal, currencyCode);
    const emoji = normalizeEmojiValue(newPendingModal.emoji, DEFAULT_TEMPTATION_EMOJI);
    const manualPrecision = getManualInputPrecision(newPendingModal.amount || "");
    const manualItem = {
      id: `manual_pending_${Date.now()}`,
      title: trimmedTitle,
      emoji,
      priceUSD: amountUSD,
      basePriceUSD: amountUSD,
      pricePrecision: manualPrecision,
      categories: [],
    };
    await handleTemptationAction("maybe", manualItem);
    setNewPendingModal({ visible: false, title: "", amount: "", emoji: DEFAULT_TEMPTATION_EMOJI });
  }, [handleTemptationAction, newPendingModal, profile.currency, t]);

  const openGoalEditorPrompt = useCallback(
    (wish) => {
      if (!wish) return;
      const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
      const targetLocal = formatNumberInputValue(convertToCurrency(wish.targetUSD || 0, currencyCode));
      setGoalEditorPrompt({
        visible: true,
        wish,
        name: getWishTitleWithoutEmoji(wish) || "",
        target: targetLocal,
        emoji: normalizeEmojiValue(wish.emoji || resolveWishEmoji(wish), DEFAULT_GOAL_EMOJI),
      });
    },
    [profile.currency]
  );

  const closeGoalEditorPrompt = useCallback(() => {
    setGoalEditorPrompt({
      visible: false,
      wish: null,
      name: "",
      target: "",
      emoji: DEFAULT_GOAL_EMOJI,
    });
  }, []);

  const handleGoalEditorNameChange = useCallback((value) => {
    setGoalEditorPrompt((prev) => ({ ...prev, name: value }));
  }, []);

  const handleGoalEditorTargetChange = useCallback((value) => {
    setGoalEditorPrompt((prev) => ({ ...prev, target: value }));
  }, []);

  const handleGoalEditorEmojiChange = useCallback((value) => {
    setGoalEditorPrompt((prev) => ({ ...prev, emoji: limitEmojiInput(value) }));
  }, []);

  const saveGoalEditorPrompt = useCallback(() => {
    if (!goalEditorPrompt.wish) return;
    const trimmedName = goalEditorPrompt.name?.trim();
    if (!trimmedName) {
      Alert.alert("Almost", t("goalEditNameError"));
      return;
    }
    const parsed = parseNumberInputValue(goalEditorPrompt.target);
    if (!Number.isFinite(parsed) || parsed <= 0) {
      Alert.alert("Almost", t("goalEditTargetError"));
      return;
    }
    const fallbackEmoji = resolveWishEmoji(goalEditorPrompt.wish);
    const normalizedEmoji = normalizeEmojiValue(
      goalEditorPrompt.emoji,
      fallbackEmoji || DEFAULT_GOAL_EMOJI
    );
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const nextTargetUSD = convertFromCurrency(parsed, currencyCode);
    let resultingStatus = goalEditorPrompt.wish.status || "active";
    setWishes((prev) => {
      let statusCapture = resultingStatus;
      const next = prev.map((wish) => {
        if (wish.id !== goalEditorPrompt.wish.id) return wish;
        const nextSaved = Math.min(wish.savedUSD || 0, nextTargetUSD);
        const nextStatus = nextSaved >= nextTargetUSD ? "done" : "active";
        statusCapture = nextStatus;
        return {
          ...wish,
          title: trimmedName,
          emoji: normalizedEmoji,
          targetUSD: nextTargetUSD,
          savedUSD: nextSaved,
          status: nextStatus,
        };
      });
      resultingStatus = statusCapture;
      return next;
    });
    const shouldResetCelebration = resultingStatus !== "done";
    if (
      goalEditorPrompt.wish.kind === PRIMARY_GOAL_KIND &&
      goalEditorPrompt.wish.goalId
    ) {
      const goalExtras = {
        customTitle: trimmedName,
        customEmoji: normalizedEmoji,
      };
      setProfile((prev) => {
        const updated = updatePrimaryGoalTargetInProfile(
          prev,
          goalEditorPrompt.wish.goalId,
          nextTargetUSD,
          goalExtras
        );
        return shouldResetCelebration
          ? { ...updated, goalCelebrated: false, goalRenewalPending: false }
          : updated;
      });
      setProfileDraft((prev) => {
        const updated = updatePrimaryGoalTargetInProfile(
          prev,
          goalEditorPrompt.wish.goalId,
          nextTargetUSD,
          goalExtras
        );
        return shouldResetCelebration
          ? { ...updated, goalCelebrated: false, goalRenewalPending: false }
          : updated;
      });
    }
    if (shouldResetCelebration) {
      dismissGoalRenewalPrompt();
    }
    closeGoalEditorPrompt();
  }, [
    closeGoalEditorPrompt,
    dismissGoalRenewalPrompt,
    goalEditorPrompt,
    profile.currency,
    setProfile,
    setProfileDraft,
    t,
  ]);

  const handleGoalRenewalLater = useCallback(() => {
    dismissGoalRenewalPrompt();
    const currentGoalId = mainGoalWish?.goalId || profile.primaryGoals?.[0]?.id || null;
    setProfile((prev) => ({ ...prev, goalRenewalPending: false }));
    setProfileDraft((prev) => ({ ...prev, goalRenewalPending: false }));
    logEvent("goal_renewal_later", { goal_id: currentGoalId });
  }, [dismissGoalRenewalPrompt, mainGoalWish, profile.primaryGoals, setProfile, setProfileDraft]);

  const handleGoalRenewalStart = useCallback(() => {
    dismissGoalRenewalPrompt();
    setProfile((prev) => ({ ...prev, goalRenewalPending: false }));
    setProfileDraft((prev) => ({ ...prev, goalRenewalPending: false }));
    goToTab("cart");
    const targetWish = mainGoalWish || selectMainGoalWish(wishes);
    logEvent("goal_renewal_start", { had_existing_goal: !!targetWish });
    setTimeout(() => {
      openNewGoalModal(true, "goal_renewal");
    }, 280);
  }, [
    dismissGoalRenewalPrompt,
    goToTab,
    mainGoalWish,
    openNewGoalModal,
    wishes,
    setProfile,
    setProfileDraft,
  ]);

  const resolveFrequencySelectionForItem = useCallback(
    (item) => {
      if (!item) {
        return { frequency: "daily", frequencyCustom: { ...DEFAULT_CUSTOM_FREQUENCY } };
      }
      const templateId = resolveTemptationTemplateId(item);
      const entry = templateId ? temptationInteractions?.[templateId] : null;
      let frequency = normalizeFrequencyId(entry?.frequency) || normalizeFrequencyId(item.frequency) || null;
      let frequencyCustom =
        normalizeCustomFrequency(entry?.frequencyCustom || item.frequencyCustom || item.customFrequency) ||
        null;
      if (frequency === "biweekly") {
        frequency = "custom";
        frequencyCustom = { ...DEFAULT_CUSTOM_FREQUENCY };
      }
      if (!frequency) frequency = "daily";
      if (frequency === "custom" && !frequencyCustom) {
        frequencyCustom = { ...DEFAULT_CUSTOM_FREQUENCY };
      }
      if (frequency !== "custom") {
        frequencyCustom = null;
      }
      return { frequency, frequencyCustom };
    },
    [resolveTemptationTemplateId, temptationInteractions]
  );

  const handleLogFreeDay = useCallback(() => {
    if (!freeDayUnlocked) return;
    const today = new Date();
    const todayKey = getDayKey(today);
    if (freeDayStats.lastDate === todayKey) {
      Alert.alert("Almost", t("freeDayLoggedToday"));
      return;
    }
    Alert.alert("Almost", t("freeDayConfirm"), [
      { text: t("priceEditCancel"), style: "cancel" },
      {
        text: t("freeDayButton"),
        onPress: () => {
          const yesterdayKey = getDayKey(new Date(today.getTime() - DAY_MS));
          const continues = freeDayStats.lastDate === yesterdayKey;
          const current = continues ? freeDayStats.current + 1 : 1;
          const best = Math.max(freeDayStats.best, current);
          const total = freeDayStats.total + 1;
          let achievements = [...freeDayStats.achievements];
          const newMilestones = FREE_DAY_MILESTONES.filter(
            (m) => current >= m && !achievements.includes(m)
          );
          achievements = [...achievements, ...newMilestones];
          setFreeDayStats({
            total,
            current,
            best,
            lastDate: todayKey,
            achievements,
            blockedDate: null,
          });
          logHistoryEvent("free_day", { total, current, best });
          logEvent("free_day_logged", {
            total,
            current_streak: current,
            best_streak: best,
            weekday: today.getDay(),
            persona: profile.persona || "unknown",
            goal: resolveProfileGoalId(profile) || "none",
          });
          newMilestones.forEach((milestone) => {
            logEvent("free_day_milestone", {
              milestone,
              current_streak: current,
            });
          });
          const message =
            newMilestones.length > 0
              ? t("freeDayMilestone", { days: current })
              : t("freeDayCongrats", { days: current });
          triggerOverlayState("purchase", message);
          triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
          const rewardBlueCoins = FREE_DAY_LOGIN_BLUE_COINS * current;
          const rewardHealthPoints = rewardBlueCoins * BLUE_HEALTH_COIN_VALUE;
          setHealthPoints((prev) => prev + rewardHealthPoints);
          const rewardReason =
            current > 1
              ? t("freeDayCoinRewardStreak", { coins: rewardBlueCoins, days: current })
              : t("freeDayCoinReward", { coins: rewardBlueCoins });
          triggerOverlayState("health", {
            amount: rewardHealthPoints,
            displayCoins: rewardBlueCoins,
            coinValue: BLUE_HEALTH_COIN_VALUE,
            reason: rewardReason,
          });
          logEvent("free_day_coin_reward", {
            blue_coins: rewardBlueCoins,
            health_points: rewardHealthPoints,
            current_streak: current,
          });
        },
      },
    ]);
  }, [
    freeDayUnlocked,
    freeDayStats,
    t,
    logEvent,
    logHistoryEvent,
    profile.goal,
    profile.persona,
    profile.primaryGoals,
    resolveProfileGoalId,
    setHealthPoints,
    triggerOverlayState,
  ]);

  const toggleTemptationEditor = useCallback(
    (item) => {
      if (!item) return;
      runLayoutAnimation();
      triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
      setPriceEditor((prev) => {
        if (prev.item?.id === item.id) {
          return {
            item: null,
            value: "",
            title: "",
            emoji: "",
            category: DEFAULT_IMPULSE_CATEGORY,
            description: "",
            frequency: "daily",
            frequencyCustom: { ...DEFAULT_CUSTOM_FREQUENCY },
          };
        }
        const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
        const currentValue = convertToCurrency(item.priceUSD || item.basePriceUSD || 0, currencyCode);
        const precisionOverride = getTemptationPricePrecision(item);
        const inputPrecision =
          precisionOverride !== null ? precisionOverride : getCurrencyDisplayPrecision(currencyCode);
        const categorySlug = resolveTemptationCategory(item);
        const descriptionString = typeof item.description === "string" ? item.description : null;
        const descriptionMap =
          item.description && typeof item.description === "object" && !Array.isArray(item.description)
            ? item.description
            : null;
        const isCustom =
          Array.isArray(item?.categories) && item.categories.some((category) => category === "custom");
        const customDescriptionFallback = isCustom
          ? buildCustomTemptationDescription(item?.gender || "none")
          : null;
        const customLanguageFallback = customDescriptionFallback
          ? resolveLanguageMapValue(customDescriptionFallback, language)
          : null;
        const descriptionLanguageValue = descriptionMap ? resolveLanguageMapValue(descriptionMap, language) : null;
        const overrideDescription =
          typeof descriptionOverrides[item.id] === "string"
            ? descriptionOverrides[item.id]
            : "";
        const baseDescription = descriptionLanguageValue || descriptionString || "";
        const computedDescription = isCustom ? baseDescription || customLanguageFallback || "" : baseDescription;
        const resolvedDescription =
          (overrideDescription && overrideDescription.length ? overrideDescription : computedDescription);
        const { frequency, frequencyCustom } = resolveFrequencySelectionForItem(item);
        logEvent("temptation_viewed", {
          temptation_id: item.id,
          category: categorySlug,
          price: convertToCurrency(item.priceUSD || item.basePriceUSD || 0, currencyCode),
        });
        return {
          item,
          value: formatNumberInputValue(Number(currentValue) || 0, inputPrecision),
          title: resolveTemptationTitle(item, language, titleOverrides[item.id]),
          emoji: item.emoji || DEFAULT_TEMPTATION_EMOJI,
          category: categorySlug,
          description: resolvedDescription,
          frequency,
          frequencyCustom,
        };
      });
    },
    [
      language,
      profile.currency,
      titleOverrides,
      descriptionOverrides,
      resolveTemptationCategory,
      resolveFrequencySelectionForItem,
    ]
  );

  const closePriceEditor = useCallback(() => {
    if (!priceEditor.item) return;
    runLayoutAnimation();
    setPriceEditor({
      item: null,
      value: "",
      title: "",
      emoji: "",
      category: DEFAULT_IMPULSE_CATEGORY,
      description: "",
      frequency: "daily",
      frequencyCustom: { ...DEFAULT_CUSTOM_FREQUENCY },
    });
  }, [priceEditor.item]);

  useEffect(() => {
    if (priceEditor.item) {
      if (!editOverlayVisible) {
        setEditOverlayVisible(true);
        editOverlayAnim.setValue(0);
      }
      Animated.spring(editOverlayAnim, {
        toValue: 1,
        damping: 22,
        stiffness: 180,
        mass: 0.9,
        useNativeDriver: true,
      }).start();
    } else if (editOverlayVisible) {
      Animated.timing(editOverlayAnim, {
        toValue: 0,
        duration: 200,
        easing: Easing.inOut(Easing.cubic),
        useNativeDriver: true,
      }).start(({ finished }) => {
        if (finished) setEditOverlayVisible(false);
      });
    }
  }, [priceEditor.item, editOverlayAnim, editOverlayVisible]);

  const handlePriceTitleChange = (value) => {
    setPriceEditor((prev) => ({ ...prev, title: value }));
  };

  const handlePriceEmojiChange = (value) => {
    setPriceEditor((prev) => ({ ...prev, emoji: limitEmojiInput(value) }));
  };

  const handlePriceCategoryChange = (value) => {
    if (!IMPULSE_CATEGORY_DEFS[value]) return;
    setPriceEditor((prev) => ({ ...prev, category: value }));
  };

  const handlePriceFrequencyChange = (value) => {
    const normalized = normalizeFrequencyId(value) || "daily";
    setPriceEditor((prev) => ({
      ...prev,
      frequency: normalized,
    }));
  };

  const handlePriceCustomFrequencyChange = (value) => {
    const normalized = normalizeCustomFrequency(value) || { ...DEFAULT_CUSTOM_FREQUENCY };
    setPriceEditor((prev) => ({
      ...prev,
      frequencyCustom: normalized,
    }));
  };

  const handleTemptationArchiveToggle = useCallback(
    (item) => {
      if (!item) return;
      const templateId = item.id || item.templateId;
      if (!templateId) return;
      triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
      if (!archivedTemptationSet.has(templateId)) {
        cancelScheduledNotificationsForTemplate(templateId);
        clearFrequencyReminderStateForTemplate(templateId);
        setSmartReminders((prev) =>
          normalizeSmartReminderEntries((prev || []).filter((entry) => entry?.templateId !== templateId))
        );
      }
      setArchivedTemptations((prev) => {
        if (prev.includes(templateId)) {
          return prev.filter((id) => id !== templateId);
        }
        return [templateId, ...prev.filter((id) => id !== templateId)];
      });
    },
    [
      archivedTemptationSet,
      cancelScheduledNotificationsForTemplate,
      clearFrequencyReminderStateForTemplate,
      setSmartReminders,
      triggerHaptic,
    ]
  );

  const handlePriceInputChange = (value) => {
    setPriceEditor((prev) => ({ ...prev, value }));
  };

  const handlePriceDescriptionChange = (value) => {
    setPriceEditor((prev) => ({ ...prev, description: value }));
  };

  const patchTemptationDisplay = useCallback((templateId, patch = {}) => {
    if (!templateId || !patch || typeof patch !== "object") return;
    setTemptations((prev) =>
      prev.map((card) => (card.id === templateId ? { ...card, ...patch } : card))
    );
    setQuickTemptations((prev) => {
      let changed = false;
      const next = prev.map((card) => {
        if (card.id !== templateId) return card;
        changed = true;
        return { ...card, ...patch };
      });
      return changed ? next : prev;
    });
  }, []);

  const removeTemptationTemplate = useCallback(
    (templateId) => {
      if (!templateId) return;
      cancelScheduledNotificationsForTemplate(templateId);
      clearFrequencyReminderStateForTemplate(templateId);
      setSmartReminders((prev) =>
        normalizeSmartReminderEntries((prev || []).filter((entry) => entry?.templateId !== templateId))
      );
      const existsInQuick = quickTemptations.some((card) => card.id === templateId);
      if (existsInQuick) {
        setQuickTemptations((prev) => prev.filter((card) => card.id !== templateId));
      } else {
        setHiddenTemptations((prev) => (prev.includes(templateId) ? prev : [...prev, templateId]));
      }
      setArchivedTemptations((prev) => prev.filter((id) => id !== templateId));
      setTemptationGoalMap((prev) => {
        if (!prev[templateId]) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setCatalogOverrides((prev) => {
        if (!(templateId in prev)) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setPricePrecisionOverrides((prev) => {
        if (!(templateId in prev)) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setTitleOverrides((prev) => {
        if (!(templateId in prev)) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setEmojiOverrides((prev) => {
        if (!(templateId in prev)) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setCategoryOverrides((prev) => {
        if (!(templateId in prev)) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setDescriptionOverrides((prev) => {
        if (!(templateId in prev)) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setRefuseStats((prev) => {
        if (!prev[templateId]) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setPendingList((prev) => prev.filter((entry) => entry.templateId !== templateId));
    },
    [
      cancelScheduledNotificationsForTemplate,
      clearFrequencyReminderStateForTemplate,
      quickTemptations,
      setQuickTemptations,
      setHiddenTemptations,
      setArchivedTemptations,
      setTemptationGoalMap,
      setCatalogOverrides,
      setPricePrecisionOverrides,
      setTitleOverrides,
      setEmojiOverrides,
      setDescriptionOverrides,
      setRefuseStats,
      setPendingList,
      setSmartReminders,
    ]
  );

  const persistPriceOverride = (valueUSD = null, precision = null) => {
    const targetId = priceEditor.item?.id;
    if (!targetId) return;
    setCatalogOverrides((prev) => {
      const next = { ...prev };
      if (valueUSD) {
        next[targetId] = valueUSD;
      } else {
        delete next[targetId];
      }
      return next;
    });
    setPricePrecisionOverrides((prev) => {
      const next = { ...prev };
      const hasPrecision = typeof precision === "number" && Number.isFinite(precision) && precision >= 0;
      if (valueUSD && hasPrecision) {
        next[targetId] = precision;
      } else if (!valueUSD || !hasPrecision) {
        delete next[targetId];
      }
      return next;
    });
  };

  const persistTitleOverride = (value = null) => {
    const targetId = priceEditor.item?.id;
    if (!targetId) return;
    setTitleOverrides((prev) => {
      const next = { ...prev };
      if (value && value.length) {
        next[targetId] = value;
      } else {
        delete next[targetId];
      }
      return next;
    });
  };

  const persistEmojiOverride = (value = null) => {
    const targetId = priceEditor.item?.id;
    if (!targetId) return;
    setEmojiOverrides((prev) => {
      const next = { ...prev };
      if (value && value.length) {
        next[targetId] = value;
      } else {
        delete next[targetId];
      }
      return next;
    });
  };

  const persistDescriptionOverride = (value = null) => {
    const targetId = priceEditor.item?.id;
    if (!targetId) return;
    setDescriptionOverrides((prev) => {
      const next = { ...prev };
      const normalized =
        typeof value === "string" && value.trim().length ? value.trim() : null;
      if (normalized) {
        next[targetId] = normalized;
      } else {
        delete next[targetId];
      }
      return next;
    });
  };

  const persistCategoryOverride = (value = null) => {
    const targetId = priceEditor.item?.id;
    if (!targetId) return;
    setCategoryOverrides((prev) => {
      const next = { ...prev };
      if (value && IMPULSE_CATEGORY_DEFS[value]) {
        next[targetId] = value;
      } else {
        delete next[targetId];
      }
      return next;
    });
  };

  const applyFrequencySelectionToTemplate = useCallback(
    (templateId, frequencyValue, customFrequencyValue = null, templateTitle = null) => {
      if (!templateId) return;
      let frequency = normalizeFrequencyId(frequencyValue) || "daily";
      let frequencyCustom = normalizeCustomFrequency(customFrequencyValue) || null;
      if (frequency === "biweekly") {
        frequency = "custom";
        frequencyCustom = { ...DEFAULT_CUSTOM_FREQUENCY };
      }
      if (frequency === "custom" && !frequencyCustom) {
        frequencyCustom = { ...DEFAULT_CUSTOM_FREQUENCY };
      }
      const customIntervalMs = frequency === "custom" ? getCustomFrequencyIntervalMs(frequencyCustom) : null;
      const bucketIntervalMs =
        frequency && frequency !== "custom" ? getFrequencyIntervalMs(frequency) : null;
      setTemptationInteractions((prev) => {
        const prevEntry = prev?.[templateId] || {};
        const lastInteractionAt = Number(prevEntry.lastInteractionAt) || 0;
        const intervalMs = frequency === "custom" ? customIntervalMs || null : null;
        const baseIntervalMs =
          Number.isFinite(customIntervalMs) && customIntervalMs > 0
            ? customIntervalMs
            : Number.isFinite(bucketIntervalMs) && bucketIntervalMs > 0
            ? bucketIntervalMs
            : null;
        const nextCheckAt =
          lastInteractionAt && baseIntervalMs ? lastInteractionAt + baseIntervalMs : null;
        return {
          ...(prev || {}),
          [templateId]: {
            ...prevEntry,
            frequency: frequency || null,
            frequencyCustom: frequency === "custom" ? frequencyCustom || null : null,
            intervalMs,
            nextCheckAt: nextCheckAt ?? prevEntry.nextCheckAt ?? null,
            templateTitle: templateTitle || prevEntry.templateTitle || null,
            frequencyReminderId: null,
            frequencyReminderIds: [],
            frequencyReminderScheduledAt: null,
            frequencyReminderLocale: null,
            frequencyReminderPlanKey: null,
          },
        };
      });
    },
    [setTemptationInteractions]
  );

  const propagateTemptationEdit = useCallback(
    (templateId, { label, emoji, priceUSD, category, pricePrecision = null }) => {
      if (!templateId) return;
      const fallbackTitle = resolveTranslationValueForLanguage(language, "defaultWishTitle") || "Goal";
      const normalizedLabel = (label && label.trim()) || fallbackTitle;
      const decoratedTitle = buildTemptationDisplayTitle(emoji, normalizedLabel, fallbackTitle);
      const numericPrice = Number(priceUSD);
      const hasPrice = Number.isFinite(numericPrice) && numericPrice > 0;
      const normalizedPrecision =
        typeof pricePrecision === "number" && Number.isFinite(pricePrecision) && pricePrecision >= 0
          ? pricePrecision
          : null;
      setPendingList((prev) => {
        let mutated = false;
        const next = prev.map((entry) => {
          if (entry.templateId !== templateId) return entry;
          const updates = {};
          if (decoratedTitle && entry.title !== decoratedTitle) {
            updates.title = decoratedTitle;
          }
          if (hasPrice && entry.priceUSD !== numericPrice) {
            updates.priceUSD = numericPrice;
          }
          if (normalizedPrecision !== null && entry.pricePrecision !== normalizedPrecision) {
            updates.pricePrecision = normalizedPrecision;
          } else if (normalizedPrecision === null && entry.pricePrecision != null) {
            updates.pricePrecision = null;
          }
          if (!Object.keys(updates).length) return entry;
          mutated = true;
          return { ...entry, ...updates };
        });
        return mutated ? next : prev || [];
      });
      setWishes((prev) => {
        let mutated = false;
        const next = prev.map((wish) => {
          if (wish.templateId !== templateId) return wish;
          const updates = {};
          if (decoratedTitle && wish.title !== decoratedTitle) {
            updates.title = decoratedTitle;
          }
          if (emoji && wish.emoji !== emoji) {
            updates.emoji = emoji;
          }
          if (hasPrice && wish.targetUSD !== numericPrice) {
            updates.targetUSD = numericPrice;
          }
          if (!Object.keys(updates).length) return wish;
          mutated = true;
          return { ...wish, ...updates };
        });
        return mutated ? next : prev;
      });
      setImpulseTracker((prev) => {
        const current = prev || INITIAL_IMPULSE_TRACKER;
        let mutated = false;
        const nextEvents = (current.events || []).map((event) => {
          if (event.templateId !== templateId) return event;
          const updates = {};
          if (decoratedTitle && event.title !== decoratedTitle) {
            updates.title = decoratedTitle;
          }
          if (emoji && event.emoji !== emoji) {
            updates.emoji = emoji;
          }
          if (hasPrice && event.amountUSD !== numericPrice) {
            updates.amountUSD = numericPrice;
          }
          if (category && event.category !== category) {
            updates.category = category;
          }
          if (!Object.keys(updates).length) return event;
          mutated = true;
          return { ...event, ...updates };
        });
        if (!mutated) return current;
        return { ...current, events: nextEvents };
      });
      const historySnapshot = Array.isArray(resolvedHistoryEvents) ? resolvedHistoryEvents : [];
      let historyMutated = false;
      let savedDelta = 0;
      const goalDeltas = {};
      const nextHistory = historySnapshot.map((entry) => {
        if (!entry || !entry.meta) return entry;
        const metaTemplateId =
          entry?.meta?.templateId || entry?.meta?.template_id || entry?.meta?.templateID;
        if (metaTemplateId !== templateId) return entry;
        const nextMeta = { ...(entry.meta || {}) };
        let metaChanged = false;
        if (decoratedTitle && nextMeta.title !== decoratedTitle) {
          nextMeta.title = decoratedTitle;
          metaChanged = true;
        }
        if (emoji && nextMeta.emoji !== emoji) {
          nextMeta.emoji = emoji;
          metaChanged = true;
        }
        if (hasPrice) {
          if (typeof nextMeta.amountUSD === "number" && nextMeta.amountUSD !== numericPrice) {
            const delta = numericPrice - nextMeta.amountUSD;
            if (delta) {
              if (entry.kind === "refuse_spend") {
                savedDelta += delta;
                const goalId =
                  entry.meta?.goalId ||
                  entry.meta?.goal_id ||
                  entry.meta?.savingTargetId ||
                  entry.meta?.saving_target_id ||
                  null;
                if (goalId) {
                  goalDeltas[goalId] = (goalDeltas[goalId] || 0) + delta;
                }
              } else if (entry.kind === "spend" && spendReducesSavings) {
                savedDelta -= delta;
              }
            }
            nextMeta.amountUSD = numericPrice;
            metaChanged = true;
          }
          if (typeof nextMeta.targetUSD === "number" && nextMeta.targetUSD !== numericPrice) {
            nextMeta.targetUSD = numericPrice;
            metaChanged = true;
          }
          if (typeof nextMeta.priceUSD === "number" && nextMeta.priceUSD !== numericPrice) {
            nextMeta.priceUSD = numericPrice;
            metaChanged = true;
          }
        }
        if (!metaChanged) return entry;
        historyMutated = true;
        return { ...entry, meta: nextMeta };
      });
      if (historyMutated) {
        setHistoryEvents(nextHistory);
        if (savedDelta) {
          setSavedTotalUSD((prev) => Math.max(0, prev + savedDelta));
          setProgressSavedTotalUSD((prev) => Math.max(0, prev + savedDelta));
        }
        Object.entries(goalDeltas).forEach(([goalId, delta]) => {
          applyHistoryGoalDelta(goalId, delta);
        });
        if (hasPrice) {
          setChallengesState((prev) => rebuildChallengeProgressFromHistory(nextHistory, prev));
        }
      }
    },
    [
      applyHistoryGoalDelta,
      language,
      rebuildChallengeProgressFromHistory,
      resolvedHistoryEvents,
      setChallengesState,
      setHistoryEvents,
      setImpulseTracker,
      setPendingList,
      setProgressSavedTotalUSD,
      setSavedTotalUSD,
      setWishes,
      spendReducesSavings,
    ]
  );

  const savePriceEdit = () => {
    if (!priceEditor.item) return;
    const parsed = parseFloat((priceEditor.value || "").replace(",", "."));
    if (!Number.isFinite(parsed) || parsed <= 0) {
      Alert.alert("Almost", t("priceEditError"));
      return;
    }
    const usdValue = parsed / (CURRENCY_RATES[activeCurrency] || 1);
    const previousPriceUSD = priceEditor.item.priceUSD || priceEditor.item.basePriceUSD || 0;
    const manualPrecision = getManualInputPrecision(priceEditor.value || "");
    persistPriceOverride(usdValue, manualPrecision);
    const titleValue = (priceEditor.title || "").trim();
    persistTitleOverride(titleValue || null);
    const hasCustomEmoji = !!priceEditor.emoji?.trim();
    const resolvedEmoji = hasCustomEmoji
      ? normalizeEmojiValue(priceEditor.emoji, priceEditor.item.emoji || DEFAULT_TEMPTATION_EMOJI)
      : priceEditor.item.emoji || DEFAULT_TEMPTATION_EMOJI;
    persistEmojiOverride(hasCustomEmoji ? resolvedEmoji : null);
    const categoryValue =
      priceEditor.category && IMPULSE_CATEGORY_DEFS[priceEditor.category]
        ? priceEditor.category
        : null;
    const previousCategory = resolveTemptationCategory(priceEditor.item);
    const nextCategory = categoryValue || previousCategory;
    persistCategoryOverride(categoryValue);
    const descriptionValue = (priceEditor.description || "").trim();
    const previousDescriptionOverride =
      typeof descriptionOverrides[priceEditor.item.id] === "string"
        ? descriptionOverrides[priceEditor.item.id]
        : "";
    const changedDescription = descriptionValue !== previousDescriptionOverride;
    persistDescriptionOverride(descriptionValue || null);
    const changedPrice = Math.abs(previousPriceUSD - usdValue) > 0.0001;
    const changedCategory = nextCategory !== previousCategory;
    const previousFrequencyState = resolveFrequencySelectionForItem(priceEditor.item);
    let nextFrequency = normalizeFrequencyId(priceEditor.frequency) || "daily";
    let nextFrequencyCustom = normalizeCustomFrequency(priceEditor.frequencyCustom) || null;
    if (nextFrequency === "biweekly") {
      nextFrequency = "custom";
      nextFrequencyCustom = { ...DEFAULT_CUSTOM_FREQUENCY };
    }
    if (nextFrequency === "custom" && !nextFrequencyCustom) {
      nextFrequencyCustom = { ...DEFAULT_CUSTOM_FREQUENCY };
    }
    if (nextFrequency !== "custom") {
      nextFrequencyCustom = null;
    }
    const prevCustom = normalizeCustomFrequency(previousFrequencyState.frequencyCustom) || null;
    const shouldCompareCustom =
      previousFrequencyState.frequency === "custom" || nextFrequency === "custom";
    const customChanged = shouldCompareCustom
      ? (prevCustom?.count ?? null) !== (nextFrequencyCustom?.count ?? null) ||
        (prevCustom?.unit ?? null) !== (nextFrequencyCustom?.unit ?? null)
      : false;
    const changedFrequency = previousFrequencyState.frequency !== nextFrequency || customChanged;
    const templateId = priceEditor.item.id;
    const storedFrequency = normalizeFrequencyId(temptationInteractions?.[templateId]?.frequency) || null;
    const shouldApplyFrequency = changedFrequency || !storedFrequency;
    const nextFrequencyIntervalMs = resolveFrequencyIntervalMs(nextFrequency, nextFrequencyCustom);
    patchTemptationDisplay(priceEditor.item.id, {
      priceUSD: usdValue,
      pricePrecision: manualPrecision,
      titleOverride: titleValue || null,
      emoji: resolvedEmoji,
      impulseCategoryOverride: categoryValue || null,
      descriptionOverride: descriptionValue || null,
      frequency: nextFrequency,
      frequencyCustom: nextFrequency === "custom" ? nextFrequencyCustom || null : null,
      frequencyIntervalMs: nextFrequency === "custom" ? nextFrequencyIntervalMs || null : null,
    });
    if (shouldApplyFrequency) {
      applyFrequencySelectionToTemplate(
        templateId,
        nextFrequency,
        nextFrequencyCustom,
        resolveTemptationTitle(
          priceEditor.item,
          language,
          titleOverrides[priceEditor.item.id] || priceEditor.item.titleOverride || null
        )
      );
    }
    const fallbackTitle =
      resolveTemptationTitle(
        priceEditor.item,
        language,
        titleOverrides[priceEditor.item.id] || priceEditor.item.titleOverride || null
      ) || resolveTranslationValueForLanguage(language, "defaultWishTitle") || "Goal";
    const normalizedLabel = titleValue || fallbackTitle;
    propagateTemptationEdit(priceEditor.item.id, {
      label: normalizedLabel,
      emoji: resolvedEmoji,
      priceUSD: usdValue,
      category: nextCategory,
      pricePrecision: manualPrecision,
    });
    logEvent("temptation_edited", {
      temptation_id: priceEditor.item.id,
      changed_price: changedPrice,
      changed_category: changedCategory,
      changed_description: changedDescription,
      changed_frequency: changedFrequency ? 1 : 0,
      frequency: nextFrequency,
    });
    closePriceEditor();
  };

  const promptTemptationDelete = useCallback(
    (targetItem = null) => {
      const item = targetItem || priceEditor.item;
      if (!item) return;
      Alert.alert(t("priceEditDelete"), t("priceEditDeleteConfirm"), [
        { text: t("priceEditCancel"), style: "cancel" },
        {
          text: t("priceEditDelete"),
          style: "destructive",
          onPress: () => {
            logEvent("temptation_deleted", {
              temptation_id: item.id,
              is_custom: isCustomTemptation(item),
              price: convertToCurrency(
                item.priceUSD || item.basePriceUSD || 0,
                profile.currency || DEFAULT_PROFILE.currency
              ),
            });
            removeTemptationTemplate(item.id);
            if (priceEditor.item?.id === item.id) {
              closePriceEditor();
            }
          },
        },
      ]);
    },
    [closePriceEditor, logEvent, priceEditor.item, profile.currency, removeTemptationTemplate, t]
  );
  const handleTemptationDelete = useCallback(
    (item) => {
      promptTemptationDelete(item);
    },
    [promptTemptationDelete]
  );

  const handleRemoveWish = useCallback(
    (wishId) => {
      const targetWish = wishes.find((wish) => wish.id === wishId);
      if (!targetWish) return;
      const performRemoval = () => {
        setWishes((prev) => prev.filter((wish) => wish.id !== wishId));
        if (
          targetWish.kind === PRIMARY_GOAL_KIND &&
          targetWish.goalId
        ) {
          setProfile((prev) => removePrimaryGoalFromProfile(prev, targetWish.goalId));
          setProfileDraft((prev) => removePrimaryGoalFromProfile(prev, targetWish.goalId));
        }
        logEvent("goal_abandoned", {
          goal_id: targetWish.goalId || targetWish.id,
          reason: "deleted",
        });
      };
      Alert.alert(t("wishlistTitle"), t("wishlistRemoveConfirm"), [
        { text: t("priceEditCancel"), style: "cancel" },
        {
          text: t("wishlistRemove"),
          style: "destructive",
          onPress: performRemoval,
        },
      ]);
    },
    [logEvent, setProfile, setProfileDraft, t, wishes]
  );

  const handlePendingDecision = useCallback(
    async (pendingItem, decision) => {
      if (!pendingItem) return;
      if (pendingItem.notificationId) {
        try {
          await safeNotifications.cancelScheduledNotificationAsync(pendingItem.notificationId);
        } catch (error) {
          console.warn("cancel reminder", error);
        }
      }
      setPendingList((prev) => prev.filter((entry) => entry.id !== pendingItem.id));
      const template = findTemplateById(pendingItem.templateId);
      const title =
        pendingItem.title || template?.title?.[language] || template?.title?.en || "Goal";
      const priceUSD = pendingItem.priceUSD || template?.basePriceUSD || 0;
      const decisionTimestamp = Date.now();
      const daysWaited = Math.max(
        0,
        Math.round((decisionTimestamp - (pendingItem.createdAt || decisionTimestamp)) / DAY_MS)
      );
      const actionTemplateId = template?.id || pendingItem.templateId || pendingItem.id;
      const actionItem = {
        ...(template || {}),
        id: actionTemplateId,
        templateId: actionTemplateId,
        title: template?.title || pendingItem.title || "Goal",
        emoji: pendingItem.emoji || template?.emoji || DEFAULT_TEMPTATION_EMOJI,
        priceUSD,
        basePriceUSD: template?.basePriceUSD || priceUSD,
        categories: template?.categories || pendingItem.categories || [],
      };
      if (decision === "want") {
        const targetUSD = pendingItem.priceUSD || template?.basePriceUSD || 0;
        const newWish = {
          id: `wish-${pendingItem.templateId}-${Date.now()}`,
          templateId: pendingItem.templateId,
          title,
          targetUSD,
          savedUSD: 0,
          status: "active",
          createdAt: Date.now(),
          autoManaged: false,
          emoji: template?.emoji || DEFAULT_GOAL_EMOJI,
        };
        setWishes((prev) => insertWishAfterPrimary(prev, newWish));
        ensureActiveGoalForNewWish(newWish);
        setDecisionStats((prev) => ({
          ...prev,
          resolvedToWishes: prev.resolvedToWishes + 1,
        }));
        logEvent(
          "pending_decide_want",
          buildTemptationPayload(
            { ...pendingItem, priceUSD },
            {
              days_waited: daysWaited,
            }
          )
        );
        logHistoryEvent("pending_to_wish", { title, targetUSD, wishId: newWish.id, pendingId: pendingItem.id });
        triggerOverlayState("purchase", t("wishAdded", { title }));
        triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
        return;
      }
      if (decision === "spend") {
        await handleTemptationAction("spend", actionItem, {
          skipPrompt: true,
          shouldAssign: false,
        });
        return;
      }
      if (decision === "decline") {
        const price = priceUSD;
        const resolvedCategory = resolveTemptationCategory(actionItem);
        setDecisionStats((prev) => ({
          ...prev,
          resolvedToDeclines: prev.resolvedToDeclines + 1,
        }));
        logEvent(
          "pending_decide_decline",
          buildTemptationPayload(
            { ...pendingItem, priceUSD: price },
            {
              days_waited: daysWaited,
            }
          )
        );
        logHistoryEvent("pending_to_decline", { title, amountUSD: price, category: resolvedCategory });
        await handleTemptationAction("save", actionItem, {
          skipPrompt: true,
          shouldAssign: false,
        });
        return;
      }
    },
    [
      buildTemptationPayload,
      findTemplateById,
      handleTemptationAction,
      language,
      logHistoryEvent,
      profile.currency,
      resolveTemptationCategory,
      t,
    ]
  );
  useEffect(() => {
    notificationActionHandlerRef.current = async ({ actionIdentifier, notification }) => {
      const action =
        actionIdentifier === NOTIFICATION_ACTION_SAVE
          ? "save"
          : actionIdentifier === NOTIFICATION_ACTION_SPEND
          ? "spend"
          : null;
      if (!action) return;
      const data = notification?.request?.content?.data || {};
      const kind = typeof data.kind === "string" ? data.kind : null;
      const pendingId = typeof data.pendingId === "string" ? data.pendingId : null;
      if (kind === "pending_decision" && pendingId) {
        const pendingItem = (pendingListRef.current || []).find((entry) => entry?.id === pendingId);
        if (pendingItem) {
          await handlePendingDecision(pendingItem, action === "spend" ? "spend" : "decline");
          return;
        }
      }
      const templateId =
        data?.templateId || data?.template_id || data?.templateID || data?.template || null;
      const template = templateId ? findTemplateById(templateId) : null;
      const fallbackTitle =
        typeof data?.title === "string" && data.title.trim() ? data.title.trim() : t("defaultDealTitle");
      const fallbackEmoji = typeof data?.emoji === "string" && data.emoji.trim() ? data.emoji : "âœ¨";
      const fallbackAmount = Math.max(0, Number(data?.amountUSD ?? data?.priceUSD ?? data?.amount) || 0);
      const item = template
        ? { ...template, id: template.id || templateId, emoji: template.emoji || fallbackEmoji }
        : {
            id: templateId || `push_${Date.now()}`,
            title: fallbackTitle,
            emoji: fallbackEmoji,
            priceUSD: fallbackAmount,
            basePriceUSD: fallbackAmount,
            categories: [],
          };
      if (action === "spend") {
        await handleTemptationAction("spend", item, {
          bypassSpendPrompt: true,
          skipPrompt: true,
        });
        return;
      }
      await handleTemptationAction("save", item, {
        skipPrompt: true,
        skipStreakRecoveryPrompt: true,
      });
    };
  }, [handlePendingDecision, handleTemptationAction, t]);
  const handlePendingDelete = useCallback(
    (pendingItem) => {
      if (!pendingItem) return;
      const template = findTemplateById(pendingItem.templateId);
      const title =
        pendingItem.title || template?.title?.[language] || template?.title?.en || "Goal";
      const performDelete = async () => {
        if (pendingItem.notificationId) {
          try {
            await safeNotifications.cancelScheduledNotificationAsync(pendingItem.notificationId);
          } catch (error) {
            console.warn("cancel reminder", error);
          }
        }
        setPendingList((prev) => prev.filter((entry) => entry.id !== pendingItem.id));
        logHistoryEvent("pending_removed", { title, pendingId: pendingItem.id });
        logEvent("pending_deleted", { pending_id: pendingItem.id });
      };
      Alert.alert(t("pendingTitle"), t("pendingDeleteConfirm"), [
        { text: t("priceEditCancel"), style: "cancel" },
        {
          text: t("goalSwipeDelete"),
          style: "destructive",
          onPress: () => {
            performDelete();
          },
        },
      ]);
    },
    [findTemplateById, language, logEvent, logHistoryEvent, setPendingList, t]
  );

  const handlePendingExtend = useCallback(
    async (pendingItem) => {
      if (!pendingItem) return;
      const template = findTemplateById(pendingItem.templateId);
      const title = pendingItem.title || template?.title?.[language] || template?.title?.en || "Goal";
      const nextDue = Date.now() + PENDING_EXTENSION_MS;
      if (pendingItem.notificationId) {
        safeNotifications.cancelScheduledNotificationAsync(pendingItem.notificationId);
      }
      const reminderId = await schedulePendingReminder(title, nextDue, {
        pendingId: pendingItem.id,
        templateId: pendingItem.templateId,
        title,
        emoji: pendingItem.emoji || template?.emoji || DEFAULT_TEMPTATION_EMOJI,
        amountUSD: pendingItem.priceUSD || template?.basePriceUSD || 0,
      });
      setPendingList((prev) =>
        prev.map((entry) =>
          entry.id === pendingItem.id
            ? {
                ...entry,
                decisionDue: nextDue,
                notificationId: reminderId || null,
              }
            : entry
        )
      );
    },
    [findTemplateById, language, schedulePendingReminder, setPendingList]
  );

  useEffect(
    () => () => {
      if (overlayRetryTimerRef.current) {
        clearTimeout(overlayRetryTimerRef.current);
        overlayRetryTimerRef.current = null;
      }
    },
    []
  );
  useEffect(() => {
    if (!pendingFocusId) return;
    if (activeTab !== "pending") return;
    if (!pendingHydrated) return;
    const hasItem = (pendingList || []).some((entry) => entry?.id === pendingFocusId);
    if (!hasItem) {
      setPendingFocusId(null);
      return;
    }
    const tryScroll = () => {
      const y = pendingCardLayoutsRef.current.get(pendingFocusId);
      if (typeof y !== "number") return false;
      pendingScrollRef.current?.scrollTo({ y: Math.max(0, y - 24), animated: true });
      return true;
    };
    if (tryScroll()) {
      setPendingFocusId(null);
      return;
    }
    const timer = setTimeout(() => {
      if (tryScroll()) {
        setPendingFocusId(null);
      }
    }, 300);
    return () => clearTimeout(timer);
  }, [activeTab, pendingFocusId, pendingHydrated, pendingList]);
  useEffect(
    () => () => {
      if (celebrationGapTimerRef.current) {
        clearTimeout(celebrationGapTimerRef.current);
        celebrationGapTimerRef.current = null;
      }
    },
    []
  );

  const processOverlayQueue = useCallback(() => {
    if (overlayActiveRef.current) return;
    const next = overlayQueueRef.current[0];
    if (!next) return;
    if ((!overlayEnvironmentReady || blockingModalVisible) && !next.force) return;
    overlayQueueRef.current.shift();
    overlayActiveRef.current = true;
    if (overlayTimer.current) {
      clearTimeout(overlayTimer.current);
    }
    if (next.type === "purchase") {
      setConfettiKey((prev) => prev + 1);
    }
    setOverlay({ type: next.type, message: next.message, clearQueueOnDismiss: !!next.clearQueueOnDismiss });
    const defaultDuration =
      next.type === "cart"
        ? 1800
        : next.type === "level"
        ? 3200
        : next.type === "reward"
        ? 3200
        : next.type === "daily_reward"
        ? 3200
        : next.type === "save"
        ? null
        : next.type === "usage_streak"
        ? null
        : next.type === "usage_streak_weekly_reward"
        ? null
        : next.type === "usage_streak_restore"
        ? null
        : next.type === "streak_pledge"
        ? null
        : next.type === "streak_pledge_reward"
        ? null
        : next.type === "premium_unlock"
        ? null
        : next.type === "impulse_alert"
        ? null
        : next.type === "focus_digest"
        ? null
        : next.type === "primary_temptation"
        ? null
        : 2600;
    const timeout = next.duration ?? defaultDuration;
    if (typeof timeout === "number" && Number.isFinite(timeout) && timeout > 0) {
      overlayTimer.current = setTimeout(() => {
        lastOverlayDismissedAtRef.current = Date.now();
        setOverlay(null);
        overlayActiveRef.current = false;
        processOverlayQueue();
      }, timeout);
    } else {
      overlayTimer.current = null;
    }
  }, [blockingModalVisible, overlayEnvironmentReady]);

  const scheduleOverlayRetry = useCallback(() => {
    if (overlayRetryTimerRef.current) return;
    if (!overlayQueueRef.current.length) return;
    overlayRetryTimerRef.current = setTimeout(() => {
      overlayRetryTimerRef.current = null;
      if ((!overlayEnvironmentReady || blockingModalVisible) && overlayQueueRef.current.length) {
        scheduleOverlayRetry();
        return;
      }
      processOverlayQueue();
    }, 250);
  }, [blockingModalVisible, overlayEnvironmentReady, processOverlayQueue]);

  const triggerOverlayState = useCallback(
    (type, message, config) => {
      let duration = null;
      let clearQueueOnDismiss = false;
      let force = false;
      if (typeof config === "number") {
        duration = config;
      } else if (config && typeof config === "object") {
        duration = typeof config.duration === "number" ? config.duration : null;
        clearQueueOnDismiss = !!config.clearQueueOnDismiss;
        force = !!config.force;
      }
      overlayQueueRef.current.push({ type, message, duration, clearQueueOnDismiss, force });
      processOverlayQueue();
      if (!overlayEnvironmentReady || blockingModalVisible) {
        scheduleOverlayRetry();
      }
    },
    [blockingModalVisible, overlayEnvironmentReady, processOverlayQueue, scheduleOverlayRetry]
  );
  triggerOverlayStateRef.current = triggerOverlayState;

  const scheduleCelebrationOverlay = useCallback(() => {
    if (celebrationGapTimerRef.current) return;
    if (!celebrationQueueRef.current.length) return;
    const now = Date.now();
    const lastAt = lastCelebrationAtRef.current || 0;
    const gapRemaining = Math.max(CELEBRATION_OVERLAY_GAP_MS - (now - lastAt), 0);
    celebrationGapTimerRef.current = setTimeout(() => {
      celebrationGapTimerRef.current = null;
      const next = celebrationQueueRef.current.shift();
      if (!next) return;
      lastCelebrationAtRef.current = Date.now();
      triggerOverlayState(next.type, next.message, next.config);
      if (celebrationQueueRef.current.length) {
        scheduleCelebrationOverlay();
      }
    }, gapRemaining);
  }, [triggerOverlayState]);

  const queueCelebrationOverlay = useCallback(
    (type, message, config) => {
      const now = Date.now();
      const lastAt = lastCelebrationAtRef.current || 0;
      if (now - lastAt >= CELEBRATION_OVERLAY_GAP_MS && !celebrationQueueRef.current.length) {
        lastCelebrationAtRef.current = now;
        triggerOverlayState(type, message, config);
        return;
      }
      celebrationQueueRef.current.push({ type, message, config });
      scheduleCelebrationOverlay();
    },
    [scheduleCelebrationOverlay, triggerOverlayState]
  );
  queueCelebrationOverlayRef.current = queueCelebrationOverlay;

  useEffect(() => {
    if (overlayEnvironmentReady && !blockingModalVisible) {
      processOverlayQueue();
    } else if (blockingModalVisible && overlayQueueRef.current.length) {
      scheduleOverlayRetry();
    }
  }, [blockingModalVisible, overlayEnvironmentReady, processOverlayQueue, scheduleOverlayRetry]);

  useEffect(() => {
    if (overlay?.type === "level") {
      pendingLevelCelebrationRef.current = null;
    }
  }, [overlay]);

  const dismissOverlay = useCallback((maybeOptions = {}) => {
    const options =
      maybeOptions && typeof maybeOptions === "object" && "nativeEvent" in maybeOptions ? {} : maybeOptions;
    const shouldPromptGoalRenewal =
      overlay?.type === "goal_complete" && goalRenewalPromptAfterGoalRef.current;
    if (overlay?.type === "focus_digest" && overlay?.message?.prompt) {
      focusPromptActiveRef.current = false;
    }
    if (overlayTimer.current) {
      clearTimeout(overlayTimer.current);
      overlayTimer.current = null;
    }
    if (overlayActiveRef.current) {
      overlayActiveRef.current = false;
    }
    const dismissedAt = Date.now();
    lastOverlayDismissedAtRef.current = dismissedAt;
    if (overlay?.type === "save") {
      lastSaveOverlayDismissedAtRef.current = dismissedAt;
    }
    const usageStreakRestoreCandidate =
      overlay?.type === "usage_streak" ? getUsageStreakRestoreBase(overlay?.message) : null;
    const shouldQueueUsageStreakRestore = !!usageStreakRestoreCandidate?.shouldOfferRestore;
    const weeklyRewardPayload =
      overlay?.type === "usage_streak" &&
      overlay?.message?.weeklyReward &&
      Number(overlay.message.weeklyReward.rewardBlueCoins) > 0
        ? overlay.message.weeklyReward
        : null;
    const hasQueuedCelebrationFollowUp =
      overlay?.type === "save" &&
      overlayQueueRef.current.some((entry) => ["level", "health", "cart"].includes(entry?.type));
    const requestedClearQueue =
      typeof options.clearQueue === "boolean" ? options.clearQueue : null;
    const shouldClearQueue = hasQueuedCelebrationFollowUp
      ? false
      : requestedClearQueue !== null
      ? requestedClearQueue
      : !!overlay?.clearQueueOnDismiss;
    if (shouldClearQueue) {
      overlayQueueRef.current = [];
    }
    setOverlay(null);
    if (weeklyRewardPayload) {
      const alreadyQueued = overlayQueueRef.current.some(
        (entry) => entry?.type === "usage_streak_weekly_reward"
      );
      if (!alreadyQueued) {
        overlayQueueRef.current.unshift({
          type: "usage_streak_weekly_reward",
          message: weeklyRewardPayload,
          duration: null,
          clearQueueOnDismiss: false,
          force: false,
        });
      }
    }
    if (shouldQueueUsageStreakRestore) {
      const alreadyQueued = overlayQueueRef.current.some(
        (entry) => entry?.type === "usage_streak_restore"
      );
      if (!alreadyQueued) {
        overlayQueueRef.current.unshift({
          type: "usage_streak_restore",
          message: overlay?.message,
          duration: null,
          clearQueueOnDismiss: false,
          force: false,
        });
      }
    }
    processOverlayQueue();
    const shouldPromptGoalRenewalFallback =
      !shouldPromptGoalRenewal &&
      goalRenewalPromptAfterGoalRef.current &&
      !pendingGoalCelebration &&
      overlayQueueRef.current.length === 0 &&
      celebrationQueueRef.current.length === 0;
    if (shouldPromptGoalRenewal || shouldPromptGoalRenewalFallback) {
      goalRenewalPromptAfterGoalRef.current = false;
      goalRenewalPromptPendingRef.current = false;
      if (!goalRenewalPromptVisible) {
        setGoalRenewalPromptVisible(true);
      }
    }
  }, [goalRenewalPromptVisible, overlay, pendingGoalCelebration, processOverlayQueue]);

  const resetFocusLossCounter = useCallback((templateId) => {
    if (!templateId) return;
    focusLossCountersRef.current[templateId] = { count: 0 };
  }, []);

  const promptFocusForTemptation = useCallback(
    (template) => {
      if (!focusTargetsUnlocked) return;
      if (!template?.id) return;
      if (!isFocusCandidateInFeed(template.id)) return;
      if (typeof resolveTemptationCategory === "function") {
        const categoryId = resolveTemptationCategory(template);
        if (isEssentialImpulseCategory(categoryId)) return;
      }
      if (focusPromptActiveRef.current) return;
      if (overlay?.type === "focus_digest") return;
      focusPromptActiveRef.current = true;
      const title = resolveTemptationTitle(template, language, titleOverrides[template.id]) || t("defaultDealTitle");
      triggerOverlayState("focus_digest", {
        title: t("focusPromptTitle"),
        body: t("focusPromptBody", { title }),
        strong: null,
        weak: { title, templateId: template.id },
        positive: false,
        targetId: template.id,
        prompt: true,
      }, null);
    },
    [
      focusTargetsUnlocked,
      isFocusCandidateInFeed,
      language,
      overlay,
      resolveTemptationCategory,
      t,
      titleOverrides,
      triggerOverlayState,
    ]
  );

  const registerFocusLoss = useCallback(
    (template) => {
      if (!focusTargetsUnlocked) return;
      if (!template?.id) return;
      if (typeof resolveTemptationCategory === "function") {
        const categoryId = resolveTemptationCategory(template);
        if (isEssentialImpulseCategory(categoryId)) return;
      }
      const key = template.id;
      const entry = focusLossCountersRef.current[key] || { count: 0 };
      const nextCount = entry.count + 1;
      focusLossCountersRef.current[key] = { count: nextCount };
      if (nextCount >= FOCUS_LOSS_THRESHOLD) {
        focusLossCountersRef.current[key] = { count: 0 };
        if (focusTemplateId === key) return;
        promptFocusForTemptation(template);
      }
    },
    [focusTargetsUnlocked, focusTemplateId, promptFocusForTemptation, resolveTemptationCategory]
  );

  const celebrateFocusVictory = useCallback(
    (template) => {
      if (!focusTargetsUnlocked) return;
      if (!template) return;
      const title = resolveTemptationTitle(template, language, titleOverrides[template.id]) || t("defaultDealTitle");
      setFocusTemplateId(null);
      setFocusSaveCount(0);
      setFocusVictoryCount((prev) => Math.max(0, Number(prev) || 0) + 1);
      resetFocusLossCounter(template.id);
      setHealthPoints((prev) => prev + FOCUS_VICTORY_REWARD);
      if (queueCelebrationOverlayRef.current) {
        queueCelebrationOverlayRef.current("focus_reward", {
          title: t("focusRewardTitle"),
          body: t("focusRewardSubtitle", { title, amount: FOCUS_VICTORY_REWARD }),
          amount: FOCUS_VICTORY_REWARD,
        });
      }
    },
    [focusTargetsUnlocked, language, resetFocusLossCounter, setHealthPoints, t, titleOverrides]
  );

  const handleFocusSaveProgress = useCallback(
    (template) => {
      if (!focusTargetsUnlocked) return;
      if (!template?.id || template.id !== focusTemplateId) return;
      resetFocusLossCounter(template.id);
      setFocusSaveCount((prev) => {
        const next = prev + 1;
        if (next >= FOCUS_VICTORY_THRESHOLD) {
          celebrateFocusVictory(template);
          return 0;
        }
        return next;
      });
    },
    [celebrateFocusVictory, focusTargetsUnlocked, focusTemplateId, resetFocusLossCounter]
  );

  const handleFocusSpend = useCallback(
    (template) => {
      if (!focusTargetsUnlocked) return;
      if (!template?.id || template.id !== focusTemplateId) return;
      setFocusSaveCount(0);
    },
    [focusTargetsUnlocked, focusTemplateId]
  );

  const applyFocusTarget = useCallback(
    (templateId, source = "manual") => {
      if (!focusTargetsUnlocked) return;
      if (!templateId) return;
      if (!isFocusCandidateInFeed(templateId)) return;
      if (typeof resolveTemplateCard === "function" && typeof resolveTemptationCategory === "function") {
        const template = resolveTemplateCard(templateId);
        const categoryId = template ? resolveTemptationCategory(template) : null;
        if (isEssentialImpulseCategory(categoryId)) return;
      }
      setFocusTemplateId(templateId);
      setFocusSaveCount(0);
      resetFocusLossCounter(templateId);
      logEvent("focus_target_set", { template_id: templateId, source });
      logEvent("focus_accepted", { template_id: templateId, source });
      triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
      playSound("focus_accept");
      queueHomeSpeech("focus_set");
    },
    [
      focusTargetsUnlocked,
      isFocusCandidateInFeed,
      logEvent,
      playSound,
      queueHomeSpeech,
      resetFocusLossCounter,
      resolveTemptationCategory,
      resolveTemplateCard,
    ]
  );

  const requestFocusCancel = useCallback(
    (template) => {
      if (!template?.id) return;
      if (template.id !== focusTemplateId) return;
      Alert.alert(t("focusCancelConfirmTitle"), "", [
        { text: t("quickCustomCancel"), style: "cancel" },
        {
          text: t("focusCancelConfirmAction"),
          style: "destructive",
          onPress: () => {
            setFocusTemplateId(null);
            setFocusSaveCount(0);
            resetFocusLossCounter(template.id);
          },
        },
      ]);
    },
    [focusTemplateId, resetFocusLossCounter, setFocusTemplateId, setFocusSaveCount, t]
  );

  const resolveFocusDigest = useCallback(
    (action = "later") => {
      if (!focusModeUnlocked) return;
      if (!pendingFocusDigest) return;
      const targetDateKey = pendingFocusDigest.dateKey;
      setFocusDigestSeenKey(targetDateKey);
      setPendingFocusDigest(null);
      setFocusDigestPromptShown(false);
      clearQueuedModal(QUEUED_MODAL_TYPES.FOCUS_DIGEST);
      AsyncStorage.removeItem(STORAGE_KEYS.FOCUS_DIGEST_PENDING).catch(() => {});
      if (action === "later") {
        logEvent("focus_digest_later", { date_key: targetDateKey });
      } else if (action === "focus") {
        logEvent("focus_digest_focus", { date_key: targetDateKey });
      }
    },
    [clearQueuedModal, focusModeUnlocked, pendingFocusDigest, logEvent]
  );

  const handleFocusOverlayConfirm = useCallback(
    (templateId, source = "digest") => {
      const isPrompt = overlay?.message?.prompt;
      if (templateId) {
        applyFocusTarget(templateId, source);
      }
      resolveFocusDigest("focus");
      dismissOverlay();
      if (isPrompt) {
        focusPromptActiveRef.current = false;
      }
    },
    [applyFocusTarget, dismissOverlay, overlay, resolveFocusDigest]
  );

  const handleFocusOverlayLater = useCallback(() => {
    const isPrompt = overlay?.message?.prompt;
    resolveFocusDigest("later");
    dismissOverlay();
    if (isPrompt) {
      focusPromptActiveRef.current = false;
    }
  }, [dismissOverlay, overlay, resolveFocusDigest]);

  const notifyImpulseRisk = useCallback(
    async (risk) => {
      if (!impulseFeaturesUnlocked) return;
      if (!risk?.templateId) return;
      if (typeof resolveTemplateCard === "function" && typeof resolveTemptationCategory === "function") {
        const template = resolveTemplateCard(risk.templateId);
        const categoryId = template ? resolveTemptationCategory(template) : null;
        if (isEssentialImpulseCategory(categoryId)) return;
      }
      const now = Date.now();
      const lastShown = impulseAlertCooldownRef.current?.[risk.templateId] || 0;
      if (now - lastShown < IMPULSE_ALERT_COOLDOWN_MS) return;
      const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
      const amountLabel = formatCurrency(
        convertToCurrency(Math.max(risk.amountUSD || 0, 0), currencyCode),
        currencyCode
      );
      const baseOverlayMessage = t("impulseAlertMessage", {
        temptation: risk.title,
        window: risk.windowLabel || "",
        amount: amountLabel,
      });
      const overlayMessage = moodPreset?.impulseOverlay
        ? `${baseOverlayMessage}\n${moodPreset.impulseOverlay}`
        : baseOverlayMessage;
      const pushTitle =
        moodPreset?.pushImpulseTitle && moodPreset.pushImpulseTitle.trim()
          ? renderTemplateString(moodPreset.pushImpulseTitle, { temptation: risk.title })
          : t("impulseNotificationTitle", { temptation: risk.title });
      const pushBody =
        moodPreset?.pushImpulseBody && moodPreset.pushImpulseBody.trim()
          ? renderTemplateString(moodPreset.pushImpulseBody, {
              temptation: risk.title,
              amount: amountLabel,
            })
          : t("impulseNotificationBody", { temptation: risk.title, amount: amountLabel });
      triggerOverlayState("impulse_alert", {
        title: t("impulseAlertTitle"),
        body: overlayMessage,
        moodLine: moodPreset?.impulseOverlay || null,
        window: risk.windowLabel || null,
        amountLabel,
        temptation: risk.title || "",
      });
      await sendImmediateNotification({
        title: pushTitle,
        body: pushBody,
      });
      impulseAlertCooldownRef.current = {
        ...(impulseAlertCooldownRef.current || {}),
        [risk.templateId]: now,
      };
      setImpulseTracker((prev) => ({
        ...(prev || INITIAL_IMPULSE_TRACKER),
        lastAlerts: {
          ...(prev?.lastAlerts || {}),
          [risk.templateId]: now,
        },
        events: prev?.events || [],
      }));
    },
    [
      impulseFeaturesUnlocked,
      moodPreset,
      profile.currency,
      resolveTemptationCategory,
      resolveTemplateCard,
      sendImmediateNotification,
      t,
      triggerOverlayState,
    ]
  );

  const triggerCelebration = () => {
    const messages = getCelebrationMessages(language, activeGender);
    if (!messages.length) return;
    triggerOverlayState("purchase", messages[Math.floor(Math.random() * messages.length)]);
  };

  const handleStreakPledgeConfirm = useCallback(
    (option, payloadOverride) => {
      if (!option) return;
      const targetDays = Math.max(0, Number(option.days) || 0);
      if (!targetDays) return;
      const payload =
        payloadOverride && typeof payloadOverride === "object"
          ? payloadOverride
          : overlay?.message && typeof overlay.message === "object"
          ? overlay.message
          : {};
      const streakCount = Math.max(
        1,
        Number(payload?.streakCount) || Number(usageStreakRef.current?.current) || 1
      );
      const startDayKey =
        typeof payload?.dayKey === "string" ? payload.dayKey : getDayKey(Date.now());
      const computed = computeStreakPledgeReward(targetDays);
      const rewardBlueCoins = computed.blueCoins;
      const rewardValue = computed.rewardValue;
      setStreakPledge((prev) => ({
        ...prev,
        status: STREAK_PLEDGE_STATUS.ACTIVE,
        targetDays,
        startCount: streakCount,
        startDayKey,
        rewardBlueCoins,
        rewardValue,
        rewardPending: false,
        rewardDeliveredAt: 0,
        introSeen: true,
        lastPromptDayKey: getDayKey(Date.now()),
      }));
      logEvent("streak_goal_selected", {
        target_days: targetDays,
        start_count: streakCount,
        reward_blue: rewardBlueCoins,
        reward_value: rewardValue,
      });
      triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
      dismissOverlay();
    },
    [dismissOverlay, logEvent, overlay?.message, setStreakPledge]
  );

  const handleStreakPledgeDismiss = useCallback(() => {
    const todayKey = getDayKey(Date.now());
    setStreakPledge((prev) => ({
      ...prev,
      introSeen: true,
      lastPromptDayKey: todayKey,
    }));
    logEvent("streak_goal_prompt_dismissed", { day_key: todayKey });
    dismissOverlay();
  }, [dismissOverlay, logEvent, setStreakPledge]);

  const handleUsageStreakPress = useCallback(
    (payload) => {
      if (!payload || typeof payload !== "object") return;
      ensureOverlayEnvironmentReady();
      triggerOverlayState("usage_streak", payload);
      queueStreakPledgeFollowUps(payload);
    },
    [ensureOverlayEnvironmentReady, queueStreakPledgeFollowUps, triggerOverlayState]
  );

  const handleUsageStreakRestore = useCallback(
    (restoreData) => {
      if (!restoreData || typeof restoreData !== "object") return;
      const lostCount = Math.max(0, Number(restoreData.lostCount) || 0);
      const todayKey = getDayKey(Date.now());
      const computedMissed = getMissedUsageStreakDays(restoreData.streakEndDayKey, todayKey);
      const missedDays = Math.max(
        0,
        Math.floor(Number(restoreData.missedDays) || computedMissed || 0)
      );
      if (!lostCount || !missedDays) return;
      const costBlueCount = missedDays * STREAK_RESTORE_BLUE_COINS_PER_DAY;
      const costValue = missedDays * STREAK_RESTORE_COST_PER_DAY;
      if (healthPoints < costValue) return;
      const yesterdayKey = getDayKey(Date.now() - DAY_MS);
      const hasLoggedToday = !!restoreData.hasLoggedToday;
      const nextCurrent = lostCount + missedDays + (hasLoggedToday ? 1 : 0);
      const nextLastDate = hasLoggedToday ? todayKey : yesterdayKey;
      setHealthPoints((prev) => Math.max(0, prev - costValue));
      setUsageStreak((prev) => ({
        ...prev,
        current: nextCurrent,
        best: Math.max(prev?.best || 0, nextCurrent),
        total: Math.max(0, Number(prev?.total) || 0) + missedDays,
        lastDate: nextLastDate,
        lostCount: 0,
      }));
      triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
      playSound?.("coin");
      dismissOverlay();
      logEvent("usage_streak_restored", {
        missed_days: missedDays,
        cost_blue: costBlueCount,
        cost_value: costValue,
        current_streak: nextCurrent,
      });
    },
    [dismissOverlay, healthPoints, logEvent, playSound]
  );

  const handleLevelCelebrate = useCallback(
    (level, levelsEarned = 1) => {
      ensureOverlayEnvironmentReady();
      const rewardCoins = sumLevelRewardCoins(level, levelsEarned);
      const startLevel = Math.max(2, level - levelsEarned + 1);
      const unlockPayloads = FEATURE_UNLOCK_STEPS.filter(
        ({ level: unlockLevel }) => unlockLevel >= startLevel && unlockLevel <= level
      )
        .map(({ messageKey }) => {
          const body = t(messageKey);
          const variantKey = FEATURE_UNLOCK_VARIANT_MAP[messageKey];
          if (variantKey && FEATURE_UNLOCK_VARIANT_CONFIG[variantKey]) {
            return {
              featureUnlock: true,
              messageKey,
              variant: variantKey,
              body,
            };
          }
          return body;
        })
        .filter(Boolean);
      const queueUnlockAnnouncements = () => {
        unlockPayloads.forEach((payload) => {
          const isFeatureUnlock = payload && typeof payload === "object" && payload.featureUnlock;
          triggerOverlayState("cart", payload, isFeatureUnlock ? { duration: 0 } : { duration: 4800 });
        });
      };
      triggerOverlayState("level", level, { force: true });
      if (rewardCoins > 0) {
        const rewardAmount = rewardCoins * HEALTH_COIN_TIERS[1].value;
        setHealthPoints((prev) => prev + rewardAmount);
        triggerOverlayState(
          "health",
          {
            amount: rewardAmount,
            displayCoins: rewardCoins,
            coinValue: rewardAmount,
            reason: t("healthCelebrateLevel"),
          },
          3200
        );
      }
      queueUnlockAnnouncements();
      triggerSuccessHaptic();
    },
    [ensureOverlayEnvironmentReady, playSound, t, triggerOverlayState]
  );
  const runPendingLevelCelebration = useCallback(() => {
    const pending = pendingLevelCelebrationRef.current;
    if (!pending) return;
    if (!overlayEnvironmentReady) return;
    if (blockingModalVisible) return;
    levelCelebrationQueuedRef.current = Math.max(
      levelCelebrationQueuedRef.current || 0,
      pending.level || 0
    );
    pendingLevelCelebrationRef.current = null;
    handleLevelCelebrate(pending.level, pending.levelsEarned);
  }, [blockingModalVisible, handleLevelCelebrate, overlayEnvironmentReady]);

  useEffect(() => {
    runPendingLevelCelebration();
  }, [blockingModalVisible, overlay, overlayEnvironmentReady, runPendingLevelCelebration]);

  const logLevelReachedRange = useCallback(
    (fromLevel, toLevel) => {
      if (analyticsOptOut !== false) return;
      const start = Math.max(1, Math.floor(Number(fromLevel) || 1));
      const end = Math.max(start, Math.floor(Number(toLevel) || start));
      for (let level = start; level <= end; level += 1) {
        logEvent("level_reached", { level });
        logEvent(`level_reached_${level}`, { level });
      }
      levelReachedLoggedRef.current = end;
      AsyncStorage.setItem(STORAGE_KEYS.LEVEL_REACHED_LOGGED, String(end)).catch(() => {});
    },
    [analyticsOptOut, logEvent]
  );

  useEffect(() => {
    if (!levelReachedLoggedHydrated) return;
    if (
      !progressSavedTotalHydrated ||
      !progressLifetimeSavedHydrated ||
      !levelProgressOffsetHydrated
    )
      return;
    if (analyticsOptOut !== false) return;
    const currentLevel = Math.max(1, Number(playerLevel) || 1);
    const lastLoggedLevel = Math.max(0, Number(levelReachedLoggedRef.current) || 0);
    if (currentLevel <= lastLoggedLevel) return;
    logLevelReachedRange(lastLoggedLevel + 1, currentLevel);
  }, [
    analyticsOptOut,
    levelReachedLoggedHydrated,
    levelProgressOffsetHydrated,
    progressLifetimeSavedHydrated,
    logLevelReachedRange,
    playerLevel,
    progressSavedTotalHydrated,
  ]);

  useEffect(() => {
    if (!lastCelebratedLevelHydrated) return;
    if (resetInProgressRef.current) {
      if (playerLevel <= 1 && progressSavedTotalUSD === 0 && progressLifetimeSavedUSD === 0) {
        resetInProgressRef.current = false;
        previousPlayerLevelRef.current = Math.max(playerLevel, 1);
      }
      return;
    }
    const previousLevel = Math.max(
      previousPlayerLevelRef.current || 1,
      lastCelebratedLevel || 1
    );
    if (playerLevel <= (levelCelebrationQueuedRef.current || 0)) {
      previousPlayerLevelRef.current = Math.max(playerLevel, previousLevel);
      return;
    }
    if (playerLevel > previousLevel) {
      const levelsEarned = playerLevel - previousLevel;
      if (overlay?.type === "save") {
        dismissOverlay({ clearQueue: false });
        queueUsageStreakOverlay("save");
      }
      logEvent("savings_level_up", {
        level: playerLevel,
        saved_usd_total: progressSavedTotalUSD,
      });
      logEvent("hero_level_unlocked", {
        level: playerLevel,
        saved_usd_total: progressSavedTotalUSD,
      });
      queueHomeSpeech("level_up");
      pendingLevelCelebrationRef.current = { level: playerLevel, levelsEarned };
      runPendingLevelCelebration();
      persistLastCelebratedLevel(playerLevel);
    }
    previousPlayerLevelRef.current = Math.max(playerLevel, previousLevel);
  }, [
    handleLevelCelebrate,
    lastCelebratedLevel,
    lastCelebratedLevelHydrated,
    progressLifetimeSavedUSD,
    persistLastCelebratedLevel,
    playerLevel,
    queueHomeSpeech,
    queueUsageStreakOverlay,
    runPendingLevelCelebration,
    progressSavedTotalUSD,
  ]);

  useEffect(() => {
    if (!pendingGoalCelebration) return;
    if (blockingModalVisible) return;
    if (overlay || overlayActiveRef.current) return;
    if (overlayQueueRef.current.length) return;
    if (celebrationQueueRef.current.length) return;
    if (pendingLevelCelebrationRef.current) return;
    triggerOverlayState(
      "goal_complete",
      pendingGoalCelebration.payload,
      pendingGoalCelebration.config
    );
    setPendingGoalCelebration(null);
  }, [blockingModalVisible, overlay, pendingGoalCelebration, triggerOverlayState]);

  const handleRewardClaim = useCallback(
    (reward) => {
      if (!reward?.id || !reward.unlocked || reward.claimed) return;
      const rewardAmount = reward.rewardHealth || HEALTH_PER_REWARD;
      const claimedAt = Date.now();
      setClaimedRewards((prev) => ({ ...prev, [reward.id]: { claimedAt } }));
      setRewardClaimTotal((prev) => Math.max(0, prev) + 1);
      setHealthPoints((prev) => prev + rewardAmount);
      triggerOverlayState(
        "health",
        {
          amount: rewardAmount,
          reason: t("healthCelebrateReward"),
        },
        3200
      );
      playSound("reward");
      triggerSuccessHaptic();
      logEvent("reward_claimed", { reward_id: reward.id });
      logHistoryEvent("reward_claimed", { rewardId: reward.id, title: reward.title });
    },
    [t, triggerOverlayState, logHistoryEvent, playSound]
  );

  const handleChallengeAccept = useCallback(
    async (challengeId) => {
      const def = CHALLENGE_DEF_MAP[challengeId];
      if (!def) return;
      if (getActiveChallengesCount(challengesState) >= MAX_ACTIVE_CHALLENGES) {
        Alert.alert(
          t("challengeLimitReachedTitle", { limit: MAX_ACTIVE_CHALLENGES }),
          t("challengeLimitReachedMessage", { limit: MAX_ACTIVE_CHALLENGES })
        );
        return;
      }
      triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
      let activated = false;
      let startedAt = Date.now();
      let expiresAt = startedAt + def.durationDays * DAY_MS;
      let limitReached = false;
      setChallengesState((prev) => {
        const entry = prev[challengeId] || createChallengeEntry(challengeId);
        const cooldownRemaining = getChallengeCooldownRemaining(entry, Date.now());
        const canStart =
          entry.status === CHALLENGE_STATUS.IDLE ||
          (entry.status === CHALLENGE_STATUS.EXPIRED && cooldownRemaining <= 0) ||
          (entry.status === CHALLENGE_STATUS.CLAIMED && cooldownRemaining <= 0);
        if (!canStart) {
          return prev;
        }
        const activeCount = getActiveChallengesCount(prev);
        if (activeCount >= MAX_ACTIVE_CHALLENGES) {
          limitReached = true;
          return prev;
        }
        activated = true;
        startedAt = Date.now();
        expiresAt = startedAt + def.durationDays * DAY_MS;
        return {
          ...prev,
          [challengeId]: {
            ...createChallengeEntry(challengeId),
            status: CHALLENGE_STATUS.ACTIVE,
            startedAt,
            expiresAt,
          },
        };
      });
      if (limitReached) {
        Alert.alert(
          t("challengeLimitReachedTitle", { limit: MAX_ACTIVE_CHALLENGES }),
          t("challengeLimitReachedMessage", { limit: MAX_ACTIVE_CHALLENGES })
        );
        return;
      }
      if (!activated) return;
      playSound("challenge_accept");
      const copy = getChallengeCopy(def, language);
      const title = copy.title || challengeId;
      triggerOverlayState("cart", t("challengeStartedOverlay", { title }));
      logEvent("challenge_started", { challenge_id: challengeId });
      logEvent("challenge_joined", {
        challenge_id: challengeId,
        type: CHALLENGE_TYPE_LABELS[def.metricType] || def.metricType,
      });
      const reminderIds = await scheduleChallengeReminders(challengeId, def, startedAt, expiresAt);
      if (reminderIds.length) {
        setChallengesState((prev) => {
          const entry = prev[challengeId];
          if (!entry || entry.startedAt !== startedAt) return prev;
          return {
            ...prev,
            [challengeId]: {
              ...entry,
              reminderNotificationIds: reminderIds,
            },
          };
        });
      }
    },
    [challengesState, language, playSound, scheduleChallengeReminders, t, triggerOverlayState]
  );

  const handleChallengeClaim = useCallback(
    (challengeId) => {
      if (
        !premiumState.isPremium &&
        premiumChallengeClaims >= FREE_CHALLENGE_CLAIMS_LIMIT
      ) {
        ensurePremiumFeatureAccess(PREMIUM_FEATURE_KEYS.unlimitedChallenges);
        return;
      }
      const def = CHALLENGE_DEF_MAP[challengeId];
      if (!def) return;
      const currentEntry = challengesState[challengeId];
      if (!currentEntry || currentEntry.status !== CHALLENGE_STATUS.COMPLETED) return;
      (currentEntry.reminderNotificationIds || []).forEach((id) => {
        safeNotifications.cancelScheduledNotificationAsync(id);
      });
      triggerSuccessHaptic();
      setChallengesState((prev) => {
        const entry = prev[challengeId];
        if (!entry || entry.status !== CHALLENGE_STATUS.COMPLETED) return prev;
        return {
          ...prev,
          [challengeId]: {
            ...entry,
            status: CHALLENGE_STATUS.CLAIMED,
            claimedAt: Date.now(),
            reminderNotificationIds: [],
          },
        };
      });
      const rewardAmount = getScaledChallengeReward(def.rewardHealth);
      const rewardLabel = formatHealthRewardText(rewardAmount);
      setHealthPoints((prev) => prev + rewardAmount);
      const copy = getChallengeCopy(def, language);
      const title = copy.title || challengeId;
      triggerOverlayState(
        "health",
        {
          amount: rewardAmount,
          reason: t("challengeClaimedOverlay", { title, amount: rewardLabel }),
        },
        3200
      );
      playSound("reward");
      logEvent("challenge_claimed", { challenge_id: challengeId });
      setPremiumChallengeClaims((prev) => Math.max(0, Number(prev) || 0) + 1);
    },
    [
      challengesState,
      ensurePremiumFeatureAccess,
      formatHealthRewardText,
      language,
      playSound,
      premiumChallengeClaims,
      premiumState.isPremium,
      t,
      triggerOverlayState,
    ]
  );

  const handleChallengeCancel = useCallback(
    (challengeId) => {
      setChallengesState((prev) => {
        const entry = prev[challengeId];
        if (!entry || entry.status !== CHALLENGE_STATUS.ACTIVE) return prev;
        (entry.reminderNotificationIds || []).forEach((id) => {
          safeNotifications.cancelScheduledNotificationAsync(id);
        });
        logEvent("challenge_cancelled", { challenge_id: challengeId });
        return {
          ...prev,
          [challengeId]: createChallengeEntry(challengeId),
        };
      });
    },
    [logEvent]
  );

  const handleFreeDayRescue = useCallback(() => {
    if (!freeDayUnlocked) return;
    const now = new Date();
    if (!freeDayStats.lastDate || healthPoints < FREE_DAY_RESCUE_COST) return;
    const yesterdayKey = getDayKey(new Date(now.getTime() - DAY_MS));
    const dayBeforeYesterdayKey = getDayKey(new Date(now.getTime() - DAY_MS * 2));
    if (freeDayStats.lastDate !== dayBeforeYesterdayKey) return;
    setHealthPoints((prev) => Math.max(prev - FREE_DAY_RESCUE_COST, 0));
    setFreeDayStats((prev) => ({ ...prev, lastDate: yesterdayKey }));
    triggerOverlayState("reward", t("freeDayRescueOverlay"));
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    logEvent("free_day_rescue", {
      current_streak: freeDayStats.current,
      health_remaining: Math.max(healthPoints - FREE_DAY_RESCUE_COST, 0),
    });
  }, [freeDayUnlocked, freeDayStats.lastDate, freeDayStats.current, healthPoints, triggerOverlayState, t]);

  const handleResetData = () => {
    Alert.alert(
      t("developerReset"),
      t("developerResetConfirm"),
      [
        { text: t("developerResetCancel"), style: "cancel" },
        {
          text: t("developerResetApply"),
          style: "destructive",
          onPress: async () => {
            resetCounterRef.current += 1;
            resetInProgressRef.current = true;
            triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
            try {
              await AsyncStorage.multiRemove(Object.values(STORAGE_KEYS));
              await AsyncStorage.clear();
            } catch (error) {
              console.warn("reset", error);
            }
            AsyncStorage.setItem(STORAGE_KEYS.TEMPTATION_TUTORIAL, "pending").catch(() => {});
            safeNotifications.cancelAllScheduledNotificationsAsync();
            try {
              await Promise.all(
                pendingList
                  .filter((entry) => entry.notificationId)
                  .map((entry) =>
                    safeNotifications.cancelScheduledNotificationAsync(entry.notificationId)
                  )
              );
            } catch {}
            try {
              const challengeReminderIds = Object.values(challengesState || {}).flatMap(
                (entry) => entry?.reminderNotificationIds || []
              );
              await Promise.all(
                challengeReminderIds.map((id) =>
                  safeNotifications.cancelScheduledNotificationAsync(id)
                )
              );
            } catch {}
            try {
              const hungerIds = Array.isArray(tamagotchiHungerNotificationIdsRef.current)
                ? tamagotchiHungerNotificationIdsRef.current
                : [];
              if (hungerIds.length) {
                await Promise.all(
                  hungerIds.map((id) =>
                    safeNotifications.cancelScheduledNotificationAsync(id)
                  )
                );
              }
              tamagotchiHungerNotificationIdsRef.current = [];
            } catch {}
            setWishes([]);
            setPendingList([]);
            setPurchases([]);
            setSavedTotalUSD(0);
            setLifetimeSavedUSD(0);
            setProgressSavedTotalUSD(0);
            setProgressLifetimeSavedUSD(0);
            setLevelProgressOffsetUSD(0);
            tutorialLevelOffsetAppliedRef.current = false;
            setDeclineCount(0);
            setCatalogOverrides({});
            setTitleOverrides({});
            setEmojiOverrides({});
            setQuickTemptations([]);
            setFreeDayStats({ ...INITIAL_FREE_DAY_STATS });
            setUsageStreak({ ...INITIAL_USAGE_STREAK });
            setUsageStreakHydrated(true);
            usageStreakBackfillRef.current = false;
            setStreakPledge({ ...INITIAL_STREAK_PLEDGE });
            setStreakPledgeHydrated(true);
            setDecisionStats({ ...INITIAL_DECISION_STATS });
            setHistoryEvents([]);
            setIncomeEntries([]);
            setBudgetOverrides({});
            setBudgetOverspendMap({});
            setIncomePromptState({ lastPromptMonthKey: null, lastPromptAt: 0 });
            setIncomeEntryModalVisible(false);
            setIncomeEntryInput({ amount: "", note: "" });
            setRefuseStats({});
            setTemptationInteractions({});
            setSmartReminders([]);
            setSmartRemindersHydrated(true);
            setPotentialPushProgress({ ...DEFAULT_POTENTIAL_PUSH_STATE });
            setPotentialPushHydrated(true);
            const resetProfile = {
              ...DEFAULT_PROFILE,
              joinedAt: new Date().toISOString(),
              goal: null,
              goalTargetUSD: 0,
              primaryGoals: [],
              goalCelebrated: false,
              goalRenewalPending: false,
            };
            setProfile(resetProfile);
            setProfileDraft(resetProfile);
            setActiveGoalId(null);
            setRegistrationData(INITIAL_REGISTRATION);
            setDailyRewardState({ ...DEFAULT_DAILY_REWARD_STATE });
            setDailyRewardHydrated(true);
            setDailyChallenge(createInitialDailyChallengeState());
            setDailyChallengeHydrated(true);
            setDailySummaryData(null);
            setDailySummaryVisible(false);
            setPendingDailySummaryData(null);
            setDailySummarySeenKey(null);
            setDailyNudgeNotificationIds({});
            dailyNudgeIdsRef.current = {};
            setDailyNudgesHydrated(true);
            pushOptInLoggedRef.current = false;
            pushDayThreePromptShownRef.current = false;
            lastSpendLoggingReminderRef.current = 0;
            goalSelectionTouchedRef.current = false;
            goToOnboardingStep("logo", { recordHistory: false, resetHistory: true });
            setActiveCategory("all");
            setActiveTabState("feed");
            updateTabHistory([]);
            goToTab("feed", { recordHistory: false, resetHistory: true });
            setOverlay(null);
            setTheme(DEFAULT_THEME);
            setLanguage(DEFAULT_LANGUAGE);
            setSoundEnabled(true);
            setSoundEnabledHydrated(true);
            setActiveCurrency(DEFAULT_PROFILE.currency);
            setHealthPoints(0);
            const resetTamagotchiState = {
              ...TAMAGOTCHI_START_STATE,
              coins: 0,
              lastFedAt: null,
              lastDecayAt: Date.now(),
              coinTick: 0,
            };
            setTamagotchiState(resetTamagotchiState);
            tamagotchiHungerPrevRef.current = TAMAGOTCHI_START_STATE.hunger;
            tamagotchiHydratedRef.current = true;
            setTamagotchiGreetingDayKey(null);
            setTamagotchiGreetingDayHydrated(true);
            setTamagotchiSkinId(DEFAULT_TAMAGOTCHI_SKIN);
            setSkinPickerVisible(false);
            setClaimedRewards({});
            setRewardClaimTotal(0);
            setRewardCelebratedMap({});
            const resetChallenges = createInitialChallengesState();
            challengesPrevRef.current = resetChallenges;
            setChallengesState(resetChallenges);
            setChallengeBadgeStore([]);
            setChallengeBadgeStoreHydrated(true);
            setImpulseTracker({ ...INITIAL_IMPULSE_TRACKER });
            setMoodState(createMoodStateForToday());
            impulseAlertCooldownRef.current = {};
            setTutorialSeen(false);
            setTutorialVisible(false);
            setTutorialStepIndex(0);
            setTemptationTutorialSeen(false);
            setTemptationTutorialStatus("pending");
            setTemptationTutorialVisible(false);
            setTemptationTutorialStepIndex(0);
            setTemptationTutorialQueued(false);
            setTemptationTutorialCompleted(false);
            setLastCelebratedLevel(1);
            setLastCelebratedLevelHydrated(true);
            setCoinValueModalVisible(false);
            setCoinValueModalStatus("none");
            coinValueModalStatusRef.current = "none";
            coinBalancePrevRef.current = 0;
            setCoinSliderMaxUSD(DEFAULT_COIN_SLIDER_MAX_USD);
            previousPlayerLevelRef.current = 1;
            levelCelebrationQueuedRef.current = 0;
            pendingLevelCelebrationRef.current = null;
            overlayQueueRef.current = [];
            overlayActiveRef.current = false;
            if (overlayRetryTimerRef.current) {
              clearTimeout(overlayRetryTimerRef.current);
              overlayRetryTimerRef.current = null;
            }
            if (overlayTimer.current) {
              clearTimeout(overlayTimer.current);
              overlayTimer.current = null;
            }
            if (customReminderId) {
              safeNotifications.cancelScheduledNotificationAsync(customReminderId);
            }
            persistCustomReminderId(null);
            try {
              await AsyncStorage.multiSet([
                [STORAGE_KEYS.HEALTH, "0"],
                [STORAGE_KEYS.TAMAGOTCHI, JSON.stringify(resetTamagotchiState)],
                [STORAGE_KEYS.COIN_SLIDER_MAX, String(DEFAULT_COIN_SLIDER_MAX_USD)],
              ]);
            } catch (error) {
              console.warn("reset storage", error);
            }
          },
        },
      ]
    );
  };

  const startProfileEdit = (mode = "identity") => {
    if (profileEditMode !== "none") return;
    triggerHaptic();
    const nextDraft = { ...profile };
    if (mode === "identity") {
      const hasFirstName =
        typeof nextDraft.firstName === "string" && nextDraft.firstName.trim().length > 0;
      const hasLastName =
        typeof nextDraft.lastName === "string" && nextDraft.lastName.trim().length > 0;
      if (!hasFirstName && !hasLastName) {
        const nameParts = (nextDraft.name || "").trim().split(/\s+/).filter(Boolean);
        if (nameParts.length) {
          nextDraft.firstName = nameParts[0];
          nextDraft.lastName = nameParts.slice(1).join(" ");
        }
      }
    }
    setProfileDraft(nextDraft);
    setProfileEditMode(mode);
  };

  const cancelProfileEdit = () => {
    triggerHaptic();
    setProfileDraft(profile);
    setProfileEditMode("none");
  };

  const saveProfileEdit = () => {
    triggerHaptic();
    const normalizedGoals = Array.isArray(profileDraft.primaryGoals) && profileDraft.primaryGoals.length
      ? profileDraft.primaryGoals
          .map((entry) => {
            const goalId = entry?.id || profileDraft.goal || profile.goal || null;
            if (!goalId) return null;
            const targetUSD =
              Number.isFinite(entry?.targetUSD) && entry.targetUSD > 0
                ? entry.targetUSD
                : getGoalDefaultTargetUSD(goalId);
            const normalized = {
              id: goalId,
              targetUSD,
            };
            if (Number.isFinite(entry?.savedUSD)) {
              normalized.savedUSD = entry.savedUSD;
            }
            if (entry?.status) {
              normalized.status = entry.status;
            }
            if (entry?.createdAt) {
              normalized.createdAt = entry.createdAt;
            }
            if (entry?.customTitle) {
              normalized.customTitle = entry.customTitle;
            }
            if (entry?.customEmoji) {
              normalized.customEmoji = entry.customEmoji;
            }
            return normalized;
          })
          .filter(Boolean)
      : [];
    const fallbackGoalId = profileDraft.goal || profile.goal || null;
    const primaryGoalEntries =
      normalizedGoals.length > 0
        ? normalizedGoals
        : fallbackGoalId
        ? [
            {
              id: fallbackGoalId,
              targetUSD: getGoalDefaultTargetUSD(fallbackGoalId),
              savedUSD: 0,
              status: "active",
              createdAt: Date.now(),
            },
          ]
        : [];
    const activeEntry = primaryGoalEntries[0];
    const activeTarget =
      Number.isFinite(activeEntry?.targetUSD) && activeEntry.targetUSD > 0
        ? activeEntry.targetUSD
        : activeEntry?.id
        ? getGoalDefaultTargetUSD(activeEntry.id)
        : 0;
    const activeSaved = Number.isFinite(activeEntry?.savedUSD) ? Math.max(activeEntry.savedUSD, 0) : 0;
    const hasMetTarget = activeTarget > 0 && activeSaved >= activeTarget;
    const prevCustomId = profile.customSpend?.id || "custom_habit";
    const prevCustomTitle = (profile.customSpend?.title || "").trim();
    const nextCustomId = profileDraft.customSpend?.id || prevCustomId;
    const nextCustomTitle = (profileDraft.customSpend?.title || "").trim();
    const rawIncomePayday = Number(profileDraft.incomePayday);
    const normalizedIncomePayday =
      Number.isFinite(rawIncomePayday) && rawIncomePayday >= 1 && rawIncomePayday <= 31
        ? Math.round(rawIncomePayday)
        : DEFAULT_INCOME_PAYDAY;
    const trimmedFirstName = (profileDraft.firstName || "").trim();
    const trimmedLastName = (profileDraft.lastName || "").trim();
    const combinedName = `${trimmedFirstName} ${trimmedLastName}`.trim();
    const displayName =
      combinedName || (profileEditMode === "identity" ? "" : (profileDraft.name || "").trim());
    const nextProfile = {
      ...profileDraft,
      name: displayName,
      firstName: trimmedFirstName,
      lastName: trimmedLastName,
      incomePayday: normalizedIncomePayday,
      primaryGoals: primaryGoalEntries,
      goal: primaryGoalEntries[0]?.id || null,
      goalTargetUSD: activeTarget,
      goalCelebrated: hasMetTarget ? profileDraft.goalCelebrated : false,
    };
    if (nextCustomId && prevCustomTitle !== nextCustomTitle) {
      setTitleOverrides((prev) => {
        const next = { ...prev };
        if (nextCustomTitle) {
          next[nextCustomId] = nextCustomTitle;
        } else {
          delete next[nextCustomId];
        }
        return next;
      });
    }
    const prevBaselineUSD = profile.spendingProfile?.baselineMonthlyWasteUSD || 0;
    const nextBaselineUSD = nextProfile.spendingProfile?.baselineMonthlyWasteUSD || 0;
    if (prevBaselineUSD !== nextBaselineUSD) {
      logEvent("profile_baseline_updated", {
        previous_usd: prevBaselineUSD,
        baseline_usd: nextBaselineUSD,
        currency: nextProfile.currency || DEFAULT_PROFILE.currency,
      });
    }
    const prevCustomSpend = profile.customSpend || null;
    const nextCustomSpend = nextProfile.customSpend || null;
    const prevCustomAmountUSD = resolveCustomPriceUSD(
      prevCustomSpend,
      profile.currency || DEFAULT_PROFILE.currency
    );
    const nextCustomAmountUSD = resolveCustomPriceUSD(
      nextCustomSpend,
      nextProfile.currency || DEFAULT_PROFILE.currency
    );
    const prevCustomFrequency = prevCustomSpend?.frequencyPerWeek || 0;
    const nextCustomFrequency = nextCustomSpend?.frequencyPerWeek || 0;
    const customSpendChanged =
      prevCustomTitle !== nextCustomTitle ||
      prevCustomAmountUSD !== nextCustomAmountUSD ||
      prevCustomFrequency !== nextCustomFrequency;
    if (customSpendChanged) {
      logEvent("profile_custom_spend_updated", {
        title_hash: hashAnalyticsText(nextCustomTitle || ""),
        amount_usd: nextCustomAmountUSD || 0,
        frequency_per_week: nextCustomFrequency || 0,
        removed: nextCustomSpend ? 0 : 1,
      });
    }
    setProfile(nextProfile);
    setProfileEditMode("none");
    Keyboard.dismiss();
  };

  const isProfileEditing = profileEditMode !== "none";
  const handleProfileFieldChange = useCallback(
    (field, value) => setProfileDraft((prev) => ({ ...prev, [field]: value })),
    []
  );
  const handleProfileEditPress = useCallback(() => startProfileEdit("identity"), [startProfileEdit]);
  const handleProfileSpendEditPress = useCallback(
    () => startProfileEdit("spend"),
    [startProfileEdit]
  );
  const handleProgressCreateGoal = useCallback(
    () => openNewGoalModal(false, "progress_goal_add"),
    [openNewGoalModal]
  );
  const handleProgressFocusHandled = useCallback(
    () => setProgressFocusChallengeId(null),
    []
  );
  const handleBudgetAutoLocked = useCallback(() => {
    if (budgetAutoEnabled) return;
    ensurePremiumFeatureAccess(PREMIUM_FEATURE_KEYS.budgetAuto);
  }, [budgetAutoEnabled, ensurePremiumFeatureAccess]);
  const handleImpulseMapLockedPress = useCallback(() => {
    ensurePremiumFeatureAccess(PREMIUM_FEATURE_KEYS.impulseMap);
  }, [ensurePremiumFeatureAccess]);
  const handlePendingPremiumShelvesPress = useCallback(() => {
    ensurePremiumFeatureAccess(PREMIUM_FEATURE_KEYS.thinkingQueue);
  }, [ensurePremiumFeatureAccess]);
  const handleHeroCarouselPremiumAttempt = useCallback(() => {
    if (premiumState.isPremium) return;
    ensurePremiumFeatureAccess(PREMIUM_FEATURE_KEYS.widgetSlider);
    setHeroCarouselIndex(0);
    setHeroCarouselLocked(true);
  }, [ensurePremiumFeatureAccess, premiumState.isPremium]);
  const handleHeroCarouselIndexChange = useCallback(
    (nextIndex) => {
      const normalized = Math.max(0, Number(nextIndex) || 0);
      if (!premiumState.isPremium && normalized > 0) {
        ensurePremiumFeatureAccess(PREMIUM_FEATURE_KEYS.widgetSlider);
        setHeroCarouselIndex(0);
        return;
      }
      setHeroCarouselIndex(normalized);
    },
    [ensurePremiumFeatureAccess, premiumState.isPremium]
  );
  const handleHeroCarouselLockChange = useCallback(
    (nextLocked) => {
      if (!premiumState.isPremium) {
        setHeroCarouselLocked(true);
        return;
      }
      setHeroCarouselLocked(!!nextLocked);
    },
    [premiumState.isPremium]
  );
  useEffect(() => {
    if (premiumState.isPremium) return;
    if (heroCarouselIndex !== 0) {
      setHeroCarouselIndex(0);
    }
    if (!heroCarouselLocked) {
      setHeroCarouselLocked(true);
    }
  }, [heroCarouselIndex, heroCarouselLocked, premiumState.isPremium]);
  const renderActiveScreen = () => {
    if (activeTab === "purchases" && !deferredHydrationReady) {
      return (
        <View style={[styles.screenLoading, { backgroundColor: colors.background }]}>
          <ActivityIndicator color={colors.text} />
        </View>
      );
    }
    switch (activeTab) {
      case "cart":
        return (
          <ProgressScreen
            wishes={wishes}
            currency={profile.currency || DEFAULT_PROFILE.currency}
            onRemoveWish={handleRemoveWish}
            t={t}
            colors={colors}
            primaryGoals={profile.primaryGoals}
            onGoalLongPress={handleGoalLongPress}
            onGoalEdit={openGoalEditorPrompt}
            activeGoalId={activeGoalId || profile.goal}
            onSetActiveGoal={handleActiveGoalSelect}
            language={language}
            catCuriousSource={tamagotchiAnimations.curious}
            healthPoints={healthPoints}
            freeDayStats={freeDayStats}
            onFreeDayLog={handleLogFreeDay}
            onFreeDayRescue={handleFreeDayRescue}
            freeDayRescueCost={FREE_DAY_RESCUE_COST}
            historyEvents={visibleHistoryEvents}
            incomeEntries={incomeEntries}
            budgetOverrides={budgetOverrides}
            budgetAutoEnabled={budgetAutoEnabled}
            onBudgetAutoLocked={handleBudgetAutoLocked}
            savedTotalUSD={savedTotalUSD}
            decisionStats={decisionStats}
            baselineMonthlyWasteUSD={baselineMonthlyWasteUSD}
            onBudgetOverrideChange={handleBudgetOverrideChange}
            onIncomeEntryOpen={openIncomeEntryModal}
            onExtraIncomeEntryOpen={openExtraIncomeEntryModal}
            impulseInsights={impulseInsights}
            showImpulseMap={impulseFeaturesUnlocked}
            showFreeDayCard={freeDayUnlocked}
            challenges={challengeList}
            dailyChallenge={resolvedDailyChallenge}
            onChallengeAccept={handleChallengeAccept}
            onChallengeClaim={handleChallengeClaim}
            onChallengeCancel={handleChallengeCancel}
            onCreateGoal={handleProgressCreateGoal}
            onFocusCancel={requestFocusCancel}
            focusChallengeId={progressFocusChallengeId}
            onFocusHandled={handleProgressFocusHandled}
            challengeBadges={challengeBadgeEmojis}
            challengeBadgeCount={challengeBadgeCount}
            playerLevel={playerLevel}
            resolveTemplateCard={resolveTemplateCard}
            resolveTemptationCategory={resolveTemptationCategory}
            customCategories={customCategories}
            onWeeklySpendPress={openSpendBreakdown}
            budgetSpeechDataRef={resolvedBudgetSpeechDataRef}
            scrollRef={progressScrollRef}
            onBudgetWidgetLayout={handleProgressBudgetWidgetLayout}
            onImpulseMapLockedPress={handleImpulseMapLockedPress}
          />
        );
      case "pending":
        return (
          <PendingScreen
            items={pendingList}
            currency={profile.currency || DEFAULT_PROFILE.currency}
            t={t}
            colors={colors}
            onResolve={handlePendingDecision}
            onDelete={handlePendingDelete}
            onExtend={handlePendingExtend}
            language={language}
            catCuriousSource={tamagotchiAnimations.curious}
            isPremiumUser={premiumState.isPremium}
            onPremiumShelvesPress={handlePendingPremiumShelvesPress}
            locked={!thinkingUnlocked}
            onItemLayout={registerPendingCardLayout}
            scrollRef={pendingScrollRef}
            playSound={playSound}
          />
        );
      case "purchases":
        return (
          <RewardsScreen
            achievements={achievements}
            challenges={challengeList}
            activePane={rewardsPane}
            onPaneChange={setRewardsPane}
            onChallengeAccept={handleChallengeAccept}
            onChallengeClaim={handleChallengeClaim}
            onChallengeCancel={handleChallengeCancel}
            t={t}
            colors={colors}
            savedTotalUSD={savedTotalUSD}
            currency={profile.currency || DEFAULT_PROFILE.currency}
            onRewardClaim={handleRewardClaim}
            healthRewardAmount={HEALTH_PER_REWARD}
            language={language}
            dailyChallenge={resolvedDailyChallenge}
            showChallenges={false}
            showDailyChallengeWidget={false}
            rewardsLocked={!rewardsUnlocked}
            challengesLocked={!challengesUnlocked}
            dailyChallengeLocked={playerLevel < 2}
            scrollRef={rewardsScrollRef}
          />
        );
      case "profile":
        return (
          <ProfileScreen
            profile={isProfileEditing ? profileDraft : profile}
            stats={profileStats}
            editMode={profileEditMode}
            onFieldChange={handleProfileFieldChange}
            onEditPress={handleProfileEditPress}
            onSpendEditPress={handleProfileSpendEditPress}
            onReportsPress={handleReportsPress}
            reportsBadgeVisible={reportsBadgeVisible}
            reportsLocked={!reportsUnlocked}
            reportsUnlockLevel={reportsUnlockLevel}
            onCancelEdit={cancelProfileEdit}
            onSaveEdit={saveProfileEdit}
            onThemeToggle={handleThemeToggle}
            onLanguageChange={handleLanguageChange}
            onCurrencyChange={handleProfileCurrencyChange}
            onResetData={handleResetData}
            onPickImage={handlePickImage}
            theme={theme}
            isPremiumUser={premiumState.isPremium}
            language={language}
            currencyValue={profile.currency || DEFAULT_PROFILE.currency}
            soundEnabled={soundEnabled}
            onSoundToggle={handleSoundToggle}
            spendReducesSavings={spendReducesSavings}
            onSpendReductionToggle={handleSpendImpactToggle}
            history={visibleHistoryEvents}
            onHistoryDelete={handleHistoryDelete}
            freeDayStats={freeDayStats}
            rewardBadgeCount={rewardClaimTotal}
            challengeBadges={challengeBadgeEmojis}
            challengeBadgeCount={challengeBadgeCount}
            monthlyIncomeUSD={currentMonthRecurringIncomeUSD}
            onIncomeEntryOpen={openIncomeEntryModal}
            t={t}
            colors={colors}
            moodPreset={moodPreset}
            mascotImageSource={tamagotchiAvatarSource}
            openAddCategoryModal={openAddCategoryModal}
            openManageCategoriesModal={openManageCategoriesModal}
            scrollRef={profileScrollRef}
          />
      );
      default:
        return (
          <FeedScreen
            ref={feedScreenRef}
            products={products}
            archivedItems={archivedProducts}
            savedTotalUSD={savedTotalUSD}
            progressSavedTotalUSD={progressSavedTotalUSD}
            wishes={wishes}
            onTemptationAction={handleTemptationAction}
            onTemptationEditToggle={toggleTemptationEditor}
            onTemptationArchiveToggle={handleTemptationArchiveToggle}
            onNewTemptation={handleFabNewTemptation}
            t={t}
            tVariant={tVariant}
            language={language}
            colors={colors}
            currency={profile.currency || DEFAULT_PROFILE.currency}
            freeDayStats={freeDayStats}
            usageStreak={usageStreak}
            onUsageStreakPress={handleUsageStreakPress}
            onFreeDayLog={handleLogFreeDay}
            goalAssignments={temptationGoalMap}
            analyticsStats={analyticsStats}
            refuseStats={refuseStats}
            cardFeedback={cardFeedback}
            historyEvents={visibleHistoryEvents}
            onHistoryDelete={handleHistoryDelete}
            profile={profile}
            incomeEntries={incomeEntries}
            budgetOverrides={budgetOverrides}
            budgetAutoEnabled={budgetAutoEnabled}
            decisionStats={decisionStats}
            customCategories={customCategories}
            titleOverrides={titleOverrides}
            descriptionOverrides={descriptionOverrides}
            onBaselineSetup={handleBaselineSetupPrompt}
            healthPoints={healthPoints}
            onFreeDayRescue={handleFreeDayRescue}
            freeDayRescueCost={FREE_DAY_RESCUE_COST}
            impulseInsights={impulseInsights}
            moodPreset={moodPreset}
            onMoodDetailsOpen={openMoodDetails}
            onPotentialDetailsOpen={openPotentialDetails}
            heroGoalTargetUSD={heroGoalTargetUSD}
            heroGoalSavedUSD={heroGoalSavedUSD}
            potentialGrowthUSD={potentialGrowthUSD}
            showPotentialGrowth={potentialGrowthVisible}
            dailyRewardUnlocked={dailyRewardUnlocked}
            dailyRewardReady={dailyRewardReady}
            dailyRewardAmount={dailyRewardDisplayAmount}
            dailyRewardBaseAmount={baseDailyRewardAmount}
            dailyRewardDay={dailyRewardDay}
            onDailyRewardClaim={handleDailyRewardClaim}
            onDailyRewardModalVisibilityChange={setDailyRewardModalVisible}
            dailyGoalCoinDropTick={dailyGoalCoinDropTick}
            onDailyGoalCollect={handleDailyGoalCollect}
            dailyGoalCollectedToday={dailyGoalCollectedToday}
            dailyGoalDayLabel={dailyGoalDayLabel}
            mascotOverride={mascotOverride}
            onMascotAnimationComplete={handleMascotAnimationComplete}
            hideMascot={tamagotchiVisible}
            onMascotPress={openTamagotchiOverlay}
            editingTemptationId={priceEditor.item?.id || null}
            editingTitleValue={priceEditor.title}
            editingPriceValue={priceEditor.value}
            editingGoalLabel={priceEditorAssignedGoalTitle}
            editingEmojiValue={priceEditor.emoji}
            editingDescriptionValue={priceEditor.description || ""}
            editingCategoryValue={priceEditor.category || DEFAULT_IMPULSE_CATEGORY}
            onTemptationEditTitleChange={handlePriceTitleChange}
            onTemptationEditPriceChange={handlePriceInputChange}
            onTemptationEditEmojiChange={handlePriceEmojiChange}
            onTemptationEditDescriptionChange={handlePriceDescriptionChange}
            onTemptationEditCategoryChange={handlePriceCategoryChange}
            onTemptationEditSave={savePriceEdit}
            onTemptationEditCancel={closePriceEditor}
            onTemptationEditDelete={handleTemptationDelete}
            onTemptationGoalSelect={openGoalLinkPrompt}
            onTemptationSwipeDelete={handleTemptationDelete}
            onSavingsBreakdownPress={openSavingsBreakdown}
            onBudgetHeroPress={requestProgressBudgetFocus}
            savingsHeroRef={savingsHeroRef}
            heroCarouselIndex={heroCarouselIndex}
            heroCarouselLocked={!premiumState.isPremium || heroCarouselLocked}
            onHeroCarouselIndexChange={handleHeroCarouselIndexChange}
            onHeroCarouselLocked={handleHeroCarouselLockChange}
            onHeroCarouselPremiumAttempt={handleHeroCarouselPremiumAttempt}
            heroCarouselHintAllowed={heroCarouselHintAllowed}
            resolveTemplateTitle={resolveTemplateTitle}
            resolveTemplateCard={resolveTemplateCard}
            resolveTemptationCategory={resolveTemptationCategory}
            tamagotchiMood={tamagotchiMood}
            tamagotchiDesiredFood={tamagotchiDesiredFood}
            tamagotchiDesiredToy={tamagotchiDesiredToy}
            tamagotchiNeedsPlay={tamagotchiNeedsPlay}
            tamagotchiNeedsCleaning={tamagotchiNeedsCleaning}
            tamagotchiDirtyLevel={tamagotchiDirtyLevel}
            tamagotchiHungerImmunityUntil={tamagotchiHungerImmunityUntil}
            tamagotchiHasHungerImmunity={tamagotchiHasHungerImmunity}
            primaryTemptationId={primaryTemptationId}
            primaryTemptationDescription={primaryTemptationDescription}
            focusTemplateId={focusTemplateId}
            onFocusCancel={requestFocusCancel}
            tamagotchiAnimations={tamagotchiAnimations}
            lifetimeSavedUSD={lifetimeSavedUSD}
            progressLifetimeSavedUSD={progressLifetimeSavedUSD}
            levelProgressOffsetUSD={levelProgressOffsetUSD}
            interactionStats={temptationInteractions}
            resolveCardRefuseStats={resolveCardRefuseStats}
            playSound={playSound}
            tutorialTemptationStepId={tutorialTemptationStepId}
            tutorialHighlightMeasureTick={tutorialHighlightMeasureTick}
            onTutorialHighlightLayoutChange={handleTutorialHighlightLayoutChange}
            allowThinkAction={thinkingUnlocked}
            isPremiumUser={premiumState.isPremium}
            activeChallenge={activeChallenge}
            onActiveChallengePress={handleProgressChallengeOpen}
            onSavingsHeroAnchorChange={handleSavingsHeroAnchor}
            homeSpeechTick={homeSpeechTrigger.tick}
            homeSpeechReason={homeSpeechTrigger.reason}
            speechAllowed={speechAllowed}
            speechWarmupTick={speechWarmupTick}
            lastVisitAt={moodState.lastVisitAt}
            lastVisitAtSnapshot={lastVisitAtSnapshotRef.current}
            tamagotchiGreetingDayKey={tamagotchiGreetingDayKey}
            onTamagotchiGreeting={markTamagotchiGreetingDay}
            budgetSpeechDataRef={resolvedBudgetSpeechDataRef}
            onScrollActivityChange={handleFeedScrollActivity}
          />
        );
    }
  };

  useEffect(() => {
    const tabScreens = {
      feed: "feed",
      cart: "wishlist",
      pending: "pending",
      purchases: "rewards",
      profile: "profile",
    };
    const screenName = tabScreens[activeTab] || "feed";
    logScreenView(screenName);
  }, [activeTab]);
  if (onboardingStep !== "done") {
    const onboardingBackHandler = canGoBackOnboarding ? handleOnboardingBack : undefined;
    const onboardingSkipHandler = canShowOnboardingSkip ? handleOnboardingSkip : null;
    let onboardContent = null;
    if (onboardingStep === "logo") {
      onboardContent = startupLogoReady ? <LogoSplash onDone={handleOnboardingLogoComplete} /> : null;
    } else if (onboardingStep === "language") {
      onboardContent = (
        <LanguageScreen
          colors={colors}
          t={t}
          selectedLanguage={language}
          selectedCurrency={registrationData.currency || DEFAULT_PROFILE.currency}
          onLanguageChange={handleLanguageChange}
          onCurrencyChange={(code) => updateRegistrationData("currency", code)}
          onContinue={handleLanguageContinue}
          onBack={onboardingBackHandler}
          onShowTerms={handleTermsOpen}
          termsAccepted={termsAccepted}
          mascotWaveSource={tamagotchiAnimations.waving}
          bottomInset={androidNavInset}
        />
      );
    } else if (onboardingStep === "guide") {
      onboardContent = (
        <HowItWorksScreen
          colors={colors}
          t={t}
          onContinue={handleGuideContinue}
          onBack={onboardingBackHandler}
          onSkip={onboardingSkipHandler}
          mascotSpeakSource={tamagotchiAnimations.speak}
          bottomInset={androidNavInset}
        />
      );
    } else if (onboardingStep === "register") {
      onboardContent = (
        <RegistrationScreen
          data={registrationData}
          onChange={updateRegistrationData}
          onSubmit={handleRegistrationSubmit}
          onPickImage={handleRegistrationPickImage}
          colors={colors}
          t={t}
          onBack={onboardingBackHandler}
          mascotImageSource={tamagotchiAvatarSource}
          onSkip={onboardingSkipHandler}
          bottomInset={androidNavInset}
        />
      );
    } else if (onboardingStep === "persona") {
      onboardContent = (
        <PersonaScreen
          data={registrationData}
          onChange={updateRegistrationData}
          onSubmit={handlePersonaSubmit}
          colors={colors}
          t={t}
          language={language}
          onBack={onboardingBackHandler}
          onSkip={onboardingSkipHandler}
          bottomInset={androidNavInset}
        />
      );
    } else if (onboardingStep === "habit") {
      onboardContent = (
        <CustomHabitScreen
          data={registrationData}
          onChange={updateRegistrationData}
          onSubmit={handleHabitSubmit}
          colors={colors}
          t={t}
          currency={registrationData.currency || profile.currency || DEFAULT_PROFILE.currency}
          onBack={onboardingBackHandler}
          language={language}
          onSkip={onboardingSkipHandler}
          bottomInset={androidNavInset}
        />
      );
    } else if (onboardingStep === "baseline") {
      onboardContent = (
        <SpendingBaselineScreen
          value={registrationData.baselineMonthlyWaste || ""}
          incomeValue={registrationData.incomeMonthlyAmount || ""}
          currency={registrationData.currency || profile.currency || DEFAULT_PROFILE.currency}
          onChange={(text) => updateRegistrationData("baselineMonthlyWaste", text)}
          onIncomeChange={(text) => updateRegistrationData("incomeMonthlyAmount", text)}
          onSubmit={handleBaselineSubmit}
          colors={colors}
          t={t}
          onBack={onboardingBackHandler}
          onSkip={onboardingSkipHandler}
          onSkipStep={handleBaselineSkip}
          bottomInset={androidNavInset}
        />
      );
    } else if (onboardingStep === "goal") {
      onboardContent = (
        <GoalScreen
          selectedGoals={registrationData.goalSelections || []}
          onToggle={handleGoalToggle}
          onSubmit={handleGoalStageContinue}
          goalTargets={registrationData.goalTargetMap || {}}
          onGoalTargetChange={handleGoalTargetDraftChange}
          currency={registrationData.currency || profile.currency || DEFAULT_PROFILE.currency}
          onRegisterGoalTargetFocus={(handler) => {
            goalTargetFocusRef.current = handler;
          }}
          colors={colors}
          t={t}
          language={language}
          onBack={onboardingBackHandler}
          customGoals={registrationData.customGoals || []}
          onCustomGoalCreate={openOnboardingGoalModal}
          onSkip={onboardingSkipHandler}
          onSkipStep={handleGoalStageSkip}
          bottomInset={androidNavInset}
        />
      );
    } else if (onboardingStep === "goal_target") {
      onboardContent = (
        <GoalTargetScreen
          selections={registrationData.goalSelections || []}
          values={registrationData.goalTargetMap || {}}
          currency={registrationData.currency || profile.currency || DEFAULT_PROFILE.currency}
          onChange={handleGoalTargetDraftChange}
          onSubmit={handleGoalTargetSubmit}
          onBack={onboardingBackHandler}
          colors={colors}
          t={t}
          language={language}
          customGoals={registrationData.customGoals || []}
          onSkip={onboardingSkipHandler}
          bottomInset={androidNavInset}
        />
      );
    } else if (onboardingStep === "analytics_consent") {
      onboardContent = (
        <AnalyticsConsentScreen
          colors={colors}
          t={t}
          onSubmit={(allow) => handleAnalyticsConsentComplete(allow)}
          onBack={onboardingBackHandler}
          bottomInset={androidNavInset}
        />
      );
    } else if (onboardingStep === "push_optin") {
      onboardContent = (
        <OnboardingNotificationsScreen
          colors={colors}
          t={t}
          onContinue={handleOnboardingNotificationsContinue}
          mascotHappySource={tamagotchiAnimations.happy}
          bottomInset={androidNavInset}
        />
      );
    }
    const onboardingBackground = onboardingStep === "logo" ? "#fff" : colors.background;
    return (
      <>
        <View
          style={[styles.appBackground, { backgroundColor: onboardingBackground }]}
          onTouchStart={handleRootTouchStart}
        >
          <SafeAreaView
            style={[
              styles.appShell,
              {
                backgroundColor: onboardingBackground,
                paddingTop: topSafeInset,
              },
            ]}
          >
            {shouldRenderStatusGlass && (
              <StatusGlass
                height={topSafeInset}
                colors={{ ...colors, background: onboardingBackground }}
                theme={theme}
                blurAvailable={statusBlurAvailable}
                solid={Platform.OS === "android"}
              />
            )}
            <StatusBar
              style={theme === "dark" ? "light" : "dark"}
              backgroundColor={canSetSystemBarColors ? onboardingBackground : undefined}
            />
            {onboardContent || (startupLogoReady ? <LogoSplash onDone={handleOnboardingLogoComplete} /> : null)}
            {backGestureResponder && (
              <View pointerEvents="box-none" style={styles.backGestureWrapper}>
                <View style={styles.backGestureEdge} {...backGestureResponder.panHandlers} />
              </View>
            )}
          </SafeAreaView>
        </View>
        <ImageSourceSheet
          visible={showImageSourceSheet}
          colors={colors}
          t={t}
          onClose={closeImagePickerSheet}
          onSelect={handleImageSourceChoice}
        />
        <OnboardingGoalModal
          visible={onboardingGoalModal.visible}
          colors={colors}
          t={t}
          currency={registrationData.currency || profile.currency || DEFAULT_PROFILE.currency}
          data={onboardingGoalModal}
          onChange={handleOnboardingGoalChange}
          onSubmit={handleOnboardingGoalSubmit}
          onCancel={handleOnboardingGoalCancel}
          keyboardOffset={keyboardModalOffset}
        />
        <TermsModal
          visible={termsModalVisible}
          colors={colors}
          t={t}
          language={language}
          onAccept={handleTermsAccept}
          onCancel={handleTermsCancel}
          onOpenLink={handleTermsLinkOpen}
        />
        <CustomSpendSavingsModal
          visible={customSpendSavingsModal.visible}
          colors={colors}
          t={t}
          title={customSpendSavingsModal.title}
          lowLabel={customSpendSavingsModal.lowLabel}
          highLabel={customSpendSavingsModal.highLabel}
          onContinue={handleCustomSpendSavingsContinue}
        />
      </>
    );
  }

  const isExtraIncomeEntry = incomeEntryModeRef.current === INCOME_ENTRY_TYPES.EXTRA;
  const incomeEntryTitleKey = isExtraIncomeEntry ? "extraIncomeEntryTitle" : "incomeEntryTitle";
  const incomeEntrySubtitleKey = isExtraIncomeEntry
    ? "extraIncomeEntrySubtitle"
    : "incomeEntrySubtitle";
  const incomeEntryExplanationKey = isExtraIncomeEntry
    ? "extraIncomeEntryExplanation"
    : "incomeEntryExplanation";
  const incomeEntryAmountLabelKey = isExtraIncomeEntry
    ? "extraIncomeEntryAmountLabel"
    : "incomeEntryAmountLabel";
  const incomeEntryConfirmKey = isExtraIncomeEntry
    ? "extraIncomeEntryConfirm"
    : "incomeEntryConfirm";
  const incomeEntrySkipKey = isExtraIncomeEntry ? "extraIncomeEntrySkip" : "incomeEntrySkip";

  return (
    <SavingsProvider value={{ savedTotalUSD }}>
      <View
        style={[styles.appBackground, { backgroundColor: colors.background }]}
        onTouchStart={handleRootTouchStart}
      >
          <SafeAreaView
            style={[
              styles.appShell,
              {
                backgroundColor: colors.background,
                paddingTop: topSafeInset,
              },
            ]}
            onLayout={handleHomeLayout}
          >
              {shouldRenderStatusGlass && (
                <StatusGlass
                  height={topSafeInset}
                  colors={colors}
                  theme={theme}
                  blurAvailable={statusBlurAvailable}
                  solid={Platform.OS === "android"}
                />
              )}
              {startupLogoVisible && (
                <View style={[styles.logoSplashOverlay, { backgroundColor: colors.background }]}>
                  <LogoSplash onDone={handleStartupLogoComplete} />
                </View>
              )}
              <StatusBar
                style={theme === "dark" ? "light" : "dark"}
                backgroundColor={
                  canSetSystemBarColors ? (systemOverlayActive ? overlaySystemColor : colors.background) : undefined
                }
              />
              {backGestureResponder && (
                <View pointerEvents="box-none" style={styles.backGestureWrapper}>
                  <View style={styles.backGestureEdge} {...backGestureResponder.panHandlers} />
                </View>
              )}
              <View style={[styles.screenWrapper, screenKeyboardAdjustmentStyle]}>{renderActiveScreen()}</View>
          <ReportsModal
            visible={reportsModalVisible}
            reports={reportsSnapshot}
            activeTab={reportsTab}
            onTabChange={setReportsTab}
            onClose={closeReportsModal}
            t={t}
            colors={colors}
            currency={profile.currency || DEFAULT_PROFILE.currency}
            language={language}
          />
          {breakdownVisible && (
            <Modal visible transparent animationType="fade" statusBarTranslucent>
              <View style={styles.breakdownOverlay}>
                <Pressable style={StyleSheet.absoluteFillObject} onPress={closeBreakdown} />
              <View
                style={[
                  styles.spendStatsCard,
                  { backgroundColor: colors.card, borderColor: colors.border },
                ]}
              >
                    <View style={styles.spendStatsHeader}>
                      <View style={[styles.spendStatsTabs, { backgroundColor: colors.background }]}>
                        {[
                          { id: "day", label: t("spendStatsTabDay") },
                          { id: "week", label: t("spendStatsTabWeek") },
                          { id: "month", label: t("spendStatsTabMonth") },
                        ].map((tab) => {
                          const active = activeBreakdownRange === tab.id;
                          return (
                            <TouchableOpacity
                              key={tab.id}
                              style={[
                                styles.spendStatsTab,
                                active && styles.spendStatsTabActive,
                                active && { backgroundColor: colors.card },
                              ]}
                              activeOpacity={0.85}
                              onPress={() => setBreakdownRangeMode(tab.id)}
                            >
                              <Text
                                style={[
                                  styles.spendStatsTabText,
                                  { color: active ? colors.text : colors.muted },
                                ]}
                              >
                                {tab.label}
                              </Text>
                            </TouchableOpacity>
                          );
                        })}
                      </View>
                      <View style={styles.spendStatsHeaderActions}>
                        <TouchableOpacity
                          onPress={closeBreakdown}
                          style={[styles.spendStatsCloseButton, { backgroundColor: colors.background }]}
                        >
                          <Text style={[styles.spendStatsCloseText, { color: colors.muted }]}>âœ•</Text>
                        </TouchableOpacity>
                      </View>
                    </View>
                    <View style={styles.spendStatsTitleRow}>
                      <TouchableOpacity
                        onPress={handleBreakdownPrev}
                        style={[
                          styles.spendStatsNavButton,
                          { backgroundColor: colors.background },
                        ]}
                      >
                        <Text
                          style={[
                            styles.spendStatsNavText,
                            { color: colors.muted },
                          ]}
                        >
                          â€¹
                        </Text>
                      </TouchableOpacity>
                      <View style={styles.spendStatsTitleBlock}>
                        {!!breakdownData.averageLabel && (
                          <Text style={[styles.spendStatsSubtitle, { color: colors.muted }]}>
                            {breakdownData.averageLabel}
                          </Text>
                        )}
                        <Text style={[styles.spendStatsTitle, { color: colors.text }]}>
                          {breakdownData.rangeTitle}
                        </Text>
                      </View>
                      <View style={styles.spendStatsTitleActions}>
                        <TouchableOpacity
                          onPress={handleBreakdownNext}
                          disabled={activeBreakdownOffset === 0}
                          style={[
                            styles.spendStatsNavButton,
                            { backgroundColor: colors.background },
                            activeBreakdownOffset === 0 && styles.spendStatsNavButtonDisabled,
                          ]}
                        >
                          <Text
                            style={[
                              styles.spendStatsNavText,
                              {
                                color: activeBreakdownOffset === 0 ? colors.border : colors.muted,
                              },
                            ]}
                          >
                            â€º
                          </Text>
                        </TouchableOpacity>
                        {renderBreakdownModeToggle(breakdownMode)}
                      </View>
                    </View>
                    {(() => {
                      const maxTotal = Math.max(
                        ...breakdownData.buckets.map((bucket) => bucket.total || 0),
                        1
                      );
                      const trackInnerHeight = Math.max(
                        0,
                        SPEND_STATS_TRACK_HEIGHT - SPEND_STATS_TRACK_PADDING * 2
                      );
                      const barItemStyle = { width: spendStatsChartMetrics.barWidth, flex: 0 };
                      const bars = breakdownData.buckets.map((bucket) => {
                        const stacks = bucket.stacks.slice().reverse();
                        const stackCount = Math.max(stacks.length, 1);
                        const availableHeight = Math.max(
                          0,
                          trackInnerHeight - SPEND_STATS_STACK_GAP * (stackCount - 1)
                        );
                        const minStackHeight = Math.min(
                          SPEND_STATS_MIN_STACK_HEIGHT,
                          availableHeight / stackCount
                        );
                        const rawHeights = stacks.map((stack) =>
                          maxTotal ? (stack.value / maxTotal) * availableHeight : 0
                        );
                        const adjustedHeights = rawHeights.map((height) => Math.max(minStackHeight, height));
                        const adjustedTotal = adjustedHeights.reduce((sum, height) => sum + height, 0);
                        const scale =
                          adjustedTotal > availableHeight && adjustedTotal > 0
                            ? availableHeight / adjustedTotal
                            : 1;
                        return (
                          <View key={bucket.label} style={[styles.spendStatsBarItem, barItemStyle]}>
                            <Text
                              style={[
                                styles.spendStatsValue,
                                { color: breakdownMode === "spend" ? SPEND_ACTION_COLOR : SAVE_ACTION_COLOR },
                              ]}
                            >
                              {breakdownData.formatLocal(bucket.total > 0 ? bucket.total : 0)}
                            </Text>
                            <View
                              style={[
                                styles.spendStatsBarTrack,
                                { backgroundColor: colors.background },
                              ]}
                            >
                              {stacks.map((stack, index) => (
                                <View
                                  key={stack.title}
                                  style={[
                                    styles.spendStatsBarStack,
                                    {
                                      height: adjustedHeights[index] * scale,
                                      marginTop: index === 0 ? 0 : SPEND_STATS_STACK_GAP,
                                      backgroundColor: stack.color,
                                    },
                                  ]}
                                />
                              ))}
                            </View>
                            <Text
                              style={[styles.spendStatsBarLabel, { color: colors.muted }]}
                              numberOfLines={1}
                              adjustsFontSizeToFit
                              minimumFontScale={0.7}
                            >
                              {bucket.label}
                            </Text>
                          </View>
                        );
                      });
                      return (
                        <ScrollView
                          ref={spendStatsScrollRef}
                          horizontal
                          scrollEnabled={spendStatsShouldScroll}
                          nestedScrollEnabled
                          showsHorizontalScrollIndicator={false}
                          style={styles.spendStatsChartScroll}
                          contentContainerStyle={[
                            styles.spendStatsChart,
                            styles.spendStatsChartScrollable,
                            {
                              width: Math.max(
                                spendStatsChartMetrics.totalWidth,
                                spendStatsChartMetrics.chartWidth
                              ),
                              paddingRight: SPEND_STATS_CHART_GAP,
                            },
                          ]}
                        >
                          {bars}
                        </ScrollView>
                      );
                    })()}
                    <View style={[styles.spendStatsDivider, { backgroundColor: colors.border }]} />
                    <View style={styles.spendStatsLegend}>
                      {breakdownData.legend.map((entry) => (
                        <View
                          key={entry.id}
                          style={[
                            styles.spendStatsLegendPill,
                            { backgroundColor: colorWithAlpha(entry.color, 0.18) },
                          ]}
                        >
                          <Text style={[styles.spendStatsLegendPercent, { color: entry.color }]}>
                            {entry.percent}%
                          </Text>
                          <Text style={[styles.spendStatsLegendLabel, { color: colors.text }]}>
                            {entry.label}
                          </Text>
                        </View>
                      ))}
                    </View>
              </View>
            </View>
          </Modal>
        )}
        {dailyChallengeCompleteVisible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={handleDailyChallengeCompleteClose}>
              <View style={styles.dailyChallengeBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <Animated.View
                    style={[
                      styles.dailyChallengeCompleteCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                      {
                        opacity: dailyChallengeCompleteAnim,
                        transform: [
                          {
                            translateY: dailyChallengeCompleteAnim.interpolate({
                              inputRange: [0, 1],
                              outputRange: [26, 0],
                            }),
                          },
                          {
                            scale: dailyChallengeCompleteAnim.interpolate({
                              inputRange: [0, 1],
                              outputRange: [0.96, 1],
                            }),
                          },
                        ],
                      },
                    ]}
                  >
                    <View
                      style={[
                        styles.dailyChallengeCompleteGlow,
                        {
                          backgroundColor: isDarkTheme
                            ? "rgba(255,200,87,0.35)"
                            : "rgba(255,160,60,0.25)",
                        },
                      ]}
                    />
                    <View style={styles.dailyChallengeCompleteHeader}>
                      <View
                        style={[
                          styles.dailyChallengeBadge,
                          { borderColor: colors.border, backgroundColor: colors.background },
                        ]}
                      >
                        <Text style={[styles.dailyChallengeBadgeText, { color: colors.muted }]}>
                          {t("dailyChallengeCompleteBadge")}
                        </Text>
                      </View>
                      <Text style={[styles.dailyChallengeCompleteTitle, { color: colors.text }]}>
                        {t("dailyChallengeCompleteTitle")}
                      </Text>
                      <Text style={[styles.dailyChallengeCompleteSubtitle, { color: colors.muted }]}>
                        {t("dailyChallengeCompleteSubtitle", {
                          temptation: dailyChallengeDisplayTitle,
                        })}
                      </Text>
                    </View>
                    <View
                      style={[
                        styles.dailyChallengeCompleteReward,
                        {
                          backgroundColor: isDarkTheme
                            ? "rgba(255,255,255,0.06)"
                            : "rgba(17,17,17,0.04)",
                          borderColor: colors.border,
                        },
                      ]}
                    >
                      <HealthRewardTokens amount={dailyChallengeTotalReward} color={colors.text} iconSize={20} />
                      <Text style={[styles.dailyChallengeCompleteRewardText, { color: colors.text }]}>
                        +{dailyChallengeTotalRewardLabel}
                      </Text>
                    </View>
                    <Text style={[styles.dailyChallengeCompleteHint, { color: colors.muted }]}>
                      {t("dailyChallengeCompleteHint")}
                    </Text>
                    <TouchableOpacity
                      style={[styles.dailyChallengeCompleteButton, { backgroundColor: colors.text }]}
                      activeOpacity={0.9}
                      onPress={handleDailyChallengeCompleteClose}
                    >
                      <Text style={[styles.dailyChallengeCompleteButtonText, { color: colors.background }]}>
                        {t("dailyChallengeCompleteCta")}
                      </Text>
                    </TouchableOpacity>
                  </Animated.View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {dailyChallengePromptVisible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={handleDailyChallengeDismiss}>
              <View style={styles.dailyChallengeBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.dailyChallengeDrawPanel,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <View
                      style={[
                        styles.dailyChallengeDrawGlow,
                        { backgroundColor: isDarkTheme ? "rgba(255,200,87,0.35)" : "rgba(255,160,60,0.25)" },
                      ]}
                    />
                    <View style={styles.dailyChallengeDrawHeader}>
                      <View
                        style={[
                          styles.dailyChallengeBadge,
                          { borderColor: colors.border, backgroundColor: colors.background },
                        ]}
                      >
                        <Text style={[styles.dailyChallengeBadgeText, { color: colors.muted }]}>
                          {t("dailyChallengeOfferBadge")}
                        </Text>
                      </View>
                      <Text style={[styles.dailyChallengeTitle, { color: colors.text }]}>
                        {dailyChallengeDrawn
                          ? t("dailyChallengeOfferTitle")
                          : t("dailyChallengeDrawTitle")}
                      </Text>
                      <Text style={[styles.dailyChallengeSubtitle, { color: colors.muted }]}>
                        {dailyChallengeDrawn
                          ? t("dailyChallengeOfferSubtitle", { temptation: dailyChallengeDisplayTitle })
                          : t("dailyChallengeDrawSubtitle")}
                      </Text>
                    </View>
                    <View style={styles.dailyChallengeDrawRow}>
                      {Array.from({ length: DAILY_CHALLENGE_DRAW_COUNT }).map((_, index) => {
                        const accent =
                          dailyChallengeCardAccents[index] || CARD_TEXTURE_ACCENTS[0] || "#8AB9FF";
                        const intro = dailyChallengeCardIntroAnims[index];
                        const float = dailyChallengeCardFloatAnims[index];
                        const tilt = DAILY_CHALLENGE_DRAW_CARD_TILT[index] || 0;
                        const isSelected = dailyChallengeDrawnIndex === index;
                        const introTranslate = intro.interpolate({
                          inputRange: [0, 1],
                          outputRange: [28, 0],
                        });
                        const floatTranslate = float.interpolate({
                          inputRange: [0, 1],
                          outputRange: [0, -6],
                        });
                        let translateY = Animated.add(introTranslate, floatTranslate);
                        let scale = intro.interpolate({ inputRange: [0, 1], outputRange: [0.95, 1] });
                        let opacity = intro;
                        if (dailyChallengeDrawn) {
                          if (isSelected) {
                            const lift = dailyChallengeSelectAnim.interpolate({
                              inputRange: [0, 1],
                              outputRange: [0, -12],
                            });
                            translateY = Animated.add(translateY, lift);
                            const selectedScale = dailyChallengeSelectAnim.interpolate({
                              inputRange: [0, 1],
                              outputRange: [1, 1.06],
                            });
                            scale = Animated.multiply(scale, selectedScale);
                          } else {
                            const fade = dailyChallengeRevealAnim.interpolate({
                              inputRange: [0, 1],
                              outputRange: [1, 0],
                            });
                            opacity = Animated.multiply(opacity, fade);
                            const drop = dailyChallengeRevealAnim.interpolate({
                              inputRange: [0, 1],
                              outputRange: [0, 18],
                            });
                            translateY = Animated.add(translateY, drop);
                            const shrink = dailyChallengeRevealAnim.interpolate({
                              inputRange: [0, 1],
                              outputRange: [1, 0.95],
                            });
                            scale = Animated.multiply(scale, shrink);
                          }
                        }
                        const backRotation = isSelected
                          ? dailyChallengeRevealAnim.interpolate({
                              inputRange: [0, 1],
                              outputRange: ["0deg", "180deg"],
                            })
                          : "0deg";
                        const frontRotation = isSelected
                          ? dailyChallengeRevealAnim.interpolate({
                              inputRange: [0, 1],
                              outputRange: ["180deg", "360deg"],
                            })
                          : "180deg";
                        const shadowColor = colorWithAlpha(accent, isSelected ? 0.4 : 0.25);
                        return (
                          <Pressable
                            key={`daily-challenge-card-${index}`}
                            style={styles.dailyChallengeDrawCardWrap}
                            disabled={dailyChallengeDrawn}
                            onPress={() => handleDailyChallengeDrawSelect(index)}
                          >
                            <Animated.View
                              style={[
                                styles.dailyChallengeDrawCard,
                                {
                                  width: DAILY_CHALLENGE_DRAW_CARD_WIDTH,
                                  height: DAILY_CHALLENGE_DRAW_CARD_HEIGHT,
                                  borderColor: colorWithAlpha(accent, 0.55),
                                  shadowColor,
                                  opacity,
                                  transform: [
                                    { perspective: 900 },
                                    { translateY },
                                    { rotateZ: `${tilt}deg` },
                                    { scale },
                                  ],
                                },
                              ]}
                            >
                              <Animated.View
                                style={[
                                  styles.dailyChallengeDrawCardFace,
                                  styles.dailyChallengeDrawCardBack,
                                  {
                                    backgroundColor: colorWithAlpha(accent, 0.18),
                                    borderColor: colorWithAlpha(accent, 0.6),
                                    transform: [{ perspective: 900 }, { rotateY: backRotation }],
                                  },
                                ]}
                              >
                                <View
                                  style={[
                                    styles.dailyChallengeDrawCardBackGlow,
                                    { backgroundColor: colorWithAlpha(accent, 0.35) },
                                  ]}
                                />
                                <View style={styles.dailyChallengeDrawCardBackPattern} />
                                <View
                                  style={[
                                    styles.dailyChallengeDrawCardBackSigil,
                                    { borderColor: colorWithAlpha(accent, 0.5) },
                                  ]}
                                >
                                  <Text
                                    style={[
                                      styles.dailyChallengeDrawCardBackSigilText,
                                      { color: colorWithAlpha(accent, 0.9) },
                                    ]}
                                  >
                                    A
                                  </Text>
                                </View>
                              </Animated.View>
                              <Animated.View
                                style={[
                                  styles.dailyChallengeDrawCardFace,
                                  styles.dailyChallengeDrawCardFront,
                                  {
                                    backgroundColor: colors.card,
                                    borderColor: colors.border,
                                    transform: [{ perspective: 900 }, { rotateY: frontRotation }],
                                  },
                                ]}
                              >
                                <View
                                  style={[
                                    styles.dailyChallengeDrawCardFrontEmoji,
                                    { backgroundColor: colorWithAlpha(accent, 0.18) },
                                  ]}
                                >
                                  <Text style={styles.dailyChallengeDrawCardFrontEmojiText}>
                                    {dailyChallengeTemplate?.emoji || dailyChallenge.emoji || "âœ¨"}
                                  </Text>
                                </View>
                                <Text
                                  style={[styles.dailyChallengeDrawCardFrontTitle, { color: colors.text }]}
                                  numberOfLines={2}
                                >
                                  {dailyChallengeDisplayTitle}
                                </Text>
                              </Animated.View>
                            </Animated.View>
                          </Pressable>
                        );
                      })}
                    </View>
                    <Animated.View
                      style={[
                        styles.dailyChallengeDrawHintWrap,
                        {
                          opacity: dailyChallengeRevealAnim.interpolate({
                            inputRange: [0, 0.6, 1],
                            outputRange: [1, 0.1, 0],
                          }),
                          transform: [
                            {
                              translateY: dailyChallengeRevealAnim.interpolate({
                                inputRange: [0, 1],
                                outputRange: [0, -8],
                              }),
                            },
                          ],
                        },
                      ]}
                      pointerEvents="none"
                    >
                      <Text style={[styles.dailyChallengeDrawHint, { color: colors.muted }]}>
                        {t("dailyChallengeDrawHint")}
                      </Text>
                    </Animated.View>
                  <Animated.View
                      style={[
                        styles.dailyChallengeRevealPanel,
                        !dailyChallengeDrawn && styles.dailyChallengeDrawHidden,
                        {
                          opacity: dailyChallengeRevealAnim,
                          backgroundColor: isDarkTheme
                            ? "rgba(255,255,255,0.05)"
                            : "rgba(17,17,17,0.03)",
                          borderColor: colors.border,
                          transform: [
                            {
                              translateY: dailyChallengeRevealAnim.interpolate({
                                inputRange: [0, 1],
                                outputRange: [18, 0],
                              }),
                            },
                          ],
                        },
                      ]}
                      pointerEvents={dailyChallengeDrawn ? "auto" : "none"}
                    >
                      <View style={styles.dailyChallengeRevealRow}>
                        <View
                          style={[
                            styles.dailyChallengeRevealEmoji,
                            {
                              backgroundColor: isDarkTheme
                                ? "rgba(255,255,255,0.12)"
                                : "rgba(17,17,17,0.06)",
                              borderColor: colors.border,
                            },
                          ]}
                        >
                          <Text style={styles.dailyChallengeRevealEmojiText}>
                            {dailyChallengeTemplate?.emoji || dailyChallenge.emoji || "âœ¨"}
                          </Text>
                        </View>
                        <View style={{ flex: 1, gap: 6 }}>
                          <Text style={[styles.dailyChallengeRevealTitle, { color: colors.text }]}>
                            {dailyChallengeDisplayTitle}
                          </Text>
                          <Text style={[styles.dailyChallengeRevealHint, { color: colors.muted }]}>
                            {t("dailyChallengeOfferHint")}
                          </Text>
                        </View>
                      </View>
                      <View style={styles.dailyChallengeRewardStack}>
                        <HealthRewardTokens amount={dailyChallengeRewardBonus} color={colors.text} iconSize={18} />
                        <Text style={[styles.dailyChallengeRewardHint, { color: colors.text }]}>
                          {t("dailyChallengeOfferReward", { amount: dailyChallengeRewardLabel })}
                        </Text>
                      </View>
                    </Animated.View>
                    <Animated.View
                      style={[
                        styles.dailyChallengeActionsWrap,
                        !dailyChallengeDrawn && styles.dailyChallengeDrawHidden,
                        {
                          opacity: dailyChallengeRevealAnim,
                          transform: [
                            {
                              translateY: dailyChallengeRevealAnim.interpolate({
                                inputRange: [0, 1],
                                outputRange: [22, 0],
                              }),
                            },
                          ],
                        },
                      ]}
                      pointerEvents={dailyChallengeDrawn ? "auto" : "none"}
                    >
                      <View style={styles.dailyChallengeActions}>
                        <TouchableOpacity
                          style={[styles.dailyChallengePrimaryButton, { backgroundColor: colors.text }]}
                          activeOpacity={0.92}
                          onPress={handleDailyChallengeAccept}
                        >
                          <Text style={[styles.dailyChallengePrimaryText, { color: colors.background }]}>
                            {t("dailyChallengeOfferAccept")}
                          </Text>
                        </TouchableOpacity>
                        <TouchableOpacity
                          style={[styles.dailyChallengeGhostButton, { borderColor: colors.border }]}
                          activeOpacity={0.85}
                          onPress={handleDailyChallengeLater}
                        >
                          <Text style={[styles.dailyChallengeGhostText, { color: colors.muted }]}>
                            {t("dailyChallengeOfferLater")}
                          </Text>
                        </TouchableOpacity>
                      </View>
                    </Animated.View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {coinValueModalVisible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <View style={styles.quickModalBackdrop}>
              <View style={[styles.quickModalCard, { backgroundColor: colors.card }]}>
                <View style={styles.coinValueHero}>
                  <View style={styles.coinValueHeroGlow} />
                  <Image source={LEVEL_SHARE_CAT} style={styles.coinValueHeroCat} />
                  <View style={styles.coinValueHeroFooter}>
                    <Image source={LEVEL_SHARE_LOGO} style={styles.coinValueHeroLogo} />
                    <Text style={styles.coinValueHeroBrand}>Almost</Text>
                  </View>
                </View>
                <Text style={[styles.quickModalTitle, { color: colors.text }]}>
                  {t("coinValueTitle")}
                </Text>
                <Text style={[styles.quickModalSubtitle, { color: colors.muted }]}>
                  {t("coinValueBody")}
                </Text>
                <View style={styles.quickModalActions}>
                  <TouchableOpacity
                    style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
                    onPress={dismissCoinValueModal}
                    activeOpacity={0.9}
                  >
                    <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>
                      {t("coinValueCta")}
                    </Text>
                  </TouchableOpacity>
                </View>
              </View>
            </View>
          </Modal>
        )}
        {dailyGoalCollectModal.visible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={closeDailyGoalCollectModal}>
              <View style={styles.quickModalBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View style={[styles.quickModalCard, { backgroundColor: colors.card }]}>
                    <View
                      style={[
                        styles.dailyGoalCollectHero,
                        {
                          backgroundColor: isDarkTheme
                            ? "rgba(46,184,115,0.2)"
                            : "rgba(46,184,115,0.12)",
                          borderColor: isDarkTheme
                            ? "rgba(120,230,175,0.6)"
                            : "rgba(46,184,115,0.4)",
                        },
                      ]}
                    >
                      {GREEN_HEALTH_COIN_ASSET ? (
                        <Image source={GREEN_HEALTH_COIN_ASSET} style={styles.dailyGoalCollectCoin} />
                      ) : null}
                      <Text
                        style={[
                          styles.dailyGoalCollectAmount,
                          { color: isDarkTheme ? "#D6FFE8" : SAVE_ACTION_COLOR },
                        ]}
                      >
                        +{dailyGoalCollectModal.coins}
                      </Text>
                    </View>
                    <Text style={[styles.quickModalTitle, { color: colors.text }]}>
                      {t("dailyGoalCollectTitle")}
                    </Text>
                    <Text style={[styles.quickModalSubtitle, { color: colors.muted }]}>
                      {t("dailyGoalCollectSubtitle", { count: dailyGoalCollectModal.coins })}
                    </Text>
                    <View style={styles.quickModalActions}>
                      <TouchableOpacity
                        style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
                        onPress={closeDailyGoalCollectModal}
                        activeOpacity={0.9}
                      >
                        <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>
                          {t("dailyGoalCollectCta")}
                        </Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {dailySummaryVisible && dailySummaryData && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={handleDailySummaryContinue}>
              <View style={styles.dailySummaryBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.dailySummaryCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <View
                      style={[
                        styles.dailySummaryGlow,
                        { backgroundColor: isDarkTheme ? "#FFC857" : "#111111" },
                      ]}
                    />
                    <View style={styles.dailySummaryCardContent}>
                      <View style={styles.dailySummaryHeroRow}>
                        <View
                          style={[
                            styles.dailySummaryIconWrap,
                            {
                              backgroundColor: isDarkTheme
                                ? "rgba(255,255,255,0.08)"
                                : "rgba(17,17,17,0.05)",
                              borderColor: colors.border,
                            },
                          ]}
                        >
                          <Text style={styles.dailySummaryIconText}>ðŸŒ™</Text>
                        </View>
                        <View style={styles.dailySummaryHeroText}>
                          <View
                            style={[
                              styles.dailySummaryBadge,
                              { backgroundColor: colors.background, borderColor: colors.border },
                            ]}
                          >
                            <Text style={[styles.dailySummaryBadgeText, { color: colors.muted }]}>
                              {t("dailySummaryBadgeLabel")}
                            </Text>
                          </View>
                          <Text style={[styles.dailySummaryTitle, { color: colors.text }]}>
                            {t("dailySummaryTitle")}
                          </Text>
                          <Text style={[styles.dailySummarySubtitle, { color: colors.muted }]}>
                            {t("dailySummarySubtitle")}
                          </Text>
                        </View>
                      </View>
                      <View
                        style={[
                          styles.dailySummaryHighlight,
                          {
                            backgroundColor: isDarkTheme
                              ? "rgba(255,255,255,0.06)"
                              : "rgba(17,17,17,0.03)",
                            borderColor: isDarkTheme ? "rgba(255,255,255,0.12)" : "rgba(0,0,0,0.06)",
                          },
                        ]}
                      >
                        <Text style={[styles.dailySummaryHighlightLabel, { color: colors.muted }]}>
                          {t("dailySummarySavedLabel")}
                        </Text>
                        <Text style={[styles.dailySummaryHighlightValue, { color: colors.text }]}>
                          {formatCurrency(
                            convertToCurrency(
                              dailySummaryData.savedUSD || 0,
                              profile.currency || DEFAULT_PROFILE.currency
                            ),
                            profile.currency || DEFAULT_PROFILE.currency
                          )}
                        </Text>
                        <Text style={[styles.dailySummaryHighlightSub, { color: colors.muted }]}>
                          {t("dailySummarySavedSub")}
                        </Text>
                      </View>
                      <View style={styles.dailySummaryStatsRow}>
                        <View
                          style={[
                            styles.dailySummaryStatCard,
                            {
                              backgroundColor: isDarkTheme
                                ? "rgba(255,255,255,0.08)"
                                : "rgba(255,255,255,0.94)",
                              borderColor: isDarkTheme ? "rgba(255,255,255,0.12)" : "rgba(0,0,0,0.05)",
                            },
                          ]}
                        >
                          <Text style={[styles.dailySummaryStatValue, { color: colors.text }]}>
                            {dailySummaryData.declines || 0}
                          </Text>
                          <Text style={[styles.dailySummaryStatLabel, { color: colors.muted }]}>
                            {t("statsDeclines")}
                          </Text>
                        </View>
                        <View
                          style={[
                            styles.dailySummaryStatCard,
                            {
                              backgroundColor: isDarkTheme
                                ? "rgba(255,255,255,0.08)"
                                : "rgba(255,255,255,0.94)",
                              borderColor: isDarkTheme ? "rgba(255,255,255,0.12)" : "rgba(0,0,0,0.05)",
                            },
                          ]}
                        >
                        <Text style={[styles.dailySummaryStatValue, { color: colors.text }]}>
                            {dailySummaryData.spends || 0}
                          </Text>
                          <Text style={[styles.dailySummaryStatLabel, { color: colors.muted }]}>
                            {t("dailySummarySpendsLabel")}
                          </Text>
                        </View>
                      </View>
                      <TouchableOpacity
                        style={[styles.dailySummaryButton, { backgroundColor: colors.text }]}
                        onPress={handleDailySummaryContinue}
                        activeOpacity={0.9}
                      >
                        <Text style={[styles.dailySummaryButtonText, { color: colors.background }]}>
                          {t("dailySummaryContinue")}
                        </Text>
                        <Text style={[styles.dailySummaryButtonIcon, { color: colors.background }]}>
                          â†’
                        </Text>
                      </TouchableOpacity>
                      <Text style={[styles.dailySummaryHint, { color: colors.muted }]}>
                        {t("dailySummaryHint")}
                      </Text>
                    </View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {pushDayThreePromptVisible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <View style={styles.quickModalBackdrop}>
              <View style={[styles.quickModalCard, { backgroundColor: colors.card }]}>
                <Text style={[styles.quickModalTitle, { color: colors.text }]}>
                  {t("pushOptInPromptTitle")}
                </Text>
                <Text style={[styles.quickModalSubtitle, { color: colors.muted }]}>
                  {t("pushOptInPromptBody")}
                </Text>
                <View style={styles.quickModalActions}>
                  <TouchableOpacity
                    style={[styles.quickModalSecondary, { borderColor: colors.border }]}
                    activeOpacity={0.85}
                    onPress={handlePushDayThreePromptLater}
                  >
                    <Text style={[styles.quickModalSecondaryText, { color: colors.muted }]}>
                      {t("pushOptInPromptSecondary")}
                    </Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
                    activeOpacity={0.92}
                    onPress={handlePushDayThreePromptEnable}
                  >
                    <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>
                      {t("pushOptInPromptPrimary")}
                    </Text>
                  </TouchableOpacity>
                </View>
              </View>
            </View>
          </Modal>
        )}
        {ratingPromptVisible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={handleRatingPromptLater}>
              <View style={styles.ratingPromptBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.ratingPromptCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <Animated.View
                      style={[styles.ratingPromptCatWrap, { transform: [{ translateY: ratingPromptCatBob }] }]}
                    >
                      <Image
                        source={tamagotchiAnimations?.cry || CLASSIC_TAMAGOTCHI_ANIMATIONS.cry}
                        style={styles.ratingPromptCat}
                        resizeMode="contain"
                      />
                    </Animated.View>
                    <Text style={[styles.ratingPromptTitle, { color: colors.text }]}>
                      {t("ratingPromptTitle")}
                    </Text>
                    <Text style={[styles.ratingPromptBody, { color: colors.muted }]}>
                      {t("ratingPromptBody")}
                    </Text>
                    <View style={styles.ratingPromptActions}>
                      <TouchableOpacity
                        style={[styles.ratingPromptSecondary, { borderColor: colors.border }]}
                        activeOpacity={0.85}
                        onPress={handleRatingPromptLater}
                      >
                        <Text style={[styles.ratingPromptSecondaryText, { color: colors.muted }]}>
                          {t("ratingPromptLater")}
                        </Text>
                      </TouchableOpacity>
                      <TouchableOpacity
                        style={[styles.ratingPromptPrimary, { backgroundColor: colors.text }]}
                        activeOpacity={0.92}
                        onPress={handleRatingPromptConfirm}
                      >
                        <Text style={[styles.ratingPromptPrimaryText, { color: colors.background }]}>
                          {t("ratingPromptAction")}
                        </Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {levelShareModal.visible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={closeLevelShareModal}>
              <View style={styles.dailySummaryBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.levelShareModalCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <Text style={[styles.levelShareModalTitle, { color: colors.text }]}>
                      {t("levelShareModalTitle")}
                    </Text>
                    <Text style={[styles.levelShareModalCaption, { color: colors.muted }]}>
                      {t("levelShareModalCaption")}
                    </Text>
                    <ViewShot
                      ref={levelShareCardRef}
                      options={{ format: "png", quality: 0.96, result: "tmpfile" }}
                      style={styles.levelShareShot}
                    >
                      <View style={styles.levelShareCanvas}>
                        <View style={styles.levelShareBadge}>
                          <Text style={styles.levelShareBadgeText}>{t("levelShareCardBadge")}</Text>
                        </View>
                        <Text style={styles.levelShareCanvasTitle}>
                          {t("levelShareCardTitle", { level: levelShareModal.level })}
                        </Text>
                        <Text style={styles.levelShareCanvasSubtitle}>{t("levelShareCardSubtitle")}</Text>
                        <Image source={LEVEL_SHARE_CAT} style={styles.levelShareCat} />
                        <Text style={styles.levelShareJoin}>{t("levelShareJoin")}</Text>
                        <Text style={styles.levelShareInstagram}>@almostsavings</Text>
                        <View style={styles.levelShareFooter}>
                          <Image source={LEVEL_SHARE_LOGO} style={styles.levelShareLogo} />
                          <View>
                            <Text style={styles.levelShareFooterBrand}>{t("levelShareFooterBrand")}</Text>
                            <Text style={styles.levelShareFooterHint}>{t("levelShareFooterHint")}</Text>
                          </View>
                        </View>
                      </View>
                    </ViewShot>
                    <View style={styles.levelShareActions}>
                      <TouchableOpacity
                        style={[
                          styles.levelSharePrimary,
                          { backgroundColor: colors.text, opacity: levelShareSharing ? 0.6 : 1 },
                        ]}
                        activeOpacity={0.92}
                        disabled={levelShareSharing}
                        onPress={handleLevelShareConfirm}
                      >
                        <Text style={[styles.levelSharePrimaryText, { color: colors.background }]}>
                          {levelShareSharing ? "..." : t("levelShareModalShare")}
                        </Text>
                      </TouchableOpacity>
                      <TouchableOpacity
                        style={[styles.levelShareGhost, { borderColor: colors.border }]}
                        activeOpacity={0.85}
                        onPress={closeLevelShareModal}
                      >
                        <Text style={[styles.levelShareGhostText, { color: colors.muted }]}>
                          {t("levelShareModalClose")}
                        </Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        <View
          style={[
            styles.tabBar,
            tutorialIsTemptation && styles.tabBarDimmed,
            {
              backgroundColor: isProTheme ? "#F3F5FF" : colors.card,
              borderTopColor: isProTheme ? colorWithAlpha(proThemeAccentColor, 0.32) : colors.border,
              paddingBottom: tabBarBottomInset + (Platform.OS === "android" ? androidTabBarExtra : 0),
              marginBottom: Platform.OS === "ios" ? -(safeAreaInsets.bottom || 0) : 0,
              paddingTop: tabBarTopPadding,
            },
          ]}
          onLayout={handleTabBarLayout}
        >
          {availableTabs.map((tab) => {
            const isHighlighted =
              !tutorialIsTemptation && !!tutorialHighlightTabs?.has(tab);
            const isActiveTab = activeTab === tab;
            const isTabLocked =
              (tab === "pending" && !thinkingUnlocked) ||
              (tab === "purchases" && !rewardsUnlocked);
            const highlightBackground = isDarkTheme
              ? "rgba(255,255,255,0.2)"
              : isProTheme
              ? colorWithAlpha(proThemeAccentColor, 0.16)
              : "#FFFFFF";
            const highlightTextColor = isDarkTheme ? "#05070D" : isProTheme ? "#1C2F86" : colors.text;
            const defaultTextColor = isActiveTab ? (isProTheme ? proThemeAccentColor : colors.text) : colors.muted;
            const textColor = isHighlighted ? highlightTextColor : defaultTextColor;
            const highlightBorderColor = isDarkTheme
              ? "rgba(255,255,255,0.4)"
              : isProTheme
              ? colorWithAlpha(proThemeAccentColor, 0.44)
              : "rgba(0,0,0,0.08)";
            const tabBadgeBackground = isDarkTheme ? "#FEE5A8" : isProTheme ? proThemeAccentColor : colors.text;
            const tabBadgeTextColor = isDarkTheme ? "#05070D" : isProTheme ? "#FFFFFF" : colors.background;
            return (
              <TouchableOpacity
                key={tab}
                style={[
                  styles.tabButton,
                  isHighlighted && styles.tabButtonHighlight,
                  isHighlighted && {
                    borderColor: highlightBorderColor,
                    backgroundColor: highlightBackground,
                  },
                  isCompactAndroid && { paddingVertical: tabButtonVerticalPadding },
                ]}
                onPress={() => handleTabChange(tab)}
              >
                <Text
                  style={[
                    styles.tabButtonText,
                    {
                      color: textColor,
                      fontWeight: isActiveTab || isHighlighted ? "700" : "500",
                      fontSize: tabLabelFontSize,
                      marginTop: tabLabelTopMargin,
                    },
                  ]}
                >
                  {tab === "feed"
                    ? t("feedTab")
                    : tab === "cart"
                    ? t("wishlistTab")
                    : tab === "pending"
                    ? t("pendingTab")
                    : tab === "purchases"
                    ? t("purchasesTitle")
                    : t("profileTab")}
                </Text>
                {isTabLocked && (
                  <Text
                    style={[
                      styles.tabLockIconOverlay,
                      isCompactAndroid && styles.tabLockIconOverlayCompact,
                      { color: textColor },
                    ]}
                  >
                    ðŸ”’
                  </Text>
                )}
                {tab === "cart" && challengeRewardsBadgeCount > 0 && challengesUnlocked && (
                  <View
                    style={[
                      styles.tabBadge,
                      styles.tabBadgeFloating,
                      {
                        backgroundColor: tabBadgeBackground,
                      },
                    ]}
                  >
                    <Text
                      style={[
                        styles.tabBadgeText,
                        { color: tabBadgeTextColor },
                      ]}
                    >
                      {challengeRewardsBadgeCount > 99 ? "99+" : `${challengeRewardsBadgeCount}`}
                    </Text>
                  </View>
                )}
                {tab === "purchases" && rewardsBadgeCount > 0 && rewardsUnlocked && (
                  <View
                    style={[
                      styles.tabBadge,
                      styles.tabBadgeFloating,
                      {
                        backgroundColor: tabBadgeBackground,
                      },
                    ]}
                  >
                    <Text
                      style={[
                        styles.tabBadgeText,
                        { color: tabBadgeTextColor },
                      ]}
                    >
                      {rewardsBadgeCount > 99 ? "99+" : `${rewardsBadgeCount}`}
                    </Text>
                  </View>
                )}
                {tab === "profile" && reportsBadgeVisible && reportsUnlocked && (
                  <View
                    style={[
                      styles.tabBadge,
                      styles.tabBadgeDot,
                      styles.tabBadgeFloating,
                      { backgroundColor: tabBadgeBackground },
                    ]}
                  />
                )}
              </TouchableOpacity>
            );
          })}
        </View>

        {activeTab !== "profile" && activeTab !== "purchases" && !(activeTab === "pending" && !thinkingUnlocked) && (
          <Animated.View
            pointerEvents="box-none"
            style={[
              styles.fabCenterContainer,
              fabSlideStyle,
              Platform.OS === "android"
                ? { bottom: FAB_CONTAINER_BOTTOM + tabBarBottomInset }
                : null,
            ]}
          >
            <View
              ref={fabButtonWrapperRef}
              style={styles.fabButtonWrapper}
              pointerEvents="box-none"
              onLayout={handleFabWrapperLayout}
              collapsable={false}
            >
              {fabTutorialVisible && (
                <View
                  pointerEvents="none"
                  style={[
                    styles.fabTutorialHalo,
                    {
                      backgroundColor: isDarkTheme
                        ? "rgba(255,214,140,0.22)"
                        : isProTheme
                        ? colorWithAlpha(proThemeAccentColor, 0.2)
                        : "rgba(245,200,105,0.22)",
                      borderColor: isDarkTheme ? "#FFE08A" : isProTheme ? proThemeAccentColor : "#F5C869",
                      shadowColor: isDarkTheme ? "#FFE08A" : isProTheme ? proThemeAccentColor : "#F5C869",
                    },
                  ]}
                />
              )}
              <AnimatedTouchableOpacity
                style={[
                  styles.cartBadge,
                  {
                    backgroundColor: isProTheme ? proThemeAccentColor : colors.text,
                    borderColor: isProTheme ? colorWithAlpha(proThemeAccentColor, 0.78) : colors.border,
                    transform: [{ scale: cartBadgeScale }],
                  },
                  fabTutorialVisible && styles.cartBadgeHighlight,
                ]}
                onPress={handleFabPress}
                onLongPress={handleFabLongPress}
                delayLongPress={420}
              >
                <Text
                  style={[styles.cartBadgeIcon, { color: isProTheme ? "#FFFFFF" : colors.background }]}
                  numberOfLines={1}
                >
                  {fabMainIcon}
                </Text>
              </AnimatedTouchableOpacity>
            </View>
          </Animated.View>
        )}

        <CoinEntryModal
          visible={coinEntryVisible}
          presetAction={coinEntryPresetAction}
          colors={colors}
          t={t}
          currency={profile.currency || DEFAULT_PROFILE.currency}
          language={language}
          maxAmountUSD={coinSliderMaxUSD}
          categoryStats={impulseInsights?.categories}
          categoryRecency={quickCategoryRecency}
          customCategories={customCategories}
          onUpdateMaxUSD={handleCoinSliderMaxUpdate}
          onSubmit={handleCoinEntrySubmit}
          onCancel={handleCoinEntryClose}
          playSound={playSound}
          origin={fabTutorialAnchor}
          saveTarget={savingsHeroAnchor}
        />

        <QuickCustomModal
          visible={showCustomSpend}
          colors={colors}
          t={t}
          currency={profile.currency || DEFAULT_PROFILE.currency}
          data={quickSpendDraft}
          onChange={handleQuickCustomChange}
          onSubmit={handleQuickCustomSubmit}
          onCancel={handleQuickCustomCancel}
          language={language}
          keyboardOffset={keyboardModalOffset}
        />
        <NewPendingModal
          visible={newPendingModal.visible}
          colors={colors}
          t={t}
          currency={profile.currency || DEFAULT_PROFILE.currency}
          data={newPendingModal}
          onChange={handleNewPendingChange}
          onSubmit={handleNewPendingSubmit}
          onCancel={handleNewPendingCancel}
          keyboardOffset={keyboardModalOffset}
        />

        <NewGoalModal
          visible={newGoalModal.visible}
          colors={colors}
          t={t}
          currency={profile.currency || DEFAULT_PROFILE.currency}
          data={newGoalModal}
          onChange={handleNewGoalChange}
          onSubmit={handleNewGoalSubmit}
          onCancel={handleNewGoalCancel}
          keyboardOffset={keyboardModalOffset}
        />

        {activeTab !== "profile" && fabTutorialVisible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={() => handleFabTutorialDismiss("backdrop")}>
              <View style={styles.fabTutorialBackdrop}>
                <Svg
                  pointerEvents="none"
                  width={SCREEN_WIDTH}
                  height={SCREEN_HEIGHT}
                  style={styles.fabTutorialOverlaySvg}
                >
                  <Defs>
                    <Mask id="fabTutorialMask">
                      <SvgRect width={SCREEN_WIDTH} height={SCREEN_HEIGHT} fill="white" />
                      <SvgCircle
                        cx={fabTutorialCutout.centerX}
                        cy={fabTutorialCutout.centerY}
                        r={FAB_TUTORIAL_HALO_SIZE / 2}
                        fill="black"
                      />
                    </Mask>
                  </Defs>
                  <SvgRect
                    width={SCREEN_WIDTH}
                    height={SCREEN_HEIGHT}
                    fill={fabOverlayColor}
                    mask="url(#fabTutorialMask)"
                  />
                </Svg>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View style={styles.fabTutorialContent} pointerEvents="box-none">
                    <View
                      style={[
                        styles.fabTutorialCard,
                        {
                          backgroundColor: colors.card,
                          borderColor: colors.border,
                          marginBottom: tabBarBottomInset + FAB_CONTAINER_BOTTOM + FAB_TUTORIAL_CARD_SPACING,
                        },
                      ]}
                    >
                      <Text style={[styles.fabTutorialTitle, { color: colors.text }]}>
                        {t("fabTutorialTitle")}
                      </Text>
                      <Text style={[styles.fabTutorialDescription, { color: colors.muted }]}>
                        {t("fabTutorialDesc")}
                      </Text>
                      <TouchableOpacity
                        style={[styles.fabTutorialButton, { backgroundColor: colors.text }]}
                        onPress={() => handleFabTutorialDismiss("cta")}
                      >
                        <Text style={[styles.fabTutorialButtonText, { color: colors.background }]}>
                          {t("fabTutorialAction")}
                        </Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}

        <BudgetWidgetTutorialModal
          visible={budgetWidgetTutorialVisible}
          colors={colors}
          t={t}
          theme={theme}
          onClose={dismissBudgetWidgetTutorial}
        />

        {tutorialContext && activeTutorialStep && (
          <Modal
            visible
            transparent
            animationType="fade"
            statusBarTranslucent
            onRequestClose={tutorialSkipHandler}
          >
            <View
              style={[
                styles.tutorialBackdrop,
                tutorialBackdropPlacementStyle,
                { paddingBottom: tutorialBackdropPaddingBottom },
              ]}
              pointerEvents="box-none"
            >
              {tutorialIsTemptation ? (
                <>
                  <View pointerEvents="none" style={StyleSheet.absoluteFillObject}>
                    <Svg
                      width="100%"
                      height="100%"
                      viewBox={`0 0 ${SCREEN_WIDTH} ${SCREEN_HEIGHT}`}
                      pointerEvents="none"
                    >
                      <Defs>
                        <Mask id="tutorialHighlightMask">
                          <SvgRect x="0" y="0" width="100%" height="100%" fill="#fff" />
                          {tutorialHighlightMaskRect && (
                            <SvgRect
                              x={tutorialHighlightMaskRect.x}
                              y={tutorialHighlightMaskRect.y}
                              width={tutorialHighlightMaskRect.width}
                              height={tutorialHighlightMaskRect.height}
                              rx={tutorialHighlightMaskRect.radius}
                              ry={tutorialHighlightMaskRect.radius}
                              fill="#000"
                            />
                          )}
                        </Mask>
                      </Defs>
                      <SvgRect
                        x="0"
                        y="0"
                        width="100%"
                        height="100%"
                        fill="rgba(0,0,0,0.6)"
                        mask="url(#tutorialHighlightMask)"
                      />
                    </Svg>
                  </View>
                  {tutorialHighlightMaskRect && (
                    <View
                      pointerEvents="none"
                      style={[
                        styles.tutorialHighlightFocus,
                        {
                          top: tutorialHighlightMaskRect.y,
                          left: tutorialHighlightMaskRect.x,
                          width: tutorialHighlightMaskRect.width,
                          height: tutorialHighlightMaskRect.height,
                          borderRadius: tutorialHighlightMaskRect.radius,
                        },
                      ]}
                    />
                  )}
                </>
              ) : (
                <View
                  pointerEvents="none"
                  style={[StyleSheet.absoluteFillObject, { bottom: tutorialBackdropBottomInset }]}
                >
                  <Animated.View
                    style={[
                      StyleSheet.absoluteFillObject,
                      styles.tutorialBackdropDim,
                      { opacity: tutorialBackdropOpacity },
                    ]}
                  />
                  <Animated.View
                    style={[
                      styles.tutorialBackdropBlob,
                      styles.tutorialBackdropBlobPrimary,
                      {
                        backgroundColor: tutorialVisualPalette.glow,
                        opacity: tutorialPulseOpacity,
                        transform: [{ translateY: tutorialAmbientLift }],
                      },
                    ]}
                  />
                  <Animated.View
                    style={[
                      styles.tutorialBackdropBlob,
                      styles.tutorialBackdropBlobSecondary,
                      {
                        backgroundColor: tutorialVisualPalette.secondary,
                        opacity: tutorialPulseOpacity,
                        transform: [{ translateY: tutorialAmbientDrift }],
                      },
                    ]}
                  />
                </View>
              )}
              <Animated.View
                style={[
                  styles.tutorialCard,
                  tutorialIsTemptation && styles.tutorialCardCompact,
                  tutorialCardPositionStyle,
                  { backgroundColor: tutorialCardBackground, borderColor: tutorialCardBorderColor },
                  {
                    opacity: tutorialCardOpacity,
                    transform: [{ translateY: tutorialCardTranslateY }, { scale: tutorialCardScale }],
                  },
                ]}
              >
                {tutorialIsTemptation ? (
                  <>
                    <View style={styles.tutorialCompactHeader}>
                      <View
                        style={[
                          styles.tutorialCompactIconWrap,
                          {
                            backgroundColor: tutorialFeatureBackground,
                            borderColor: tutorialFeatureBorderColor,
                          },
                        ]}
                      >
                        <Text style={styles.tutorialCompactIcon}>{activeTutorialStep.icon}</Text>
                      </View>
                      <View style={styles.tutorialCompactHeaderCopy}>
                        <Text style={[styles.tutorialCompactTitle, { color: colors.text }]}>
                          {t(activeTutorialStep.titleKey)}
                        </Text>
                        <Text style={[styles.tutorialCompactStepText, { color: colors.muted }]}>
                          {`${Math.min(tutorialCurrentIndex + 1, tutorialStepCount)}/${tutorialStepCount}`}
                        </Text>
                      </View>
                    </View>
                    <Text style={[styles.tutorialCompactDescription, { color: colors.muted }]}>
                      {t(activeTutorialStep.descriptionKey)}
                    </Text>
                    <View style={styles.tutorialCompactProgressRow}>
                      <View style={styles.tutorialDots}>
                        {tutorialContext.steps.map((step, index) => (
                          <View
                            key={step.id}
                            style={[
                              styles.tutorialDot,
                              index < tutorialCurrentIndex && styles.tutorialDotCompleted,
                              index === tutorialCurrentIndex && styles.tutorialDotActive,
                              {
                                backgroundColor:
                                  index <= tutorialCurrentIndex
                                    ? colors.text
                                    : tutorialDotInactiveColor,
                              },
                            ]}
                          />
                        ))}
                      </View>
                      <Text style={[styles.tutorialProgressText, { color: colors.muted }]}>
                        {t("tutorialProgress", {
                          current: `${Math.min(tutorialCurrentIndex + 1, tutorialStepCount)}`,
                          total: `${tutorialStepCount}`,
                        })}
                      </Text>
                    </View>
                    <View style={styles.tutorialCompactActions}>
                      <TouchableOpacity
                        style={[
                          styles.tutorialCompactSkipButton,
                          {
                            backgroundColor: tutorialFeatureBackground,
                            borderColor: tutorialFeatureBorderColor,
                          },
                        ]}
                        onPress={tutorialSkipHandler}
                      >
                        <Text style={[styles.tutorialCompactSkipText, { color: colors.muted }]}>
                          {t("tutorialSkip")}
                        </Text>
                      </TouchableOpacity>
                      <TouchableOpacity
                        style={[styles.tutorialCompactPrimaryButton, { backgroundColor: tutorialPrimaryButtonBg }]}
                        onPress={tutorialAdvanceHandler}
                        activeOpacity={0.9}
                      >
                        <Text style={[styles.tutorialCompactPrimaryText, { color: tutorialPrimaryButtonTextColor }]}>
                          {tutorialStepCount && tutorialCurrentIndex === tutorialStepCount - 1
                            ? t("tutorialDone")
                            : t("tutorialNext")}
                        </Text>
                      </TouchableOpacity>
                    </View>
                  </>
                ) : (
                  <>
                    <View style={styles.tutorialTopRow}>
                      <View
                        style={[
                          styles.tutorialStepBadge,
                          {
                            backgroundColor: tutorialFeatureBackground,
                            borderColor: tutorialFeatureBorderColor,
                          },
                        ]}
                      >
                        <Text style={styles.tutorialIcon}>{activeTutorialStep.icon}</Text>
                        <Text style={[styles.tutorialStepBadgeText, { color: tutorialFeatureTextColor }]} numberOfLines={1}>
                          {t(tutorialBadgeLabelKey)}
                        </Text>
                      </View>
                      <View style={[styles.tutorialStepCounter, { borderColor: tutorialFeatureBorderColor }]}>
                        <Text style={[styles.tutorialStepCounterText, { color: colors.muted }]}>
                          {`${Math.min(tutorialCurrentIndex + 1, tutorialStepCount)}/${tutorialStepCount}`}
                        </Text>
                      </View>
                    </View>
                    <View style={[styles.tutorialVisualWrap, { borderColor: tutorialFeatureBorderColor }]}>
                      <Animated.View
                        pointerEvents="none"
                        style={[
                          styles.tutorialVisualPulse,
                          {
                            borderColor: tutorialVisualPalette.glow,
                            opacity: tutorialPulseOpacity,
                            transform: [{ scale: tutorialPulseScale }],
                          },
                        ]}
                      />
                      <Animated.View
                        pointerEvents="none"
                        style={[
                          styles.tutorialVisualOrb,
                          styles.tutorialVisualOrbPrimary,
                          {
                            backgroundColor: tutorialVisualPalette.primary,
                            transform: [{ translateY: tutorialAmbientLift }, { rotate: tutorialAmbientRotate }],
                          },
                        ]}
                      />
                      <Animated.View
                        pointerEvents="none"
                        style={[
                          styles.tutorialVisualOrb,
                          styles.tutorialVisualOrbSecondary,
                          {
                            backgroundColor: tutorialVisualPalette.secondary,
                            transform: [{ translateY: tutorialAmbientDrift }, { rotate: tutorialAmbientRotate }],
                          },
                        ]}
                      />
                      <View style={styles.tutorialVisualGrid} pointerEvents="none" />
                      <View style={styles.tutorialVisualBarsRow} pointerEvents="none">
                        {tutorialVisualBars.map((value, index) => {
                          const normalized = Math.min(1, Math.max(0.18, Number(value) || 0));
                          return (
                            <View key={`${activeTutorialStep.id}_bar_${index}`} style={styles.tutorialVisualBarTrack}>
                              <Animated.View
                                style={[
                                  styles.tutorialVisualBarFill,
                                  {
                                    height: `${Math.round(normalized * 100)}%`,
                                    backgroundColor:
                                      index % 2 === 0
                                        ? tutorialVisualPalette.primary
                                        : tutorialVisualPalette.secondary,
                                    opacity: tutorialBarsOpacity,
                                    transform: [{ translateY: tutorialBarsTranslateY }],
                                  },
                                ]}
                              />
                            </View>
                          );
                        })}
                      </View>
                    </View>
                    <Text style={[styles.tutorialTitle, { color: colors.text }]}>
                      {t(activeTutorialStep.titleKey)}
                    </Text>
                    <Text style={[styles.tutorialDescription, { color: colors.muted }]}>
                      {t(activeTutorialStep.descriptionKey)}
                    </Text>
                    {!!tutorialFeatureKeys.length && (
                      <View style={styles.tutorialFeatureRow}>
                        {tutorialFeatureKeys.slice(0, 4).map((key) => (
                          <View
                            key={`${activeTutorialStep.id}_${key}`}
                            style={[
                              styles.tutorialFeatureChip,
                              {
                                backgroundColor: tutorialFeatureBackground,
                                borderColor: tutorialFeatureBorderColor,
                              },
                            ]}
                          >
                            <Text
                              style={[styles.tutorialFeatureChipText, { color: tutorialFeatureTextColor }]}
                              numberOfLines={1}
                            >
                              {t(key)}
                            </Text>
                          </View>
                        ))}
                      </View>
                    )}
                    <View style={styles.tutorialProgressRow}>
                      <View style={styles.tutorialDots}>
                        {tutorialContext.steps.map((step, index) => (
                          <View
                            key={step.id}
                            style={[
                              styles.tutorialDot,
                              index < tutorialCurrentIndex && styles.tutorialDotCompleted,
                              index === tutorialCurrentIndex && styles.tutorialDotActive,
                              {
                                backgroundColor:
                                  index <= tutorialCurrentIndex
                                    ? colors.text
                                    : tutorialDotInactiveColor,
                              },
                            ]}
                          />
                        ))}
                      </View>
                      <Text style={[styles.tutorialProgressText, { color: colors.muted }]}>
                        {t("tutorialProgress", {
                          current: `${Math.min(tutorialCurrentIndex + 1, tutorialStepCount)}`,
                          total: `${tutorialStepCount}`,
                        })}
                      </Text>
                    </View>
                    <View style={styles.tutorialActions}>
                      <TouchableOpacity
                        style={[
                          styles.tutorialSkipButton,
                          {
                            backgroundColor: tutorialFeatureBackground,
                            borderColor: tutorialFeatureBorderColor,
                          },
                        ]}
                        onPress={tutorialSkipHandler}
                      >
                        <Text style={[styles.tutorialSkipText, { color: colors.muted }]}>
                          {t("tutorialSkip")}
                        </Text>
                      </TouchableOpacity>
                      <TouchableOpacity
                        style={[styles.tutorialPrimaryButton, { backgroundColor: tutorialPrimaryButtonBg }]}
                        onPress={tutorialAdvanceHandler}
                        activeOpacity={0.9}
                      >
                        <Text style={[styles.tutorialPrimaryText, { color: tutorialPrimaryButtonTextColor }]}>
                          {tutorialStepCount && tutorialCurrentIndex === tutorialStepCount - 1
                            ? t("tutorialDone")
                            : t("tutorialNext")}
                        </Text>
                      </TouchableOpacity>
                    </View>
                  </>
                )}
              </Animated.View>
            </View>
          </Modal>
        )}
        <Modal
          visible={tamagotchiVisible}
          transparent
          animationType="fade"
          onRequestClose={closeTamagotchiOverlay}
          statusBarTranslucent
        >
          <View
            style={[
              styles.tamagotchiBackdrop,
              { backgroundColor: isDarkTheme ? "#0D111A" : colors.background },
            ]}
          >
            <View
              pointerEvents="none"
              style={[
                styles.tamagotchiBackdropDecor,
                {
                  backgroundColor: colorWithAlpha(isDarkTheme ? "#355DFF" : "#9EDAFF", isDarkTheme ? 0.2 : 0.26),
                },
              ]}
            />
            <View
              pointerEvents="none"
              style={[
                styles.tamagotchiBackdropDecorSecondary,
                {
                  backgroundColor: colorWithAlpha(isDarkTheme ? "#FF6FA8" : "#FFD5A3", isDarkTheme ? 0.16 : 0.24),
                },
              ]}
            />
            {partyActive && (
              <>
                <PartyFireworksLayer isDarkMode={isDarkTheme} />
                <PartySparklesLayer isDarkMode={isDarkTheme} />
                <CoinRainOverlay dropCount={12} />
              </>
            )}
	            <Animated.View
	              style={[
	                styles.tamagotchiCard,
                { backgroundColor: colors.card, borderColor: colors.border },
                {
                  transform: [
                    {
                      translateY: tamagotchiModalAnim.interpolate({
                        inputRange: [0, 1],
                        outputRange: [20, 0],
                      }),
                    },
                    {
                      scale: tamagotchiModalAnim.interpolate({
                        inputRange: [0, 1],
                        outputRange: [0.95, 1],
                      }),
                    },
                  ],
                  opacity: tamagotchiModalAnim,
	                },
	              ]}
	            >
	                  <View
	                    pointerEvents="box-none"
	                    style={[
	                      styles.tamagotchiStickyBackWrap,
	                      { top: Math.max(2, (safeAreaInsets.top || topSafeInset || 0) - 6) },
	                    ]}
	                  >
	                    <TouchableOpacity
	                      style={[
	                        styles.tamagotchiBackButton,
	                        styles.tamagotchiBackButtonFloating,
	                        {
	                          borderColor: colorWithAlpha(colors.border, 0.95),
	                          backgroundColor: colorWithAlpha(lightenColor(colors.card, isDarkTheme ? 0.08 : 0.18), 0.95),
	                          shadowColor: colorWithAlpha("#0A1324", isDarkTheme ? 0.5 : 0.28),
	                        },
	                      ]}
	                      onPress={closeTamagotchiOverlay}
	                      activeOpacity={0.9}
	                    >
	                      <Text style={[styles.tamagotchiBackButtonArrow, { color: colors.text }]}>â†</Text>
	                      <Text style={[styles.tamagotchiBackButtonText, { color: colors.text }]}>
	                        {t("onboardingBack")}
	                      </Text>
	                    </TouchableOpacity>
	                  </View>
	                  <View
	                    pointerEvents="box-none"
	                    style={[
	                      styles.tamagotchiStickyRewardWrap,
	                      { top: Math.max(2, (safeAreaInsets.top || topSafeInset || 0) - 6) },
	                    ]}
	                  >
                    <View style={styles.tamagotchiStickyOverlayStack}>
                      <Animated.View style={{ transform: [{ scale: tamagotchiRewardPulseAnim }] }}>
                        <TouchableOpacity
                          style={[
                            styles.tamagotchiStickyRewardButton,
                            {
                              borderColor: dailyRewardReady ? SAVE_ACTION_COLOR : colors.border,
                              backgroundColor: colorWithAlpha(colors.card, isDarkTheme ? 0.95 : 0.98),
                              opacity: dailyRewardReady ? 1 : 0.72,
                            },
                          ]}
                          onPress={handleTamagotchiDailyRewardPress}
                          activeOpacity={dailyRewardReady ? 0.86 : 0.94}
                        >
                          <Text style={styles.tamagotchiRewardIcon}>ðŸŽ</Text>
                          <Text
                            style={[styles.tamagotchiStickyRewardText, { color: colors.text }]}
                            numberOfLines={1}
                            adjustsFontSizeToFit
                            minimumFontScale={0.66}
                          >
                            {dailyRewardButtonLabel}
                          </Text>
                        </TouchableOpacity>
                      </Animated.View>
	                      <View
	                        style={[
	                          styles.tamagotchiStickyCoinsPill,
	                          {
	                            borderColor: colorWithAlpha(colors.border, 0.94),
	                            backgroundColor: colorWithAlpha(colors.card, isDarkTheme ? 0.94 : 0.98),
	                          },
	                        ]}
	                      >
	                        {tamagotchiStickyCoinTokens.map((token) => (
	                          <View key={token.id} style={styles.tamagotchiStickyCoinToken}>
	                            <Image source={token.asset} style={styles.tamagotchiStickyCoinsIcon} />
	                            <Text style={[styles.tamagotchiStickyCoinsValue, { color: colors.text }]}>
	                              Ã—{token.count}
	                            </Text>
	                          </View>
	                        ))}
	                      </View>
                    </View>
                  </View>
	                  <ScrollView
	                    style={styles.tamagotchiCardScroll}
	                    scrollEnabled={!tamagotchiCleanTouchActive}
	                    contentContainerStyle={[
	                      styles.tamagotchiCardContent,
	                      {
	                        paddingTop: Math.max(
	                          IS_SHORT_DEVICE ? 108 : 116,
	                          (safeAreaInsets.top || topSafeInset || 0) + 82
	                        ),
	                        paddingBottom: Math.max(16, (safeAreaInsets.bottom || 0) + 14),
	                      },
	                    ]}
                    showsVerticalScrollIndicator={false}
                    bounces={false}
                    keyboardShouldPersistTaps="handled"
	                  >
	                  <View style={styles.tamagotchiHeader}>
	                    <View style={styles.tamagotchiHeaderTextWrap}>
	                      <View style={styles.tamagotchiHeaderLine}>
	                        <Text style={[styles.tamagotchiTitle, { color: colors.text }]} numberOfLines={1}>
	                          {t("tamagotchiName")}
	                        </Text>
	                        <Text style={[styles.tamagotchiMood, { color: colors.muted }]} numberOfLines={1}>
	                          {tamagotchiMood.label}
	                        </Text>
	                      </View>
	                    </View>
                  </View>
                  <View
                    style={[
                      styles.tamagotchiPreview,
                      {
                        borderColor: colors.border,
                        backgroundColor: lightenColor(colors.card, isDarkTheme ? 0.08 : 0.16),
                      },
                    ]}
                  >
                    <View
                      pointerEvents="none"
                      style={[
                        styles.tamagotchiPreviewAura,
                        {
                          backgroundColor: colorWithAlpha(isDarkTheme ? "#5B8FFF" : "#8DD9FF", isDarkTheme ? 0.22 : 0.26),
                        },
                      ]}
                    />
                    <View
                      pointerEvents="none"
                      style={[
                        styles.tamagotchiPreviewAuraSecondary,
                        {
                          backgroundColor: colorWithAlpha(isDarkTheme ? "#FF7AB0" : "#FFD6A5", isDarkTheme ? 0.14 : 0.2),
                        },
                      ]}
                    />
                    <View style={styles.skinPickerControl}>
	                      <TouchableOpacity
	                        style={[
	                          styles.skinPickerButton,
	                          {
	                            borderColor: colors.border,
	                            backgroundColor: colorWithAlpha(colors.card, isDarkTheme ? 0.92 : 0.98),
	                          },
	                          !catCustomizationUnlocked && styles.skinPickerButtonLocked,
	                        ]}
	                        onPress={openSkinPicker}
	                        hitSlop={8}
	                        activeOpacity={0.85}
	                      >
                        <Text style={styles.skinPickerIcon}>ðŸ§¥</Text>
                        {!catCustomizationUnlocked && (
                          <View
                            style={[
                              styles.skinPickerLockBadge,
                              { backgroundColor: colors.card, borderColor: colors.border },
                            ]}
                          >
                            <Text style={styles.skinPickerLockText}>ðŸ”’</Text>
                          </View>
                        )}
                      </TouchableOpacity>
                    </View>
                    <View
                      style={styles.tamagotchiMascotWrap}
                      {...(tamagotchiActiveTab === "clean"
                        ? tamagotchiCleanPanResponder.panHandlers
                        : {})}
                    >
                      <AlmiTamagotchi
                        override={mascotOverride}
                        onOverrideComplete={handleMascotAnimationComplete}
                        isStarving={
                          tamagotchiMood?.need === "food" &&
                          tamagotchiMood?.tone === "urgent"
                        }
                        isPlayDeprived={tamagotchiNeedsPlay}
                        desaturation={tamagotchiDirtyLevel}
                        animations={tamagotchiAnimations}
                        style={styles.tamagotchiMascotLarge}
                      />
                      {tamagotchiToyFlightId && (
                        <Animated.View
                          pointerEvents="none"
                          style={[
                            styles.tamagotchiToyOrbit,
                            {
                              opacity: tamagotchiToyFlightAnim.interpolate({
                                inputRange: [0, 0.08, 0.9, 1],
                                outputRange: [0, 1, 1, 0],
                              }),
                              transform: [
                                {
                                  translateX: tamagotchiToyFlightAnim.interpolate({
                                    inputRange: [0, 0.25, 0.5, 0.75, 1],
                                    outputRange: [0, 62, -56, 48, 0],
                                  }),
                                },
                                {
                                  translateY: tamagotchiToyFlightAnim.interpolate({
                                    inputRange: [0, 0.25, 0.5, 0.75, 1],
                                    outputRange: [-24, -70, -18, -62, -18],
                                  }),
                                },
                                {
                                  rotate: tamagotchiToyFlightAnim.interpolate({
                                    inputRange: [0, 0.5, 1],
                                    outputRange: ["0deg", "180deg", "340deg"],
                                  }),
                                },
                                {
                                  scale: tamagotchiToyFlightAnim.interpolate({
                                    inputRange: [0, 0.12, 0.8, 1],
                                    outputRange: [0.7, 1.2, 1, 0.75],
                                  }),
                                },
                              ],
                            },
                          ]}
                        >
                          <Text style={styles.tamagotchiToyOrbitText}>
                            {TAMAGOTCHI_TOY_MAP[tamagotchiToyFlightId]?.emoji || "ðŸ§¶"}
                          </Text>
                        </Animated.View>
                      )}
                      {[0, 1, 2, 3, 4].map((index) => (
                        <Animated.View
                          key={`heart_${index}`}
                          pointerEvents="none"
                          style={[
                            styles.tamagotchiHeartBurst,
                            {
                              opacity: tamagotchiHeartBurstAnim.interpolate({
                                inputRange: [0, 0.08 + index * 0.06, 0.45 + index * 0.04, 1],
                                outputRange: [0, 0, 1, 0],
                                extrapolate: "clamp",
                              }),
                              transform: [
                                {
                                  translateX: tamagotchiHeartBurstAnim.interpolate({
                                    inputRange: [0, 1],
                                    outputRange: [-14 + index * 7, -34 + index * 13],
                                  }),
                                },
                                {
                                  translateY: tamagotchiHeartBurstAnim.interpolate({
                                    inputRange: [0, 1],
                                    outputRange: [10 + index * 2, -68 - index * 6],
                                  }),
                                },
                                {
                                  scale: tamagotchiHeartBurstAnim.interpolate({
                                    inputRange: [0, 0.25, 1],
                                    outputRange: [0.6, 1.1, 0.82],
                                  }),
                                },
                              ],
                            },
                          ]}
                        >
                          <Text style={styles.tamagotchiHeartBurstText}>ðŸ’–</Text>
                        </Animated.View>
                      ))}
                      {tamagotchiActiveTab === "clean" && (
                        <>
                          <View pointerEvents="none" style={styles.tamagotchiCleanTapOverlay}>
                            <Text style={styles.tamagotchiCleanTapOverlayText}>
                              {tamagotchiCleanNeedEmoji}
                            </Text>
                          </View>
                          <View
                            pointerEvents="none"
                            style={[
                              styles.tamagotchiCleanSwipeBubble,
                              {
                                backgroundColor: colorWithAlpha(colors.card, isDarkTheme ? 0.95 : 0.97),
                                borderColor: colorWithAlpha(colors.border, isDarkTheme ? 0.95 : 0.9),
                              },
                            ]}
                          >
                            <Text
                              style={[styles.tamagotchiCleanSwipeBubbleText, { color: colors.text }]}
                            >
                              {t("tamagotchiCleanSwipeHint")}
                            </Text>
                          </View>
                        </>
                      )}
                      {tamagotchiHasHungerImmunity && (
                        <Pressable
                          style={styles.tamagotchiShieldOverlay}
                          onPress={showTamagotchiImmunityHint}
                          hitSlop={8}
                        >
                          <Text style={styles.tamagotchiShieldOverlayIcon}>ðŸ›¡ï¸</Text>
                        </Pressable>
                      )}
                    </View>
                    {tamagotchiImmunityHintVisible &&
                      tamagotchiHasHungerImmunity && (
                        <Animated.View
                          pointerEvents="none"
                          style={[
                            styles.tamagotchiImmunityHintBubble,
                            {
                              backgroundColor: tamagotchiImmunityHintPalette.backgroundColor,
                              borderColor: tamagotchiImmunityHintPalette.borderColor,
                              opacity: tamagotchiImmunityHintAnim.interpolate({
                                inputRange: [0, 0.35, 1],
                                outputRange: [0, 0.85, 1],
                              }),
                              transform: [
                                {
                                  translateY: tamagotchiImmunityHintAnim.interpolate({
                                    inputRange: [0, 1],
                                    outputRange: [12, 0],
                                  }),
                                },
                                {
                                  scale: tamagotchiImmunityHintAnim.interpolate({
                                    inputRange: [0, 1],
                                    outputRange: [0.92, 1],
                                  }),
                                },
                              ],
                            },
                          ]}
                        >
                          <Text
                            style={[
                              styles.immunityHintTitle,
                              { color: tamagotchiImmunityHintPalette.titleColor },
                            ]}
                          >
                            {t("tamagotchiImmunityHintTitle")}
                          </Text>
                          <Text
                            style={[
                              styles.immunityHintTimer,
                              { color: tamagotchiImmunityHintPalette.textColor },
                            ]}
                          >
                            {tamagotchiImmunityHintCountdownLabel}
                          </Text>
                        </Animated.View>
                      )}
                  </View>
                  {tamagotchiHasHungerImmunity && (
                    <View
                      style={[
                        styles.tamagotchiImmunityPill,
                        {
                          borderColor: colors.border,
                          backgroundColor: lightenColor(colors.card, isDarkTheme ? 0.08 : 0.2),
                        },
                      ]}
                    >
                      <Text style={styles.tamagotchiImmunityPillIcon}>ðŸ›¡ï¸</Text>
                      <Text style={[styles.tamagotchiImmunityPillText, { color: colors.text }]}>
                        {t("tamagotchiImmunityActiveLabel")}
                      </Text>
                    </View>
                  )}
                  <View
                    style={[
                      styles.tamagotchiStatsStack,
                      {
                        borderColor: colors.border,
                        backgroundColor: lightenColor(colors.card, isDarkTheme ? 0.05 : 0.1),
                      },
                    ]}
                  >
                    <View style={styles.tamagotchiStatRow}>
                      <Text style={[styles.tamagotchiStatLabel, { color: colors.muted }]}>
                        {t("tamagotchiFullnessLabel")}
                      </Text>
                      <Text style={[styles.tamagotchiStatValue, { color: colors.text }]}>
                        {Math.round(tamagotchiHungerPercent)}%
                      </Text>
                    </View>
                    <View style={[styles.tamagotchiProgress, { backgroundColor: colors.border }]}>
                      <View
                        style={[
                          styles.tamagotchiProgressFill,
                          {
                            backgroundColor: "#FFB664",
                            width: `${Math.max(8, Math.min(100, tamagotchiHungerPercent))}%`,
                          },
                        ]}
                      />
                    </View>
                    <View style={styles.tamagotchiStatRow}>
                      <Text style={[styles.tamagotchiStatLabel, { color: colors.muted }]}>
                        {t("tamagotchiMoodLabel")}
                      </Text>
                      <Text style={[styles.tamagotchiStatValue, { color: colors.text }]}>
                        {Math.round(tamagotchiMoodPercent)}%
                      </Text>
                    </View>
                    <View style={[styles.tamagotchiProgress, { backgroundColor: colors.border }]}>
                      <View
                        style={[
                          styles.tamagotchiProgressFill,
                          {
                            backgroundColor: "#FF7AA9",
                            width: `${Math.max(8, Math.min(100, tamagotchiMoodPercent))}%`,
                          },
                        ]}
                      />
                    </View>
                    <View style={styles.tamagotchiStatRow}>
                      <Text style={[styles.tamagotchiStatLabel, { color: colors.muted }]}>
                        {t("tamagotchiCleanlinessLabel")}
                      </Text>
                      <Text style={[styles.tamagotchiStatValue, { color: colors.text }]}>
                        {Math.round(tamagotchiCleanlinessPercent)}%
                      </Text>
                    </View>
                    <View style={[styles.tamagotchiProgress, { backgroundColor: colors.border }]}>
                      <View
                        style={[
                          styles.tamagotchiProgressFill,
                          {
                            backgroundColor: "#79C8FF",
                            width: `${Math.max(8, Math.min(100, tamagotchiCleanlinessPercent))}%`,
                          },
                        ]}
                      />
                    </View>
                  </View>
                  {tamagotchiState.lastFedAt ? (
                    <Text style={[styles.tamagotchiSub, { color: colors.muted }]}>
                      {t("tamagotchiFedAtLabel")}:{" "}
                      {new Date(tamagotchiState.lastFedAt).toLocaleString()}
                    </Text>
                  ) : (
                    <Text style={[styles.tamagotchiSub, { color: colors.muted }]}>
                      {t("tamagotchiAwaitingFirstCoin")}
                    </Text>
                  )}
                  <View style={styles.tamagotchiTabsRow}>
                    {tamagotchiTabItems.map((tab) => {
                      const active = tab.id === tamagotchiActiveTab;
                      const accent =
                        tab.id === "clean" ? "#6FCBFF" : tab.id === "games" ? "#F97AB2" : "#F6A553";
                      const activeTabBackground =
                        Platform.OS === "android"
                          ? blendColors(colors.card || "#FFFFFF", accent, isDarkTheme ? 0.28 : 0.22)
                          : colorWithAlpha(accent, isDarkTheme ? 0.24 : 0.2);
                      return (
                        <TouchableOpacity
                          key={tab.id}
                          style={[
                            styles.tamagotchiTabButton,
                            {
                              borderColor: active ? colorWithAlpha(accent, 0.9) : colors.border,
                              backgroundColor: active ? activeTabBackground : colors.card,
                              shadowColor: active && Platform.OS !== "android" ? accent : "transparent",
                            },
                          ]}
                          onPress={() => handleTamagotchiTabPress(tab.id)}
                          activeOpacity={0.9}
                        >
                          <Text
                            style={[
                              styles.tamagotchiTabButtonText,
                              { color: colors.text, opacity: active ? 1 : 0.76 },
                            ]}
                          >
                            {tab.label}
                          </Text>
                        </TouchableOpacity>
                      );
                    })}
                  </View>
                  <Text style={[styles.tamagotchiFoodTitle, { color: colors.text }]}>
                    {activeTamagotchiTabTitle}
                  </Text>
                  <Animated.View
                    style={[
                      styles.tamagotchiTabContentWrap,
                      {
                        opacity: tamagotchiTabContentAnim,
                        transform: [
                          {
                            translateY: tamagotchiTabContentAnim.interpolate({
                              inputRange: [0, 1],
                              outputRange: [12, 0],
                            }),
                          },
                        ],
                      },
                    ]}
                  >
                    {renderTamagotchiTabContent()}
                  </Animated.View>
                  <View style={[styles.tamagotchiActions, styles.tamagotchiActionsSingle]}>
                    <TouchableOpacity
                      style={[
                        styles.tamagotchiButton,
                        styles.tamagotchiPartyButton,
                        { backgroundColor: colors.card, borderColor: colors.border },
                      ]}
                      onPress={startParty}
                    >
                      <View style={styles.tamagotchiButtonContent}>
                        <Image source={HEALTH_COIN_TIERS[1].asset} style={styles.tamagotchiButtonIcon} />
                        <Text style={[styles.tamagotchiButtonText, { color: colors.text }]}>
                          {t("tamagotchiPartyButtonLabel", { cost: TAMAGOTCHI_PARTY_BLUE_COST })}
                        </Text>
                      </View>
                    </TouchableOpacity>
                  </View>
                  {tamagotchiIsFull && tamagotchiActiveTab === "food" && (
                    <Text style={[styles.tamagotchiHint, { color: colors.muted }]}>
                      {t("tamagotchiFullHint")}
                    </Text>
                  )}
                  </ScrollView>
              {partyActive && (
                <>
                  <ConfettiCannon
                    key={`party_confetti_${partyBurstKey}`}
                    count={180}
                    origin={{ x: SCREEN_WIDTH / 2, y: 0 }}
                    fadeOut
                    explosionSpeed={520}
                    fallSpeed={3600}
                  />
                  <Animated.View
                    pointerEvents="none"
                    style={[
                      styles.partyGlowOverlay,
                      {
                        opacity: partyGlow.interpolate({
                          inputRange: [0, 1],
                          outputRange: [0.1, 0.4],
                        }),
                        backgroundColor: isDarkTheme ? "rgba(110,155,255,0.6)" : "rgba(255,210,120,0.7)",
                      },
                    ]}
                  />
                </>
              )}
            </Animated.View>
	            <View pointerEvents="box-none" style={styles.tamagotchiGestureWrapper}>
	              <View
	                style={[
	                  styles.tamagotchiGestureEdge,
	                  { top: Math.max(84, (safeAreaInsets.top || topSafeInset || 0) + 34) },
	                ]}
	                {...tamagotchiCloseSwipeResponder.panHandlers}
	              />
	            </View>
          </View>
        </Modal>
        <Modal
          visible={skinPickerVisible}
          transparent
          animationType="fade"
          statusBarTranslucent
          onRequestClose={closeSkinPicker}
        >
          <TouchableWithoutFeedback onPress={closeSkinPicker}>
            <View style={styles.skinPickerBackdrop}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View
                  style={[
                    styles.skinPickerCard,
                    { backgroundColor: colors.card, borderColor: colors.border },
                  ]}
                >
                  <Text style={[styles.skinPickerTitle, { color: colors.text, textAlign: "center" }]}>
                    {t("tamagotchiSkinTitle")}
                  </Text>
                  <ScrollView
                    contentContainerStyle={styles.skinPickerList}
                    showsVerticalScrollIndicator={false}
                  >
                    {TAMAGOTCHI_SKIN_OPTIONS.map((skin) => {
                      const active = skin.id === tamagotchiSkinId;
                      const label = skin.label?.[language] || skin.label?.en || skin.id;
                      const description =
                        skin.description?.[language] || skin.description?.en || "";
                      return (
                        <TouchableOpacity
                          key={skin.id}
                          style={[
                            styles.skinPickerItem,
                            {
                              borderColor: active ? colors.text : colors.border,
                              backgroundColor: active
                                ? lightenColor(colors.card, isDarkTheme ? 0.1 : 0.2)
                                : "transparent",
                            },
                          ]}
                          onPress={() => handleSkinSelect(skin.id)}
                        >
                          <Image source={skin.preview} style={styles.skinPickerAvatar} />
                          <View style={{ flex: 1 }}>
                            <Text style={[styles.skinPickerItemTitle, { color: colors.text }]}>
                              {label}
                            </Text>
                            {!!description && (
                              <Text style={[styles.skinPickerItemSubtitle, { color: colors.muted }]}>
                                {description}
                              </Text>
                            )}
                          </View>
                          {active ? (
                            <View
                              style={[
                                styles.skinPickerBadge,
                                { borderColor: colors.border, backgroundColor: colors.background },
                              ]}
                            >
                              <Text style={[styles.skinPickerBadgeText, { color: colors.text }]}>
                                {t("tamagotchiSkinCurrent")}
                              </Text>
                            </View>
                          ) : null}
                        </TouchableOpacity>
                      );
                    })}
                  </ScrollView>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>
        <Modal
          visible={proThemeAccentPickerVisible}
          transparent
          animationType="fade"
          statusBarTranslucent
          onRequestClose={closeProThemeAccentPicker}
        >
          <TouchableWithoutFeedback onPress={closeProThemeAccentPicker}>
            <View style={styles.proAccentBackdrop}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View
                  style={[
                    styles.proAccentCard,
                    { backgroundColor: colors.card, borderColor: colors.border },
                  ]}
                >
                  <Text style={[styles.proAccentTitle, { color: colors.text }]}>
                    {proThemeAccentCopy.title}
                  </Text>
                  <Text style={[styles.proAccentSubtitle, { color: colors.muted }]}>
                    {proThemeAccentCopy.subtitle}
                  </Text>

                  <View
                    style={[
                      styles.proAccentHero,
                      {
                        borderColor: colorWithAlpha(proThemeAccentColor, 0.4),
                        backgroundColor: blendHexColors("#0A1E72", proThemeAccentColor, 0.24),
                      },
                    ]}
                  >
                    <View
                      pointerEvents="none"
                      style={[
                        styles.proAccentHeroOrbPrimary,
                        { backgroundColor: colorWithAlpha(proThemeAccentColor, 0.5) },
                      ]}
                    />
                    <View
                      pointerEvents="none"
                      style={[
                        styles.proAccentHeroOrbSecondary,
                        { backgroundColor: colorWithAlpha(proThemeAccentColor, 0.3) },
                      ]}
                    />
                    <View
                      style={[
                        styles.proAccentHeroBadge,
                        { backgroundColor: colorWithAlpha(proThemeAccentColor, 0.8) },
                      ]}
                    >
                      <Text style={styles.proAccentHeroBadgeText}>ALMOST PRO</Text>
                    </View>
                    <Text style={styles.proAccentHeroText}>ðŸª½ðŸ’¸</Text>
                  </View>

                  <View style={styles.proAccentGrid}>
                    {PRO_THEME_ACCENT_OPTIONS.map((option) => {
                      const active = proThemeAccentId === option.id;
                      const optionLabel = resolveProAccentLabel(option, language);
                      return (
                        <TouchableOpacity
                          key={option.id}
                          style={[
                            styles.proAccentOption,
                            {
                              borderColor: active ? option.accent : colors.border,
                              backgroundColor: active
                                ? colorWithAlpha(option.accent, 0.14)
                                : "transparent",
                            },
                          ]}
                          activeOpacity={0.9}
                          onPress={() => handleProThemeAccentSelect(option.id, { close: false })}
                        >
                          <View style={styles.proAccentOptionTopRow}>
                            <View
                              style={[styles.proAccentSwatch, { backgroundColor: option.accent }]}
                            />
                            <Text style={[styles.proAccentOptionLabel, { color: colors.text }]}>
                              {`${option.emoji} ${optionLabel}`}
                            </Text>
                          </View>
                          <View style={[styles.proAccentMiniPreview, { borderColor: colorWithAlpha(option.accent, 0.35) }]}>
                            <View
                              style={[
                                styles.proAccentMiniPreviewPill,
                                { backgroundColor: option.accent },
                              ]}
                            />
                            <View style={styles.proAccentMiniPreviewBars}>
                              <View
                                style={[
                                  styles.proAccentMiniPreviewBar,
                                  { backgroundColor: colorWithAlpha(option.accent, 0.22), width: "78%" },
                                ]}
                              />
                              <View
                                style={[
                                  styles.proAccentMiniPreviewBar,
                                  { backgroundColor: colorWithAlpha(option.accent, 0.14), width: "58%" },
                                ]}
                              />
                            </View>
                          </View>
                          {active ? (
                            <Text style={[styles.proAccentOptionSelected, { color: option.accent }]}>
                              {proThemeAccentCopy.selected}
                            </Text>
                          ) : null}
                        </TouchableOpacity>
                      );
                    })}
                  </View>

                  <TouchableOpacity
                    style={[
                      styles.proAccentDoneButton,
                      { backgroundColor: proThemeAccentColor, shadowColor: proThemeAccentColor },
                    ]}
                    onPress={closeProThemeAccentPicker}
                    activeOpacity={0.9}
                  >
                    <Text style={styles.proAccentDoneButtonText}>{t("profileOk") || "OK"}</Text>
                  </TouchableOpacity>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>

        {editOverlayVisible && (
          <TouchableWithoutFeedback onPress={closePriceEditor}>
            <View
              style={[styles.temptationEditOverlay, modalKeyboardPaddingStyle]}
              pointerEvents="box-none"
            >
              <Animated.View
                style={[
                  styles.temptationEditBackdrop,
                  {
                    opacity: editOverlayAnim.interpolate({
                      inputRange: [0, 1],
                      outputRange: [0, 0.6],
                    }),
                  },
                ]}
              />
              {priceEditor.item && (
                <TouchableWithoutFeedback onPress={() => {}}>
                  <Animated.View
                    style={[
                      styles.temptationEditSheetContainer,
                      {
                        opacity: editOverlayAnim,
                        transform: [
                          {
                            translateY: editOverlayAnim.interpolate({
                              inputRange: [0, 1],
                              outputRange: [30, 0],
                            }),
                          },
                          {
                            scale: editOverlayAnim.interpolate({
                              inputRange: [0, 1],
                              outputRange: [0.96, 1],
                            }),
                          },
                        ],
                      },
                    ]}
                  >
                    <TemptationEditSheet
                      item={priceEditor.item}
                      language={language}
                      colors={colors}
                      t={t}
                      currency={profile.currency || DEFAULT_PROFILE.currency}
                      titleOverride={titleOverrides[priceEditor.item.id]}
                      editTitleValue={priceEditor.title}
                      editPriceValue={priceEditor.value}
                      editGoalLabel={priceEditorAssignedGoalTitle || ""}
                      editEmojiValue={priceEditor.emoji}
                      editDescriptionValue={priceEditor.description || ""}
                      editCategoryValue={priceEditor.category}
                      editFrequencyValue={priceEditor.frequency}
                      editFrequencyCustomValue={priceEditor.frequencyCustom}
                      onEditTitleChange={handlePriceTitleChange}
                      onEditPriceChange={handlePriceInputChange}
                      onEditEmojiChange={handlePriceEmojiChange}
                      onEditDescriptionChange={handlePriceDescriptionChange}
                      onEditCategoryChange={handlePriceCategoryChange}
                      onEditFrequencyChange={handlePriceFrequencyChange}
                      onEditFrequencyCustomChange={handlePriceCustomFrequencyChange}
                      onEditSave={savePriceEdit}
                      onEditCancel={closePriceEditor}
                      onEditDelete={() => promptTemptationDelete(priceEditor.item)}
                      onEditGoalSelect={() => {
                        setGoalLinkPrompt({
                          visible: true,
                          item: priceEditor.item,
                          intent: "edit",
                          amountUSD: null,
                        });
                      }}
                    />
                  </Animated.View>
                </TouchableWithoutFeedback>
              )}
            </View>
          </TouchableWithoutFeedback>
        )}

        {moodDetailsVisible && moodPreset && (
          <Modal
            visible
            transparent
            animationType="fade"
            onRequestClose={closeMoodDetails}
            statusBarTranslucent
          >
            <TouchableWithoutFeedback onPress={closeMoodDetails}>
              <View style={styles.moodDetailsBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <MoodGradientBlock colors={moodGradient} style={styles.moodDetailsCard}>
                    <Text style={[styles.moodDetailsLabel, { color: colors.text }]}>
                      {moodPreset.label}
                    </Text>
                    {moodDescription ? (
                      <Text style={[styles.moodDetailsDescription, { color: colors.text }]}>
                        {moodDescription}
                      </Text>
                    ) : null}
                    <TouchableOpacity
                      style={[styles.moodDetailsButton, { borderColor: colors.text }]}
                      onPress={closeMoodDetails}
                    >
                      <Text style={[styles.moodDetailsButtonText, { color: colors.text }]}>
                        {t("profileOk") || "ÐžÐº"}
                      </Text>
                    </TouchableOpacity>
                  </MoodGradientBlock>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}

        {baselinePrompt.visible && (
          <Modal
            visible
            transparent
            animationType="fade"
            onRequestClose={closeBaselinePrompt}
            statusBarTranslucent
          >
            <TouchableWithoutFeedback onPress={closeBaselinePrompt}>
              <View style={styles.baselinePromptBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.baselinePromptCard,
                      {
                        backgroundColor: colors.card,
                        borderColor: colors.border,
                      },
                    ]}
                  >
                    <Text style={[styles.baselinePromptTitle, { color: colors.text }]}>
                      {t("baselineTitle")}
                    </Text>
                    <Text style={[styles.baselinePromptSubtitle, { color: colors.muted }]}>
                      {t("baselineSubtitle")}
                    </Text>
                    <View style={styles.baselineInputGroup}>
                      <TextInput
                        style={[
                          styles.primaryInput,
                          {
                            borderColor: colors.border,
                            backgroundColor: colors.background,
                            color: colors.text,
                          },
                        ]}
                        value={baselinePrompt.value}
                        onChangeText={handleBaselinePromptChange}
                        placeholder={t("baselinePlaceholder", {
                          amount: formatSampleAmount(
                            BASELINE_SAMPLE_USD,
                            baselinePrompt.currency ||
                              profile.currency ||
                              DEFAULT_PROFILE.currency
                          ),
                        })}
                        placeholderTextColor={colorWithAlpha(colors.muted, 0.6)}
                        keyboardType={Platform.OS === "ios" ? "numbers-and-punctuation" : "decimal-pad"}
                        returnKeyType="done"
                        onSubmitEditing={handleBaselinePromptSubmit}
                      />
                    </View>
                    <Text style={[styles.baselineHint, { color: colors.muted }]}>
                      {t("baselineHint")}
                    </Text>
                    <TouchableOpacity
                      style={[styles.primaryButton, { backgroundColor: colors.text }]}
                      onPress={handleBaselinePromptSubmit}
                    >
                      <Text style={[styles.primaryButtonText, { color: colors.background }]}>
                        {t("baselineCTA")}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity style={styles.baselinePromptDismiss} onPress={closeBaselinePrompt}>
                      <Text style={[styles.baselinePromptDismissText, { color: colors.muted }]}>
                        {t("profileCancel")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}

        {potentialDetailsVisible && (
          <Modal
            visible
            transparent
            animationType="fade"
            onRequestClose={closePotentialDetails}
            statusBarTranslucent
          >
            <TouchableWithoutFeedback onPress={closePotentialDetails}>
              <View style={styles.moodDetailsBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.moodDetailsCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <Text style={[styles.moodDetailsLabel, { color: colors.text }]}>
                      {t("potentialBlockTitle")}
                    </Text>
                    <Text style={[styles.moodDetailsDescription, { color: colors.muted }]}>
                      {potentialDetailsText}
                    </Text>
                    <TouchableOpacity
                      style={[styles.moodDetailsButton, { borderColor: colors.text }]}
                      onPress={closePotentialDetails}
                    >
                      <Text style={[styles.moodDetailsButtonText, { color: colors.text }]}>
                        {t("profileOk") || "ÐžÐº"}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}

        {activeTab !== "profile" && fabMenuVisible && (
          <View pointerEvents="box-none" style={styles.fabMenuOverlay}>
            <TouchableWithoutFeedback onPress={closeFabMenu}>
              <View style={styles.fabMenuBackdrop} />
            </TouchableWithoutFeedback>
            <Animated.View
              style={[
                styles.fabOption,
                styles.fabOptionRow,
                {
                  opacity: fabMenuAnim,
                  transform: [
                    {
                      translateY: fabMenuAnim.interpolate({
                        inputRange: [0, 1],
                        outputRange: [20, 0],
                      }),
                    },
                    { scale: fabMenuAnim },
                  ],
                },
              ]}
            >
              <View style={styles.fabOptionRowContent}>
                <TouchableOpacity
                  style={[styles.fabCircle, { backgroundColor: colors.card, borderColor: colors.border }]}
                  onPress={handleFabNewGoal}
                >
                  <Text style={[styles.fabOptionText, { color: colors.text }]} numberOfLines={2}>
                    {t("fabNewGoal")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.fabCircle, { backgroundColor: colors.card, borderColor: colors.border }]}
                  onPress={handleFabNewTemptation}
                >
                  <Text style={[styles.fabOptionText, { color: colors.text }]} numberOfLines={2}>
                    {t("fabNewTemptation")}
                  </Text>
                </TouchableOpacity>
              </View>
            </Animated.View>
          </View>
        )}

        {overlay &&
          overlay.type !== "level" &&
          overlay.type !== "save" &&
          overlay.type !== "custom_temptation" &&
          overlay.type !== "primary_temptation" &&
          overlay.type !== "reward" &&
          overlay.type !== "daily_reward" &&
          overlay.type !== "health" &&
          overlay.type !== "usage_streak" &&
          overlay.type !== "usage_streak_restore" &&
          overlay.type !== "streak_pledge" &&
          overlay.type !== "streak_pledge_reward" &&
          overlay.type !== "premium_unlock" &&
          overlay.type !== "focus_reward" &&
          overlay.type !== "goal_complete" &&
          overlay.type !== "impulse_alert" &&
          overlay.type !== "focus_digest" &&
          !isFeatureUnlockOverlay && (
            <Modal visible transparent animationType="fade" statusBarTranslucent>
              <TouchableWithoutFeedback onPress={dismissOverlay}>
                <View style={styles.confettiLayer}>
                  <View
                    style={[
                      styles.overlayDim,
                      { backgroundColor: overlayDimColor },
                    ]}
                  />
                  {overlay.type === "cancel" && <RainOverlay colors={colors} />}
                  {overlay.type === "purchase" && (
                    <ConfettiCannon
                      key={confettiKey}
                      count={90}
                      origin={{ x: SCREEN_WIDTH / 2, y: 0 }}
                      fadeOut
                      explosionSpeed={350}
                      fallSpeed={2600}
                    />
                  )}
                  <View
                    style={[
                      styles.celebrationBanner,
                      {
                        backgroundColor: overlayCardBackground,
                        borderColor: overlayBorderColor,
                        borderWidth: overlay.type === "cart" ? 0 : 1,
                      },
                    ]}
                  >
                    {(overlay.type === "cancel" ||
                      overlay.type === "purchase" ||
                      overlay.type === "completion") && (
                      <Image
                        source={
                          overlay.type === "cancel"
                            ? tamagotchiAnimations.sad
                            : tamagotchiAnimations.happy
                        }
                        style={[
                          styles.celebrationCat,
                          overlay.type === "purchase" || overlay.type === "completion"
                            ? styles.catHappy
                            : styles.catSad,
                        ]}
                      />
                    )}
                    <Text style={[styles.celebrationText, { color: colors.text }]}>
                      {overlay.message}
                    </Text>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </Modal>
        )}
        {overlay?.type === "focus_digest" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <View style={styles.overlayFullScreen}>
              <View
                style={[
                  styles.overlayDim,
                  { backgroundColor: overlayDimColor },
                ]}
              />
              <TouchableWithoutFeedback onPress={() => {}}>
                <View
                  style={[
                    styles.focusDigestCard,
                    { backgroundColor: colors.card, borderColor: colors.border },
                  ]}
                >
                  <Text style={[styles.focusDigestTitle, { color: colors.text }]}>
                    {overlay.message?.title || ""}
                  </Text>
                  <Text style={[styles.focusDigestBody, { color: colors.muted }]}>
                    {overlay.message?.body || ""}
                  </Text>
                  <View style={styles.focusDigestStats}>
                    <View
                      style={[
                        styles.focusDigestStat,
                        {
                          borderColor: colors.border,
                          backgroundColor: lightenColor(colors.card, isDarkTheme ? 0.08 : 0.2),
                        },
                      ]}
                    >
                      <Text style={[styles.focusDigestLabel, { color: colors.muted }]}>
                        {t("focusDigestStrongLabel")}
                      </Text>
                      <Text style={[styles.focusDigestValue, { color: colors.text }]}>
                        {keepEmojiWithText(overlay.message?.strong?.title || t("focusDigestMissing"))}
                      </Text>
                      {overlay.message?.strong?.window && (
                        <Text style={[styles.focusDigestHint, { color: colors.muted }]}>
                          {overlay.message.strong.window}
                        </Text>
                      )}
                    </View>
                    <View
                      style={[
                        styles.focusDigestStat,
                        {
                          borderColor: colors.border,
                          backgroundColor: lightenColor(colors.card, isDarkTheme ? 0.04 : 0.12),
                        },
                      ]}
                    >
                      <Text style={[styles.focusDigestLabel, { color: colors.muted }]}>
                        {t("focusDigestWeakLabel")}
                      </Text>
                      <Text style={[styles.focusDigestValue, { color: colors.text }]}>
                        {keepEmojiWithText(overlay.message?.weak?.title || t("focusDigestMissing"))}
                      </Text>
                      {overlay.message?.weak?.window && (
                        <Text style={[styles.focusDigestHint, { color: colors.muted }]}>
                          {overlay.message.weak.window}
                        </Text>
                      )}
                    </View>
                  </View>
                  <View style={styles.focusDigestButtons}>
                    <TouchableOpacity
                      style={[styles.focusDigestSecondary, { borderColor: colors.border }]}
                      onPress={handleFocusOverlayLater}
                    >
                      <Text style={[styles.focusDigestSecondaryText, { color: colors.muted }]}>
                        {t("focusDigestDismiss")}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[
                        styles.focusDigestPrimary,
                        {
                          backgroundColor: overlay.message?.targetId ? colors.text : colors.border,
                        },
                      ]}
                      disabled={!overlay.message?.targetId}
                      onPress={() =>
                        handleFocusOverlayConfirm(
                          overlay.message?.targetId,
                          overlay.message?.positive ? "digest_positive" : "digest_negative"
                        )
                      }
                    >
                      <Text
                        style={[
                          styles.focusDigestPrimaryText,
                          { color: overlay.message?.targetId ? colors.background : colors.muted },
                        ]}
                      >
                        {t("focusDigestButton")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </Modal>
        )}
        {isFeatureUnlockOverlay && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <View style={styles.overlayFullScreen}>
              <View
                style={[
                  styles.overlayDim,
                  { backgroundColor: overlayDimColor },
                ]}
              />
              <TouchableWithoutFeedback onPress={dismissOverlay}>
                <View style={styles.overlayTouchable} />
              </TouchableWithoutFeedback>
              <View style={styles.featureUnlockWrapper} pointerEvents="box-none">
                <FeatureUnlockCelebration
                  colors={colors}
                  payload={overlay.message}
                  t={t}
                  tamagotchiAnimations={tamagotchiAnimations}
                  onDismiss={dismissOverlay}
                />
              </View>
            </View>
          </Modal>
        )}
        {overlay?.type === "level" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <View style={styles.overlayFullScreen}>
              <TouchableWithoutFeedback onPress={dismissOverlay}>
                <View style={styles.overlayTouchable} />
              </TouchableWithoutFeedback>
              <LevelUpCelebration
                colors={colors}
                message={overlay.message}
                level={overlay.message}
                t={t}
                onSharePress={handleLevelSharePress}
              />
            </View>
          </Modal>
        )}
        {overlay?.type === "save" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={handleSaveOverlayPress}>
              <View style={styles.saveOverlay}>
                <View
                  style={[
                    styles.overlayDim,
                    { backgroundColor: overlayDimColor },
                  ]}
                />
                <CoinRainOverlay dropCount={16} />
                <SaveCelebration
                  ref={saveCelebrationRef}
                  colors={colors}
                  t={t}
                  language={language}
                  payload={saveOverlayPayload}
                  goalCopy={saveOverlayGoalText}
                  goalPrefix={saveOverlayGoalPrefix}
                  coinReward={saveOverlayPayload?.coinReward}
                  onPrimaryAction={handleSaveOverlayPress}
                  onCountdownAction={handleSaveOverlayPress}
                  playSound={playSound}
                  mascotHappySource={tamagotchiAnimations.happy}
                  autoCountdown={false}
                  progressStart={
                    Number.isFinite(saveOverlayPayload?.progressStart)
                      ? saveOverlayPayload.progressStart
                      : heroGoalProgressRatio
                  }
                  progressEnd={
                    Number.isFinite(saveOverlayPayload?.progressEnd)
                      ? saveOverlayPayload.progressEnd
                      : heroGoalProgressRatio
                  }
                  remainingActions={
                    Number.isFinite(saveOverlayPayload?.remainingTemptations)
                      ? saveOverlayPayload.remainingTemptations
                      : remainingGoalActions
                  }
                />
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "custom_temptation" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.saveOverlay}>
                <View
                  style={[
                    styles.overlayDim,
                    { backgroundColor: overlayDimColor },
                  ]}
                />
                <View
                  style={[
                    styles.customTemptationCard,
                    { backgroundColor: overlayCardBackground, borderColor: overlayBorderColor },
                  ]}
                >
                  <Image source={tamagotchiAnimations.follow} style={styles.customTemptationGif} />
                  <Text style={[styles.customTemptationText, { color: colors.text }]}>
                    {t("customTemptationAdded", { title: overlay.message || "" })}
                  </Text>
                </View>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "primary_temptation" && primaryTemptationOverlayItem && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <View
                  style={[
                    styles.overlayDim,
                    { backgroundColor: overlayDimColor },
                  ]}
                />
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.primaryTemptationOverlayCardContainer,
                      { backgroundColor: colors.background, borderColor: overlayBorderColor },
                    ]}
                  >
                    <Text style={[styles.primaryTemptationOverlayTitle, { color: colors.text }]}>
                      {t("customSpendTitle")}
                    </Text>
                    <TemptationCard
                      item={primaryTemptationOverlayItem}
                      language={language}
                      colors={colors}
                      t={t}
                      allowThinkAction={thinkingUnlocked}
                      currency={profile.currency || DEFAULT_PROFILE.currency}
                      stats={primaryTemptationOverlayStats}
                      feedback={primaryTemptationOverlayItem ? cardFeedback[primaryTemptationOverlayItem.id] : null}
                      titleOverride={primaryTemptationOverlayTitle}
                      descriptionOverride={primaryTemptationOverlayDescription}
                      goalLabel={primaryTemptationOverlayGoalLabel}
                      isPrimaryTemptation={primaryTemptationOverlayItem.id === primaryTemptationId}
                      onAction={(type, item, actionOptions) =>
                        handlePrimaryTemptationOverlayAction(type, item, actionOptions)
                      }
                      playSound={playSound}
                      onToggleEdit={null}
                      cardStyle={styles.primaryTemptationCard}
                    />
                    <TouchableOpacity
                      style={[styles.primaryTemptationDismiss, { borderColor: colors.border }]}
                      onPress={dismissOverlay}
                    >
                      <Text style={[styles.primaryTemptationDismissText, { color: colors.muted }]}>
                        {t("profileCancel")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "reward" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <RewardCelebration
                  colors={colors}
                  message={overlay.message}
                  t={t}
                  mascotHappySource={tamagotchiAnimations.happy}
                />
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "daily_reward" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <DailyRewardCelebration
                  colors={colors}
                  payload={overlay.message}
                  t={t}
                />
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "usage_streak" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <UsageStreakCelebration
                  colors={colors}
                  payload={overlay.message}
                  t={t}
                  language={language}
                  mascotHappySource={tamagotchiAnimations.happy}
                />
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "usage_streak_weekly_reward" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <UsageStreakWeeklyRewardCelebration
                  colors={colors}
                  payload={overlay.message}
                  t={t}
                  language={language}
                  mascotHappySource={tamagotchiAnimations.happy}
                  onClose={dismissOverlay}
                />
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "usage_streak_restore" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <UsageStreakRestorePrompt
                  colors={colors}
                  payload={overlay.message}
                  t={t}
                  language={language}
                  healthPoints={healthPoints}
                  onRestore={handleUsageStreakRestore}
                />
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "streak_pledge_reward" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <StreakPledgeRewardCelebration
                  colors={colors}
                  payload={overlay.message}
                  t={t}
                  language={language}
                  onClose={dismissOverlay}
                />
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "premium_unlock" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <PremiumUnlockCelebration
              payload={overlay.message}
              playSound={playSound}
              onClose={dismissOverlay}
            />
          </Modal>
        )}
        {overlay?.type === "streak_pledge" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={handleStreakPledgeDismiss}>
              <View style={styles.overlayFullScreen}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <StreakPledgePrompt
                    colors={colors}
                    payload={overlay.message}
                    t={t}
                    language={language}
                    options={STREAK_PLEDGE_OPTIONS}
                    mascotHappySource={tamagotchiAnimations.happy}
                    onConfirm={handleStreakPledgeConfirm}
                    onDismiss={handleStreakPledgeDismiss}
                  />
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "focus_reward" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.focusRewardCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <View style={styles.focusRewardIconRow}>
                      <Image source={HEALTH_COIN_TIERS[0].asset} style={styles.focusRewardCoin} />
                      <Text style={[styles.focusRewardAmount, { color: colors.text }]}>
                        +{overlay.message?.amount || FOCUS_VICTORY_REWARD}
                      </Text>
                    </View>
                    <Text style={[styles.focusRewardTitle, { color: colors.text }]}>
                      {overlay.message?.title || t("focusRewardTitle")}
                    </Text>
                    <Text style={[styles.focusRewardBody, { color: colors.muted }]}>
                      {overlay.message?.body || ""}
                    </Text>
                    <TouchableOpacity
                      style={[styles.focusRewardButton, { borderColor: colors.text }]}
                      onPress={dismissOverlay}
                    >
                      <Text style={[styles.focusRewardButtonText, { color: colors.text }]}>
                        {t("profileOk") || "ÐžÐº"}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "health" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <HealthCelebration colors={colors} payload={overlay.message} t={t} language={language} />
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "goal_complete" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <View style={styles.overlayFullScreen}>
              <Pressable style={StyleSheet.absoluteFillObject} onPress={dismissOverlay} />
              <View style={styles.overlayFullScreen} pointerEvents="box-none">
                <GoalCelebration
                  colors={colors}
                  payload={overlay.message}
                  t={t}
                  mascotHappySource={tamagotchiAnimations.happy}
                  onClose={dismissOverlay}
                />
              </View>
            </View>
          </Modal>
        )}
        {overlay?.type === "impulse_alert" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <View
                  style={[
                    styles.overlayDim,
                    { backgroundColor: overlayDimColor },
                  ]}
                />
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.impulseAlertCard,
                      { backgroundColor: overlayCardBackground, borderColor: overlayBorderColor },
                    ]}
                  >
                    <View
                      style={[
                        styles.impulseAlertGlow,
                        { backgroundColor: isDarkTheme ? "#FFC857" : "#FF8F5A" },
                      ]}
                    />
                    <View style={styles.impulseAlertContent}>
                      <View style={styles.impulseAlertHeader}>
                        <View
                          style={[
                            styles.impulseAlertBadge,
                            { backgroundColor: colors.background, borderColor: colors.border },
                          ]}
                        >
                          <Text style={[styles.impulseAlertBadgeText, { color: colors.muted }]}>
                            {t("impulseAlertBadgeLabel")}
                          </Text>
                        </View>
                        <Text style={styles.impulseAlertEmoji}>âš¡ï¸</Text>
                      </View>
                      <Text style={[styles.impulseAlertTitle, { color: colors.text }]}>
                        {impulseAlertPayload?.title || t("impulseAlertTitle")}
                      </Text>
                      <Text style={[styles.impulseAlertBody, { color: colors.muted }]}>
                        {impulseAlertPayload?.body || ""}
                      </Text>
                      {(impulseAlertPayload?.window || impulseAlertPayload?.amountLabel) && (
                        <View style={styles.impulseAlertStats}>
                          {impulseAlertPayload?.window ? (
                            <View style={styles.impulseAlertStat}>
                              <Text style={[styles.impulseAlertStatLabel, { color: colors.muted }]}>
                                {t("impulseAlertWindowLabel")}
                              </Text>
                              <Text style={[styles.impulseAlertStatValue, { color: colors.text }]}>
                                {impulseAlertPayload.window}
                              </Text>
                            </View>
                          ) : null}
                          {impulseAlertPayload?.amountLabel ? (
                            <View style={styles.impulseAlertStat}>
                              <Text style={[styles.impulseAlertStatLabel, { color: colors.muted }]}>
                                {t("impulseAlertAmountLabel")}
                              </Text>
                              <Text style={[styles.impulseAlertStatValue, { color: colors.text }]}>
                                {impulseAlertPayload.amountLabel}
                              </Text>
                            </View>
                          ) : null}
                        </View>
                      )}
                      {impulseAlertPayload?.moodLine ? (
                        <View
                          style={[
                            styles.impulseAlertMoodCard,
                            {
                              backgroundColor: isDarkTheme
                                ? "rgba(255,255,255,0.08)"
                                : "rgba(17,17,17,0.04)",
                              borderColor: isDarkTheme ? "rgba(255,255,255,0.12)" : "rgba(0,0,0,0.05)",
                            },
                          ]}
                        >
                          <Text style={[styles.impulseAlertMood, { color: colors.text }]}>
                            {impulseAlertPayload.moodLine}
                          </Text>
                        </View>
                      ) : null}
                      <TouchableOpacity
                        style={[styles.impulseAlertButton, { backgroundColor: colors.text }]}
                        onPress={dismissOverlay}
                        activeOpacity={0.9}
                      >
                        <Text style={[styles.impulseAlertButtonText, { color: colors.background }]}>
                          {t("impulseAlertButtonLabel")}
                        </Text>
                        <Text style={[styles.impulseAlertButtonIcon, { color: colors.background }]}>
                          â†’
                        </Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        <PremiumPaywallModal
          visible={premiumPaywallState.visible}
          copy={premiumCopy}
          planCards={premiumPlanCards}
          purchaseLoadingPlan={premiumPurchaseLoadingPlan}
          restoring={premiumRestoreLoading}
          onPlanSelect={handlePremiumPlanSelected}
          onPlanPress={handlePremiumPlanPress}
          onRestorePress={handlePremiumRestore}
          onManagePress={handleManageSubscriptionsOpen}
          onTermsPress={handleTermsLinkOpen}
          onPrivacyPress={handlePrivacyPolicyOpen}
          onClose={closePremiumPaywall}
          colors={colors}
        />

        <Modal
          visible={goalLinkPrompt.visible}
          transparent
          animationType="fade"
          statusBarTranslucent
        >
          <TouchableWithoutFeedback onPress={closeGoalLinkPrompt}>
            <View style={[styles.priceModalBackdrop, modalKeyboardPaddingStyle]}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View style={[styles.goalModalCard, { backgroundColor: colors.card }] }>
                  <Text style={[styles.goalModalTitle, { color: colors.text }]}>
                    {t("goalAssignPromptTitle")}
                  </Text>
                  {goalLinkPrompt.item && (
                    <Text style={[styles.goalModalSubtitle, { color: colors.muted }]}>
                      {t("goalAssignPromptSubtitle", {
                        title: resolveTemptationTitle(
                          goalLinkPrompt.item,
                          language,
                          titleOverrides[goalLinkPrompt.item.id]
                        ),
                      })}
                    </Text>
                  )}
                  <ScrollView style={{ maxHeight: 360 }}>
                    {goalSelectionList.map((goal) => {
                      const active = goalLinkCurrentGoalId === goal.id;
                      const currentLocal = formatCurrency(
                        convertToCurrency(goal.savedUSD || 0, profile.currency || DEFAULT_PROFILE.currency),
                        profile.currency || DEFAULT_PROFILE.currency
                      );
                      const targetLocal = formatCurrency(
                        convertToCurrency(goal.targetUSD || 0, profile.currency || DEFAULT_PROFILE.currency),
                        profile.currency || DEFAULT_PROFILE.currency
                      );
                      return (
                        <TouchableOpacity
                          key={goal.id}
                          style={[
                            styles.goalOptionButton,
                            {
                              borderColor: colors.border,
                              backgroundColor: active ? colors.text : "transparent",
                            },
                          ]}
                          onPress={() => handleGoalLinkSelect(goal.id)}
                        >
                          <Text
                            style={[
                              styles.goalOptionTitle,
                              { color: active ? colors.background : colors.text },
                            ]}
                          >
                            {goal.title}
                          </Text>
                          <Text
                            style={[
                              styles.goalOptionSubtitle,
                              { color: active ? colors.background : colors.muted },
                            ]}
                          >
                            {t("wishlistProgress", { current: currentLocal, target: targetLocal })}
                          </Text>
                        </TouchableOpacity>
                      );
                    })}
                  </ScrollView>
                  {goalLinkPrompt.intent !== "save" && goalLinkPrompt.item && (
                    <TouchableOpacity
                      style={styles.goalPickerReset}
                      onPress={() => {
                        const templateId = resolveTemptationTemplateId(goalLinkPrompt.item);
                        assignTemptationGoal(templateId || goalLinkPrompt.item.id, null);
                        closeGoalLinkPrompt();
                      }}
                    >
                      <Text style={[styles.goalPickerResetText, { color: colors.muted }]}>
                        {t("goalAssignClear")}
                      </Text>
                    </TouchableOpacity>
                  )}
                  <TouchableOpacity onPress={closeGoalLinkPrompt}>
                    <Text style={[styles.priceModalCancel, { color: colors.muted }]}>
                      {t("priceEditCancel")}
                    </Text>
                  </TouchableOpacity>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>

        <Modal
          visible={goalTemptationPrompt.visible}
          transparent
          animationType="fade"
          statusBarTranslucent
        >
          <TouchableWithoutFeedback onPress={closeGoalTemptationPrompt}>
            <View style={[styles.priceModalBackdrop, modalKeyboardPaddingStyle]}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View style={[styles.goalModalCard, { backgroundColor: colors.card }] }>
                  <Text style={[styles.goalModalTitle, { color: colors.text }]}>
                    {t("goalAssignTemptationTitle")}
                  </Text>
                  <Text style={[styles.goalModalSubtitle, { color: colors.muted }]}>
                    {t("goalAssignTemptationSubtitle", {
                      goal: goalTemptationPrompt.wish?.title || "",
                    })}
                  </Text>
                  <ScrollView style={{ maxHeight: 360 }}>
                    {temptations.map((template) => {
                      const templateTitle = resolveTemptationTitle(
                        template,
                        language,
                        titleOverrides[template.id]
                      );
                      const assignedGoalId = temptationGoalMap[template.id];
                      const isActive =
                        assignedGoalId && goalTemptationPrompt.wish
                          ? assignedGoalId === goalTemptationPrompt.wish.id
                          : false;
                      const assignedLabel = assignedGoalId
                        ? getWishTitleById(assignedGoalId)
                        : t("goalAssignNone");
                      return (
                        <TouchableOpacity
                          key={template.id}
                          style={[
                            styles.goalOptionButton,
                            {
                              borderColor: colors.border,
                              backgroundColor: isActive ? colors.text : "transparent",
                            },
                          ]}
                          onPress={() => handleGoalTemptationAssign(template.id)}
                        >
                          <Text
                            style={[
                              styles.goalOptionTitle,
                              { color: isActive ? colors.background : colors.text },
                            ]}
                          >
                            {templateTitle}
                          </Text>
                          <Text
                            style={[
                              styles.goalOptionSubtitle,
                              { color: isActive ? colors.background : colors.muted },
                            ]}
                          >
                            {assignedLabel}
                          </Text>
                        </TouchableOpacity>
                      );
                    })}
                  </ScrollView>
                  <TouchableOpacity onPress={closeGoalTemptationPrompt}>
                    <Text style={[styles.priceModalCancel, { color: colors.muted }]}>
                      {t("priceEditCancel")}
                    </Text>
                  </TouchableOpacity>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>

        <Modal
          visible={goalEditorPrompt.visible}
          transparent
          animationType="fade"
          statusBarTranslucent
        >
          <TouchableWithoutFeedback onPress={closeGoalEditorPrompt}>
            <View style={[styles.priceModalBackdrop, modalKeyboardPaddingStyle]}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View style={[styles.priceModalCard, { backgroundColor: colors.card }] }>
                  <Text style={[styles.priceModalTitle, { color: colors.text }]}>
                    {t("goalEditModalTitle")}
                  </Text>
                  <Text style={[styles.priceModalLabel, { color: colors.muted, marginTop: 0 }]}>
                    {t("goalEditNameLabel")}
                  </Text>
                  <TextInput
                    style={[
                      styles.priceModalInput,
                      {
                        borderColor: colors.border,
                        color: colors.text,
                        backgroundColor: colors.card,
                      },
                    ]}
                    value={goalEditorPrompt.name}
                    onChangeText={handleGoalEditorNameChange}
                    placeholder={t("goalEditNameLabel")}
                    placeholderTextColor={colors.muted}
                  />
                  <Text style={[styles.priceModalLabel, { color: colors.muted }]}>
                    {t("goalEditTargetLabel")}
                  </Text>
                  <TextInput
                    style={[
                      styles.priceModalInput,
                      {
                        borderColor: colors.border,
                        color: colors.text,
                        backgroundColor: colors.card,
                      },
                    ]}
                    value={goalEditorPrompt.target}
                    onChangeText={handleGoalEditorTargetChange}
                    placeholder={t("goalEditTargetLabel")}
                    placeholderTextColor={colors.muted}
                    keyboardType="numeric"
                  />
                  <Text style={[styles.priceModalLabel, { color: colors.muted }]}>
                    {t("goalEditEmojiLabel")}
                  </Text>
                  <TextInput
                    style={[
                      styles.priceModalInput,
                      {
                        borderColor: colors.border,
                        color: colors.text,
                        backgroundColor: colors.card,
                      },
                    ]}
                    value={goalEditorPrompt.emoji}
                    onChangeText={handleGoalEditorEmojiChange}
                  placeholder={t("goalEditEmojiLabel")}
                  placeholderTextColor={colors.muted}
                  selectTextOnFocus
                  maxLength={2}
                />
                  <View style={styles.priceModalButtons}>
                    <TouchableOpacity
                      style={[styles.priceModalPrimary, { backgroundColor: colors.text }]}
                      onPress={saveGoalEditorPrompt}
                    >
                      <Text style={[styles.priceModalPrimaryText, { color: colors.background }]}>
                        {t("goalEditSave")}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[styles.priceModalSecondary, { borderColor: colors.border }]}
                      onPress={closeGoalEditorPrompt}
                    >
                      <Text style={[styles.priceModalSecondaryText, { color: colors.muted }]}>
                        {t("goalEditCancel")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>

        <Modal
          visible={goalRenewalPromptVisible}
          transparent
          animationType="fade"
          statusBarTranslucent
        >
          <TouchableWithoutFeedback onPress={handleGoalRenewalLater}>
            <View style={styles.goalRenewalBackdrop}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View
                  style={[
                    styles.goalRenewalCard,
                    { backgroundColor: colors.card, borderColor: colors.border },
                  ]}
                >
                  <Text style={[styles.goalRenewalTitle, { color: colors.text }]}>
                    {t("goalRenewalTitle")}
                  </Text>
                  <Text style={[styles.goalRenewalSubtitle, { color: colors.muted }]}>
                    {t("goalRenewalSubtitle")}
                  </Text>
                  <View style={styles.goalRenewalActions}>
                    <TouchableOpacity
                      style={[styles.goalRenewalSecondary, { borderColor: colors.border }]}
                      onPress={handleGoalRenewalLater}
                    >
                      <Text style={[styles.goalRenewalSecondaryText, { color: colors.muted }]}>
                        {t("goalRenewalLater")}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[styles.goalRenewalPrimary, { backgroundColor: colors.text }]}
                      onPress={handleGoalRenewalStart}
                    >
                      <Text style={[styles.goalRenewalPrimaryText, { color: colors.background }]}>
                        {t("goalRenewalCreate")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>

        <Modal
          visible={incomeEntryModalVisible}
          transparent
          animationType="fade"
          statusBarTranslucent
        >
          <TouchableWithoutFeedback onPress={handleIncomeEntryDismiss}>
            <View style={[styles.priceModalBackdrop, modalKeyboardPaddingStyle]}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View style={[styles.priceModalCard, { backgroundColor: colors.card }]}>
                  <Text style={[styles.priceModalTitle, { color: colors.text }]}>
                    {t(incomeEntryTitleKey)}
                  </Text>
                  <Text style={[styles.priceModalLabel, { color: colors.muted, marginTop: 0 }]}>
                    {t(incomeEntrySubtitleKey)}
                  </Text>
                  <View
                    style={[
                      styles.incomeEntryVisual,
                      { backgroundColor: colors.background, borderColor: colors.border },
                    ]}
                  >
                    <View style={styles.incomeEntryVisualRow}>
                      <View
                        style={[
                          styles.incomeEntryVisualItem,
                          { backgroundColor: colors.card, borderColor: colors.border },
                        ]}
                      >
                        <Text style={styles.incomeEntryVisualIcon}>ðŸ’¸</Text>
                        <Text style={[styles.incomeEntryVisualLabel, { color: colors.text }]}>
                          {t("incomeEntryVisualIncome")}
                        </Text>
                      </View>
                      <Text style={[styles.incomeEntryVisualArrow, { color: colors.muted }]}>â†’</Text>
                      <View
                        style={[
                          styles.incomeEntryVisualItem,
                          { backgroundColor: colors.card, borderColor: colors.border },
                        ]}
                      >
                        <Text style={styles.incomeEntryVisualIcon}>ðŸ“Š</Text>
                        <Text style={[styles.incomeEntryVisualLabel, { color: colors.text }]}>
                          {t("incomeEntryVisualBudget")}
                        </Text>
                      </View>
                      <Text style={[styles.incomeEntryVisualArrow, { color: colors.muted }]}>â†’</Text>
                      <View
                        style={[
                          styles.incomeEntryVisualItem,
                          { backgroundColor: colors.card, borderColor: colors.border },
                        ]}
                      >
                        <Text style={styles.incomeEntryVisualIcon}>ðŸ’Ž</Text>
                        <Text style={[styles.incomeEntryVisualLabel, { color: colors.text }]}>
                          {t("incomeEntryVisualSavings")}
                        </Text>
                      </View>
                    </View>
                  </View>
                  <Text style={[styles.incomeEntryExplanation, { color: colors.muted }]}>
                    {t(incomeEntryExplanationKey)}
                  </Text>
                  <Text style={[styles.priceModalLabel, { color: colors.muted }]}>
                    {t(incomeEntryAmountLabelKey)}
                  </Text>
                  <TextInput
                    style={[
                      styles.priceModalInput,
                      {
                        borderColor: colors.border,
                        color: colors.text,
                        backgroundColor: colors.card,
                      },
                    ]}
                    value={incomeEntryInput.amount}
                    onChangeText={(text) =>
                      setIncomeEntryInput((prev) => ({ ...prev, amount: text }))
                    }
                    placeholder={t(incomeEntryAmountLabelKey)}
                    placeholderTextColor={colors.muted}
                    keyboardType="decimal-pad"
                  />
                  <View style={styles.priceModalButtons}>
                    <TouchableOpacity
                      style={[styles.priceModalPrimary, { backgroundColor: colors.text }]}
                      onPress={handleIncomeEntrySubmit}
                    >
                      <Text style={[styles.priceModalPrimaryText, { color: colors.background }]}>
                        {t(incomeEntryConfirmKey)}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[styles.priceModalSecondary, { borderColor: colors.border }]}
                      onPress={handleIncomeEntrySkip}
                    >
                      <Text style={[styles.priceModalSecondaryText, { color: colors.muted }]}>
                        {t(incomeEntrySkipKey)}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>

        <ImageSourceSheet
          visible={showImageSourceSheet}
          colors={colors}
          t={t}
          onClose={closeImagePickerSheet}
          onSelect={handleImageSourceChoice}
        />
        <Modal
          visible={categoryPrompt.visible}
          transparent
          animationType="fade"
          statusBarTranslucent
        >
          <TouchableWithoutFeedback onPress={closeCategoryPrompt}>
            <View style={[styles.priceModalBackdrop, modalKeyboardPaddingStyle]}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View style={[styles.priceModalCard, { backgroundColor: colors.card }]}>
                  <Text style={[styles.priceModalTitle, { color: colors.text }]}>
                    {t("categoryPromptTitle")}
                  </Text>
                  <Text style={[styles.priceModalLabel, { color: colors.muted, marginTop: 0 }]}>
                    {t("categoryPromptSubtitle")}
                  </Text>
                  <ImpulseCategorySelector
                    value={categoryPromptSelection || DEFAULT_IMPULSE_CATEGORY}
                    onChange={setCategoryPromptSelection}
                    colors={colors}
                    language={language}
                    horizontal
                    visibleCount={5}
                  />
                  <View style={styles.priceModalButtons}>
                    <TouchableOpacity
                      style={[styles.priceModalPrimary, { backgroundColor: colors.text }]}
                      onPress={handleCategoryPromptConfirm}
                    >
                      <Text style={[styles.priceModalPrimaryText, { color: colors.background }]}>
                        {t("categoryPromptConfirm")}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[styles.priceModalSecondary, { borderColor: colors.border }]}
                      onPress={closeCategoryPrompt}
                    >
                      <Text style={[styles.priceModalSecondaryText, { color: colors.muted }]}>
                        {t("categoryPromptCancel")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>
        <Modal
          visible={manageCategoriesVisible}
          transparent
          animationType="fade"
          statusBarTranslucent
          onRequestClose={closeManageCategoriesModal}
        >
          <View style={styles.progressCategoryModalRoot}>
            <TouchableWithoutFeedback onPress={closeManageCategoriesModal}>
              <View
                style={[
                  styles.progressCategoryBackdrop,
                  { backgroundColor: "rgba(0,0,0,0.35)" },
                ]}
              />
            </TouchableWithoutFeedback>
            <View style={styles.progressCategoryModalWrap} pointerEvents="box-none">
              <View style={[styles.priceModalCard, { backgroundColor: colors.card }]}>
                <Text style={[styles.priceModalTitle, { color: colors.text }]}>
                  {t("manageCategoriesTitle")}
                </Text>
                <View style={[styles.categoryManagerSavingsCard, { borderColor: colors.border }]}>
                  <Text style={[styles.categoryManagerSavingsTitle, { color: colors.text }]}>
                    {t("manageCategoriesEditTitle")}
                  </Text>
                  {!!categoryEditId && (
                    <Text style={[styles.categoryManagerEditSubtitle, { color: colors.muted }]}>
                      {categoryEditId === "savings"
                        ? `${getBudgetCategoryEmoji("savings")} ${getBudgetCategoryLabel("savings", language)}`
                        : getImpulseCategoryLabel(categoryEditId, language)}
                    </Text>
                  )}
                  <View style={styles.categoryManagerSavingsRow}>
                    <View style={styles.categoryManagerSavingsField}>
                      <Text style={[styles.priceModalLabel, { color: colors.muted, marginTop: 0 }]}>
                        {t("addCategoryNameLabel")}
                      </Text>
                      <TextInput
                        style={[
                          styles.priceModalInputCompact,
                          {
                            borderColor: colors.border,
                            color: colors.text,
                            backgroundColor: colors.card,
                          },
                        ]}
                        value={categoryEditName}
                        onChangeText={setCategoryEditName}
                        placeholder={t("addCategoryNameLabel")}
                        placeholderTextColor={colors.muted}
                      />
                    </View>
                    <View style={styles.categoryManagerSavingsEmojiField}>
                      <Text style={[styles.priceModalLabel, { color: colors.muted, marginTop: 0 }]}>
                        {t("addCategoryEmojiLabel")}
                      </Text>
                      <TextInput
                        style={[
                          styles.priceModalInputCompact,
                          {
                            borderColor: colors.border,
                            color: colors.text,
                            backgroundColor: colors.card,
                            textAlign: "center",
                          },
                        ]}
                        value={categoryEditEmoji}
                        onChangeText={(text) => setCategoryEditEmoji(limitEmojiInput(text))}
                        placeholder={t("addCategoryEmojiLabel")}
                        placeholderTextColor={colors.muted}
                        selectTextOnFocus
                        maxLength={2}
                      />
                    </View>
                  </View>
                  <View style={styles.categoryManagerSavingsActions}>
                    <TouchableOpacity
                      style={[styles.priceModalPrimary, styles.categoryManagerSavingsButton, { backgroundColor: colors.text }]}
                      onPress={handleCategoryEditSave}
                    >
                      <Text style={[styles.priceModalPrimaryText, { color: colors.background }]}>
                        {t("addCategorySave")}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[styles.priceModalSecondary, styles.categoryManagerSavingsButton, { borderColor: colors.border }]}
                      onPress={handleCategoryEditCancel}
                    >
                      <Text style={[styles.priceModalSecondaryText, { color: colors.muted }]}>
                        {t("addCategoryCancel")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
                <ScrollView
                  style={[
                    styles.categoryManagerList,
                    { borderColor: colors.border, height: categoryManagerListHeight },
                  ]}
                  contentContainerStyle={styles.categoryManagerListContent}
                  showsVerticalScrollIndicator
                  keyboardShouldPersistTaps="handled"
                >
                  <TouchableOpacity
                    style={[
                      styles.categoryManagerAddButton,
                      { borderColor: colors.border, backgroundColor: colors.text },
                    ]}
                    onPress={openAddCategoryModal}
                  >
                    <Text style={[styles.categoryManagerAddButtonText, { color: colors.background }]}>
                      {t("addCategoryButton")}
                    </Text>
                  </TouchableOpacity>
                  {categoryManagerList.map((entry, index) => {
                    const isActive = entry.id === categoryEditId;
                    return (
                      <View
                        key={entry.id}
                        style={[
                          styles.categoryManagerRow,
                          isActive ? { backgroundColor: colorWithAlpha(colors.text, 0.08) } : null,
                          {
                            borderColor: colors.border,
                            borderBottomWidth:
                              index === categoryManagerList.length - 1
                                ? 0
                                : StyleSheet.hairlineWidth,
                          },
                        ]}
                      >
                        <Pressable
                          style={styles.categoryManagerRowInfo}
                          onPress={() => handleCategorySelect(entry.id)}
                        >
                          <Text style={styles.categoryManagerEmoji}>{entry.emoji}</Text>
                          <Text
                            style={[styles.categoryManagerName, { color: colors.text }]}
                            numberOfLines={1}
                          >
                            {entry.label}
                          </Text>
                        </Pressable>
                        <View style={styles.categoryManagerRowActions}>
                          {!entry.custom && (
                            <Text style={[styles.categoryManagerDefaultTag, { color: colors.muted }]}>
                              {t("manageCategoriesDefaultTag")}
                            </Text>
                          )}
                          {entry.deletable && (
                            <TouchableOpacity
                              style={[styles.categoryManagerDeleteButton, { borderColor: colors.border }]}
                              onPress={() => confirmCategoryDelete(entry.id)}
                            >
                              <Text style={[styles.categoryManagerDeleteText, { color: "#E15555" }]}>
                                {t("cartRemove")}
                              </Text>
                            </TouchableOpacity>
                          )}
                        </View>
                      </View>
                    );
                  })}
                </ScrollView>
                <View style={styles.priceModalButtons}>
                  <TouchableOpacity
                    style={[styles.priceModalSecondary, { borderColor: colors.border }]}
                    onPress={closeManageCategoriesModal}
                  >
                    <Text style={[styles.priceModalSecondaryText, { color: colors.muted }]}>
                      {t("manageCategoriesClose")}
                    </Text>
                  </TouchableOpacity>
                </View>
              </View>
            </View>
          </View>
        </Modal>
        <Modal
          visible={addCategoryModalVisible}
          transparent
          animationType="fade"
          statusBarTranslucent
        >
          <TouchableWithoutFeedback onPress={closeAddCategoryModal}>
            <View style={[styles.priceModalBackdrop, modalKeyboardPaddingStyle]}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View style={[styles.priceModalCard, { backgroundColor: colors.card }]}>
                  <Text style={[styles.priceModalTitle, { color: colors.text }]}>
                    {t("addCategoryModalTitle")}
                  </Text>
                  <Text style={[styles.priceModalLabel, { color: colors.muted, marginTop: 0 }]}>
                    {t("addCategoryNameLabel")}
                  </Text>
                  <TextInput
                    style={[
                      styles.priceModalInput,
                      {
                        borderColor: colors.border,
                        color: colors.text,
                        backgroundColor: colors.card,
                      },
                    ]}
                    value={addCategoryName}
                    onChangeText={(text) => {
                      setAddCategoryName(text);
                      setAddCategoryError(false);
                    }}
                    placeholder={t("addCategoryNameLabel")}
                    placeholderTextColor={colors.muted}
                  />
                  <Text style={[styles.priceModalLabel, { color: colors.muted }]}>
                    {t("addCategoryEmojiLabel")}
                  </Text>
                  <TextInput
                    style={[
                      styles.priceModalInput,
                      {
                        borderColor: colors.border,
                        color: colors.text,
                        backgroundColor: colors.card,
                      },
                    ]}
                    value={addCategoryEmoji}
                    onChangeText={(text) => setAddCategoryEmoji(limitEmojiInput(text))}
                    placeholder={t("addCategoryEmojiLabel")}
                    placeholderTextColor={colors.muted}
                    selectTextOnFocus
                    maxLength={2}
                  />
                  {addCategoryError && (
                    <Text style={[styles.priceModalDeleteText, { color: "#E15555" }]}>
                      {t("addCategoryError")}
                    </Text>
                  )}
                  <View style={styles.priceModalButtons}>
                    <TouchableOpacity
                      style={[styles.priceModalPrimary, { backgroundColor: colors.text }]}
                      onPress={handleAddCategorySave}
                    >
                      <Text style={[styles.priceModalPrimaryText, { color: colors.background }]}>
                        {t("addCategorySave")}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[styles.priceModalSecondary, { borderColor: colors.border }]}
                      onPress={closeAddCategoryModal}
                    >
                      <Text style={[styles.priceModalSecondaryText, { color: colors.muted }]}>
                        {t("addCategoryCancel")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>
        <SpendConfirmSheet
          visible={spendPrompt.visible}
          item={spendPrompt.item}
          amountUSD={spendPrompt.amountUSD}
          currency={profile.currency || DEFAULT_PROFILE.currency}
          language={language}
          onCancel={closeSpendPrompt}
          onConfirm={handleSpendConfirm}
          colors={colors}
          t={t}
          theme={theme}
        />
        <SaveSpamDisclaimerModal
          visible={saveSpamPrompt.visible}
          t={t}
          colors={colors}
          catCuriousSource={tamagotchiAnimations.curious}
          onConfirm={handleSaveSpamPromptConfirm}
          onCancel={handleSaveSpamPromptCancel}
        />
        <StormOverlay
          visible={stormActive}
          t={t}
          catCrySource={tamagotchiAnimations.cry}
          colors={colors}
          onDismiss={dismissStormEffect}
        />
      </SafeAreaView>
      </View>
    </SavingsProvider>
  );
}

function App() {
  return (
    <SafeAreaProvider>
      <AppContent />
    </SafeAreaProvider>
  );
}

export default Sentry.wrap(App);

const StatusGlass = React.memo(({ height, colors, theme, blurAvailable = false, solid = false }) => {
  const gradientId = useMemo(() => `status-glass-${Math.random().toString(36).slice(2, 10)}`, []);
  const baseColor = colors?.background || "#fff";
  const isDarkTheme = theme === "dark";
  const tintedBase = isDarkTheme
    ? blendColors(baseColor, "#000000", 0.35)
    : blendColors(baseColor, "#ffffff", 0.45);
  const highlightBase = isDarkTheme ? "#000000" : "#ffffff";
  const highlight = colorWithAlpha(highlightBase, isDarkTheme ? 0.3 : 0.32);
  const softCore = colorWithAlpha(tintedBase, isDarkTheme ? 0.45 : 0.38);
  const fadeOut = colorWithAlpha(baseColor, 0);
  const borderColor = colorWithAlpha(colors?.border || tintedBase, isDarkTheme ? 0.35 : 0.18);
  const borderOffset = solid ? StyleSheet.hairlineWidth : 26;
  const borderPosition = Math.max(0, height - borderOffset);
  if (solid) {
    return (
      <View
        pointerEvents="none"
        style={[styles.statusGlass, { height, backgroundColor: baseColor }]}
      >
        <View style={[styles.statusGlassBorder, { borderColor, top: borderPosition }]} />
      </View>
    );
  }
  const overlay = (
    <Svg style={StyleSheet.absoluteFill} pointerEvents="none">
      <Defs>
        <SvgLinearGradient id={gradientId} x1="0" y1="0" x2="0" y2="1">
          <SvgStop offset="0%" stopColor={highlight} />
          <SvgStop offset="55%" stopColor={softCore} />
          <SvgStop offset="100%" stopColor={fadeOut} />
        </SvgLinearGradient>
      </Defs>
      <SvgRect x="0" y="0" width="100%" height="100%" fill={`url(#${gradientId})`} />
    </Svg>
  );
  const border = <View style={[styles.statusGlassBorder, { borderColor, top: borderPosition }]} />;
  if (blurAvailable) {
    return (
      <View pointerEvents="none" style={[styles.statusGlass, { height }]}>
        {Platform.OS === "android" && AndroidBlurView && !ANDROID_DIMEZIS_DISABLED ? (
          <AndroidBlurView
            blurType={theme === "dark" ? "dark" : "light"}
            blurAmount={4}
            autoUpdate={ANDROID_BLUR_AUTO_UPDATE}
            reducedTransparencyFallbackColor={isDarkTheme ? "#0B0B0B" : "#F2F2F2"}
            style={StyleSheet.absoluteFill}
          />
        ) : (
          <ExpoBlurView
            tint={theme === "dark" ? "dark" : "extraLight"}
            intensity={18}
            experimentalBlurMethod={
              Platform.OS === "android" && !ANDROID_DIMEZIS_DISABLED
                ? "dimezisBlurView"
                : undefined
            }
            style={StyleSheet.absoluteFill}
          />
        )}
        {overlay}
        {border}
      </View>
    );
  }
  return (
    <View pointerEvents="none" style={[styles.statusGlass, { height }]}>
      {overlay}
      {border}
    </View>
  );
});

const TYPOGRAPHY = {
  logo: {
    fontFamily: INTER_FONTS.extraBold,
    fontSize: scaleFontSize(44),
    letterSpacing: scaleLetterSpacing(-0.5),
  },
  display: {
    fontFamily: INTER_FONTS.bold,
    fontSize: scaleFontSize(34),
    letterSpacing: scaleLetterSpacing(-0.2),
  },
  blockTitle: {
    fontFamily: INTER_FONTS.bold,
    fontSize: scaleFontSize(24),
    letterSpacing: scaleLetterSpacing(-0.2),
  },
  body: {
    fontFamily: INTER_FONTS.regular,
    fontSize: scaleFontSize(15),
    lineHeight: scaleFontSize(20),
  },
  secondary: {
    fontFamily: INTER_FONTS.light,
    fontSize: scaleFontSize(12),
    lineHeight: scaleFontSize(16),
  },
  cta: {
    fontFamily: INTER_FONTS.semiBold,
    fontSize: scaleFontSize(14),
    letterSpacing: scaleLetterSpacing(CTA_LETTER_SPACING),
  },
};

const createBodyText = (overrides = {}) => ({ ...TYPOGRAPHY.body, ...scaleTypographyOverrides(overrides) });
const createSecondaryText = (overrides = {}) => ({
  ...TYPOGRAPHY.secondary,
  ...scaleTypographyOverrides(overrides),
});
const createCtaText = (overrides = {}) => ({ ...TYPOGRAPHY.cta, ...scaleTypographyOverrides(overrides) });

const SPEND_STATS_TRACK_HEIGHT = 140;
const SPEND_STATS_TRACK_PADDING = 6;
const SPEND_STATS_STACK_GAP = 4;
const SPEND_STATS_MIN_STACK_HEIGHT = 6;
const SPEND_STATS_CARD_MAX_WIDTH = 360;
const SPEND_STATS_CARD_PADDING = 18;
const SPEND_STATS_CHART_GAP = 10;
const SPEND_STATS_VISIBLE_COLUMNS = 4;
const BREAKDOWN_OVERLAY_PADDING = 16;
const BREAKDOWN_TOGGLE_SAVE_COLOR = "#2EB873";
const BREAKDOWN_TOGGLE_SPEND_COLOR = "#E15555";
const BREAKDOWN_TOGGLE_SHIELD_PATH = "M12 2L4 5V11C4 16 8 19 12 22C16 19 20 16 20 11V5L12 2Z";

const styles = StyleSheet.create({
  appBackground: {
    flex: 1,
  },
  appShell: {
    flex: 1,
  },
  screenWrapper: {
    flex: 1,
  },
  backGestureWrapper: {
    ...StyleSheet.absoluteFillObject,
    alignItems: "flex-end",
  },
  backGestureEdge: {
    width: BACK_GESTURE_EDGE_WIDTH,
    height: "100%",
  },
  statusGlass: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    overflow: "hidden",
    zIndex: 10,
  },
  statusGlassBorder: {
    position: "absolute",
    left: 0,
    right: 0,
    borderBottomWidth: StyleSheet.hairlineWidth,
  },
  container: {
    flex: 1,
    paddingHorizontal: BASE_HORIZONTAL_PADDING,
    paddingTop: 24,
    position: "relative",
  },
  screenLoading: {
    flex: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  feedList: {
    marginHorizontal: -BASE_HORIZONTAL_PADDING,
    overflow: "visible",
  },
  feedListContent: {
    paddingTop: 4,
    paddingBottom: 160,
    paddingHorizontal: BASE_HORIZONTAL_PADDING,
  },
  frequencySectionHeader: {
    marginTop: 16,
    marginBottom: 8,
    paddingVertical: 10,
    paddingHorizontal: 14,
    borderRadius: 16,
    borderWidth: 1,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  frequencySectionHeaderText: {
    flexDirection: "row",
    alignItems: "center",
  },
  frequencySectionTitle: {
    fontSize: 15,
    fontWeight: "600",
  },
  frequencySectionCount: {
    fontSize: 13,
    fontWeight: "500",
    marginLeft: 8,
  },
  frequencySectionToggle: {
    flexDirection: "row",
    alignItems: "center",
  },
  frequencySectionToggleLabel: {
    fontSize: 13,
    fontWeight: "600",
  },
  frequencySectionToggleArrow: {
    fontSize: 14,
    fontWeight: "700",
    marginLeft: 6,
  },
  archiveSection: {
    marginTop: 8,
  },
  archiveList: {
    marginTop: 8,
  },
  archiveEmptyText: {
    marginTop: 6,
    marginBottom: 12,
    fontSize: 13,
    fontWeight: "500",
  },
  feedHero: {
    paddingBottom: 12,
  },
  feedTemptationHeader: {
    marginTop: 12,
    marginBottom: 6,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  feedTemptationTitle: {
    fontSize: 18,
    fontWeight: "700",
  },
  feedTemptationAddButton: {
    width: 30,
    height: 30,
    borderRadius: 15,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  feedTemptationAddIcon: {
    fontSize: 18,
    fontWeight: "700",
    lineHeight: 20,
  },
  feedHeroTop: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-start",
  },
  heroCarousel: {
    marginTop: 12,
  },
  heroCarouselItem: {
    width: "100%",
    alignItems: "stretch",
    paddingHorizontal: 0,
    marginRight: HERO_CAROUSEL_ITEM_GUTTER,
  },
  heroCarouselSizedCard: {
    marginTop: 0,
    marginBottom: 0,
    alignSelf: "stretch",
  },
  moodGradientBlock: {
    position: "relative",
    overflow: "hidden",
  },
  moodGradientOverlay: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.55,
    transform: [{ rotate: "-10deg" }],
  },
  heroMoodGradient: {
    flex: 1,
    width: "100%",
    borderRadius: 28,
    padding: 18,
    paddingBottom: 20,
    position: "relative",
    overflow: "hidden",
  },
  moodBadge: {
    alignSelf: "flex-start",
    paddingHorizontal: 14,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "rgba(255,255,255,0.85)",
    marginTop: 16,
  },
  moodBadgeText: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase" }),
  },
  moodBadgeTextRu: {
    ...createCtaText({ fontSize: 10, textTransform: "uppercase" }),
  },
  heroLevelBadge: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
  },
  heroLevelBadgeText: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase" }),
  },
  heroBadgeRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    marginTop: 16,
    alignSelf: "flex-start",
  },
  heroStreakBadge: {
    flexDirection: "row",
    alignItems: "center",
    gap: 4,
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 999,
    borderWidth: 1,
    minHeight: 26,
  },
  heroStreakEmoji: {
    fontSize: 12,
    lineHeight: 16,
  },
  heroStreakEmojiLost: {
    opacity: 0.35,
  },
  heroStreakBadgeText: {
    ...createCtaText({ fontSize: 11 }),
    lineHeight: 14,
  },
  heroLevelExpandedCard: {
    alignSelf: "stretch",
    marginTop: 12,
    marginBottom: 0,
    overflow: "hidden",
  },
  moodDetailsBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.5)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  moodDetailsCard: {
    width: "100%",
    borderRadius: 32,
    padding: 24,
    alignItems: "center",
    gap: 12,
  },
  moodDetailsLabel: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 20,
    textAlign: "center",
  },
  moodDetailsDescription: {
    ...createBodyText({ fontSize: 16, textAlign: "center", lineHeight: 22 }),
  },
  moodDetailsButton: {
    marginTop: 12,
    paddingHorizontal: 24,
    paddingVertical: 10,
    borderRadius: 999,
    borderWidth: 1,
  },
  moodDetailsButtonText: {
    ...createCtaText({ textTransform: "uppercase" }),
  },
  baselinePromptBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.45)",
    padding: 24,
    justifyContent: "center",
  },
  baselinePromptCard: {
    borderRadius: 28,
    borderWidth: 1,
    padding: 20,
    gap: 12,
  },
  baselinePromptTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 22,
  },
  baselinePromptSubtitle: {
    ...createBodyText({ fontSize: 15, lineHeight: 22 }),
  },
  baselinePromptDismiss: {
    alignItems: "center",
    marginTop: 4,
  },
  baselinePromptDismissText: {
    ...createCtaText({ fontSize: 13 }),
  },
  heroMascotRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  heroMascotContainer: {
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    marginTop: 52,
    width: HERO_MASCOT_SIZE,
    height: HERO_MASCOT_SIZE,
  },
  heroMascotShieldOverlay: {
    position: "absolute",
    top: -10,
    left: -8,
    width: 28,
    height: 28,
    borderRadius: 14,
    backgroundColor: "rgba(255,255,255,0.9)",
    alignItems: "center",
    justifyContent: "center",
    borderWidth: 1,
    borderColor: "rgba(47,112,255,0.45)",
    zIndex: 7,
    elevation: 5,
  },
  heroMascotShieldIcon: {
    fontSize: 14,
  },
  heroImmunityHintBubble: {
    position: "absolute",
    top: -42,
    right: "100%",
    marginRight: 8,
    borderRadius: 14,
    borderWidth: 1,
    paddingHorizontal: 8,
    paddingVertical: 6,
    shadowColor: "#0A1324",
    shadowOpacity: 0.22,
    shadowRadius: 12,
    shadowOffset: { width: 0, height: 6 },
    elevation: 10,
    zIndex: 20,
    alignItems: "flex-start",
  },
  immunityHintTitle: {
    ...createBodyText({ fontSize: 11 }),
    fontWeight: "700",
  },
  immunityHintTimer: {
    ...createBodyText({ fontSize: 13 }),
    fontWeight: "700",
    marginTop: 2,
  },
  heroMascotBadge: {
    position: "absolute",
    top: -6,
    right: -6,
    minWidth: 20,
    height: 20,
    paddingHorizontal: 5,
    borderRadius: 999,
    backgroundColor: "#FF4D4F",
    alignItems: "center",
    justifyContent: "center",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.9)",
    zIndex: 8,
    elevation: 6,
  },
  heroMascotBadgeText: {
    fontSize: 11,
    fontWeight: "800",
    color: "#fff",
  },
  heroTextWrap: {
    flex: 1,
    paddingRight: 6,
  },
  heroTitleRow: {
    alignSelf: "flex-start",
    position: "relative",
    paddingRight: 16,
  },
  appName: {
    ...TYPOGRAPHY.logo,
  },
  heroProBadge: {
    position: "absolute",
    top: -8,
    right: -1,
    minHeight: 11,
    paddingHorizontal: 3,
    paddingVertical: 0.5,
    borderRadius: 6,
    borderWidth: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  heroProBadgeText: {
    ...createCtaText({ fontSize: 6, textTransform: "uppercase" }),
    letterSpacing: 0.35,
  },
  heroTagline: {
    ...TYPOGRAPHY.body,
    marginTop: 4,
  },
  almiMascotWrap: {
    width: HERO_MASCOT_SIZE,
    height: HERO_MASCOT_SIZE,
    borderRadius: 28,
    backgroundColor: "rgba(255,255,255,0.75)",
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden",
    borderWidth: 1,
    borderColor: "rgba(255,255,255,0.5)",
  },
  almiMascotImage: {
    width: "120%",
    height: "120%",
  },
  mascotBubbleWrap: {
    position: "absolute",
    bottom: HERO_MASCOT_SIZE + 8,
    left: 0,
    right: 0,
    zIndex: 6,
    elevation: 6,
    alignItems: "center",
    marginBottom: -2,
  },
  mascotBubble: {
    minHeight: 34,
    paddingHorizontal: 10,
    paddingVertical: 7,
    borderRadius: 16,
    borderWidth: 1,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.25,
    shadowRadius: 10,
    elevation: 4,
    justifyContent: "center",
  },
  mascotBubbleText: {
    ...createBodyText({ fontSize: 10, textAlign: "center", lineHeight: 13 }),
    fontWeight: "600",
    paddingTop: 2,
    paddingBottom: 1,
  },
  mascotBubbleTail: {
    position: "absolute",
    bottom: -6,
    left: "50%",
    width: 12,
    height: 12,
    transform: [{ translateX: -6 }, { rotate: "45deg" }],
    borderRadius: 3,
  },
  skinPickerControl: {
    position: "absolute",
    top: 10,
    right: 10,
    zIndex: 12,
  },
  skinPickerButton: {
    width: 44,
    height: 40,
    borderRadius: 12,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "rgba(0,0,0,0.25)",
    shadowOpacity: 0.25,
    shadowOffset: { width: 0, height: 2 },
    shadowRadius: 4,
    elevation: 3,
  },
  skinPickerButtonLocked: {
    opacity: 0.7,
  },
  skinPickerIcon: {
    fontSize: 16,
  },
  skinPickerLockBadge: {
    position: "absolute",
    top: -6,
    right: -6,
    borderRadius: 999,
    paddingHorizontal: 4,
    paddingVertical: 2,
    borderWidth: 1,
  },
  skinPickerLockText: {
    fontSize: 10,
  },
  skinPickerLockedLabel: {
    ...createBodyText({ fontSize: 10 }),
    fontWeight: "600",
    textAlign: "center",
    lineHeight: 12,
    width: "100%",
  },
  proAccentBackdrop: {
    flex: 1,
    backgroundColor: "rgba(4,10,33,0.6)",
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 18,
    paddingVertical: 18,
  },
  proAccentCard: {
    width: "100%",
    maxWidth: 420,
    borderRadius: 26,
    borderWidth: 1,
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 14,
    gap: 10,
  },
  proAccentTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 21,
    textAlign: "center",
  },
  proAccentSubtitle: {
    ...createBodyText({ fontSize: 13, lineHeight: 18, textAlign: "center" }),
  },
  proAccentHero: {
    borderRadius: 20,
    borderWidth: 1,
    minHeight: 106,
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden",
    position: "relative",
  },
  proAccentHeroOrbPrimary: {
    position: "absolute",
    width: 140,
    height: 140,
    borderRadius: 999,
    top: -60,
    right: -25,
  },
  proAccentHeroOrbSecondary: {
    position: "absolute",
    width: 118,
    height: 118,
    borderRadius: 999,
    bottom: -58,
    left: -20,
  },
  proAccentHeroBadge: {
    borderRadius: 999,
    paddingHorizontal: 11,
    paddingVertical: 5,
    marginBottom: 7,
  },
  proAccentHeroBadgeText: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase" }),
    color: "#FFFFFF",
  },
  proAccentHeroText: {
    fontSize: 33,
    color: "#FFFFFF",
  },
  proAccentGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  proAccentOption: {
    width: "48%",
    borderRadius: 14,
    borderWidth: 1,
    paddingHorizontal: 10,
    paddingVertical: 9,
    gap: 6,
  },
  proAccentOptionTopRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 7,
  },
  proAccentSwatch: {
    width: 14,
    height: 14,
    borderRadius: 999,
  },
  proAccentOptionLabel: {
    ...createBodyText({ fontSize: 12, lineHeight: 16 }),
    fontWeight: "700",
    flex: 1,
  },
  proAccentMiniPreview: {
    borderRadius: 10,
    borderWidth: 1,
    paddingHorizontal: 8,
    paddingVertical: 6,
    gap: 5,
  },
  proAccentMiniPreviewPill: {
    alignSelf: "flex-start",
    borderRadius: 999,
    width: 42,
    height: 8,
  },
  proAccentMiniPreviewBars: {
    gap: 4,
  },
  proAccentMiniPreviewBar: {
    height: 6,
    borderRadius: 999,
  },
  proAccentOptionSelected: {
    ...createBodyText({ fontSize: 11, lineHeight: 14 }),
    fontWeight: "700",
  },
  proAccentDoneButton: {
    marginTop: 4,
    minHeight: 46,
    borderRadius: 14,
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "#4353FF",
    shadowOpacity: 0.24,
    shadowOffset: { width: 0, height: 6 },
    shadowRadius: 12,
    elevation: 8,
  },
  proAccentDoneButtonText: {
    ...createCtaText({ fontSize: 14, textTransform: "none" }),
    color: "#FFFFFF",
  },
  skinPickerBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.55)",
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 20,
    paddingVertical: 20,
  },
  skinPickerCard: {
    width: "100%",
    maxWidth: 380,
    borderRadius: 28,
    paddingVertical: 16,
    paddingHorizontal: 18,
    borderWidth: 1,
    gap: 8,
  },
  skinPickerTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 20,
  },
  skinPickerSubtitle: {
    ...createBodyText({ fontSize: 15 }),
  },
  skinPickerList: {
    paddingVertical: 6,
    paddingHorizontal: 4,
  },
  skinUnlockCard: {
    borderWidth: 1,
    borderRadius: 20,
    padding: 16,
    marginBottom: 16,
    gap: 10,
  },
  skinUnlockTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 17,
  },
  skinUnlockSubtitle: {
    ...createBodyText({ fontSize: 14 }),
  },
  skinUnlockButton: {
    borderRadius: 999,
    paddingVertical: 12,
    paddingHorizontal: 16,
    alignItems: "center",
  },
  skinUnlockButtonText: {
    ...createCtaText({ fontSize: 14, textTransform: "none" }),
  },
  featureUnlockWrapper: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    padding: 24,
    justifyContent: "center",
    alignItems: "center",
  },
  featureUnlockCard: {
    width: "100%",
    maxWidth: 420,
    maxHeight: SCREEN_HEIGHT * 0.86,
    borderRadius: 34,
    padding: 22,
    borderWidth: 1,
    overflow: "hidden",
    shadowColor: "#000",
    shadowOpacity: 0.2,
    shadowOffset: { width: 0, height: 18 },
    shadowRadius: 28,
    elevation: 12,
  },
  featureUnlockCardCompact: {
    padding: 16,
    maxHeight: SCREEN_HEIGHT * 0.82,
  },
  featureUnlockCardScroll: {
    paddingBottom: 8,
  },
  featureUnlockHeader: {
    borderRadius: 24,
    borderWidth: 1,
    borderColor: "rgba(120,180,255,0.24)",
    backgroundColor: "rgba(255,255,255,0.02)",
    padding: 14,
    overflow: "hidden",
    marginBottom: 14,
  },
  featureUnlockHeroGlow: {
    position: "absolute",
    width: 220,
    height: 220,
    borderRadius: 110,
    top: -84,
    right: -82,
  },
  featureUnlockHeroRow: {
    flexDirection: "row",
    alignItems: "center",
  },
  featureUnlockHeroCopy: {
    flex: 1,
    gap: 10,
  },
  featureUnlockBadge: {
    alignSelf: "flex-start",
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 10,
    paddingVertical: 5,
    backgroundColor: "rgba(255,255,255,0.08)",
  },
  featureUnlockBadgeText: {
    ...createCtaText({ fontSize: 10 }),
    letterSpacing: 0.45,
    textTransform: "uppercase",
  },
  featureUnlockCat: {
    width: 78,
    height: 78,
    marginRight: 14,
    resizeMode: "contain",
  },
  featureUnlockMessage: {
    ...createBodyText({ fontSize: 21, lineHeight: 27, fontWeight: "800" }),
  },
  featureUnlockMessageSub: {
    ...createBodyText({ fontSize: 13, lineHeight: 18, fontWeight: "600" }),
  },
  featureUnlockSection: {
    marginTop: 2,
    borderWidth: 1,
    borderRadius: 24,
    padding: 16,
  },
  featureUnlockSectionLabel: {
    ...createCtaText({ fontSize: 11 }),
    textTransform: "uppercase",
    letterSpacing: 0.7,
  },
  featureUnlockSectionTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 18,
    marginTop: 8,
  },
  featureUnlockSectionDescription: {
    ...createBodyText({ fontSize: 14, lineHeight: 20 }),
    marginTop: 6,
  },
  featureUnlockIllustration: {
    marginTop: 12,
    borderRadius: 22,
    borderWidth: 1,
    padding: 12,
    overflow: "hidden",
    minHeight: 212,
  },
  featureUnlockIllustrationGlow: {
    position: "absolute",
    width: 220,
    height: 220,
    borderRadius: 110,
    top: -92,
    right: -88,
  },
  featureUnlockIllustrationFrame: {
    gap: 10,
  },
  featureUnlockIllustrationHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  featureUnlockIllustrationEmoji: {
    fontSize: 24,
  },
  featureUnlockMiniPhone: {
    borderWidth: 1,
    borderRadius: 16,
    overflow: "hidden",
  },
  featureUnlockMiniStatusRow: {
    minHeight: 24,
    borderBottomWidth: 1,
    paddingHorizontal: 8,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  featureUnlockMiniStatusDots: {
    flexDirection: "row",
    alignItems: "center",
    gap: 4,
    width: 24,
  },
  featureUnlockMiniStatusDot: {
    width: 4,
    height: 4,
    borderRadius: 999,
  },
  featureUnlockMiniStatusTitle: {
    ...createCtaText({ fontSize: 9, textTransform: "none" }),
    textAlign: "center",
    flex: 1,
    marginHorizontal: 8,
  },
  featureUnlockMiniBody: {
    padding: 8,
    gap: 7,
  },
  featureUnlockMiniNav: {
    borderTopWidth: 1,
    paddingHorizontal: 4,
    paddingVertical: 5,
    flexDirection: "row",
    gap: 4,
  },
  featureUnlockMiniNavItem: {
    flex: 1,
    minHeight: 26,
    borderRadius: 8,
    alignItems: "center",
    justifyContent: "center",
    paddingHorizontal: 2,
  },
  featureUnlockMiniNavItemActive: {
    borderWidth: 1,
  },
  featureUnlockMiniNavLabel: {
    ...createCtaText({ fontSize: 8, textTransform: "uppercase" }),
    letterSpacing: 0.2,
  },
  featureUnlockMiniNavLabelActive: {
    fontWeight: "800",
  },
  featureUnlockMiniHeroCard: {
    borderWidth: 1,
    borderRadius: 12,
    paddingHorizontal: 8,
    paddingVertical: 6,
    flexDirection: "row",
    alignItems: "center",
    gap: 7,
  },
  featureUnlockMiniHeroCat: {
    width: 30,
    height: 30,
    resizeMode: "contain",
  },
  featureUnlockMiniHeroCopy: {
    flex: 1,
    gap: 1,
  },
  featureUnlockMiniHeroTitle: {
    ...createCtaText({ fontSize: 10, textTransform: "none" }),
    fontWeight: "800",
  },
  featureUnlockMiniHeroSubtitle: {
    ...createBodyText({ fontSize: 9, lineHeight: 12 }),
  },
  featureUnlockMiniModalCard: {
    borderWidth: 1,
    borderRadius: 12,
    padding: 8,
    gap: 6,
  },
  featureUnlockMiniModalTitle: {
    ...createCtaText({ fontSize: 10, textTransform: "none" }),
    fontWeight: "800",
  },
  featureUnlockMiniRewardRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  featureUnlockMiniActionButton: {
    marginLeft: "auto",
    borderRadius: 999,
    paddingHorizontal: 8,
    minHeight: 22,
    justifyContent: "center",
  },
  featureUnlockMiniActionText: {
    ...createCtaText({ fontSize: 9, textTransform: "none" }),
    color: "#1F1300",
    fontWeight: "700",
  },
  featureUnlockMiniLine: {
    height: 6,
    borderRadius: 4,
  },
  featureUnlockMiniChipRow: {
    flexDirection: "row",
    gap: 6,
  },
  featureUnlockMiniChip: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 999,
    minHeight: 24,
    alignItems: "center",
    justifyContent: "center",
    paddingHorizontal: 6,
  },
  featureUnlockMiniChipText: {
    ...createCtaText({ fontSize: 9, textTransform: "none" }),
  },
  featureUnlockMiniGrid: {
    borderWidth: 1,
    borderRadius: 12,
    padding: 6,
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 6,
  },
  featureUnlockMiniGridCell: {
    width: "48%",
    borderWidth: 1,
    borderRadius: 10,
    minHeight: 38,
    alignItems: "center",
    justifyContent: "center",
  },
  featureUnlockMiniGridEmoji: {
    fontSize: 15,
  },
  featureUnlockMiniList: {
    borderWidth: 1,
    borderRadius: 12,
    padding: 8,
    gap: 6,
  },
  featureUnlockMiniListRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  featureUnlockMiniListDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
  },
  featureUnlockMiniTag: {
    borderWidth: 1,
    borderRadius: 999,
    paddingHorizontal: 7,
    paddingVertical: 2,
  },
  featureUnlockMiniTagText: {
    ...createCtaText({ fontSize: 8, textTransform: "uppercase" }),
    letterSpacing: 0.2,
  },
  featureUnlockMiniMap: {
    borderWidth: 1,
    borderRadius: 12,
    padding: 8,
    gap: 5,
  },
  featureUnlockMiniMapRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    gap: 4,
  },
  featureUnlockMiniMapDot: {
    width: 10,
    height: 10,
    borderRadius: 5,
  },
  featureUnlockMiniCalendarRow: {
    flexDirection: "row",
    gap: 5,
  },
  featureUnlockMiniDay: {
    flex: 1,
    minHeight: 22,
    borderWidth: 1,
    borderRadius: 8,
    alignItems: "center",
    justifyContent: "center",
  },
  featureUnlockMiniDayActive: {
    borderWidth: 1,
  },
  featureUnlockMiniDayText: {
    ...createCtaText({ fontSize: 8, textTransform: "none" }),
  },
  featureUnlockMiniProfileCard: {
    borderWidth: 1,
    borderRadius: 12,
    padding: 8,
    gap: 7,
  },
  featureUnlockMiniProfileTitle: {
    ...createCtaText({ fontSize: 10, textTransform: "none" }),
    fontWeight: "800",
  },
  featureUnlockMiniProfileButton: {
    borderWidth: 1,
    borderRadius: 10,
    minHeight: 28,
    alignItems: "center",
    justifyContent: "center",
    paddingHorizontal: 8,
  },
  featureUnlockMiniProfileButtonText: {
    ...createCtaText({ fontSize: 9, textTransform: "none" }),
    fontWeight: "700",
  },
  featureUnlockMiniChallengeCard: {
    borderWidth: 1,
    borderRadius: 12,
    padding: 8,
    gap: 2,
  },
  featureUnlockMiniChallengeTitle: {
    ...createCtaText({ fontSize: 10, textTransform: "none" }),
    fontWeight: "800",
  },
  featureUnlockMiniChallengeMeta: {
    ...createBodyText({ fontSize: 9, lineHeight: 12 }),
  },
  featureUnlockPreviewCard: {
    borderWidth: 1,
    borderRadius: 16,
    padding: 12,
    gap: 4,
  },
  featureUnlockPreviewBadge: {
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 999,
  },
  featureUnlockPreviewBadgeText: {
    ...createCtaText({ fontSize: 10 }),
    fontWeight: "700",
    color: "#1F1300",
    letterSpacing: 0.2,
  },
  featureUnlockPreviewCat: {
    alignSelf: "flex-end",
    width: 54,
    height: 54,
    marginTop: -8,
    marginBottom: -4,
    resizeMode: "contain",
  },
  featureUnlockPreviewLines: {
    marginTop: 2,
  },
  featureUnlockPreviewLine: {
    height: 7,
    borderRadius: 4,
    marginTop: 5,
  },
  featureUnlockModalButton: {
    marginLeft: "auto",
    borderRadius: 18,
    paddingVertical: 8,
    paddingHorizontal: 14,
    alignItems: "center",
    justifyContent: "center",
  },
  featureUnlockModalButtonText: {
    ...createCtaText({ fontSize: 12 }),
    fontWeight: "700",
    color: "#1F1300",
  },
  featureUnlockRewardRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    borderWidth: 1,
    borderColor: "rgba(125,190,255,0.26)",
    borderRadius: 14,
    padding: 10,
    marginBottom: 4,
  },
  featureUnlockRewardCoin: {
    width: 28,
    height: 28,
    resizeMode: "contain",
  },
  featureUnlockRewardAmount: {
    ...createCtaText({ fontSize: 18 }),
  },
  featureUnlockMap: {
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: "rgba(125,190,255,0.22)",
    borderRadius: 14,
    paddingHorizontal: 10,
    paddingBottom: 6,
  },
  featureUnlockMapRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginBottom: 5,
  },
  featureUnlockMapDot: {
    width: 16,
    height: 16,
    borderRadius: 8,
  },
  featureUnlockList: {
    paddingVertical: 6,
    borderWidth: 1,
    borderColor: "rgba(125,190,255,0.22)",
    borderRadius: 14,
    paddingHorizontal: 10,
  },
  featureUnlockListItem: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 8,
  },
  featureUnlockListBullet: {
    width: 10,
    height: 10,
    borderRadius: 5,
    marginRight: 7,
  },
  featureUnlockListLine: {
    height: 7,
    borderRadius: 4,
  },
  featureUnlockButton: {
    marginTop: 18,
    borderRadius: 18,
    paddingVertical: 13,
    alignItems: "center",
  },
  featureUnlockButtonText: {
    ...createCtaText({ fontSize: 14 }),
  },
  lockedFeatureWrap: {
    position: "relative",
    overflow: "hidden",
  },
  lockedFeatureOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "flex-start",
    alignItems: "flex-start",
    paddingTop: 18,
    paddingBottom: 24,
    paddingHorizontal: 18,
  },
  lockedFeatureOverlayCentered: {
    justifyContent: "center",
    alignItems: "center",
  },
  lockedFeatureOverlayCompact: {
    paddingTop: 12,
    paddingBottom: 12,
    paddingHorizontal: 12,
  },
  lockedFeatureBlur: {
    zIndex: 0,
  },
  lockedFeatureScrim: {
    ...StyleSheet.absoluteFillObject,
  },
  lockedFeatureOverlayContent: {
    gap: 8,
    width: "100%",
    maxWidth: "100%",
    flexShrink: 1,
    zIndex: 1,
  },
  lockedFeatureOverlayContentCentered: {
    alignItems: "center",
    width: "100%",
  },
  lockedFeatureOverlayContentCompact: {
    gap: 6,
  },
  lockedFeatureLockRow: {
    flexDirection: "row",
    alignItems: "center",
  },
  lockedFeatureLockRowCentered: {
    justifyContent: "center",
    width: "100%",
  },
  lockedFeatureLockIcon: {
    fontSize: 16,
  },
  lockedFeatureLockIconCentered: {
    alignSelf: "center",
    textAlign: "center",
    textAlignVertical: "center",
  },
  lockedFeatureLockIconCompact: {
    fontSize: 12,
  },
  lockedFeaturePremiumPill: {
    alignSelf: "flex-start",
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 8,
    paddingVertical: 2,
  },
  lockedFeaturePremiumPillText: {
    ...createCtaText({ fontSize: 10, textTransform: "uppercase" }),
    letterSpacing: 0.4,
  },
  lockedFeatureTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 18,
    flexShrink: 1,
  },
  lockedFeatureTitleCentered: {
    textAlign: "center",
  },
  lockedFeatureTitleCompact: {
    fontSize: 14,
  },
  lockedFeatureDescription: {
    ...createBodyText({ fontSize: 14 }),
    lineHeight: 20,
    flexShrink: 1,
  },
  lockedFeatureDescriptionCentered: {
    textAlign: "center",
  },
  lockedFeatureDescriptionCompact: {
    fontSize: 11,
    lineHeight: 14,
  },
  lockedFeatureLevelBadge: {
    alignSelf: "flex-start",
    marginTop: 4,
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    maxWidth: "100%",
  },
  lockedFeatureLevelBadgeCentered: {
    alignSelf: "center",
  },
  lockedFeatureLevelBadgeCompact: {
    marginTop: 2,
    paddingHorizontal: 8,
    paddingVertical: 4,
  },
  lockedFeatureLevelText: {
    fontSize: 12,
    fontWeight: "700",
    flexShrink: 1,
    textAlign: "center",
  },
  lockedFeatureLevelTextCompact: {
    fontSize: 10,
  },
  lockedFeaturePlaceholder: {
    borderRadius: 20,
    borderWidth: 1,
    padding: 18,
    gap: 10,
    minHeight: 140,
  },
  lockedFeaturePlaceholderCompact: {
    borderRadius: 20,
    borderWidth: 1,
    padding: 16,
    gap: 8,
    minHeight: 110,
  },
  lockedFeaturePlaceholderSquare: {
    aspectRatio: 1,
    width: "100%",
    minHeight: 0,
  },
  lockedFeaturePlaceholderLine: {
    height: 10,
    borderRadius: 6,
  },
  lockedFeatureCard: {
    borderRadius: 20,
    marginTop: 12,
  },
  lockedFeatureRow: {
    flexDirection: "row",
    gap: 12,
    marginTop: 12,
  },
  lockedFeatureMiniCard: {
    flex: 1,
    borderRadius: 18,
  },
  lockedFeatureInlineCard: {
    borderRadius: 20,
  },
  lockedFeaturePane: {
    borderRadius: 24,
    minHeight: 220,
  },
  lockedFeaturePaneContent: {
    padding: 6,
  },
  lockedFeatureScreen: {
    flex: 1,
  },
  lockedFeatureScreenContent: {
    flex: 1,
  },
  skinPickerItem: {
    flexDirection: "row",
    alignItems: "center",
    borderWidth: 1,
    borderRadius: 18,
    padding: 12,
    gap: 12,
    marginBottom: 12,
  },
  skinPickerAvatar: {
    width: 56,
    height: 56,
    borderRadius: 18,
  },
  skinPickerItemTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 16,
  },
  skinPickerItemSubtitle: {
    ...createBodyText({ fontSize: 13 }),
  },
  skinPickerBadge: {
    borderWidth: 1,
    borderRadius: 999,
    paddingHorizontal: 10,
    paddingVertical: 4,
  },
  skinPickerBadgeText: {
    ...createCtaText({ fontSize: 10, textTransform: "uppercase" }),
  },
  skinPickerLockedBadge: {
    opacity: 0.85,
  },
  skinPickerLockedBadgeText: {
    letterSpacing: 0.5,
  },
  tamagotchiBackdrop: {
    flex: 1,
    justifyContent: "flex-start",
    alignItems: "stretch",
    paddingHorizontal: 8,
    paddingVertical: 6,
    overflow: "hidden",
  },
  tamagotchiBackdropDecor: {
    position: "absolute",
    top: -110,
    left: -70,
    width: 280,
    height: 280,
    borderRadius: 999,
  },
  tamagotchiBackdropDecorSecondary: {
    position: "absolute",
    bottom: 60,
    right: -90,
    width: 250,
    height: 250,
    borderRadius: 999,
  },
  partyGlowOverlay: {
    ...StyleSheet.absoluteFillObject,
  },
  partyFireworksOverlay: {
    ...StyleSheet.absoluteFillObject,
  },
  partyFireworkRing: {
    position: "absolute",
    borderWidth: 2,
    opacity: 0,
  },
  partySparklesOverlay: {
    ...StyleSheet.absoluteFillObject,
  },
  partySparkle: {
    position: "absolute",
    shadowColor: "#FFFFFF",
    shadowOpacity: 0.8,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 0 },
    elevation: 3,
  },
  tamagotchiCard: {
    flex: 1,
    width: "100%",
    maxWidth: "100%",
    borderRadius: 30,
    borderWidth: 1,
    overflow: "hidden",
    shadowColor: "#0A1324",
    shadowOpacity: 0.18,
    shadowRadius: 22,
    shadowOffset: { width: 0, height: 12 },
    elevation: 14,
  },
  tamagotchiGestureWrapper: {
    ...StyleSheet.absoluteFillObject,
    alignItems: "flex-start",
    zIndex: 80,
    elevation: 80,
  },
  tamagotchiGestureEdge: {
    position: "absolute",
    left: 0,
    width: TAMAGOTCHI_CLOSE_EDGE_WIDTH,
    bottom: 0,
  },
  tamagotchiCardScroll: {
    flex: 1,
  },
  tamagotchiCardContent: {
    paddingHorizontal: IS_SHORT_DEVICE ? 16 : 18,
    gap: IS_SHORT_DEVICE ? 10 : 12,
  },
  tamagotchiStickyRewardWrap: {
    position: "absolute",
    right: 12,
    zIndex: 32,
  },
  tamagotchiStickyBackWrap: {
    position: "absolute",
    left: 10,
    zIndex: 33,
  },
  tamagotchiStickyOverlayStack: {
    alignItems: "flex-end",
    gap: 6,
  },
  tamagotchiStickyRewardButton: {
    minWidth: 112,
    maxWidth: 176,
    borderWidth: 1,
    borderRadius: 14,
    paddingHorizontal: 10,
    paddingVertical: 6,
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
    shadowOpacity: 0.2,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 4 },
    elevation: 8,
  },
  tamagotchiStickyRewardText: {
    ...createCtaText({ fontSize: 11 }),
    flexShrink: 1,
  },
  tamagotchiStickyCoinsPill: {
    borderWidth: 1,
    borderRadius: 999,
    paddingHorizontal: 10,
    paddingVertical: 5,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "flex-start",
    gap: 8,
    shadowColor: "#0A1324",
    shadowOpacity: 0.16,
    shadowRadius: 8,
    shadowOffset: { width: 0, height: 4 },
    elevation: 5,
  },
  tamagotchiStickyCoinToken: {
    flexDirection: "row",
    alignItems: "center",
    gap: 4,
  },
  tamagotchiStickyCoinsIcon: {
    width: 15,
    height: 15,
  },
  tamagotchiStickyCoinsValue: {
    ...createCtaText({ fontSize: 12 }),
  },
  tamagotchiHeader: {
    minHeight: 44,
  },
  tamagotchiBackButton: {
    minWidth: 66,
    height: 34,
    borderRadius: 10,
    borderWidth: 1,
    paddingHorizontal: 8,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 4,
    marginTop: 0,
    shadowOpacity: 0.16,
    shadowRadius: 8,
    shadowOffset: { width: 0, height: 4 },
    elevation: 4,
  },
  tamagotchiBackButtonFloating: {
    minWidth: 74,
    height: 38,
    borderRadius: 12,
    paddingHorizontal: 10,
  },
  tamagotchiBackButtonArrow: {
    ...createCtaText({ fontSize: 15 }),
    lineHeight: 15,
  },
  tamagotchiBackButtonText: {
    ...createCtaText({ fontSize: 12 }),
  },
  tamagotchiHeaderTextWrap: {
    flex: 1,
    minHeight: 44,
    justifyContent: "flex-start",
    alignSelf: "flex-start",
  },
  tamagotchiHeaderLine: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    minHeight: 40,
  },
  tamagotchiTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: IS_SHORT_DEVICE ? 29 : 32,
    lineHeight: IS_SHORT_DEVICE ? 31 : 34,
    textAlign: "left",
    flexShrink: 0,
  },
  tamagotchiMood: {
    ...createBodyText({ fontSize: IS_SHORT_DEVICE ? 14 : 15, lineHeight: 18 }),
    textAlign: "left",
    flexShrink: 1,
  },
  tamagotchiStatsStack: {
    gap: 8,
    borderWidth: 1,
    borderRadius: 24,
    paddingHorizontal: 14,
    paddingVertical: 14,
    shadowColor: "#0A1324",
    shadowOpacity: 0.08,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 4 },
    elevation: 3,
  },
  tamagotchiStatRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  tamagotchiStatLabel: {
    ...createBodyText({ fontSize: 14 }),
  },
  tamagotchiStatValue: {
    ...createBodyText({ fontSize: 16, fontWeight: "700" }),
  },
  tamagotchiProgress: {
    height: 13,
    borderRadius: 999,
    overflow: "hidden",
  },
  tamagotchiProgressFill: {
    height: "100%",
    borderRadius: 999,
  },
  tamagotchiActions: {
    flexDirection: "row",
    gap: 10,
    marginTop: 8,
    marginBottom: 6,
  },
  tamagotchiActionsSingle: {
    marginTop: 10,
  },
  tamagotchiButton: {
    flex: 1,
    paddingVertical: IS_SHORT_DEVICE ? 12 : 13,
    borderRadius: 16,
    borderWidth: 1,
    alignItems: "center",
    shadowColor: "#0A1324",
    shadowOpacity: 0.12,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 5 },
    elevation: 4,
  },
  tamagotchiPartyButton: {
    borderRadius: 18,
  },
  tamagotchiButtonContent: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  tamagotchiButtonIcon: {
    width: 20,
    height: 20,
  },
  tamagotchiRewardIcon: {
    fontSize: 16,
  },
  tamagotchiPreview: {
    width: "100%",
    alignItems: "center",
    justifyContent: "center",
    borderWidth: 1,
    borderRadius: 30,
    paddingTop: 26,
    paddingBottom: 20,
    marginBottom: 4,
    overflow: "hidden",
    shadowColor: "#0A1324",
    shadowOpacity: 0.14,
    shadowRadius: 14,
    shadowOffset: { width: 0, height: 8 },
    elevation: 7,
  },
  tamagotchiPreviewAura: {
    position: "absolute",
    top: -34,
    width: 240,
    height: 180,
    borderRadius: 120,
  },
  tamagotchiPreviewAuraSecondary: {
    position: "absolute",
    bottom: -42,
    right: -28,
    width: 160,
    height: 120,
    borderRadius: 100,
  },
  tamagotchiMascotWrap: {
    position: "relative",
    alignItems: "center",
    justifyContent: "center",
    minHeight: 228,
  },
  tamagotchiMascotLarge: {
    width: 172,
    height: 172,
  },
  tamagotchiToyOrbit: {
    position: "absolute",
    zIndex: 10,
  },
  tamagotchiToyOrbitText: {
    fontSize: 30,
  },
  tamagotchiHeartBurst: {
    position: "absolute",
    bottom: 26,
    left: "50%",
    marginLeft: -8,
    zIndex: 9,
  },
  tamagotchiHeartBurstText: {
    fontSize: 20,
  },
  tamagotchiCleanTapOverlay: {
    position: "absolute",
    bottom: -4,
    right: 2,
    zIndex: 8,
    borderRadius: 999,
    paddingHorizontal: 8,
    paddingVertical: 3,
    backgroundColor: "rgba(255,255,255,0.82)",
  },
  tamagotchiCleanTapOverlayText: {
    fontSize: 15,
  },
  tamagotchiCleanSwipeBubble: {
    position: "absolute",
    top: -14,
    alignSelf: "center",
    borderWidth: 1,
    borderRadius: 12,
    paddingHorizontal: 10,
    paddingVertical: 4,
    maxWidth: 180,
    zIndex: 9,
  },
  tamagotchiCleanSwipeBubbleText: {
    ...createCtaText({ fontSize: 10, textAlign: "center" }),
  },
  tamagotchiShieldOverlay: {
    position: "absolute",
    top: -8,
    left: -8,
    width: 34,
    height: 34,
    borderRadius: 17,
    backgroundColor: "rgba(255,255,255,0.92)",
    borderWidth: 1,
    borderColor: "rgba(47,112,255,0.45)",
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "rgba(47,112,255,0.35)",
    shadowOpacity: 0.35,
    shadowRadius: 8,
    shadowOffset: { width: 0, height: 3 },
    elevation: 5,
  },
  tamagotchiShieldOverlayIcon: {
    fontSize: 18,
  },
  tamagotchiImmunityHintBubble: {
    position: "absolute",
    top: -30,
    right: "50%",
    marginRight: 74,
    borderRadius: 14,
    borderWidth: 1,
    paddingHorizontal: 8,
    paddingVertical: 6,
    shadowColor: "#0A1324",
    shadowOpacity: 0.25,
    shadowRadius: 12,
    shadowOffset: { width: 0, height: 6 },
    elevation: 10,
    zIndex: 20,
    alignItems: "flex-start",
  },
  tamagotchiImmunityPill: {
    marginTop: 2,
    marginBottom: 4,
    borderRadius: 12,
    borderWidth: 1,
    paddingHorizontal: 10,
    paddingVertical: 6,
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
    alignSelf: "flex-start",
  },
  tamagotchiImmunityPillIcon: {
    fontSize: 14,
  },
  tamagotchiImmunityPillText: {
    ...createBodyText({ fontSize: 12 }),
    fontWeight: "700",
  },
  tamagotchiButtonText: {
    ...createCtaText({ fontSize: 14 }),
  },
  tamagotchiFoodTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 28,
    lineHeight: 32,
    marginTop: IS_SHORT_DEVICE ? 8 : 10,
    marginBottom: 6,
    position: "relative",
    zIndex: 4,
  },
  tamagotchiTabsRow: {
    flexDirection: "row",
    gap: 10,
    marginTop: 6,
  },
  tamagotchiTabButton: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 14,
    paddingVertical: 9,
    paddingHorizontal: 6,
    alignItems: "center",
    justifyContent: "center",
    ...Platform.select({
      android: {
        elevation: 0,
      },
      default: {
        shadowOpacity: 0.12,
        shadowRadius: 8,
        shadowOffset: { width: 0, height: 4 },
      },
    }),
  },
  tamagotchiTabButtonText: {
    ...createCtaText({ fontSize: 12 }),
  },
  tamagotchiTabContentWrap: {
    minHeight: 180,
    marginTop: 2,
    overflow: "hidden",
  },
  tamagotchiFoodList: {
    marginTop: IS_SHORT_DEVICE ? 1 : 2,
    paddingTop: 20,
    paddingBottom: 2,
  },
  tamagotchiFoodScroll: {
    height: Math.min(IS_SHORT_DEVICE ? 250 : 290, SCREEN_HEIGHT * (IS_SHORT_DEVICE ? 0.38 : 0.42)),
    overflow: "hidden",
  },
  tamagotchiFoodButton: {
    flexDirection: "row",
    alignItems: "center",
    borderWidth: 1,
    borderRadius: 20,
    paddingTop: IS_SHORT_DEVICE ? 12 : 14,
    paddingBottom: IS_SHORT_DEVICE ? 9 : 11,
    paddingHorizontal: IS_SHORT_DEVICE ? 12 : 14,
    gap: IS_SHORT_DEVICE ? 10 : 12,
    position: "relative",
    marginBottom: IS_SHORT_DEVICE ? 6 : 8,
    ...Platform.select({
      android: {
        elevation: 0,
      },
      default: {
        shadowOpacity: 0.1,
        shadowRadius: 8,
        shadowOffset: { width: 0, height: 4 },
      },
    }),
  },
  tamagotchiFoodButtonWanted: {
    ...Platform.select({
      android: {
        elevation: 0,
      },
      default: {
        shadowOpacity: 0.2,
        shadowRadius: 14,
        shadowOffset: { width: 0, height: 8 },
      },
    }),
    paddingTop: IS_SHORT_DEVICE ? 16 : 18,
  },
  tamagotchiFoodButtonLast: {
    marginBottom: 0,
  },
  tamagotchiFoodButtonDisabled: {
    opacity: 0.5,
  },
  tamagotchiFoodEmoji: {
    fontSize: IS_SHORT_DEVICE ? 24 : 28,
  },
  tamagotchiFoodInfo: {
    flex: 1,
    gap: 2,
  },
  tamagotchiFoodLabel: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: IS_SHORT_DEVICE ? 14 : 15,
  },
  tamagotchiFoodBoost: {
    ...createSecondaryText({ fontSize: IS_SHORT_DEVICE ? 11 : 12 }),
  },
  tamagotchiFoodCost: {
    flexDirection: "row",
    alignItems: "center",
    gap: 4,
  },
  tamagotchiToyMetaWrap: {
    alignItems: "flex-end",
    justifyContent: "center",
    minWidth: 62,
    gap: 1,
  },
  tamagotchiFoodCostIcon: {
    width: 18,
    height: 18,
  },
  tamagotchiFoodCostText: {
    ...createCtaText({ fontSize: 13 }),
  },
  tamagotchiToyPenaltyWrap: {
    alignItems: "flex-end",
    justifyContent: "center",
    minWidth: 44,
  },
  tamagotchiToyPenaltyText: {
    ...createCtaText({ fontSize: 12 }),
    lineHeight: 14,
  },
  tamagotchiToyPenaltySub: {
    ...createSecondaryText({ fontSize: 10 }),
    lineHeight: 12,
  },
  tamagotchiFoodBadge: {
    position: "absolute",
    top: -8,
    right: 8,
    borderRadius: 999,
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderWidth: 1,
    borderColor: "rgba(255,255,255,0.28)",
    alignItems: "center",
    justifyContent: "center",
    maxWidth: SCREEN_WIDTH * 0.55,
    shadowColor: "#0A1324",
    shadowOpacity: 0.18,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 3 },
    elevation: 4,
    zIndex: 10,
  },
  tamagotchiFoodBadgeText: {
    ...createCtaText({ fontSize: 9, textTransform: "uppercase" }),
    letterSpacing: 0.45,
    flexShrink: 1,
    textAlign: "center",
    lineHeight: 10,
  },
  tamagotchiSub: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  tamagotchiCleanPanel: {
    marginTop: 4,
    gap: 8,
  },
  tamagotchiCleanHint: {
    ...createSecondaryText({ fontSize: 12 }),
    textAlign: "center",
  },
  tamagotchiCleanTapHint: {
    ...createBodyText({ fontSize: 13, textAlign: "center" }),
    fontWeight: "700",
  },
  tamagotchiCleanToolsRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  tamagotchiCleanToolButton: {
    width: "48%",
    borderWidth: 1,
    borderRadius: 12,
    paddingVertical: 8,
    paddingHorizontal: 8,
    gap: 7,
  },
  tamagotchiCleanToolTop: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  tamagotchiCleanToolEmoji: {
    fontSize: 18,
  },
  tamagotchiCleanToolLabel: {
    ...createBodyText({ fontSize: 11 }),
    flex: 1,
  },
  tamagotchiCleanToolBarWrap: {
    gap: 4,
  },
  tamagotchiCleanToolBarTrack: {
    height: 6,
    borderRadius: 999,
    overflow: "hidden",
  },
  tamagotchiCleanToolBarFill: {
    height: "100%",
    borderRadius: 999,
  },
  tamagotchiCleanToolAmountText: {
    ...createSecondaryText({ fontSize: 10 }),
  },
  tamagotchiCleanToolActionButton: {
    marginTop: 1,
    borderWidth: 1,
    borderRadius: 10,
    paddingVertical: 6,
    paddingHorizontal: 8,
    alignItems: "center",
    justifyContent: "center",
  },
  tamagotchiCleanToolActionText: {
    ...createCtaText({ fontSize: 11 }),
  },
  tamagotchiCleanToolBuyWrap: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 4,
  },
  tamagotchiCleanSupplyHint: {
    ...createSecondaryText({ fontSize: 11, textAlign: "center" }),
    marginTop: 2,
  },
  tamagotchiCleanProgressGroup: {
    gap: 4,
    marginTop: 2,
  },
  tamagotchiCleanProgressRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  tamagotchiCleanProgressLabel: {
    ...createSecondaryText({ fontSize: 11 }),
  },
  tamagotchiCleanProgressValue: {
    ...createCtaText({ fontSize: 11 }),
  },
  tamagotchiCleanTapButton: {
    marginTop: 2,
    borderWidth: 1,
    borderRadius: 12,
    paddingVertical: 10,
    alignItems: "center",
    justifyContent: "center",
  },
  tamagotchiCleanTapButtonText: {
    ...createCtaText({ fontSize: 13 }),
  },
  tamagotchiHint: {
    ...createSecondaryText({ fontSize: 12, textAlign: "center" }),
    marginTop: 4,
  },
  tamagotchiClose: {
    alignSelf: "center",
    marginTop: 6,
    paddingVertical: 6,
    paddingHorizontal: 12,
  },
  tamagotchiCloseText: {
    ...createCtaText({ fontSize: 14 }),
  },
  heroStatCard: {
    padding: 16,
    borderRadius: 24,
    marginTop: 18,
  },
  heroStatRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  heroStatLabel: {
    textTransform: "uppercase",
    fontSize: 12,
  },
  heroStatValue: {
    fontSize: 24,
    fontWeight: "700",
  },
  heroSpendLine: {
    fontSize: Platform.OS === "ios" ? 16 : 18,
    lineHeight: Platform.OS === "ios" ? 20 : 22,
    fontWeight: "600",
    marginTop: Platform.OS === "ios" ? 6 : 10,
  },
  progressHeroCard: {
    marginTop: 10,
    borderRadius: 28,
    padding: 18,
    borderWidth: 1,
  },
  savedHeroCard: {
    marginTop: 12,
    padding: IS_SHORT_DEVICE ? 16 : 22,
    borderRadius: 30,
    shadowOpacity: 0.12,
    shadowRadius: 26,
    shadowOffset: { width: 0, height: 12 },
    elevation: 9,
    overflow: "hidden",
    position: "relative",
  },
  savedHeroGlowWrap: {
    ...StyleSheet.absoluteFillObject,
    zIndex: 0,
  },
  savedHeroGlow: {
    position: "absolute",
    width: 220,
    height: 220,
    borderRadius: 110,
    top: -120,
    left: -40,
    opacity: 0.35,
    zIndex: -1,
  },
  savedHeroGlowBottom: {
    width: 200,
    height: 200,
    bottom: -120,
    right: -40,
    zIndex: -1,
  },
  savedHeroContent: {
    position: "relative",
    zIndex: 1,
  },
  heroBudgetCard: {
    gap: 12,
  },
  heroBudgetHeader: {
    flexDirection: "row",
    alignItems: "flex-start",
    justifyContent: "space-between",
    gap: 12,
  },
  heroBudgetTitleBlock: {
    flex: 1,
  },
  heroBudgetTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 18,
  },
  heroBudgetSubtitle: {
    ...createSecondaryText({ fontSize: 12 }),
    marginTop: 2,
  },
  heroBudgetChip: {
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 10,
    paddingVertical: 4,
  },
  heroBudgetChipText: {
    ...createCtaText({ fontSize: 10, textTransform: "uppercase" }),
  },
  heroBudgetSummary: {
    flexDirection: "row",
    alignItems: "baseline",
    justifyContent: "space-between",
    gap: 8,
  },
  heroBudgetSummaryLabel: {
    ...createSecondaryText({ fontSize: 10, textTransform: "uppercase" }),
  },
  heroBudgetSummaryValue: {
    ...TYPOGRAPHY.display,
    fontSize: 22,
  },
  heroBudgetCategoryList: {
    gap: 8,
  },
  heroBudgetRow: {
    gap: 6,
  },
  heroBudgetRowHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 8,
  },
  heroBudgetRowTitle: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    flex: 1,
  },
  heroBudgetRowEmoji: {
    fontSize: 16,
  },
  heroBudgetRowLabel: {
    ...createBodyText({ fontSize: 12, fontWeight: "600" }),
    flex: 1,
  },
  heroBudgetRowValue: {
    ...createBodyText({ fontSize: 12, fontWeight: "700" }),
  },
  heroBudgetRowTrack: {
    height: 8,
    borderRadius: 999,
    overflow: "hidden",
    position: "relative",
  },
  heroBudgetRowFill: {
    height: "100%",
    borderRadius: 999,
    position: "absolute",
    left: 0,
  },
  heroBudgetRowOverflow: {
    height: "100%",
    borderRadius: 999,
    position: "absolute",
    right: 0,
  },
  heroBudgetEmpty: {
    alignItems: "center",
    gap: 6,
    paddingVertical: 6,
  },
  heroBudgetEmptyTitle: {
    ...createBodyText({ fontSize: 14, fontWeight: "700", textAlign: "center" }),
  },
  heroBudgetEmptySubtitle: {
    ...createSecondaryText({ fontSize: 12, textAlign: "center" }),
  },
  heroDailyCard: {
    gap: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  heroDailyHeader: {
    width: "100%",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 8,
  },
  heroDailyTitle: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase" }),
  },
  heroDailyChip: {
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 8,
    paddingVertical: 3,
  },
  heroDailyChipText: {
    ...createSecondaryText({ fontSize: 10 }),
  },
  heroDailyAmount: {
    ...TYPOGRAPHY.display,
    fontSize: 34,
    textAlign: "center",
  },
  heroDailySubtitle: {
    ...createSecondaryText({ fontSize: 12, textAlign: "center" }),
  },
  heroDailyEmpty: {
    alignItems: "center",
    gap: 6,
    paddingVertical: 6,
  },
  heroDailyEmptyTitle: {
    ...createBodyText({ fontSize: 14, fontWeight: "700", textAlign: "center" }),
  },
  heroDailyEmptySubtitle: {
    ...createSecondaryText({ fontSize: 12, textAlign: "center" }),
  },
  heroDailyGoalBody: {
    width: "100%",
    alignItems: "center",
    justifyContent: "center",
    gap: 12,
    flex: 1,
  },
  piggyWrap: {
    width: "100%",
    alignItems: "center",
    justifyContent: "center",
    paddingVertical: 2,
    position: "relative",
  },
  piggyBodyWrap: {
    width: IS_SHORT_DEVICE ? 160 : 176,
    height: IS_SHORT_DEVICE ? 160 : 176,
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
  },
  piggyShadow: {
    position: "absolute",
    bottom: -8,
    width: "78%",
    height: 14,
    borderRadius: 999,
    backgroundColor: "rgba(0,0,0,0.08)",
    opacity: 0.45,
  },
  piggyBody: {
    width: IS_SHORT_DEVICE ? 150 : 170,
    height: IS_SHORT_DEVICE ? 134 : 152,
    borderRadius: 999,
    borderWidth: 1,
    overflow: "hidden",
    alignItems: "center",
    justifyContent: "center",
    shadowOpacity: 0.2,
    shadowRadius: 14,
    shadowOffset: { width: 0, height: 8 },
    elevation: 4,
  },
  piggyCoinsClip: {
    ...StyleSheet.absoluteFillObject,
    paddingHorizontal: PIGGY_COIN_PADDING_X,
    paddingVertical: PIGGY_COIN_PADDING_Y,
    zIndex: 3,
  },
  piggyCoin: {
    position: "absolute",
    resizeMode: "contain",
  },
  piggyGlassBlur: {
    opacity: 0.45,
  },
  piggyGlassBlurFallback: {
    opacity: 0.35,
  },
  piggyGlassInner: {
    position: "absolute",
    top: 6,
    left: 6,
    right: 6,
    bottom: 6,
    borderRadius: 999,
    borderWidth: 1,
    opacity: 0.55,
  },
  piggyGlassHighlight: {
    position: "absolute",
    top: 8,
    left: 18,
    width: "34%",
    height: "72%",
    borderRadius: 80,
    transform: [{ rotate: "-14deg" }],
  },
  piggyGlassHighlightSecondary: {
    top: 16,
    left: "52%",
    width: "18%",
    height: "46%",
    opacity: 0.35,
    transform: [{ rotate: "10deg" }],
  },
  piggyGlassRim: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    height: 7,
    opacity: 0.7,
  },
  piggyLid: {
    position: "absolute",
    top: 4,
    left: "12%",
    right: "12%",
    height: 16,
    borderRadius: 12,
    borderWidth: 1,
    zIndex: 6,
    shadowOpacity: 0.25,
    shadowRadius: 8,
    shadowOffset: { width: 0, height: 4 },
    elevation: 6,
  },
  piggyLidHighlight: {
    position: "absolute",
    top: 6,
    left: "18%",
    right: "18%",
    height: 5,
    borderRadius: 6,
    opacity: 0.65,
    zIndex: 7,
  },
  piggyLidKnob: {
    position: "absolute",
    top: 3,
    left: "50%",
    width: 18,
    height: 8,
    marginLeft: -9,
    borderRadius: 6,
    borderWidth: 1,
    zIndex: 7,
  },
  piggyCollectLabel: {
    ...createSecondaryText({ fontSize: 11, textAlign: "center" }),
    marginBottom: 4,
    textTransform: "lowercase",
  },
  piggyGoalValueWrap: {
    position: "absolute",
    left: 10,
    right: 10,
    top: "30%",
    alignItems: "center",
    zIndex: 4,
  },
  piggyGoalValue: {
    ...TYPOGRAPHY.display,
    fontSize: IS_SHORT_DEVICE ? 24 : 28,
    textAlign: "center",
    letterSpacing: -0.4,
  },
  piggyGoalCheck: {
    ...TYPOGRAPHY.display,
    fontSize: IS_SHORT_DEVICE ? 34 : 38,
    lineHeight: IS_SHORT_DEVICE ? 38 : 42,
    textAlign: "center",
    letterSpacing: -0.3,
  },
  piggyEarLeft: {
    position: "absolute",
    top: -16,
    left: "32%",
    width: 24,
    height: 24,
    borderRadius: 999,
    borderWidth: 1,
    zIndex: 3,
  },
  piggyEarRight: {
    position: "absolute",
    top: -16,
    left: "58%",
    width: 24,
    height: 24,
    borderRadius: 999,
    borderWidth: 1,
    zIndex: 3,
  },
  piggySnout: {
    position: "absolute",
    left: "50%",
    top: "54%",
    width: 46,
    height: 28,
    marginLeft: -23,
    borderRadius: 14,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
    zIndex: 3,
  },
  piggyNostrilRow: {
    flexDirection: "row",
    gap: 8,
  },
  piggyNostril: {
    width: 5,
    height: 5,
    borderRadius: 3,
    opacity: 0.7,
  },
  piggyLegLeft: {
    position: "absolute",
    left: "34%",
    bottom: -8,
    width: 22,
    height: 12,
    borderRadius: 6,
    borderWidth: 1,
    zIndex: 2,
  },
  piggyLegRight: {
    position: "absolute",
    left: "54%",
    bottom: -8,
    width: 22,
    height: 12,
    borderRadius: 6,
    borderWidth: 1,
    zIndex: 2,
  },
  piggyTail: {
    position: "absolute",
    left: -6,
    top: "60%",
    width: 20,
    height: 4,
    borderRadius: 999,
    opacity: 0.6,
  },
  piggyDropCoin: {
    position: "absolute",
    top: -12,
    left: "50%",
    width: IS_SHORT_DEVICE ? 24 : 28,
    height: IS_SHORT_DEVICE ? 24 : 28,
    marginLeft: IS_SHORT_DEVICE ? -12 : -14,
    zIndex: 5,
    resizeMode: "contain",
  },
  savedHeroHeader: {
    marginBottom: 4,
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
  },
  savedHeroTitleWrap: {
    flex: 1,
    paddingRight: 8,
  },
  savedHeroSubtitle: {
    ...createBodyText({
      fontSize: Platform.OS === "ios" ? 12 : 14,
      marginTop: 6,
      marginBottom: 10,
      lineHeight: Platform.OS === "ios" ? 18 : 20,
      width: "100%",
      textAlign: "center",
    }),
  },
  savedHeroRecentList: {
    width: "100%",
    alignSelf: "stretch",
    marginTop: 10,
    gap: Platform.OS === "ios" ? 4 : 6,
    marginBottom: 10,
    paddingHorizontal: 6,
  },
  savedHeroRecentTitle: {
    ...createCtaText({ fontSize: 10, textTransform: "uppercase" }),
  },
  savedHeroRecentItem: {
    ...createBodyText({
      fontSize: Platform.OS === "ios" ? 11 : 12,
      lineHeight: Platform.OS === "ios" ? 15 : 17,
    }),
    width: "100%",
    flexShrink: 1,
    textAlign: "left",
  },
  savedHeroDivider: {
    height: 1,
    width: "100%",
    opacity: 0.6,
    marginTop: 2,
    marginBottom: 12,
  },
  dailyRewardButton: {
    borderRadius: 16,
    borderWidth: 1,
    paddingVertical: 3,
    paddingHorizontal: 10,
    alignItems: "center",
    justifyContent: "center",
    gap: 4,
  },
  dailyRewardCoin: {
    width: 22,
    height: 22,
    resizeMode: "contain",
  },
  dailyRewardAmount: {
    fontSize: 12,
    fontWeight: "800",
    lineHeight: 14,
  },
  dailyRewardCaption: {
    fontSize: 7,
    fontWeight: "600",
    textTransform: "none",
    textAlign: "center",
    includeFontPadding: false,
    lineHeight: 9,
  },
  dailyRewardLockedIcon: {
    fontSize: 12,
    lineHeight: 14,
  },
  dailyRewardLockedLabel: {
    fontSize: 9,
    fontWeight: "700",
    textTransform: "uppercase",
    textAlign: "center",
    includeFontPadding: false,
    lineHeight: 12,
  },
  dailyRewardFloating: {
    position: "absolute",
    right: 0,
    zIndex: 2,
    elevation: 2,
  },
  dailyRewardModalLayer: {
    flex: 1,
  },
  dailyRewardModalBackdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(0,0,0,0.35)",
  },
  dailyRewardModalWrap: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    padding: IS_SHORT_DEVICE ? 12 : 20,
    justifyContent: "center",
    alignItems: "center",
  },
  dailyRewardModalCard: {
    width: "100%",
    maxWidth: 372,
    borderRadius: 28,
    borderWidth: 1,
    paddingVertical: IS_SHORT_DEVICE ? 16 : 20,
    paddingHorizontal: IS_SHORT_DEVICE ? 14 : 18,
    maxHeight: IS_SHORT_DEVICE ? SCREEN_HEIGHT * 0.8 : undefined,
    overflow: "hidden",
    shadowColor: "#000",
    shadowOpacity: 0.2,
    shadowOffset: { width: 0, height: 14 },
    shadowRadius: 24,
    elevation: 8,
    gap: 12,
  },
  dailyRewardModalFlash: {
    ...StyleSheet.absoluteFillObject,
  },
  dailyRewardModalHalo: {
    position: "absolute",
    width: 220,
    height: 220,
    borderRadius: 999,
    borderWidth: 1,
    top: -80,
    right: -56,
  },
  dailyRewardModalHeaderRow: {
    alignItems: "center",
    gap: 8,
  },
  dailyRewardModalPill: {
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 12,
    paddingVertical: 5,
  },
  dailyRewardModalPillText: {
    fontSize: 11,
    fontWeight: "800",
    letterSpacing: 0.4,
    textTransform: "uppercase",
  },
  dailyRewardModalTitle: {
    fontSize: IS_SHORT_DEVICE ? 20 : 22,
    fontWeight: "900",
    textAlign: "center",
    letterSpacing: -0.3,
  },
  dailyRewardModalHero: {
    alignItems: "center",
    gap: 8,
    marginTop: 2,
  },
  dailyRewardModalCoinOrbit: {
    width: IS_SHORT_DEVICE ? 74 : 82,
    height: IS_SHORT_DEVICE ? 74 : 82,
    borderRadius: 999,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "#000",
    shadowOpacity: 0.12,
    shadowOffset: { width: 0, height: 6 },
    shadowRadius: 12,
    elevation: 3,
  },
  dailyRewardModalCoinIcon: {
    width: IS_SHORT_DEVICE ? 44 : 52,
    height: IS_SHORT_DEVICE ? 44 : 52,
    resizeMode: "contain",
  },
  dailyRewardModalHeroAmount: {
    fontSize: IS_SHORT_DEVICE ? 28 : 32,
    fontWeight: "900",
    letterSpacing: -0.6,
    lineHeight: IS_SHORT_DEVICE ? 32 : 36,
  },
  dailyRewardModalSubtitle: {
    fontSize: 13,
    fontWeight: "600",
    textAlign: "center",
    lineHeight: 18,
  },
  dailyRewardCalendar: {
    flexDirection: "row",
    alignItems: "stretch",
    justifyContent: "center",
    flexWrap: "wrap",
    gap: IS_SHORT_DEVICE ? 6 : 8,
  },
  dailyRewardCalendarDay: {
    minWidth: IS_SHORT_DEVICE ? 62 : 68,
    maxWidth: IS_SHORT_DEVICE ? 76 : 82,
    width: IS_SHORT_DEVICE ? 66 : 72,
    minHeight: IS_SHORT_DEVICE ? 64 : 70,
    paddingVertical: IS_SHORT_DEVICE ? 6 : 8,
    paddingHorizontal: IS_SHORT_DEVICE ? 6 : 8,
    borderRadius: 16,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
    gap: 2,
  },
  dailyRewardCalendarDayLabel: {
    fontSize: IS_SHORT_DEVICE ? 9 : 10,
    fontWeight: "700",
    textAlign: "center",
  },
  dailyRewardCalendarAmount: {
    fontSize: IS_SHORT_DEVICE ? 13 : 14,
    fontWeight: "900",
  },
  dailyRewardCalendarSuperLabel: {
    fontSize: IS_SHORT_DEVICE ? 8 : 9,
    fontWeight: "700",
    textTransform: "uppercase",
    letterSpacing: 0.5,
  },
  dailyRewardModalNoteWrap: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 6,
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 12,
    paddingVertical: 8,
  },
  dailyRewardModalNoteIcon: {
    fontSize: 13,
    lineHeight: 16,
  },
  dailyRewardModalNote: {
    fontSize: 12,
    fontWeight: "600",
    textAlign: "center",
    lineHeight: 16,
    flexShrink: 1,
  },
  dailyRewardModalActions: {
    flexDirection: "row",
    gap: 10,
    marginTop: IS_SHORT_DEVICE ? 2 : 4,
  },
  dailyRewardModalSecondary: {
    flex: 1,
    paddingVertical: IS_SHORT_DEVICE ? 10 : 12,
    borderRadius: 14,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  dailyRewardModalSecondaryText: {
    fontSize: 14,
    fontWeight: "800",
  },
  dailyRewardModalPrimary: {
    flex: 1,
    paddingVertical: IS_SHORT_DEVICE ? 11 : 13,
    borderRadius: 14,
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "#000",
    shadowOpacity: 0.14,
    shadowOffset: { width: 0, height: 6 },
    shadowRadius: 10,
    elevation: 2,
  },
  dailyRewardModalPrimaryText: {
    fontSize: 14,
    fontWeight: "900",
  },
  savedHeroAmountWrap: {
    marginTop: 2,
    marginBottom: 10,
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
  },
  heroLevelDetails: {
    borderRadius: 16,
    borderWidth: 1,
    padding: 12,
    marginBottom: 10,
  },
  heroLevelTitle: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  heroLevelSubtitle: {
    ...createBodyText({ fontSize: 12, marginTop: 6 }),
  },
  heroLevelMeta: {
    ...createSecondaryText({ marginTop: 8 }),
  },
  heroPotentialCard: {
    marginTop: 10,
    marginBottom: 12,
    borderRadius: 18,
    padding: 14,
    gap: 8,
  },
  heroPotentialBody: {
    ...createBodyText({ fontSize: 14 }),
  },
  heroPotentialHeader: {
    gap: 6,
  },
  heroPotentialRow: {
    flexDirection: "row",
    alignItems: "baseline",
    justifyContent: "space-between",
    width: "100%",
    gap: 12,
  },
  heroPotentialLabel: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
    lineHeight: 16,
    flex: 1,
  },
  heroPotentialValue: {
    ...createBodyText({ fontSize: 16, fontWeight: "700" }),
    lineHeight: 20,
    textAlign: "right",
  },
  heroPotentialHint: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  heroPotentialStatus: {
    ...createSecondaryText({ fontSize: 12 }),
    lineHeight: 16,
    flex: 1,
  },
  heroPotentialDelta: {
    ...createCtaText({ fontSize: 13 }),
    marginTop: 0,
    textAlign: "right",
  },
  heroPotentialButton: {
    borderWidth: 1,
    borderRadius: 999,
    paddingVertical: 8,
    alignItems: "center",
  },
  heroPotentialButtonText: {
    ...createCtaText(),
  },
  savedHeroProgressRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    marginBottom: 6,
  },
  savedHeroBar: {
    flex: 1,
    marginBottom: 0,
  },
  savedHeroPercentTag: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
  },
  savedHeroPercentText: {
    ...createCtaText({ fontSize: 12 }),
  },
  savedHeroGoalRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
    marginTop: 0,
    marginBottom: 8,
  },
  goalLabel: {
    ...createCtaText({ fontSize: 12 }),
  },
  savedHeroGoalPercent: {
    fontSize: 14,
    fontWeight: "700",
  },
  savedHeroGoalMetaRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
    marginTop: 8,
  },
  savedHeroGoalMetaActions: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  goalCompleteBadge: {
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 12,
    paddingVertical: 4,
  },
  goalCompleteBadgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  heroChallengeBlock: {
    marginTop: 10,
    borderRadius: 16,
    borderWidth: 1,
    padding: 10,
    gap: 6,
    opacity: 0.9,
  },
  heroChallengeRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 8,
  },
  heroChallengeTitleRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
    flex: 1,
  },
  heroChallengeEmoji: {
    fontSize: 16,
  },
  heroChallengeMeta: {
    ...createSecondaryText({ fontSize: 11 }),
  },
  heroChallengeName: {
    ...createBodyText({ fontSize: 13, fontWeight: "700" }),
    flex: 1,
  },
  heroChallengeProgressRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  heroChallengeBar: {
    flex: 1,
    height: 6,
    borderRadius: 999,
    overflow: "hidden",
  },
  heroChallengeFill: {
    height: "100%",
    borderRadius: 999,
  },
  heroChallengeLabel: {
    ...createSecondaryText({ fontSize: 11 }),
  },
  goalSelectButton: {
    marginTop: 10,
    paddingVertical: 10,
    paddingHorizontal: 14,
    borderRadius: 14,
    borderWidth: 1,
    alignItems: "center",
  },
  goalSelectText: {
    ...createCtaText({ fontSize: 13 }),
  },
  breakdownOverlay: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.45)",
    justifyContent: "center",
    alignItems: "center",
    padding: BREAKDOWN_OVERLAY_PADDING,
  },
  dailySummaryBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.6)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  dailyChallengeBackdrop: {
    flex: 1,
    backgroundColor: "rgba(7,9,16,0.68)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  dailySummaryCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 28,
    padding: 24,
    borderWidth: 1,
    overflow: "hidden",
  },
  dailySummaryGlow: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.12,
  },
  dailySummaryCardContent: {
    gap: 18,
  },
  dailySummaryHeroRow: {
    flexDirection: "row",
    gap: 12,
  },
  dailySummaryHeroText: {
    flex: 1,
  },
  dailySummaryIconWrap: {
    width: 56,
    height: 56,
    borderRadius: 18,
    alignItems: "center",
    justifyContent: "center",
    borderWidth: 1,
  },
  dailySummaryIconText: {
    fontSize: 28,
  },
  dailySummaryBadge: {
    alignSelf: "flex-start",
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 999,
    borderWidth: 1,
    marginBottom: 6,
  },
  dailySummaryBadgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  dailySummaryTitle: {
    ...TYPOGRAPHY.blockTitle,
  },
  dailySummarySubtitle: {
    ...createBodyText({ fontSize: 16, marginTop: 4 }),
  },
  dailySummaryHighlight: {
    borderRadius: 22,
    padding: 18,
    borderWidth: 1,
  },
  dailySummaryHighlightLabel: {
    ...createCtaText({ fontSize: 13, textTransform: "uppercase" }),
  },
  dailySummaryHighlightValue: {
    fontSize: 32,
    fontWeight: "800",
    marginTop: 8,
  },
  dailySummaryHighlightSub: {
    ...createBodyText({ fontSize: 14, marginTop: 6 }),
  },
  dailySummaryStatsRow: {
    flexDirection: "row",
    gap: 12,
  },
  dailySummaryStatCard: {
    flex: 1,
    borderRadius: 20,
    paddingVertical: 16,
    borderWidth: 1,
    alignItems: "center",
  },
  dailySummaryStatValue: {
    fontSize: 26,
    fontWeight: "800",
  },
  dailySummaryStatLabel: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase", marginTop: 8 }),
  },
  dailySummaryButton: {
    borderRadius: 18,
    paddingVertical: 14,
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "row",
    gap: 8,
  },
  dailySummaryButtonText: {
    ...createCtaText({ fontSize: 15 }),
  },
  dailySummaryButtonIcon: {
    ...createCtaText({ fontSize: 16 }),
  },
  dailySummaryHint: {
    ...createSecondaryText({ textAlign: "center" }),
  },
  ratingPromptBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.5)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  ratingPromptCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 26,
    padding: 24,
    gap: 16,
    borderWidth: 1,
  },
  ratingPromptCatWrap: {
    alignItems: "center",
  },
  ratingPromptCat: {
    width: 130,
    height: 130,
  },
  ratingPromptTitle: {
    ...TYPOGRAPHY.blockTitle,
    textAlign: "center",
  },
  ratingPromptBody: {
    ...createBodyText({ fontSize: 15, textAlign: "center" }),
  },
  ratingPromptActions: {
    flexDirection: "row",
    gap: 12,
  },
  ratingPromptSecondary: {
    flex: 1,
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
    borderWidth: 1,
  },
  ratingPromptSecondaryText: {
    ...createCtaText({ fontSize: 15 }),
  },
  ratingPromptPrimary: {
    flex: 1,
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
  },
  ratingPromptPrimaryText: {
    ...createCtaText({ fontSize: 15 }),
  },
  levelShareModalCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 28,
    padding: 22,
    borderWidth: 1,
    gap: 12,
  },
  levelShareModalTitle: {
    ...TYPOGRAPHY.blockTitle,
    textAlign: "center",
  },
  levelShareModalCaption: {
    ...createSecondaryText({ textAlign: "center" }),
  },
  levelShareShot: {
    width: "100%",
    borderRadius: 28,
    overflow: "hidden",
  },
  levelShareCanvas: {
    backgroundColor: LEVEL_SHARE_BG,
    borderRadius: 24,
    paddingVertical: 26,
    paddingHorizontal: 20,
    alignItems: "center",
    gap: 12,
  },
  levelShareBadge: {
    borderRadius: 999,
    paddingHorizontal: 18,
    paddingVertical: 6,
    backgroundColor: LEVEL_SHARE_ACCENT,
  },
  levelShareBadgeText: {
    color: "#1E0F00",
    fontWeight: "800",
    fontSize: 12,
    letterSpacing: 1,
  },
  levelShareCanvasTitle: {
    color: "#FFFFFF",
    fontSize: 32,
    fontWeight: "900",
    textTransform: "uppercase",
  },
  levelShareCanvasSubtitle: {
    color: LEVEL_SHARE_MUTED,
    fontSize: 15,
    textAlign: "center",
  },
  levelShareCat: {
    width: 180,
    height: 180,
    resizeMode: "contain",
  },
  levelShareJoin: {
    color: "#FFFFFF",
    fontSize: 16,
    fontWeight: "700",
    textAlign: "center",
  },
  levelShareInstagram: {
    color: LEVEL_SHARE_MUTED,
    fontSize: 13,
    fontWeight: "700",
    textAlign: "center",
  },
  levelShareFooter: {
    marginTop: 12,
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  levelShareLogo: {
    width: 48,
    height: 48,
    borderRadius: 16,
  },
  levelShareFooterBrand: {
    color: "#FFFFFF",
    fontSize: 18,
    fontWeight: "800",
  },
  levelShareFooterHint: {
    color: LEVEL_SHARE_MUTED,
    fontSize: 12,
    textTransform: "uppercase",
  },
  levelShareActions: {
    gap: 10,
  },
  levelSharePrimary: {
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
  },
  levelSharePrimaryText: {
    ...createCtaText({ fontSize: 15 }),
  },
  levelShareGhost: {
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
    borderWidth: 1,
  },
  levelShareGhostText: {
    ...createCtaText({ fontSize: 15 }),
  },
  dailyChallengeCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 30,
    padding: 24,
    borderWidth: 1,
    overflow: "hidden",
  },
  dailyChallengeGlow: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.25,
  },
  dailyChallengeContent: {
    gap: 20,
  },
  dailyChallengeHeroRow: {
    flexDirection: "row",
    alignItems: "flex-start",
    gap: 16,
  },
  dailyChallengeBadge: {
    alignSelf: "flex-start",
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 999,
    borderWidth: 1,
  },
  dailyChallengeBadgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  dailyChallengeTitle: {
    ...TYPOGRAPHY.blockTitle,
  },
  dailyChallengeSubtitle: {
    ...createBodyText({ fontSize: 15, marginTop: 4 }),
  },
  dailyChallengeRewardStack: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    flexWrap: "wrap",
  },
  dailyChallengeRewardHint: {
    ...createBodyText({ fontSize: 13 }),
    fontWeight: "700",
  },
  dailyChallengeTemptationRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    borderWidth: 1,
    borderRadius: 24,
    padding: 14,
    backgroundColor: "rgba(17,17,17,0.03)",
  },
  dailyChallengeEmojiCard: {
    width: 58,
    height: 58,
    borderRadius: 18,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "rgba(17,17,17,0.05)",
  },
  dailyChallengeEmojiCardText: {
    fontSize: 32,
  },
  dailyChallengeTemptationTitle: {
    fontSize: 16,
    fontWeight: "700",
  },
  dailyChallengeTemptationHint: {
    ...createBodyText({ fontSize: 14 }),
  },
  dailyChallengeActions: {
    flexDirection: "row",
    gap: 12,
  },
  dailyChallengeActionsWrap: {
    gap: 10,
  },
  dailyChallengeSkipButton: {
    alignSelf: "center",
    paddingVertical: 6,
    paddingHorizontal: 12,
  },
  dailyChallengeSkipText: {
    ...createCtaText({ fontSize: 13 }),
    textTransform: "uppercase",
    letterSpacing: 0.8,
  },
  dailyChallengePrimaryButton: {
    flex: 1,
    borderRadius: 18,
    paddingVertical: 14,
    alignItems: "center",
  },
  dailyChallengePrimaryText: {
    ...createCtaText({ fontSize: 15 }),
  },
  dailyChallengeGhostButton: {
    flex: 1,
    borderRadius: 18,
    paddingVertical: 14,
    alignItems: "center",
    borderWidth: 1,
  },
  dailyChallengeGhostText: {
    ...createCtaText({ fontSize: 15 }),
  },
  dailyChallengeDrawPanel: {
    width: "100%",
    maxWidth: 380,
    borderRadius: 28,
    padding: 20,
    borderWidth: 1,
    overflow: "hidden",
    gap: 16,
    shadowColor: "#000",
    shadowOpacity: 0.12,
    shadowRadius: 18,
    shadowOffset: { width: 0, height: 10 },
    elevation: 8,
  },
  dailyChallengeDrawGlow: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.22,
  },
  dailyChallengeDrawHeader: {
    gap: 8,
  },
  dailyChallengeDrawRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    gap: 10,
    alignItems: "flex-end",
  },
  dailyChallengeDrawCardWrap: {
    flex: 1,
    alignItems: "center",
  },
  dailyChallengeDrawCard: {
    position: "relative",
    borderRadius: 18,
    borderWidth: 1,
    overflow: "hidden",
    backgroundColor: "rgba(255,255,255,0.04)",
    shadowOpacity: 0.25,
    shadowRadius: 12,
    shadowOffset: { width: 0, height: 8 },
    elevation: 6,
  },
  dailyChallengeDrawCardFace: {
    ...StyleSheet.absoluteFillObject,
    borderRadius: 18,
    borderWidth: 1,
    backfaceVisibility: "hidden",
    alignItems: "center",
    justifyContent: "center",
    padding: 10,
  },
  dailyChallengeDrawCardBack: {
    overflow: "hidden",
  },
  dailyChallengeDrawCardBackGlow: {
    position: "absolute",
    top: -8,
    left: -12,
    right: -12,
    height: 48,
    borderRadius: 40,
    opacity: 0.6,
    transform: [{ rotate: "-12deg" }],
  },
  dailyChallengeDrawCardBackPattern: {
    position: "absolute",
    top: 14,
    left: 12,
    right: 12,
    bottom: 14,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "rgba(255,255,255,0.25)",
    borderStyle: "dashed",
    opacity: 0.6,
  },
  dailyChallengeDrawCardBackSigil: {
    width: 42,
    height: 42,
    borderRadius: 21,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "rgba(255,255,255,0.12)",
  },
  dailyChallengeDrawCardBackSigilText: {
    fontSize: 16,
    fontWeight: "700",
    letterSpacing: 2,
  },
  dailyChallengeDrawCardFront: {
    alignItems: "center",
    justifyContent: "center",
    gap: 8,
    padding: 10,
  },
  dailyChallengeDrawCardFrontEmoji: {
    width: 42,
    height: 42,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  dailyChallengeDrawCardFrontEmojiText: {
    fontSize: 24,
  },
  dailyChallengeDrawCardFrontTitle: {
    fontSize: 13,
    fontWeight: "700",
    textAlign: "center",
    lineHeight: 16,
    minHeight: 32,
  },
  dailyChallengeDrawCardFrontMeta: {
    fontSize: 11,
    fontWeight: "700",
    letterSpacing: 0.5,
    textTransform: "uppercase",
  },
  dailyChallengeDrawHintWrap: {
    alignItems: "center",
  },
  dailyChallengeDrawHint: {
    ...createBodyText({ fontSize: 13 }),
    textAlign: "center",
  },
  dailyChallengeDrawHidden: {
    display: "none",
  },
  dailyChallengeRevealPanel: {
    borderRadius: 20,
    padding: 14,
    borderWidth: 1,
    gap: 12,
    backgroundColor: "rgba(17,17,17,0.03)",
  },
  dailyChallengeRevealRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  dailyChallengeRevealEmoji: {
    width: 52,
    height: 52,
    borderRadius: 16,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  dailyChallengeRevealEmojiText: {
    fontSize: 28,
  },
  dailyChallengeRevealTitle: {
    fontSize: 16,
    fontWeight: "700",
  },
  dailyChallengeRevealHint: {
    ...createBodyText({ fontSize: 14 }),
  },
  dailyChallengeCompleteCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 28,
    padding: 22,
    borderWidth: 1,
    overflow: "hidden",
    gap: 16,
    shadowColor: "#000",
    shadowOpacity: 0.12,
    shadowRadius: 18,
    shadowOffset: { width: 0, height: 10 },
    elevation: 8,
  },
  dailyChallengeCompleteGlow: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.2,
  },
  dailyChallengeCompleteHeader: {
    gap: 8,
  },
  dailyChallengeCompleteTitle: {
    fontSize: 22,
    fontWeight: "800",
  },
  dailyChallengeCompleteSubtitle: {
    ...createBodyText({ fontSize: 15 }),
    lineHeight: 20,
  },
  dailyChallengeCompleteReward: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 8,
    borderRadius: 18,
    borderWidth: 1,
    paddingVertical: 12,
  },
  dailyChallengeCompleteRewardText: {
    fontSize: 20,
    fontWeight: "800",
  },
  dailyChallengeCompleteHint: {
    ...createBodyText({ fontSize: 13 }),
    textAlign: "center",
  },
  dailyChallengeCompleteButton: {
    borderRadius: 18,
    paddingVertical: 14,
    alignItems: "center",
  },
  dailyChallengeCompleteButtonText: {
    ...createCtaText({ fontSize: 15 }),
  },
  breakdownCard: {
    width: "100%",
    maxWidth: 420,
    borderRadius: 20,
    padding: 16,
    borderWidth: 1,
  },
  breakdownHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 12,
    gap: 12,
  },
  breakdownTitle: {
    fontSize: 18,
    fontWeight: "800",
    flexShrink: 1,
  },
  breakdownClose: {
    fontSize: 18,
    fontWeight: "700",
  },
  breakdownHeaderActions: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  breakdownModeToggle: {
    flexDirection: "row",
    padding: 3,
    borderRadius: 999,
    borderWidth: 1,
    gap: 4,
  },
  breakdownModeToggleOption: {
    width: 22,
    height: 22,
    borderRadius: 11,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  breakdownModeToggleOptionActive: {
    shadowColor: "#000",
    shadowOpacity: 0.08,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 2,
  },
  breakdownModeToggleText: {
    fontSize: 12,
    fontWeight: "800",
    lineHeight: 14,
  },
  breakdownBars: {
    flexDirection: "row",
    justifyContent: "space-between",
    gap: 10,
    marginBottom: 16,
  },
  breakdownBarItem: {
    flex: 1,
    alignItems: "center",
    gap: 6,
  },
  breakdownBarTrack: {
    width: "100%",
    height: 140,
    borderRadius: 10,
    overflow: "hidden",
    justifyContent: "flex-end",
  },
  breakdownBarStack: {
    width: "100%",
  },
  breakdownBarLabel: {
    fontSize: 11,
    fontWeight: "700",
    textAlign: "center",
  },
  breakdownBarAmount: {
    fontSize: 11,
    fontWeight: "600",
    textAlign: "center",
  },
  breakdownAmountWrapper: {
    width: "100%",
    paddingHorizontal: 4,
  },
  breakdownLegend: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  breakdownLegendItem: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 12,
    borderWidth: 1,
  },
  breakdownLegendDot: {
    width: 10,
    height: 10,
    borderRadius: 5,
  },
  breakdownLegendText: {
    fontSize: 12,
    fontWeight: "700",
  },
  spendStatsCard: {
    width: "100%",
    maxWidth: SPEND_STATS_CARD_MAX_WIDTH,
    borderRadius: 24,
    borderWidth: 1,
    padding: SPEND_STATS_CARD_PADDING,
    gap: 12,
  },
  spendStatsHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  spendStatsTabs: {
    flex: 1,
    flexDirection: "row",
    padding: 4,
    borderRadius: 999,
    gap: 4,
    flexShrink: 1,
  },
  spendStatsTab: {
    flex: 1,
    paddingVertical: 8,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
  },
  spendStatsTabActive: {
    shadowColor: "#000",
    shadowOpacity: 0.06,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 2,
  },
  spendStatsTabText: {
    fontSize: 15,
    fontWeight: "700",
  },
  spendStatsCloseButton: {
    width: 36,
    height: 36,
    borderRadius: 18,
    alignItems: "center",
    justifyContent: "center",
  },
  spendStatsCloseText: {
    fontSize: 16,
    fontWeight: "700",
  },
  spendStatsHeaderActions: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  spendStatsTitleRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
  },
  spendStatsTitleActions: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  spendStatsNavButton: {
    width: 38,
    height: 38,
    borderRadius: 19,
    alignItems: "center",
    justifyContent: "center",
  },
  spendStatsNavButtonDisabled: {
    opacity: 0.4,
  },
  spendStatsNavText: {
    fontSize: 20,
    fontWeight: "700",
  },
  spendStatsTitleBlock: {
    flex: 1,
    alignItems: "center",
    gap: 4,
  },
  spendStatsSubtitle: {
    fontSize: 13,
    fontWeight: "600",
  },
  spendStatsTitle: {
    fontSize: 20,
    fontWeight: "800",
  },
  spendStatsChart: {
    flexDirection: "row",
    alignItems: "flex-end",
    justifyContent: "space-between",
    gap: SPEND_STATS_CHART_GAP,
    minHeight: 190,
  },
  spendStatsChartScrollable: {
    justifyContent: "flex-start",
  },
  spendStatsChartScroll: {
    width: "100%",
  },
  spendStatsBarItem: {
    flex: 1,
    alignItems: "center",
    gap: 6,
  },
  spendStatsValue: {
    fontSize: 13,
    fontWeight: "700",
  },
  spendStatsBarTrack: {
    width: "100%",
    height: SPEND_STATS_TRACK_HEIGHT,
    borderRadius: 16,
    padding: SPEND_STATS_TRACK_PADDING,
    justifyContent: "flex-end",
  },
  spendStatsBarStack: {
    width: "100%",
    borderRadius: 10,
  },
  spendStatsBarLabel: {
    fontSize: 11,
    fontWeight: "700",
    textAlign: "center",
  },
  spendStatsDivider: {
    height: 1,
  },
  spendStatsLegend: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 10,
    justifyContent: "center",
  },
  spendStatsLegendPill: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
  },
  spendStatsLegendPercent: {
    fontSize: 13,
    fontWeight: "800",
  },
  spendStatsLegendLabel: {
    fontSize: 14,
    fontWeight: "700",
  },
  savedHeroToggleRow: {
    marginTop: 10,
    alignItems: "flex-end",
  },
  savedHeroToggleButton: {
    paddingVertical: 4,
    paddingHorizontal: 8,
  },
  savedHeroToggleText: {
    fontSize: 12,
    fontWeight: "600",
    textAlign: "right",
  },
  savedHeroDaily: {
    marginTop: IS_SHORT_DEVICE ? 8 : 12,
    gap: IS_SHORT_DEVICE ? 8 : 12,
  },
  savedHeroExpanded: {
    marginTop: IS_SHORT_DEVICE ? 8 : 12,
    gap: IS_SHORT_DEVICE ? 12 : 16,
  },
  savedHeroCoinsCard: {
    flexDirection: "row",
    alignItems: "center",
    gap: 14,
    borderRadius: 18,
    borderWidth: 1,
    padding: IS_SHORT_DEVICE ? 12 : 14,
  },
  savedHeroCoinsText: {
    flex: 1,
    gap: 4,
  },
  savedHeroCoinsLabel: {
    fontSize: 14,
    fontWeight: "800",
  },
  savedHeroCoinsSubtitle: {
    fontSize: 12,
    fontWeight: "600",
  },
  savedHeroCoinsValue: {
    fontSize: 24,
    fontWeight: "900",
  },
  savedHeroDailyTitle: {
    fontSize: 14,
    fontWeight: "700",
  },
  savedHeroBars: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-end",
    gap: 8,
  },
  savedHeroBarItem: {
    flex: 1,
    alignItems: "center",
    gap: 4,
  },
  savedHeroBarAmountWrap: {
    minHeight: 28,
    justifyContent: "flex-end",
    alignItems: "center",
    gap: 2,
    paddingHorizontal: 2,
  },
  savedHeroBarAmountBlock: {
    alignItems: "center",
    maxWidth: 60,
    width: "100%",
  },
  savedHeroBarAmount: {
    fontSize: 9,
    textAlign: "center",
    lineHeight: 11,
    fontWeight: "600",
  },
  savedHeroBarSpend: {
    fontSize: 8,
    textAlign: "center",
    lineHeight: 10,
    fontWeight: "600",
  },
  savedHeroBarCurrency: {
    fontSize: 8,
    fontWeight: "600",
  },
  savedHeroBarTrack: {
    width: 20,
    height: 70,
    borderRadius: 10,
    backgroundColor: "rgba(255,255,255,0.4)",
    justifyContent: "flex-end",
    overflow: "hidden",
    position: "relative",
  },
  savedHeroBarColumn: {
    width: "100%",
    borderRadius: 10,
  },
  savedHeroBarColumnSpend: {
    position: "absolute",
    left: 0,
    bottom: 0,
    width: "100%",
    borderRadius: 10,
  },
  savedHeroBarLabel: {
    fontSize: 11,
    fontWeight: "600",
  },
  savedHeroDailyEmpty: {
    fontSize: 12,
  },
  weeklyTrendRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 12,
    marginTop: 6,
    marginBottom: 2,
  },
  weeklyTrendItem: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  weeklyTrendLabel: {
    ...createSecondaryText({ fontSize: 11 }),
  },
  weeklyTrendValue: {
    ...createSecondaryText({ fontSize: 11 }),
    fontWeight: "700",
  },
  progressHeroHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 12,
  },
  progressHeroTitle: {
    ...createCtaText({ fontSize: 13, textTransform: "uppercase" }),
    fontFamily: INTER_FONTS.bold,
    letterSpacing: scaleLetterSpacing(1.2),
    textAlign: "center",
  },
  progressHeroAmount: {
    fontSize: IS_SHORT_DEVICE ? 36 : Platform.OS === "ios" ? 44 : 46,
    fontWeight: "900",
    fontFamily: INTER_FONTS.extraBold,
    lineHeight: IS_SHORT_DEVICE ? 40 : Platform.OS === "ios" ? 48 : 50,
    letterSpacing: Platform.OS === "ios" ? -0.6 : -0.8,
    textAlign: "center",
  },
  progressHeroLevel: {
    fontSize: 14,
    fontWeight: "600",
  },
  progressHeroBar: {
    height: 8,
    borderRadius: 999,
    overflow: "hidden",
    marginBottom: 8,
  },
  progressHeroFill: {
    height: "100%",
    borderRadius: 999,
  },
  progressHeroNext: {
    fontSize: 13,
    fontWeight: "500",
  },
  savedHeroStatsRow: {
    flexDirection: "row",
    gap: 10,
    marginTop: IS_SHORT_DEVICE ? 10 : 14,
  },
  savedHeroStatsItem: {
    flex: 1,
    borderRadius: 18,
    borderWidth: 1,
    paddingVertical: 12,
    paddingHorizontal: 12,
  },
  savedHeroStatsValue: {
    fontSize: 18,
    fontWeight: "800",
  },
  savedHeroStatsLabel: {
    fontSize: 12,
    marginTop: 4,
  },
  payBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.5)",
    justifyContent: "flex-end",
  },
  payBackdropHit: {
    flex: 1,
  },
  paySheet: {
    borderTopLeftRadius: 28,
    borderTopRightRadius: 28,
    padding: 24,
    gap: 16,
  },
  paySheetHandle: {
    width: 60,
    height: 4,
    borderRadius: 2,
    backgroundColor: "rgba(255,255,255,0.3)",
    alignSelf: "center",
    marginBottom: 4,
  },
  payBrand: {
    fontSize: 18,
    fontWeight: "700",
    textAlign: "center",
  },
  payCard: {
    flexDirection: "row",
    alignItems: "center",
    borderRadius: 18,
    padding: 16,
    gap: 12,
  },
  payCardIcon: {
    width: 48,
    height: 48,
    borderRadius: 14,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "rgba(0,0,0,0.05)",
  },
  payCardEmoji: {
    fontSize: 26,
  },
  payCardTexts: {
    flex: 1,
    marginLeft: 10,
  },
  payCardTitle: {
    fontSize: 14,
    fontWeight: "600",
  },
  payCardAmount: {
    fontSize: 16,
    fontWeight: "700",
  },
  paySheetReminder: {
    width: "100%",
    alignItems: "center",
    paddingVertical: 8,
  },
  paySheetSubtitle: {
    fontSize: 11,
    lineHeight: 14,
    textAlign: "center",
    maxWidth: "90%",
    alignSelf: "center",
  },
  payConfirm: {
    borderRadius: 999,
    paddingVertical: 12,
    alignItems: "center",
  },
  payConfirmText: {
    fontSize: 15,
    fontWeight: "700",
  },
  payCancel: {
    paddingVertical: 8,
    alignItems: "center",
  },
  payCancelText: {
    fontSize: 14,
    fontWeight: "600",
  },
  freeDayCard: {
    marginTop: 12,
    padding: IS_SHORT_DEVICE ? 14 : 18,
    borderRadius: 24,
    borderWidth: 1,
    gap: IS_SHORT_DEVICE ? 10 : 12,
    position: "relative",
  },
  freeDayHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    flexWrap: "wrap",
    gap: 12,
  },
  freeDayTitleBlock: {
    flex: 1,
  },
  freeDayLabel: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 18,
    letterSpacing: -0.3,
  },
  freeDayStatsRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 6,
  },
  freeDayStat: {
    flex: 1,
    alignItems: "center",
  },
  freeDayStatLabel: {
    ...createSecondaryText({ marginBottom: 2, textAlign: "center" }),
  },
  freeDayStatValue: {
    ...createBodyText({ fontSize: 16, fontWeight: "700", textAlign: "center" }),
  },
  freeDaySummaryRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginTop: 4,
    flexWrap: "wrap",
    gap: 8,
  },
  freeDayChip: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "rgba(0,0,0,0.05)",
    alignItems: "center",
    flexDirection: "row",
    flexShrink: 1,
  },
  freeDayChipText: {
    ...createCtaText({ fontSize: 12, textAlign: "center" }),
  },
  freeDayToggle: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    alignItems: "center",
  },
  freeDayToggleText: {
    ...createCtaText({ fontSize: 12, textAlign: "center" }),
  },
  freeDayStatusPill: {
    borderRadius: 999,
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderWidth: 1,
    alignSelf: "flex-start",
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "row",
  },
  freeDayStatusText: {
    ...createCtaText({ fontSize: 12, textAlign: "center" }),
  },
  freeDayStatusPillDisabled: {
    opacity: 0.5,
  },
  freeDayStatusCoin: {
    width: 18,
    height: 18,
    marginLeft: 6,
    resizeMode: "contain",
  },
  freeDayHealthBadge: {
    display: "none",
  },
  freeDayRescueBanner: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    borderRadius: 16,
    borderWidth: 1,
    paddingHorizontal: 14,
    paddingVertical: 10,
    gap: 12,
  },
  freeDayRescueTitle: {
    ...createBodyText({ fontSize: 15, marginBottom: 2 }),
  },
  freeDayRescueSubtitle: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  freeDayRescueButton: {
    borderRadius: 999,
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  freeDayRescueButtonText: {
    ...createCtaText({ fontSize: 13, color: "#fff", textAlign: "center" }),
  },
  freeDayRescueButtonDisabled: {
    backgroundColor: "rgba(0,0,0,0.05)",
    borderWidth: 1,
    borderColor: "rgba(0,0,0,0.08)",
  },
  impulseCard: {
    marginTop: 12,
    padding: IS_SHORT_DEVICE ? 14 : 18,
    borderRadius: 24,
    borderWidth: 1,
    gap: IS_SHORT_DEVICE ? 10 : 12,
    position: "relative",
    overflow: "hidden",
  },
  impulseCardGlow: {
    position: "absolute",
    width: 220,
    height: 220,
    borderRadius: 110,
    top: -90,
    right: -80,
    opacity: 0.2,
  },
  impulseHeaderRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-start",
    gap: 8,
  },
  impulseHeader: {
    gap: 4,
    flex: 1,
  },
  impulseCardTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 21,
  },
  impulseCardSubtitle: {
    ...createBodyText({ fontSize: 13, lineHeight: 18 }),
  },
  impulseToggle: {
    borderWidth: 1,
    borderRadius: 999,
    paddingHorizontal: 14,
    paddingVertical: 7,
  },
  impulseToggleText: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase", letterSpacing: 0.4 }),
  },
  impulseSummaryGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 10,
  },
  impulseBadge: {
    flex: 1,
    minWidth: "47%",
    borderRadius: 18,
    padding: IS_SHORT_DEVICE ? 10 : 12,
    borderWidth: 1,
    gap: 6,
  },
  impulseSummaryLabel: {
    ...createCtaText({ fontSize: 10, textTransform: "uppercase", letterSpacing: 0.5 }),
  },
  impulseSummaryValue: {
    ...createBodyText({ fontSize: 13, lineHeight: 17, fontWeight: "600" }),
  },
  impulseTrendRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    paddingVertical: 6,
    paddingHorizontal: 10,
    borderRadius: 999,
    borderWidth: 1,
    alignSelf: "flex-start",
  },
  impulseTrendText: {
    ...createBodyText({ fontSize: 11, fontWeight: "700", letterSpacing: 0.2 }),
  },
  impulseCategoryList: {
    marginTop: IS_SHORT_DEVICE ? 6 : 8,
    flexDirection: "row",
    flexWrap: "wrap",
    gap: IS_SHORT_DEVICE ? 6 : 8,
  },
  impulseCategoryRow: {
    flexBasis: "48%",
    flexGrow: 1,
    flexDirection: "column",
    alignItems: "flex-start",
    borderWidth: 1,
    borderRadius: 16,
    paddingHorizontal: IS_SHORT_DEVICE ? 10 : 12,
    paddingVertical: IS_SHORT_DEVICE ? 8 : 10,
    gap: IS_SHORT_DEVICE ? 6 : 8,
  },
  impulseCategoryLabel: {
    ...createBodyText({ fontSize: 12, fontWeight: "700" }),
  },
  impulseCategoryStats: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "flex-start",
    gap: 8,
  },
  impulseCategoryStat: {
    ...createBodyText({ fontSize: 11, fontWeight: "700" }),
  },
  impulseCategoryStatSecondary: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  impulseSequenceSection: {
    marginTop: IS_SHORT_DEVICE ? 8 : 12,
    borderRadius: 18,
    borderWidth: 1,
    padding: IS_SHORT_DEVICE ? 10 : 12,
    gap: 6,
  },
  impulseSequenceTitle: {
    ...createBodyText({ fontSize: 11, fontWeight: "700", textTransform: "uppercase", letterSpacing: 0.4 }),
    marginBottom: 2,
  },
  impulseSequenceEntry: {
    ...createSecondaryText({ fontSize: 11, lineHeight: 16 }),
  },
  freeDayHealthRow: {
    flexDirection: "row",
    alignItems: "center",
    borderWidth: 1,
    borderRadius: 16,
    padding: 12,
    marginBottom: 10,
    gap: 12,
  },
  freeDayHealthIcon: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "rgba(16,91,49,0.08)",
  },
  healthCoinIcon: {
    width: 26,
    height: 26,
    resizeMode: "contain",
  },
  freeDayHealthLabel: {
    fontSize: 14,
    fontWeight: "700",
  },
  freeDayHealthSubtitle: {
    fontSize: 12,
  },
  freeDayCoinRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginTop: 6,
  },
  freeDayCoinBadge: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 999,
    borderWidth: 1,
    gap: 6,
  },
  freeDayCoinImage: {
    width: 20,
    height: 20,
    resizeMode: "contain",
  },
  freeDayCoinCount: {
    fontSize: 12,
    fontWeight: "600",
  },
  freeDayHealthValue: {
    fontSize: 20,
    fontWeight: "800",
    minWidth: 40,
    textAlign: "right",
  },
  freeDayCalendar: {
    marginTop: 4,
    borderRadius: 16,
    padding: IS_SHORT_DEVICE ? 8 : 12,
    backgroundColor: "rgba(255,255,255,0.35)",
  },
  freeDayCalendarHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 6,
  },
  freeDayCalendarTitle: {
    fontSize: IS_SHORT_DEVICE ? 11 : 12,
    fontWeight: "600",
  },
  freeDayCalendarDays: {
    flexDirection: "row",
    justifyContent: "space-between",
  },
  freeDayCalendarDay: {
    alignItems: "center",
    gap: 4,
    flex: 1,
  },
  freeDayCalendarLabel: {
    fontSize: IS_SHORT_DEVICE ? 10 : 11,
    textTransform: "uppercase",
  },
  freeDayCalendarDot: {
    width: IS_SHORT_DEVICE ? 12 : 16,
    height: IS_SHORT_DEVICE ? 12 : 16,
    borderRadius: IS_SHORT_DEVICE ? 6 : 8,
    borderWidth: 1,
    borderColor: "rgba(0,0,0,0.08)",
  },
  freeDayCalendarDotActive: {
    backgroundColor: "#1EB25F",
    borderColor: "#1EB25F",
  },
  freeDayCalendarDotToday: {
    borderColor: "#1EB25F",
    borderWidth: 2,
  },
  progressHeroGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 12,
  },
  progressWeeklyCard: {
    borderRadius: 18,
    borderWidth: 1,
    padding: 14,
    gap: 10,
  },
  budgetWidgetCard: {
    borderRadius: 22,
    borderWidth: 1,
    padding: 14,
    gap: 10,
  },
  budgetWidgetHeader: {
    flexDirection: "row",
    alignItems: "flex-start",
    justifyContent: "space-between",
    gap: 10,
  },
  budgetWidgetTap: {
    gap: 12,
  },
  budgetWidgetTitleBlock: {
    flex: 1,
  },
  budgetWidgetEditChip: {
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 10,
    paddingVertical: 4,
  },
  budgetWidgetEditChipText: {
    ...createCtaText({ fontSize: 10, textTransform: "uppercase" }),
  },
  budgetWidgetTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 18,
  },
  budgetWidgetSubtitle: {
    ...createSecondaryText({ fontSize: 12 }),
    marginTop: 2,
  },
  budgetWidgetStatsRow: {
    flexDirection: "row",
    gap: 8,
    flexWrap: "nowrap",
    justifyContent: "space-between",
    alignItems: "center",
  },
  budgetWidgetStat: {
    flex: 1,
    minWidth: 70,
    alignItems: "center",
  },
  budgetWidgetStatLabel: {
    ...createSecondaryText({ fontSize: 10 }),
    textAlign: "center",
  },
  budgetWidgetStatValue: {
    ...createBodyText({ fontSize: 12, fontWeight: "700" }),
    marginTop: 1,
    textAlign: "center",
  },
  budgetWidgetList: {
    width: "100%",
  },
  budgetWidgetListContent: {
    gap: BUDGET_WIDGET_CARD_GAP,
    paddingTop: 4,
    paddingBottom: 2,
  },
  budgetWidgetListHeader: {
    alignItems: "flex-end",
  },
  budgetWidgetListHeaderText: {
    ...createSecondaryText({ fontSize: 10 }),
    letterSpacing: 0.4,
  },
  budgetWidgetRow: {
    gap: 6,
  },
  budgetWidgetRowHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 8,
  },
  budgetWidgetRowTitle: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    flex: 1,
  },
  budgetWidgetRowEmoji: {
    fontSize: 18,
  },
  budgetWidgetRowLabel: {
    ...createBodyText({ fontSize: 13, fontWeight: "600" }),
    flex: 1,
  },
  budgetWidgetRowValue: {
    ...createBodyText({ fontSize: 12, fontWeight: "700" }),
  },
  budgetWidgetRowTrack: {
    height: 10,
    borderRadius: 999,
    overflow: "hidden",
    position: "relative",
  },
  budgetWidgetRowFill: {
    height: "100%",
    borderRadius: 999,
    position: "absolute",
    left: 0,
  },
  budgetWidgetRowOverflow: {
    height: "100%",
    borderRadius: 999,
    position: "absolute",
    right: 0,
  },
  budgetWidgetHint: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  budgetWidgetEmpty: {
    alignItems: "center",
    gap: 8,
    paddingVertical: 6,
  },
  budgetWidgetEmptyTitle: {
    ...createBodyText({ fontSize: 14, fontWeight: "700", textAlign: "center" }),
  },
  budgetWidgetEmptySubtitle: {
    ...createSecondaryText({ fontSize: 12, textAlign: "center" }),
  },
  budgetWidgetEmptyButton: {
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  budgetWidgetEmptyButtonText: {
    ...createCtaText({ fontSize: 12 }),
  },
  budgetModalRoot: {
    flex: 1,
    justifyContent: "center",
  },
  budgetModalBackdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(0,0,0,0.35)",
  },
  budgetModalWrap: {
    flex: 1,
    justifyContent: "center",
    paddingHorizontal: 18,
  },
  budgetModalCard: {
    borderRadius: 20,
    borderWidth: 1,
    padding: 16,
    maxHeight: IS_SHORT_DEVICE ? "75%" : "80%",
    gap: 10,
  },
  budgetModalHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
  },
  budgetModalTitleBlock: {
    flex: 1,
  },
  budgetModalTitle: {
    fontSize: 18,
    fontWeight: "800",
  },
  budgetModalSubtitle: {
    ...createSecondaryText({ fontSize: 12 }),
    marginTop: 2,
  },
  budgetModalClose: {
    padding: 4,
  },
  budgetModalCloseText: {
    fontSize: 18,
    fontWeight: "700",
  },
  budgetModalMonthScroll: {
    marginTop: 4,
  },
  budgetModalMonthContent: {
    gap: 8,
    paddingVertical: 4,
    paddingRight: 4,
  },
  budgetModalMonthChip: {
    borderRadius: 14,
    borderWidth: 1,
    paddingHorizontal: 12,
    paddingVertical: 6,
  },
  budgetModalMonthChipText: {
    fontSize: 11,
    fontWeight: "600",
  },
  budgetModalStatsRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 12,
  },
  budgetModalStat: {
    flex: 1,
    minWidth: 90,
  },
  budgetModalStatLabel: {
    ...createSecondaryText({ fontSize: 11 }),
  },
  budgetModalStatValue: {
    ...createBodyText({ fontSize: 14, fontWeight: "700" }),
    marginTop: 2,
  },
  budgetModalHint: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  budgetModalBars: {
    gap: 12,
    paddingVertical: 6,
    paddingRight: 6,
  },
  budgetModalBarItem: {
    width: 90,
    alignItems: "center",
    gap: 6,
  },
  budgetModalBarTrack: {
    width: 46,
    height: BUDGET_BAR_MAX_HEIGHT,
    borderRadius: 16,
    overflow: "hidden",
    position: "relative",
  },
  budgetModalLimitFill: {
    position: "absolute",
    bottom: 0,
    width: "100%",
    borderTopLeftRadius: 14,
    borderTopRightRadius: 14,
  },
  budgetModalBarFill: {
    width: "100%",
    borderTopLeftRadius: 14,
    borderTopRightRadius: 14,
    position: "absolute",
    bottom: 0,
  },
  budgetModalBarOverflow: {
    position: "absolute",
    width: "100%",
    borderTopLeftRadius: 14,
    borderTopRightRadius: 14,
  },
  budgetModalBarAmount: {
    fontSize: 11,
    fontWeight: "700",
    textAlign: "center",
  },
  budgetModalBarLabel: {
    ...createSecondaryText({ fontSize: 10, textAlign: "center" }),
  },
  budgetModalActions: {
    flexDirection: "row",
    gap: 10,
    marginTop: 4,
  },
  budgetModalAction: {
    flex: 1,
    borderRadius: 12,
    borderWidth: 1,
    paddingVertical: 10,
    alignItems: "center",
  },
  budgetModalActionText: {
    ...createCtaText({ fontSize: 12 }),
  },
  budgetModalActionPrimary: {
    flex: 1,
    borderRadius: 12,
    paddingVertical: 10,
    alignItems: "center",
  },
  budgetModalActionPrimaryText: {
    ...createCtaText({ fontSize: 12 }),
  },
  progressWeeklyTitle: {
    fontSize: 14,
    fontWeight: "700",
  },
  progressGoalCard: {
    flex: 1,
    borderRadius: 22,
    padding: 16,
    borderWidth: 1,
    gap: 8,
  },
  progressGoalHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  progressGoalTitle: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase" }),
  },
  progressGoalEmoji: {
    fontSize: 20,
  },
  progressGoalName: {
    ...createBodyText({ fontSize: 16, fontWeight: "700" }),
  },
  progressGoalMeta: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  progressGoalRingRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    marginTop: 4,
  },
  progressGoalRingWrap: {
    width: 76,
    height: 76,
    alignItems: "center",
    justifyContent: "center",
  },
  progressGoalRingInner: {
    position: "absolute",
    width: "100%",
    height: "100%",
    alignItems: "center",
    justifyContent: "center",
    paddingHorizontal: 8,
  },
  progressGoalRingText: {
    gap: 2,
    flex: 1,
    minWidth: 0,
    minHeight: 76,
    justifyContent: "center",
  },
  progressGoalPercent: {
    fontSize: 18,
    fontWeight: "800",
  },
  progressGoalTarget: {
    ...createSecondaryText({ fontSize: 12, textAlign: "center" }),
  },
  progressCoinCard: {
    flex: 1,
    borderRadius: 22,
    padding: 16,
    borderWidth: 1,
    gap: 8,
  },
  progressCoinHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  progressCoinTitle: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase" }),
  },
  progressCoinEmoji: {
    fontSize: 20,
  },
  progressCoinValue: {
    fontSize: 26,
    fontWeight: "800",
  },
  progressCoinSubtitle: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  progressCoinRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  progressCoinBadge: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
    borderRadius: 12,
    borderWidth: 1,
    paddingHorizontal: 8,
    paddingVertical: 4,
  },
  progressCoinImage: {
    width: 14,
    height: 14,
    resizeMode: "contain",
  },
  progressCoinCount: {
    fontSize: 12,
    fontWeight: "600",
  },
  progressActiveChallenge: {
    borderRadius: 22,
    padding: 16,
    borderWidth: 1,
    gap: 10,
  },
  progressActiveChallengeHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  progressActiveChallengeTitle: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase" }),
  },
  progressActiveChallengeMeta: {
    ...createSecondaryText({ fontSize: 11 }),
  },
  progressActiveChallengeRow: {
    flexDirection: "row",
    alignItems: "flex-start",
    gap: 12,
  },
  progressActiveChallengeName: {
    ...createBodyText({ fontSize: 16, fontWeight: "700" }),
  },
  progressActiveChallengeDesc: {
    ...createBodyText({ fontSize: 13 }),
  },
  progressActiveChallengeButton: {
    borderRadius: 14,
    paddingVertical: 10,
    alignItems: "center",
    marginTop: 4,
  },
  progressActiveChallengeButtonText: {
    ...createCtaText({ fontSize: 13 }),
  },
  progressActiveChallengeEmpty: {
    ...createSecondaryText({ fontSize: 13 }),
  },
  progressAnalyticsCard: {
    borderRadius: 22,
    padding: 16,
    borderWidth: 1,
    gap: 10,
  },
  progressAnalyticsHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    gap: 8,
  },
  progressAnalyticsHeaderRight: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  progressAnalyticsChevron: {
    width: 12,
    height: 12,
    position: "relative",
    alignItems: "center",
    justifyContent: "center",
  },
  progressAnalyticsChevronLineLeft: {
    position: "absolute",
    width: 8,
    height: 1.5,
    borderRadius: 999,
    left: 1,
    top: 7,
  },
  progressAnalyticsChevronLineRight: {
    position: "absolute",
    width: 8,
    height: 1.5,
    borderRadius: 999,
    right: 1,
    top: 7,
  },
  progressAnalyticsTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 16,
  },
  progressAnalyticsLegend: {
    flexDirection: "column",
    alignItems: "flex-end",
    gap: 4,
    flexWrap: "nowrap",
  },
  progressAnalyticsLegendItem: {
    flexDirection: "row",
    alignItems: "center",
    gap: 4,
  },
  progressAnalyticsDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
  },
  progressAnalyticsLegendText: {
    ...createSecondaryText({ fontSize: 10 }),
    flexShrink: 1,
  },
  progressAnalyticsSubtitle: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  progressAnalyticsCollapsed: {
    paddingTop: 4,
  },
  progressAnalyticsScroll: {
    width: "100%",
  },
  progressAnalyticsList: {
    gap: 10,
    marginTop: 4,
  },
  progressBadgeRow: {
    marginTop: 6,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 8,
  },
  progressBadgeLabel: {
    ...createSecondaryText({ fontSize: 11 }),
  },
  progressBadgeList: {
    flexDirection: "row",
    alignItems: "center",
    gap: 4,
  },
  progressBadgeEmoji: {
    fontSize: 14,
  },
  progressBadgeCount: {
    ...createSecondaryText({ fontSize: 11 }),
  },
  progressAnalyticsRow: {
    gap: 6,
  },
  progressAnalyticsRowHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  progressAnalyticsLabel: {
    ...createBodyText({ fontSize: 13, fontWeight: "600" }),
  },
  progressAnalyticsValue: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  progressAnalyticsTrack: {
    height: 10,
    borderRadius: 999,
    overflow: "hidden",
  },
  progressAnalyticsFill: {
    height: "100%",
    flexDirection: "row",
    borderRadius: 999,
    overflow: "hidden",
  },
  progressAnalyticsSave: {
    height: "100%",
  },
  progressAnalyticsSpend: {
    height: "100%",
  },
  progressCategoryModalRoot: {
    flex: 1,
    justifyContent: "center",
  },
  progressCategoryBackdrop: {
    ...StyleSheet.absoluteFillObject,
  },
  progressCategoryModalWrap: {
    flex: 1,
    justifyContent: "center",
    paddingHorizontal: 18,
  },
  progressCategoryModalCard: {
    borderRadius: 18,
    borderWidth: 1,
    padding: 16,
    maxHeight: IS_SHORT_DEVICE ? "62%" : "70%",
  },
  progressCategoryModalHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
    marginBottom: 8,
  },
  progressCategoryModalTitle: {
    fontSize: 16,
    fontWeight: "800",
    flex: 1,
  },
  progressCategoryModalClose: {
    padding: 4,
  },
  progressCategoryModalCloseText: {
    fontSize: 18,
    fontWeight: "700",
  },
  progressCategoryModalList: {
    borderWidth: 1,
    borderRadius: 12,
    maxHeight: IS_SHORT_DEVICE ? 300 : 380,
  },
  progressSectionHeader: {
    gap: 2,
  },
  progressSectionTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 18,
  },
  progressSectionSubtitle: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  progressGoalScroll: {
    paddingVertical: 4,
    paddingHorizontal: 2,
    paddingRight: 12,
    gap: 12,
  },
  progressGoalMiniCard: {
    width: 150,
    borderRadius: 18,
    borderWidth: 1,
    padding: 14,
    gap: 6,
    justifyContent: "center",
  },
  progressGoalMiniPlaceholder: {
    borderStyle: "dashed",
    alignItems: "center",
  },
  progressGoalMiniEmoji: {
    fontSize: 20,
  },
  progressGoalMiniTitle: {
    fontSize: 14,
    fontWeight: "700",
  },
  progressGoalMiniMeta: {
    ...createSecondaryText({ fontSize: 11 }),
  },
  progressGoalMiniPlus: {
    fontSize: 22,
    fontWeight: "700",
  },
  profileBadgeRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  profileChallengeBadge: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
    borderRadius: 12,
    borderWidth: 1,
    paddingHorizontal: 8,
    paddingVertical: 4,
  },
  profileChallengeBadgeList: {
    flexDirection: "row",
    alignItems: "center",
    gap: 2,
  },
  profileChallengeBadgeEmoji: {
    fontSize: 12,
  },
  profileChallengeBadgeCount: {
    ...createSecondaryText({ fontSize: 11 }),
  },
  stormOverlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(4,6,15,0.92)",
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 24,
    zIndex: 99,
  },
  stormFlash: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(255,255,255,0.55)",
  },
  stormMessageWrap: {
    width: "85%",
    maxWidth: 360,
    paddingHorizontal: 26,
    paddingVertical: 24,
    borderRadius: 32,
    borderWidth: 1,
    alignItems: "center",
    gap: 8,
  },
  stormMessage: {
    fontSize: 18,
    fontWeight: "700",
    textAlign: "center",
    lineHeight: 24,
  },
  stormComfortText: {
    fontSize: 14,
    textAlign: "center",
    fontWeight: "500",
  },
  stormCatWrap: {
    marginBottom: 8,
  },
  stormCatImage: {
    width: 170,
    height: 170,
  },
  stormLightningBolt: {
    position: "absolute",
    width: 80,
    height: 200,
  },
  saveSpamOverlay: {
    flex: 1,
    backgroundColor: "rgba(6,10,18,0.58)",
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 24,
  },
  saveSpamCard: {
    width: "100%",
    maxWidth: 380,
    borderRadius: 28,
    borderWidth: 1,
    paddingHorizontal: 22,
    paddingVertical: 20,
    alignItems: "center",
    gap: 10,
  },
  saveSpamCatWrap: {
    marginBottom: 2,
  },
  saveSpamCatImage: {
    width: 132,
    height: 132,
  },
  saveSpamTitle: {
    fontSize: 20,
    fontWeight: "800",
    textAlign: "center",
  },
  saveSpamBody: {
    fontSize: 14,
    lineHeight: 20,
    textAlign: "center",
    fontWeight: "600",
  },
  saveSpamHint: {
    fontSize: 13,
    lineHeight: 18,
    textAlign: "center",
  },
  saveSpamActions: {
    marginTop: 6,
    width: "100%",
    flexDirection: "row",
    gap: 10,
  },
  saveSpamButton: {
    flex: 1,
    borderRadius: 16,
    paddingVertical: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  saveSpamButtonCancel: {
    borderWidth: 1,
    borderColor: colorWithAlpha(SPEND_ACTION_COLOR, 0.35),
    backgroundColor: colorWithAlpha(SPEND_ACTION_COLOR, 0.12),
  },
  saveSpamButtonConfirm: {
    backgroundColor: SAVE_ACTION_COLOR,
  },
  saveSpamButtonCancelText: {
    color: SPEND_ACTION_COLOR,
    fontSize: 14,
    fontWeight: "700",
  },
  saveSpamButtonConfirmText: {
    color: "#FFFFFF",
    fontSize: 14,
    fontWeight: "700",
  },
  productCard: {
    width: "48%",
    borderRadius: 28,
    padding: 16,
    minHeight: 210,
  },
  productTagline: {
    fontSize: 12,
    color: "#4A3D5E",
  },
  productImage: {
    width: 100,
    height: 100,
    alignSelf: "center",
    marginVertical: 12,
    borderRadius: 16,
  },
  productTitle: {
    fontSize: 18,
    fontWeight: "700",
    color: "#1C1A2A",
  },
  productPrice: {
    marginTop: 4,
    color: "#1C1A2A",
  },
  temptationCard: {
    borderRadius: TEMPTATION_CARD_RADIUS,
    padding: 20,
    gap: 12,
    position: "relative",
    overflow: "visible",
  },
  temptationTextureContainer: {
    ...StyleSheet.absoluteFillObject,
    borderRadius: TEMPTATION_CARD_RADIUS,
    overflow: "hidden",
  },
  temptationTextureOverlay: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.18,
  },
  temptationTextureAccent: {
    transform: [{ rotate: "-8deg" }],
    opacity: 0.12,
    top: -80,
    bottom: -80,
  },
  temptationTextureHighlight: {
    opacity: 0.16,
    transform: [{ rotate: "14deg" }],
    left: "-20%",
    right: "-20%",
    top: "-60%",
    bottom: "-60%",
  },
  temptationSwipeWrapper: {
    marginBottom: 16,
    position: "relative",
  },
  temptationSwipeBackground: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    paddingHorizontal: 16,
  },
  temptationTutorialSwipeHint: {
    borderRadius: TEMPTATION_CARD_RADIUS,
    ...Platform.select({
      android: {
        borderWidth: 0,
        borderColor: "transparent",
        backgroundColor: "transparent",
      },
      default: {
        borderColor: "#F6C16B",
        backgroundColor: "rgba(246,193,107,0.12)",
        borderWidth: 2,
      },
    }),
  },
  swipeHint: {
    borderWidth: 1,
    borderRadius: 24,
    paddingHorizontal: 12,
    paddingVertical: 6,
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  swipeHintLeft: {
    justifyContent: "flex-start",
  },
  swipeHintRight: {
    justifyContent: "flex-end",
  },
  swipeHintIcon: {
    fontSize: 14,
  },
  swipeHintText: {
    fontSize: 12,
    fontWeight: "600",
  },
  temptationHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  temptationEmoji: {
    fontSize: 28,
  },
  emojiDisplayWrapper: {
    width: 40,
    alignItems: "center",
  },
  temptationBadgeStack: {
    position: "absolute",
    top: 0,
    right: 0,
    alignItems: "flex-end",
    gap: 4,
  },
  temptationPinnedBadge: {
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 10,
    paddingVertical: 4,
  },
  temptationPinnedBadgeText: {
    fontSize: 11,
    fontWeight: "700",
  },
  temptationTitle: {
    fontSize: 18,
    fontWeight: "700",
    flex: 1,
    flexWrap: "wrap",
  },
  temptationBudgetAlert: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
    borderRadius: 14,
    borderWidth: 1,
    paddingHorizontal: 10,
    paddingVertical: 6,
  },
  temptationBudgetAlertIcon: {
    fontSize: 12,
  },
  temptationBudgetAlertText: {
    flex: 1,
    fontSize: 12,
    fontWeight: "600",
    lineHeight: 16,
  },
  titleEditWrapper: {
    flex: 1,
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  titleEditInputContainer: {
    flex: 1,
    position: "relative",
  },
  titleEditInput: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 14,
    paddingVertical: 6,
    fontSize: 18,
    fontWeight: "700",
  },
  emojiEditWrapper: {
    width: 60,
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 12,
    paddingVertical: 6,
    justifyContent: "center",
    position: "relative",
  },
  emojiEditInput: {
    textAlign: "center",
    fontSize: 18,
    fontWeight: "700",
    paddingRight: 14,
  },
  temptationDesc: {
    lineHeight: 20,
    marginTop: 4,
    marginBottom: 8,
  },
  temptationPriceRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginTop: 6,
    marginBottom: 6,
  },
  temptationGoalRow: {
    flexDirection: "row",
    alignItems: "center",
    marginTop: 6,
    marginBottom: 6,
  },
  temptationPricePill: {
    paddingVertical: 6,
    paddingHorizontal: 14,
    borderRadius: 16,
    borderWidth: 1,
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  pricePillInput: {
    minWidth: 60,
    fontSize: 20,
    fontWeight: "700",
    borderWidth: 0,
    backgroundColor: "transparent",
  },
  temptationPrice: {
    fontSize: 20,
    fontWeight: "700",
  },
  temptationAmountPanel: {
    borderRadius: 18,
    borderWidth: 1,
    padding: 12,
    gap: 8,
    marginTop: 4,
    position: "relative",
    zIndex: 6,
    shadowColor: "rgba(15,23,42,0.25)",
    shadowOpacity: 0.25,
    shadowRadius: 12,
    shadowOffset: { width: 0, height: 6 },
    elevation: 6,
  },
  temptationAmountHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  temptationAmountPill: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 999,
  },
  temptationAmountPillText: {
    fontSize: 11,
    fontWeight: "700",
    textTransform: "uppercase",
    letterSpacing: 0.3,
  },
  temptationAmountClose: {
    width: 28,
    height: 28,
    borderRadius: 14,
    alignItems: "center",
    justifyContent: "center",
  },
  temptationAmountCloseText: {
    fontSize: 16,
    fontWeight: "700",
  },
  temptationAmountValue: {
    fontSize: 22,
    fontWeight: "800",
  },
  temptationAmountTrackWrap: {
    width: "100%",
    height: 36,
    justifyContent: "center",
    position: "relative",
    paddingVertical: 4,
  },
  temptationAmountTrack: {
    height: 12,
    borderRadius: 999,
    overflow: "hidden",
    justifyContent: "center",
    width: "100%",
  },
  temptationAmountTrackFill: {
    height: "100%",
    borderRadius: 999,
  },
  temptationAmountTrackMid: {
    position: "absolute",
    width: 2,
    height: 18,
    left: "50%",
    top: "50%",
    marginTop: -9,
    marginLeft: -1,
    borderRadius: 1,
  },
  temptationAmountThumb: {
    position: "absolute",
    top: 7,
    left: 0,
    borderWidth: 2,
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "rgba(15,23,42,0.35)",
    shadowOpacity: 0.4,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 3 },
    elevation: 6,
  },
  temptationAmountThumbInner: {
    width: 8,
    height: 8,
    borderRadius: 4,
    opacity: 0.9,
  },
  temptationAmountScale: {
    flexDirection: "row",
    justifyContent: "space-between",
  },
  temptationAmountScaleText: {
    fontSize: 11,
    fontWeight: "600",
  },
  temptationGoalBadge: {
    alignSelf: "flex-start",
    paddingHorizontal: 8,
    paddingVertical: 3,
    borderRadius: 999,
    borderWidth: 1,
    marginBottom: 6,
  },
  temptationGoalBadgeFloating: {
    alignSelf: "flex-end",
    marginBottom: 0,
  },
  temptationGoalBadgeEditable: {
    flexDirection: "row",
    alignItems: "center",
  },
  temptationGoalBadgeText: {
    fontSize: 10,
    fontWeight: "700",
  },
  temptationGoalBadgeInline: {
    marginLeft: 12,
    marginTop: 2,
  },
  categoryEditSection: {
    marginTop: 10,
    gap: 6,
  },
  categoryEditLabel: {
    ...createSecondaryText({ fontSize: 11, textTransform: "uppercase" }),
  },
  temptationFocusBadge: {
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 999,
    borderWidth: 1,
    marginBottom: 6,
  },
  temptationFocusBadgeText: {
    ...createCtaText({ fontSize: 11 }),
  },
  editPriceText: {
    fontSize: 13,
    fontWeight: "600",
  },
  temptationRefuseMeta: {
    fontSize: 12,
    marginBottom: 6,
  },
  temptationTimerBlock: {
    marginTop: 8,
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 12,
    borderWidth: 1,
  },
  temptationTimerTitle: {
    fontSize: 13,
    fontWeight: "600",
  },
  temptationTimerCountdown: {
    fontSize: 12,
    marginTop: 2,
    fontWeight: "500",
  },
  temptationFeedbackOverlay: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    borderRadius: 28,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 24,
  },
  temptationFeedbackText: {
    fontSize: 18,
    fontWeight: "700",
    textAlign: "center",
  },
  coinBurst: {
    position: "absolute",
    bottom: 32,
    left: "50%",
    marginLeft: -8,
    width: 16,
    height: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: "#E9A600",
    backgroundColor: "#FFD766",
    shadowColor: "#E9A600",
    shadowOpacity: 0.4,
    shadowRadius: 4,
    shadowOffset: { width: 0, height: 2 },
    elevation: 4,
    justifyContent: "center",
    alignItems: "center",
  },
  coinBurstInner: {
    width: 8,
    height: 8,
    borderRadius: 4,
    backgroundColor: "#FFF4B3",
  },
  temptationEditor: {
    marginTop: 8,
    borderTopWidth: StyleSheet.hairlineWidth,
    paddingTop: 12,
    gap: 14,
  },
  temptationEditorField: {
    gap: 6,
  },
  editorLabelRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  temptationEditorActions: {
    gap: 8,
  },
  temptationBadge: {
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 999,
    borderWidth: 1,
  },
  temptationBadgeText: {
    fontSize: 12,
    fontWeight: "600",
    textTransform: "uppercase",
  },
  temptationActions: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginTop: 8,
  },
  temptationTutorialAccent: {
    borderWidth: 2,
    borderColor: "#F6C16B",
    borderRadius: 28,
    padding: 12,
    backgroundColor: "rgba(246,193,107,0.08)",
    zIndex: 2,
  },
  temptationButtonPrimary: {
    flexGrow: 1,
    borderRadius: 16,
    paddingVertical: 12,
    alignItems: "center",
  },
  temptationButtonPrimaryText: {
    fontWeight: "700",
    fontSize: 14,
  },
  temptationButtonGhost: {
    flexGrow: 1,
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 10,
    alignItems: "center",
  },
  temptationButtonGhostText: {
    fontWeight: "600",
  },
  temptationButtonSpendFilled: {
    backgroundColor: SPEND_ACTION_COLOR,
    borderColor: SPEND_ACTION_COLOR,
  },
  temptationButtonSpendFilledText: {
    color: "#FFFFFF",
  },
  temptationButtonOutline: {
    flexGrow: 1,
    borderRadius: 16,
    paddingVertical: 10,
    borderWidth: 1,
    alignItems: "center",
  },
  temptationButtonOutlineText: {
    fontWeight: "600",
  },
  temptationButtonConfirm: {
    ...Platform.select({
      android: {},
      default: { transform: [{ scale: 1.01 }] },
    }),
  },
  temptationButtonConfirmActive: {
    borderWidth: 1.5,
    ...Platform.select({
      android: { elevation: 0 },
      default: {
        shadowOpacity: 0.25,
        shadowRadius: 12,
        shadowOffset: { width: 0, height: 6 },
      },
    }),
  },
  temptationTutorialAccentButton: {
    borderWidth: 2,
    borderColor: "#F6C16B",
    backgroundColor: "rgba(246,193,107,0.16)",
    shadowColor: "rgba(246,193,107,0.45)",
    shadowOpacity: Platform.OS === "ios" ? 0.7 : 0.5,
    shadowRadius: 20,
    shadowOffset: { width: 0, height: 12 },
  },
  detailBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.4)",
    justifyContent: "center",
    padding: 24,
  },
  detailCard: {
    borderRadius: 30,
    padding: 20,
  },
  detailHero: {
    borderRadius: 24,
    padding: 24,
    alignItems: "center",
    marginBottom: 16,
  },
  detailImage: {
    width: 160,
    height: 160,
  },
  detailTitle: {
    fontSize: 26,
    fontWeight: "700",
  },
  detailTagline: {
    marginTop: 6,
    fontWeight: "600",
  },
  detailPrice: {
    fontSize: 20,
    fontWeight: "700",
    marginTop: 8,
  },
  detailRating: {
    marginTop: 4,
    fontSize: 14,
  },
  detailDesc: {
    marginTop: 12,
    lineHeight: 20,
  },
  tutorialBackdrop: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 20,
  },
  tutorialBackdropDim: {
    backgroundColor: "rgba(4,8,20,0.75)",
  },
  tutorialBackdropBlob: {
    position: "absolute",
    width: 280,
    height: 280,
    borderRadius: 999,
  },
  tutorialBackdropBlobPrimary: {
    top: -72,
    left: -92,
  },
  tutorialBackdropBlobSecondary: {
    bottom: 120,
    right: -90,
  },
  tutorialCard: {
    width: "100%",
    maxWidth: 372,
    borderRadius: 30,
    padding: 20,
    borderWidth: 1,
    gap: 14,
    ...Platform.select({
      android: {
        elevation: 8,
      },
      default: {
        shadowColor: "rgba(5,9,20,0.45)",
        shadowOpacity: 0.42,
        shadowRadius: 24,
        shadowOffset: { width: 0, height: 14 },
      },
    }),
  },
  tutorialCardCompact: {
    maxWidth: 326,
    borderRadius: 22,
    padding: 14,
    gap: 10,
  },
  tutorialHighlightFocus: {
    position: "absolute",
    ...Platform.select({
      android: {
        borderWidth: 0,
        borderColor: "transparent",
        elevation: 0,
      },
      default: {
        borderWidth: 2,
        borderColor: "#F6C16B",
        shadowColor: "rgba(246,193,107,0.65)",
        shadowOpacity: 0.95,
        shadowRadius: 32,
        shadowOffset: { width: 0, height: 18 },
      },
    }),
  },
  tutorialCompactHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  tutorialCompactIconWrap: {
    width: 40,
    height: 40,
    borderRadius: 999,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
    overflow: "visible",
  },
  tutorialCompactIcon: {
    fontSize: 22,
    lineHeight: Platform.OS === "android" ? 30 : 26,
    textAlign: "center",
    ...Platform.select({
      android: {
        includeFontPadding: true,
        textAlignVertical: "center",
      },
      default: null,
    }),
    transform: [{ translateY: 1 }],
  },
  tutorialCompactHeaderCopy: {
    flex: 1,
    minWidth: 0,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 8,
  },
  tutorialCompactTitle: {
    fontSize: 19,
    fontWeight: "800",
    letterSpacing: -0.2,
    flexShrink: 1,
  },
  tutorialCompactStepText: {
    fontSize: 12,
    fontWeight: "700",
  },
  tutorialCompactDescription: {
    fontSize: 14,
    lineHeight: 20,
  },
  tutorialCompactProgressRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 10,
  },
  tutorialCompactActions: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  tutorialCompactSkipButton: {
    flex: 1,
    minHeight: 42,
    borderRadius: 13,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
    paddingHorizontal: 10,
  },
  tutorialCompactSkipText: {
    fontSize: 14,
    fontWeight: "600",
  },
  tutorialCompactPrimaryButton: {
    flex: 1,
    minHeight: 42,
    borderRadius: 13,
    alignItems: "center",
    justifyContent: "center",
    paddingHorizontal: 10,
  },
  tutorialCompactPrimaryText: {
    fontSize: 16,
    fontWeight: "700",
  },
  tutorialTopRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 10,
  },
  tutorialStepBadge: {
    flex: 1,
    minWidth: 0,
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 10,
    paddingVertical: 8,
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  tutorialStepBadgeText: {
    fontSize: 12,
    fontWeight: "700",
    flexShrink: 1,
  },
  tutorialStepCounter: {
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 10,
    paddingVertical: 6,
  },
  tutorialStepCounterText: {
    fontSize: 11,
    fontWeight: "700",
    letterSpacing: 0.2,
  },
  tutorialVisualWrap: {
    borderRadius: 22,
    minHeight: 128,
    borderWidth: 1,
    overflow: "hidden",
    paddingHorizontal: 16,
    paddingVertical: 14,
    justifyContent: "flex-end",
    backgroundColor: "rgba(255,255,255,0.04)",
  },
  tutorialVisualPulse: {
    position: "absolute",
    width: 160,
    height: 160,
    borderRadius: 999,
    borderWidth: 1.5,
    top: -42,
    right: -24,
  },
  tutorialVisualOrb: {
    position: "absolute",
    borderRadius: 999,
  },
  tutorialVisualOrbPrimary: {
    width: 76,
    height: 76,
    top: -12,
    left: -20,
    opacity: 0.45,
  },
  tutorialVisualOrbSecondary: {
    width: 58,
    height: 58,
    top: 44,
    right: 18,
    opacity: 0.48,
  },
  tutorialVisualGrid: {
    ...StyleSheet.absoluteFillObject,
    borderRadius: 22,
    borderWidth: 1,
    borderColor: "rgba(255,255,255,0.12)",
  },
  tutorialVisualBarsRow: {
    flexDirection: "row",
    alignItems: "flex-end",
    justifyContent: "space-between",
    height: 78,
    gap: 8,
  },
  tutorialVisualBarTrack: {
    flex: 1,
    borderRadius: 999,
    overflow: "hidden",
    justifyContent: "flex-end",
    height: "100%",
    backgroundColor: "rgba(255,255,255,0.14)",
  },
  tutorialVisualBarFill: {
    width: "100%",
    borderRadius: 999,
  },
  tutorialIcon: {
    fontSize: 20,
    lineHeight: 20,
  },
  tutorialTitle: {
    fontSize: 23,
    fontWeight: "800",
    textAlign: "left",
    letterSpacing: -0.3,
  },
  tutorialDescription: {
    fontSize: 15,
    lineHeight: 22,
    textAlign: "left",
  },
  tutorialFeatureRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  tutorialFeatureChip: {
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 10,
    paddingVertical: 7,
    maxWidth: "100%",
  },
  tutorialFeatureChipText: {
    fontSize: 12,
    fontWeight: "600",
  },
  tutorialProgressRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginTop: 4,
    gap: 12,
  },
  tutorialDots: {
    flexDirection: "row",
    alignItems: "center",
    gap: 7,
  },
  tutorialDot: {
    width: 10,
    height: 10,
    borderRadius: 999,
  },
  tutorialDotCompleted: {
    width: 14,
  },
  tutorialDotActive: {
    width: 28,
  },
  tutorialProgressText: {
    fontSize: 11,
    fontWeight: "700",
  },
  tutorialActions: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    marginTop: 2,
  },
  tutorialSkipButton: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: 15,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  tutorialSkipText: {
    textAlign: "center",
    fontSize: 13,
    fontWeight: "600",
  },
  tutorialPrimaryButton: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: 15,
    alignItems: "center",
    ...Platform.select({
      android: {},
      default: {
        shadowColor: "rgba(7,16,35,0.36)",
        shadowOpacity: 0.26,
        shadowRadius: 12,
        shadowOffset: { width: 0, height: 8 },
      },
    }),
  },
  tutorialPrimaryText: {
    fontSize: 15,
    fontWeight: "700",
  },
  variantRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    marginTop: 18,
    gap: 10,
  },
  variantPill: {
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 10,
    paddingHorizontal: 14,
  },
  variantText: {
    fontWeight: "600",
  },
  variantPrice: {
    fontSize: 12,
    marginTop: 4,
  },
  primaryButton: {
    borderRadius: 24,
    paddingVertical: 16,
    alignItems: "center",
    marginTop: 22,
  },
  primaryButtonText: {
    ...createCtaText({ fontSize: 16 }),
  },
  secondaryButtonClear: {
    alignItems: "center",
    paddingVertical: 12,
  },
  secondaryButtonClearText: {
    ...createCtaText({ fontSize: 14 }),
  },
  secondaryButton: {
    borderRadius: 24,
    paddingVertical: 14,
    alignItems: "center",
    marginTop: 12,
    borderWidth: 1,
  },
  secondaryButtonText: {
    ...createCtaText(),
  },
  closeButton: {
    alignSelf: "flex-end",
  },
  closeButtonText: {
    fontSize: 28,
  },
  header: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 30,
    marginBottom: 16,
  },
  subheader: {
    ...TYPOGRAPHY.blockTitle,
    marginTop: 24,
    marginBottom: 12,
  },
  emptyState: {
    alignItems: "center",
    paddingVertical: 60,
  },
  emptyStateTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 20,
  },
  emptyStateText: {
    ...createBodyText({ textAlign: "center", marginTop: 6 }),
  },
  cartEmptyState: {
    alignItems: "center",
    paddingVertical: 60,
    gap: 12,
  },
  catImage: {
    width: 160,
    height: 160,
    opacity: 0.4,
    borderRadius: 32,
  },
  catImageLarge: {
    width: 220,
    height: 220,
    opacity: 0.9,
  },
  cartEmptyTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 22,
  },
  cartEmptySubtitle: {
    ...createBodyText({ fontSize: 16, textAlign: "center" }),
  },
  cartCard: {
    flexDirection: "row",
    alignItems: "center",
    borderRadius: 28,
    padding: 16,
    marginBottom: 14,
  },
  cartImageWrap: {
    width: 70,
    height: 70,
    borderRadius: 22,
    backgroundColor: "#F1F2F6",
    alignItems: "center",
    justifyContent: "center",
    marginRight: 14,
  },
  cartTitleText: {
    fontSize: 16,
    fontWeight: "700",
  },
  cartVariant: {
    marginTop: 4,
  },
  cartRight: {
    alignItems: "flex-end",
  },
  cartPrice: {
    fontWeight: "700",
  },
  cartBuyButton: {
    marginTop: 6,
    borderRadius: 16,
    paddingHorizontal: 14,
    paddingVertical: 6,
  },
  cartBuyText: {
    fontSize: 12,
    fontWeight: "600",
  },
  cartRemove: {
    marginTop: 4,
    fontSize: 12,
  },
  wishCard: {
    borderRadius: 28,
    padding: 18,
    marginBottom: 16,
    gap: 10,
    position: "relative",
  },
  goalSwipeRow: {
    marginBottom: 20,
    overflow: "hidden",
    position: "relative",
  },
  goalSwipeActions: {
    position: "absolute",
    left: 0,
    top: 0,
    bottom: 0,
    width: 160,
    justifyContent: "center",
    alignItems: "flex-start",
    paddingVertical: 12,
    paddingHorizontal: 12,
    gap: 10,
    zIndex: 0,
  },
  goalSwipeButton: {
    paddingVertical: 8,
    paddingHorizontal: 10,
    borderRadius: 12,
    borderWidth: 1,
  },
  goalSwipeButtonDisabled: {
    opacity: 0.4,
  },
  goalSwipeButtonText: {
    ...createCtaText({ fontSize: 14 }),
  },
  goalSwipeContent: {
    width: "100%",
    zIndex: 1,
  },
  wishHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-start",
  },
  wishTitleWrap: {
    flexDirection: "row",
    alignItems: "center",
    flex: 1,
    marginRight: 12,
    gap: 8,
  },
  wishEmoji: {
    fontSize: 22,
  },
  wishTitle: {
    fontSize: 18,
    fontWeight: "700",
    flex: 1,
    paddingRight: 0,
  },
  wishSavedHint: {
    fontSize: 12,
    marginTop: 2,
  },
  wishBadge: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "transparent",
    backgroundColor: "rgba(0,0,0,0.04)",
  },
  wishBadgeText: {
    fontSize: 12,
    fontWeight: "700",
  },
  wishMeta: {
    fontSize: 13,
    marginBottom: 4,
  },
  wishProgressRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    marginTop: 6,
  },
  wishProgressTrack: {
    flex: 1,
    height: 10,
    borderRadius: 999,
    overflow: "hidden",
  },
  wishProgressBar: {
    height: 10,
    borderRadius: 999,
    overflow: "hidden",
    marginTop: 8,
    marginBottom: 12,
  },
  wishProgressFill: {
    height: "100%",
    borderRadius: 999,
  },
  wishProgressLabel: {
    ...createSecondaryText({ fontSize: 13 }),
  },
  wishButtonGhost: {
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 12,
    paddingHorizontal: 16,
    justifyContent: "center",
    alignItems: "center",
  },
  goalDragWrapper: {
    flexDirection: "row",
    alignItems: "stretch",
    gap: 10,
    paddingVertical: 4,
  },
  goalDragWrapperActive: {
    opacity: 0.94,
  },
  goalDragHandle: {
    width: 32,
    alignItems: "center",
    justifyContent: "center",
    borderRadius: 16,
    paddingVertical: 18,
    marginRight: 4,
  },
  goalDragHandleDots: {
    fontSize: 18,
    fontWeight: "700",
  },
  goalDragCardActive: {
    transform: [{ scale: 0.995 }],
  },
  primaryGoalCard: {
    borderRadius: 36,
    padding: 28,
    overflow: "hidden",
  },
  primaryGoalAura: {
    position: "absolute",
    width: 220,
    height: 220,
    borderRadius: 110,
    top: -60,
    right: -40,
  },
  primaryGoalTop: {
    flexDirection: "row",
    alignItems: "flex-start",
    gap: 16,
  },
  primaryGoalBadge: {
    borderRadius: 999,
    paddingHorizontal: 14,
    paddingVertical: 6,
    borderWidth: 1,
    alignSelf: "flex-start",
  },
  primaryGoalBadgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  primaryGoalTitle: {
    ...TYPOGRAPHY.blockTitle,
  },
  primaryGoalSubtitle: {
    ...createBodyText({ fontSize: 15, marginTop: 6 }),
  },
  primaryGoalEmblem: {
    width: 64,
    height: 64,
    borderRadius: 32,
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 1,
  },
  primaryGoalProgressRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    marginTop: 18,
  },
  primaryGoalProgressTrack: {
    flex: 1,
    height: 14,
    borderRadius: 999,
    overflow: "hidden",
  },
  primaryGoalProgressFill: {
    height: "100%",
    borderRadius: 999,
  },
  primaryGoalPercent: {
    ...createBodyText({ fontSize: 16, fontWeight: "800" }),
  },
  pendingCard: {
    borderRadius: 24,
    padding: 18,
    gap: 12,
  },
  pendingSwipeWrapper: {
    position: "relative",
  },
  pendingSwipeBackground: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    justifyContent: "flex-end",
    alignItems: "center",
    paddingHorizontal: 16,
    flexDirection: "row",
  },
  pendingHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    gap: 12,
  },
  pendingTitle: {
    ...createBodyText({ fontSize: 18, fontWeight: "700", flex: 1 }),
  },
  pendingDue: {
    ...createCtaText({ fontSize: 13, textTransform: "uppercase" }),
  },
  pendingPrice: {
    fontSize: 16,
    fontWeight: "600",
  },
  pendingButtons: {
    flexDirection: "row",
    gap: 10,
  },
  pendingCountdown: {
    fontSize: 20,
    fontWeight: "800",
    marginTop: 6,
  },
  pendingButtonPrimary: {
    flex: 1,
    borderRadius: 16,
    paddingVertical: 12,
    alignItems: "center",
  },
  pendingButtonPrimaryText: {
    ...createCtaText(),
  },
  pendingButtonSecondary: {
    borderWidth: 1,
    borderRadius: 16,
    paddingHorizontal: 16,
    paddingVertical: 12,
    alignItems: "center",
  },
  pendingFridgeScreen: {
    flex: 1,
    paddingHorizontal: BASE_HORIZONTAL_PADDING,
    paddingTop: 14,
    paddingBottom: 14,
  },
  fridgeStage: {
    flex: 1,
  },
  fridgeCabinet: {
    flex: 1,
    borderRadius: 36,
    padding: 10,
    borderWidth: 1,
    shadowColor: "#000",
    shadowOpacity: 0.18,
    shadowRadius: 20,
    shadowOffset: { width: 0, height: 14 },
    elevation: 6,
  },
  fridgeAura: {
    position: "absolute",
    top: -40,
    left: -40,
    width: 180,
    height: 180,
    borderRadius: 90,
    opacity: 0.6,
  },
  fridgeInteriorWrap: {
    flex: 1,
    borderRadius: 26,
    borderWidth: 1,
    overflow: "hidden",
    position: "relative",
    zIndex: 0,
  },
  fridgeInterior: {
    flex: 1,
  },
  fridgeInteriorHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingHorizontal: 16,
    paddingTop: 26,
    paddingBottom: 12,
  },
  fridgeInteriorTitle: {
    ...createBodyText({ fontSize: 20, fontWeight: "800" }),
  },
  fridgeInteriorBadge: {
    borderRadius: 999,
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderWidth: 1,
  },
  fridgeInteriorBadgeText: {
    ...createCtaText({ fontSize: 12 }),
  },
  fridgeShelfScroll: {
    flex: 1,
  },
  fridgeShelfContent: {
    paddingHorizontal: 16,
    paddingBottom: 140,
    paddingTop: 10,
    gap: 18,
  },
  fridgeShelfRow: {
    position: "relative",
    paddingBottom: 18,
  },
  fridgeShelfLine: {
    position: "absolute",
    left: 8,
    right: 8,
    bottom: 4,
    height: 7,
    borderRadius: 8,
  },
  fridgeShelfLip: {
    position: "absolute",
    left: 12,
    right: 12,
    bottom: 7,
    height: 2,
    borderRadius: 2,
  },
  fridgeItemCard: {
    borderRadius: 22,
    padding: 16,
    borderWidth: 1,
    gap: 10,
    overflow: "hidden",
  },
  fridgeShelfPlaceholderCard: {
    borderRadius: 22,
    paddingHorizontal: 16,
    minHeight: 88,
    borderWidth: 1,
    borderStyle: "dashed",
    alignItems: "center",
    justifyContent: "center",
  },
  fridgeShelfPlaceholderText: {
    ...createBodyText({ fontSize: 14, fontWeight: "700" }),
  },
  fridgePremiumShelfCard: {
    borderRadius: 22,
    padding: 16,
    borderWidth: 1,
    gap: 10,
    shadowColor: "#000",
    shadowOpacity: 0.16,
    shadowRadius: 12,
    shadowOffset: { width: 0, height: 8 },
    elevation: 4,
  },
  fridgePremiumShelfBadge: {
    alignSelf: "flex-start",
    borderRadius: 999,
    paddingHorizontal: 10,
    paddingVertical: 4,
  },
  fridgePremiumShelfBadgeText: {
    ...createCtaText({ fontSize: 10, textTransform: "uppercase" }),
  },
  fridgePremiumShelfTitle: {
    ...createBodyText({ fontSize: 16, fontWeight: "800" }),
  },
  fridgePremiumShelfSubtitle: {
    ...createBodyText({ fontSize: 13, fontWeight: "600", lineHeight: 18 }),
  },
  fridgePremiumShelfButton: {
    marginTop: 2,
    alignSelf: "flex-start",
    borderRadius: 14,
    paddingVertical: 10,
    paddingHorizontal: 14,
  },
  fridgePremiumShelfButtonText: {
    ...createCtaText({ fontSize: 12 }),
    color: "#FFFFFF",
  },
  fridgeItemHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
  },
  fridgeItemTitleRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
    flex: 1,
  },
  fridgeItemEmoji: {
    fontSize: 22,
  },
  fridgeItemTitle: {
    ...createBodyText({ fontSize: 16, fontWeight: "700", flex: 1 }),
  },
  fridgeCountdownPill: {
    borderWidth: 1,
    borderRadius: 12,
    paddingHorizontal: 10,
    paddingVertical: 5,
  },
  fridgeCountdownText: {
    fontSize: 12,
    fontWeight: "700",
  },
  fridgeItemMetaRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  fridgeItemPrice: {
    fontSize: 16,
    fontWeight: "700",
  },
  fridgeActionRow: {
    flexDirection: "row",
    gap: 8,
    flexWrap: "wrap",
  },
  fridgeActionPrimary: {
    flexGrow: 1,
    borderRadius: 14,
    paddingVertical: 10,
    paddingHorizontal: 16,
    alignItems: "center",
  },
  fridgeActionPrimaryText: {
    ...createCtaText({ fontSize: 13 }),
  },
  fridgeActionSecondary: {
    borderWidth: 1,
    borderRadius: 14,
    paddingVertical: 10,
    paddingHorizontal: 14,
    alignItems: "center",
  },
  fridgeDoor: {
    position: "absolute",
    top: 10,
    bottom: 10,
    left: 10,
    right: 10,
    borderRadius: 26,
    borderWidth: 1,
    padding: 18,
    justifyContent: "flex-start",
    backfaceVisibility: "hidden",
    zIndex: 3,
    elevation: 8,
  },
  fridgeDoorInset: {
    position: "absolute",
    top: 12,
    bottom: 12,
    left: 12,
    right: 12,
    borderRadius: 22,
    borderWidth: 1,
    opacity: 0.55,
  },
  fridgeDoorContent: {
    flex: 1,
    paddingTop: 16,
    paddingRight: 70,
    gap: 12,
  },
  fridgeDoorTitleLarge: {
    ...createBodyText({ fontSize: 20, fontWeight: "900", lineHeight: 24 }),
    textTransform: "uppercase",
    letterSpacing: 0.8,
  },
  fridgeDoorHeroStat: {
    alignSelf: "stretch",
    width: "100%",
    borderWidth: 1,
    borderRadius: 22,
    paddingVertical: 12,
    paddingHorizontal: 16,
  },
  fridgeDoorHeroNumber: {
    fontSize: 52,
    lineHeight: 58,
    fontWeight: "900",
    letterSpacing: -0.5,
  },
  fridgeDoorHeroLabel: {
    fontSize: 12,
    fontWeight: "700",
    textTransform: "uppercase",
    letterSpacing: 0.7,
  },
  fridgeDoorStatsRow: {
    flexDirection: "row",
    gap: 8,
  },
  fridgeDoorStatCard: {
    flex: 1,
    minWidth: 0,
    borderRadius: 18,
    borderWidth: 1,
    paddingVertical: 10,
    paddingHorizontal: 10,
  },
  fridgeDoorStatNumber: {
    fontSize: 20,
    lineHeight: 24,
    fontWeight: "800",
  },
  fridgeDoorStatLabel: {
    marginTop: 6,
    fontSize: 10,
    fontWeight: "700",
    textTransform: "uppercase",
    letterSpacing: 0.5,
  },
  fridgeDoorHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  fridgeDoorTitle: {
    ...createBodyText({ fontSize: 22, fontWeight: "800" }),
  },
  fridgeDoorBadge: {
    borderRadius: 999,
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderWidth: 1,
  },
  fridgeDoorBadgeText: {
    ...createCtaText({ fontSize: 12 }),
  },
  fridgeDoorHint: {
    position: "absolute",
    right: 92,
    top: "54%",
    width: 140,
    textAlign: "right",
    fontSize: 12,
    fontWeight: "600",
  },
  fridgeHandleWrap: {
    position: "absolute",
    right: 16,
    top: "40%",
  },
  fridgeHandle: {
    width: 52,
    height: 150,
    borderRadius: 28,
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "#000",
    shadowOpacity: 0.18,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 6 },
    elevation: 4,
  },
  fridgeHandleInner: {
    width: 16,
    height: 110,
    borderRadius: 12,
  },
  fridgeHandleGlow: {
    position: "absolute",
    top: 10,
    left: 8,
    right: 8,
    height: 18,
    borderRadius: 9,
    backgroundColor: "rgba(255,255,255,0.8)",
  },
  fridgeDoorShadow: {
    position: "absolute",
    right: -6,
    top: 0,
    bottom: 0,
    width: 18,
    borderRadius: 12,
    backgroundColor: "rgba(0,0,0,0.12)",
  },
  fridgeMist: {
    position: "absolute",
    left: 24,
    right: 24,
    top: 70,
    height: 120,
    borderRadius: 80,
  },
  fridgeEmptyWrap: {
    paddingTop: 40,
    paddingBottom: 80,
  },
  pendingFridgeLocked: {
    flex: 1,
  },
  pendingFridgeLockedContent: {
    flex: 1,
  },
  cartTotalRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginTop: 12,
  },
  cartTotalText: {
    ...createBodyText({ fontSize: 18, fontWeight: "600" }),
  },
  cartTotalAmount: {
    ...createBodyText({ fontSize: 18, fontWeight: "700" }),
  },
  buyAllButton: {
    marginTop: 18,
    borderRadius: 24,
    paddingVertical: 16,
    alignItems: "center",
  },
  buyAllButtonText: {
    ...createCtaText(),
  },
  purchasesSubtitle: {
    marginBottom: 16,
  },
  progressCard: {
    borderRadius: 26,
    padding: 18,
    marginBottom: 20,
  },
  progressTextRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginBottom: 12,
  },
  progressLabel: {
    textTransform: "uppercase",
    fontSize: 12,
  },
  progressValue: {
    fontSize: 32,
    fontWeight: "800",
  },
  progressGoal: {
    fontWeight: "700",
  },
  progressBar: {
    height: 12,
    borderRadius: 12,
    overflow: "hidden",
  },
  progressFill: {
    height: "100%",
    borderRadius: 12,
  },
  progressHint: {
    marginTop: 10,
  },
  purchaseCard: {
    borderRadius: 24,
    padding: 16,
    marginBottom: 14,
  },
  purchaseInfo: {
    marginBottom: 8,
  },
  purchaseTitle: {
    fontWeight: "700",
  },
  purchaseDesc: {
    marginTop: 4,
  },
  purchasePrice: {
    fontWeight: "700",
  },
  levelWidget: {
    borderRadius: 28,
    padding: 20,
    borderWidth: 1,
    gap: 12,
  },
  levelWidgetHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  levelWidgetTitle: {
    fontSize: 18,
    fontWeight: "800",
  },
  levelWidgetBadge: {
    borderRadius: 999,
    paddingHorizontal: 14,
    paddingVertical: 6,
  },
  levelWidgetBadgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  levelWidgetSubtitle: {
    ...createBodyText({ fontSize: 14, fontWeight: "600" }),
  },
  levelWidgetBar: {
    height: 8,
    borderRadius: 16,
    overflow: "hidden",
    marginTop: 8,
  },
  levelWidgetFill: {
    height: "100%",
    borderRadius: 16,
  },
  levelWidgetMeta: {
    ...createSecondaryText({ fontSize: 13 }),
  },
  goalCard: {
    borderRadius: 24,
    padding: 20,
    marginBottom: 12,
    gap: 12,
    position: "relative",
  },
  goalTitle: {
    ...createBodyText({ fontWeight: "700", fontSize: 16 }),
  },
  goalDesc: {
    ...createBodyText({ marginTop: 4 }),
  },
  rewardHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
  },
  rewardBadge: {
    borderRadius: 999,
    paddingHorizontal: 12,
    paddingVertical: 5,
    alignSelf: "flex-start",
  },
  rewardBadgeFloating: {
    position: "absolute",
    top: 0,
    right: -6,
  },
  rewardBadgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  rewardBadgeContainer: {
    position: "absolute",
    top: -8,
    right: -10,
    padding: 0,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "flex-end",
    width: "100%",
    pointerEvents: "none",
  },
  healthRewardTokenRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  healthRewardTokenRowCompact: {
    gap: 6,
  },
  healthRewardToken: {
    flexDirection: "row",
    alignItems: "center",
    gap: 4,
  },
  healthRewardTokenIcon: {
    width: 18,
    height: 18,
    resizeMode: "contain",
  },
  healthRewardTokenCount: {
    ...createCtaText({ fontSize: 12 }),
  },
  rewardClaimButton: {
    borderRadius: 16,
    paddingVertical: 10,
    paddingHorizontal: 20,
    marginTop: 6,
  },
  rewardClaimButtonText: {
    ...createCtaText({ fontSize: 14, textAlign: "center", width: "100%" }),
  },
  rewardsTabs: {
    flexDirection: "row",
    gap: 10,
    marginTop: 4,
    marginBottom: 4,
  },
  rewardsTabButton: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 10,
    alignItems: "center",
  },
  rewardsTabText: {
    ...createCtaText({ fontSize: 14 }),
  },
  challengeCard: {
    borderRadius: 22,
    padding: 18,
    gap: 12,
    borderWidth: 1,
    position: "relative",
  },
  challengeHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  challengeEmoji: {
    fontSize: 28,
  },
  challengeTitle: {
    ...createBodyText({ fontSize: CHALLENGE_TITLE_FONT_SIZE, fontWeight: "700" }),
  },
  challengeDesc: {
    ...createBodyText({ fontSize: CHALLENGE_DESC_FONT_SIZE, lineHeight: CHALLENGE_LINE_HEIGHT }),
  },
  challengeMetaRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  challengeStatus: {
    ...createCtaText({ fontSize: CHALLENGE_META_FONT_SIZE, textTransform: "uppercase" }),
  },
  challengeTimer: {
    ...createSecondaryText({ fontSize: CHALLENGE_META_FONT_SIZE }),
    textAlign: "right",
  },
  challengeProgressBar: {
    height: 8,
    borderRadius: 999,
    overflow: "hidden",
  },
  challengeProgressFill: {
    height: "100%",
    borderRadius: 999,
  },
  challengeProgressLabel: {
    ...createSecondaryText({ fontSize: CHALLENGE_META_FONT_SIZE }),
  },
  challengeDotRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  challengeDot: {
    width: 18,
    height: 18,
    borderRadius: 9,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  challengeDotCheck: {
    fontSize: 11,
    fontWeight: "700",
  },
  challengePotential: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  challengeLockRow: {
    borderRadius: 14,
    borderWidth: 1,
    borderColor: "transparent",
    paddingVertical: 10,
    alignItems: "center",
  },
  challengeLockText: {
    ...createSecondaryText({ fontSize: 12 }),
    textTransform: "uppercase",
    letterSpacing: 0.6,
  },
  challengeCardLocked: {
    opacity: 1,
  },
  challengeActionButton: {
    borderRadius: 16,
    paddingVertical: 12,
    alignItems: "center",
  },
  challengeActionText: {
    ...createCtaText(),
  },
  dailyChallengeWidget: {
    borderRadius: 24,
    padding: 18,
    borderWidth: 1,
    gap: 16,
  },
  dailyChallengeWidgetHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  dailyChallengeWidgetRewardRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  dailyChallengeMultiplierPill: {
    borderRadius: 999,
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderWidth: 1,
  },
  dailyChallengeMultiplierText: {
    fontSize: scaleFontSize(12),
    fontWeight: "800",
    letterSpacing: 0.4,
  },
  dailyChallengeWidgetBody: {
    flexDirection: "row",
    alignItems: "center",
    gap: 14,
  },
  dailyChallengeEmojiPill: {
    width: 54,
    height: 54,
    borderRadius: 18,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "rgba(0,0,0,0.06)",
  },
  dailyChallengeEmojiText: {
    fontSize: scaleFontSize(30),
  },
  dailyChallengeWidgetTitle: {
    fontSize: scaleFontSize(18),
    fontWeight: "800",
  },
  dailyChallengeWidgetDesc: {
    ...createBodyText({ fontSize: 14 }),
  },
  dailyChallengeProgressBar: {
    height: 8,
    borderRadius: 8,
    overflow: "hidden",
  },
  dailyChallengeProgressFill: {
    height: "100%",
    borderRadius: 8,
  },
  dailyChallengeWidgetFooter: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  dailyChallengeProgressLabel: {
    ...createSecondaryText({ fontSize: 13 }),
  },
  dailyChallengeRewardLabel: {
    fontSize: scaleFontSize(14),
    fontWeight: "800",
  },
  challengeRewardChip: {
    borderRadius: 999,
    paddingHorizontal: 10,
    paddingVertical: 4,
  },
  challengeRewardChipFloating: {
    position: "absolute",
    right: 10,
    top: -6,
  },
  challengeSwipeWrapper: {
    position: "relative",
    borderRadius: 22,
    backgroundColor: "transparent",
  },
  challengeSwipeActions: {
    position: "absolute",
    right: 0,
    top: 0,
    bottom: 0,
    width: CHALLENGE_SWIPE_ACTION_WIDTH,
    justifyContent: "center",
    alignItems: "center",
    borderRadius: 22,
    overflow: "hidden",
  },
  challengeSwipeButton: {
    borderRadius: 16,
    paddingVertical: 12,
    paddingHorizontal: 10,
    width: "80%",
    alignItems: "center",
  },
  challengeSwipeButtonText: {
    ...createCtaText({ fontSize: 13, textAlign: "center" }),
  },
  goalProgressBar: {
    height: 8,
    borderRadius: 999,
    overflow: "hidden",
    marginTop: 16,
    marginBottom: 8,
  },
  goalProgressFill: {
    height: "100%",
    borderRadius: 999,
  },
  profileCard: {
    borderRadius: 30,
    padding: 24,
    alignItems: "center",
    marginBottom: 20,
  },
  profileMoodAura: {
    alignItems: "center",
    width: "100%",
    marginBottom: 12,
  },
  profileMoodGradient: {
    width: 170,
    height: 170,
    borderRadius: 85,
    justifyContent: "center",
    alignItems: "center",
    padding: 8,
  },
  profileMoodStatus: {
    ...createCtaText({ fontSize: 13, textTransform: "uppercase", marginTop: 10 }),
  },
  profileScrollContent: {
    paddingTop: 4,
    paddingBottom: 40,
    flexGrow: 1,
  },
  profileAvatarWrap: {
    alignItems: "center",
    marginBottom: 0,
    position: "relative",
  },
  profileAvatar: {
    width: 120,
    height: 120,
    borderRadius: 60,
  },
  profileNameRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  rewardBadgeSmall: {
    borderRadius: 999,
    paddingHorizontal: 10,
    paddingVertical: 4,
  },
  rewardBadgeSmallText: {
    ...createCtaText({ fontSize: 12 }),
  },
  profileAvatarHint: {
    ...createSecondaryText({ fontSize: 12, marginTop: 12, textAlign: "center" }),
  },
  profileAvatarEditBadge: {
    position: "absolute",
    top: 6,
    right: 6,
    width: 32,
    height: 32,
    borderRadius: 16,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  profileAvatarEditIcon: {
    fontSize: 15,
    fontWeight: "700",
  },
  profileName: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: scaleFontSize(28),
  },
  profileSubtitle: {
    ...createBodyText({ marginTop: 4 }),
    fontSize: PROFILE_SUBTITLE_FONT_SIZE,
    lineHeight: PROFILE_SUBTITLE_LINE_HEIGHT,
    textAlign: "center",
  },
  profileBio: {
    ...createBodyText({ marginTop: 10, textAlign: "center", lineHeight: 20 }),
  },
  profileStatsRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    width: "100%",
    marginTop: 20,
  },
  profileStat: {
    alignItems: "center",
    flex: 1,
    paddingHorizontal: 2,
  },
  profileStatValueRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 4,
  },
  profileStatValue: {
    ...createBodyText({ fontWeight: "700" }),
  },
  profileStatValueSuffix: {
    ...createBodyText({ fontWeight: "700" }),
  },
  profileStatLabel: {
    ...createCtaText({
      fontSize: PROFILE_STAT_LABEL_FONT_SIZE,
      textTransform: "uppercase",
      marginTop: 4,
      letterSpacing: PROFILE_STAT_LETTER_SPACING,
    }),
    textAlign: "center",
    flexShrink: 1,
  },
  profileActions: {
    width: "100%",
    marginTop: 20,
    gap: 12,
  },
  profileActionPrimary: {
    paddingVertical: 14,
    borderRadius: 24,
    alignItems: "center",
  },
  profileActionPrimaryText: {
    ...createCtaText(),
  },
  profileActionSecondary: {
    paddingVertical: 14,
    borderRadius: 24,
    alignItems: "center",
    borderWidth: 1,
  },
  profileActionPremiumLocked: {
    borderWidth: 1.5,
    ...Platform.select({
      android: {
        elevation: 0,
      },
      default: {
        shadowColor: "#4353FF",
        shadowOpacity: 0.14,
        shadowRadius: 10,
        shadowOffset: { width: 0, height: 5 },
      },
    }),
  },
  profileActionRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 8,
  },
  profileActionPremiumPill: {
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 8,
    paddingVertical: 2,
  },
  profileActionPremiumPillText: {
    ...createCtaText({ fontSize: 10, textTransform: "uppercase" }),
  },
  profileActionSecondaryText: {
    ...createCtaText(),
  },
  profileActionLockedLabel: {
    ...createCtaText({ fontSize: 12 }),
    marginTop: 6,
  },
  reportsBadgeChip: {
    borderRadius: 999,
    paddingHorizontal: 8,
    paddingVertical: 2,
  },
  reportsBadgeText: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase" }),
  },
  profileInput: {
    width: "100%",
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 16,
    paddingVertical: 10,
    marginBottom: 10,
  },
  profileInputPlaceholder: {
    fontSize: IS_COMPACT_DEVICE ? 13 : 14,
  },
  goalTargetInputWrap: {
    flexDirection: "row",
    alignItems: "center",
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 16,
    paddingVertical: 10,
    gap: 10,
  },
  goalTargetInput: {
    flex: 1,
    fontSize: 16,
    fontWeight: "600",
  },
  goalTargetCurrency: {
    fontWeight: "700",
  },
  goalTargetRow: {
    width: "100%",
    marginBottom: 12,
    gap: 6,
  },
  goalTargetLabel: {
    fontSize: 13,
    fontWeight: "600",
  },
  profileInputHalf: {
    flex: 1,
    width: "auto",
  },
  profileHintText: {
    fontSize: 12,
    lineHeight: 18,
  },
  profileSettingValue: {
    fontSize: 16,
    fontWeight: "600",
  },
  profileBioInput: {
    height: 90,
    textAlignVertical: "top",
  },
  inputRow: {
    flexDirection: "row",
    gap: 10,
    width: "100%",
  },
  settingsCard: {
    borderRadius: 26,
    padding: 20,
    marginBottom: 40,
  },
  profileSection: {
    marginBottom: 16,
    gap: 12,
  },
  settingsDivider: {
    height: 1,
    width: "100%",
    backgroundColor: "rgba(0,0,0,0.05)",
    marginVertical: 8,
  },
  settingsTitle: {
    fontSize: 20,
    fontWeight: "700",
    marginBottom: 16,
  },
  settingRow: {
    marginBottom: 18,
  },
  settingRowContent: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  settingRowActions: {
    flexDirection: "row",
    alignItems: "center",
    flexWrap: "wrap",
    justifyContent: "flex-end",
    gap: 8,
  },
  settingLabel: {
    marginBottom: 8,
  },
  settingValue: {
    fontSize: 16,
    fontWeight: "600",
  },
  settingChoices: {
    flexDirection: "row",
    gap: 12,
    flexWrap: "wrap",
  },
  settingCurrencyScrollWrapper: {
    position: "relative",
    marginTop: 4,
    marginRight: -32,
    paddingRight: 32,
  },
  settingCurrencyScroll: {
    marginTop: 0,
  },
  settingCurrencyScrollContent: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    paddingRight: 16,
  },
  incomeCalendarGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    width: "100%",
    marginTop: 4,
  },
  incomeCalendarDay: {
    width: "14.2857%",
    aspectRatio: 1,
    alignItems: "center",
    justifyContent: "center",
    borderRadius: 10,
    borderWidth: 1,
  },
  incomeCalendarDayText: {
    fontSize: IS_COMPACT_DEVICE ? 11 : 12,
    fontWeight: "600",
  },
  profileGoalGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 10,
  },
  profileGoalOption: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    borderWidth: 1,
    borderRadius: 20,
    paddingVertical: 8,
    paddingHorizontal: 12,
  },
  profileGoalEmoji: {
    fontSize: 18,
  },
  profileGoalText: {
    fontWeight: "600",
  },
  goalTargetBlock: {
    width: "100%",
    borderWidth: 1,
    borderRadius: 18,
    padding: 14,
    gap: 8,
  },
  goalTargetHeader: {
    gap: 4,
    marginBottom: 4,
  },
  goalTargetTitle: {
    fontSize: 15,
    fontWeight: "700",
  },
  goalTargetHint: {
    fontSize: 12,
  },
  onboardGuideHero: {
    flexDirection: "row",
    alignItems: "center",
    gap: 14,
  },
  onboardGuideHeroStacked: {
    flexDirection: "column",
    alignItems: "flex-start",
  },
  onboardGuideMascotWrap: {
    width: 92,
    height: 92,
    borderRadius: 24,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden",
  },
  onboardGuideMascot: {
    width: "120%",
    height: "120%",
  },
  onboardGuideBubbleWrap: {
    flex: 1,
    alignItems: "flex-start",
  },
  onboardGuideBubble: {
    position: "relative",
    borderRadius: 18,
    borderWidth: 1,
    paddingVertical: 10,
    paddingHorizontal: 14,
    shadowColor: "rgba(0,0,0,0.3)",
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.12,
    shadowRadius: 10,
    elevation: 3,
  },
  onboardGuideBubbleText: {
    ...createBodyText({ fontSize: 18, lineHeight: 23 }),
    fontWeight: "700",
  },
  onboardGuideBubbleTail: {
    position: "absolute",
    left: 18,
    bottom: -6,
    width: 12,
    height: 12,
    transform: [{ rotate: "45deg" }],
    borderWidth: 1,
    borderTopWidth: 0,
    borderLeftWidth: 0,
  },
  guideCards: {
    width: "100%",
    gap: 12,
  },
  guideCard: {
    borderRadius: 22,
    padding: 18,
    borderWidth: 1,
    gap: 8,
  },
  guideTitleRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  guideEmojiInline: {
    fontSize: 22,
  },
  guideEmoji: {
    fontSize: 28,
  },
  guideTitle: {
    fontSize: 16,
    fontWeight: "700",
  },
  guideDesc: {
    fontSize: 13,
    lineHeight: 18,
  },
  settingToggle: {
    width: 48,
    height: 28,
    borderRadius: 16,
    borderWidth: 1,
    padding: 2,
    justifyContent: "center",
  },
  settingToggleHandle: {
    width: 22,
    height: 22,
    borderRadius: 12,
  },
  settingChip: {
    paddingHorizontal: 14,
    paddingVertical: 8,
    borderRadius: 18,
    borderWidth: 1,
  },
  resetButton: {
    marginTop: Platform.OS === "ios" ? 16 : 8,
    paddingVertical: 12,
    borderWidth: 1,
    borderRadius: 18,
    alignItems: "center",
  },
  analyticsCard: {
    borderRadius: 26,
    padding: 20,
    marginBottom: 24,
  },
  analyticsTitle: {
    fontSize: 18,
    fontWeight: "700",
    marginBottom: 12,
  },
  analyticsRow: {
    flexDirection: "row",
    gap: 12,
  },
  analyticsItem: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 14,
    paddingHorizontal: 12,
    alignItems: "center",
  },
  analyticsValue: {
    fontSize: 22,
    fontWeight: "800",
  },
  analyticsLabel: {
    marginTop: 6,
    fontSize: 12,
    textAlign: "center",
  },
  historyCard: {
    borderRadius: 26,
    padding: 20,
    marginBottom: 80,
  },
  historyTitle: {
    fontSize: 20,
    fontWeight: "700",
    marginBottom: 12,
  },
  historyEmpty: {
    fontSize: 14,
  },
  historyList: {
    borderWidth: StyleSheet.hairlineWidth,
    borderRadius: 20,
  },
  historyListContent: {
    paddingHorizontal: 12,
  },
  historyMoreButton: {
    marginTop: 12,
    borderWidth: 1,
    borderRadius: 14,
    alignSelf: "flex-start",
    paddingHorizontal: 14,
    paddingVertical: 8,
  },
  historyMoreText: {
    ...createBodyText({ fontWeight: "600", fontSize: 13 }),
  },
  historyItem: {
    paddingVertical: 12,
  },
  historyRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  historyDeleteBtn: {
    width: 32,
    height: 32,
    borderWidth: 1,
    borderRadius: 16,
    alignItems: "center",
    justifyContent: "center",
  },
  historyDeleteText: {
    fontSize: 16,
    fontWeight: "700",
  },
  historyItemTitle: {
    ...createBodyText({ fontWeight: "600" }),
  },
  historyItemMeta: {
    ...createSecondaryText({ marginTop: 4 }),
  },
  reportsModalRoot: {
    flex: 1,
    justifyContent: "center",
  },
  reportsBackdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(0,0,0,0.45)",
  },
  reportsModalWrap: {
    flex: 1,
    justifyContent: "center",
    paddingHorizontal: 16,
  },
  reportsModalCard: {
    borderRadius: 20,
    borderWidth: 1,
    padding: 16,
    maxHeight: IS_SHORT_DEVICE ? "74%" : "82%",
  },
  reportsHeaderRow: {
    flexDirection: "row",
    alignItems: "flex-start",
    justifyContent: "space-between",
    gap: 12,
    marginBottom: 12,
  },
  reportsTitle: {
    fontSize: 18,
    fontWeight: "800",
  },
  reportsUpdated: {
    ...createSecondaryText({ fontSize: 12, marginTop: 4 }),
  },
  reportsClose: {
    padding: 4,
  },
  reportsCloseText: {
    fontSize: 18,
    fontWeight: "700",
  },
  reportsTabsRow: {
    flexDirection: "row",
    gap: 10,
    marginBottom: 12,
  },
  reportsTab: {
    flex: 1,
    paddingVertical: 8,
    borderRadius: 16,
    borderWidth: 1,
    alignItems: "center",
  },
  reportsTabText: {
    fontSize: 13,
    fontWeight: "600",
  },
  reportsList: {
    flexGrow: 0,
  },
  reportsListContent: {
    paddingBottom: 12,
  },
  reportsEmpty: {
    ...createBodyText({ textAlign: "center", marginVertical: 16 }),
  },
  reportCard: {
    borderWidth: 1,
    borderRadius: 18,
    padding: 14,
    marginBottom: 12,
    gap: 12,
  },
  reportHeaderRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 8,
  },
  reportTitle: {
    fontSize: 16,
    fontWeight: "700",
    flex: 1,
  },
  reportBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
    borderWidth: 1,
  },
  reportBadgeText: {
    fontSize: 11,
    fontWeight: "600",
    textTransform: "uppercase",
  },
  reportStatsRow: {
    flexDirection: "row",
    gap: 8,
  },
  reportStatPill: {
    flex: 1,
    borderRadius: 12,
    padding: 10,
    borderWidth: 1,
    gap: 6,
  },
  reportStatLabel: {
    ...createCtaText({ fontSize: 10, textTransform: "uppercase" }),
  },
  reportStatValue: {
    fontSize: 16,
    fontWeight: "700",
  },
  reportTopRow: {
    flexDirection: "row",
    gap: 10,
  },
  reportTopItem: {
    flex: 1,
    gap: 4,
  },
  reportTopLabel: {
    ...createSecondaryText({ fontSize: 11 }),
  },
  reportTopValue: {
    ...createBodyText({ fontWeight: "600" }),
  },
  reportTopAmount: {
    ...createSecondaryText({ fontSize: 12, fontWeight: "700" }),
  },
  reportSection: {
    gap: 6,
  },
  reportSectionTitle: {
    fontSize: 13,
    fontWeight: "700",
  },
  reportSectionList: {
    gap: 4,
  },
  reportLine: {
    ...createSecondaryText({ fontSize: 12, lineHeight: 18 }),
  },
  profileLinkButton: {
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 10,
    paddingHorizontal: 14,
    marginBottom: 16,
    gap: 2,
  },
  profileLinkText: {
    ...createCtaText({ fontSize: 14 }),
  },
  profileLinkHint: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  resetButtonText: {
    ...createCtaText(),
  },
  tabBar: {
    flexDirection: "row",
    borderTopWidth: 1,
    paddingHorizontal: 12,
    overflow: "visible",
  },
  tabBarDimmed: {
    opacity: 0.35,
  },
  tabButton: {
    flex: 1,
    paddingVertical: 14,
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
  },
  tabButtonHighlight: {
    borderWidth: 1,
    borderRadius: 18,
    marginHorizontal: 4,
    paddingHorizontal: 10,
    shadowColor: "#000",
    shadowOpacity: 0.08,
    shadowRadius: 8,
    shadowOffset: { width: 0, height: 4 },
    elevation: 4,
  },
  tabButtonText: {
    ...createCtaText({ fontSize: 13, textTransform: "uppercase" }),
    marginTop: 6,
  },
  tabLockIconOverlay: {
    fontSize: 12,
    lineHeight: 14,
    position: "absolute",
    top: 4,
    left: "50%",
    marginLeft: -7,
    textAlign: "center",
    textAlignVertical: "center",
  },
  tabLockIconOverlayCompact: {
    fontSize: 10,
    lineHeight: 12,
    top: 1,
    marginLeft: -6,
  },
  tabBadge: {
    minWidth: 20,
    height: 20,
    borderRadius: 10,
    paddingHorizontal: 6,
    alignItems: "center",
    justifyContent: "center",
  },
  tabBadgeDot: {
    width: 20,
    paddingHorizontal: 0,
  },
  tabBadgeFloating: {
    position: "absolute",
    top: -6,
    right: -2,
  },
  tabBadgeText: {
    ...createCtaText({ fontSize: 11, textTransform: "none" }),
  },
  analyticsConsentScreen: {
    flex: 1,
    justifyContent: "flex-start",
    padding: 24,
    paddingTop: 48,
    gap: 20,
  },
  analyticsConsentContent: {
    flexGrow: 1,
  },
  analyticsConsentCard: {
    borderRadius: 32,
    borderWidth: 1,
    padding: 28,
    gap: 20,
  },
  analyticsConsentTitle: {
    ...TYPOGRAPHY.blockTitle,
  },
  analyticsConsentBody: {
    ...createBodyText({ lineHeight: 22 }),
  },
  analyticsConsentPrimary: {
    borderRadius: 20,
    paddingVertical: 14,
    alignItems: "center",
  },
  analyticsConsentPrimaryText: {
    ...createCtaText({ fontSize: 15 }),
  },
  analyticsConsentSecondary: {
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
  },
  analyticsConsentSecondaryText: {
    ...createCtaText({ fontSize: 14 }),
  },
  modalContainer: {
    flex: 1,
    justifyContent: "flex-end",
    backgroundColor: "rgba(0,0,0,0.4)",
  },
  paySheet: {
    borderTopLeftRadius: 30,
    borderTopRightRadius: 30,
    padding: 24,
  },
  modalTitle: {
    fontSize: 28,
    fontWeight: "700",
    marginBottom: 16,
  },
  payCard: {
    borderRadius: 22,
    padding: 18,
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 14,
  },
  payLabel: {
    fontSize: 12,
    textTransform: "uppercase",
  },
  payDigits: {
    marginTop: 6,
    fontSize: 16,
  },
  payAmount: {
    fontWeight: "700",
    fontSize: 20,
  },
  payOptions: {
    flexDirection: "row",
    gap: 12,
    marginBottom: 10,
  },
  payOptionChip: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 10,
    alignItems: "center",
  },
  partialInputWrap: {
    marginTop: 6,
  },
  partialLabel: {
    marginBottom: 6,
  },
  partialInput: {
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 16,
    paddingVertical: 10,
  },
  partialInfo: {
    ...createBodyText({ marginVertical: 12, textAlign: "center" }),
  },
  appleButton: {
    paddingVertical: 16,
    borderRadius: 26,
    alignItems: "center",
    marginTop: 12,
  },
  appleButtonText: {
    ...createCtaText({ fontSize: 16 }),
  },
  payCancel: {
    ...createSecondaryText({ textAlign: "center", marginTop: 12 }),
  },
  fabCenterContainer: {
    position: "absolute",
    bottom: FAB_CONTAINER_BOTTOM,
    right: FAB_CONTAINER_SIDE,
    alignItems: "flex-end",
    justifyContent: "center",
  },
  fabButtonWrapper: {
    width: FAB_BUTTON_SIZE,
    height: FAB_BUTTON_SIZE,
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
  },
  cartBadge: {
    width: FAB_BUTTON_SIZE,
    height: FAB_BUTTON_SIZE,
    borderRadius: FAB_BUTTON_SIZE / 2,
    justifyContent: "center",
    alignItems: "center",
    shadowColor: "#000",
    shadowOpacity: 0.2,
    shadowOffset: { width: 0, height: 2 },
    shadowRadius: 4,
    elevation: 4,
    borderWidth: 1,
  },
  cartBadgeHighlight: {
    borderColor: "#F5C869",
    shadowColor: "#F5C869",
    shadowOpacity: 0.85,
    shadowRadius: 16,
    elevation: 8,
    borderWidth: 2,
    borderRadius: FAB_BUTTON_SIZE / 2,
  },
  cartBadgeIcon: {
    fontSize: 20,
    lineHeight: 20,
    fontWeight: "700",
    letterSpacing: 0.5,
    textAlign: "center",
    textAlignVertical: "center",
    includeFontPadding: false,
  },
  fabMenuOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "flex-end",
    alignItems: "flex-end",
    paddingBottom: 180,
    paddingHorizontal: 24,
  },
  fabMenuBackdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(0,0,0,0.15)",
  },
  fabOption: {
    alignItems: "center",
    justifyContent: "center",
  },
  fabOptionRow: {
    alignSelf: "flex-end",
  },
  fabOptionRowContent: {
    flexDirection: "row",
    gap: 12,
  },
  fabCircle: {
    width: 88,
    height: 88,
    borderRadius: 44,
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 1,
    paddingHorizontal: 8,
  },
  fabOptionText: {
    fontSize: 13,
    fontWeight: "700",
    textAlign: "center",
    lineHeight: 16,
  },
  fabTutorialBackdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "transparent",
    justifyContent: "flex-end",
    alignItems: "center",
  },
  fabTutorialOverlaySvg: {
    ...StyleSheet.absoluteFillObject,
  },
  fabTutorialContent: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "flex-end",
    alignItems: "center",
    paddingHorizontal: 24,
  },
  fabTutorialHalo: {
    position: "absolute",
    width: FAB_TUTORIAL_HALO_SIZE,
    height: FAB_TUTORIAL_HALO_SIZE,
    borderRadius: FAB_TUTORIAL_HALO_SIZE / 2,
    borderWidth: 2,
    top: -FAB_TUTORIAL_HALO_INSET,
    left: -FAB_TUTORIAL_HALO_INSET,
    shadowOpacity: 0.65,
    shadowRadius: 28,
    shadowOffset: { width: 0, height: 6 },
    elevation: 6,
    zIndex: -1,
  },
  fabTutorialCard: {
    width: "90%",
    maxWidth: 360,
    borderRadius: 24,
    paddingHorizontal: 20,
    paddingVertical: 20,
    borderWidth: 1,
  },
  fabTutorialTitle: {
    fontSize: 18,
    fontWeight: "700",
    textAlign: "center",
    marginBottom: 8,
  },
  fabTutorialDescription: {
    fontSize: 15,
    lineHeight: 21,
    textAlign: "center",
    marginBottom: 16,
  },
  fabTutorialButton: {
    borderRadius: 16,
    paddingVertical: 12,
    paddingHorizontal: 16,
  },
  fabTutorialButtonText: {
    fontSize: 15,
    fontWeight: "700",
    textAlign: "center",
  },
  budgetTutorialBackdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(0,0,0,0.55)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  budgetTutorialCard: {
    width: "100%",
    maxWidth: 380,
    borderRadius: 24,
    padding: 20,
    borderWidth: 1,
    gap: 14,
  },
  budgetTutorialTitle: {
    fontSize: 18,
    fontWeight: "700",
    textAlign: "center",
  },
  budgetTutorialSubtitle: {
    fontSize: 14,
    lineHeight: 20,
    textAlign: "center",
  },
  budgetTutorialHero: {
    borderRadius: 16,
    padding: 14,
    borderWidth: 1,
    gap: 10,
  },
  budgetTutorialHeroHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 8,
  },
  budgetTutorialHeroTitle: {
    fontSize: 14,
    fontWeight: "700",
  },
  budgetTutorialHeroChip: {
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 10,
    paddingVertical: 4,
  },
  budgetTutorialHeroChipText: {
    fontSize: 11,
    fontWeight: "700",
  },
  budgetTutorialHeroRows: {
    gap: 8,
  },
  budgetTutorialHeroRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  budgetTutorialHeroEmoji: {
    fontSize: 16,
  },
  budgetTutorialHeroTrack: {
    flex: 1,
    height: 6,
    borderRadius: 999,
    overflow: "hidden",
  },
  budgetTutorialHeroFill: {
    height: "100%",
    borderRadius: 999,
  },
  budgetTutorialIllustrations: {
    flexDirection: "row",
    flexWrap: "wrap",
    justifyContent: "center",
    gap: 10,
  },
  budgetTutorialIllustrationCard: {
    flex: 1,
    minWidth: 92,
    borderRadius: 14,
    borderWidth: 1,
    padding: 10,
    alignItems: "center",
    gap: 6,
  },
  budgetTutorialIllustrationEmoji: {
    fontSize: 18,
  },
  budgetTutorialIllustrationTitle: {
    fontSize: 12,
    fontWeight: "700",
    textAlign: "center",
  },
  budgetTutorialIllustrationDesc: {
    fontSize: 11,
    lineHeight: 14,
    textAlign: "center",
  },
  budgetTutorialButton: {
    borderRadius: 16,
    paddingVertical: 12,
    paddingHorizontal: 16,
  },
  budgetTutorialButtonText: {
    fontSize: 15,
    fontWeight: "700",
    textAlign: "center",
  },
  quickModalBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.4)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  quickModalCard: {
    width: "100%",
    borderRadius: 28,
    padding: 20,
    gap: 14,
  },
  dailyGoalCollectHero: {
    alignSelf: "center",
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    paddingHorizontal: 14,
    paddingVertical: 8,
    borderRadius: 999,
    borderWidth: 1,
  },
  dailyGoalCollectCoin: {
    width: 26,
    height: 26,
    resizeMode: "contain",
  },
  dailyGoalCollectAmount: {
    fontSize: 20,
    fontWeight: "700",
  },
  coinValueHero: {
    height: 140,
    borderRadius: 22,
    backgroundColor: LEVEL_SHARE_BG,
    borderWidth: 1,
    borderColor: "rgba(255,180,71,0.6)",
    justifyContent: "center",
    alignItems: "center",
    overflow: "hidden",
  },
  coinValueHeroGlow: {
    position: "absolute",
    top: -40,
    right: -20,
    width: 140,
    height: 140,
    borderRadius: 70,
    backgroundColor: "rgba(255,180,71,0.25)",
  },
  coinValueHeroCat: {
    width: 92,
    height: 92,
    resizeMode: "contain",
  },
  coinValueHeroFooter: {
    position: "absolute",
    bottom: 12,
    right: 14,
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  coinValueHeroLogo: {
    width: 18,
    height: 18,
    resizeMode: "contain",
  },
  coinValueHeroBrand: {
    color: LEVEL_SHARE_MUTED,
    fontSize: 12,
    fontWeight: "600",
  },
  quickModalTitle: {
    fontSize: 20,
    fontWeight: "700",
  },
  quickModalSubtitle: {
    fontSize: 14,
    lineHeight: 20,
  },
  quickModalHint: {
    fontSize: 12,
    lineHeight: 18,
  },
  quickModalDisclaimer: {
    fontSize: 13,
    lineHeight: 19,
    fontWeight: "800",
  },
  quickModalActions: {
    flexDirection: "row",
    gap: 12,
    width: "100%",
  },
  quickModalSecondary: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 16,
    justifyContent: "center",
    alignItems: "center",
    paddingVertical: 12,
  },
  quickModalSecondaryText: {
    fontWeight: "600",
  },
  quickModalPrimary: {
    flex: 1,
    borderRadius: 16,
    justifyContent: "center",
    alignItems: "center",
    paddingVertical: 12,
  },
  quickModalPrimaryText: {
    ...createCtaText(),
  },
  savingsModalHero: {
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  savingsModalBadge: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: "#FFE7A3",
    alignItems: "center",
    justifyContent: "center",
  },
  savingsModalBadgeText: {
    fontSize: 18,
  },
  savingsModalRange: {
    width: "100%",
    paddingVertical: 10,
    paddingHorizontal: 12,
    borderRadius: 16,
    alignItems: "center",
  },
  savingsModalRangeText: {
    fontSize: 18,
    fontWeight: "800",
  },
  frequencyPickerWrap: {
    width: "100%",
    gap: 8,
  },
  frequencyPickerLabel: {
    fontSize: 12,
    fontWeight: "600",
    textTransform: "uppercase",
    letterSpacing: 0.6,
  },
  segmentedSlider: {
    width: "100%",
    borderRadius: 16,
    borderWidth: 1,
    backgroundColor: "rgba(0,0,0,0.06)",
    flexDirection: "row",
    overflow: "hidden",
  },
  segmentedSliderIndicator: {
    position: "absolute",
    top: 2,
    bottom: 2,
    left: 2,
    borderRadius: 14,
  },
  segmentedSliderOption: {
    flex: 1,
    paddingVertical: 10,
    paddingHorizontal: 6,
    alignItems: "center",
    justifyContent: "center",
  },
  segmentedSliderOptionText: {
    fontSize: 12,
    fontWeight: "700",
  },
  segmentedSliderOptionTextActive: {
    textShadowColor: "rgba(0,0,0,0.15)",
    textShadowOffset: { width: 0, height: 1 },
    textShadowRadius: 2,
  },
  frequencyCustomRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
  },
  frequencyCustomSummary: {
    fontSize: 13,
    fontWeight: "600",
  },
  frequencyCustomEdit: {
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 12,
    paddingVertical: 6,
  },
  frequencyCustomEditText: {
    fontSize: 12,
    fontWeight: "700",
  },
  frequencyModalCard: {
    width: "100%",
    maxWidth: 420,
    borderRadius: 24,
    padding: 20,
    gap: 14,
    borderWidth: 1,
  },
  frequencyModalTitle: {
    fontSize: 20,
    fontWeight: "700",
  },
  frequencyModalSubtitle: {
    fontSize: 14,
    lineHeight: 20,
  },
  frequencyModalRow: {
    width: "100%",
    gap: 12,
  },
  frequencyModalInputWrap: {
    width: "100%",
    gap: 6,
  },
  frequencyModalUnitWrap: {
    width: "100%",
    gap: 6,
  },
  frequencyModalLabel: {
    fontSize: 12,
    fontWeight: "600",
    textTransform: "uppercase",
    letterSpacing: 0.6,
  },
  frequencyModalUnitSlider: {
    borderRadius: 14,
  },
  frequencyModalUnitText: {
    fontSize: 11,
  },
  frequencyModalError: {
    fontSize: 12,
    fontWeight: "600",
  },
  coinEntryOverlayRoot: {
    flex: 1,
  },
  coinEntryRevealCircle: {
    position: "absolute",
    width: COIN_REVEAL_SIZE,
    height: COIN_REVEAL_SIZE,
    borderRadius: COIN_REVEAL_SIZE / 2,
  },
  coinEntryCloseTint: {
    ...StyleSheet.absoluteFillObject,
  },
  coinEntryFlightCoin: {
    position: "absolute",
    width: COIN_FLIGHT_SIZE,
    height: COIN_FLIGHT_SIZE,
    alignItems: "center",
    justifyContent: "center",
    zIndex: 4,
    elevation: 20,
  },
  coinEntryFlightCoinImage: {
    width: COIN_FLIGHT_SIZE,
    height: COIN_FLIGHT_SIZE,
    resizeMode: "contain",
  },
  coinEntryBackdrop: {
    flex: 1,
    backgroundColor: "transparent",
    paddingHorizontal: 24,
    paddingVertical: IS_SHORT_DEVICE ? 12 : 24,
    justifyContent: "center",
    alignItems: "center",
  },
  coinEntryCard: {
    width: "100%",
    maxWidth: 420,
    borderRadius: 32,
    paddingHorizontal: 22,
    paddingVertical: IS_SHORT_DEVICE ? 14 : 22,
    borderWidth: 1,
    gap: IS_SHORT_DEVICE ? 10 : 16,
  },
  coinEntryHeader: {
    flexDirection: "row",
    alignItems: "flex-start",
    gap: 12,
  },
  coinEntryTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 24,
  },
  coinEntrySubtitle: {
    ...createBodyText({ fontSize: 15, lineHeight: 20 }),
  },
  coinEntryClose: {
    padding: 4,
  },
  coinEntryCloseText: {
    fontSize: 20,
    fontWeight: "700",
  },
  coinEntryAmountRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  coinEntryAmount: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 28,
  },
  coinEntryManualTapHint: {
    ...createBodyText({ fontSize: 12, lineHeight: 16 }),
    textAlign: "center",
    marginTop: IS_SHORT_DEVICE ? 3 : 6,
  },
  coinSliderWrapper: {
    marginTop: IS_SHORT_DEVICE ? 12 : 20,
    alignItems: "center",
    justifyContent: "center",
    minHeight: COIN_SLIDER_SIZE + (IS_SHORT_DEVICE ? 22 : 40),
    width: "100%",
  },
  coinSliderBackdrop: {
    position: "absolute",
    width: "100%",
    height: "100%",
    borderRadius: 24,
  },
  coinCircle: {
    width: COIN_SLIDER_SIZE,
    height: COIN_SLIDER_SIZE,
    borderRadius: COIN_SLIDER_SIZE / 2,
    borderWidth: 3,
    backgroundColor: "#F6F8FC",
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden",
    shadowOpacity: 0.25,
    shadowRadius: 18,
    shadowOffset: { width: 0, height: 12 },
    elevation: 12,
  },
  coinInnerSurface: {
    width: COIN_SLIDER_SIZE - 24,
    height: COIN_SLIDER_SIZE - 24,
    borderRadius: (COIN_SLIDER_SIZE - 24) / 2,
    backgroundColor: "#ECEFF5",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.8)",
    justifyContent: "center",
    alignItems: "center",
    overflow: "hidden",
  },
  coinFillTrack: {
    position: "absolute",
    bottom: 0,
    width: "100%",
    alignItems: "center",
  },
  coinFill: {
    width: "100%",
    borderTopLeftRadius: (COIN_SLIDER_SIZE - 24) / 2,
    borderTopRightRadius: (COIN_SLIDER_SIZE - 24) / 2,
  },
  coinShine: {
    position: "absolute",
    top: 18,
    left: 26,
    width: 86,
    height: 14,
    borderRadius: 14,
    opacity: 0.6,
  },
  coinCurrencySymbol: {
    fontSize: 48,
    fontWeight: "800",
    opacity: 0.2,
  },
  coinDirectionLabels: {
    flexDirection: "row",
    justifyContent: "space-between",
    width: "100%",
    paddingHorizontal: 16,
    marginTop: IS_SHORT_DEVICE ? 6 : 12,
  },
  coinDirectionLabel: {
    fontSize: 13,
    fontWeight: "700",
    textTransform: "uppercase",
  },
  coinEntryActions: {
    flexDirection: "row",
    gap: 12,
    marginTop: IS_SHORT_DEVICE ? 10 : 16,
  },
  coinEntryActionButton: {
    flex: 1,
    borderRadius: 20,
    paddingVertical: IS_SHORT_DEVICE ? 10 : 14,
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "#000",
    shadowOpacity: 0.08,
    shadowRadius: 8,
    shadowOffset: { width: 0, height: 4 },
    elevation: 4,
  },
  coinEntryActionButtonSpend: {
    backgroundColor: COIN_ENTRY_SPEND_BACKGROUND,
  },
  coinEntryActionButtonSave: {
    backgroundColor: COIN_ENTRY_SAVE_BACKGROUND,
  },
  coinEntryActionButtonText: {
    fontSize: 16,
    fontWeight: "700",
  },
  coinEntryActionButtonTextSpend: {
    color: "#FFFFFF",
  },
  coinEntryActionButtonTextSave: {
    color: "#FFFFFF",
  },
  coinEntryHint: {
    ...createBodyText({ fontSize: IS_SHORT_DEVICE ? 12 : 13 }),
  },
  coinEntryCategoryLabel: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: IS_SHORT_DEVICE ? 15 : 18,
  },
  coinEntryError: {
    fontSize: 12,
    fontWeight: "600",
  },
  coinEntryCategoryScroll: {
    width: "100%",
  },
  coinEntryCategoryRow: {
    flexDirection: "row",
    gap: 10,
    paddingHorizontal: 4,
  },
  coinEntryCategoryButton: {
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: IS_SHORT_DEVICE ? 8 : 14,
    paddingHorizontal: 8,
    alignItems: "center",
    gap: 6,
  },
  coinEntryCategoryEmoji: {
    fontSize: 28,
  },
  coinEntryCategoryText: {
    fontSize: 10,
    fontWeight: "700",
    textAlign: "center",
  },
  coinEntryMaxLabel: {
    fontSize: 14,
    fontWeight: "600",
  },
  coinEntryManualBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.6)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  coinEntryManualCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 28,
    padding: 20,
    borderWidth: 1,
    gap: 12,
  },
  coinEntryManualTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 20,
  },
  coinEntryManualInput: {
    borderWidth: 1,
    borderRadius: 16,
    paddingHorizontal: 14,
    paddingVertical: 10,
    fontSize: 18,
    fontWeight: "600",
  },
  coinEntryManualError: {
    fontSize: 12,
    fontWeight: "600",
  },
  coinEntryManualActions: {
    flexDirection: "row",
    gap: 12,
  },
  coinEntryManualButtonGhost: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 12,
    alignItems: "center",
  },
  coinEntryManualButtonGhostText: {
    fontWeight: "600",
  },
  coinEntryManualButtonPrimary: {
    flex: 1,
    borderRadius: 16,
    paddingVertical: 12,
    alignItems: "center",
  },
  coinEntryManualButtonPrimaryText: {
    ...createCtaText(),
  },
  termsCard: {
    width: "100%",
    borderRadius: 28,
    padding: 22,
    gap: 12,
  },
  termsTitle: {
    ...TYPOGRAPHY.blockTitle,
    textAlign: "center",
  },
  termsSubtitle: {
    ...createBodyText({ fontSize: 15, lineHeight: 22, textAlign: "center" }),
  },
  termsScroll: {
    maxHeight: 260,
    marginVertical: 4,
  },
  termsScrollContent: {
    paddingBottom: 4,
    gap: 12,
  },
  termsPoint: {
    flexDirection: "row",
    gap: 8,
  },
  termsPointIndex: {
    ...createCtaText({ fontSize: 13 }),
  },
  termsPointText: {
    ...createBodyText({ flex: 1, fontSize: 15, lineHeight: 22 }),
  },
  termsLinkButton: {
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 10,
    alignItems: "center",
  },
  termsLinkText: {
    ...createCtaText({ fontSize: 14 }),
  },
  termsHint: {
    ...createSecondaryText({ fontSize: 12, textAlign: "center" }),
  },
  languageMascot: {
    width: 220,
    height: 220,
    alignSelf: "center",
    marginBottom: 4,
  },
  confettiLayer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  overlayFullScreen: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
  },
  overlayTouchable: {
    ...StyleSheet.absoluteFillObject,
  },
  overlayDim: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(5, 6, 15, 0.2)",
  },
  celebrationBanner: {
    position: "absolute",
    top: "35%",
    paddingHorizontal: 28,
    paddingVertical: 20,
    borderRadius: 30,
    alignItems: "center",
    gap: 12,
  },
  celebrationText: {
    fontWeight: "700",
    fontSize: 18,
    textAlign: "center",
  },
  celebrationSubtext: {
    fontWeight: "600",
    fontSize: 14,
    textAlign: "center",
  },
  focusDigestCard: {
    width: "86%",
    borderRadius: 30,
    borderWidth: 1,
    padding: 24,
    gap: 14,
  },
  focusDigestTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 22,
    textAlign: "center",
  },
  focusDigestBody: {
    ...createBodyText({ fontSize: 15, lineHeight: 22 }),
    textAlign: "center",
  },
  focusDigestStats: {
    flexDirection: "row",
    gap: 12,
  },
  focusDigestStat: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 18,
    padding: 12,
    gap: 4,
  },
  focusDigestLabel: {
    ...createCtaText({ fontSize: 10, textTransform: "uppercase" }),
  },
  focusDigestValue: {
    ...createBodyText({ fontSize: 15, fontWeight: "700" }),
  },
  focusDigestHint: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  focusDigestButtons: {
    flexDirection: "row",
    gap: 12,
    marginTop: 6,
  },
  focusDigestPrimary: {
    flex: 1,
    borderRadius: 16,
    paddingVertical: 12,
    paddingHorizontal: 12,
    alignItems: "center",
  },
  focusDigestPrimaryText: {
    ...createCtaText({ fontSize: 14 }),
  },
  focusDigestSecondary: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 12,
    paddingHorizontal: 12,
    alignItems: "center",
  },
  focusDigestSecondaryText: {
    ...createCtaText({ fontSize: 14 }),
  },
  focusRewardCard: {
    width: "82%",
    borderRadius: 30,
    borderWidth: 1,
    padding: 24,
    gap: 14,
    alignItems: "center",
  },
  focusRewardIconRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  focusRewardCoin: {
    width: 48,
    height: 48,
  },
  focusRewardAmount: {
    ...createCtaText({ fontSize: 24 }),
  },
  focusRewardTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 24,
    textAlign: "center",
  },
  focusRewardBody: {
    ...createBodyText({ fontSize: 15, lineHeight: 22 }),
    textAlign: "center",
  },
  focusRewardButton: {
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 24,
    paddingVertical: 10,
  },
  focusRewardButtonText: {
    ...createCtaText({ fontSize: 14 }),
  },
  impulseCategoryPicker: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  impulseCategoryPickerScroll: {
    width: "100%",
  },
  impulseCategoryPickerScrollContent: {
    paddingVertical: 2,
    paddingHorizontal: 4,
  },
  impulseCategoryPickerCompact: {
    marginTop: 2,
  },
  impulseCategoryChip: {
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 6,
    paddingHorizontal: 14,
    alignItems: "center",
    justifyContent: "center",
  },
  impulseCategoryChipCompact: {
    paddingVertical: 4,
    paddingHorizontal: 12,
  },
  impulseCategoryChipTall: {
    paddingVertical: 8,
    minHeight: 36,
  },
  impulseCategoryChipTallCompact: {
    paddingVertical: 6,
    minHeight: 34,
  },
  impulseCategoryChipText: {
    ...createCtaText({ fontSize: 10 }),
    textAlign: "center",
  },
  impulseCategoryChipTextCompact: {
    fontSize: 9,
  },
  impulseAlertCard: {
    marginHorizontal: 24,
    borderRadius: 28,
    borderWidth: 1,
    overflow: "hidden",
    position: "relative",
  },
  impulseAlertGlow: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.18,
  },
  impulseAlertContent: {
    padding: 24,
    gap: 16,
    position: "relative",
  },
  impulseAlertHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  impulseAlertBadge: {
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 999,
    borderWidth: 1,
  },
  impulseAlertBadgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  impulseAlertEmoji: {
    fontSize: 28,
  },
  impulseAlertTitle: {
    ...TYPOGRAPHY.blockTitle,
  },
  impulseAlertBody: {
    ...createBodyText({ fontSize: 15, lineHeight: 22 }),
  },
  impulseAlertStats: {
    flexDirection: "row",
    gap: 12,
  },
  impulseAlertStat: {
    flex: 1,
    borderRadius: 18,
    padding: 14,
    borderWidth: 1,
  },
  impulseAlertStatLabel: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase" }),
  },
  impulseAlertStatValue: {
    ...createBodyText({ fontSize: 18, fontWeight: "800", marginTop: 6 }),
  },
  impulseAlertMoodCard: {
    borderRadius: 18,
    borderWidth: 1,
    padding: 12,
  },
  impulseAlertMood: {
    ...createBodyText({ fontSize: 14, lineHeight: 20 }),
  },
  impulseAlertButton: {
    borderRadius: 16,
    paddingVertical: 13,
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "row",
    gap: 8,
  },
  impulseAlertButtonText: {
    ...createCtaText({ fontSize: 15 }),
  },
  impulseAlertButtonIcon: {
    ...createCtaText({ fontSize: 16 }),
  },
  celebrationCat: {
    width: 90,
    height: 90,
    borderRadius: 18,
    opacity: 0.9,
  },
  catHappy: {
    transform: [{ scale: 1.05 }],
  },
  catSad: {
    opacity: 0.7,
  },
  levelOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
  },
  levelBackdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(241,247,255,0.92)",
  },
  levelAura: {
    position: "absolute",
    width: 320,
    height: 320,
    borderRadius: 160,
    top: "18%",
    left: "14%",
  },
  levelAuraSecondary: {
    width: 280,
    height: 280,
    borderRadius: 140,
    top: undefined,
    left: undefined,
    right: "8%",
    bottom: "18%",
  },
  levelContent: {
    width: "88%",
    maxWidth: 380,
    padding: 24,
    borderRadius: 30,
    backgroundColor: "rgba(255,255,255,0.95)",
    borderWidth: 1,
    borderColor: "rgba(73,141,248,0.26)",
    alignItems: "center",
    gap: 10,
    overflow: "hidden",
    shadowColor: "#000",
    shadowOpacity: 0.18,
    shadowOffset: { width: 0, height: 16 },
    shadowRadius: 26,
    elevation: 10,
  },
  levelHeroRow: {
    width: "100%",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 2,
  },
  levelBadge: {
    borderWidth: 1,
    borderRadius: 999,
    paddingHorizontal: 12,
    paddingVertical: 6,
  },
  levelBadgeText: {
    ...createCtaText({ fontSize: 10 }),
    letterSpacing: 0.45,
  },
  levelHeroCat: {
    width: 72,
    height: 72,
  },
  levelTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 29,
    textAlign: "center",
  },
  levelSubtitle: {
    ...createBodyText({ fontSize: 15, lineHeight: 22, fontWeight: "700", textAlign: "center" }),
  },
  levelProgressPreview: {
    width: "100%",
    borderRadius: 18,
    borderWidth: 1,
    borderColor: "rgba(125,190,255,0.24)",
    paddingVertical: 10,
    paddingHorizontal: 12,
    marginTop: 4,
    marginBottom: 2,
    gap: 6,
  },
  levelProgressRow: {
    width: "100%",
  },
  levelProgressTrack: {
    width: "100%",
    height: 6,
    borderRadius: 999,
    overflow: "hidden",
  },
  levelProgressFill: {
    height: "100%",
    borderRadius: 999,
  },
  levelShareButton: {
    borderRadius: 999,
    paddingVertical: 11,
    paddingHorizontal: 24,
    marginTop: 6,
  },
  levelShareButtonText: {
    ...createCtaText({ fontSize: 14 }),
  },
  rewardOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
  },
  rewardBackdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(255,241,225,0.92)",
  },
  rewardCard: {
    paddingVertical: 30,
    paddingHorizontal: 24,
    borderRadius: 36,
    alignItems: "center",
    width: OVERLAY_CARD_MAX_WIDTH,
    maxWidth: OVERLAY_CARD_MAX_WIDTH,
    borderWidth: 2,
    borderColor: "rgba(255,181,115,0.7)",
    gap: 12,
  },
  rewardCat: {
    width: 140,
    height: 140,
    marginBottom: 8,
  },
  rewardTitle: {
    fontSize: 22,
    fontWeight: "800",
    textAlign: "center",
  },
  rewardSubtitle: {
    fontSize: 16,
    fontWeight: "600",
    textAlign: "center",
  },
  healthOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 24,
  },
  healthBackdrop: {
    ...StyleSheet.absoluteFillObject,
  },
  healthCoinStage: {
    width: 190,
    height: 190,
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 6,
  },
  healthHalo: {
    position: "absolute",
    width: 180,
    height: 180,
    alignItems: "center",
    justifyContent: "center",
  },
  healthHaloSvg: {
    width: 180,
    height: 180,
  },
  healthCoinWrap: {
    width: 118,
    height: 118,
    borderRadius: 59,
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "#000",
    shadowOpacity: 0.24,
    shadowOffset: { width: 0, height: 12 },
    shadowRadius: 20,
    elevation: 10,
    overflow: "hidden",
  },
  healthCoinImage: {
    width: 76,
    height: 76,
    resizeMode: "contain",
  },
  healthCoinShine: {
    position: "absolute",
    width: 52,
    height: 140,
    top: -30,
    left: -38,
    borderRadius: 30,
    backgroundColor: "rgba(255,255,255,0.35)",
  },
  healthCard: {
    paddingHorizontal: 24,
    paddingVertical: 22,
    borderRadius: 28,
    borderWidth: 1,
    alignItems: "center",
    width: OVERLAY_CARD_MAX_WIDTH,
    maxWidth: OVERLAY_CARD_MAX_WIDTH,
    overflow: "hidden",
    shadowColor: "#000",
    shadowOpacity: 0.16,
    shadowOffset: { width: 0, height: 14 },
    shadowRadius: 24,
    elevation: 9,
  },
  healthCardGradient: {
    ...StyleSheet.absoluteFillObject,
  },
  healthCardOrb: {
    position: "absolute",
    width: 200,
    height: 200,
    borderRadius: 100,
    top: -90,
    right: -70,
    opacity: 0.6,
  },
  healthCardOrbSecondary: {
    width: 180,
    height: 180,
    left: -80,
    bottom: -80,
  },
  healthCardContent: {
    alignItems: "center",
    gap: 8,
  },
  healthTitle: {
    fontSize: 28,
    fontWeight: "800",
    textAlign: "center",
  },
  healthSubtitle: {
    fontSize: 15,
    lineHeight: 21,
    textAlign: "center",
  },
  goalCelebrateOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
  },
  goalCelebrateBackdrop: {
    ...StyleSheet.absoluteFillObject,
  },
  goalCelebrateCard: {
    paddingVertical: 26,
    paddingHorizontal: 22,
    borderRadius: 34,
    borderWidth: 2,
    alignItems: "stretch",
    width: OVERLAY_CARD_MAX_WIDTH,
    maxWidth: OVERLAY_CARD_MAX_WIDTH,
    maxHeight: SCREEN_HEIGHT * 0.78,
    gap: 16,
  },
  goalCelebrateContent: {
    gap: 16,
    paddingBottom: 4,
  },
  goalCelebrateHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 16,
  },
  goalCelebrateCat: {
    width: 96,
    height: 96,
  },
  goalCelebrateHeaderText: {
    flex: 1,
    gap: 6,
  },
  goalCelebrateTitle: {
    fontSize: 24,
    fontWeight: "900",
  },
  goalCelebrateSubtitle: {
    fontSize: 16,
    fontWeight: "600",
  },
  goalCelebrateTarget: {
    fontSize: 15,
    fontWeight: "700",
  },
  goalCelebrateBadge: {
    alignSelf: "flex-start",
    borderRadius: 999,
    borderWidth: 1,
    paddingVertical: 6,
    paddingHorizontal: 14,
  },
  goalCelebrateBadgeText: {
    ...createCtaText({ fontSize: 12 }),
  },
  goalCelebrateTotal: {
    borderRadius: 20,
    borderWidth: 1,
    paddingVertical: 14,
    paddingHorizontal: 16,
    gap: 6,
  },
  goalCelebrateTotalLabel: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase" }),
  },
  goalCelebrateTotalValue: {
    ...TYPOGRAPHY.display,
    fontSize: 28,
  },
  goalCelebrateTotalSub: {
    ...createBodyText({ fontSize: 13, lineHeight: 18 }),
  },
  goalCelebratePraise: {
    ...createBodyText({ fontSize: 13, lineHeight: 18, fontWeight: "700" }),
  },
  goalCelebrateRewardRow: {
    marginTop: 6,
    borderRadius: 12,
    paddingVertical: 8,
    paddingHorizontal: 10,
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  goalCelebrateRewardCoin: {
    width: 20,
    height: 20,
    resizeMode: "contain",
  },
  goalCelebrateRewardText: {
    ...createBodyText({ fontSize: 12, fontWeight: "700" }),
  },
  goalCelebrateStatsRow: {
    flexDirection: "row",
    gap: 12,
  },
  goalCelebrateStatCard: {
    flex: 1,
    borderRadius: 16,
    borderWidth: 1,
    paddingVertical: 12,
    paddingHorizontal: 12,
    gap: 4,
  },
  goalCelebrateStatLabel: {
    ...createCtaText({ fontSize: 10, textTransform: "uppercase" }),
  },
  goalCelebrateStatValue: {
    ...createBodyText({ fontSize: 18, fontWeight: "800" }),
  },
  goalCelebrateWeek: {
    gap: 8,
  },
  goalCelebrateSectionLabel: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase" }),
  },
  goalCelebrateWeekBars: {
    flexDirection: "row",
    alignItems: "flex-end",
    gap: 6,
  },
  goalCelebrateWeekBarWrap: {
    flex: 1,
    alignItems: "center",
  },
  goalCelebrateWeekBar: {
    width: 10,
    borderRadius: 6,
  },
  goalCelebrateInsights: {
    gap: 12,
  },
  goalCelebrateCta: {
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  goalCelebrateCtaText: {
    ...createCtaText({ fontSize: 14 }),
  },
  goalCelebrateInsightCard: {
    borderRadius: 18,
    borderWidth: 1,
    paddingVertical: 12,
    paddingHorizontal: 14,
    gap: 8,
  },
  goalCelebrateInsightHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  goalCelebrateInsightIcon: {
    fontSize: 18,
  },
  goalCelebrateInsightTitle: {
    ...createBodyText({ fontSize: 15, fontWeight: "800" }),
  },
  goalCelebrateInsightBody: {
    ...createBodyText({ fontSize: 13, lineHeight: 19 }),
  },
  goalCelebrateBreakdown: {
    gap: 10,
  },
  goalCelebrateBreakdownList: {
    gap: 10,
  },
  goalCelebrateBreakdownRow: {
    borderRadius: 14,
    paddingVertical: 10,
    paddingHorizontal: 12,
    backgroundColor: "rgba(0,0,0,0.04)",
  },
  goalCelebrateBreakdownTitle: {
    ...createBodyText({ fontSize: 14, fontWeight: "700" }),
  },
  goalCelebrateBreakdownMeta: {
    ...createBodyText({ fontSize: 12, lineHeight: 18 }),
  },
  heartRain: {
    ...StyleSheet.absoluteFillObject,
  },
  heartRainDrop: {
    position: "absolute",
    top: -40,
    textShadowColor: "rgba(0,0,0,0.25)",
    textShadowOffset: { width: 0, height: 2 },
    textShadowRadius: 6,
  },
  rewardHeart: {
    position: "absolute",
    bottom: 40,
    fontSize: 22,
    textShadowColor: "rgba(0,0,0,0.35)",
    textShadowRadius: 6,
  },
  dailyRewardOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
  },
  dailyRewardBackdrop: {
    ...StyleSheet.absoluteFillObject,
  },
  dailyRewardCard: {
    width: "86%",
    borderRadius: 28,
    borderWidth: 1,
    padding: 22,
    alignItems: "center",
  },
  dailyRewardBadge: {
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 14,
    paddingVertical: 6,
    alignSelf: "flex-start",
  },
  dailyRewardBadgeText: {
    fontSize: 13,
    fontWeight: "700",
    letterSpacing: 0.6,
    textTransform: "uppercase",
  },
  dailyRewardHero: {
    alignItems: "center",
    marginTop: 18,
    marginBottom: 12,
  },
  dailyRewardCoinWrap: {
    width: 96,
    height: 96,
    borderRadius: 48,
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 14,
    shadowColor: "#000",
    shadowOpacity: 0.12,
    shadowOffset: { width: 0, height: 8 },
    shadowRadius: 16,
    elevation: 6,
  },
  dailyRewardCoinLarge: {
    width: 54,
    height: 54,
    resizeMode: "contain",
  },
  dailyRewardAmountLarge: {
    fontSize: 36,
    fontWeight: "800",
    marginBottom: 6,
  },
  dailyRewardTitle: {
    fontSize: 18,
    fontWeight: "700",
    textAlign: "center",
  },
  dailyRewardReason: {
    fontSize: 14,
    lineHeight: 20,
    textAlign: "center",
    marginTop: 6,
    marginBottom: 14,
  },
  dailyRewardFooter: {
    borderTopWidth: 1,
    paddingTop: 12,
    width: "100%",
    alignItems: "center",
  },
  dailyRewardHint: {
    fontSize: 13,
    fontWeight: "600",
    textTransform: "uppercase",
    letterSpacing: 0.5,
  },
  streakPledgeOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 24,
  },
  streakPledgeBackdrop: {
    ...StyleSheet.absoluteFillObject,
  },
  streakPledgeCard: {
    width: "100%",
    maxWidth: 420,
    borderRadius: 30,
    borderWidth: 1,
    padding: 22,
    gap: 14,
    alignItems: "stretch",
  },
  streakPledgeHeader: {
    flexDirection: "row",
    alignItems: "flex-end",
    gap: 12,
  },
  streakPledgeBubble: {
    flex: 1,
    borderRadius: 18,
    borderWidth: 1,
    paddingVertical: 10,
    paddingHorizontal: 14,
  },
  streakPledgeBubbleText: {
    ...createBodyText({ fontSize: 14, lineHeight: 20, fontWeight: "700" }),
  },
  streakPledgeBubbleTail: {
    position: "absolute",
    width: 14,
    height: 14,
    bottom: -6,
    left: 28,
    borderRightWidth: 1,
    borderBottomWidth: 1,
    transform: [{ rotate: "45deg" }],
  },
  streakPledgeMascot: {
    width: 72,
    height: 72,
  },
  streakPledgeSubtitle: {
    ...createBodyText({ fontSize: 14, lineHeight: 20 }),
  },
  streakPledgeOptions: {
    gap: 10,
  },
  streakPledgeOption: {
    borderRadius: 18,
    borderWidth: 1,
    paddingVertical: 12,
    paddingHorizontal: 14,
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    gap: 12,
  },
  streakPledgeOptionRewardRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  streakPledgeOptionLabel: {
    ...createCtaText({ fontSize: 14 }),
  },
  streakPledgeOptionReward: {
    ...createBodyText({ fontSize: 12, lineHeight: 16 }),
  },
  streakPledgeOptionRewardIcon: {
    width: 18,
    height: 18,
    resizeMode: "contain",
  },
  streakPledgeOptionRewardIconFallback: {
    fontSize: 14,
  },
  streakPledgePrimaryButton: {
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
    marginTop: 4,
  },
  streakPledgePrimaryText: {
    ...createCtaText({ fontSize: 14 }),
  },
  streakPledgeSecondaryButton: {
    alignItems: "center",
    paddingVertical: 6,
  },
  streakPledgeSecondaryText: {
    ...createCtaText({ fontSize: 13 }),
  },
  streakPledgeRewardOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 24,
  },
  streakPledgeRewardBackdrop: {
    ...StyleSheet.absoluteFillObject,
  },
  streakPledgeRewardCard: {
    width: "88%",
    maxWidth: 360,
    borderRadius: 30,
    borderWidth: 1,
    padding: 24,
    alignItems: "center",
    gap: 10,
    overflow: "hidden",
    shadowColor: "#000",
    shadowOpacity: 0.18,
    shadowOffset: { width: 0, height: 16 },
    shadowRadius: 26,
    elevation: 10,
  },
  streakPledgeRewardGradient: {
    ...StyleSheet.absoluteFillObject,
  },
  streakPledgeRewardOrb: {
    position: "absolute",
    width: 220,
    height: 220,
    borderRadius: 110,
    top: -90,
    right: -70,
    opacity: 0.6,
  },
  streakPledgeRewardHero: {
    alignItems: "center",
    gap: 12,
  },
  streakPledgeRewardCoinStage: {
    width: 150,
    height: 150,
    alignItems: "center",
    justifyContent: "center",
  },
  streakPledgeRewardHalo: {
    position: "absolute",
    width: 150,
    height: 150,
    alignItems: "center",
    justifyContent: "center",
  },
  streakPledgeRewardHaloSvg: {
    width: 150,
    height: 150,
  },
  streakPledgeRewardCoinWrap: {
    width: 92,
    height: 92,
    borderRadius: 46,
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "#000",
    shadowOpacity: 0.24,
    shadowOffset: { width: 0, height: 12 },
    shadowRadius: 20,
    elevation: 10,
    overflow: "hidden",
  },
  streakPledgeRewardCoin: {
    width: 52,
    height: 52,
    resizeMode: "contain",
  },
  streakPledgeRewardCoinShine: {
    position: "absolute",
    width: 50,
    height: 120,
    top: -20,
    left: -30,
    borderRadius: 30,
    backgroundColor: "rgba(255,255,255,0.35)",
  },
  streakPledgeRewardCoinFallback: {
    fontSize: 34,
  },
  streakPledgeRewardAmountRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  streakPledgeRewardAmount: {
    ...createCtaText({ fontSize: 30 }),
  },
  streakPledgeRewardAmountPill: {
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 12,
    paddingVertical: 4,
  },
  streakPledgeRewardAmountPillText: {
    ...createBodyText({ fontSize: 12, lineHeight: 16, fontWeight: "700" }),
    textTransform: "uppercase",
    letterSpacing: 0.6,
  },
  streakPledgeRewardLabel: {
    ...createBodyText({ fontSize: 13, lineHeight: 18 }),
  },
  streakPledgeRewardTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 22,
    textAlign: "center",
    marginTop: 2,
  },
  streakPledgeRewardSubtitle: {
    ...createBodyText({ fontSize: 14, lineHeight: 20 }),
    textAlign: "center",
  },
  streakPledgeRewardButton: {
    borderWidth: 1,
    borderRadius: 20,
    paddingHorizontal: 24,
    paddingVertical: 11,
    marginTop: 8,
  },
  streakPledgeRewardButtonText: {
    ...createCtaText({ fontSize: 14 }),
  },
  usageStreakWeeklyOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 24,
  },
  usageStreakWeeklyBackdrop: {
    ...StyleSheet.absoluteFillObject,
  },
  usageStreakWeeklyCard: {
    width: "92%",
    maxWidth: 392,
    borderRadius: 30,
    borderWidth: 1,
    padding: 24,
    alignItems: "center",
    gap: 6,
    overflow: "hidden",
    shadowColor: "#000",
    shadowOpacity: 0.2,
    shadowOffset: { width: 0, height: 16 },
    shadowRadius: 26,
    elevation: 10,
  },
  usageStreakWeeklyCardGradient: {
    ...StyleSheet.absoluteFillObject,
  },
  usageStreakWeeklyOrb: {
    position: "absolute",
    width: 240,
    height: 240,
    borderRadius: 120,
    top: -90,
    right: -70,
    opacity: 0.6,
  },
  usageStreakWeeklyOrbSecondary: {
    width: 200,
    height: 200,
    left: -80,
    bottom: -90,
  },
  usageStreakWeeklyBadgeRow: {
    alignSelf: "stretch",
    alignItems: "flex-start",
  },
  usageStreakWeeklyBadge: {
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 12,
    paddingVertical: 6,
  },
  usageStreakWeeklyBadgeText: {
    fontSize: 12,
    fontWeight: "700",
    letterSpacing: 0.4,
    textTransform: "uppercase",
  },
  usageStreakWeeklyHero: {
    width: "100%",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
    marginTop: 6,
  },
  usageStreakWeeklyCoinStage: {
    width: 150,
    height: 150,
    alignItems: "center",
    justifyContent: "center",
  },
  usageStreakWeeklyHalo: {
    position: "absolute",
    width: 150,
    height: 150,
    alignItems: "center",
    justifyContent: "center",
  },
  usageStreakWeeklyHaloSvg: {
    width: 150,
    height: 150,
  },
  usageStreakWeeklyCoinWrap: {
    width: 90,
    height: 90,
    borderRadius: 45,
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "#000",
    shadowOpacity: 0.24,
    shadowOffset: { width: 0, height: 12 },
    shadowRadius: 20,
    elevation: 10,
    overflow: "hidden",
  },
  usageStreakWeeklyCoin: {
    width: 52,
    height: 52,
    resizeMode: "contain",
  },
  usageStreakWeeklyCoinShine: {
    position: "absolute",
    width: 50,
    height: 120,
    top: -20,
    left: -30,
    borderRadius: 30,
    backgroundColor: "rgba(255,255,255,0.35)",
  },
  usageStreakWeeklyCoinFallback: {
    fontSize: 34,
  },
  usageStreakWeeklyAmount: {
    ...createCtaText({ fontSize: 30 }),
  },
  usageStreakWeeklyAmountRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
    marginTop: 2,
  },
  usageStreakWeeklyAmountPill: {
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 12,
    paddingVertical: 4,
  },
  usageStreakWeeklyAmountPillText: {
    ...createBodyText({ fontSize: 12, lineHeight: 16, fontWeight: "700" }),
    textTransform: "uppercase",
    letterSpacing: 0.6,
  },
  usageStreakWeeklyLabel: {
    ...createBodyText({ fontSize: 13, lineHeight: 18 }),
  },
  usageStreakWeeklyRewardLabel: {
    ...createBodyText({ fontSize: 12, lineHeight: 16 }),
    textTransform: "uppercase",
    letterSpacing: 0.6,
  },
  usageStreakWeeklyCat: {
    width: 86,
    height: 76,
  },
  usageStreakWeeklyTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 22,
    textAlign: "center",
    marginTop: 2,
  },
  usageStreakWeeklySubtitle: {
    ...createBodyText({ fontSize: 14, lineHeight: 20 }),
    textAlign: "center",
  },
  usageStreakWeeklyThanks: {
    ...createBodyText({ fontSize: 14, lineHeight: 20, fontWeight: "700" }),
    textAlign: "center",
    marginTop: 4,
  },
  usageStreakWeeklyMotivation: {
    ...createBodyText({ fontSize: 13, lineHeight: 18 }),
    textAlign: "center",
  },
  usageStreakWeeklyButton: {
    marginTop: 8,
    borderRadius: 20,
    paddingHorizontal: 26,
    paddingVertical: 11,
    shadowColor: "#000",
    shadowOpacity: 0.14,
    shadowOffset: { width: 0, height: 10 },
    shadowRadius: 18,
    elevation: 6,
  },
  usageStreakWeeklyButtonText: {
    ...createCtaText({ fontSize: 14 }),
  },
  usageStreakOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 24,
  },
  usageStreakBackdrop: {
    ...StyleSheet.absoluteFillObject,
  },
  usageStreakCard: {
    width: "100%",
    maxWidth: 380,
    borderRadius: 32,
    borderWidth: 1,
    padding: 24,
    alignItems: "center",
    gap: 10,
    overflow: "hidden",
  },
  usageStreakAura: {
    position: "absolute",
    width: 240,
    height: 240,
    borderRadius: 120,
    top: -50,
    right: -70,
    opacity: 0.6,
  },
  usageStreakBubble: {
    alignSelf: "stretch",
    borderRadius: 18,
    paddingVertical: 10,
    paddingHorizontal: 14,
    borderWidth: 1,
    marginBottom: 4,
  },
  usageStreakBubbleText: {
    ...createBodyText({ fontSize: 14, lineHeight: 20 }),
  },
  usageStreakBubbleTail: {
    position: "absolute",
    width: 14,
    height: 14,
    bottom: -6,
    left: 30,
    borderRightWidth: 1,
    borderBottomWidth: 1,
    transform: [{ rotate: "45deg" }],
  },
  usageStreakFlameWrap: {
    width: 86,
    height: 86,
    alignItems: "center",
    justifyContent: "center",
    marginTop: 6,
  },
  usageStreakFlameGlow: {
    position: "absolute",
    width: 72,
    height: 72,
    borderRadius: 36,
  },
  usageStreakFlame: {
    fontSize: 46,
  },
  usageStreakSmoke: {
    position: "absolute",
    fontSize: 34,
  },
  usageStreakNumber: {
    fontSize: IS_SHORT_DEVICE ? 76 : 96,
    lineHeight: IS_SHORT_DEVICE ? 80 : 100,
    fontWeight: "900",
    letterSpacing: -1,
    position: "absolute",
  },
  usageStreakNumberWrap: {
    height: STREAK_COUNTER_DIGIT_HEIGHT + 20,
    alignItems: "center",
    justifyContent: "center",
    marginTop: -4,
  },
  usageStreakCounterRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 6,
  },
  usageStreakCounterDigit: {
    width: STREAK_COUNTER_DIGIT_WIDTH,
    height: STREAK_COUNTER_DIGIT_HEIGHT,
    alignItems: "center",
    justifyContent: "center",
  },
  usageStreakCounterDigitSurface: {
    width: "100%",
    height: "100%",
    borderRadius: 14,
    borderWidth: 1,
    overflow: "hidden",
    alignItems: "center",
    justifyContent: "center",
  },
  usageStreakCounterDigitColumn: {
    position: "absolute",
    top: -4,
    left: 0,
    right: 0,
    width: "100%",
    alignItems: "center",
    paddingVertical: 4,
  },
  usageStreakCounterDigitText: {
    fontSize: IS_SHORT_DEVICE ? 78 : 102,
    lineHeight: STREAK_COUNTER_DIGIT_HEIGHT,
    fontWeight: "900",
    letterSpacing: -1,
    fontVariant: ["tabular-nums"],
    textAlign: "center",
    width: "100%",
  },
  usageStreakCounterDigitDivider: {
    position: "absolute",
    height: 2,
    left: 6,
    right: 6,
    top: STREAK_COUNTER_DIGIT_HEIGHT / 2 - 1,
    backgroundColor: "rgba(0,0,0,0.12)",
    opacity: 0.4,
  },
  usageStreakCounterSeparator: {
    paddingHorizontal: 4,
    alignItems: "center",
    justifyContent: "center",
  },
  usageStreakCounterSeparatorText: {
    fontSize: IS_SHORT_DEVICE ? 54 : 68,
    fontWeight: "800",
  },
  usageStreakNumberLabel: {
    fontSize: 18,
    fontWeight: "700",
    textAlign: "center",
  },
  usageStreakWeekRow: {
    flexDirection: "row",
    justifyContent: "center",
    gap: 8,
    marginTop: 8,
    marginBottom: 6,
  },
  usageStreakWeekDay: {
    width: 34,
    height: 34,
    borderRadius: 17,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden",
  },
  usageStreakWeekGlow: {
    position: "absolute",
    width: "100%",
    height: "100%",
    borderRadius: 17,
  },
  usageStreakWeekLabel: {
    fontSize: 12,
    fontWeight: "700",
  },
  usageStreakRestoreCard: {
    width: "100%",
    maxWidth: 360,
    alignSelf: "center",
    borderRadius: 22,
    borderWidth: 1,
    paddingVertical: 16,
    paddingHorizontal: 18,
    gap: 8,
  },
  usageStreakRestoreTitle: {
    fontSize: 16,
    fontWeight: "700",
    textAlign: "center",
  },
  usageStreakRestoreSubtitle: {
    fontSize: 13,
    lineHeight: 18,
    textAlign: "center",
  },
  usageStreakRestoreCostRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 8,
  },
  usageStreakRestoreCoin: {
    width: 20,
    height: 20,
    resizeMode: "contain",
  },
  usageStreakRestoreCoinFallback: {
    fontSize: 16,
  },
  usageStreakRestoreCostText: {
    fontSize: 14,
    fontWeight: "700",
  },
  usageStreakRestoreButton: {
    marginTop: 6,
    paddingVertical: 8,
    borderRadius: 18,
    alignItems: "center",
  },
  usageStreakRestoreButtonDisabled: {
    opacity: 0.55,
  },
  usageStreakRestoreButtonText: {
    fontSize: 12,
    fontWeight: "700",
    letterSpacing: 0.6,
    textTransform: "uppercase",
  },
  usageStreakRestoreButtonTextDisabled: {
    opacity: 0.85,
  },
  usageStreakRestoreNeed: {
    fontSize: 12,
    textAlign: "center",
  },
  usageStreakMissedMark: {
    position: "absolute",
    fontSize: 18,
    fontWeight: "900",
  },
  usageStreakCat: {
    width: 160,
    height: 130,
    marginTop: 2,
  },
  usageStreakHint: {
    ...createBodyText({ fontSize: 13, lineHeight: 18, textAlign: "center" }),
  },
  levelCoin: {
    position: "absolute",
    borderRadius: 999,
    backgroundColor: "#FFD93D",
  },
  saveOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
  },
  primaryTemptationOverlayCardContainer: {
    width: OVERLAY_CARD_MAX_WIDTH,
    maxWidth: OVERLAY_CARD_MAX_WIDTH,
    borderRadius: 34,
    padding: 20,
    borderWidth: 1,
    gap: 16,
  },
  primaryTemptationOverlayTitle: {
    fontSize: 20,
    fontWeight: "800",
    textAlign: "center",
  },
  primaryTemptationCard: {
    width: "100%",
  },
  primaryTemptationDismiss: {
    alignSelf: "center",
    paddingHorizontal: 18,
    paddingVertical: 8,
    borderRadius: 24,
    borderWidth: 1,
  },
  primaryTemptationDismissText: {
    fontSize: 14,
    fontWeight: "600",
  },
  saveCelebrationOverlay: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: "center",
    alignItems: "center",
  },
  saveCelebrationCard: {
    paddingVertical: 22,
    paddingHorizontal: 22,
    borderRadius: 32,
    alignItems: "stretch",
    width: OVERLAY_CARD_MAX_WIDTH,
    maxWidth: OVERLAY_CARD_MAX_WIDTH,
    borderWidth: 2,
    overflow: "hidden",
  },
  saveCelebrationPrimary: {},
  saveCelebrationGlow: {
    position: "absolute",
    top: -40,
    left: -30,
    right: -30,
    height: 140,
    borderRadius: 999,
    opacity: 0.55,
  },
  saveCelebrationGlowTop: {
    top: -90,
    height: 180,
    opacity: 0.25,
  },
  saveCelebrationContent: {
    gap: 16,
  },
  saveCelebrationHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 14,
  },
  saveCelebrationMascotWrap: {
    width: 90,
    height: 90,
    borderRadius: 45,
    alignItems: "center",
    justifyContent: "center",
    borderWidth: 1,
    shadowColor: "#000",
    shadowOpacity: 0.18,
    shadowRadius: 16,
    shadowOffset: { width: 0, height: 6 },
    elevation: 4,
  },
  saveCelebrationCat: {
    width: 68,
    height: 68,
    resizeMode: "contain",
  },
  saveCelebrationTitleBlock: {
    flex: 1,
    gap: 6,
  },
  saveCelebrationTitle: {
    fontSize: 20,
    fontWeight: "800",
    textAlign: "left",
    lineHeight: 24,
  },
  saveCelebrationSubtitle: {
    fontSize: 11,
    fontWeight: "700",
    textAlign: "left",
    textTransform: "uppercase",
    letterSpacing: 0.8,
  },
  saveCelebrationStatsRow: {
    flexDirection: "row",
    gap: 10,
    alignItems: "stretch",
    justifyContent: "space-between",
  },
  saveCelebrationStatCard: {
    flex: 1,
    borderRadius: 18,
    paddingVertical: 12,
    paddingHorizontal: 10,
    alignItems: "center",
    gap: 6,
    borderWidth: 1,
    shadowOpacity: 0.12,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 6 },
    elevation: 3,
  },
  saveCelebrationStatAccent: {
    width: 24,
    height: 4,
    borderRadius: 999,
  },
  saveCelebrationStatIconWrap: {
    width: 30,
    height: 30,
    borderRadius: 15,
    alignItems: "center",
    justifyContent: "center",
  },
  saveCelebrationStatIcon: {
    width: 16,
    height: 16,
    resizeMode: "contain",
  },
  saveCelebrationStatDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
  },
  saveCelebrationStatValue: {
    fontSize: 16,
    fontWeight: "800",
    textAlign: "center",
    fontVariant: ["tabular-nums"],
  },
  saveCelebrationStatLabel: {
    fontSize: 11,
    fontWeight: "600",
    textAlign: "center",
    lineHeight: 14,
  },
  saveQuoteCard: {
    borderRadius: 16,
    borderWidth: 1,
    paddingVertical: 10,
    paddingHorizontal: 12,
    alignSelf: "stretch",
  },
  saveQuote: {
    fontSize: 13,
    fontWeight: "600",
    textAlign: "center",
    lineHeight: 18,
    fontStyle: "italic",
  },
  saveCelebrationPrimaryButton: {
    alignSelf: "stretch",
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
    borderWidth: 1,
    marginTop: 2,
  },
  saveCelebrationPrimaryButtonText: {
    fontSize: 14,
    fontWeight: "800",
    letterSpacing: 0.6,
    textTransform: "uppercase",
  },
  saveProgressSection: {
    width: "100%",
    alignItems: "center",
    gap: 6,
  },
  saveProgressTrack: {
    width: SAVE_PROGRESS_BAR_WIDTH,
    height: 10,
    borderRadius: 999,
    overflow: "hidden",
  },
  saveProgressFill: {
    height: "100%",
    borderRadius: 999,
  },
  saveProgressLabelRow: {
    width: SAVE_PROGRESS_BAR_WIDTH,
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  saveProgressValue: {
    fontSize: 18,
    fontWeight: "800",
    fontVariant: ["tabular-nums"],
  },
  saveProgressHint: {
    fontSize: 12,
    fontWeight: "600",
  },
  saveCountdownCard: {
    position: "absolute",
    paddingVertical: 18,
    paddingHorizontal: 16,
    borderRadius: 26,
    gap: 14,
    alignItems: "center",
    overflow: "hidden",
  },
  saveCountdownGlow: {
    position: "absolute",
    top: -40,
    left: -60,
    right: -60,
    bottom: -40,
    borderRadius: 999,
  },
  saveCountdownHeaderRow: {
    width: "100%",
    alignItems: "center",
  },
  saveCountdownBadge: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
  },
  saveCountdownBadgeText: {
    fontSize: 12,
    fontWeight: "800",
    letterSpacing: 0.6,
    textTransform: "uppercase",
    textAlign: "center",
  },
  saveCountdownGoal: {
    fontSize: 16,
    fontWeight: "800",
    textAlign: "center",
  },
  saveCountdownGoalPrefix: {
    fontSize: 14,
    fontWeight: "700",
    textAlign: "center",
    marginTop: 4,
  },
  saveCounterRow: {
    flexDirection: "row",
    gap: 6,
    alignItems: "center",
    justifyContent: "center",
  },
  saveCounterSeparator: {
    paddingHorizontal: 2,
    paddingVertical: 4,
  },
  saveCounterSeparatorText: {
    fontSize: 22,
    fontWeight: "900",
  },
  saveCounterSpace: {
    width: 10,
  },
  saveCounterDigit: {
    width: 54,
    height: SAVE_COUNTER_DIGIT_HEIGHT,
    borderRadius: 16,
    padding: 2,
    shadowColor: "#000",
    shadowOpacity: 0.18,
    shadowRadius: 12,
    shadowOffset: { width: 0, height: 5 },
    elevation: 4,
  },
  saveCounterDigitSurface: {
    flex: 1,
    borderRadius: 14,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: "rgba(0,0,0,0.12)",
    alignItems: "center",
    justifyContent: "center",
  },
  saveCounterDigitColumn: {
    position: "absolute",
    top: -4,
    left: 0,
    right: 0,
    width: "100%",
    alignItems: "center",
    paddingVertical: 4,
  },
  saveCounterDigitText: {
    fontSize: 32,
    fontWeight: "900",
    fontVariant: ["tabular-nums"],
    textAlign: "center",
    height: SAVE_COUNTER_DIGIT_HEIGHT,
    lineHeight: SAVE_COUNTER_DIGIT_HEIGHT,
  },
  saveCounterDigitEdgeTop: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    height: SAVE_COUNTER_DIGIT_HEIGHT / 2,
    backgroundColor: "rgba(255,255,255,0.22)",
  },
  saveCounterDigitEdgeBottom: {
    position: "absolute",
    bottom: 0,
    left: 0,
    right: 0,
    height: SAVE_COUNTER_DIGIT_HEIGHT / 2,
    backgroundColor: "rgba(0,0,0,0.12)",
  },
  saveCounterDigitHighlight: {
    position: "absolute",
    top: 6,
    left: 6,
    right: 6,
    height: 16,
    borderRadius: 999,
    backgroundColor: "rgba(255,255,255,0.7)",
  },
  saveCounterDigitDivider: {
    position: "absolute",
    top: SAVE_COUNTER_DIGIT_HEIGHT / 2 - 1,
    left: 8,
    right: 8,
    height: 2,
    borderRadius: 999,
    backgroundColor: "rgba(0,0,0,0.22)",
  },
  saveCountdownButton: {
    alignSelf: "stretch",
    borderRadius: 18,
    paddingVertical: 10,
    alignItems: "center",
    borderWidth: 1,
    marginTop: 2,
  },
  saveCountdownButtonText: {
    fontSize: 13,
    fontWeight: "800",
    letterSpacing: 0.6,
    textTransform: "uppercase",
  },
  saveRemainingCopy: {
    fontSize: 16,
    fontWeight: "600",
    textAlign: "center",
    opacity: 0.85,
  },
  customTemptationCard: {
    backgroundColor: "rgba(255,255,255,0.95)",
    borderRadius: 24,
    paddingVertical: 28,
    paddingHorizontal: 24,
    alignItems: "center",
    gap: 16,
    borderWidth: 1,
    borderColor: "rgba(18,15,40,0.08)",
    marginHorizontal: 24,
  },
  customTemptationGif: {
    width: 160,
    height: 160,
    borderRadius: 32,
    resizeMode: "contain",
  },
  customTemptationText: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 18,
    textAlign: "center",
  },
  rainLayer: {
    ...StyleSheet.absoluteFillObject,
  },
  rainDrop: {
    width: 2,
    borderRadius: 1,
    position: "absolute",
    top: 0,
  },
  sheetBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.35)",
    justifyContent: "flex-end",
  },
  sheetCard: {
    borderTopLeftRadius: 28,
    borderTopRightRadius: 28,
    paddingHorizontal: 24,
    paddingTop: 16,
    paddingBottom: 36,
    gap: 14,
  },
  sheetHandle: {
    width: 60,
    height: 4,
    borderRadius: 2,
    alignSelf: "center",
    marginBottom: 6,
  },
  sheetTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 20,
    textAlign: "center",
  },
  sheetSubtitle: {
    ...createBodyText({ fontSize: 15, textAlign: "center" }),
  },
  sheetButton: {
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
  },
  sheetCancel: {
    ...createCtaText({ textAlign: "center", marginTop: 4 }),
  },
  priceModalBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.35)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  priceModalCard: {
    width: "100%",
    borderRadius: 28,
    padding: 20,
    gap: 16,
  },
  priceModalTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 20,
    textAlign: "center",
  },
  priceModalLabel: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase", marginTop: 12, marginBottom: 4 }),
  },
  priceModalInput: {
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 16,
    paddingVertical: 10,
    fontSize: 18,
    textAlign: "center",
  },
  priceModalInputCompact: {
    borderWidth: 1,
    borderRadius: 14,
    paddingHorizontal: 12,
    paddingVertical: 8,
    fontSize: 16,
    textAlign: "left",
  },
  incomeEntryVisual: {
    borderRadius: 18,
    borderWidth: 1,
    paddingVertical: 10,
    paddingHorizontal: 12,
  },
  incomeEntryVisualRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 6,
  },
  incomeEntryVisualItem: {
    flex: 1,
    borderRadius: 14,
    borderWidth: 1,
    paddingVertical: 8,
    paddingHorizontal: 6,
    alignItems: "center",
    gap: 4,
  },
  incomeEntryVisualIcon: {
    fontSize: 16,
  },
  incomeEntryVisualLabel: {
    fontSize: 10,
    fontWeight: "700",
    textAlign: "center",
  },
  incomeEntryVisualArrow: {
    fontSize: 14,
    fontWeight: "700",
  },
  incomeEntryExplanation: {
    ...createBodyText({ fontSize: 13, lineHeight: 18, textAlign: "center" }),
  },
  goalPickerButton: {
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 12,
    paddingHorizontal: 16,
  },
  goalPickerButtonText: {
    ...createCtaText({ fontSize: 15 }),
  },
  goalPickerReset: {
    marginTop: 6,
  },
  goalPickerResetText: {
    ...createSecondaryText({ fontSize: 13 }),
  },
  temptationEditOverlay: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    zIndex: 400,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 16,
    paddingVertical: 16,
  },
  temptationEditBackdrop: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    backgroundColor: "#05060F",
  },
  temptationEditSheetContainer: {
    width: "88%",
    maxWidth: 420,
    alignSelf: "center",
  },
  temptationEditSheet: {
    width: "100%",
    borderRadius: 24,
    borderWidth: 1,
    overflow: "hidden",
    maxHeight: SCREEN_HEIGHT * 0.7,
  },
  temptationEditScroll: {
    maxHeight: SCREEN_HEIGHT * (IS_SHORT_DEVICE ? 0.4 : 0.52),
  },
  temptationEditContent: {
    paddingHorizontal: 16,
    paddingTop: 14,
    paddingBottom: 10,
    gap: 10,
  },
  temptationEditFieldRow: {
    flexDirection: "row",
    gap: 10,
  },
  temptationEditField: {
    gap: 6,
  },
  temptationEditFieldGrow: {
    flex: 1,
  },
  temptationEditLabel: {
    ...createSecondaryText({ fontSize: 10, textTransform: "uppercase" }),
  },
  temptationEditSubtitle: {
    fontSize: 13,
    lineHeight: 18,
  },
  temptationEditInputWrap: {
    borderWidth: 1,
    borderRadius: 16,
    paddingHorizontal: 10,
    paddingVertical: 8,
  },
  temptationEditEmojiWrap: {
    width: 62,
    alignItems: "center",
    justifyContent: "center",
  },
  temptationEditEmojiInput: {
    fontSize: 18,
    fontWeight: "700",
    textAlign: "center",
  },
  temptationEditTextInput: {
    fontSize: 15,
    fontWeight: "600",
  },
  temptationEditAmountWrap: {
    flexDirection: "row",
    alignItems: "center",
  },
  temptationEditAmountInput: {
    flex: 1,
    fontSize: 18,
    fontWeight: "700",
  },
  temptationEditGoalButton: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 8,
    borderWidth: 1,
    borderRadius: 16,
    paddingHorizontal: 10,
    paddingVertical: 10,
  },
  temptationEditGoalText: {
    flex: 1,
    fontSize: 13,
    fontWeight: "600",
  },
  temptationEditGoalChevron: {
    fontSize: 16,
    fontWeight: "700",
  },
  temptationEditDescriptionInput: {
    minHeight: 70,
    fontSize: 13,
    lineHeight: 18,
  },
  temptationEditCategoryWrap: {
    marginTop: 2,
  },
  temptationEditFooter: {
    paddingHorizontal: 16,
    paddingTop: 10,
    paddingBottom: 12,
    borderTopWidth: StyleSheet.hairlineWidth,
    gap: 8,
  },
  temptationEditSave: {
    borderRadius: 16,
    paddingVertical: 12,
    alignItems: "center",
  },
  temptationEditSaveText: {
    fontSize: 14,
    fontWeight: "700",
  },
  temptationEditFooterRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  temptationEditCancelText: {
    fontSize: 13,
    fontWeight: "600",
  },
  temptationEditDeleteText: {
    fontSize: 13,
    fontWeight: "700",
  },
  priceModalButtons: {
    gap: 10,
  },
  priceModalPrimary: {
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
  },
  priceModalPrimaryText: {
    fontWeight: "700",
  },
  priceModalSecondary: {
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
    borderWidth: 1,
  },
  priceModalSecondaryText: {
    fontWeight: "600",
  },
  priceModalCancel: {
    textAlign: "center",
    fontWeight: "600",
    marginTop: 4,
  },
  priceModalDeleteText: {
    textAlign: "center",
    fontWeight: "700",
    marginTop: 10,
  },
  categoryManagerList: {
    borderWidth: 1,
    borderRadius: 18,
    maxHeight: Math.min(280, SCREEN_HEIGHT * 0.45),
  },
  categoryManagerListContent: {
    paddingVertical: 4,
  },
  categoryManagerAddButton: {
    marginTop: 8,
    marginHorizontal: 12,
    marginBottom: 6,
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 10,
    alignItems: "center",
  },
  categoryManagerAddButtonText: {
    fontSize: 13,
    fontWeight: "700",
  },
  categoryManagerSavingsCard: {
    borderWidth: 1,
    borderRadius: 18,
    padding: 12,
    gap: 10,
  },
  categoryManagerSavingsTitle: {
    fontSize: 14,
    fontWeight: "700",
  },
  categoryManagerEditSubtitle: {
    fontSize: 12,
    fontWeight: "600",
  },
  categoryManagerSavingsRow: {
    flexDirection: "row",
    gap: 10,
  },
  categoryManagerSavingsField: {
    flex: 1,
    gap: 4,
  },
  categoryManagerSavingsEmojiField: {
    width: 82,
    gap: 4,
  },
  categoryManagerSavingsActions: {
    flexDirection: "row",
    gap: 10,
  },
  categoryManagerSavingsButton: {
    flex: 1,
  },
  categoryManagerRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingHorizontal: 12,
    paddingVertical: 10,
  },
  categoryManagerRowInfo: {
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
    flex: 1,
    marginRight: 10,
  },
  categoryManagerRowActions: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  categoryManagerEmoji: {
    fontSize: 18,
  },
  categoryManagerName: {
    fontSize: 14,
    fontWeight: "600",
    flexShrink: 1,
  },
  categoryManagerDefaultTag: {
    fontSize: 12,
    fontWeight: "600",
  },
  categoryManagerDeleteButton: {
    borderWidth: 1,
    borderRadius: 14,
    paddingHorizontal: 10,
    paddingVertical: 6,
  },
  categoryManagerDeleteText: {
    fontSize: 12,
    fontWeight: "700",
  },
  goalModalCard: {
    width: "100%",
    borderRadius: 28,
    padding: 20,
    gap: 10,
  },
  goalModalTitle: {
    fontSize: 20,
    fontWeight: "700",
    textAlign: "center",
  },
  goalModalSubtitle: {
    fontSize: 14,
    lineHeight: 20,
    textAlign: "center",
  },
  goalOptionButton: {
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 12,
    paddingHorizontal: 16,
    marginTop: 10,
  },
  goalOptionTitle: {
    fontSize: 16,
    fontWeight: "600",
  },
  goalOptionSubtitle: {
    fontSize: 13,
    marginTop: 2,
  },
  goalRenewalBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.45)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  goalRenewalCard: {
    width: "100%",
    borderRadius: 32,
    borderWidth: 1,
    padding: 24,
    gap: 12,
  },
  goalRenewalTitle: {
    ...TYPOGRAPHY.blockTitle,
    textAlign: "center",
  },
  goalRenewalSubtitle: {
    ...createBodyText({ fontSize: 16, textAlign: "center", lineHeight: 22 }),
  },
  goalRenewalActions: {
    flexDirection: "row",
    gap: 12,
    marginTop: 8,
  },
  goalRenewalSecondary: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
  },
  goalRenewalSecondaryText: {
    ...createCtaText({ fontSize: 15 }),
  },
  goalRenewalPrimary: {
    flex: 1,
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
  },
  goalRenewalPrimaryText: {
    ...createCtaText({ fontSize: 15 }),
  },
  onboardContainer: {
    flex: 1,
    paddingHorizontal: BASE_HORIZONTAL_PADDING,
    paddingTop: 40,
    gap: 20,
  },
  onboardContent: {
    gap: 16,
    paddingBottom: 60,
  },
  onboardCenteredContent: {
    alignItems: "center",
  },
  onboardWideButton: {
    alignSelf: "stretch",
    width: "100%",
  },
  onboardContentWithFooter: {
    paddingBottom: 140,
  },
  onboardContentCompact: {
    gap: 12,
    paddingBottom: 40,
  },
  onboardHeaderRow: {
    flexDirection: "row",
    alignItems: "center",
    width: "100%",
  },
  onboardTitle: {
    ...TYPOGRAPHY.display,
  },
  onboardTitleCompact: {
    ...TYPOGRAPHY.display,
    fontSize: Math.max(TYPOGRAPHY.display.fontSize - 4, 26),
    lineHeight: Math.max(TYPOGRAPHY.display.fontSize - 2, 28),
  },
  personaTitleCompact: {
    ...TYPOGRAPHY.display,
    fontSize: Math.max(TYPOGRAPHY.display.fontSize - 8, 22),
    lineHeight: Math.max(TYPOGRAPHY.display.fontSize - 6, 24),
  },
  onboardSubtitle: {
    ...createBodyText({ fontSize: 16, lineHeight: 22 }),
  },
  onboardGuideContent: {
    gap: 12,
    paddingBottom: 24,
  },
  onboardFloatingActions: {
    position: "absolute",
    left: BASE_HORIZONTAL_PADDING,
    right: BASE_HORIZONTAL_PADDING,
    bottom: 24,
    paddingTop: 12,
  },
  onboardFloatingActionsTight: {
    bottom: 0,
  },
  onboardFloatingPrimary: {
    shadowColor: "#000",
    shadowOpacity: 0.15,
    shadowRadius: 12,
    shadowOffset: { width: 0, height: 4 },
    elevation: 6,
  },
  avatarPreview: {
    borderWidth: 1,
    borderRadius: 24,
    padding: 16,
    alignItems: "center",
  },
  primaryInput: {
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 16,
    paddingVertical: 12,
    fontSize: 16,
  },
  baselineInputGroup: {
    marginTop: 8,
    gap: 4,
  },
  baselineStack: {
    marginTop: 10,
    gap: 12,
  },
  baselineCard: {
    borderWidth: 1,
    borderRadius: 20,
    padding: 12,
    gap: 8,
  },
  baselineCardTitle: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase", marginBottom: 2 }),
  },
  baselineCardHint: {
    ...createSecondaryText({ fontSize: 12, lineHeight: 16 }),
  },
  baselineInputCompact: {
    paddingVertical: 10,
    fontSize: 16,
  },
  baselineHint: {
    ...createSecondaryText({ fontSize: 14, lineHeight: 20 }),
  },
  avatarImage: {
    width: 120,
    height: 120,
    borderRadius: 60,
    marginBottom: 8,
  },
  avatarPlaceholder: {
    width: 120,
    height: 120,
    borderRadius: 60,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 8,
  },
  currencyLabel: {
    fontSize: 14,
    textTransform: "none",
    marginTop: 4,
  },
  currencyScrollWrapper: {
    marginTop: 12,
    position: "relative",
    marginRight: -32,
    paddingRight: 32,
  },
    currencyScroll: {
    marginTop: 0,
  },
  currencyScrollContent: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    paddingRight: 12,
  },
  currencyScrollFadeWrapper: {
    position: "absolute",
    right: 0,
    top: 0,
    bottom: 0,
    width: 40,
  },
  currencyScrollFade: {
    height: "100%",
  },
  currencyChipLarge: {
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 8,
    paddingHorizontal: 12,
  },
  goalGrid: {
    flex: 1,
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 12,
  },
  goalCustomSectionTitle: {
    ...createCtaText({ fontSize: 14, textTransform: "uppercase", marginTop: 16 }),
  },
  goalCustomButton: {
    borderWidth: 1,
    borderRadius: 22,
    paddingVertical: 14,
    alignItems: "center",
    marginTop: 16,
  },
  goalCustomButtonText: {
    ...createCtaText({ fontSize: 14 }),
  },
  goalOptionWrap: {
    width: "48%",
    gap: 8,
  },
  goalOption: {
    borderWidth: 1,
    borderRadius: 22,
    padding: 16,
    alignItems: "center",
    gap: 8,
  },
  goalTargetInline: {
    width: "100%",
  },
  personaGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 12,
  },
  personaCard: {
    width: "48%",
    borderWidth: 1,
    borderRadius: 22,
    padding: 16,
    gap: 6,
  },
  personaEmoji: {
    fontSize: 24,
  },
  personaTitle: {
    ...createBodyText({ fontWeight: "700", fontSize: 15 }),
  },
  personaSubtitleCard: {
    ...createBodyText({ fontSize: 14, lineHeight: 20 }),
  },
  goalEmoji: {
    fontSize: 28,
  },
  goalText: {
    ...createBodyText({ fontWeight: "600", textAlign: "center" }),
  },
  languageButtons: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 10,
  },
  languageTermsBlock: {
    width: "100%",
    marginTop: 12,
    gap: 6,
  },
  languageTermsNote: {
    ...createSecondaryText({ fontSize: 12, lineHeight: 16 }),
  },
  languageTermsButton: {
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 10,
    alignItems: "center",
  },
  languageTermsButtonText: {
    ...createCtaText({ fontSize: 13 }),
  },
  genderGrid: {
    flexDirection: "row",
    justifyContent: "space-between",
    gap: 12,
  },
  genderChip: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 20,
    paddingVertical: 12,
    alignItems: "center",
    gap: 6,
  },
  genderEmoji: {
    fontSize: 20,
  },
  genderLabel: {
    ...createBodyText({ fontWeight: "600" }),
  },
  languageButton: {
    flexGrow: 1,
    width: "48%",
    borderWidth: 1,
    borderRadius: 20,
    paddingVertical: 18,
    paddingHorizontal: 12,
    alignItems: "center",
  },
  onboardBackButton: {
    flexDirection: "row",
    alignItems: "center",
    alignSelf: "flex-start",
    borderWidth: 1,
    borderRadius: 999,
    paddingHorizontal: 14,
    paddingVertical: 6,
    gap: 6,
    marginBottom: 12,
  },
  onboardBackIcon: {
    fontSize: 14,
  },
  onboardBackLabel: {
    ...createCtaText({ fontSize: 13 }),
  },
  onboardSkipButton: {
    marginLeft: "auto",
    borderRadius: 999,
    paddingHorizontal: 16,
    paddingVertical: 8,
    backgroundColor: "#000000",
    marginBottom: 12,
  },
  onboardSkipLabel: {
    ...createCtaText({ fontSize: 13 }),
    color: "#FFFFFF",
  },
  onboardHeaderCta: {
    marginLeft: "auto",
    borderRadius: 999,
    paddingHorizontal: 16,
    paddingVertical: 8,
    marginBottom: 12,
  },
  onboardHeaderCtaText: {
    ...createCtaText({ fontSize: 13 }),
  },
  languageHint: {
    ...createSecondaryText({ marginTop: 6, fontSize: 12 }),
  },
  goalTargetHint: {
    ...createSecondaryText({ fontSize: 13, marginTop: 8, marginBottom: 22 }),
  },
  logoSplashOverlay: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    zIndex: 1000,
  },
  logoSplash: {
    flex: 1,
    backgroundColor: "#fff",
    justifyContent: "center",
    alignItems: "center",
  },
  logoSplashImage: {
    width: 140,
    height: 140,
    marginBottom: 8,
  },
  logoSplashText: {
    ...TYPOGRAPHY.logo,
    fontSize: 48,
    letterSpacing: -0.5,
    color: "#111",
  },
});
function ImageSourceSheet({ visible, colors, t, onClose, onSelect }) {
  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onClose}
      statusBarTranslucent
    >
      <TouchableWithoutFeedback onPress={onClose}>
        <View style={styles.sheetBackdrop}>
          <TouchableWithoutFeedback onPress={() => {}}>
            <View style={[styles.sheetCard, { backgroundColor: colors.card }] }>
              <View style={[styles.sheetHandle, { backgroundColor: colors.border }]} />
              <Text style={[styles.sheetTitle, { color: colors.text }]}>{t("photoPromptTitle")}</Text>
              <Text style={[styles.sheetSubtitle, { color: colors.muted }]}>{t("photoPromptSubtitle")}</Text>
              <TouchableOpacity
                style={[styles.sheetButton, { borderColor: colors.border }]}
                onPress={() => onSelect("library")}
              >
                <Text style={{ color: colors.text }}>{t("photoLibrary")}</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.sheetButton, { borderColor: colors.border }]}
                onPress={() => onSelect("camera")}
              >
                <Text style={{ color: colors.text }}>{t("photoCamera")}</Text>
              </TouchableOpacity>
              <TouchableOpacity onPress={onClose}>
                <Text style={[styles.sheetCancel, { color: colors.muted }]}>{t("profileCancel")}</Text>
              </TouchableOpacity>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
}

function RegistrationScreen({
  data,
  onChange,
  onSubmit,
  onPickImage,
  colors,
  t,
  onBack,
  mascotImageSource,
  onSkip,
  bottomInset = 0,
}) {
  const fallbackAvatar = mascotImageSource || CLASSIC_TAMAGOTCHI_ANIMATIONS.idle;
  const fade = useFadeIn();
  const resolvedAvatarUri = useMemo(() => resolveAvatarUri(data?.avatar), [data?.avatar]);
  const bottomInsetStyle = addBottomInsetStyle(styles.onboardContent, bottomInset);
  const swapActions = IS_SHORT_DEVICE && typeof onSkip === "function";
  const headerAction = swapActions ? (
    <OnboardingHeaderAction label={t("goalButton")} onPress={onSubmit} colors={colors} />
  ) : null;

  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView
        contentContainerStyle={[styles.onboardContent, bottomInsetStyle]}
        showsVerticalScrollIndicator={false}
        keyboardShouldPersistTaps="handled"
      >
        <OnboardingHeader
          onBack={onBack}
          onSkip={swapActions ? null : onSkip}
          rightAction={headerAction}
          colors={colors}
          t={t}
        />
        <Text style={[styles.onboardTitle, { color: colors.text }]}>{t("registrationTitle")}</Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("registrationSubtitle")}</Text>

        <TouchableOpacity
          style={[styles.avatarPreview, { borderColor: colors.border }]}
          onPress={() => onPickImage?.()}
        >
          {resolvedAvatarUri ? (
            <Image source={{ uri: resolvedAvatarUri }} style={styles.avatarImage} />
          ) : (
            <Image source={fallbackAvatar} style={styles.avatarImage} />
          )}
          <Text style={{ color: colors.muted }}>{t("photoTapHint")}</Text>
        </TouchableOpacity>

      <View style={styles.inputRow}>
        <TextInput
          style={[
            styles.profileInput,
            styles.profileInputHalf,
            { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
          ]}
          placeholder={t("inputFirstName")}
          placeholderTextColor={colors.muted}
          value={data.firstName}
          onChangeText={(text) => onChange("firstName", text)}
          returnKeyType="done"
          blurOnSubmit
          onSubmitEditing={Keyboard.dismiss}
        />
        <TextInput
          style={[
            styles.profileInput,
            styles.profileInputHalf,
            { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
          ]}
          placeholder={t("inputLastName")}
          placeholderTextColor={colors.muted}
          value={data.lastName}
          onChangeText={(text) => onChange("lastName", text)}
          returnKeyType="done"
          blurOnSubmit
          onSubmitEditing={Keyboard.dismiss}
        />
      </View>

        <TextInput
          style={[
            styles.profileInput,
            { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
          ]}
          placeholder={t("inputMotto")}
          placeholderTextColor={colors.muted}
          value={data.motto}
          onChangeText={(text) => onChange("motto", text)}
          returnKeyType="done"
          blurOnSubmit
          onSubmitEditing={Keyboard.dismiss}
        />

        {swapActions ? (
          <TouchableOpacity style={styles.secondaryButtonClear} onPress={onSkip}>
            <Text style={[styles.secondaryButtonClearText, { color: colors.muted }]}>{t("onboardingSkip")}</Text>
          </TouchableOpacity>
        ) : (
          <TouchableOpacity style={[styles.primaryButton, { backgroundColor: colors.text }]} onPress={onSubmit}>
            <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("goalButton")}</Text>
          </TouchableOpacity>
        )}
      </ScrollView>
    </Animated.View>
  );
}

function GoalScreen({
  selectedGoals = [],
  onToggle,
  onSubmit,
  goalTargets = {},
  onGoalTargetChange,
  currency,
  onRegisterGoalTargetFocus,
  colors,
  t,
  language,
  onBack,
  customGoals = [],
  onCustomGoalCreate,
  onSkip,
  onSkipStep,
  bottomInset = 0,
}) {
  const fade = useFadeIn();
  const selection = Array.isArray(selectedGoals) ? selectedGoals : [];
  const targets = goalTargets && typeof goalTargets === "object" ? goalTargets : {};
  const resolvedCurrency = currency || DEFAULT_PROFILE.currency;
  const scrollRef = useRef(null);
  const inputRefs = useRef({});
  const layoutRefs = useRef({});
  const bottomInsetStyle = addBottomInsetStyle(styles.onboardContent, bottomInset);
  const swapActions = IS_SHORT_DEVICE && typeof onSkip === "function";
  const handleSubmit = useCallback(() => {
    onSubmit?.();
  }, [onSubmit]);
  const headerAction = swapActions ? (
    <OnboardingHeaderAction label={t("nextButton")} onPress={handleSubmit} colors={colors} />
  ) : null;
  const focusGoalTarget = useCallback((goalId) => {
    if (!goalId) return;
    const layout = layoutRefs.current[goalId];
    if (layout && scrollRef.current?.scrollTo) {
      scrollRef.current.scrollTo({ y: Math.max(0, layout.y - 32), animated: true });
    }
    setTimeout(() => {
      inputRefs.current?.[goalId]?.focus?.();
    }, 120);
  }, []);
  const handleGoalPress = useCallback(
    (goalId) => {
      const wasActive = selection.includes(goalId);
      onToggle?.(goalId);
      if (!wasActive) {
        setTimeout(() => {
          focusGoalTarget(goalId);
        }, 160);
      }
    },
    [focusGoalTarget, onToggle, selection]
  );
  const primaryAction = (
    <TouchableOpacity style={[styles.primaryButton, { backgroundColor: colors.text }]} onPress={handleSubmit}>
      <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("nextButton")}</Text>
    </TouchableOpacity>
  );
  const skipAction =
    typeof onSkipStep === "function" ? (
      <TouchableOpacity style={styles.secondaryButtonClear} onPress={onSkipStep}>
        <Text style={[styles.secondaryButtonClearText, { color: colors.muted }]}>{t("goalSkip")}</Text>
      </TouchableOpacity>
    ) : null;
  useEffect(() => {
    onRegisterGoalTargetFocus?.(focusGoalTarget);
    return () => {
      onRegisterGoalTargetFocus?.(null);
    };
  }, [focusGoalTarget, onRegisterGoalTargetFocus]);
  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView
        contentContainerStyle={[styles.onboardContent, bottomInsetStyle]}
        showsVerticalScrollIndicator={false}
        keyboardShouldPersistTaps="handled"
        ref={scrollRef}
      >
        <OnboardingHeader
          onBack={onBack}
          onSkip={swapActions ? null : onSkip}
          rightAction={headerAction}
          colors={colors}
          t={t}
        />
        <Text style={[styles.onboardTitle, { color: colors.text }]}>{t("goalTitle")}</Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("goalSubtitle")}</Text>

        <View style={styles.goalGrid}>
          {GOAL_PRESETS.map((goal) => {
            const active = selection.includes(goal.id);
            return (
              <View key={goal.id} style={styles.goalOptionWrap}>
                <TouchableOpacity
                  style={[
                    styles.goalOption,
                    {
                      borderColor: colors.border,
                      backgroundColor: active ? colors.card : "transparent",
                    },
                  ]}
                  onPress={() => handleGoalPress(goal.id)}
                >
                  <Text style={styles.goalEmoji}>{goal.emoji}</Text>
                  <Text style={[styles.goalText, { color: colors.text }]}>
                    {goal[language] || goal.en}
                  </Text>
                </TouchableOpacity>
                {active && (
                  <View
                    style={[
                      styles.goalTargetInputWrap,
                      styles.goalTargetInline,
                      { borderColor: colors.border, backgroundColor: colors.card },
                    ]}
                    onLayout={(event) => {
                      layoutRefs.current[goal.id] = event.nativeEvent.layout;
                    }}
                  >
                    <TextInput
                      ref={(node) => {
                        if (node) {
                          inputRefs.current[goal.id] = node;
                        }
                      }}
                      style={[styles.goalTargetInput, { color: colors.text }]}
                      placeholder={t("goalTargetPlaceholder")}
                      placeholderTextColor={colors.muted}
                      keyboardType="decimal-pad"
                      value={targets[goal.id] || ""}
                      onChangeText={(text) => onGoalTargetChange?.(goal.id, text)}
                      returnKeyType="done"
                      blurOnSubmit
                      onSubmitEditing={Keyboard.dismiss}
                    />
                    <Text style={[styles.goalTargetCurrency, { color: colors.muted }]}>
                      {resolvedCurrency}
                    </Text>
                  </View>
                )}
              </View>
            );
          })}
        </View>

        {customGoals.length > 0 && (
          <>
            <Text style={[styles.goalCustomSectionTitle, { color: colors.muted }]}>
              {t("goalCustomSectionTitle")}
            </Text>
            <View style={styles.goalGrid}>
              {customGoals.map((goal) => {
                const active = selection.includes(goal.id);
                return (
                  <View key={goal.id} style={styles.goalOptionWrap}>
                    <TouchableOpacity
                      style={[
                        styles.goalOption,
                        {
                          borderColor: colors.border,
                          backgroundColor: active ? colors.card : "transparent",
                        },
                      ]}
                      onPress={() => handleGoalPress(goal.id)}
                    >
                      <Text style={styles.goalEmoji}>{goal.emoji || "ðŸŽ¯"}</Text>
                      <Text style={[styles.goalText, { color: colors.text }]}>{goal.title}</Text>
                    </TouchableOpacity>
                    {active && (
                      <View
                        style={[
                          styles.goalTargetInputWrap,
                          styles.goalTargetInline,
                          { borderColor: colors.border, backgroundColor: colors.card },
                        ]}
                        onLayout={(event) => {
                          layoutRefs.current[goal.id] = event.nativeEvent.layout;
                        }}
                      >
                    <TextInput
                      ref={(node) => {
                        if (node) {
                          inputRefs.current[goal.id] = node;
                        }
                      }}
                      style={[styles.goalTargetInput, { color: colors.text }]}
                      placeholder={t("goalTargetPlaceholder")}
                      placeholderTextColor={colors.muted}
                      keyboardType="decimal-pad"
                      value={targets[goal.id] || ""}
                      onChangeText={(text) => onGoalTargetChange?.(goal.id, text)}
                      returnKeyType="done"
                      blurOnSubmit
                      onSubmitEditing={Keyboard.dismiss}
                    />
                        <Text style={[styles.goalTargetCurrency, { color: colors.muted }]}>
                          {resolvedCurrency}
                        </Text>
                      </View>
                    )}
                  </View>
                );
              })}
            </View>
          </>
        )}

        {onCustomGoalCreate && (
          <TouchableOpacity
            style={[styles.goalCustomButton, { borderColor: colors.border }]}
            onPress={onCustomGoalCreate}
          >
            <Text style={[styles.goalCustomButtonText, { color: colors.text }]}>
              {t("goalCustomCreate")}
            </Text>
          </TouchableOpacity>
        )}

        {swapActions ? (
          <>
            {skipAction}
            <TouchableOpacity style={styles.secondaryButtonClear} onPress={onSkip}>
              <Text style={[styles.secondaryButtonClearText, { color: colors.muted }]}>
                {t("onboardingSkip")}
              </Text>
            </TouchableOpacity>
          </>
        ) : (
          <>
            {primaryAction}
            {skipAction}
          </>
        )}
      </ScrollView>
    </Animated.View>
  );
}

function GoalTargetScreen({
  selections = [],
  values = {},
  currency,
  onChange,
  onSubmit,
  onBack,
  colors,
  t,
  language,
  customGoals = [],
  onSkip,
  bottomInset = 0,
}) {
  const fade = useFadeIn();
  const selectionList = Array.isArray(selections) ? selections : [];
  const customGoalMap = useMemo(() => {
    const entries = Array.isArray(customGoals) ? customGoals : [];
    return entries.reduce((acc, goal) => {
      acc[goal.id] = goal;
      return acc;
    }, {});
  }, [customGoals]);
  const bottomInsetStyle = addBottomInsetStyle(styles.onboardContent, bottomInset);
  const swapActions = IS_SHORT_DEVICE && typeof onSkip === "function";
  const headerAction = swapActions ? (
    <OnboardingHeaderAction label={t("goalTargetCTA")} onPress={onSubmit} colors={colors} />
  ) : null;
  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView
        contentContainerStyle={[styles.onboardContent, bottomInsetStyle]}
        showsVerticalScrollIndicator={false}
        keyboardShouldPersistTaps="handled"
      >
        <OnboardingHeader
          onBack={onBack}
          onSkip={swapActions ? null : onSkip}
          rightAction={headerAction}
          colors={colors}
          t={t}
        />
        <Text style={[styles.onboardTitle, { color: colors.text }]}>{t("goalTargetTitle")}</Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("goalTargetSubtitle")}</Text>
        {selectionList.map((goalId) => {
          const preset = getGoalPreset(goalId);
          const customGoal = customGoalMap[goalId];
          const goalLabel =
            customGoal?.title || preset?.[language] || preset?.en || goalId;
          return (
            <View key={goalId} style={styles.goalTargetRow}>
              <Text style={[styles.goalTargetLabel, { color: colors.muted }]}>{goalLabel}</Text>
              <View
                style={[
                  styles.goalTargetInputWrap,
                  { borderColor: colors.border, backgroundColor: colors.card },
                ]}
              >
                <TextInput
                  style={[styles.goalTargetInput, { color: colors.text }]}
                  placeholder={t("goalTargetPlaceholder")}
                  placeholderTextColor={colors.muted}
                  keyboardType="decimal-pad"
                  value={values[goalId] || ""}
                  onChangeText={(text) => onChange?.(goalId, text)}
                  returnKeyType="done"
                  blurOnSubmit
                  onSubmitEditing={Keyboard.dismiss}
                />
                <Text style={[styles.goalTargetCurrency, { color: colors.muted }]}>{currency}</Text>
              </View>
            </View>
          );
        })}
        <Text style={[styles.goalTargetHint, { color: colors.muted }]}>{t("goalTargetHint")}</Text>
        {swapActions ? (
          <TouchableOpacity style={styles.secondaryButtonClear} onPress={onSkip}>
            <Text style={[styles.secondaryButtonClearText, { color: colors.muted }]}>
              {t("onboardingSkip")}
            </Text>
          </TouchableOpacity>
        ) : (
          <TouchableOpacity style={[styles.primaryButton, { backgroundColor: colors.text }]} onPress={onSubmit}>
            <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("goalTargetCTA")}</Text>
          </TouchableOpacity>
        )}
      </ScrollView>
    </Animated.View>
  );
}

function AnalyticsConsentScreen({ colors, t, onSubmit, onBack, bottomInset = 0 }) {
  const isTrackingPrePrompt = Platform.OS === "ios";
  const titleKey = isTrackingPrePrompt ? "trackingConsentTitle" : "analyticsConsentTitle";
  const bodyKey = isTrackingPrePrompt ? "trackingConsentBody" : "analyticsConsentBody";
  const primaryKey = isTrackingPrePrompt ? "trackingConsentContinue" : "analyticsConsentAgree";
  const bottomInsetStyle = addBottomInsetStyle(
    [styles.analyticsConsentScreen, styles.analyticsConsentContent],
    bottomInset
  );

  return (
    <ScrollView
      contentContainerStyle={[
        styles.analyticsConsentScreen,
        styles.analyticsConsentContent,
        { backgroundColor: colors.background },
        bottomInsetStyle,
      ]}
      showsVerticalScrollIndicator={false}
    >
      <OnboardingBackButton onPress={onBack} colors={colors} t={t} />
      <View
        style={[
          styles.analyticsConsentCard,
          { backgroundColor: colors.card, borderColor: colors.border },
        ]}
      >
        <Text style={[styles.analyticsConsentTitle, { color: colors.text }]}>
          {t(titleKey)}
        </Text>
        <Text style={[styles.analyticsConsentBody, { color: colors.muted }]}>
          {t(bodyKey)}
        </Text>
        <TouchableOpacity
          style={[styles.analyticsConsentPrimary, { backgroundColor: colors.text }]}
          onPress={() => onSubmit(true)}
        >
          <Text style={[styles.analyticsConsentPrimaryText, { color: colors.background }]}>
            {t(primaryKey)}
          </Text>
        </TouchableOpacity>
        {!isTrackingPrePrompt && (
          <TouchableOpacity
            style={[styles.analyticsConsentSecondary, { borderColor: colors.border }]}
            onPress={() => onSubmit(false)}
          >
            <Text style={[styles.analyticsConsentSecondaryText, { color: colors.muted }]}>
              {t("analyticsConsentSkip")}
            </Text>
          </TouchableOpacity>
        )}
      </View>
    </ScrollView>
  );
}

function OnboardingNotificationsScreen({ colors, t, onContinue, mascotHappySource, bottomInset = 0 }) {
  const fade = useFadeIn();
  const happySource = mascotHappySource || CLASSIC_TAMAGOTCHI_ANIMATIONS.happy;
  const bottomInsetStyle = addBottomInsetStyle(
    [styles.onboardContent, styles.onboardCenteredContent],
    bottomInset
  );

  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView
        contentContainerStyle={[styles.onboardContent, styles.onboardCenteredContent, bottomInsetStyle]}
        showsVerticalScrollIndicator={false}
      >
        <Image source={happySource} style={styles.languageMascot} />
        <Text style={[styles.onboardTitleCompact, { color: colors.text, textAlign: "center" }]}>
          {t("onboardingNotificationsTitle")}
        </Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted, textAlign: "center" }]}>
          {t("onboardingNotificationsBody")}
        </Text>
        <TouchableOpacity
          style={[styles.primaryButton, styles.onboardWideButton, { backgroundColor: colors.text }]}
          onPress={onContinue}
        >
          <Text style={[styles.primaryButtonText, { color: colors.background }]}>
            {t("onboardingNotificationsCTA")}
          </Text>
        </TouchableOpacity>
      </ScrollView>
    </Animated.View>
  );
}

function SpendingBaselineScreen({
  value,
  incomeValue,
  currency,
  onChange,
  onIncomeChange,
  onSubmit,
  colors,
  t,
  onBack,
  onSkip,
  onSkipStep,
  bottomInset = 0,
}) {
  const fade = useFadeIn();
  const baselineSampleLabel = formatSampleAmount(BASELINE_SAMPLE_USD, currency || DEFAULT_PROFILE.currency);
  const bottomInsetStyle = addBottomInsetStyle(styles.onboardContent, bottomInset);
  const swapActions = IS_SHORT_DEVICE && typeof onSkip === "function";
  const headerAction = swapActions ? (
    <OnboardingHeaderAction label={t("baselineCTA")} onPress={onSubmit} colors={colors} />
  ) : null;
  const primaryAction = (
    <TouchableOpacity style={[styles.primaryButton, { backgroundColor: colors.text }]} onPress={onSubmit}>
      <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("baselineCTA")}</Text>
    </TouchableOpacity>
  );
  const skipAction =
    typeof onSkipStep === "function" ? (
      <TouchableOpacity style={styles.secondaryButtonClear} onPress={onSkipStep}>
        <Text style={[styles.secondaryButtonClearText, { color: colors.muted }]}>{t("baselineSkip")}</Text>
      </TouchableOpacity>
    ) : null;
  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView
        contentContainerStyle={[styles.onboardContent, bottomInsetStyle]}
        showsVerticalScrollIndicator={false}
        keyboardShouldPersistTaps="handled"
      >
        <OnboardingHeader
          onBack={onBack}
          onSkip={swapActions ? null : onSkip}
          rightAction={headerAction}
          colors={colors}
          t={t}
        />
        <Text style={[styles.onboardTitle, { color: colors.text }]}>{t("baselineTitle")}</Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("baselineSubtitle")}</Text>
        <View style={styles.baselineStack}>
          <View
            style={[
              styles.baselineCard,
              { borderColor: colors.border, backgroundColor: colors.card },
            ]}
          >
            <Text style={[styles.baselineCardTitle, { color: colors.text }]}>
              {t("baselineIncomeLabel")}
            </Text>
          <TextInput
            style={[
              styles.primaryInput,
              styles.baselineInputCompact,
              { borderColor: colors.border, color: colors.text, backgroundColor: colors.background },
            ]}
            placeholder={t("baselineIncomePlaceholder")}
            placeholderTextColor={colors.muted}
            keyboardType="decimal-pad"
            value={incomeValue}
            onChangeText={onIncomeChange}
            returnKeyType="done"
            blurOnSubmit
            onSubmitEditing={Keyboard.dismiss}
          />
          <Text style={[styles.baselineCardHint, { color: colors.muted }]}>
            {t("baselineIncomeHint")}
          </Text>
        </View>
          <View
            style={[
              styles.baselineCard,
              { borderColor: colors.border, backgroundColor: colors.card },
            ]}
          >
            <Text style={[styles.baselineCardTitle, { color: colors.text }]}>
              {t("baselineSpendLabel")}
            </Text>
            <TextInput
              style={[
                styles.primaryInput,
                styles.baselineInputCompact,
                { borderColor: colors.border, color: colors.text, backgroundColor: colors.background },
              ]}
              placeholder={t("baselinePlaceholder", { amount: baselineSampleLabel })}
              placeholderTextColor={colors.muted}
              keyboardType="decimal-pad"
              value={value}
              onChangeText={onChange}
              returnKeyType="done"
              blurOnSubmit
              onSubmitEditing={Keyboard.dismiss}
            />
          </View>
        </View>
        <Text style={[styles.baselineHint, { color: colors.muted }]}>{t("baselineHint")}</Text>
        {swapActions ? (
          <>
            {skipAction}
            <TouchableOpacity style={styles.secondaryButtonClear} onPress={onSkip}>
              <Text style={[styles.secondaryButtonClearText, { color: colors.muted }]}>
                {t("onboardingSkip")}
              </Text>
            </TouchableOpacity>
          </>
        ) : (
          <>
            {primaryAction}
            {skipAction}
          </>
        )}
      </ScrollView>
    </Animated.View>
  );
}

function PersonaScreen({ data, onChange, onSubmit, colors, t, language, onBack, onSkip, bottomInset = 0 }) {
  const fade = useFadeIn();
  const personaList = Object.values(PERSONA_PRESETS);
  const bottomInsetStyle = addBottomInsetStyle(
    [styles.onboardContent, styles.onboardContentWithFooter],
    bottomInset
  );
  const floatingInsetStyle = addBottomOffsetStyle(
    Platform.OS === "android"
      ? [styles.onboardFloatingActions, styles.onboardFloatingActionsTight]
      : styles.onboardFloatingActions,
    bottomInset
  );
  const swapActions = IS_SHORT_DEVICE && typeof onSkip === "function";
  const headerAction = swapActions ? (
    <OnboardingHeaderAction label={t("personaConfirm")} onPress={onSubmit} colors={colors} />
  ) : null;
  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView
        contentContainerStyle={[
          styles.onboardContent,
          styles.onboardContentWithFooter,
          bottomInsetStyle,
        ]}
        showsVerticalScrollIndicator={false}
      >
        <OnboardingHeader
          onBack={onBack}
          onSkip={swapActions ? null : onSkip}
          rightAction={headerAction}
          colors={colors}
          t={t}
        />
        <Text style={[styles.personaTitleCompact, { color: colors.text }]}>
          {t("personaTitle")}
        </Text>
        <View style={styles.genderGrid}>
          {GENDER_OPTIONS.map((option) => {
            const active = option.id === data.gender;
            return (
              <TouchableOpacity
                key={option.id}
                style={[
                  styles.genderChip,
                  {
                    borderColor: colors.border,
                    backgroundColor: active ? colors.card : "transparent",
                  },
                ]}
                onPress={() => onChange("gender", option.id)}
              >
                <Text style={styles.genderEmoji}>{option.emoji}</Text>
                <Text style={[styles.genderLabel, { color: colors.text }]}>
                  {option.label[language] || option.label.en}
                </Text>
              </TouchableOpacity>
            );
          })}
        </View>

        <View style={styles.personaGrid}>
          {personaList.map((persona) => {
            const active = data.persona === persona.id;
            return (
              <TouchableOpacity
                key={persona.id}
                style={[
                  styles.personaCard,
                  {
                    borderColor: colors.border,
                    backgroundColor: active ? colors.card : "transparent",
                  },
                ]}
                onPress={() => onChange("persona", persona.id)}
              >
                <Text style={styles.personaEmoji}>{persona.emoji}</Text>
                <Text style={[styles.personaTitle, { color: colors.text }]}>
                  {persona.title[language] || persona.title.en}
                </Text>
                <Text style={[styles.personaSubtitleCard, { color: colors.muted }]}>
                  {persona.description[language] || persona.description.en}
                </Text>
              </TouchableOpacity>
            );
          })}
        </View>

      </ScrollView>
      <View
        style={[
          styles.onboardFloatingActions,
          { backgroundColor: colors.background },
          floatingInsetStyle,
        ]}
      >
        {swapActions ? (
          <TouchableOpacity style={styles.secondaryButtonClear} onPress={onSkip}>
            <Text style={[styles.secondaryButtonClearText, { color: colors.muted }]}>{t("onboardingSkip")}</Text>
          </TouchableOpacity>
        ) : (
          <TouchableOpacity
            style={[styles.primaryButton, styles.onboardFloatingPrimary, { backgroundColor: colors.text }]}
            onPress={onSubmit}
          >
            <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("personaConfirm")}</Text>
          </TouchableOpacity>
        )}
      </View>
    </Animated.View>
  );
}

function CustomHabitScreen({
  data,
  onChange,
  onSubmit,
  colors,
  t,
  currency,
  onBack,
  language,
  onSkip,
  bottomInset = 0,
}) {
  const fade = useFadeIn();
  const customSpendSampleLabel = formatSampleAmount(CUSTOM_SPEND_SAMPLE_USD, currency || DEFAULT_PROFILE.currency);
  const bottomInsetStyle = addBottomInsetStyle(styles.onboardContentCompact, bottomInset);
  const swapActions = IS_SHORT_DEVICE && typeof onSkip === "function";
  const headerAction = swapActions ? (
    <OnboardingHeaderAction label={t("personaConfirm")} onPress={() => onSubmit(false)} colors={colors} />
  ) : null;
  const primaryAction = (
    <TouchableOpacity style={[styles.primaryButton, { backgroundColor: colors.text }]} onPress={() => onSubmit(false)}>
      <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("personaConfirm")}</Text>
    </TouchableOpacity>
  );
  const skipAction = (
    <TouchableOpacity style={styles.secondaryButtonClear} onPress={() => onSubmit(true)}>
      <Text style={[styles.secondaryButtonClearText, { color: colors.muted }]}>{t("customSpendSkip")}</Text>
    </TouchableOpacity>
  );
  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView
        contentContainerStyle={[styles.onboardContentCompact, bottomInsetStyle]}
        showsVerticalScrollIndicator={false}
      >
        <OnboardingHeader
          onBack={onBack}
          onSkip={swapActions ? null : onSkip}
          rightAction={headerAction}
          colors={colors}
          t={t}
        />
        <Text style={[styles.onboardTitleCompact, { color: colors.text }]}>{t("customSpendTitle")}</Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("customSpendSubtitle")}</Text>

        <TextInput
          style={[
            styles.primaryInput,
            { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
          ]}
          placeholder={t("customSpendNamePlaceholder")}
          placeholderTextColor={colors.muted}
          value={data.customSpendTitle}
          onChangeText={(text) => onChange("customSpendTitle", text)}
          returnKeyType="done"
          blurOnSubmit
          onSubmitEditing={Keyboard.dismiss}
        />
        <View style={{ gap: 6 }}>
          <Text style={[styles.currencyLabel, { color: colors.muted }]}>{t("customSpendAmountLabel")}</Text>
          <TextInput
            style={[
              styles.primaryInput,
              { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
            ]}
            placeholder={t("customSpendAmountPlaceholder", { amount: customSpendSampleLabel })}
            placeholderTextColor={colors.muted}
            keyboardType="decimal-pad"
            value={data.customSpendAmount}
            onChangeText={(text) => onChange("customSpendAmount", text)}
            returnKeyType="done"
            blurOnSubmit
            onSubmitEditing={Keyboard.dismiss}
          />
        </View>
        <View style={{ gap: 6 }}>
          <Text style={[styles.currencyLabel, { color: colors.muted }]}>{t("customSpendFrequencyLabel")}</Text>
          <TextInput
            style={[
              styles.primaryInput,
              { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
            ]}
            placeholder={t("customSpendFrequencyPlaceholder")}
            placeholderTextColor={colors.muted}
            keyboardType="number-pad"
            value={data.customSpendFrequency}
            onChangeText={(text) => onChange("customSpendFrequency", text)}
            returnKeyType="done"
            blurOnSubmit
            onSubmitEditing={Keyboard.dismiss}
          />
        </View>
        <View style={{ gap: 6 }}>
          <Text style={[styles.currencyLabel, { color: colors.muted }]}>{t("impulseCategoryLabel")}</Text>
          <ImpulseCategorySelector
            value={data.customSpendCategory || DEFAULT_IMPULSE_CATEGORY}
            onChange={(cat) => onChange("customSpendCategory", cat)}
            colors={colors}
            language={language}
            compact
            horizontal
            visibleCount={4}
          />
        </View>
        <Text style={{ color: colors.muted }}>{t("customSpendHint")}</Text>
        {swapActions ? (
          <>
            {skipAction}
            <TouchableOpacity style={styles.secondaryButtonClear} onPress={onSkip}>
              <Text style={[styles.secondaryButtonClearText, { color: colors.muted }]}>
                {t("onboardingSkip")}
              </Text>
            </TouchableOpacity>
          </>
        ) : (
          <>
            {primaryAction}
            {skipAction}
          </>
        )}
      </ScrollView>
    </Animated.View>
  );
}

function ImpulseCategorySelector({
  value,
  onChange,
  colors,
  language,
  compact = false,
  horizontal = false,
  visibleCount = 5,
  allowEmpty = false,
  tall = false,
}) {
  const selected = value && IMPULSE_CATEGORY_DEFS[value] ? value : allowEmpty ? null : DEFAULT_IMPULSE_CATEGORY;
  const categoryOrder = getBudgetCategoryOrder().filter((id) => id !== "savings");
  const gap = compact ? 6 : 8;
  const horizontalPadding = compact ? 16 : 24;
  const minChipWidth = compact ? 72 : 64;
  const tallChipStyle = tall
    ? compact
      ? styles.impulseCategoryChipTallCompact
      : styles.impulseCategoryChipTall
    : null;
  const chipWidth = horizontal
    ? Math.max(
        minChipWidth,
        Math.floor(
          (SCREEN_WIDTH - horizontalPadding * 2 - gap * Math.max(visibleCount - 1, 0)) /
            Math.max(visibleCount, 1)
        )
      )
    : null;
  const chips = categoryOrder.map((categoryId) => {
    const active = selected === categoryId;
    return (
      <TouchableOpacity
        key={categoryId}
        style={[
          styles.impulseCategoryChip,
          compact && styles.impulseCategoryChipCompact,
          tallChipStyle,
          horizontal && chipWidth ? { width: chipWidth } : null,
          {
            borderColor: active ? colors.text : colors.border,
            backgroundColor: active ? colors.text : "transparent",
          },
        ]}
        onPress={() => onChange?.(categoryId)}
        activeOpacity={0.85}
      >
        <Text
          style={[
            styles.impulseCategoryChipText,
            compact && styles.impulseCategoryChipTextCompact,
            { color: active ? colors.background : colors.text },
          ]}
          numberOfLines={2}
        >
          {getImpulseCategoryLabel(categoryId, language)}
        </Text>
      </TouchableOpacity>
    );
  });
  if (horizontal) {
    return (
      <ScrollView
        horizontal
        showsHorizontalScrollIndicator={false}
        style={styles.impulseCategoryPickerScroll}
        contentContainerStyle={[styles.impulseCategoryPickerScrollContent, { gap }]}
      >
        {chips}
      </ScrollView>
    );
  }
  return (
    <View
      style={[
        styles.impulseCategoryPicker,
        compact && styles.impulseCategoryPickerCompact,
      ]}
    >
      {chips}
    </View>
  );
}

function CoinEntryModal({
  visible,
  presetAction = null,
  colors,
  t,
  currency,
  language,
  maxAmountUSD = DEFAULT_COIN_SLIDER_MAX_USD,
  categoryStats,
  categoryRecency,
  customCategories = [],
  onUpdateMaxUSD,
  onSubmit,
  onCancel,
  playSound,
  origin,
  saveTarget,
}) {
  const [sliderValue, setSliderValue] = useState(0.25);
  const [trackHeight, setTrackHeight] = useState(260);
  const [selectedCategory, setSelectedCategory] = useState(null);
  const [categoryError, setCategoryError] = useState(false);
  const [manualMode, setManualMode] = useState(null);
  const [manualValue, setManualValue] = useState("");
  const [manualError, setManualError] = useState("");
  const [manualExactLocal, setManualExactLocal] = useState(null);
  const [flightCoinAsset, setFlightCoinAsset] = useState(HEALTH_COIN_TIERS[0]?.asset || null);
  const [flightDirection, setFlightDirection] = useState("save");
  const preferredAction =
    presetAction === "save" || presetAction === "spend" ? presetAction : null;
  const [closeTintColor, setCloseTintColor] = useState("transparent");
  const revealAnim = useRef(new Animated.Value(0)).current;
  const cardAnim = useRef(new Animated.Value(0)).current;
  const closeTintOpacity = useRef(new Animated.Value(0)).current;
  const flightPosition = useRef(new Animated.ValueXY({ x: 0, y: 0 })).current;
  const flightScale = useRef(new Animated.Value(0.4)).current;
  const flightOpacity = useRef(new Animated.Value(0)).current;
  const flightSpin = useRef(new Animated.Value(0)).current;
  const coinCircleRef = useRef(null);
  const closingRef = useRef(false);
  const dismissingRef = useRef(false);
  const directionAnim = useRef(new Animated.Value(0)).current;
  const sliderValueRef = useRef(0.25);
  const sliderValueCommitRef = useRef(0.25);
  const pendingSliderValueRef = useRef(null);
  const sliderRafRef = useRef(null);
  const hapticStepRef = useRef(0);
  const sliderHapticCooldownRef = useRef(0);
  const sliderTickStepRef = useRef(null);
  const sliderTickCooldownRef = useRef(0);
  const tossingRef = useRef(false);
  const touchStartValueRef = useRef(0.25);
  const touchStartPageYRef = useRef(0);
  const sliderGestureRef = useRef({
    axis: "pending",
  });
  const touchStartRef = useRef(0);
  const manualVisible = manualMode !== null;
  const manualIsAmountMode = manualMode === "amount";
  useEffect(() => {
    return () => {
      if (sliderRafRef.current) {
        cancelAnimationFrame(sliderRafRef.current);
        sliderRafRef.current = null;
      }
    };
  }, []);
  useEffect(() => {
    if (!visible) return;
    updateSliderValue(0.25, { force: true });
    hapticStepRef.current = Math.round(0.25 * 20);
    sliderHapticCooldownRef.current = 0;
    sliderGestureRef.current = {
      axis: "pending",
    };
    setSelectedCategory(null);
    setCategoryError(false);
    setManualMode(null);
    setManualValue("");
    setManualError("");
    setManualExactLocal(null);
    directionAnim.setValue(0);
    sliderTickStepRef.current = null;
    sliderTickCooldownRef.current = 0;
    tossingRef.current = false;
    touchStartRef.current = 0;
    touchStartValueRef.current = 0.25;
    touchStartPageYRef.current = 0;
  }, [directionAnim, updateSliderValue, visible]);
  useEffect(() => {
    if (!visible) {
      setCloseTintColor("transparent");
      revealAnim.setValue(0);
      cardAnim.setValue(0);
      closeTintOpacity.setValue(0);
      flightOpacity.setValue(0);
      flightScale.setValue(0.4);
      flightSpin.setValue(0);
      closingRef.current = false;
      dismissingRef.current = false;
      return;
    }
    setCloseTintColor("transparent");
    revealAnim.setValue(0);
    cardAnim.setValue(0);
    closeTintOpacity.setValue(0);
    flightOpacity.setValue(0);
    flightScale.setValue(0.4);
    flightSpin.setValue(0);
    closingRef.current = false;
    dismissingRef.current = false;
    Animated.parallel([
      Animated.timing(revealAnim, {
        toValue: 1,
        duration: 420,
        easing: Easing.out(Easing.cubic),
        useNativeDriver: true,
      }),
      Animated.spring(cardAnim, {
        toValue: 1,
        friction: 7,
        tension: 110,
        useNativeDriver: true,
      }),
    ]).start();
  }, [cardAnim, closeTintOpacity, flightOpacity, flightScale, flightSpin, revealAnim, visible]);
  const currencySymbol =
    CURRENCY_SIGNS[currency] ||
    CURRENCY_SIGNS[DEFAULT_PROFILE.currency] ||
    DEFAULT_PROFILE.currency ||
    "$";
  const displayPrecision = useMemo(() => getCurrencyDisplayPrecision(currency), [currency]);
  const tickStepLocal = useMemo(
    () => (displayPrecision > 0 ? Math.pow(10, -displayPrecision) : 1),
    [displayPrecision]
  );
  const computeAmountUSDForValue = useCallback(
    (value) => {
      if (!Number.isFinite(value) || maxAmountUSD <= 0) return 0;
      const localAmount = roundCurrencyValue(
        convertToCurrency(maxAmountUSD * value, currency),
        currency
      );
      const usd = convertFromCurrency(localAmount, currency);
      return Math.max(0, Math.min(maxAmountUSD, usd));
    },
    [currency, maxAmountUSD]
  );
  const sliderAmountUSD = computeAmountUSDForValue(sliderValue);
  const sliderLocalValue = snapCurrencyValue(convertToCurrency(sliderAmountUSD, currency), currency);
  const sliderAmountLocal = manualExactLocal
    ? formatCurrencyWhole(manualExactLocal.value, currency, manualExactLocal.precision)
    : formatCurrencyWhole(sliderLocalValue, currency);
  const sliderMaxLocalValue = useMemo(
    () => snapCurrencyValue(convertToCurrency(maxAmountUSD, currency), currency),
    [currency, maxAmountUSD]
  );
  const sliderMaxLocal = formatCurrencyWhole(sliderMaxLocalValue, currency);
  const sliderFillHeight = Math.max(COIN_FILL_MIN_HEIGHT, Math.min(trackHeight, trackHeight * sliderValue));
  const coinHasValue = sliderValue > 0.02;
  const coinFillColor = coinHasValue ? "#F7C45D" : "#DADDE3";
  const coinShineColor = coinHasValue ? "rgba(255,255,255,0.5)" : "rgba(255,255,255,0.25)";
  const isDarkTheme = colors.background === THEMES.dark.background;
  const coinSurfaceOuter = isDarkTheme ? "#111525" : "#F6F8FC";
  const coinSurfaceInner = isDarkTheme ? "#181D31" : "#ECEFF5";
  const coinSurfaceBorder = isDarkTheme ? "rgba(255,255,255,0.14)" : "rgba(255,255,255,0.8)";
  const coinSymbolColor = isDarkTheme ? "rgba(245,248,255,0.78)" : "rgba(5,7,13,0.25)";
  const coinSymbolOpacity = isDarkTheme ? 0.85 : 0.2;
  const sliderBackground = directionAnim.interpolate({
    inputRange: [-1, 0, 1],
    outputRange: ["rgba(217,72,98,0.18)", "rgba(0,0,0,0)", "rgba(46,184,115,0.18)"],
    extrapolate: "clamp",
  });
  const coinTranslateX = directionAnim.interpolate({
    inputRange: [-3, -1, 0, 1, 3],
    outputRange: [-SCREEN_WIDTH, -48, 0, 48, SCREEN_WIDTH],
    extrapolate: "clamp",
  });
  const originX = Number.isFinite(origin?.x) ? origin.x : SCREEN_WIDTH / 2;
  const originY = Number.isFinite(origin?.y) ? origin.y : SCREEN_HEIGHT - 120;
  const maxRevealScale = useMemo(
    () => Math.max(1, Math.hypot(SCREEN_WIDTH, SCREEN_HEIGHT) / (COIN_REVEAL_SIZE / 2)),
    []
  );
  const revealScale = revealAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0.15, maxRevealScale],
    extrapolate: "clamp",
  });
  const backdropOpacity = revealAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0, 1],
    extrapolate: "clamp",
  });
  const cardScale = cardAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0.4, 1],
    extrapolate: "clamp",
  });
  const cardOpacity = cardAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0, 1],
    extrapolate: "clamp",
  });
  const currencyFineStep = useMemo(() => getCurrencyFineStep(currency), [currency]);
  const computeTickIndex = useCallback(
    (value) => {
      if (!Number.isFinite(value)) return 0;
      const amountUSD = computeAmountUSDForValue(value);
      const localAmount = snapCurrencyValue(convertToCurrency(amountUSD, currency), currency);
      const roundedLocal = roundCurrencyValue(localAmount, currency, displayPrecision);
      const stepLocal = tickStepLocal || 1;
      if (!Number.isFinite(stepLocal) || stepLocal <= 0) {
        return Math.round(roundedLocal * 100);
      }
      return Math.round(roundedLocal / stepLocal);
    },
    [computeAmountUSDForValue, currency, displayPrecision, tickStepLocal]
  );
  const triggerSliderTick = useCallback(
    (stepIndex) => {
      if (stepIndex === null || stepIndex === undefined) return;
      if (sliderTickStepRef.current === stepIndex) return;
      sliderTickStepRef.current = stepIndex;
      const now = Date.now();
      if (now - sliderTickCooldownRef.current < 30) return;
      sliderTickCooldownRef.current = now;
      playSound?.("counter", { skipCooldown: true });
    },
    [playSound]
  );
  const computeSteppedValue = useCallback(
    (rawValue) => {
      const clamped = Math.max(0, Math.min(1, rawValue));
      if (!Number.isFinite(clamped) || maxAmountUSD <= 0 || sliderMaxLocalValue <= 0) {
        return clamped;
      }
      const targetLocal = clamped * sliderMaxLocalValue;
      const stepLocal = currencyFineStep;
      let roundedLocal;
      if (stepLocal > 0) {
        roundedLocal = Math.round(targetLocal / stepLocal) * stepLocal;
      } else {
        roundedLocal = targetLocal;
      }
      roundedLocal = roundCurrencyValue(roundedLocal, currency);
      const limitedLocal = Math.max(0, Math.min(sliderMaxLocalValue, roundedLocal));
      const roundedUSD = convertFromCurrency(limitedLocal, currency);
      if (!Number.isFinite(roundedUSD) || roundedUSD < 0) {
        return clamped;
      }
      return Math.max(0, Math.min(1, roundedUSD / maxAmountUSD));
    },
    [currency, currencyFineStep, sliderMaxLocalValue, maxAmountUSD]
  );
  const computeValueFromTouch = useCallback(
    (locationY) => {
      if (!Number.isFinite(locationY) || trackHeight <= 0) {
        return sliderValueRef.current;
      }
      const clamped = Math.max(0, Math.min(trackHeight, locationY));
      const normalized = 1 - clamped / trackHeight;
      return Math.max(0, Math.min(1, normalized));
    },
    [sliderValueRef, trackHeight]
  );
  const resolveSaveTarget = useCallback(() => {
    if (saveTarget && Number.isFinite(saveTarget.x) && Number.isFinite(saveTarget.y)) {
      return { x: saveTarget.x, y: saveTarget.y };
    }
    return { x: SCREEN_WIDTH / 2, y: Math.max(80, SCREEN_HEIGHT * 0.2) };
  }, [saveTarget]);
  const resolveSpendTarget = useCallback(
    () => ({ x: originX, y: SCREEN_HEIGHT + COIN_FLIGHT_SIZE * 0.8 }),
    [originX]
  );
  const measureCoinAnchor = useCallback(
    (callback) => {
      const node = coinCircleRef.current;
      if (!node || typeof node.measureInWindow !== "function") {
        callback({ x: originX, y: originY });
        return;
      }
      node.measureInWindow((x, y, width, height) => {
        if (!Number.isFinite(x) || !Number.isFinite(y) || !width || !height) {
          callback({ x: originX, y: originY });
          return;
        }
        const androidStatusBarOffset = Platform.OS === "android" ? RNStatusBar.currentHeight || 0 : 0;
        callback({
          x: x + width / 2,
          y: y + height / 2 + androidStatusBarOffset,
        });
      });
    },
    [originX, originY]
  );
  const runDismissAnimation = useCallback(
    (onComplete) => {
      if (dismissingRef.current || closingRef.current) return;
      dismissingRef.current = true;
      Animated.parallel([
        Animated.timing(cardAnim, {
          toValue: 0,
          duration: 160,
          easing: Easing.in(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(revealAnim, {
          toValue: 0,
          duration: 200,
          easing: Easing.in(Easing.cubic),
          useNativeDriver: true,
        }),
      ]).start(() => {
        dismissingRef.current = false;
        onComplete?.();
      });
    },
    [cardAnim, revealAnim]
  );
  const runSubmitAnimation = useCallback(
    (direction, payload) => {
      if (closingRef.current) return;
      closingRef.current = true;
      setFlightDirection(direction);
      setCloseTintColor(
        direction === "save" ? "rgba(46,184,115,0.35)" : "rgba(217,72,98,0.35)"
      );
      setFlightCoinAsset(
        direction === "save"
          ? HEALTH_COIN_TIERS.find((tier) => tier.id === "green")?.asset || HEALTH_COIN_TIERS[0]?.asset
          : HEALTH_COIN_TIERS.find((tier) => tier.id === "red")?.asset || HEALTH_COIN_TIERS[0]?.asset
      );
      closeTintOpacity.setValue(0);
      flightOpacity.setValue(0);
      flightScale.setValue(0.5);
      flightSpin.setValue(0);
      measureCoinAnchor((start) => {
        const target = direction === "save" ? resolveSaveTarget() : resolveSpendTarget();
        flightPosition.setValue({
          x: start.x - COIN_FLIGHT_SIZE / 2,
          y: start.y - COIN_FLIGHT_SIZE / 2,
        });
        Animated.parallel([
          Animated.timing(closeTintOpacity, {
            toValue: 1,
            duration: 180,
            easing: Easing.out(Easing.quad),
            useNativeDriver: true,
          }),
          Animated.timing(cardAnim, {
            toValue: 0,
            duration: 180,
            easing: Easing.in(Easing.quad),
            useNativeDriver: true,
          }),
          Animated.timing(flightOpacity, {
            toValue: 1,
            duration: 160,
            useNativeDriver: true,
          }),
          Animated.sequence([
            Animated.timing(flightScale, {
              toValue: 1.05,
              duration: 160,
              easing: Easing.out(Easing.back(1.1)),
              useNativeDriver: true,
            }),
            Animated.timing(flightScale, {
              toValue: 0.7,
              duration: 320,
              easing: Easing.in(Easing.quad),
              useNativeDriver: true,
            }),
          ]),
          Animated.timing(flightSpin, {
            toValue: 1,
            duration: 520,
            easing: Easing.out(Easing.cubic),
            useNativeDriver: true,
          }),
          Animated.timing(flightPosition, {
            toValue: { x: target.x - COIN_FLIGHT_SIZE / 2, y: target.y - COIN_FLIGHT_SIZE / 2 },
            duration: 520,
            easing: Easing.inOut(Easing.cubic),
            useNativeDriver: true,
          }),
        ]).start(() => {
          closingRef.current = false;
          onSubmit?.(payload);
        });
      });
    },
    [
      cardAnim,
      closeTintOpacity,
      flightOpacity,
      flightPosition,
      flightScale,
      flightSpin,
      measureCoinAnchor,
      onSubmit,
      resolveSaveTarget,
      resolveSpendTarget,
    ]
  );
  const updateSliderValue = useCallback(
    (value, { force = false, fromUser = false, manualOverride = false } = {}) => {
      if (!manualOverride) {
        setManualExactLocal(null);
      }
      const clamped = Math.max(0, Math.min(1, Number.isFinite(value) ? value : 0));
      sliderValueRef.current = clamped;
      if (force) {
        if (sliderRafRef.current) {
          cancelAnimationFrame(sliderRafRef.current);
          sliderRafRef.current = null;
        }
        pendingSliderValueRef.current = null;
        sliderValueCommitRef.current = clamped;
        setSliderValue(clamped);
        return clamped;
      }
      pendingSliderValueRef.current = clamped;
      if (sliderRafRef.current) {
        return clamped;
      }
      sliderRafRef.current = requestAnimationFrame(() => {
        sliderRafRef.current = null;
        const pending = pendingSliderValueRef.current;
        if (pending === null || pending === undefined) return;
        pendingSliderValueRef.current = null;
        sliderValueCommitRef.current = pending;
        setSliderValue(pending);
      });
      return clamped;
    },
    [setManualExactLocal]
  );
  const openManual = useCallback(
    (mode) => {
      setManualMode(mode);
      setManualError("");
      if (mode === "amount") {
        const formatted = sliderLocalValue > 0 ? formatNumberInputValue(sliderLocalValue) : "";
        setManualValue(formatted);
      } else {
        setManualValue("");
      }
    },
    [sliderLocalValue]
  );
  const closeManual = useCallback(() => {
    setManualMode(null);
    setManualError("");
  }, []);
  const finalizeSliderValue = useCallback(() => {
    const snapped = computeSteppedValue(sliderValueRef.current);
    sliderValueRef.current = snapped;
    updateSliderValue(snapped, { force: true });
  }, [computeSteppedValue, updateSliderValue]);
  const panResponder = useMemo(
    () =>
      PanResponder.create({
        onStartShouldSetPanResponder: () => true,
        onPanResponderGrant: (evt, gesture) => {
          sliderGestureRef.current = {
            axis: "vertical",
          };
          const touchY = evt.nativeEvent?.locationY;
          if (Number.isFinite(touchY)) {
            const nextValue = computeValueFromTouch(touchY);
            const applied = updateSliderValue(nextValue, { force: true, fromUser: true });
            const snapped = computeSteppedValue(applied);
            touchStartValueRef.current = applied;
            hapticStepRef.current = Math.round(snapped * 20);
            triggerSliderTick(computeTickIndex(snapped));
          } else {
            touchStartValueRef.current = sliderValueRef.current;
          }
          touchStartPageYRef.current = Number.isFinite(gesture?.y0) ? gesture.y0 : evt.nativeEvent?.pageY || 0;
          touchStartRef.current = Date.now();
          directionAnim.stopAnimation();
          directionAnim.setValue(0);
        },
        onPanResponderMove: (evt, gesture) => {
          if (tossingRef.current) return;
          if (trackHeight <= 0) return;
          const startY = touchStartPageYRef.current;
          const moveY = Number.isFinite(gesture?.moveY) ? gesture.moveY : evt.nativeEvent?.pageY;
          let nextValue;
          if (Number.isFinite(startY) && Number.isFinite(moveY)) {
            const dy = moveY - startY;
            nextValue = Math.max(0, Math.min(1, touchStartValueRef.current - dy / trackHeight));
          } else {
            const touchY = evt.nativeEvent?.locationY;
            nextValue = computeValueFromTouch(touchY);
          }
          const applied = updateSliderValue(nextValue, { fromUser: true });
          const snapped = computeSteppedValue(applied);
          const nextStep = Math.round(snapped * 20);
          if (nextStep !== hapticStepRef.current) {
            const now = Date.now();
            if (now - sliderHapticCooldownRef.current >= COIN_SLIDER_HAPTIC_COOLDOWN_MS) {
              triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
              sliderHapticCooldownRef.current = now;
            }
            hapticStepRef.current = nextStep;
            triggerSliderTick(computeTickIndex(snapped));
          }
        },
        onPanResponderRelease: (_, gesture) => {
          const elapsed = Date.now() - (touchStartRef.current || 0);
          const isTap =
            Math.abs(gesture.dx) < 6 && Math.abs(gesture.dy) < 6 && elapsed < 200 && !tossingRef.current;
          sliderGestureRef.current = {
            axis: "pending",
          };
          finalizeSliderValue();
          if (isTap) {
            openManual("amount");
          }
        },
        onPanResponderTerminate: () => {
          sliderGestureRef.current = {
            axis: "pending",
          };
          finalizeSliderValue();
        },
      }),
    [
      computeSteppedValue,
      computeValueFromTouch,
      directionAnim,
      finalizeSliderValue,
      openManual,
      trackHeight,
    ]
  );
  const handleManualSave = () => {
    const parsed = parseNumberInputValue(manualValue);
    if (!Number.isFinite(parsed) || parsed <= 0) {
      setManualError(t("coinEntryManualError"));
      return;
    }
    const normalizedLocal = manualIsAmountMode ? parsed : snapCurrencyValue(parsed, currency);
    if (manualIsAmountMode) {
      const parsedUSD = convertFromCurrency(normalizedLocal, currency);
      if (!Number.isFinite(parsedUSD) || parsedUSD <= 0) {
        setManualError(t("coinEntryManualError"));
        return;
      }
      onUpdateMaxUSD?.(parsedUSD);
      updateSliderValue(1, { force: true, fromUser: true, manualOverride: true });
      hapticStepRef.current = 20;
      const manualPrecision = getManualInputPrecision(manualValue);
      setManualExactLocal({
        value: normalizedLocal,
        precision: manualPrecision,
      });
      sliderGestureRef.current = {
        axis: "pending",
      };
      closeManual();
      return;
    }
    const parsedUSD = convertFromCurrency(normalizedLocal, currency);
    if (!Number.isFinite(parsedUSD) || parsedUSD <= 0) {
      setManualError(t("coinEntryManualError"));
      return;
    }
    onUpdateMaxUSD?.(parsedUSD);
    closeManual();
  };
  const categoryLabelKey = getShortLanguageKey(language);
  const categoryChipWidth = useMemo(() => {
    const visibleCount = 3;
    const gap = 10;
    const horizontalPadding = 32;
    const available = SCREEN_WIDTH - horizontalPadding * 2 - gap * (visibleCount - 1);
    return Math.max(96, Math.floor(available / visibleCount));
  }, []);
  const manualTitle = manualIsAmountMode ? t("coinEntryManualAmountTitle") : t("coinEntryManualTitle");
  const manualPlaceholder = manualIsAmountMode
    ? t("coinEntryManualAmountPlaceholder", { amount: sliderAmountLocal })
    : t("coinEntryManualPlaceholder", { amount: sliderMaxLocal });
  const customCategoryMap = useMemo(() => {
    const map = new Map();
    (customCategories || []).forEach((entry) => {
      if (entry?.id) {
        map.set(entry.id, entry);
      }
    });
    return map;
  }, [customCategories]);
  const categoryOrder = useMemo(() => {
    const baseOrder = [...IMPULSE_CATEGORY_ORDER];
    if (customCategories.length) {
      customCategories.forEach((entry) => {
        const id = entry?.id;
        if (id && !baseOrder.includes(id)) {
          baseOrder.push(id);
        }
      });
    }
    const baseIndex = new Map(baseOrder.map((id, index) => [id, index]));
    const recencyMap = categoryRecency instanceof Map ? categoryRecency : null;
    const hasRecency = recencyMap && recencyMap.size > 0;
    const hasStats = !!categoryStats;
    if (!hasRecency && !hasStats) return baseOrder;
    return baseOrder.sort((a, b) => {
      if (hasRecency) {
        const aRecent = recencyMap.get(a) || 0;
        const bRecent = recencyMap.get(b) || 0;
        if (bRecent !== aRecent) return bRecent - aRecent;
      }
      if (hasStats) {
        const aStats = categoryStats[a] || {};
        const bStats = categoryStats[b] || {};
        const aSpend = Number(aStats.spend) || 0;
        const bSpend = Number(bStats.spend) || 0;
        if (bSpend !== aSpend) return bSpend - aSpend;
        const aTotal = aSpend + (Number(aStats.save) || 0);
        const bTotal = bSpend + (Number(bStats.save) || 0);
        if (bTotal !== aTotal) return bTotal - aTotal;
      }
      return (baseIndex.get(a) ?? 0) - (baseIndex.get(b) ?? 0);
    });
  }, [categoryRecency, categoryStats, customCategories]);
  const handleAction = useCallback(
    (direction) => {
      if (tossingRef.current || closingRef.current || dismissingRef.current) return;
      const value = sliderValueRef.current;
      const hasAmount = value >= 0.02;
      if (!hasAmount) {
        triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
        return;
      }
      if (!selectedCategory) {
        setCategoryError(true);
        triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
        return;
      }
      playSound?.("coin");
      const computedAmountUSD = manualExactLocal
        ? convertFromCurrency(manualExactLocal.value, currency)
        : computeAmountUSDForValue(value);
      tossingRef.current = true;
      Animated.timing(directionAnim, {
        toValue: direction === "save" ? 3.2 : -3.2,
        duration: 180,
        easing: Easing.out(Easing.circle),
        useNativeDriver: false,
      }).start(() => {
        tossingRef.current = false;
        directionAnim.setValue(0);
        runSubmitAnimation(direction, {
          amountUSD: computedAmountUSD,
          category: selectedCategory,
          direction,
        });
      });
    },
    [
      computeAmountUSDForValue,
      currency,
      directionAnim,
      manualExactLocal,
      playSound,
      runSubmitAnimation,
      selectedCategory,
    ]
  );
  const handleDismiss = useCallback(() => {
    if (closingRef.current) return;
    runDismissAnimation(onCancel);
  }, [onCancel, runDismissAnimation]);
  const showActionButtons = true;
  return (
    <Modal visible={visible} transparent animationType="none" onRequestClose={handleDismiss} statusBarTranslucent>
      <View style={styles.coinEntryOverlayRoot}>
        <Animated.View
          pointerEvents="none"
          style={[
            styles.coinEntryRevealCircle,
            {
              left: originX - COIN_REVEAL_SIZE / 2,
              top: originY - COIN_REVEAL_SIZE / 2,
              backgroundColor: "rgba(0,0,0,0.55)",
              transform: [{ scale: revealScale }],
            },
          ]}
        />
        <Animated.View
          pointerEvents="none"
          style={[
            styles.coinEntryCloseTint,
            {
              backgroundColor: closeTintColor,
              opacity: closeTintOpacity,
            },
          ]}
        />
        <Animated.View
          pointerEvents="none"
          style={[
            styles.coinEntryFlightCoin,
            {
              opacity: flightOpacity,
              transform: [
                ...flightPosition.getTranslateTransform(),
                { scale: flightScale },
                {
                  rotate: flightSpin.interpolate({
                    inputRange: [0, 1],
                    outputRange: ["0deg", flightDirection === "save" ? "360deg" : "-360deg"],
                  }),
                },
              ],
            },
          ]}
        >
          {!!flightCoinAsset && (
            <Image source={flightCoinAsset} style={styles.coinEntryFlightCoinImage} />
          )}
        </Animated.View>
        <TouchableWithoutFeedback onPress={handleDismiss}>
          <Animated.View style={[styles.coinEntryBackdrop, { opacity: backdropOpacity }]}>
            <TouchableWithoutFeedback onPress={() => {}}>
              <Animated.View
                style={[
                  styles.coinEntryCard,
                  {
                    backgroundColor: colors.card,
                    borderColor: colors.border,
                    opacity: cardOpacity,
                    transform: [{ scale: cardScale }],
                  },
                ]}
              >
              <View style={styles.coinEntryHeader}>
                <View style={{ flex: 1 }}>
                  <Text style={[styles.coinEntryTitle, { color: colors.text }]}>{t("coinEntryTitle")}</Text>
                  <Text style={[styles.coinEntrySubtitle, { color: colors.muted }]}>
                    {t("coinEntrySubtitle")}
                  </Text>
                </View>
                <TouchableOpacity onPress={handleDismiss} style={styles.coinEntryClose}>
                  <Text style={[styles.coinEntryCloseText, { color: colors.muted }]}>âœ•</Text>
                </TouchableOpacity>
              </View>
              <View style={styles.coinEntryAmountRow}>
                <Text style={[styles.coinEntryAmount, { color: colors.text }]}>{sliderAmountLocal}</Text>
              </View>
              <Text style={[styles.coinEntryManualTapHint, { color: colors.muted }]}>
                {t("coinEntryManualTapHint")}
              </Text>
              <View style={styles.coinSliderWrapper}>
                <Animated.View style={[styles.coinSliderBackdrop, { backgroundColor: sliderBackground }]} />
                <Animated.View
                  ref={coinCircleRef}
                  style={[
                    styles.coinCircle,
                    {
                      borderColor: coinHasValue ? "rgba(247,196,93,0.5)" : colors.border,
                      backgroundColor: coinSurfaceOuter,
                      shadowColor: coinHasValue ? "#F7C45D" : "#A0A5B6",
                      transform: [{ translateX: coinTranslateX }],
                    },
                  ]}
                  onLayout={(event) => {
                    const { height } = event.nativeEvent.layout;
                    if (height) setTrackHeight(height);
                  }}
                  {...panResponder.panHandlers}
                >
                  <View
                    style={[
                      styles.coinInnerSurface,
                      { backgroundColor: coinSurfaceInner, borderColor: coinSurfaceBorder },
                    ]}
                  >
                    <View style={styles.coinFillTrack}>
                      <View
                        style={[
                          styles.coinFill,
                          {
                            height: sliderFillHeight,
                            backgroundColor: coinFillColor,
                          },
                        ]}
                      />
                    </View>
                    <View style={[styles.coinShine, { backgroundColor: coinShineColor }]} />
                    <Text
                      style={[
                        styles.coinCurrencySymbol,
                        { color: coinSymbolColor, opacity: coinSymbolOpacity },
                      ]}
                    >
                      {currencySymbol}
                    </Text>
                  </View>
                </Animated.View>
              </View>
              {showActionButtons && (
                <View style={styles.coinEntryActions}>
                  <TouchableOpacity
                    style={[
                      styles.coinEntryActionButton,
                      styles.coinEntryActionButtonSpend,
                      preferredAction === "spend"
                        ? { borderWidth: 2, borderColor: colors.text }
                        : null,
                    ]}
                    onPress={() => handleAction("spend")}
                    activeOpacity={0.85}
                  >
                    <Text style={[styles.coinEntryActionButtonText, styles.coinEntryActionButtonTextSpend]}>
                      {t("spendAction")}
                    </Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[
                      styles.coinEntryActionButton,
                      styles.coinEntryActionButtonSave,
                      preferredAction === "save"
                        ? { borderWidth: 2, borderColor: colors.text }
                        : null,
                    ]}
                    onPress={() => handleAction("save")}
                    activeOpacity={0.85}
                  >
                    <Text style={[styles.coinEntryActionButtonText, styles.coinEntryActionButtonTextSave]}>
                      {t("saveAction")}
                    </Text>
                  </TouchableOpacity>
                </View>
              )}
              <Text style={[styles.coinEntryHint, { color: colors.muted }]}>{t("coinEntryHint")}</Text>
              <Text style={[styles.coinEntryCategoryLabel, { color: colors.text }]}>
                {t("coinEntryCategoryLabel")}
              </Text>
              {categoryError && (
                <Text style={[styles.coinEntryError, { color: SPEND_ACTION_COLOR }]}>
                  {t("coinEntryCategoryError")}
                </Text>
              )}
              <ScrollView
                horizontal
                showsHorizontalScrollIndicator={false}
                style={styles.coinEntryCategoryScroll}
                contentContainerStyle={styles.coinEntryCategoryRow}
              >
                {categoryOrder.map((categoryId) => {
                  const def = IMPULSE_CATEGORY_DEFS[categoryId] || customCategoryMap.get(categoryId);
                  if (!def) return null;
                  const active = selectedCategory === categoryId;
                  const emoji = def.emoji || "âœ¨";
                  const label =
                    def[categoryLabelKey] ||
                    def.en ||
                    def.ru ||
                    def.es ||
                    def.fr ||
                    categoryId;
                  return (
                    <TouchableOpacity
                      key={categoryId}
                      style={[
                        styles.coinEntryCategoryButton,
                        {
                          width: categoryChipWidth,
                          borderColor: active ? colors.text : colors.border,
                          backgroundColor: active ? colors.text : "transparent",
                        },
                      ]}
                      onPress={() => {
                        setSelectedCategory(categoryId);
                        setCategoryError(false);
                      }}
                    >
                      <Text style={styles.coinEntryCategoryEmoji}>{emoji}</Text>
                      <Text
                        style={[
                          styles.coinEntryCategoryText,
                          { color: active ? colors.background : colors.text },
                        ]}
                        numberOfLines={2}
                      >
                        {label}
                      </Text>
                    </TouchableOpacity>
                  );
                })}
              </ScrollView>
              </Animated.View>
            </TouchableWithoutFeedback>
          </Animated.View>
        </TouchableWithoutFeedback>
      </View>
      {manualVisible && (
        <Modal visible transparent animationType="fade" onRequestClose={closeManual}>
          <TouchableWithoutFeedback onPress={closeManual}>
            <View style={styles.coinEntryManualBackdrop}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View
                  style={[
                    styles.coinEntryManualCard,
                    { backgroundColor: colors.card, borderColor: colors.border },
                  ]}
                >
                  <Text style={[styles.coinEntryManualTitle, { color: colors.text }]}>
                    {manualTitle}
                  </Text>
                  <TextInput
                    style={[styles.coinEntryManualInput, { color: colors.text, borderColor: colors.border }]}
                    placeholder={manualPlaceholder}
                    placeholderTextColor={colors.muted}
                    keyboardType="numeric"
                    value={manualValue}
                    onChangeText={setManualValue}
                  />
                  {!!manualError && (
                    <Text style={[styles.coinEntryManualError, { color: SPEND_ACTION_COLOR }]}>{manualError}</Text>
                  )}
                  <View style={styles.coinEntryManualActions}>
                    <TouchableOpacity
                      style={[styles.coinEntryManualButtonGhost, { borderColor: colors.border }]}
                      onPress={closeManual}
                    >
                      <Text style={[styles.coinEntryManualButtonGhostText, { color: colors.muted }]}>
                        {t("coinEntryManualCancel")}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[styles.coinEntryManualButtonPrimary, { backgroundColor: colors.text }]}
                      onPress={handleManualSave}
                    >
                      <Text style={[styles.coinEntryManualButtonPrimaryText, { color: colors.background }]}>
                        {t("coinEntryManualSave")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>
      )}
    </Modal>
  );
}

function SegmentedSlider({
  value,
  options = [],
  onChange,
  colors,
  style = null,
  indicatorStyle = null,
  textStyle = null,
  activeTextStyle = null,
}) {
  const [trackWidth, setTrackWidth] = useState(0);
  const optionCount = options.length;
  const foundIndex = options.findIndex((option) => option.id === value);
  const activeIndex = foundIndex;
  const anim = useRef(new Animated.Value(activeIndex)).current;
  useEffect(() => {
    if (activeIndex < 0) return;
    Animated.spring(anim, {
      toValue: activeIndex,
      useNativeDriver: true,
      damping: 18,
      stiffness: 170,
      mass: 0.8,
    }).start();
  }, [activeIndex, anim]);
  if (!optionCount) return null;
  const innerWidth = trackWidth > 0 ? Math.max(0, trackWidth - 4) : 0;
  const indicatorWidth = innerWidth > 0 ? innerWidth / optionCount : 0;
  const translateX =
    optionCount > 1
      ? anim.interpolate({
          inputRange: [0, optionCount - 1],
          outputRange: [0, indicatorWidth * (optionCount - 1)],
        })
      : anim;
  const hasSelection = activeIndex >= 0;
  return (
    <View
      style={[
        styles.segmentedSlider,
        { borderColor: colors.border, backgroundColor: colorWithAlpha(colors.text, 0.08) },
        style,
      ]}
      onLayout={(event) => {
        const width = event?.nativeEvent?.layout?.width || 0;
        if (!width) return;
        setTrackWidth((prev) => (Math.abs(prev - width) < 1 ? prev : width));
      }}
    >
      {indicatorWidth > 0 && hasSelection && (
        <Animated.View
          style={[
            styles.segmentedSliderIndicator,
            { width: indicatorWidth, backgroundColor: colors.text },
            indicatorStyle,
            { transform: [{ translateX }] },
          ]}
        />
      )}
      {options.map((option) => {
        const isActive = option.id === value;
        return (
          <Pressable
            key={option.id}
            style={styles.segmentedSliderOption}
            onPress={() => onChange?.(option.id)}
          >
            <Text
              style={[
                styles.segmentedSliderOptionText,
                { color: colors.muted },
                textStyle,
                isActive && [styles.segmentedSliderOptionTextActive, { color: colors.background }, activeTextStyle],
              ]}
              numberOfLines={1}
              adjustsFontSizeToFit
              minimumFontScale={0.75}
            >
              {option.label}
            </Text>
          </Pressable>
        );
      })}
    </View>
  );
}

function FrequencyCustomModal({
  visible,
  colors,
  t,
  value,
  onCancel,
  onSave,
  keyboardOffset = 0,
}) {
  const [localValue, setLocalValue] = useState("1");
  const [localUnit, setLocalUnit] = useState("day");
  const [error, setError] = useState("");
  const keyboardPaddingStyle = keyboardOffset ? { paddingBottom: keyboardOffset } : null;
  useEffect(() => {
    if (!visible) return;
    const normalized = normalizeCustomFrequency(value) || { ...DEFAULT_CUSTOM_FREQUENCY };
    setLocalValue(String(normalized.count || 1));
    setLocalUnit(normalized.unit || "day");
    setError("");
  }, [value, visible]);
  const unitOptions = useMemo(
    () =>
      CUSTOM_FREQUENCY_UNITS.map((unit) => ({
        id: unit.id,
        label: t(unit.longKey),
      })),
    [t]
  );
  const handleSave = () => {
    const parsed = Number(String(localValue || "").replace(",", "."));
    if (!Number.isFinite(parsed) || parsed <= 0) {
      setError(t("frequencyCustomInputError"));
      return;
    }
    const normalized = normalizeCustomFrequency({ count: parsed, unit: localUnit });
    if (!normalized) {
      setError(t("frequencyCustomInputError"));
      return;
    }
    setError("");
    onSave?.(normalized);
  };
  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onCancel}
      statusBarTranslucent
    >
      <TouchableWithoutFeedback onPress={onCancel}>
        <View style={[styles.quickModalBackdrop, keyboardPaddingStyle]}>
          <TouchableWithoutFeedback onPress={() => {}}>
            <View
              style={[
                styles.frequencyModalCard,
                { backgroundColor: colors.card, borderColor: colors.border },
              ]}
            >
              <Text style={[styles.frequencyModalTitle, { color: colors.text }]}>
                {t("frequencyCustomTitle")}
              </Text>
              <Text style={[styles.frequencyModalSubtitle, { color: colors.muted }]}>
                {t("frequencyCustomSubtitle")}
              </Text>
              <View style={styles.frequencyModalRow}>
                <View style={styles.frequencyModalInputWrap}>
                  <Text style={[styles.frequencyModalLabel, { color: colors.muted }]}>
                    {t("frequencyCustomEvery")}
                  </Text>
                  <TextInput
                    style={[
                      styles.primaryInput,
                      { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                    ]}
                    placeholder={t("frequencyCustomInputPlaceholder")}
                    placeholderTextColor={colors.muted}
                    keyboardType="number-pad"
                    value={localValue}
                    onChangeText={(text) => setLocalValue(text)}
                  />
                </View>
                <View style={styles.frequencyModalUnitWrap}>
                  <Text style={[styles.frequencyModalLabel, { color: colors.muted }]}>
                    {t("frequencyCustomUnitLabel")}
                  </Text>
                  <SegmentedSlider
                    value={localUnit}
                    options={unitOptions}
                    onChange={(next) => setLocalUnit(next)}
                    colors={colors}
                    style={styles.frequencyModalUnitSlider}
                    textStyle={styles.frequencyModalUnitText}
                  />
                </View>
              </View>
              {!!error && (
                <Text style={[styles.frequencyModalError, { color: SPEND_ACTION_COLOR }]}>{error}</Text>
              )}
              <View style={styles.quickModalActions}>
                <TouchableOpacity
                  style={[styles.quickModalSecondary, { borderColor: colors.border }]}
                  onPress={onCancel}
                >
                  <Text style={[styles.quickModalSecondaryText, { color: colors.muted }]}>
                    {t("frequencyCustomCancel")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
                  onPress={handleSave}
                >
                  <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>
                    {t("frequencyCustomSave")}
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
}

function FrequencyPicker({
  value,
  customValue,
  onValueChange,
  onCustomChange,
  colors,
  t,
  keyboardOffset = 0,
}) {
  const [customModalVisible, setCustomModalVisible] = useState(false);
  const pendingCustomRef = useRef(false);
  const lastNonCustomRef = useRef(value && value !== "custom" ? value : null);
  useEffect(() => {
    if (value && value !== "custom") {
      lastNonCustomRef.current = value;
    }
  }, [value]);
  const options = useMemo(
    () =>
      FREQUENCY_PICKER_OPTIONS.map((option) => ({
        id: option.id,
        label: t(option.labelKey),
      })),
    [t]
  );
  const openCustomModal = (markPending = false) => {
    pendingCustomRef.current = markPending;
    setCustomModalVisible(true);
  };
  const handleFrequencyChange = (next) => {
    const normalized = normalizeFrequencyId(next) || "daily";
    if (normalized === "custom") {
      if (value && value !== "custom") {
        lastNonCustomRef.current = value;
      }
      onValueChange?.("custom");
      openCustomModal(true);
      return;
    }
    pendingCustomRef.current = false;
    onValueChange?.(normalized);
  };
  const handleCustomCancel = () => {
    setCustomModalVisible(false);
    if (pendingCustomRef.current) {
      if (!normalizeCustomFrequency(customValue)) {
        const fallback = lastNonCustomRef.current || null;
        onValueChange?.(fallback);
      }
    }
    pendingCustomRef.current = false;
  };
  const handleCustomSave = (nextCustom) => {
    pendingCustomRef.current = false;
    setCustomModalVisible(false);
    onValueChange?.("custom");
    onCustomChange?.(nextCustom);
  };
  const customSummary = value === "custom" ? formatCustomFrequencySummary(customValue, t) : "";
  return (
    <View style={styles.frequencyPickerWrap}>
      <Text style={[styles.frequencyPickerLabel, { color: colors.muted }]}>
        {t("frequencyPickerLabel")}
      </Text>
      <SegmentedSlider
        value={value}
        options={options}
        onChange={handleFrequencyChange}
        colors={colors}
      />
      {value === "custom" && (
        <View style={styles.frequencyCustomRow}>
          <Text style={[styles.frequencyCustomSummary, { color: colors.text }]}>
            {customSummary || t("frequencyCustomUnset")}
          </Text>
          <TouchableOpacity
            style={[styles.frequencyCustomEdit, { borderColor: colors.border }]}
            onPress={() => openCustomModal(false)}
          >
            <Text style={[styles.frequencyCustomEditText, { color: colors.text }]}>
              {t("frequencyCustomEdit")}
            </Text>
          </TouchableOpacity>
        </View>
      )}
      <FrequencyCustomModal
        visible={customModalVisible}
        colors={colors}
        t={t}
        value={customValue}
        onCancel={handleCustomCancel}
        onSave={handleCustomSave}
        keyboardOffset={keyboardOffset}
      />
    </View>
  );
}

function QuickCustomModal({
  visible,
  colors,
  t,
  currency,
  data,
  onChange,
  onSubmit,
  onCancel,
  language,
  keyboardOffset = 0,
}) {
  const keyboardPaddingStyle = keyboardOffset ? { paddingBottom: keyboardOffset } : null;
  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onCancel}
      statusBarTranslucent
    >
      <TouchableWithoutFeedback onPress={onCancel}>
        <View style={[styles.quickModalBackdrop, keyboardPaddingStyle]}>
          <TouchableWithoutFeedback onPress={() => {}}>
            <View style={[styles.quickModalCard, { backgroundColor: colors.card }] }>
              <Text style={[styles.quickModalTitle, { color: colors.text }]}>{t("quickCustomTitle")}</Text>
              <Text style={[styles.quickModalSubtitle, { color: colors.muted }]}>{t("quickCustomSubtitle")}</Text>
              <View style={{ gap: 12, width: "100%" }}>
                <FrequencyPicker
                  value={data.frequency}
                  customValue={data.customFrequency}
                  onValueChange={(next) => onChange("frequency", next)}
                  onCustomChange={(next) => onChange("customFrequency", next)}
                  colors={colors}
                  t={t}
                  keyboardOffset={keyboardOffset}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("quickCustomNameLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.title}
                  onChangeText={(text) => onChange("title", text)}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("quickCustomAmountLabel", { currency })}
                  placeholderTextColor={colors.muted}
                  keyboardType="decimal-pad"
                  value={data.amount}
                  onChangeText={(text) => onChange("amount", text)}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("quickCustomEmojiLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.emoji || ""}
                  onChangeText={(text) => onChange("emoji", text)}
                  selectTextOnFocus
                  maxLength={2}
                />
                <View style={{ gap: 6 }}>
                  <Text style={[styles.currencyLabel, { color: colors.muted }]}>
                    {t("impulseCategoryLabel")}
                  </Text>
                  <ImpulseCategorySelector
                    value={data.category}
                    onChange={(cat) => onChange("category", cat)}
                    colors={colors}
                    language={language}
                    horizontal
                    visibleCount={3}
                    allowEmpty
                  />
                </View>
              </View>
              <View style={styles.quickModalActions}>
                <TouchableOpacity
                  style={[styles.quickModalSecondary, { borderColor: colors.border }]}
                  onPress={onCancel}
                >
                  <Text style={[styles.quickModalSecondaryText, { color: colors.muted }]}>
                    {t("quickCustomCancel")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
                  onPress={() => onSubmit(data)}
                >
                  <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>
                    {t("quickCustomConfirm")}
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
}

function NewGoalModal({
  visible,
  colors,
  t,
  currency,
  data,
  onChange,
  onSubmit,
  onCancel,
  keyboardOffset = 0,
}) {
  const keyboardPaddingStyle = keyboardOffset ? { paddingBottom: keyboardOffset } : null;
  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onCancel}
      statusBarTranslucent
    >
      <TouchableWithoutFeedback onPress={onCancel}>
        <View style={[styles.quickModalBackdrop, keyboardPaddingStyle]}>
          <TouchableWithoutFeedback onPress={() => {}}>
            <View style={[styles.quickModalCard, { backgroundColor: colors.card }] }>
              <Text style={[styles.quickModalTitle, { color: colors.text }]}>{t("newGoalTitle")}</Text>
              <Text style={[styles.quickModalSubtitle, { color: colors.muted }]}>{t("newGoalSubtitle")}</Text>
              <View style={{ gap: 8, width: "100%" }}>
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newGoalNameLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.name}
                  onChangeText={(text) => onChange("name", text)}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newGoalTargetLabel", { currency })}
                  placeholderTextColor={colors.muted}
                  keyboardType="decimal-pad"
                  value={data.target}
                  onChangeText={(text) => onChange("target", text)}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newGoalEmojiLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.emoji || ""}
                  onChangeText={(text) => onChange("emoji", text)}
                  selectTextOnFocus
                  maxLength={2}
                />
              </View>
              <View style={styles.quickModalActions}>
                <TouchableOpacity
                  style={[styles.quickModalSecondary, { borderColor: colors.border }]}
                  onPress={onCancel}
                >
                  <Text style={[styles.quickModalSecondaryText, { color: colors.muted }]}>
                    {t("newGoalCancel")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
                  onPress={onSubmit}
                >
                  <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>
                    {t("newGoalCreate")}
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
}

function NewPendingModal({
  visible,
  colors,
  t,
  currency,
  data,
  onChange,
  onSubmit,
  onCancel,
  keyboardOffset = 0,
}) {
  const keyboardPaddingStyle = keyboardOffset ? { paddingBottom: keyboardOffset } : null;
  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onCancel}
      statusBarTranslucent
    >
      <TouchableWithoutFeedback onPress={onCancel}>
        <View style={[styles.quickModalBackdrop, keyboardPaddingStyle]}>
          <TouchableWithoutFeedback onPress={() => {}}>
            <View style={[styles.quickModalCard, { backgroundColor: colors.card }] }>
              <Text style={[styles.quickModalTitle, { color: colors.text }]}>{t("newPendingTitle")}</Text>
              <Text style={[styles.quickModalSubtitle, { color: colors.muted }]}>{t("newPendingSubtitle")}</Text>
              <View style={{ gap: 8, width: "100%" }}>
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newPendingNameLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.title}
                  onChangeText={(text) => onChange("title", text)}
                  returnKeyType="done"
                  blurOnSubmit
                  onSubmitEditing={Keyboard.dismiss}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newPendingAmountLabel", { currency })}
                  placeholderTextColor={colors.muted}
                  keyboardType="decimal-pad"
                  value={data.amount}
                  onChangeText={(text) => onChange("amount", text)}
                  returnKeyType="done"
                  blurOnSubmit
                  onSubmitEditing={Keyboard.dismiss}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newPendingEmojiLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.emoji || ""}
                  onChangeText={(text) => onChange("emoji", text)}
                  selectTextOnFocus
                  maxLength={2}
                  returnKeyType="done"
                  blurOnSubmit
                  onSubmitEditing={Keyboard.dismiss}
                />
              </View>
              <View style={styles.quickModalActions}>
                <TouchableOpacity
                  style={[styles.quickModalSecondary, { borderColor: colors.border }]}
                  onPress={onCancel}
                >
                  <Text style={[styles.quickModalSecondaryText, { color: colors.muted }]}>
                    {t("newPendingCancel")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
                  onPress={onSubmit}
                >
                  <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>
                    {t("newPendingCreate")}
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
}

function OnboardingGoalModal({
  visible,
  colors,
  t,
  currency,
  data,
  onChange,
  onSubmit,
  onCancel,
  keyboardOffset = 0,
}) {
  const keyboardPaddingStyle = keyboardOffset ? { paddingBottom: keyboardOffset } : null;
  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onCancel}
      statusBarTranslucent
    >
      <TouchableWithoutFeedback onPress={onCancel}>
        <View style={[styles.quickModalBackdrop, keyboardPaddingStyle]}>
          <TouchableWithoutFeedback onPress={() => {}}>
            <View style={[styles.quickModalCard, { backgroundColor: colors.card }] }>
              <Text style={[styles.quickModalTitle, { color: colors.text }]}>{t("newGoalTitle")}</Text>
              <Text style={[styles.quickModalSubtitle, { color: colors.muted }]}>{t("newGoalSubtitle")}</Text>
              <View style={{ gap: 8, width: "100%" }}>
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newGoalNameLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.name}
                  onChangeText={(text) => onChange("name", text)}
                  returnKeyType="done"
                  blurOnSubmit
                  onSubmitEditing={Keyboard.dismiss}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newGoalTargetLabel", { currency })}
                  placeholderTextColor={colors.muted}
                  keyboardType="decimal-pad"
                  value={data.target}
                  onChangeText={(text) => onChange("target", text)}
                  returnKeyType="done"
                  blurOnSubmit
                  onSubmitEditing={Keyboard.dismiss}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newGoalEmojiLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.emoji || ""}
                  onChangeText={(text) => onChange("emoji", text)}
                  selectTextOnFocus
                  maxLength={2}
                  returnKeyType="done"
                  blurOnSubmit
                  onSubmitEditing={Keyboard.dismiss}
                />
              </View>
              <View style={styles.quickModalActions}>
                <TouchableOpacity
                  style={[styles.quickModalSecondary, { borderColor: colors.border }]}
                  onPress={onCancel}
                >
                  <Text style={[styles.quickModalSecondaryText, { color: colors.muted }]}>
                    {t("newGoalCancel")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
                  onPress={onSubmit}
                >
                  <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>
                    {t("goalCustomCreate")}
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
}

function CustomSpendSavingsModal({
  visible,
  colors,
  t,
  title,
  lowLabel,
  highLabel,
  onContinue,
}) {
  const resolvedTitle = (title || "").trim() || t("customSpendTitle");
  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onContinue}
      statusBarTranslucent
    >
      <View style={styles.quickModalBackdrop}>
        {visible && (
          <ConfettiCannon
            count={50}
            origin={{ x: SCREEN_WIDTH / 2, y: -20 }}
            fallSpeed={2800}
            fadeOut
          />
        )}
        <View style={[styles.quickModalCard, { backgroundColor: colors.card }]}>
          <View style={styles.savingsModalHero}>
            <View style={styles.savingsModalBadge}>
              <Text style={styles.savingsModalBadgeText}>ðŸŽ‰</Text>
            </View>
            <Text style={[styles.quickModalTitle, { color: colors.text }]}>
              {t("customSpendSavingsTitle")}
            </Text>
          </View>
          <View style={[styles.savingsModalRange, { backgroundColor: colors.background }]}>
            <Text style={[styles.savingsModalRangeText, { color: colors.text }]}>
              {lowLabel} - {highLabel}
            </Text>
          </View>
          <Text style={[styles.quickModalSubtitle, { color: colors.muted }]}>
            {t("customSpendSavingsBody", {
              title: resolvedTitle,
              low: lowLabel,
              high: highLabel,
            })}
          </Text>
          <Text style={[styles.quickModalHint, { color: colors.muted }]}>
            {t("customSpendSavingsHint")}
          </Text>
          <Text style={[styles.quickModalDisclaimer, { color: colors.text }]}>
            {t("customSpendSavingsDisclaimer")}
          </Text>
          <View style={styles.quickModalActions}>
            <TouchableOpacity
              style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
              onPress={onContinue}
            >
              <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>
                {t("customSpendSavingsCta")}
              </Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
}

function TermsModal({ visible, colors, t, language, onAccept, onCancel, onOpenLink }) {
  const normalizedLanguage = normalizeLanguage(language);
  const points = TERMS_POINTS[normalizedLanguage] || TERMS_POINTS.en;
  return (
    <Modal visible={visible} transparent animationType="fade" statusBarTranslucent onRequestClose={onCancel}>
      <View style={styles.quickModalBackdrop}>
        <View style={[styles.termsCard, { backgroundColor: colors.card }]}>
          <Text style={[styles.termsTitle, { color: colors.text }]}>{t("termsTitle")}</Text>
          <Text style={[styles.termsSubtitle, { color: colors.muted }]}>{t("termsSubtitle")}</Text>
          <ScrollView
            style={styles.termsScroll}
            contentContainerStyle={styles.termsScrollContent}
            showsVerticalScrollIndicator={false}
          >
            {points.map((point, index) => (
              <View key={`${index}-${language}`} style={styles.termsPoint}>
                <Text style={[styles.termsPointIndex, { color: colors.muted }]}>{index + 1}.</Text>
                <Text style={[styles.termsPointText, { color: colors.text }]}>{point}</Text>
              </View>
            ))}
          </ScrollView>
          <TouchableOpacity
            style={[styles.termsLinkButton, { borderColor: colors.border }]}
            onPress={onOpenLink}
          >
            <Text style={[styles.termsLinkText, { color: colors.text }]}>{t("termsViewFull")}</Text>
          </TouchableOpacity>
          <Text style={[styles.termsHint, { color: colors.muted }]}>{t("termsLinkHint")}</Text>
          <View style={styles.quickModalActions}>
            <TouchableOpacity
              style={[styles.quickModalSecondary, { borderColor: colors.border }]}
              onPress={onCancel}
            >
              <Text style={[styles.quickModalSecondaryText, { color: colors.muted }]}>{t("termsDecline")}</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
              onPress={onAccept}
            >
              <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>{t("termsAccept")}</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
}

function addBottomInsetStyle(baseStyle, inset) {
  const safeInset = Math.max(0, Number(inset) || 0);
  if (!safeInset) return null;
  const basePadding = StyleSheet.flatten(baseStyle)?.paddingBottom || 0;
  return { paddingBottom: basePadding + safeInset };
}

function addBottomOffsetStyle(baseStyle, inset) {
  const safeInset = Math.max(0, Number(inset) || 0);
  if (!safeInset) return null;
  const baseBottom = StyleSheet.flatten(baseStyle)?.bottom || 0;
  return { bottom: baseBottom + safeInset };
}

function OnboardingBackButton({ onPress, colors, t }) {
  if (!onPress) return null;
  return (
    <TouchableOpacity
      style={[styles.onboardBackButton, { borderColor: colors.border }]}
      onPress={onPress}
      hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
    >
      <Text style={[styles.onboardBackIcon, { color: colors.text }]}>â†</Text>
      <Text style={[styles.onboardBackLabel, { color: colors.text }]}>{t("onboardingBack")}</Text>
    </TouchableOpacity>
  );
}

function OnboardingSkipButton({ onPress, t }) {
  if (!onPress) return null;
  return (
    <TouchableOpacity
      style={styles.onboardSkipButton}
      onPress={onPress}
      hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
    >
      <Text style={styles.onboardSkipLabel}>{t("onboardingSkip")}</Text>
    </TouchableOpacity>
  );
}

function OnboardingHeaderAction({ label, onPress, colors }) {
  if (!onPress) return null;
  return (
    <TouchableOpacity
      style={[styles.onboardHeaderCta, { backgroundColor: colors.text }]}
      onPress={onPress}
      hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
    >
      <Text style={[styles.onboardHeaderCtaText, { color: colors.background }]}>{label}</Text>
    </TouchableOpacity>
  );
}

function OnboardingHeader({ onBack, onSkip, rightAction, colors, t }) {
  if (!onBack && !onSkip && !rightAction) return null;
  return (
    <View style={styles.onboardHeaderRow}>
      <OnboardingBackButton onPress={onBack} colors={colors} t={t} />
      {rightAction || <OnboardingSkipButton onPress={onSkip} t={t} />}
    </View>
  );
}

function HowItWorksScreen({
  colors,
  t,
  onContinue,
  onBack,
  onSkip,
  bottomInset = 0,
  mascotSpeakSource,
}) {
  const fade = useFadeIn();
  const bottomInsetStyle = addBottomInsetStyle(
    [styles.onboardContent, styles.onboardGuideContent],
    bottomInset
  );
  const swapActions = IS_SHORT_DEVICE && typeof onSkip === "function";
  const headerAction = swapActions ? (
    <OnboardingHeaderAction label={t("onboardingGuideButton")} onPress={onContinue} colors={colors} />
  ) : null;
  const speakingSource =
    mascotSpeakSource || CLASSIC_TAMAGOTCHI_ANIMATIONS.speak || CLASSIC_TAMAGOTCHI_ANIMATIONS.happy;
  const heroLayoutStyle = [styles.onboardGuideHero, IS_SHORT_DEVICE && styles.onboardGuideHeroStacked];
  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView
        contentContainerStyle={[styles.onboardContent, styles.onboardGuideContent, bottomInsetStyle]}
        showsVerticalScrollIndicator={false}
      >
        <OnboardingHeader
          onBack={onBack}
          onSkip={swapActions ? null : onSkip}
          rightAction={headerAction}
          colors={colors}
          t={t}
        />
        <View style={heroLayoutStyle}>
          <View
            style={[
              styles.onboardGuideMascotWrap,
              { backgroundColor: colors.card, borderColor: colors.border },
            ]}
          >
            <Image source={speakingSource} style={styles.onboardGuideMascot} />
          </View>
          <View style={styles.onboardGuideBubbleWrap}>
            <View
              style={[
                styles.onboardGuideBubble,
                { backgroundColor: colors.card, borderColor: colors.border },
              ]}
            >
              <Text style={[styles.onboardGuideBubbleText, { color: colors.text }]}>
                {t("onboardingGuideTitle")}
              </Text>
              <View
                style={[
                  styles.onboardGuideBubbleTail,
                  { backgroundColor: colors.card, borderColor: colors.border },
                ]}
              />
            </View>
          </View>
        </View>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("onboardingGuideSubtitle")}</Text>
        <View style={styles.guideCards}>
          {HOW_IT_WORKS_STEPS.map((step) => (
            <View
              key={step.id}
              style={[
                styles.guideCard,
                {
                  backgroundColor: colors.card,
                  borderColor: colors.border,
                },
              ]}
            >
              <View style={styles.guideTitleRow}>
                <Text style={styles.guideEmojiInline}>{step.emoji}</Text>
                <Text style={[styles.guideTitle, { color: colors.text }]} numberOfLines={1}>
                  {t(step.titleKey)}
                </Text>
              </View>
              <Text style={[styles.guideDesc, { color: colors.muted }]}>{t(step.descKey)}</Text>
            </View>
          ))}
        </View>
        {swapActions ? (
          <TouchableOpacity style={styles.secondaryButtonClear} onPress={onSkip}>
            <Text style={[styles.secondaryButtonClearText, { color: colors.muted }]}>{t("onboardingSkip")}</Text>
          </TouchableOpacity>
        ) : (
          <TouchableOpacity
            style={[styles.primaryButton, { backgroundColor: colors.text }]}
            onPress={onContinue}
          >
            <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("onboardingGuideButton")}</Text>
          </TouchableOpacity>
        )}
      </ScrollView>
    </Animated.View>
  );
}
function LanguageScreen({
  colors,
  t,
  selectedLanguage,
  selectedCurrency,
  onLanguageChange,
  onCurrencyChange,
  onContinue,
  onBack,
  onShowTerms,
  termsAccepted,
  mascotWaveSource,
  bottomInset = 0,
}) {
  const fade = useFadeIn();
  const wavingSource = mascotWaveSource || CLASSIC_TAMAGOTCHI_ANIMATIONS.waving;
  const bottomInsetStyle = addBottomInsetStyle(styles.onboardContent, bottomInset);
  const [currencyIndicatorVisible, setCurrencyIndicatorVisible] = useState(true);
  const currencyScrollRef = useRef(null);
  const currencyNudgeRan = useRef(false);
  const [shouldAnimateCurrencyNudge, setShouldAnimateCurrencyNudge] = useState(false);
  const handleCurrencyScroll = useCallback(
    (event) => {
      const { contentOffset, contentSize, layoutMeasurement } = event.nativeEvent;
      const scrollable = contentSize.width > layoutMeasurement.width + 4;
      if (!scrollable) {
        setCurrencyIndicatorVisible(false);
        return;
      }
      const atEnd = contentOffset.x + layoutMeasurement.width >= contentSize.width - 8;
      setCurrencyIndicatorVisible(!atEnd);
    },
    [setCurrencyIndicatorVisible]
  );
  useEffect(() => {
    let cancelled = false;
    AsyncStorage.getItem(STORAGE_KEYS.LANGUAGE_CURRENCY_NUDGE)
      .then((value) => {
        if (!cancelled && !value) setShouldAnimateCurrencyNudge(true);
      })
      .catch(() => {});
    return () => {
      cancelled = true;
    };
  }, []);
  useEffect(() => {
    if (!shouldAnimateCurrencyNudge || currencyNudgeRan.current) return undefined;
    currencyNudgeRan.current = true;
    let backTimeout;
    const forwardTimeout = setTimeout(() => {
      currencyScrollRef.current?.scrollTo({ x: 48, animated: true });
      backTimeout = setTimeout(() => {
        currencyScrollRef.current?.scrollTo({ x: 0, animated: true });
      }, 650);
    }, 900);
    AsyncStorage.setItem(STORAGE_KEYS.LANGUAGE_CURRENCY_NUDGE, "1").catch(() => {});
    return () => {
      clearTimeout(forwardTimeout);
      if (backTimeout) clearTimeout(backTimeout);
    };
  }, [shouldAnimateCurrencyNudge]);
  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView
        contentContainerStyle={[styles.onboardContent, bottomInsetStyle]}
        showsVerticalScrollIndicator={false}
      >
        <OnboardingBackButton onPress={onBack} colors={colors} t={t} />
        <Image source={wavingSource} style={styles.languageMascot} />
        <Text style={[styles.onboardTitleCompact, { color: colors.text }]}>{t("languageTitle")}</Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("languageSubtitle")}</Text>
        <View style={styles.languageButtons}>
          {SUPPORTED_LANGUAGES.map((langKey) => {
            const label = LANGUAGE_NATIVE_LABELS[langKey] || langKey.toUpperCase();
            const active = selectedLanguage === langKey;
            return (
              <TouchableOpacity
                key={langKey}
                style={[
                  styles.languageButton,
                  {
                    borderColor: colors.border,
                    backgroundColor: active ? colors.text : "transparent",
                  },
                ]}
                onPress={() => onLanguageChange?.(langKey)}
              >
                <Text style={{ color: active ? colors.background : colors.text, fontWeight: "700" }}>
                  {label}
                </Text>
              </TouchableOpacity>
            );
          })}
        </View>
        <View style={{ width: "100%", marginTop: 20 }}>
          <Text style={[styles.currencyLabel, { color: colors.muted }]}>
            {t("currencyLabel")} <Text style={{ fontSize: 16 }}>â†’</Text>
          </Text>
          <View style={styles.currencyScrollWrapper}>
            <ScrollView
              ref={currencyScrollRef}
              horizontal
              showsHorizontalScrollIndicator={false}
              style={styles.currencyScroll}
              contentContainerStyle={styles.currencyScrollContent}
              onScroll={handleCurrencyScroll}
              scrollEventThrottle={16}
            >
              {CURRENCIES.map((currency) => {
                const active = currency === selectedCurrency;
                return (
                  <TouchableOpacity
                    key={currency}
                    style={[
                      styles.currencyChipLarge,
                      {
                        backgroundColor: active ? colors.text : "transparent",
                        borderColor: colors.border,
                      },
                    ]}
                    onPress={() => onCurrencyChange?.(currency)}
                  >
                    <Text
                      style={{
                        color: active ? colors.background : colors.text,
                        fontWeight: "600",
                      }}
                    >
                      {currency}
                    </Text>
                  </TouchableOpacity>
                );
              })}
            </ScrollView>
            {currencyIndicatorVisible && (
              <View pointerEvents="none" style={styles.currencyScrollFadeWrapper}>
                <Svg style={styles.currencyScrollFade} width="100%" height="100%">
                  <Defs>
                    <SvgLinearGradient id="currencyFade" x1="0" y1="0" x2="1" y2="0">
                      <SvgStop offset="0%" stopColor={colors.background} stopOpacity="0" />
                      <SvgStop offset="100%" stopColor={colors.background} stopOpacity="1" />
                    </SvgLinearGradient>
                  </Defs>
                  <SvgRect x="0" y="0" width="100%" height="100%" fill="url(#currencyFade)" />
                </Svg>
              </View>
            )}
          </View>
          <Text style={[styles.languageHint, { color: colors.muted }]}>{t("languageCurrencyHint")}</Text>
        </View>
        <TouchableOpacity
          style={[styles.primaryButton, { backgroundColor: colors.text, marginTop: 20 }]}
          onPress={onContinue}
        >
          <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("nextButton")}</Text>
        </TouchableOpacity>
        <View style={styles.languageTermsBlock}>
          <Text style={[styles.languageTermsNote, { color: colors.muted }]}>
            {termsAccepted ? t("languageTermsAccepted") : t("languageTermsHint")}
          </Text>
          <TouchableOpacity
            style={[styles.languageTermsButton, { borderColor: colors.border }]}
            onPress={() => onShowTerms?.()}
          >
            <Text style={[styles.languageTermsButtonText, { color: colors.text }]}>{t("languageTermsLink")}</Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </Animated.View>
  );
}

function LogoSplash({ onDone }) {
  const [text, setText] = useState("");
  const onDoneRef = useRef(onDone);
  const animationIdRef = useRef(0);
  const completedRef = useRef(false);
  useEffect(() => {
    onDoneRef.current = onDone;
  }, [onDone]);
  const handleLayout = useCallback(() => {
    SplashScreen.hideAsync().catch(() => {});
  }, []);
  useEffect(() => {
    const word = "Almost";
    const animationId = animationIdRef.current + 1;
    animationIdRef.current = animationId;
    completedRef.current = false;
    setText("");
    let index = 0;
    let stepTimer = null;
    let doneTimer = null;
    const step = () => {
      if (animationIdRef.current !== animationId || completedRef.current) return;
      index += 1;
      setText(word.slice(0, index));
      if (index >= word.length) {
        completedRef.current = true;
        doneTimer = setTimeout(() => {
          if (animationIdRef.current !== animationId) return;
          onDoneRef.current?.();
        }, 600);
        return;
      }
      stepTimer = setTimeout(step, 140);
    };
    stepTimer = setTimeout(step, 140);
    return () => {
      if (stepTimer) clearTimeout(stepTimer);
      if (doneTimer) clearTimeout(doneTimer);
    };
  }, []);

  return (
    <View style={styles.logoSplash} onLayout={handleLayout}>
      <Text style={styles.logoSplashText}>{text}</Text>
    </View>
  );
}
const LevelUpCelebration = ({ colors, message, t, onSharePress }) => {
  const isDarkMode = colors.background === THEMES.dark.background;
  const levelNumber = Math.max(1, Number(message) || 1);
  const entryAnim = useRef(new Animated.Value(0)).current;
  const auraAnim = useRef(new Animated.Value(0)).current;
  const badgeFloatAnim = useRef(new Animated.Value(0)).current;
  useEffect(() => {
    entryAnim.setValue(0);
    auraAnim.setValue(0);
    badgeFloatAnim.setValue(0);
    const entry = Animated.spring(entryAnim, {
      toValue: 1,
      damping: 18,
      stiffness: 210,
      mass: 0.95,
      useNativeDriver: true,
    });
    const auraPulse = Animated.loop(
      Animated.sequence([
        Animated.timing(auraAnim, {
          toValue: 1,
          duration: 1900,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(auraAnim, {
          toValue: 0,
          duration: 1900,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    const badgeFloat = Animated.loop(
      Animated.sequence([
        Animated.timing(badgeFloatAnim, {
          toValue: 1,
          duration: 1700,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(badgeFloatAnim, {
          toValue: 0,
          duration: 1700,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    entry.start();
    auraPulse.start();
    badgeFloat.start();
    return () => {
      entry.stop();
      auraPulse.stop();
      badgeFloat.stop();
    };
  }, [auraAnim, badgeFloatAnim, entryAnim]);
  const coins = useMemo(
    () =>
      Array.from({ length: 28 }).map((_, index) => ({
        id: `level_coin_${index}`,
        delay: Math.random() * 420,
        left: Math.random() * SCREEN_WIDTH,
        size: 14 + Math.random() * 20,
        duration: 1450 + Math.random() * 650,
      })),
    []
  );
  const cardTranslateY = entryAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [36, 0],
  });
  const cardScale = entryAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0.92, 1],
  });
  const auraScale = auraAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0.9, 1.16],
  });
  const auraOpacity = auraAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0.42, 0.78],
  });
  const badgeFloatY = badgeFloatAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0, -6],
  });
  const palette = isDarkMode
    ? {
        backdrop: "rgba(4,9,20,0.9)",
        card: "rgba(13,22,40,0.92)",
        border: "rgba(122,188,255,0.36)",
        title: "#ECF6FF",
        subtitle: "rgba(224,241,255,0.9)",
        badgeBg: "rgba(111,176,255,0.24)",
        badgeBorder: "rgba(125,191,255,0.44)",
        badgeText: "#BDE2FF",
        auraPrimary: "rgba(112,177,255,0.45)",
        auraSecondary: "rgba(136,255,218,0.36)",
        previewTrack: "rgba(255,255,255,0.1)",
        previewFill: "#7BC2FF",
        shareBg: "#7BC2FF",
        shareText: "#051325",
      }
    : {
        backdrop: "rgba(241,247,255,0.92)",
        card: "rgba(255,255,255,0.96)",
        border: "rgba(93,162,255,0.34)",
        title: "#122138",
        subtitle: "rgba(18,33,56,0.78)",
        badgeBg: "rgba(88,157,255,0.14)",
        badgeBorder: "rgba(88,157,255,0.28)",
        badgeText: "#2856A6",
        auraPrimary: "rgba(111,178,255,0.46)",
        auraSecondary: "rgba(102,225,195,0.36)",
        previewTrack: "rgba(18,33,56,0.12)",
        previewFill: "#4E8DFF",
        shareBg: "#122138",
        shareText: "#FFFFFF",
      };
  const previewBars = [
    0.28 + ((levelNumber + 1) % 4) * 0.08,
    0.44 + ((levelNumber + 2) % 4) * 0.08,
    0.6 + ((levelNumber + 3) % 4) * 0.08,
    0.76 + ((levelNumber + 4) % 4) * 0.06,
  ];
  return (
    <View style={styles.levelOverlay} pointerEvents="box-none">
      <View style={[styles.levelBackdrop, { backgroundColor: palette.backdrop }]} />
      <Animated.View
        pointerEvents="none"
        style={[
          styles.levelAura,
          {
            backgroundColor: palette.auraPrimary,
            opacity: auraOpacity,
            transform: [{ scale: auraScale }],
          },
        ]}
      />
      <Animated.View
        pointerEvents="none"
        style={[
          styles.levelAura,
          styles.levelAuraSecondary,
          {
            backgroundColor: palette.auraSecondary,
            opacity: auraOpacity,
            transform: [{ scale: auraScale }],
          },
        ]}
      />
      <Animated.View
        style={[
          styles.levelContent,
          {
            backgroundColor: palette.card,
            borderColor: palette.border,
            opacity: entryAnim,
            transform: [{ translateY: cardTranslateY }, { scale: cardScale }],
          },
        ]}
      >
        <View style={styles.levelHeroRow}>
          <Animated.View
            style={[
              styles.levelBadge,
              {
                backgroundColor: palette.badgeBg,
                borderColor: palette.badgeBorder,
                transform: [{ translateY: badgeFloatY }],
              },
            ]}
          >
            <Text style={[styles.levelBadgeText, { color: palette.badgeText }]}>LEVEL {levelNumber}</Text>
          </Animated.View>
          <Animated.Image
            source={LEVEL_SHARE_CAT}
            style={[styles.levelHeroCat, { transform: [{ translateY: badgeFloatY }] }]}
            resizeMode="contain"
          />
        </View>
        <Text style={[styles.levelTitle, { color: palette.title }]}>
          {t("progressHeroLevel", { level: levelNumber })}
        </Text>
        <Text style={[styles.levelSubtitle, { color: palette.subtitle }]}>
          {t("levelCelebrate", { level: levelNumber })}
        </Text>
        <View style={styles.levelProgressPreview}>
          {previewBars.map((value, index) => (
            <View key={`level_preview_${index}`} style={styles.levelProgressRow}>
              <View style={[styles.levelProgressTrack, { backgroundColor: palette.previewTrack }]}>
                <View
                  style={[
                    styles.levelProgressFill,
                    {
                      width: `${Math.min(100, Math.max(20, Math.round(value * 100)))}%`,
                      backgroundColor: palette.previewFill,
                    },
                  ]}
                />
              </View>
            </View>
          ))}
        </View>
        {onSharePress ? (
          <TouchableOpacity
            style={[styles.levelShareButton, { backgroundColor: palette.shareBg }]}
            activeOpacity={0.92}
            onPress={() => onSharePress(levelNumber)}
          >
            <Text style={[styles.levelShareButtonText, { color: palette.shareText }]}>
              {t("levelShareButton")}
            </Text>
          </TouchableOpacity>
        ) : null}
      </Animated.View>
      {coins.map((coin) => (
        <FallingCoin key={coin.id} {...coin} />
      ))}
    </View>
  );
};

const FallingCoin = ({ left, size, delay, duration }) => {
  const progress = useRef(new Animated.Value(0)).current;
  useEffect(() => {
    const animation = Animated.sequence([
      Animated.delay(delay),
      Animated.timing(progress, {
        toValue: 1,
        duration,
        easing: Easing.in(Easing.quad),
        useNativeDriver: true,
      }),
    ]);
    animation.start();
    return () => animation.stop();
  }, [delay, duration, progress]);

  const translateY = progress.interpolate({
    inputRange: [0, 1],
    outputRange: [-80, Dimensions.get("window").height],
  });
  const rotate = progress.interpolate({
    inputRange: [0, 1],
    outputRange: ["-40deg", "40deg"],
  });
  const opacity = progress.interpolate({
    inputRange: [0, 0.1, 0.9, 1],
    outputRange: [0, 1, 1, 0],
  });

  return (
    <Animated.View
      pointerEvents="none"
      style={[
        styles.levelCoin,
        {
          width: size,
          height: size,
          left,
          opacity,
          transform: [{ translateY }, { rotate }],
        },
      ]}
    />
  );
};

const getRandomFinancialQuote = (language) => {
  const normalized = normalizeLanguage(language);
  const pool = FINANCIAL_QUOTES.map((entry) => entry[normalized] || entry.en).filter(Boolean);
  if (!pool.length) return "";
  return pool[Math.floor(Math.random() * pool.length)];
};

const getSaveProgressCopy = (language) => {
  const normalized = normalizeLanguage(language);
  const map = {
    ru: "Ð”Ð¾ Ñ†ÐµÐ»Ð¸",
    en: "Closer to goal",
    es: "MÃ¡s cerca de la meta",
    fr: "Plus prÃ¨s de l'objectif",
  };
  return map[normalized] || map.en;
};

const getSaveCountdownTitle = (language) => {
  const normalized = normalizeLanguage(language);
  const map = {
    ru: "Ð¡ÐºÐ¾Ð»ÑŒÐºÐ¾ Ð¾ÑÑ‚Ð°Ð»Ð¾ÑÑŒ Ð´Ð¾ Ñ†ÐµÐ»Ð¸",
    en: "Steps left to reach it",
    es: "Lo que falta para llegar",
    fr: "Combien reste-t-il",
  };
  return map[normalized] || map.en;
};

const getSaveCountdownCopy = (language, count) => {
  const normalized = normalizeLanguage(language);
  const safeCount = Math.max(0, Number(count) || 0);
  if (safeCount <= 0) {
    const doneMap = {
      ru: "Ð¦ÐµÐ»ÑŒ Ð¿Ð¾Ñ‡Ñ‚Ð¸ Ð´Ð¾ÑÑ‚Ð¸Ð³Ð½ÑƒÑ‚Ð°!",
      en: "Goal is within reach!",
      es: "La meta estÃ¡ al alcance.",
      fr: "L'objectif est tout proche !",
    };
    return doneMap[normalized] || doneMap.en;
  }
  if (normalized === "ru") {
    const suffix =
      safeCount % 10 === 1 && safeCount % 100 !== 11
        ? "Ð¿Ð¾ÑÑ‚ÑƒÐ¿Ð¾Ðº"
        : safeCount % 10 >= 2 && safeCount % 10 <= 4 && (safeCount % 100 < 10 || safeCount % 100 >= 20)
        ? "Ð¿Ð¾ÑÑ‚ÑƒÐ¿ÐºÐ°"
        : "Ð¿Ð¾ÑÑ‚ÑƒÐ¿ÐºÐ¾Ð²";
    return `Ð•Ñ‰Ñ‘ ${safeCount} ${suffix} Ð´Ð¾ Ñ†ÐµÐ»Ð¸`;
  }
  const map = {
    en: `${safeCount} more actions like this to reach your goal`,
    es: `Quedan ${safeCount} pasos como este hasta la meta`,
    fr: `Encore ${safeCount} actions comme celle-ci pour la cible`,
  };
  return map[normalized] || map.en;
};

const buildSaveCountdownSlots = (count, language) => {
  const rawCount = Number(count);
  const safeCount = Number.isFinite(rawCount) ? Math.max(0, rawCount) : 0;
  const formattedLocale = getFormatLocale(language) || "en-US";
  let formattedValue;
  if (safeCount >= 1000) {
    try {
      formattedValue =
        typeof safeCount.toLocaleString === "function"
          ? safeCount.toLocaleString(formattedLocale)
          : `${safeCount}`;
    } catch (error) {
      formattedValue = `${safeCount}`;
    }
  } else {
    formattedValue = safeCount.toString().padStart(3, "0");
  }
  formattedValue = String(formattedValue).replace(/\u202F/g, " ").replace(/\u00A0/g, " ");
  return formattedValue.split("").map((char, index) => {
    if (/[0-9]/.test(char)) {
      return { type: "digit", value: Number(char), key: `digit_${index}_${char}` };
    }
    if (char === " ") {
      return { type: "space", value: char, key: `space_${index}` };
    }
    return { type: "separator", value: char, key: `separator_${index}_${char}` };
  });
};

const buildUsageStreakCounterSlots = (count, language) => {
  const rawCount = Number(count);
  const safeCount = Number.isFinite(rawCount) ? Math.max(0, rawCount) : 0;
  const formattedLocale = getFormatLocale(language) || "en-US";
  let formattedValue = safeCount >= 1000 ? safeCount.toLocaleString(formattedLocale) : `${safeCount}`;
  formattedValue = String(formattedValue).replace(/\u202F/g, " ").replace(/\u00A0/g, " ");
  return formattedValue.split("").map((char, index) => {
    if (/[0-9]/.test(char)) {
      return { type: "digit", value: Number(char), key: `streak_digit_${index}_${char}` };
    }
    return { type: "separator", value: char, key: `streak_separator_${index}_${char}` };
  });
};

const getGoalQuoteMarks = (language) => {
  const normalized = normalizeLanguage(language);
  switch (normalized) {
    case "ru":
    case "fr":
    case "es":
      return ["Â«", "Â»"];
    default:
      return ["â€œ", "â€"];
  }
};

const clampProgress = (value) => {
  if (!Number.isFinite(value)) return 0;
  if (value < 0) return 0;
  if (value > 1) return 1;
  return value;
};
const MIN_PROGRESS_PULSE = 0.012;
const MAX_PROGRESS_PULSE = 0.05;

const SaveCelebration = forwardRef(
  (
    {
      colors,
      payload,
      t,
      language,
      goalCopy,
      goalPrefix = null,
      coinReward = 0,
      onPrimaryAction,
      onCountdownAction,
      playSound,
      mascotHappySource,
      progressStart: progressStartProp = 0,
      progressEnd: progressEndProp = 0,
      remainingActions = 0,
      autoCountdown = true,
    },
    ref
  ) => {
    const happySource = mascotHappySource || CLASSIC_TAMAGOTCHI_ANIMATIONS.happy;
    const countdownEnabled = !!goalCopy;
    const progressEnabled = !!goalCopy;
    const rawProgressStart = clampProgress(progressStartProp);
    const rawProgressEnd = clampProgress(
      progressEndProp < rawProgressStart ? rawProgressStart : progressEndProp
    );
    const progressStart = rawProgressStart;
    const progressEnd =
      progressEnabled && rawProgressEnd === 0 ? MIN_PROGRESS_PULSE : rawProgressEnd;
    const displayActions = Number.isFinite(Number(remainingActions))
      ? Math.max(0, Number(remainingActions))
      : 0;
    const countdownSlots = useMemo(
      () => buildSaveCountdownSlots(displayActions, language),
      [displayActions, language]
    );
    const hearts = useMemo(
      () =>
        Array.from({ length: 18 }).map((_, index) => ({
          id: `reward_heart_${index}`,
          left: Math.random() * SCREEN_WIDTH,
          delay: Math.random() * 1200,
          duration: 1800 + Math.random() * 800,
        })),
      []
    );
    const celebrationQuote = useMemo(() => getRandomFinancialQuote(language), [language]);
    const isDarkTheme = colors.background === THEMES.dark.background;
    const primaryCardBg = isDarkTheme ? lightenColor(colors.card, 0.12) : colors.card;
    const primaryCardBorder = isDarkTheme ? lightenColor(colors.border, 0.25) : "rgba(255,181,115,0.7)";
    const countdownCardBg = isDarkTheme ? lightenColor(colors.card, 0.1) : lightenColor(colors.card, 0.04);
    const countdownCardBorder = isDarkTheme ? lightenColor(colors.border, 0.3) : "rgba(255,180,126,0.65)";
    const progressAccent = isDarkTheme ? "#FFD06A" : "#FF8C3B";
    const progressTrack = isDarkTheme ? "rgba(255,255,255,0.08)" : "rgba(17,7,0,0.08)";
    const counterDigitBackground = isDarkTheme ? "rgba(255,255,255,0.08)" : "rgba(255,255,255,0.92)";
    const glowColor = isDarkTheme ? "rgba(255,214,165,0.35)" : "rgba(255,178,120,0.35)";
    const mascotWrapBg = isDarkTheme ? "rgba(255,255,255,0.08)" : "rgba(255,255,255,0.96)";
    const mascotWrapBorder = colorWithAlpha(progressAccent, isDarkTheme ? 0.45 : 0.25);
    const statBaseBg = isDarkTheme ? "rgba(255,255,255,0.06)" : "rgba(255,255,255,0.92)";
    const statBaseBorder = isDarkTheme ? "rgba(255,255,255,0.16)" : "rgba(28,26,42,0.08)";
    const statShadowColor = isDarkTheme ? "rgba(0,0,0,0.5)" : "rgba(31,24,59,0.12)";
    const quoteBg = isDarkTheme ? "rgba(255,255,255,0.06)" : "rgba(255,255,255,0.9)";
    const quoteBorder = isDarkTheme ? "rgba(255,255,255,0.14)" : "rgba(28,26,42,0.08)";
    const coinsAccent = isDarkTheme ? "#63D0FF" : "#4DA3FF";
    const skipsAccent = isDarkTheme ? "#FFB278" : "#FF8D54";
    const progressValue = useRef(new Animated.Value(progressStart)).current;
    const progressPulse = useRef(new Animated.Value(1)).current;
    const progressHapticTimersRef = useRef([]);
    const progressSoundTimersRef = useRef([]);
    const counterSoundTimersRef = useRef([]);
    const countdownSoundTimerRef = useRef(null);
    const counterSoundStartedRef = useRef(false);
    const fanfarePlayedRef = useRef(false);
    const introOpacity = useRef(new Animated.Value(1)).current;
    const introScale = useRef(new Animated.Value(0.94)).current;
    const statIntro = useRef(Array.from({ length: 3 }, () => new Animated.Value(0))).current;
    const mascotFloat = useRef(new Animated.Value(0)).current;
    const countdownOpacity = useRef(new Animated.Value(0)).current;
    const countdownScale = useRef(new Animated.Value(0.9)).current;
    const countdownZoom = useRef(new Animated.Value(1)).current;
    const glowPulse = useRef(new Animated.Value(0)).current;
    const [countdownActive, setCountdownActive] = useState(false);
    const [countdownReady, setCountdownReady] = useState(false);
    const [counterSkipToken, setCounterSkipToken] = useState(0);
    const introTimerRef = useRef(null);
    const countdownActiveRef = useRef(false);
    const digitsCompletedRef = useRef(0);
    const digitCount = useMemo(
      () => countdownSlots.filter((slot) => slot.type === "digit").length,
      [countdownSlots]
    );
    const handleDigitSpinComplete = useCallback(() => {
      if (digitCount <= 0) {
        setCountdownReady(true);
        triggerSuccessHaptic();
        return;
      }
      if (digitsCompletedRef.current >= digitCount) {
        return;
      }
      digitsCompletedRef.current += 1;
      if (digitsCompletedRef.current === 1) {
        triggerSelectionHaptic();
      }
      if (digitsCompletedRef.current >= digitCount) {
        setCountdownReady(true);
        triggerSuccessHaptic();
      }
    }, [digitCount]);
    const progressWidth = progressValue.interpolate({
      inputRange: [0, 1],
      outputRange: [0, SAVE_PROGRESS_BAR_WIDTH],
    });
    useEffect(() => {
      introScale.setValue(0.94);
      const introEntrance = Animated.spring(introScale, {
        toValue: 1,
        useNativeDriver: true,
        friction: 8,
      });
      introEntrance.start();
      return () => introEntrance.stop();
    }, [introScale]);
    useEffect(() => {
      const floatAnim = Animated.loop(
        Animated.sequence([
          Animated.timing(mascotFloat, {
            toValue: 1,
            duration: 1600,
            easing: Easing.inOut(Easing.quad),
            useNativeDriver: true,
          }),
          Animated.timing(mascotFloat, {
            toValue: 0,
            duration: 1600,
            easing: Easing.inOut(Easing.quad),
            useNativeDriver: true,
          }),
        ])
      );
      floatAnim.start();
      return () => floatAnim.stop();
    }, [mascotFloat]);
    useEffect(() => {
      progressValue.setValue(progressStart);
      progressPulse.setValue(1);
      const diff = Math.max(0, progressEnd - progressStart);
      const impactDelta = Math.max(diff, MIN_PROGRESS_PULSE);
      const paddedTarget = clampProgress(progressStart + impactDelta);
      const overshootDelta = Math.min(
        Math.max(impactDelta * 0.65, MIN_PROGRESS_PULSE * 0.75),
        MAX_PROGRESS_PULSE
      );
      const pumpTarget =
        diff < MIN_PROGRESS_PULSE
          ? paddedTarget
          : clampProgress(Math.max(progressStart, progressEnd - overshootDelta * 0.75));
      const overshootTarget = clampProgress(pumpTarget + overshootDelta);
      const fillSequence = Animated.sequence([
        Animated.spring(progressValue, {
          toValue: pumpTarget,
          friction: 7,
          tension: 120,
          velocity: 1.1,
          useNativeDriver: false,
        }),
        Animated.spring(progressValue, {
          toValue: overshootTarget,
          friction: 5,
          tension: 70,
          velocity: 0.8,
          useNativeDriver: false,
        }),
        Animated.spring(progressValue, {
          toValue: progressEnd,
          friction: 11,
          tension: 90,
          velocity: 0.65,
          useNativeDriver: false,
        }),
      ]);
      const anim = Animated.sequence([
        Animated.delay(SAVE_PROGRESS_DELAY_MS),
        Animated.spring(progressPulse, {
          toValue: SAVE_PROGRESS_PULSE_SCALE,
          friction: 6,
          tension: 140,
          useNativeDriver: true,
        }),
        Animated.delay(90),
        fillSequence,
        Animated.delay(60),
        Animated.spring(progressPulse, {
          toValue: 1,
          friction: 9,
          tension: 80,
          useNativeDriver: true,
        }),
      ]);
      anim.start();
      return () => anim.stop();
    }, [progressEnd, progressPulse, progressStart, progressValue]);
    const clearProgressHapticTimers = useCallback(() => {
      if (progressHapticTimersRef.current.length) {
        progressHapticTimersRef.current.forEach((timerId) => clearTimeout(timerId));
        progressHapticTimersRef.current = [];
      }
    }, []);
    const clearProgressSoundTimers = useCallback(() => {
      if (progressSoundTimersRef.current.length) {
        progressSoundTimersRef.current.forEach((timerId) => clearTimeout(timerId));
        progressSoundTimersRef.current = [];
      }
    }, []);
    const clearCounterSoundTimers = useCallback(() => {
      if (counterSoundTimersRef.current.length) {
        counterSoundTimersRef.current.forEach((timerId) => clearTimeout(timerId));
        counterSoundTimersRef.current = [];
      }
    }, []);
    const playCounterBurst = useCallback(() => {
      if (!playSound) return;
      clearCounterSoundTimers();
      const spacing = 70;
      [0, 1, 2].forEach((index) => {
        const timerId = setTimeout(() => {
          playSound("counter", { skipCooldown: index > 0 });
        }, index * spacing);
        counterSoundTimersRef.current.push(timerId);
      });
    }, [clearCounterSoundTimers, playSound]);
    useEffect(() => () => clearCounterSoundTimers(), [clearCounterSoundTimers]);
    const handleCounterSpinStart = useCallback(() => {
      if (!playSound) return;
      if (counterSoundStartedRef.current) return;
      counterSoundStartedRef.current = true;
      playCounterBurst();
    }, [playCounterBurst, playSound]);
    useEffect(() => {
      clearProgressHapticTimers();
      const diff = Math.max(0, progressEnd - progressStart);
      if (diff <= 0) return undefined;
      const schedule = (timeout, fn) => {
        const timerId = setTimeout(fn, Math.max(0, timeout));
        progressHapticTimersRef.current.push(timerId);
      };
      const baseDelay = SAVE_PROGRESS_DELAY_MS + 100;
      const diffScale = Math.min(Math.max(diff, MIN_PROGRESS_PULSE), 0.85);
      const fillDuration = 640 + diffScale * 1600;
      schedule(baseDelay, () => triggerHaptic(Haptics.ImpactFeedbackStyle.Light));
      schedule(baseDelay + fillDuration * 0.45, () => triggerSelectionHaptic());
      schedule(baseDelay + fillDuration * 0.92, () => triggerHaptic(Haptics.ImpactFeedbackStyle.Medium));
      return () => {
        clearProgressHapticTimers();
      };
    }, [clearProgressHapticTimers, progressEnd, progressStart]);
    useEffect(() => {
      clearProgressSoundTimers();
      if (!playSound) return undefined;
      if (countdownEnabled) return undefined;
      const diff = Math.max(0, progressEnd - progressStart);
      if (diff <= 0) return undefined;
      const baseDelay = SAVE_PROGRESS_DELAY_MS + 120;
      const diffScale = Math.min(Math.max(diff, MIN_PROGRESS_PULSE), 0.85);
      const fillDuration = 640 + diffScale * 1600;
      const scheduleSound = (timeout, key) => {
        const timerId = setTimeout(() => playSound(key), Math.max(0, timeout));
        progressSoundTimersRef.current.push(timerId);
      };
      scheduleSound(baseDelay, "counter");
      scheduleSound(baseDelay + fillDuration * 0.55, "counter");
      scheduleSound(baseDelay + fillDuration * 0.94, "coin");
      return () => {
        clearProgressSoundTimers();
      };
    }, [clearProgressSoundTimers, countdownEnabled, playSound, progressEnd, progressStart]);
    const clearIntroTimer = useCallback(() => {
      if (introTimerRef.current) {
        clearTimeout(introTimerRef.current);
        introTimerRef.current = null;
      }
    }, []);
    const startCountdownPhase = useCallback(() => {
      if (!countdownEnabled) return false;
      if (countdownActiveRef.current) return false;
      clearIntroTimer();
      digitsCompletedRef.current = 0;
      counterSoundStartedRef.current = false;
      fanfarePlayedRef.current = false;
      setCountdownReady(digitCount <= 0);
      countdownActiveRef.current = true;
      setCountdownActive(true);
      triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
      Animated.parallel([
        Animated.timing(introOpacity, {
          toValue: 0,
          duration: 320,
          easing: Easing.out(Easing.cubic),
          useNativeDriver: true,
        }),
        Animated.timing(countdownOpacity, {
          toValue: 1,
          duration: 360,
          easing: Easing.out(Easing.cubic),
          useNativeDriver: true,
        }),
        Animated.spring(countdownScale, {
          toValue: 1,
          useNativeDriver: true,
          friction: 8,
        }),
      ]).start();
      return true;
    }, [clearIntroTimer, countdownOpacity, countdownScale, digitCount, introOpacity, playCounterBurst]);
    useEffect(() => {
      clearIntroTimer();
      if (!countdownEnabled) return undefined;
      if (!autoCountdown) return undefined;
      if (countdownActiveRef.current) return undefined;
      const diff = Math.max(0, progressEnd - progressStart);
      const diffScale = Math.min(Math.max(diff, MIN_PROGRESS_PULSE), 0.85);
      const fillDuration = 640 + diffScale * 1600;
      const autoDelay = SAVE_PROGRESS_DELAY_MS + 100 + fillDuration + 240;
      introTimerRef.current = setTimeout(() => {
        startCountdownPhase();
      }, Math.max(0, autoDelay));
      return () => {
        clearIntroTimer();
      };
    }, [autoCountdown, clearIntroTimer, countdownEnabled, progressEnd, progressStart, startCountdownPhase]);
    const skipCountdownAnimation = useCallback(() => {
      if (!countdownEnabled) return false;
      if (!countdownActiveRef.current) return false;
      if (countdownReady) return false;
      clearCounterSoundTimers();
      digitsCompletedRef.current = digitCount;
      setCountdownReady(true);
      setCounterSkipToken((prev) => prev + 1);
      triggerSuccessHaptic();
      return true;
    }, [clearCounterSoundTimers, countdownEnabled, countdownReady, digitCount]);
    useEffect(() => {
      if (!countdownEnabled) return;
      countdownActiveRef.current = countdownActive;
    }, [countdownActive]);
    useEffect(() => {
      if (!countdownEnabled || !countdownActive || !countdownReady) return;
      if (countdownSoundTimerRef.current) {
        clearTimeout(countdownSoundTimerRef.current);
        countdownSoundTimerRef.current = null;
      }
      if (playSound && !fanfarePlayedRef.current) {
        fanfarePlayedRef.current = true;
        countdownSoundTimerRef.current = setTimeout(() => {
          playSound("reward");
        }, 160);
      }
      glowPulse.setValue(0);
      countdownZoom.setValue(1);
      const pulse = Animated.sequence([
        Animated.delay(SAVE_COUNTDOWN_ZOOM_DELAY_AFTER_SPIN),
        Animated.parallel([
          Animated.sequence([
            Animated.timing(glowPulse, {
              toValue: 1,
              duration: 260,
              useNativeDriver: true,
            }),
            Animated.timing(glowPulse, {
              toValue: 0,
              duration: 420,
              useNativeDriver: true,
            }),
          ]),
          Animated.sequence([
            Animated.timing(countdownZoom, {
              toValue: 1.04,
              duration: 240,
              easing: Easing.out(Easing.quad),
              useNativeDriver: true,
            }),
            Animated.timing(countdownZoom, {
              toValue: 1,
              duration: 320,
              easing: Easing.out(Easing.quad),
              useNativeDriver: true,
            }),
          ]),
        ]),
        Animated.delay(SAVE_COUNTDOWN_FINAL_HOLD_DELAY),
      ]);
      pulse.start();
      return () => {
        pulse.stop();
        if (countdownSoundTimerRef.current) {
          clearTimeout(countdownSoundTimerRef.current);
          countdownSoundTimerRef.current = null;
        }
      };
    }, [countdownActive, countdownEnabled, countdownReady, countdownZoom, glowPulse, playSound]);
    const percentLabel =
      progressEnd > 0
        ? Math.min(100, Math.max(1, Math.round(progressEnd * 100)))
        : 0;
    const progressCopy = getSaveProgressCopy(language);
    const countdownTitle = getSaveCountdownTitle(language);
    const rewardLabel = Math.max(0, Number(coinReward) || 0);
    const savedAmountLabel = typeof payload?.savedAmountLabel === "string" ? payload.savedAmountLabel : "";
    const saveCount = Math.max(0, Number(payload?.saveCount) || 0);
    const saveCountLocale = getFormatLocale(language) || "en-US";
    const savedValue = savedAmountLabel || "0";
    const coinsValue = rewardLabel > 0 ? `+${rewardLabel}` : "0";
    const skipsValue = saveCount.toLocaleString(saveCountLocale);
    const statCards = useMemo(
      () => [
        { key: "saved", label: t("saveOverlayStatSaved"), value: savedValue, accent: SAVE_ACTION_COLOR },
        { key: "coins", label: t("saveOverlayStatCoins"), value: coinsValue, accent: coinsAccent, icon: HEALTH_COIN_TIERS[0].asset },
        { key: "skips", label: t("saveOverlayStatSkips"), value: skipsValue, accent: skipsAccent },
      ],
      [coinsValue, coinsAccent, savedValue, skipsAccent, skipsValue, t]
    );
    const mascotTranslateY = mascotFloat.interpolate({
      inputRange: [0, 1],
      outputRange: [0, -6],
    });
    const statAnimatedStyles = useMemo(
      () =>
        statIntro.map((value, index) => {
          const direction = index % 2 === 0 ? 1 : -1;
          return {
            opacity: value.interpolate({
              inputRange: [0, 0.2, 1],
              outputRange: [0, 0.65, 1],
            }),
            transform: [
              {
                translateY: value.interpolate({
                  inputRange: [0, 0.7, 1],
                  outputRange: [18, -6, 0],
                }),
              },
              {
                scale: value.interpolate({
                  inputRange: [0, 0.6, 1],
                  outputRange: [0.9, 1.05, 1],
                }),
              },
              {
                rotate: value.interpolate({
                  inputRange: [0, 1],
                  outputRange: [`${direction * -1.4}deg`, "0deg"],
                }),
              },
            ],
          };
        }),
      [statIntro]
    );
    const [goalQuoteStart, goalQuoteEnd] = useMemo(() => getGoalQuoteMarks(language), [language]);
    const goalDisplay = goalPrefix && goalCopy ? `${goalQuoteStart}${goalCopy}${goalQuoteEnd}` : goalCopy;
    useEffect(() => {
      statIntro.forEach((value) => value.setValue(0));
      const animation = Animated.sequence([
        Animated.delay(180),
        Animated.stagger(
          160,
          statIntro.map((value) =>
            Animated.spring(value, {
              toValue: 1,
              useNativeDriver: true,
              friction: 6,
              tension: 140,
            })
          )
        ),
      ]);
      animation.start();
      return () => animation.stop();
    }, [coinsValue, savedValue, skipsValue, statIntro]);
    useImperativeHandle(
      ref,
      () => ({
        skipToCountdown: () => (countdownEnabled ? startCountdownPhase() : false),
        skipCountdownAnimation,
        isCountdownActive: () => (countdownEnabled ? countdownActiveRef.current : false),
        isCountdownReady: () => (countdownEnabled ? countdownReady : true),
      }),
      [countdownEnabled, countdownReady, skipCountdownAnimation, startCountdownPhase]
    );
    return (
      <View style={styles.saveCelebrationOverlay} pointerEvents="box-none">
        {hearts.map((heart) => (
          <RewardHeart key={heart.id} {...heart} />
        ))}
        <Animated.View
          pointerEvents={countdownActive ? "none" : "auto"}
          style={[
            styles.saveCelebrationCard,
            styles.saveCelebrationPrimary,
            {
              backgroundColor: primaryCardBg,
              borderColor: primaryCardBorder,
              opacity: introOpacity,
              transform: [{ scale: introScale }],
            },
          ]}
        >
          <View pointerEvents="none" style={[styles.saveCelebrationGlow, { backgroundColor: glowColor }]} />
          <View
            pointerEvents="none"
            style={[styles.saveCelebrationGlow, styles.saveCelebrationGlowTop, { backgroundColor: progressAccent }]}
          />
          <View style={styles.saveCelebrationContent}>
            <View style={styles.saveCelebrationHeader}>
              <View
                style={[
                  styles.saveCelebrationMascotWrap,
                  { backgroundColor: mascotWrapBg, borderColor: mascotWrapBorder },
                ]}
              >
                <Animated.Image
                  source={happySource}
                  style={[styles.saveCelebrationCat, { transform: [{ translateY: mascotTranslateY }] }]}
                />
              </View>
              <View style={styles.saveCelebrationTitleBlock}>
                <Text style={[styles.saveCelebrationSubtitle, { color: colors.muted }]}>
                  {t("saveCelebrateTitlePrefix")}
                </Text>
                <Text style={[styles.saveCelebrationTitle, { color: colors.text }]} numberOfLines={2}>
                  {payload?.title || ""}
                </Text>
              </View>
            </View>
            <View style={styles.saveCelebrationStatsRow}>
              {statCards.map((stat, index) => (
                <Animated.View
                  key={stat.key}
                  style={[
                    styles.saveCelebrationStatCard,
                    {
                      backgroundColor: statBaseBg,
                      borderColor: statBaseBorder,
                      shadowColor: statShadowColor,
                    },
                    statAnimatedStyles[index],
                  ]}
                >
                  <View style={[styles.saveCelebrationStatAccent, { backgroundColor: stat.accent }]} />
                  <View
                    style={[
                      styles.saveCelebrationStatIconWrap,
                      { backgroundColor: colorWithAlpha(stat.accent, isDarkTheme ? 0.25 : 0.18) },
                    ]}
                  >
                    {stat.icon ? (
                      <Image source={stat.icon} style={styles.saveCelebrationStatIcon} />
                    ) : (
                      <View style={[styles.saveCelebrationStatDot, { backgroundColor: stat.accent }]} />
                    )}
                  </View>
                  <Text
                    style={[styles.saveCelebrationStatValue, { color: colors.text }]}
                    numberOfLines={1}
                    adjustsFontSizeToFit
                    minimumFontScale={0.8}
                  >
                    {stat.value}
                  </Text>
                  <Text style={[styles.saveCelebrationStatLabel, { color: colors.muted }]} numberOfLines={2}>
                    {stat.label}
                  </Text>
                </Animated.View>
              ))}
            </View>
            {celebrationQuote ? (
              <View style={[styles.saveQuoteCard, { backgroundColor: quoteBg, borderColor: quoteBorder }]}>
                <Text style={[styles.saveQuote, { color: colors.text }]}>{celebrationQuote}</Text>
              </View>
            ) : null}
            {progressEnabled && (
              <Animated.View style={[styles.saveProgressSection, { transform: [{ scaleY: progressPulse }] }]}>
                <View style={[styles.saveProgressTrack, { backgroundColor: progressTrack }]}>
                  <Animated.View
                    style={[
                      styles.saveProgressFill,
                      {
                        width: progressWidth,
                        backgroundColor: progressAccent,
                      },
                    ]}
                  />
                </View>
                <View style={styles.saveProgressLabelRow}>
                  <Text style={[styles.saveProgressValue, { color: colors.text }]}>{percentLabel}%</Text>
                  <Text style={[styles.saveProgressHint, { color: colors.muted }]}>{progressCopy}</Text>
                </View>
              </Animated.View>
            )}
            {onPrimaryAction ? (
              <TouchableOpacity
                style={[
                  styles.saveCelebrationPrimaryButton,
                  {
                    backgroundColor: progressAccent,
                    borderColor: colorWithAlpha(progressAccent, isDarkTheme ? 0.6 : 0.4),
                  },
                ]}
                activeOpacity={0.86}
                onPress={onPrimaryAction}
              >
                <Text
                  style={[
                    styles.saveCelebrationPrimaryButtonText,
                    { color: isDarkTheme ? "#1C1A2A" : "#ffffff" },
                  ]}
                >
                  {t("saveOverlayPrimaryCta")}
                </Text>
              </TouchableOpacity>
            ) : null}
          </View>
        </Animated.View>
        {countdownEnabled && (
          <Animated.View
            pointerEvents={countdownActive ? "auto" : "none"}
            style={[
              styles.saveCelebrationCard,
              styles.saveCountdownCard,
              {
                backgroundColor: countdownCardBg,
                borderColor: countdownCardBorder,
                opacity: countdownOpacity,
                transform: [{ scale: countdownScale }, { scale: countdownZoom }],
              },
            ]}
          >
            <Animated.View
              pointerEvents="none"
              style={[
                styles.saveCountdownGlow,
                {
                  backgroundColor: glowColor,
                  opacity: glowPulse,
                },
              ]}
            />
            <View style={styles.saveCountdownHeaderRow}>
              <View
                style={[
                  styles.saveCountdownBadge,
                  {
                    backgroundColor: colorWithAlpha(progressAccent, isDarkTheme ? 0.22 : 0.16),
                    borderColor: colorWithAlpha(progressAccent, isDarkTheme ? 0.5 : 0.35),
                  },
                ]}
              >
                <Text style={[styles.saveCountdownBadgeText, { color: colors.text }]}>
                  {countdownTitle}
                </Text>
              </View>
            </View>
            <View style={styles.saveCounterRow}>
              {countdownSlots.map((slot, index) => {
                if (slot.type === "digit") {
                  return (
                    <SaveCounterDigit
                      key={slot.key}
                      index={index}
                      digit={slot.value}
                      delay={index * 110}
                      active={countdownActive}
                      skipToken={counterSkipToken}
                      color={colors.text}
                      backgroundColor={counterDigitBackground}
                      onSpinStart={index === 0 ? handleCounterSpinStart : undefined}
                      onSpinComplete={handleDigitSpinComplete}
                    />
                  );
                }
                if (slot.type === "separator") {
                  return (
                    <View key={`${slot.key}-sep`} style={styles.saveCounterSeparator}>
                      <Text style={[styles.saveCounterSeparatorText, { color: colors.muted }]}>{slot.value}</Text>
                    </View>
                  );
                }
                return <View key={`${slot.key}-space`} style={styles.saveCounterSpace} />;
              })}
            </View>
            {goalPrefix && goalDisplay ? (
              <>
                <Text style={[styles.saveCountdownGoalPrefix, { color: colors.muted }]}>{goalPrefix}</Text>
                <Text style={[styles.saveCountdownGoal, { color: colors.text }]}>{goalDisplay}</Text>
              </>
            ) : goalDisplay ? (
              <Text style={[styles.saveCountdownGoal, { color: colors.text }]}>{goalDisplay}</Text>
            ) : null}
            {onCountdownAction ? (
              <TouchableOpacity
                style={[
                  styles.saveCountdownButton,
                  {
                    backgroundColor: progressAccent,
                    borderColor: colorWithAlpha(progressAccent, isDarkTheme ? 0.6 : 0.4),
                  },
                ]}
                activeOpacity={0.86}
                onPress={onCountdownAction}
              >
                <Text
                  style={[
                    styles.saveCountdownButtonText,
                    { color: isDarkTheme ? "#1C1A2A" : "#ffffff" },
                  ]}
                >
                  {t("saveOverlayNextCta")}
                </Text>
              </TouchableOpacity>
            ) : null}
          </Animated.View>
        )}
      </View>
    );
  }
);

const SaveCounterDigit = React.memo(({
  digit = 0,
  delay = 0,
  active = false,
  skipToken = 0,
  color = "#000",
  backgroundColor = "rgba(0,0,0,0.05)",
  index = 0,
  onSpinStart,
  onSpinComplete,
}) => {
  const spinProgress = useRef(new Animated.Value(0)).current;
  const digitScale = useRef(new Animated.Value(0.96)).current;
  const tiltProgress = useRef(new Animated.Value(0)).current;
  const shineProgress = useRef(new Animated.Value(0)).current;
  const animationRef = useRef(null);
  const spinStartTimerRef = useRef(null);
  const completedRef = useRef(false);
  const loops = Math.max(1, SAVE_COUNTER_SPIN_LOOPS + index);
  const hapticsEnabled = active && index === 0 && skipToken === 0;
  const spinHapticTimeoutsRef = useRef([]);
  const spinHapticIntervalRef = useRef(null);
  const clearSpinHaptics = useCallback(() => {
    if (spinHapticTimeoutsRef.current.length) {
      spinHapticTimeoutsRef.current.forEach((timerId) => clearTimeout(timerId));
      spinHapticTimeoutsRef.current = [];
    }
    if (spinHapticIntervalRef.current) {
      clearInterval(spinHapticIntervalRef.current);
      spinHapticIntervalRef.current = null;
    }
  }, []);
  const digitsSequence = useMemo(() => {
    const safeDigit = Math.max(0, Number(digit) || 0);
    const values = [];
    for (let counter = 0; counter < loops * 10; counter += 1) {
      values.push(counter % 10);
    }
    values.push(safeDigit);
    return values;
  }, [digit, loops]);
  const digitNodes = useMemo(
    () =>
      digitsSequence.map((value, valueIndex) => (
        <Text key={`${value}-${valueIndex}`} style={[styles.saveCounterDigitText, { color }]}>
          {value}
        </Text>
      )),
    [color, digitsSequence]
  );
  const spinSteps = Math.max(1, digitsSequence.length - 1);
  const translateY = spinProgress.interpolate({
    inputRange: [0, spinSteps],
    outputRange: [0, -SAVE_COUNTER_DIGIT_HEIGHT * spinSteps],
  });
  const rotateX = tiltProgress.interpolate({
    inputRange: [0, 1],
    outputRange: ["0deg", "-7deg"],
  });
  const highlightOpacity = shineProgress.interpolate({
    inputRange: [0, 1],
    outputRange: [0.1, 0.7],
  });
  useEffect(() => {
    if (spinStartTimerRef.current) {
      clearTimeout(spinStartTimerRef.current);
      spinStartTimerRef.current = null;
    }
    if (animationRef.current) {
      animationRef.current.stop();
      animationRef.current = null;
    }
    if (skipToken > 0) {
      clearSpinHaptics();
      spinProgress.setValue(spinSteps);
      digitScale.setValue(1);
      tiltProgress.setValue(0);
      shineProgress.setValue(0.35);
      completedRef.current = true;
      return;
    }
    spinProgress.setValue(0);
    digitScale.setValue(0.96);
    tiltProgress.setValue(0);
    shineProgress.setValue(0);
    completedRef.current = false;
    if (!active) return;
    const spinStartTimer = onSpinStart
      ? setTimeout(() => {
          onSpinStart();
        }, Math.max(0, delay))
      : null;
    spinStartTimerRef.current = spinStartTimer;
    const animation = Animated.sequence([
      Animated.delay(delay),
      Animated.timing(spinProgress, {
        toValue: spinSteps - 0.35,
        duration: 900 + spinSteps * 12,
        easing: Easing.out(Easing.cubic),
        useNativeDriver: true,
      }),
      Animated.timing(spinProgress, {
        toValue: spinSteps,
        duration: 160,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }),
      Animated.parallel([
        Animated.spring(digitScale, {
          toValue: 1.08,
          friction: 5,
          tension: 140,
          useNativeDriver: true,
        }),
        Animated.spring(tiltProgress, {
          toValue: 1,
          friction: 6,
          tension: 110,
          useNativeDriver: true,
        }),
        Animated.sequence([
          Animated.timing(shineProgress, {
            toValue: 1,
            duration: 160,
            useNativeDriver: true,
          }),
          Animated.spring(shineProgress, {
            toValue: 0.35,
            friction: 6,
            useNativeDriver: true,
          }),
        ]),
      ]),
      Animated.spring(digitScale, {
        toValue: 1,
        friction: 7,
        tension: 90,
        useNativeDriver: true,
      }),
      Animated.spring(tiltProgress, {
        toValue: 0,
        friction: 7,
        tension: 70,
        useNativeDriver: true,
      }),
    ]);
    animationRef.current = animation;
    animation.start(({ finished }) => {
      if (finished && !completedRef.current) {
        completedRef.current = true;
        onSpinComplete?.();
      }
    });
    return () => {
      if (spinStartTimerRef.current) {
        clearTimeout(spinStartTimerRef.current);
        spinStartTimerRef.current = null;
      }
      if (animationRef.current) {
        animationRef.current.stop();
        animationRef.current = null;
      }
    };
  }, [
    active,
    clearSpinHaptics,
    delay,
    digitScale,
    onSpinComplete,
    onSpinStart,
    shineProgress,
    skipToken,
    spinProgress,
    spinSteps,
    tiltProgress,
  ]);
  useEffect(() => {
    clearSpinHaptics();
    if (!hapticsEnabled) return undefined;
    const startDelay = Math.max(0, delay + 60);
    const spinDuration = 900 + spinSteps * 12 + 160;
    const tickInterval = Math.max(70, Math.min(170, spinDuration / Math.max(2, loops * 1.2)));
    const startTimer = setTimeout(() => {
      triggerSelectionHaptic();
      spinHapticIntervalRef.current = setInterval(() => {
        triggerSelectionHaptic();
      }, tickInterval);
    }, startDelay);
    const stopTimer = setTimeout(() => {
      clearSpinHaptics();
    }, startDelay + spinDuration);
    spinHapticTimeoutsRef.current = [startTimer, stopTimer];
    return () => {
      clearSpinHaptics();
    };
  }, [clearSpinHaptics, delay, hapticsEnabled, loops, spinSteps]);
  return (
    <Animated.View style={[styles.saveCounterDigit, { transform: [{ scale: digitScale }] }]}>
      <Animated.View
        style={[
          styles.saveCounterDigitSurface,
          {
            backgroundColor,
            transform: [{ perspective: 400 }, { rotateX }],
          },
        ]}
      >
        <View pointerEvents="none" style={styles.saveCounterDigitEdgeTop} />
        <View pointerEvents="none" style={styles.saveCounterDigitEdgeBottom} />
        <Animated.View
          style={[
            styles.saveCounterDigitColumn,
            {
              transform: [{ translateY }],
            },
          ]}
        >
          {digitNodes}
        </Animated.View>
        <Animated.View
          pointerEvents="none"
          style={[styles.saveCounterDigitHighlight, { opacity: highlightOpacity }]}
        />
        <View pointerEvents="none" style={styles.saveCounterDigitDivider} />
      </Animated.View>
    </Animated.View>
  );
});

const UsageStreakCounterDigit = ({
  digit = 0,
  delay = 0,
  active = false,
  color = "#000",
  backgroundColor = "rgba(0,0,0,0.08)",
  borderColor = "rgba(0,0,0,0.12)",
  dividerColor = "rgba(0,0,0,0.12)",
  index = 0,
}) => {
  const spinProgress = useRef(new Animated.Value(0)).current;
  const digitScale = useRef(new Animated.Value(0.92)).current;
  const loops = Math.max(1, STREAK_COUNTER_SPIN_LOOPS + index);
  const digitsSequence = useMemo(() => {
    const safeDigit = Math.max(0, Number(digit) || 0);
    const values = [];
    for (let counter = 0; counter < loops * 10; counter += 1) {
      values.push(counter % 10);
    }
    values.push(safeDigit);
    return values;
  }, [digit, loops]);
  const spinSteps = Math.max(1, digitsSequence.length - 1);
  const translateY = spinProgress.interpolate({
    inputRange: [0, spinSteps],
    outputRange: [0, -STREAK_COUNTER_DIGIT_HEIGHT * spinSteps],
  });
  useEffect(() => {
    spinProgress.setValue(0);
    digitScale.setValue(0.92);
    if (!active) return;
    const animation = Animated.sequence([
      Animated.delay(delay),
      Animated.timing(spinProgress, {
        toValue: spinSteps,
        duration: 720 + spinSteps * 10,
        easing: Easing.out(Easing.cubic),
        useNativeDriver: true,
      }),
      Animated.spring(digitScale, {
        toValue: 1,
        friction: 6,
        tension: 130,
        useNativeDriver: true,
      }),
    ]);
    animation.start();
    return () => {
      animation.stop();
    };
  }, [active, delay, digitScale, spinProgress, spinSteps]);
  return (
    <Animated.View style={[styles.usageStreakCounterDigit, { transform: [{ scale: digitScale }] }]}>
      <View style={[styles.usageStreakCounterDigitSurface, { backgroundColor, borderColor }]}>
        <Animated.View style={[styles.usageStreakCounterDigitColumn, { transform: [{ translateY }] }]}>
          {digitsSequence.map((value, valueIndex) => (
            <Text key={`${value}-${valueIndex}`} style={[styles.usageStreakCounterDigitText, { color }]}>
              {value}
            </Text>
          ))}
        </Animated.View>
        <View
          pointerEvents="none"
          style={[styles.usageStreakCounterDigitDivider, { backgroundColor: dividerColor }]}
        />
      </View>
    </Animated.View>
  );
};

const premiumUnlockStyles = StyleSheet.create({
  root: {
    flex: 1,
    alignItems: "center",
    justifyContent: "center",
    paddingHorizontal: 16,
    paddingVertical: 24,
  },
  backdrop: {
    ...StyleSheet.absoluteFillObject,
  },
  card: {
    width: "100%",
    maxWidth: 520,
    maxHeight: Math.min(SCREEN_HEIGHT - 32, IS_SHORT_DEVICE ? 560 : 620),
    borderRadius: 28,
    borderWidth: 1,
    overflow: "hidden",
  },
  hero: {
    backgroundColor: "#0A1E72",
    paddingHorizontal: 18,
    paddingTop: 16,
    paddingBottom: 14,
    alignItems: "center",
  },
  heroOrbMain: {
    position: "absolute",
    top: -58,
    right: -30,
    width: 190,
    height: 190,
    borderRadius: 999,
    backgroundColor: "rgba(99,113,255,0.55)",
  },
  heroOrbSub: {
    position: "absolute",
    bottom: -80,
    left: -40,
    width: 168,
    height: 168,
    borderRadius: 999,
    backgroundColor: "rgba(67,83,255,0.4)",
  },
  badge: {
    borderRadius: 999,
    paddingHorizontal: 14,
    paddingVertical: 6,
    backgroundColor: "rgba(136,103,255,0.9)",
    borderWidth: 1,
    borderColor: "rgba(255,255,255,0.28)",
    marginBottom: 10,
  },
  badgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
    color: "#FFFFFF",
  },
  heroEmoji: {
    fontSize: 40,
    marginBottom: 6,
  },
  title: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 24,
    lineHeight: 30,
    textAlign: "center",
    color: "#F5F7FF",
  },
  subtitle: {
    ...createBodyText({ fontSize: 13, lineHeight: 19, textAlign: "center" }),
    marginTop: 6,
    color: "rgba(227,234,255,0.94)",
  },
  body: {
    flexShrink: 1,
    paddingHorizontal: 18,
    paddingTop: 14,
    paddingBottom: 14,
    backgroundColor: "#FFFFFF",
  },
  featuresScroll: {
    maxHeight: Math.min(250, IS_SHORT_DEVICE ? 180 : SCREEN_HEIGHT * 0.3),
  },
  features: {
    gap: 8,
    paddingRight: 2,
  },
  featureRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 9,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "rgba(67,83,255,0.14)",
    backgroundColor: "rgba(67,83,255,0.08)",
    paddingHorizontal: 11,
    paddingVertical: 8,
  },
  featureCheckWrap: {
    width: 20,
    height: 20,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "#4353FF",
  },
  featureCheck: {
    color: "#FFFFFF",
    fontSize: 13,
    lineHeight: 14,
    fontWeight: "800",
  },
  featureText: {
    ...createBodyText({ fontSize: 14, lineHeight: 20 }),
    flex: 1,
    fontWeight: "600",
    color: "#182250",
  },
  cta: {
    marginTop: 16,
    borderRadius: 14,
    minHeight: 52,
    alignItems: "center",
    justifyContent: "center",
    paddingHorizontal: 22,
    backgroundColor: "#4353FF",
    shadowColor: "#4353FF",
    shadowOpacity: 0.34,
    shadowRadius: 14,
    shadowOffset: { width: 0, height: 8 },
    elevation: 10,
  },
  ctaText: {
    ...createCtaText({ fontSize: 14, textTransform: "none" }),
    color: "#FFFFFF",
  },
});

const PremiumUnlockCelebration = ({ payload, onClose, playSound }) => {
  const data = payload && typeof payload === "object" ? payload : {};
  const title = typeof data.title === "string" && data.title.trim() ? data.title.trim() : "Premium unlocked";
  const subtitle =
    typeof data.subtitle === "string" && data.subtitle.trim()
      ? data.subtitle.trim()
      : "Your Premium access is now active.";
  const cta = typeof data.cta === "string" && data.cta.trim() ? data.cta.trim() : "Continue";
  const accentColor =
    typeof data.accentColor === "string" && data.accentColor.trim()
      ? data.accentColor.trim()
      : "#4353FF";
  const heroBackground = blendHexColors("#0A1E72", accentColor, 0.18);
  const features = Array.isArray(data.features)
    ? data.features
        .filter((entry) => typeof entry === "string" && entry.trim().length > 0)
        .map((entry) => entry.trim())
        .slice(0, 14)
    : [];
  const entryAnim = useRef(new Animated.Value(0)).current;
  const badgePulseAnim = useRef(new Animated.Value(0)).current;
  const emojiFloatAnim = useRef(new Animated.Value(0)).current;
  const fanfarePlayedRef = useRef(false);

  useEffect(() => {
    entryAnim.setValue(0);
    const entrance = Animated.spring(entryAnim, {
      toValue: 1,
      friction: 8,
      tension: 92,
      useNativeDriver: true,
    });
    const badgeLoop = Animated.loop(
      Animated.sequence([
        Animated.timing(badgePulseAnim, {
          toValue: 1,
          duration: 1100,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(badgePulseAnim, {
          toValue: 0,
          duration: 1100,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    const emojiLoop = Animated.loop(
      Animated.sequence([
        Animated.timing(emojiFloatAnim, {
          toValue: 1,
          duration: 1800,
          easing: Easing.inOut(Easing.sin),
          useNativeDriver: true,
        }),
        Animated.timing(emojiFloatAnim, {
          toValue: 0,
          duration: 1800,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    entrance.start();
    badgeLoop.start();
    emojiLoop.start();
    return () => {
      entrance.stop();
      badgeLoop.stop();
      emojiLoop.stop();
    };
  }, [badgePulseAnim, emojiFloatAnim, entryAnim]);

  useEffect(() => {
    if (!playSound || fanfarePlayedRef.current) return;
    fanfarePlayedRef.current = true;
    const timers = [
      setTimeout(() => {
        playSound("level_up", { skipCooldown: true });
      }, 0),
      setTimeout(() => {
        playSound("reward", { skipCooldown: true });
      }, 220),
      setTimeout(() => {
        playSound("party_cheer", { skipCooldown: true });
      }, 460),
    ];
    return () => {
      timers.forEach((timer) => clearTimeout(timer));
    };
  }, [playSound]);

  const cardAnimatedStyle = {
    opacity: entryAnim.interpolate({ inputRange: [0, 1], outputRange: [0, 1] }),
    transform: [
      { translateY: entryAnim.interpolate({ inputRange: [0, 1], outputRange: [36, 0] }) },
      { scale: entryAnim.interpolate({ inputRange: [0, 1], outputRange: [0.95, 1] }) },
    ],
  };
  const badgeAnimatedStyle = {
    transform: [
      {
        scale: badgePulseAnim.interpolate({
          inputRange: [0, 1],
          outputRange: [1, 1.05],
        }),
      },
    ],
  };
  const emojiAnimatedStyle = {
    transform: [
      {
        translateY: emojiFloatAnim.interpolate({
          inputRange: [0, 1],
          outputRange: [-6, 6],
        }),
      },
    ],
  };
  const featureCount = Math.max(1, features.length);
  const getFeatureAnimatedStyle = (index) => {
    const start = 0.2 + (index / featureCount) * 0.45;
    const end = Math.min(1, start + 0.2);
    return {
      opacity: entryAnim.interpolate({
        inputRange: [start, end],
        outputRange: [0, 1],
        extrapolate: "clamp",
      }),
      transform: [
        {
          translateY: entryAnim.interpolate({
            inputRange: [start, end],
            outputRange: [14, 0],
            extrapolate: "clamp",
          }),
        },
      ],
    };
  };

  return (
    <View style={premiumUnlockStyles.root}>
      <View style={[premiumUnlockStyles.backdrop, { backgroundColor: "rgba(4,10,38,0.86)" }]} />
      <ConfettiCannon
        count={110}
        origin={{ x: SCREEN_WIDTH / 2, y: -20 }}
        fadeOut
        explosionSpeed={300}
        fallSpeed={3200}
      />
      <Animated.View
        style={[
          premiumUnlockStyles.card,
          cardAnimatedStyle,
          { backgroundColor: "#FFFFFF", borderColor: colorWithAlpha(accentColor, 0.34) },
        ]}
      >
        <View style={[premiumUnlockStyles.hero, { backgroundColor: heroBackground }]}>
          <View
            pointerEvents="none"
            style={[premiumUnlockStyles.heroOrbMain, { backgroundColor: colorWithAlpha(accentColor, 0.5) }]}
          />
          <View
            pointerEvents="none"
            style={[premiumUnlockStyles.heroOrbSub, { backgroundColor: colorWithAlpha(accentColor, 0.36) }]}
          />
          <Animated.View style={badgeAnimatedStyle}>
            <View
              style={[
                premiumUnlockStyles.badge,
                {
                  backgroundColor: colorWithAlpha(accentColor, 0.72),
                  borderColor: colorWithAlpha("#FFFFFF", 0.3),
                },
              ]}
            >
              <Text style={premiumUnlockStyles.badgeText}>ALMOST PRO</Text>
            </View>
          </Animated.View>
          <Animated.View style={emojiAnimatedStyle}>
            <Text style={premiumUnlockStyles.heroEmoji}>ðŸª½ðŸ’¸</Text>
          </Animated.View>
          <Text style={premiumUnlockStyles.title}>{title}</Text>
          <Text style={premiumUnlockStyles.subtitle}>{subtitle}</Text>
        </View>
        <View style={premiumUnlockStyles.body}>
          {!!features.length && (
            <ScrollView
              style={premiumUnlockStyles.featuresScroll}
              contentContainerStyle={premiumUnlockStyles.features}
              showsVerticalScrollIndicator={features.length > 5}
              alwaysBounceVertical={false}
              nestedScrollEnabled
            >
              {features.map((feature, index) => (
                <Animated.View
                  key={`${feature}_${index}`}
                  style={[
                    premiumUnlockStyles.featureRow,
                    {
                      borderColor: colorWithAlpha(accentColor, 0.16),
                      backgroundColor: colorWithAlpha(accentColor, 0.08),
                    },
                    getFeatureAnimatedStyle(index),
                  ]}
                >
                  <View style={[premiumUnlockStyles.featureCheckWrap, { backgroundColor: accentColor }]}>
                    <Text style={premiumUnlockStyles.featureCheck}>âœ“</Text>
                  </View>
                  <Text style={premiumUnlockStyles.featureText}>{feature}</Text>
                </Animated.View>
              ))}
            </ScrollView>
          )}
          <TouchableOpacity
            style={[premiumUnlockStyles.cta, { backgroundColor: accentColor, shadowColor: accentColor }]}
            onPress={onClose}
            activeOpacity={0.92}
          >
            <Text style={premiumUnlockStyles.ctaText}>{cta}</Text>
          </TouchableOpacity>
        </View>
      </Animated.View>
    </View>
  );
};

const RewardCelebration = ({ colors, message, t, mascotHappySource }) => {
  const happySource = mascotHappySource || CLASSIC_TAMAGOTCHI_ANIMATIONS.happy;
  const hearts = useMemo(
    () =>
      Array.from({ length: 18 }).map((_, index) => ({
        id: `reward_heart_${index}`,
        left: Math.random() * SCREEN_WIDTH,
        delay: Math.random() * 1200,
        duration: 1800 + Math.random() * 800,
      })),
    []
  );
  const isDarkTheme = colors.background === THEMES.dark.background;
  const rewardBackdropColor = isDarkTheme ? "rgba(0,0,0,0.85)" : "rgba(255,241,225,0.92)";
  const rewardCardBg = isDarkTheme ? lightenColor(colors.card, 0.12) : colors.card;
  const rewardCardBorder = isDarkTheme ? lightenColor(colors.border, 0.25) : "rgba(255,181,115,0.7)";
  return (
    <View style={styles.rewardOverlay}>
      <View style={[styles.rewardBackdrop, { backgroundColor: rewardBackdropColor }]} />
      {hearts.map((heart) => (
        <RewardHeart key={heart.id} {...heart} />
      ))}
      <View
        style={[
          styles.rewardCard,
          { backgroundColor: rewardCardBg, borderColor: rewardCardBorder },
        ]}
      >
        <Image source={happySource} style={styles.rewardCat} />
        <Text style={[styles.rewardTitle, { color: colors.text }]}>
          {t("rewardCelebrateTitle", { title: message })}
        </Text>
        <Text style={[styles.rewardSubtitle, { color: colors.muted }]}>
          {t("rewardCelebrateSubtitle")}
        </Text>
      </View>
    </View>
  );
};

const HealthCelebration = ({ colors, payload, t, language }) => {
  const data = payload && typeof payload === "object" ? payload : { reason: payload };
  const amount =
    typeof data.amount === "number" && Number.isFinite(data.amount) ? data.amount : HEALTH_PER_REWARD;
  const coinValue =
    typeof data.coinValue === "number" && Number.isFinite(data.coinValue) ? data.coinValue : amount;
  const baseSubtitle = t("healthCelebrateSubtitle");
  const reason = data.reason || baseSubtitle;
  const rewardCoinTier = getHealthCoinTierForAmount(coinValue);
  const titleAmount = formatHealthRewardLabel(coinValue, language);
  const isDarkTheme = colors.background === THEMES.dark.background;
  const tierId = rewardCoinTier?.id || "blue";
  const accentMap = {
    green: "#43D18B",
    blue: "#2F9BEB",
    orange: "#FFB257",
    red: "#FF6A6A",
    pink: "#FF7AC8",
  };
  const accent = accentMap[tierId] || accentMap.blue;
  const accentSoft = colorWithAlpha(accent, isDarkTheme ? 0.35 : 0.22);
  const accentText = isDarkTheme ? "#ECF7FF" : "#103252";
  const cardBg = isDarkTheme ? "rgba(9,16,28,0.96)" : "#F7FAFF";
  const cardBorder = colorWithAlpha(accent, isDarkTheme ? 0.32 : 0.2);
  const backdropColor = isDarkTheme ? "rgba(3,6,12,0.86)" : "rgba(5,18,34,0.45)";
  const gradientStart = isDarkTheme ? "#0C2036" : blendHexColors("#FFFFFF", accent, 0.12);
  const gradientEnd = isDarkTheme ? "#142C45" : "#FFFFFF";
  const gradientId = useRef(`health_reward_${Math.random().toString(36).slice(2, 8)}`).current;
  const ringId = useRef(`health_ring_${Math.random().toString(36).slice(2, 8)}`).current;
  const entryOpacity = useRef(new Animated.Value(0)).current;
  const entryTranslate = useRef(new Animated.Value(18)).current;
  const cardScale = useRef(new Animated.Value(0.96)).current;
  const coinScale = useRef(new Animated.Value(0.9)).current;
  const coinTilt = useRef(new Animated.Value(0)).current;
  const haloSpin = useRef(new Animated.Value(0)).current;
  const glowPulse = useRef(new Animated.Value(0)).current;
  const shineSweep = useRef(new Animated.Value(-1)).current;

  useEffect(() => {
    Animated.parallel([
      Animated.timing(entryOpacity, {
        toValue: 1,
        duration: 360,
        easing: Easing.out(Easing.cubic),
        useNativeDriver: true,
      }),
      Animated.timing(entryTranslate, {
        toValue: 0,
        duration: 360,
        easing: Easing.out(Easing.cubic),
        useNativeDriver: true,
      }),
      Animated.spring(cardScale, {
        toValue: 1,
        friction: 6,
        tension: 80,
        useNativeDriver: true,
      }),
    ]).start();

    const pulse = Animated.loop(
      Animated.sequence([
        Animated.timing(coinScale, {
          toValue: 1.03,
          duration: 520,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(coinScale, {
          toValue: 0.95,
          duration: 520,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    const tilt = Animated.loop(
      Animated.sequence([
        Animated.timing(coinTilt, {
          toValue: 1,
          duration: 1200,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(coinTilt, {
          toValue: 0,
          duration: 1200,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    const spin = Animated.loop(
      Animated.timing(haloSpin, {
        toValue: 1,
        duration: 7600,
        easing: Easing.linear,
        useNativeDriver: true,
      })
    );
    const glow = Animated.loop(
      Animated.sequence([
        Animated.timing(glowPulse, {
          toValue: 1,
          duration: 1400,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(glowPulse, {
          toValue: 0,
          duration: 1400,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    const shine = Animated.loop(
      Animated.sequence([
        Animated.delay(420),
        Animated.timing(shineSweep, {
          toValue: 1,
          duration: 920,
          easing: Easing.out(Easing.cubic),
          useNativeDriver: true,
        }),
        Animated.timing(shineSweep, {
          toValue: -1,
          duration: 0,
          useNativeDriver: true,
        }),
      ])
    );

    pulse.start();
    tilt.start();
    spin.start();
    glow.start();
    shine.start();

    return () => {
      pulse.stop();
      tilt.stop();
      spin.stop();
      glow.stop();
      shine.stop();
    };
  }, [
    cardScale,
    coinScale,
    coinTilt,
    entryOpacity,
    entryTranslate,
    glowPulse,
    haloSpin,
    shineSweep,
  ]);

  const haloRotation = haloSpin.interpolate({
    inputRange: [0, 1],
    outputRange: ["0deg", "360deg"],
  });
  const coinRotation = coinTilt.interpolate({
    inputRange: [0, 1],
    outputRange: ["-6deg", "6deg"],
  });
  const glowScale = glowPulse.interpolate({
    inputRange: [0, 1],
    outputRange: [0.96, 1.08],
  });
  const glowOpacity = glowPulse.interpolate({
    inputRange: [0, 1],
    outputRange: [0.4, 0.85],
  });
  const shineTranslate = shineSweep.interpolate({
    inputRange: [-1, 1],
    outputRange: [-70, 70],
  });

  return (
    <View style={styles.healthOverlay}>
      <View style={[styles.healthBackdrop, { backgroundColor: backdropColor }]} />
      <CoinRainOverlay dropCount={12} asset={rewardCoinTier?.asset || HEALTH_COIN_TIERS[0].asset} />
      <Animated.View
        style={[
          styles.healthCoinStage,
          { opacity: entryOpacity, transform: [{ translateY: entryTranslate }] },
        ]}
      >
        <Animated.View
          style={[
            styles.healthHalo,
            { opacity: glowOpacity, transform: [{ rotate: haloRotation }] },
          ]}
        >
          <Svg style={styles.healthHaloSvg} width="180" height="180">
            <Defs>
              <SvgLinearGradient id={ringId} x1="0" y1="0" x2="1" y2="1">
                <SvgStop offset="0" stopColor={accent} stopOpacity={0.95} />
                <SvgStop offset="1" stopColor={accentText} stopOpacity={0.45} />
              </SvgLinearGradient>
            </Defs>
            <SvgCircle cx="90" cy="90" r="62" stroke={`url(#${ringId})`} strokeWidth="3" fill="none" />
            <SvgCircle
              cx="90"
              cy="90"
              r="48"
              stroke={`url(#${ringId})`}
              strokeWidth="1.5"
              opacity="0.6"
              fill="none"
            />
          </Svg>
        </Animated.View>
        <Animated.View
          style={[
            styles.healthCoinWrap,
            { backgroundColor: accent, transform: [{ scale: coinScale }, { rotate: coinRotation }] },
          ]}
        >
          <Image source={rewardCoinTier.asset} style={styles.healthCoinImage} />
          <Animated.View
            pointerEvents="none"
            style={[
              styles.healthCoinShine,
              { transform: [{ translateX: shineTranslate }, { rotate: "18deg" }] },
            ]}
          />
        </Animated.View>
      </Animated.View>
      <Animated.View
        style={[
          styles.healthCard,
          { backgroundColor: cardBg, borderColor: cardBorder },
          { opacity: entryOpacity, transform: [{ translateY: entryTranslate }, { scale: cardScale }] },
        ]}
      >
        <Svg
          style={styles.healthCardGradient}
          width="100%"
          height="100%"
          preserveAspectRatio="xMidYMid slice"
        >
          <Defs>
            <SvgLinearGradient id={gradientId} x1="0" y1="0" x2="1" y2="1">
              <SvgStop offset="0" stopColor={gradientStart} stopOpacity={0.95} />
              <SvgStop offset="1" stopColor={gradientEnd} stopOpacity={0.9} />
            </SvgLinearGradient>
          </Defs>
          <SvgRect x="0" y="0" width="100%" height="100%" rx="28" ry="28" fill={`url(#${gradientId})`} />
        </Svg>
        <Animated.View
          style={[
            styles.healthCardOrb,
            { backgroundColor: accentSoft, opacity: glowOpacity, transform: [{ scale: glowScale }] },
          ]}
        />
        <Animated.View
          style={[
            styles.healthCardOrb,
            styles.healthCardOrbSecondary,
            { backgroundColor: accentSoft, opacity: glowOpacity, transform: [{ scale: glowScale }] },
          ]}
        />
        <View style={styles.healthCardContent}>
          <Text style={[styles.healthTitle, { color: colors.text }]}>
            {t("healthCelebrateTitle", { amount: titleAmount })}
          </Text>
          <Text style={[styles.healthSubtitle, { color: colors.muted }]}>{reason}</Text>
          {reason !== baseSubtitle && (
            <Text style={[styles.healthSubtitle, { color: colors.muted }]}>{baseSubtitle}</Text>
          )}
        </View>
      </Animated.View>
    </View>
  );
};

const HeartRain = ({ count = 26 }) => {
  const hearts = useMemo(
    () =>
      Array.from({ length: count }).map((_, index) => ({
        id: `rain_heart_${index}`,
        left: Math.random() * (SCREEN_WIDTH - 20),
        delay: Math.random() * 1400,
        duration: 2200 + Math.random() * 1600,
        size: 14 + Math.random() * 14,
        sway: 12 + Math.random() * 16,
        rotate: Math.random() * 40 - 20,
      })),
    [count]
  );
  return (
    <View style={styles.heartRain} pointerEvents="none">
      {hearts.map((heart) => (
        <FallingHeart key={heart.id} {...heart} />
      ))}
    </View>
  );
};

const FallingHeart = ({ left, delay, duration, size, sway, rotate }) => {
  const translateY = useRef(new Animated.Value(-40)).current;
  const translateX = useRef(new Animated.Value(0)).current;
  const opacity = useRef(new Animated.Value(0)).current;
  useEffect(() => {
    const drop = Animated.parallel([
      Animated.timing(translateY, {
        toValue: SCREEN_HEIGHT + 120,
        duration,
        easing: Easing.in(Easing.quad),
        useNativeDriver: true,
      }),
      Animated.sequence([
        Animated.timing(opacity, {
          toValue: 1,
          duration: Math.min(320, duration * 0.2),
          useNativeDriver: true,
        }),
        Animated.timing(opacity, {
          toValue: 0,
          duration: Math.min(420, duration * 0.3),
          delay: Math.max(duration * 0.4, 0),
          useNativeDriver: true,
        }),
      ]),
      Animated.sequence([
        Animated.timing(translateX, {
          toValue: sway,
          duration: duration * 0.5,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(translateX, {
          toValue: -sway,
          duration: duration * 0.5,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ]),
    ]);
    const anim = Animated.loop(Animated.sequence([Animated.delay(delay), drop]), {
      resetBeforeIteration: true,
    });
    anim.start();
    return () => anim.stop();
  }, [delay, duration, opacity, sway, translateX, translateY]);

  return (
    <AnimatedText
      style={[
        styles.heartRainDrop,
        {
          left,
          fontSize: size,
          opacity,
          transform: [{ translateY }, { translateX }, { rotate: `${rotate}deg` }],
        },
      ]}
    >
      â¤ï¸
    </AnimatedText>
  );
};

const GoalCelebration = ({ colors, payload, t, mascotHappySource, onClose }) => {
  const happySource = mascotHappySource || CLASSIC_TAMAGOTCHI_ANIMATIONS.happy;
  const data =
    payload && typeof payload === "object"
      ? payload
      : { title: payload || t("goalCelebrationTitle"), subtitle: t("goalCelebrationSubtitle") };
  const summary = data.summary || null;
  const currency = data.currency || DEFAULT_PROFILE.currency;
  const language = data.language || DEFAULT_LANGUAGE;
  const rewardCoins = Math.max(0, Number(data.rewardCoins) || 0);
  const rewardAsset = data.rewardAsset || GOAL_COMPLETION_REWARD_TIER?.asset || null;
  const totalSavedUSD =
    Number.isFinite(summary?.totalSavedUSD) && summary.totalSavedUSD > 0
      ? summary.totalSavedUSD
      : Number.isFinite(data.fallbackTotalUSD)
      ? data.fallbackTotalUSD
      : 0;
  const totalSavedLabel = formatCurrency(convertToCurrency(totalSavedUSD, currency), currency);
  const totalWins = summary?.totalCount || 0;
  const totalDays = summary?.daysCount || 0;
  const strongDay = summary?.strongDay || null;
  const weakDay = summary?.weakDay || null;
  const breakdown = summary?.breakdown || [];
  const resolveDayLabel = (dayKey) => {
    if (!dayKey) return "";
    const ts = parseDayKey(dayKey)?.getTime();
    return formatRelativeDayLabel(ts, Date.now(), language) || dayKey;
  };
  const formatAmount = (amountUSD) =>
    formatCurrency(convertToCurrency(Math.max(0, amountUSD || 0), currency), currency);
  const strongLabel = strongDay ? resolveDayLabel(strongDay.dayKey) : "";
  const strongAmount = strongDay ? formatAmount(strongDay.savedUSD) : "";
  const strongBody = strongDay
    ? strongDay.topTitle
      ? t("goalCelebrationStrongBody", {
          dayLabel: strongLabel,
          amount: strongAmount,
          count: strongDay.count || 0,
          title: strongDay.topTitle,
        })
      : t("goalCelebrationStrongBodyNoTitle", {
          dayLabel: strongLabel,
          amount: strongAmount,
          count: strongDay.count || 0,
        })
    : t("goalCelebrationStrongFallback");
  const weakLabel = weakDay ? resolveDayLabel(weakDay.dayKey) : "";
  const weakAmount = weakDay ? formatAmount(weakDay.savedUSD) : "";
  const weakBody = weakDay
    ? summary?.weakMode === "spend" && (weakDay.spendCount || 0) > 0
      ? t("goalCelebrationWeakBody", {
          dayLabel: weakLabel,
          spends: weakDay.spendCount || 0,
          amount: weakAmount,
          count: weakDay.count || 0,
        })
      : t("goalCelebrationWeakBodyNoSpends", {
          dayLabel: weakLabel,
          amount: weakAmount,
          count: weakDay.count || 0,
        })
    : t("goalCelebrationWeakFallback");
  const weekBars = summary?.lastSevenDays || [];
  const maxWeekSaved = summary?.maxWeekSavedUSD || 0;
  const isDarkTheme = colors.background === THEMES.dark.background;
  const backdropColor = isDarkTheme ? "rgba(0,0,0,0.85)" : "rgba(7,44,23,0.85)";
  const cardBg = isDarkTheme ? lightenColor(colors.card, 0.15) : "#E7FFE9";
  const cardBorder = isDarkTheme ? lightenColor(colors.border, 0.25) : "#8FD7AE";
  const accent = isDarkTheme ? "#7CFFB0" : "#18B86A";
  return (
    <View style={styles.goalCelebrateOverlay}>
      <View style={[styles.goalCelebrateBackdrop, { backgroundColor: backdropColor }]} />
      <HeartRain />
      <View style={[styles.goalCelebrateCard, { backgroundColor: cardBg, borderColor: cardBorder }]}>
        <ScrollView contentContainerStyle={styles.goalCelebrateContent} showsVerticalScrollIndicator={false}>
          <View style={styles.goalCelebrateHeader}>
            <Image source={happySource} style={styles.goalCelebrateCat} />
            <View style={styles.goalCelebrateHeaderText}>
              <Text style={[styles.goalCelebrateTitle, { color: colors.text }]}>
                {data.title || t("goalCelebrationTitle")}
              </Text>
              <Text style={[styles.goalCelebrateSubtitle, { color: colors.muted }]}>
                {data.subtitle || t("goalCelebrationSubtitle")}
              </Text>
            </View>
          </View>
          {data.targetLabel ? (
            <View style={[styles.goalCelebrateBadge, { borderColor: cardBorder }]}>
              <Text style={[styles.goalCelebrateBadgeText, { color: colors.text }]}>
                {data.targetLabel}
              </Text>
            </View>
          ) : null}
          <View style={[styles.goalCelebrateTotal, { borderColor: cardBorder }]}>
            <Text style={[styles.goalCelebrateTotalLabel, { color: colors.muted }]}>
              {t("goalCelebrationTotalLabel")}
            </Text>
            <Text style={[styles.goalCelebrateTotalValue, { color: colors.text }]}>
              {totalSavedLabel}
            </Text>
            <Text style={[styles.goalCelebrateTotalSub, { color: colors.muted }]}>
              {t("goalCelebrationTotalSub", { wins: totalWins, days: totalDays })}
            </Text>
            <Text style={[styles.goalCelebratePraise, { color: colors.text }]}>
              {t("goalCelebrationPraise")}
            </Text>
            {rewardCoins > 0 && rewardAsset ? (
              <View style={[styles.goalCelebrateRewardRow, { backgroundColor: "rgba(0,0,0,0.06)" }]}>
                <Image source={rewardAsset} style={styles.goalCelebrateRewardCoin} />
                <Text style={[styles.goalCelebrateRewardText, { color: colors.text }]}>
                  {t("saveOverlayCoinReward", { amount: rewardCoins })}
                </Text>
              </View>
            ) : null}
          </View>
          <View style={styles.goalCelebrateStatsRow}>
            <View style={[styles.goalCelebrateStatCard, { borderColor: cardBorder }]}>
              <Text style={[styles.goalCelebrateStatLabel, { color: colors.muted }]}>
                {t("goalCelebrationTotalWinsLabel")}
              </Text>
              <Text style={[styles.goalCelebrateStatValue, { color: colors.text }]}>
                {totalWins}
              </Text>
            </View>
            <View style={[styles.goalCelebrateStatCard, { borderColor: cardBorder }]}>
              <Text style={[styles.goalCelebrateStatLabel, { color: colors.muted }]}>
                {t("goalCelebrationTotalDaysLabel")}
              </Text>
              <Text style={[styles.goalCelebrateStatValue, { color: colors.text }]}>
                {totalDays}
              </Text>
            </View>
          </View>
          {weekBars.length ? (
            <View style={styles.goalCelebrateWeek}>
              <Text style={[styles.goalCelebrateSectionLabel, { color: colors.muted }]}>
                {t("goalCelebrationWeekLabel")}
              </Text>
              <View style={styles.goalCelebrateWeekBars}>
                {weekBars.map((entry) => {
                  const ratio = maxWeekSaved > 0 ? entry.savedUSD / maxWeekSaved : 0;
                  const height = 8 + 32 * ratio;
                  return (
                    <View key={entry.dayKey} style={styles.goalCelebrateWeekBarWrap}>
                      <View
                        style={[
                          styles.goalCelebrateWeekBar,
                          {
                            height,
                            backgroundColor: entry.savedUSD > 0 ? accent : "rgba(0,0,0,0.08)",
                          },
                        ]}
                      />
                    </View>
                  );
                })}
              </View>
            </View>
          ) : null}
          <View style={styles.goalCelebrateInsights}>
            <View style={[styles.goalCelebrateInsightCard, { borderColor: cardBorder }]}>
              <View style={styles.goalCelebrateInsightHeader}>
                <Text style={styles.goalCelebrateInsightIcon}>ðŸ”¥</Text>
                <Text style={[styles.goalCelebrateInsightTitle, { color: colors.text }]}>
                  {t("goalCelebrationStrongTitle")}
                </Text>
              </View>
              <Text style={[styles.goalCelebrateInsightBody, { color: colors.muted }]}>
                {strongBody}
              </Text>
            </View>
            <View style={[styles.goalCelebrateInsightCard, { borderColor: cardBorder }]}>
              <View style={styles.goalCelebrateInsightHeader}>
                <Text style={styles.goalCelebrateInsightIcon}>ðŸŒ§ï¸</Text>
                <Text style={[styles.goalCelebrateInsightTitle, { color: colors.text }]}>
                  {t("goalCelebrationWeakTitle")}
                </Text>
              </View>
              <Text style={[styles.goalCelebrateInsightBody, { color: colors.muted }]}>
                {weakBody}
              </Text>
            </View>
          </View>
          {breakdown.length ? (
            <View style={styles.goalCelebrateBreakdown}>
              <Text style={[styles.goalCelebrateSectionLabel, { color: colors.muted }]}>
                {t("goalCelebrationBreakdownLabel")}
              </Text>
              <View style={styles.goalCelebrateBreakdownList}>
                {breakdown.map((entry) => (
                  <View key={entry.title} style={styles.goalCelebrateBreakdownRow}>
                    <Text style={[styles.goalCelebrateBreakdownTitle, { color: colors.text }]}>
                      {entry.title}
                    </Text>
                    <Text style={[styles.goalCelebrateBreakdownMeta, { color: colors.muted }]}>
                      {t("goalCelebrationBreakdownItem", {
                        count: entry.count || 0,
                        amount: formatAmount(entry.savedUSD || 0),
                      })}
                    </Text>
                  </View>
                ))}
              </View>
            </View>
          ) : null}
          <TouchableOpacity style={[styles.goalCelebrateCta, { backgroundColor: colors.text }]} onPress={onClose}>
            <Text style={[styles.goalCelebrateCtaText, { color: colors.background }]}>
              {t("goalCelebrationCta")}
            </Text>
          </TouchableOpacity>
        </ScrollView>
      </View>
    </View>
  );
};

const DailyRewardCelebration = ({ colors, payload, t }) => {
  const rewardLabel = payload?.amount || "";
  const amountValue =
    typeof payload === "object" && Number.isFinite(payload?.amountValue)
      ? payload.amountValue
      : 0;
  const coinTier = getHealthCoinTierForAmount(amountValue) || HEALTH_COIN_TIERS[0];
  const reason = payload?.reason || "";
  const isDarkTheme = colors.background === THEMES.dark.background;
  const cardBg = isDarkTheme ? lightenColor(colors.card, 0.12) : "#FFF7EC";
  const cardBorder = isDarkTheme ? lightenColor(colors.border, 0.3) : "#FFD0A6";
  const badgeBg = isDarkTheme ? "rgba(255,210,140,0.2)" : "rgba(255,170,90,0.2)";
  const accent = isDarkTheme ? "#FFD06A" : "#FF9B4A";
  return (
    <View style={styles.dailyRewardOverlay} pointerEvents="none">
      <View style={[styles.dailyRewardBackdrop, { backgroundColor: isDarkTheme ? "rgba(0,0,0,0.82)" : "rgba(255,241,225,0.92)" }]} />
      <View style={[styles.dailyRewardCard, { backgroundColor: cardBg, borderColor: cardBorder }]}>
        <View style={[styles.dailyRewardBadge, { backgroundColor: badgeBg, borderColor: cardBorder }]}>
          <Text style={[styles.dailyRewardBadgeText, { color: colors.text }]}>
            {t("dailyRewardButtonLabel")}
          </Text>
        </View>
        <View style={styles.dailyRewardHero}>
          <View style={[styles.dailyRewardCoinWrap, { backgroundColor: accent }]}>
            <Image source={coinTier.asset} style={styles.dailyRewardCoinLarge} />
          </View>
          <Text style={[styles.dailyRewardAmountLarge, { color: colors.text }]}>
            {rewardLabel ? `+${rewardLabel}` : t("dailyRewardCelebrateMessage", { amount: "" })}
          </Text>
          <Text style={[styles.dailyRewardTitle, { color: colors.text }]}>
            {t("dailyRewardButtonLabel")}
          </Text>
        </View>
        {reason ? (
          <Text style={[styles.dailyRewardReason, { color: colors.muted }]}>{reason}</Text>
        ) : null}
        <View style={[styles.dailyRewardFooter, { borderColor: cardBorder }]}>
          <Text style={[styles.dailyRewardHint, { color: colors.muted }]}>
            {t("dailyRewardCollectedLabel")}
          </Text>
        </View>
      </View>
    </View>
  );
};

const UsageStreakWeeklyRewardCelebration = ({
  colors,
  payload,
  t,
  language,
  mascotHappySource,
  onClose,
}) => {
  const data = payload && typeof payload === "object" ? payload : {};
  const days = Math.max(0, Number(data.days) || Number(data.count) || 0);
  const weekIndex = Math.max(1, Math.floor(days / USAGE_STREAK_WEEKLY_BONUS_DAYS));
  let rewardBlueCoins = Math.max(0, Number(data.rewardBlueCoins) || Number(data.blueCoins) || 0);
  if (!rewardBlueCoins && days) {
    const computed = computeUsageStreakWeeklyBonus(days);
    rewardBlueCoins = Math.max(0, Number(computed?.rewardBlueCoins) || 0);
  }
  const labels = HEALTH_COIN_LABELS[language] || HEALTH_COIN_LABELS.en;
  const blueLabel = labels.blue || "blue coins";
  const happySource = mascotHappySource || CLASSIC_TAMAGOTCHI_ANIMATIONS.happy;
  const isDarkTheme = colors.background === THEMES.dark.background;
  const cardBg = isDarkTheme ? "rgba(9,16,28,0.96)" : "#F6FBFF";
  const cardBorder = isDarkTheme ? "rgba(255,255,255,0.12)" : "rgba(32,86,140,0.16)";
  const accent = isDarkTheme ? "#6FD3FF" : "#2F9BEB";
  const accentSoft = isDarkTheme ? "rgba(72,164,255,0.35)" : "rgba(74,160,255,0.22)";
  const accentText = isDarkTheme ? "#E8F7FF" : "#0B3A66";
  const badgeBg = isDarkTheme ? "rgba(111,211,255,0.18)" : "rgba(47,155,235,0.12)";
  const backdropColor = isDarkTheme ? "rgba(3,6,12,0.86)" : "rgba(4,20,38,0.55)";
  const gradientId = useRef(`weekly_reward_${Math.random().toString(36).slice(2, 8)}`).current;
  const ringId = useRef(`weekly_ring_${Math.random().toString(36).slice(2, 8)}`).current;
  const entryOpacity = useRef(new Animated.Value(0)).current;
  const entryTranslate = useRef(new Animated.Value(18)).current;
  const cardScale = useRef(new Animated.Value(0.95)).current;
  const coinScale = useRef(new Animated.Value(0.92)).current;
  const coinTilt = useRef(new Animated.Value(0)).current;
  const haloSpin = useRef(new Animated.Value(0)).current;
  const glowPulse = useRef(new Animated.Value(0)).current;
  const catFloat = useRef(new Animated.Value(0)).current;
  const shineSweep = useRef(new Animated.Value(-1)).current;
  const didHapticRef = useRef(false);

  useEffect(() => {
    Animated.parallel([
      Animated.timing(entryOpacity, {
        toValue: 1,
        duration: 360,
        easing: Easing.out(Easing.cubic),
        useNativeDriver: true,
      }),
      Animated.timing(entryTranslate, {
        toValue: 0,
        duration: 360,
        easing: Easing.out(Easing.cubic),
        useNativeDriver: true,
      }),
      Animated.spring(cardScale, {
        toValue: 1,
        friction: 6,
        tension: 80,
        useNativeDriver: true,
      }),
    ]).start();

    const coinPulse = Animated.loop(
      Animated.sequence([
        Animated.timing(coinScale, {
          toValue: 1.02,
          duration: 520,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(coinScale, {
          toValue: 0.96,
          duration: 520,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    const tilt = Animated.loop(
      Animated.sequence([
        Animated.timing(coinTilt, {
          toValue: 1,
          duration: 1200,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(coinTilt, {
          toValue: 0,
          duration: 1200,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    const spin = Animated.loop(
      Animated.timing(haloSpin, {
        toValue: 1,
        duration: 7200,
        easing: Easing.linear,
        useNativeDriver: true,
      })
    );
    const glow = Animated.loop(
      Animated.sequence([
        Animated.timing(glowPulse, {
          toValue: 1,
          duration: 1400,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(glowPulse, {
          toValue: 0,
          duration: 1400,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    const float = Animated.loop(
      Animated.sequence([
        Animated.timing(catFloat, {
          toValue: -6,
          duration: 900,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(catFloat, {
          toValue: 6,
          duration: 900,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    const shine = Animated.loop(
      Animated.sequence([
        Animated.delay(420),
        Animated.timing(shineSweep, {
          toValue: 1,
          duration: 920,
          easing: Easing.out(Easing.cubic),
          useNativeDriver: true,
        }),
        Animated.timing(shineSweep, {
          toValue: -1,
          duration: 0,
          useNativeDriver: true,
        }),
      ])
    );

    coinPulse.start();
    tilt.start();
    spin.start();
    glow.start();
    float.start();
    shine.start();

    return () => {
      coinPulse.stop();
      tilt.stop();
      spin.stop();
      glow.stop();
      float.stop();
      shine.stop();
    };
  }, [
    cardScale,
    catFloat,
    coinScale,
    coinTilt,
    entryOpacity,
    entryTranslate,
    glowPulse,
    haloSpin,
    shineSweep,
  ]);

  useEffect(() => {
    if (didHapticRef.current) return undefined;
    didHapticRef.current = true;
    triggerSuccessHaptic();
    const timerId = setTimeout(() => {
      triggerCoinRewardHaptics();
    }, 140);
    return () => clearTimeout(timerId);
  }, []);

  const haloRotation = haloSpin.interpolate({
    inputRange: [0, 1],
    outputRange: ["0deg", "360deg"],
  });
  const coinRotation = coinTilt.interpolate({
    inputRange: [0, 1],
    outputRange: ["-6deg", "6deg"],
  });
  const glowScale = glowPulse.interpolate({
    inputRange: [0, 1],
    outputRange: [0.96, 1.08],
  });
  const glowOpacity = glowPulse.interpolate({
    inputRange: [0, 1],
    outputRange: [0.45, 0.85],
  });
  const shineTranslate = shineSweep.interpolate({
    inputRange: [-1, 1],
    outputRange: [-70, 70],
  });
  const handleClose = useCallback(() => {
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    onClose?.();
  }, [onClose]);

  return (
    <View style={styles.usageStreakWeeklyOverlay}>
      <View style={[styles.usageStreakWeeklyBackdrop, { backgroundColor: backdropColor }]} />
      <CoinRainOverlay dropCount={16} asset={BLUE_HEALTH_COIN_ASSET || HEALTH_COIN_TIERS[0].asset} />
      <Animated.View
        style={[
          styles.usageStreakWeeklyCard,
          { backgroundColor: cardBg, borderColor: cardBorder },
          { opacity: entryOpacity, transform: [{ translateY: entryTranslate }, { scale: cardScale }] },
        ]}
      >
        <Svg
          style={styles.usageStreakWeeklyCardGradient}
          width="100%"
          height="100%"
          preserveAspectRatio="xMidYMid slice"
        >
          <Defs>
            <SvgLinearGradient id={gradientId} x1="0" y1="0" x2="1" y2="1">
              <SvgStop
                offset="0"
                stopColor={isDarkTheme ? "#0C223A" : "#E1F0FF"}
                stopOpacity={0.95}
              />
              <SvgStop
                offset="1"
                stopColor={isDarkTheme ? "#132B48" : "#FFFFFF"}
                stopOpacity={0.9}
              />
            </SvgLinearGradient>
          </Defs>
          <SvgRect x="0" y="0" width="100%" height="100%" rx="30" ry="30" fill={`url(#${gradientId})`} />
        </Svg>
        <Animated.View
          style={[
            styles.usageStreakWeeklyOrb,
            { backgroundColor: accentSoft, opacity: glowOpacity, transform: [{ scale: glowScale }] },
          ]}
        />
        <Animated.View
          style={[
            styles.usageStreakWeeklyOrb,
            styles.usageStreakWeeklyOrbSecondary,
            { backgroundColor: accentSoft, opacity: glowOpacity, transform: [{ scale: glowScale }] },
          ]}
        />
        <View style={styles.usageStreakWeeklyBadgeRow}>
          <View style={[styles.usageStreakWeeklyBadge, { backgroundColor: badgeBg, borderColor: cardBorder }]}>
            <Text style={[styles.usageStreakWeeklyBadgeText, { color: accentText }]}>
              {t("usageStreakWeeklyBadge", { week: weekIndex, days: USAGE_STREAK_WEEKLY_BONUS_DAYS })}
            </Text>
          </View>
        </View>
        <View style={styles.usageStreakWeeklyHero}>
          <View style={styles.usageStreakWeeklyCoinStage}>
            <Animated.View
              style={[
                styles.usageStreakWeeklyHalo,
                { opacity: glowOpacity, transform: [{ rotate: haloRotation }] },
              ]}
            >
              <Svg style={styles.usageStreakWeeklyHaloSvg} width="150" height="150">
                <Defs>
                  <SvgLinearGradient id={ringId} x1="0" y1="0" x2="1" y2="1">
                    <SvgStop offset="0" stopColor={accent} stopOpacity={0.95} />
                    <SvgStop offset="1" stopColor={accentText} stopOpacity={0.45} />
                  </SvgLinearGradient>
                </Defs>
                <SvgCircle cx="75" cy="75" r="54" stroke={`url(#${ringId})`} strokeWidth="3" fill="none" />
                <SvgCircle
                  cx="75"
                  cy="75"
                  r="42"
                  stroke={`url(#${ringId})`}
                  strokeWidth="1.5"
                  opacity="0.6"
                  fill="none"
                />
              </Svg>
            </Animated.View>
            <Animated.View
              style={[
                styles.usageStreakWeeklyCoinWrap,
                { backgroundColor: accent, transform: [{ scale: coinScale }, { rotate: coinRotation }] },
              ]}
            >
              {BLUE_HEALTH_COIN_ASSET ? (
                <Image source={BLUE_HEALTH_COIN_ASSET} style={styles.usageStreakWeeklyCoin} />
              ) : (
                <Text style={styles.usageStreakWeeklyCoinFallback}>ðŸŸ¦</Text>
              )}
              <Animated.View
                pointerEvents="none"
                style={[
                  styles.usageStreakWeeklyCoinShine,
                  { transform: [{ translateX: shineTranslate }, { rotate: "18deg" }] },
                ]}
              />
            </Animated.View>
          </View>
          <Animated.Image
            source={happySource}
            style={[styles.usageStreakWeeklyCat, { transform: [{ translateY: catFloat }] }]}
            resizeMode="contain"
          />
        </View>
        <View style={styles.usageStreakWeeklyAmountRow}>
          <Text style={[styles.usageStreakWeeklyAmount, { color: colors.text }]}>+{rewardBlueCoins}</Text>
          <View style={[styles.usageStreakWeeklyAmountPill, { backgroundColor: badgeBg, borderColor: cardBorder }]}>
            <Text style={[styles.usageStreakWeeklyAmountPillText, { color: accentText }]}>
              {blueLabel}
            </Text>
          </View>
        </View>
        <Text style={[styles.usageStreakWeeklyRewardLabel, { color: colors.muted }]}>
          {t("usageStreakWeeklyRewardLabel")}
        </Text>
        <Text style={[styles.usageStreakWeeklyTitle, { color: colors.text }]}>
          {t("usageStreakWeeklyTitle", { week: weekIndex, days })}
        </Text>
        {days ? (
          <Text style={[styles.usageStreakWeeklySubtitle, { color: colors.muted }]}>
            {t("usageStreakWeeklySubtitle", { days })}
          </Text>
        ) : null}
        <Text style={[styles.usageStreakWeeklyThanks, { color: colors.text }]}>
          {t("usageStreakWeeklyThanks")}
        </Text>
        <Text style={[styles.usageStreakWeeklyMotivation, { color: colors.muted }]}>
          {t("usageStreakWeeklyMotivation")}
        </Text>
        <TouchableOpacity
          style={[styles.usageStreakWeeklyButton, { backgroundColor: colors.text }]}
          onPress={handleClose}
          activeOpacity={0.9}
        >
          <Text style={[styles.usageStreakWeeklyButtonText, { color: colors.background }]}>
            {t("usageStreakWeeklyButton")}
          </Text>
        </TouchableOpacity>
      </Animated.View>
    </View>
  );
};

const StreakPledgeRewardCelebration = ({ colors, payload, t, language, onClose }) => {
  const data = payload && typeof payload === "object" ? payload : {};
  const targetDays = Math.max(0, Number(data.targetDays) || Number(data.days) || 0);
  let rewardBlueCoins = Math.max(0, Number(data.rewardBlueCoins) || 0);
  if (!rewardBlueCoins) {
    const computed = computeStreakPledgeReward(targetDays);
    rewardBlueCoins = computed.blueCoins;
  }
  const labels = HEALTH_COIN_LABELS[language] || HEALTH_COIN_LABELS.en;
  const blueLabel = labels.blue || "blue coins";
  const isDarkTheme = colors.background === THEMES.dark.background;
  const cardBg = isDarkTheme ? "rgba(9,18,30,0.96)" : "#F4F9FF";
  const cardBorder = isDarkTheme ? "rgba(255,255,255,0.12)" : "rgba(30,82,138,0.16)";
  const accent = isDarkTheme ? "#7ED9FF" : "#2D9CDB";
  const accentSoft = isDarkTheme ? "rgba(97,196,255,0.35)" : "rgba(62,145,235,0.22)";
  const accentText = isDarkTheme ? "#E8F7FF" : "#0B3A66";
  const badgeBg = isDarkTheme ? "rgba(126,217,255,0.18)" : "rgba(45,156,219,0.12)";
  const backdropColor = isDarkTheme ? "rgba(3,7,12,0.86)" : "rgba(6,24,46,0.55)";
  const gradientId = useRef(`pledge_reward_${Math.random().toString(36).slice(2, 8)}`).current;
  const ringId = useRef(`pledge_ring_${Math.random().toString(36).slice(2, 8)}`).current;
  const entryOpacity = useRef(new Animated.Value(0)).current;
  const entryTranslate = useRef(new Animated.Value(16)).current;
  const cardScale = useRef(new Animated.Value(0.96)).current;
  const coinScale = useRef(new Animated.Value(0.92)).current;
  const coinTilt = useRef(new Animated.Value(0)).current;
  const haloSpin = useRef(new Animated.Value(0)).current;
  const glowPulse = useRef(new Animated.Value(0)).current;
  const shineSweep = useRef(new Animated.Value(-1)).current;
  const didHapticRef = useRef(false);

  useEffect(() => {
    Animated.parallel([
      Animated.timing(entryOpacity, {
        toValue: 1,
        duration: 360,
        easing: Easing.out(Easing.cubic),
        useNativeDriver: true,
      }),
      Animated.timing(entryTranslate, {
        toValue: 0,
        duration: 360,
        easing: Easing.out(Easing.cubic),
        useNativeDriver: true,
      }),
      Animated.spring(cardScale, {
        toValue: 1,
        friction: 6,
        tension: 80,
        useNativeDriver: true,
      }),
    ]).start();

    const coinPulse = Animated.loop(
      Animated.sequence([
        Animated.timing(coinScale, {
          toValue: 1.02,
          duration: 520,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(coinScale, {
          toValue: 0.96,
          duration: 520,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    const tilt = Animated.loop(
      Animated.sequence([
        Animated.timing(coinTilt, {
          toValue: 1,
          duration: 1200,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(coinTilt, {
          toValue: 0,
          duration: 1200,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    const spin = Animated.loop(
      Animated.timing(haloSpin, {
        toValue: 1,
        duration: 7400,
        easing: Easing.linear,
        useNativeDriver: true,
      })
    );
    const glow = Animated.loop(
      Animated.sequence([
        Animated.timing(glowPulse, {
          toValue: 1,
          duration: 1400,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(glowPulse, {
          toValue: 0,
          duration: 1400,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    const shine = Animated.loop(
      Animated.sequence([
        Animated.delay(420),
        Animated.timing(shineSweep, {
          toValue: 1,
          duration: 920,
          easing: Easing.out(Easing.cubic),
          useNativeDriver: true,
        }),
        Animated.timing(shineSweep, {
          toValue: -1,
          duration: 0,
          useNativeDriver: true,
        }),
      ])
    );

    coinPulse.start();
    tilt.start();
    spin.start();
    glow.start();
    shine.start();

    return () => {
      coinPulse.stop();
      tilt.stop();
      spin.stop();
      glow.stop();
      shine.stop();
    };
  }, [cardScale, coinScale, coinTilt, entryOpacity, entryTranslate, glowPulse, haloSpin, shineSweep]);

  useEffect(() => {
    if (didHapticRef.current) return undefined;
    didHapticRef.current = true;
    triggerSuccessHaptic();
    const timerId = setTimeout(() => {
      triggerCoinRewardHaptics();
    }, 140);
    return () => clearTimeout(timerId);
  }, []);

  const haloRotation = haloSpin.interpolate({
    inputRange: [0, 1],
    outputRange: ["0deg", "360deg"],
  });
  const coinRotation = coinTilt.interpolate({
    inputRange: [0, 1],
    outputRange: ["-6deg", "6deg"],
  });
  const glowScale = glowPulse.interpolate({
    inputRange: [0, 1],
    outputRange: [0.96, 1.08],
  });
  const glowOpacity = glowPulse.interpolate({
    inputRange: [0, 1],
    outputRange: [0.45, 0.85],
  });
  const shineTranslate = shineSweep.interpolate({
    inputRange: [-1, 1],
    outputRange: [-70, 70],
  });
  const handleClose = useCallback(() => {
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    onClose?.();
  }, [onClose]);

  return (
    <View style={styles.streakPledgeRewardOverlay}>
      <View style={[styles.streakPledgeRewardBackdrop, { backgroundColor: backdropColor }]} />
      <CoinRainOverlay dropCount={12} asset={BLUE_HEALTH_COIN_ASSET || HEALTH_COIN_TIERS[0].asset} />
      <Animated.View
        style={[
          styles.streakPledgeRewardCard,
          { backgroundColor: cardBg, borderColor: cardBorder },
          { opacity: entryOpacity, transform: [{ translateY: entryTranslate }, { scale: cardScale }] },
        ]}
      >
        <Svg
          style={styles.streakPledgeRewardGradient}
          width="100%"
          height="100%"
          preserveAspectRatio="xMidYMid slice"
        >
          <Defs>
            <SvgLinearGradient id={gradientId} x1="0" y1="0" x2="1" y2="1">
              <SvgStop
                offset="0"
                stopColor={isDarkTheme ? "#0D233A" : "#E4F2FF"}
                stopOpacity={0.95}
              />
              <SvgStop
                offset="1"
                stopColor={isDarkTheme ? "#142C48" : "#FFFFFF"}
                stopOpacity={0.9}
              />
            </SvgLinearGradient>
          </Defs>
          <SvgRect x="0" y="0" width="100%" height="100%" rx="30" ry="30" fill={`url(#${gradientId})`} />
        </Svg>
        <Animated.View
          style={[
            styles.streakPledgeRewardOrb,
            { backgroundColor: accentSoft, opacity: glowOpacity, transform: [{ scale: glowScale }] },
          ]}
        />
        <View style={styles.streakPledgeRewardHero}>
          <View style={styles.streakPledgeRewardCoinStage}>
            <Animated.View
              style={[
                styles.streakPledgeRewardHalo,
                { opacity: glowOpacity, transform: [{ rotate: haloRotation }] },
              ]}
            >
              <Svg style={styles.streakPledgeRewardHaloSvg} width="150" height="150">
                <Defs>
                  <SvgLinearGradient id={ringId} x1="0" y1="0" x2="1" y2="1">
                    <SvgStop offset="0" stopColor={accent} stopOpacity={0.95} />
                    <SvgStop offset="1" stopColor={accentText} stopOpacity={0.45} />
                  </SvgLinearGradient>
                </Defs>
                <SvgCircle cx="75" cy="75" r="54" stroke={`url(#${ringId})`} strokeWidth="3" fill="none" />
                <SvgCircle
                  cx="75"
                  cy="75"
                  r="42"
                  stroke={`url(#${ringId})`}
                  strokeWidth="1.5"
                  opacity="0.6"
                  fill="none"
                />
              </Svg>
            </Animated.View>
            <Animated.View
              style={[
                styles.streakPledgeRewardCoinWrap,
                { backgroundColor: accent, transform: [{ scale: coinScale }, { rotate: coinRotation }] },
              ]}
            >
              {BLUE_HEALTH_COIN_ASSET ? (
                <Image source={BLUE_HEALTH_COIN_ASSET} style={styles.streakPledgeRewardCoin} />
              ) : (
                <Text style={styles.streakPledgeRewardCoinFallback}>ðŸŸ¦</Text>
              )}
              <Animated.View
                pointerEvents="none"
                style={[
                  styles.streakPledgeRewardCoinShine,
                  { transform: [{ translateX: shineTranslate }, { rotate: "18deg" }] },
                ]}
              />
            </Animated.View>
          </View>
          <View style={styles.streakPledgeRewardAmountRow}>
            <Text style={[styles.streakPledgeRewardAmount, { color: colors.text }]}>+{rewardBlueCoins}</Text>
            <View style={[styles.streakPledgeRewardAmountPill, { backgroundColor: badgeBg, borderColor: cardBorder }]}>
              <Text style={[styles.streakPledgeRewardAmountPillText, { color: accentText }]}>
                {blueLabel}
              </Text>
            </View>
          </View>
        </View>
        <Text style={[styles.streakPledgeRewardTitle, { color: colors.text }]}>
          {t("streakPledgeRewardTitle")}
        </Text>
        <Text style={[styles.streakPledgeRewardSubtitle, { color: colors.muted }]}>
          {t("streakPledgeRewardSubtitle", { days: targetDays })}
        </Text>
        <TouchableOpacity
          style={[
            styles.streakPledgeRewardButton,
            {
              borderColor: colors.text,
              backgroundColor: isDarkTheme ? "rgba(255,255,255,0.06)" : "rgba(255,255,255,0.7)",
            },
          ]}
          onPress={handleClose}
          activeOpacity={0.9}
        >
          <Text style={[styles.streakPledgeRewardButtonText, { color: colors.text }]}>
            {t("streakPledgeRewardButton")}
          </Text>
        </TouchableOpacity>
      </Animated.View>
    </View>
  );
};

const StreakPledgePrompt = ({
  colors,
  payload,
  t,
  language,
  options = [],
  mascotHappySource,
  onConfirm,
  onDismiss,
}) => {
  const [selectedId, setSelectedId] = useState(options[0]?.id || null);
  const selectedOption = useMemo(
    () => options.find((option) => option.id === selectedId) || null,
    [options, selectedId]
  );
  const labels = HEALTH_COIN_LABELS[language] || HEALTH_COIN_LABELS.en;
  const isDarkTheme = colors.background === THEMES.dark.background;
  const cardBg = isDarkTheme ? lightenColor(colors.card, 0.08) : colors.card;
  const cardBorder = isDarkTheme ? lightenColor(colors.border, 0.25) : colors.border;
  const bubbleBg = isDarkTheme ? "rgba(9,12,18,0.95)" : "#FFFFFF";
  const bubbleBorder = isDarkTheme ? "rgba(255,255,255,0.16)" : "rgba(0,0,0,0.08)";
  const bubbleText = isDarkTheme ? "#F6EBDD" : "#2B1C0D";
  const mascotSource = mascotHappySource || CLASSIC_TAMAGOTCHI_ANIMATIONS.happy;
  return (
    <View style={styles.streakPledgeOverlay}>
      <View
        style={[
          styles.streakPledgeBackdrop,
          { backgroundColor: isDarkTheme ? "rgba(0,0,0,0.86)" : "rgba(8,8,14,0.55)" },
        ]}
      />
      <View style={[styles.streakPledgeCard, { backgroundColor: cardBg, borderColor: cardBorder }]}>
        <View style={styles.streakPledgeHeader}>
          <View style={[styles.streakPledgeBubble, { backgroundColor: bubbleBg, borderColor: bubbleBorder }]}>
            <Text style={[styles.streakPledgeBubbleText, { color: bubbleText }]}>
              {t("streakPledgePromptTitle")}
            </Text>
            <View style={[styles.streakPledgeBubbleTail, { backgroundColor: bubbleBg, borderColor: bubbleBorder }]} />
          </View>
          <Image source={mascotSource} style={styles.streakPledgeMascot} resizeMode="contain" />
        </View>
        <Text style={[styles.streakPledgeSubtitle, { color: colors.muted }]}>
          {t("streakPledgePromptSubtitle")}
        </Text>
        <View style={styles.streakPledgeOptions}>
          {options.map((option) => {
            const active = selectedId === option.id;
            const reward = computeStreakPledgeReward(option.days);
            return (
              <TouchableOpacity
                key={option.id}
                style={[
                  styles.streakPledgeOption,
                  {
                    borderColor: active ? colors.text : colors.border,
                    backgroundColor: active ? colors.text : "transparent",
                  },
                ]}
                onPress={() => setSelectedId(option.id)}
                activeOpacity={0.85}
                >
                  <Text
                    style={[
                      styles.streakPledgeOptionLabel,
                      { color: active ? colors.background : colors.text },
                    ]}
                  >
                    {t(option.labelKey)}
                  </Text>
                  <View style={styles.streakPledgeOptionRewardRow}>
                    <Text
                      style={[
                        styles.streakPledgeOptionReward,
                        { color: active ? colors.background : colors.muted },
                      ]}
                    >
                      {reward.blueCoins}
                    </Text>
                    {BLUE_HEALTH_COIN_ASSET ? (
                      <Image
                        source={BLUE_HEALTH_COIN_ASSET}
                        style={[
                          styles.streakPledgeOptionRewardIcon,
                          { opacity: active ? 1 : 0.9 },
                        ]}
                      />
                    ) : (
                      <Text
                        style={[
                          styles.streakPledgeOptionRewardIconFallback,
                          { opacity: active ? 1 : 0.9 },
                        ]}
                      >
                        ðŸŸ¦
                      </Text>
                    )}
                  </View>
                </TouchableOpacity>
              );
          })}
        </View>
        <TouchableOpacity
          style={[
            styles.streakPledgePrimaryButton,
            {
              backgroundColor: colors.text,
              opacity: selectedOption ? 1 : 0.6,
            },
          ]}
          onPress={() => onConfirm?.(selectedOption, payload)}
          disabled={!selectedOption}
          activeOpacity={0.85}
        >
          <Text style={[styles.streakPledgePrimaryText, { color: colors.background }]}>
            {t("streakPledgeConfirmButton")}
          </Text>
        </TouchableOpacity>
        <TouchableOpacity onPress={onDismiss} style={styles.streakPledgeSecondaryButton}>
          <Text style={[styles.streakPledgeSecondaryText, { color: colors.muted }]}>
            {t("streakPledgeLater")}
          </Text>
        </TouchableOpacity>
      </View>
    </View>
  );
};

const UsageStreakCelebration = ({
  colors,
  payload,
  t,
  language,
  mascotHappySource,
}) => {
  const data = payload && typeof payload === "object" ? payload : {};
  const rawCount = Number(data.count);
  const count = Math.max(1, Number.isFinite(rawCount) ? rawCount : 1);
  const previousCount = Math.max(0, Number(data.previousCount) || 0);
  const missed = !!data.missed;
  const lostCount = Math.max(0, Number(data.lostCount) || 0, previousCount);
  const displayCount = missed ? (previousCount > 0 ? previousCount : lostCount || count) : count;
  const timestamp = Number.isFinite(data.timestamp) ? data.timestamp : Date.now();
  const fallbackDayKey = getDayKey(timestamp);
  const missedDayKey =
    typeof data.missedDayKey === "string" && data.missedDayKey
      ? data.missedDayKey
      : missed
      ? getDayKey(timestamp - DAY_MS)
      : null;
  const dayKey = typeof data.dayKey === "string" && data.dayKey ? data.dayKey : fallbackDayKey;
  const streakEndDayKey =
    typeof data.streakEndDayKey === "string" && data.streakEndDayKey
      ? data.streakEndDayKey
      : dayKey;
  const resolvedDayKey = missed && missedDayKey ? missedDayKey : dayKey;
  const resolvedDate = resolvedDayKey ? parseDayKey(resolvedDayKey) : null;
  const dayIndex = resolvedDate instanceof Date && !Number.isNaN(resolvedDate.getTime())
    ? resolvedDate.getDay()
    : new Date(timestamp).getDay();
  const mondayIndex = (dayIndex + 6) % 7;
  const streakEndDate = streakEndDayKey ? parseDayKey(streakEndDayKey) : null;
  const streakEndTimestamp =
    streakEndDate instanceof Date && !Number.isNaN(streakEndDate.getTime())
      ? streakEndDate.getTime()
      : timestamp;
  const weekLabels = WEEKDAY_LABELS_MONDAY_FIRST[language] || WEEKDAY_LABELS_MONDAY_FIRST.en;
  const isDarkTheme = colors.background === THEMES.dark.background;
  const accent = missed
    ? isDarkTheme
      ? "#9CA3AF"
      : "#B6BDC9"
    : isDarkTheme
    ? "#FFB347"
    : "#FF8C3C";
  const accentSoft = missed
    ? isDarkTheme
      ? "rgba(148,163,184,0.22)"
      : "rgba(176,186,198,0.28)"
    : isDarkTheme
    ? "rgba(255,179,90,0.25)"
    : "rgba(255,183,104,0.28)";
  const accentGlow = missed
    ? isDarkTheme
      ? "rgba(148,163,184,0.35)"
      : "rgba(176,186,198,0.3)"
    : isDarkTheme
    ? "rgba(255,186,110,0.4)"
    : "rgba(255,179,105,0.5)";
  const cardBg = isDarkTheme ? "rgba(15,14,16,0.96)" : "#FFF7E8";
  const cardBorder = isDarkTheme ? "rgba(255,205,145,0.35)" : "rgba(255,172,104,0.45)";
  const bubbleBg = isDarkTheme ? "rgba(9,10,14,0.92)" : "#FFFFFF";
  const bubbleBorder = isDarkTheme ? "rgba(255,255,255,0.18)" : "rgba(0,0,0,0.08)";
  const bubbleText = isDarkTheme ? "#FCE7C8" : "#2A1A0B";
  const bubbleCopy = missed ? t("usageStreakLostBubble") : t("usageStreakBubble");
  const streakDayAccent = isDarkTheme ? "#7FE4AC" : SAVE_ACTION_COLOR;
  const streakDayGlow = colorWithAlpha(streakDayAccent, isDarkTheme ? 0.45 : 0.4);
  const streakDayText = "#FFFFFF";
  const mutedDayBg = isDarkTheme ? "rgba(255,255,255,0.08)" : "rgba(0,0,0,0.05)";
  const mutedDayBorder = isDarkTheme ? "rgba(255,255,255,0.12)" : "rgba(0,0,0,0.08)";
  const missedDayBg = isDarkTheme ? "rgba(255,255,255,0.12)" : "rgba(0,0,0,0.08)";
  const missedDayBorder = isDarkTheme ? "rgba(255,255,255,0.22)" : "rgba(0,0,0,0.14)";
  const missedMarkColor = isDarkTheme ? "rgba(255,255,255,0.9)" : "rgba(45,45,45,0.8)";
  const counterDigitBackground = isDarkTheme ? "rgba(255,255,255,0.08)" : "rgba(255,255,255,0.92)";
  const counterDigitBorder = isDarkTheme ? "rgba(255,255,255,0.14)" : "rgba(0,0,0,0.08)";
  const counterDividerColor = isDarkTheme ? "rgba(255,255,255,0.16)" : "rgba(0,0,0,0.12)";
  const counterTextColor = missed ? (isDarkTheme ? "#E5E7EB" : "#4B5563") : accent;
  const activeWeekIndices = useMemo(() => {
    const indices = new Set();
    const streakLength = Math.max(1, Number(displayCount) || 1);
    const limit = Math.min(streakLength, 7);
    if (!Number.isFinite(streakEndTimestamp) || limit <= 0) return indices;
    const baseDate = new Date(streakEndTimestamp);
    baseDate.setHours(0, 0, 0, 0);
    const baseDayMs = baseDate.getTime();
    if (Number.isNaN(baseDayMs)) return indices;
    const baseDayIndex = baseDate.getDay();
    const mondayOffset = (baseDayIndex + 6) % 7;
    const weekStartMs = baseDayMs - mondayOffset * DAY_MS;
    for (let i = 0; i < limit; i += 1) {
      const dayMs = baseDayMs - i * DAY_MS;
      if (dayMs < weekStartMs) break;
      const dayKey = getDayKey(dayMs);
      if (!dayKey) continue;
      const dayDate = parseDayKey(dayKey);
      if (!dayDate) continue;
      const index = (dayDate.getDay() + 6) % 7;
      indices.add(index);
    }
    return indices;
  }, [displayCount, streakEndTimestamp]);
  const counterSlots = useMemo(
    () => buildUsageStreakCounterSlots(displayCount, language),
    [displayCount, language]
  );
  const [counterActive, setCounterActive] = useState(false);
  useEffect(() => {
    setCounterActive(false);
    const timer = setTimeout(() => setCounterActive(true), 120);
    return () => clearTimeout(timer);
  }, [displayCount]);
  const flameScale = useRef(new Animated.Value(0.7)).current;
  const flameGlow = useRef(new Animated.Value(0)).current;
  const numberScale = useRef(new Animated.Value(0.4)).current;
  const flameOpacity = useRef(new Animated.Value(1)).current;
  const smokeOpacity = useRef(new Animated.Value(0)).current;
  const smokeScale = useRef(new Animated.Value(0.9)).current;
  const dayGlow = useRef(new Animated.Value(0)).current;
  useEffect(() => {
    flameScale.setValue(0.8);
    numberScale.setValue(0.4);
    dayGlow.setValue(0);
    flameGlow.setValue(missed ? 0.8 : 0.2);
    flameOpacity.setValue(1);
    smokeOpacity.setValue(0);
    smokeScale.setValue(0.9);
    const numberIn = Animated.spring(numberScale, {
      toValue: 1,
      friction: 6,
      tension: 90,
      useNativeDriver: true,
    });
    if (missed) {
      numberIn.start();
      const extinguish = Animated.sequence([
        Animated.timing(flameScale, {
          toValue: 1.05,
          duration: 220,
          easing: Easing.out(Easing.cubic),
          useNativeDriver: true,
        }),
        Animated.parallel([
          Animated.timing(flameScale, {
            toValue: 0.85,
            duration: 380,
            easing: Easing.in(Easing.quad),
            useNativeDriver: true,
          }),
          Animated.timing(flameOpacity, {
            toValue: 0,
            duration: 360,
            easing: Easing.in(Easing.quad),
            useNativeDriver: true,
          }),
          Animated.timing(flameGlow, {
            toValue: 0,
            duration: 360,
            easing: Easing.in(Easing.quad),
            useNativeDriver: true,
          }),
        ]),
        Animated.parallel([
          Animated.timing(smokeOpacity, {
            toValue: 0.65,
            duration: 220,
            easing: Easing.out(Easing.cubic),
            useNativeDriver: true,
          }),
          Animated.spring(smokeScale, {
            toValue: 1.1,
            friction: 6,
            tension: 90,
            useNativeDriver: true,
          }),
        ]),
        Animated.timing(smokeOpacity, {
          toValue: 0,
          duration: 260,
          easing: Easing.out(Easing.cubic),
          useNativeDriver: true,
        }),
      ]);
      extinguish.start();
      return () => {
        extinguish.stop();
      };
    }
    const flameLoop = Animated.loop(
      Animated.sequence([
        Animated.timing(flameScale, {
          toValue: 1.08,
          duration: 420,
          useNativeDriver: true,
        }),
        Animated.timing(flameScale, {
          toValue: 0.95,
          duration: 420,
          useNativeDriver: true,
        }),
      ])
    );
    const glowLoop = Animated.loop(
      Animated.sequence([
        Animated.timing(flameGlow, {
          toValue: 1,
          duration: 360,
          useNativeDriver: true,
        }),
        Animated.timing(flameGlow, {
          toValue: 0.25,
          duration: 420,
          useNativeDriver: true,
        }),
      ])
    );
    const dayLoop = Animated.loop(
      Animated.sequence([
        Animated.timing(dayGlow, {
          toValue: 1,
          duration: 520,
          useNativeDriver: true,
        }),
        Animated.timing(dayGlow, {
          toValue: 0,
          duration: 520,
          useNativeDriver: true,
        }),
      ])
    );
    numberIn.start();
    flameLoop.start();
    glowLoop.start();
    dayLoop.start();
    return () => {
      flameLoop.stop();
      glowLoop.stop();
      dayLoop.stop();
    };
  }, [
    dayGlow,
    flameGlow,
    flameOpacity,
    flameScale,
    missed,
    numberScale,
    smokeOpacity,
    smokeScale,
  ]);
  const dayGlowScale = dayGlow.interpolate({
    inputRange: [0, 1],
    outputRange: [1, 1.22],
  });
  const dayGlowOpacity = dayGlow.interpolate({
    inputRange: [0, 1],
    outputRange: [0.5, 1],
  });
  const resolveDayLabel = useCallback(
    (value) => {
      const safeCount = Math.max(1, Number(value) || 1);
      const normalized = normalizeLanguage(language);
      if (normalized === "ru") {
        const mod10 = safeCount % 10;
        const mod100 = safeCount % 100;
        if (mod10 === 1 && mod100 !== 11) return "Ð´ÐµÐ½ÑŒ Ð² ÑƒÐ´Ð°Ñ€Ðµ";
        if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
          return "Ð´Ð½Ñ Ð² ÑƒÐ´Ð°Ñ€Ðµ";
        }
        return "Ð´Ð½ÐµÐ¹ Ð² ÑƒÐ´Ð°Ñ€Ðµ";
      }
      if (normalized === "es") return safeCount === 1 ? "dÃ­a de racha" : "dÃ­as de racha";
      if (normalized === "fr") return safeCount === 1 ? "jour de sÃ©rie" : "jours de sÃ©rie";
      return "day streak";
    },
    [language]
  );
  const dayLabel = useMemo(() => resolveDayLabel(displayCount), [displayCount, resolveDayLabel]);
  const happySource = mascotHappySource || CLASSIC_TAMAGOTCHI_ANIMATIONS.happy;
  return (
    <View style={styles.usageStreakOverlay}>
      <View style={[styles.usageStreakBackdrop, { backgroundColor: isDarkTheme ? "rgba(0,0,0,0.86)" : "rgba(8,8,14,0.55)" }]} />
      <View style={[styles.usageStreakCard, { backgroundColor: cardBg, borderColor: cardBorder }]}>
        <View style={[styles.usageStreakAura, { backgroundColor: accentSoft }]} />
        <View style={[styles.usageStreakBubble, { backgroundColor: bubbleBg, borderColor: bubbleBorder }]}>
          <Text style={[styles.usageStreakBubbleText, { color: bubbleText }]}>
            {bubbleCopy}
          </Text>
          <View style={[styles.usageStreakBubbleTail, { backgroundColor: bubbleBg, borderColor: bubbleBorder }]} />
        </View>
        <Animated.View style={[styles.usageStreakFlameWrap, { transform: [{ scale: flameScale }] }]}>
          <Animated.View
            style={[
              styles.usageStreakFlameGlow,
              {
                backgroundColor: accentGlow,
                opacity: flameGlow,
              },
            ]}
          />
          <Animated.Text style={[styles.usageStreakFlame, { opacity: flameOpacity }]}>ðŸ”¥</Animated.Text>
          {missed && (
            <Animated.Text
              style={[
                styles.usageStreakSmoke,
                { opacity: smokeOpacity, transform: [{ scale: smokeScale }] },
              ]}
            >
              ðŸ’¨
            </Animated.Text>
          )}
        </Animated.View>
        <Animated.View style={[styles.usageStreakNumberWrap, { transform: [{ scale: numberScale }] }]}>
          <View style={styles.usageStreakCounterRow}>
            {counterSlots.map((slot, index) => {
              if (slot.type === "digit") {
                return (
                  <UsageStreakCounterDigit
                    key={`${slot.key}-${counterActive}`}
                    index={index}
                    digit={slot.value}
                    delay={index * 90}
                    active={counterActive}
                    color={counterTextColor}
                    backgroundColor={counterDigitBackground}
                    borderColor={counterDigitBorder}
                    dividerColor={counterDividerColor}
                  />
                );
              }
              return (
                <View key={slot.key} style={styles.usageStreakCounterSeparator}>
                  <Text style={[styles.usageStreakCounterSeparatorText, { color: counterTextColor }]}>
                    {slot.value}
                  </Text>
                </View>
              );
            })}
          </View>
        </Animated.View>
        <Text style={[styles.usageStreakNumberLabel, { color: colors.text }]}>{dayLabel}</Text>
        <View style={styles.usageStreakWeekRow}>
          {weekLabels.map((label, index) => {
            const isMissedDay = missed && index === mondayIndex;
            const isActive = activeWeekIndices.has(index) && !isMissedDay;
            const dayBg = isActive ? streakDayAccent : isMissedDay ? missedDayBg : mutedDayBg;
            const dayBorder = isActive ? streakDayAccent : isMissedDay ? missedDayBorder : mutedDayBorder;
            return (
              <View
                key={`${label}_${index}`}
                style={[
                  styles.usageStreakWeekDay,
                  {
                    backgroundColor: dayBg,
                    borderColor: dayBorder,
                  },
                ]}
              >
                {isActive && (
                  <Animated.View
                    style={[
                      styles.usageStreakWeekGlow,
                      {
                        backgroundColor: streakDayGlow,
                        opacity: dayGlowOpacity,
                        transform: [{ scale: dayGlowScale }],
                      },
                    ]}
                  />
                )}
                {isMissedDay && (
                  <Text style={[styles.usageStreakMissedMark, { color: missedMarkColor }]}>âœ•</Text>
                )}
                <Text
                  style={[
                    styles.usageStreakWeekLabel,
                    { color: isActive ? streakDayText : colors.muted, opacity: isMissedDay ? 0.5 : 1 },
                  ]}
                >
                  {label}
                </Text>
              </View>
            );
          })}
        </View>
        <Image source={happySource} style={styles.usageStreakCat} resizeMode="contain" />
        <Text style={[styles.usageStreakHint, { color: colors.muted }]}>
          {t("usageStreakSubtitle")}
        </Text>
      </View>
    </View>
  );
};

const UsageStreakRestorePrompt = ({
  colors,
  payload,
  t,
  language,
  healthPoints = 0,
  onRestore = null,
}) => {
  const {
    shouldOfferRestore,
    canRestore,
    costLabel,
    missedDays,
    lostCount,
    streakEndDayKey,
    hasLoggedToday,
  } = resolveUsageStreakRestoreDetails(payload, { healthPoints, language });
  const isDarkTheme = colors.background === THEMES.dark.background;
  const bubbleBg = isDarkTheme ? "rgba(9,10,14,0.92)" : "#FFFFFF";
  const bubbleBorder = isDarkTheme ? "rgba(255,255,255,0.18)" : "rgba(0,0,0,0.08)";
  const restorePulse = useRef(new Animated.Value(1)).current;
  useEffect(() => {
    if (!shouldOfferRestore) return undefined;
    const pulse = Animated.loop(
      Animated.sequence([
        Animated.timing(restorePulse, {
          toValue: 1.1,
          duration: 420,
          useNativeDriver: true,
        }),
        Animated.timing(restorePulse, {
          toValue: 1,
          duration: 420,
          useNativeDriver: true,
        }),
      ])
    );
    pulse.start();
    return () => pulse.stop();
  }, [restorePulse, shouldOfferRestore]);
  const handleRestorePress = useCallback(() => {
    if (!shouldOfferRestore) return;
    if (!canRestore || typeof onRestore !== "function") return;
    onRestore({ lostCount, missedDays, streakEndDayKey, hasLoggedToday });
  }, [canRestore, hasLoggedToday, lostCount, missedDays, onRestore, shouldOfferRestore, streakEndDayKey]);
  if (!shouldOfferRestore) return null;
  return (
    <View style={styles.usageStreakOverlay}>
      <View
        style={[
          styles.usageStreakBackdrop,
          { backgroundColor: isDarkTheme ? "rgba(0,0,0,0.86)" : "rgba(8,8,14,0.55)" },
        ]}
      />
      <View
        style={[
          styles.usageStreakRestoreCard,
          { backgroundColor: bubbleBg, borderColor: bubbleBorder },
        ]}
      >
        <Text style={[styles.usageStreakRestoreTitle, { color: colors.text }]}>
          {t("usageStreakRestoreTitle")}
        </Text>
        <Text style={[styles.usageStreakRestoreSubtitle, { color: colors.muted }]}>
          {t("usageStreakRestoreSubtitle", { days: missedDays, cost: costLabel })}
        </Text>
        <View style={styles.usageStreakRestoreCostRow}>
          {BLUE_HEALTH_COIN_ASSET ? (
            <Animated.Image
              source={BLUE_HEALTH_COIN_ASSET}
              style={[
                styles.usageStreakRestoreCoin,
                { transform: [{ scale: restorePulse }] },
              ]}
            />
          ) : (
            <Animated.Text
              style={[
                styles.usageStreakRestoreCoinFallback,
                { transform: [{ scale: restorePulse }] },
              ]}
            >
              ðŸŸ¦
            </Animated.Text>
          )}
          <Text style={[styles.usageStreakRestoreCostText, { color: colors.text }]}>
            {costLabel}
          </Text>
        </View>
        <TouchableOpacity
          style={[
            styles.usageStreakRestoreButton,
            { backgroundColor: colors.text },
            !canRestore && styles.usageStreakRestoreButtonDisabled,
          ]}
          onPress={handleRestorePress}
          disabled={!canRestore}
          activeOpacity={0.85}
        >
          <Text
            style={[
              styles.usageStreakRestoreButtonText,
              { color: colors.background },
              !canRestore && styles.usageStreakRestoreButtonTextDisabled,
            ]}
          >
            {t("usageStreakRestoreButton")}
          </Text>
        </TouchableOpacity>
        {!canRestore && (
          <Text style={[styles.usageStreakRestoreNeed, { color: colors.muted }]}>
            {t("usageStreakRestoreNeedCoins", { cost: costLabel })}
          </Text>
        )}
      </View>
    </View>
  );
};

const FeatureUnlockCelebration = ({ colors, payload, t, tamagotchiAnimations, onDismiss }) => {
  const happySource = tamagotchiAnimations?.happy || CLASSIC_TAMAGOTCHI_ANIMATIONS.happy;
  const messageText = typeof payload === "object" ? payload?.body || "" : payload || "";
  const variantKey = typeof payload === "object" ? payload?.variant || null : null;
  const variant = variantKey ? FEATURE_UNLOCK_VARIANT_CONFIG[variantKey] : null;
  const whereLabel = t("featureUnlockWhereLabel");
  const previewSectionLabel = t("featureUnlockPreviewLabel");
  const sectionTitle = variant ? t(variant.titleKey) : "";
  const sectionDescription = variant ? t(variant.descriptionKey) : "";
  const compactLayout = IS_SHORT_DEVICE || IS_COMPACT_DEVICE || IS_EXTRA_COMPACT_DEVICE;
  const normalizedHeroCopy = compactUnlockCopy(
    stripUnlockLevelPrefix(messageText),
    compactLayout ? 112 : 128
  );
  const heroTitleText = compactUnlockCopy(
    sectionTitle || normalizedHeroCopy || messageText,
    compactLayout ? 58 : 72
  );
  const heroSubtitleText =
    sectionTitle &&
    normalizedHeroCopy &&
    sectionTitle.trim().toLowerCase() !== normalizedHeroCopy.trim().toLowerCase()
      ? normalizedHeroCopy
      : "";
  const compactSectionDescription = compactUnlockCopy(sectionDescription, compactLayout ? 110 : 124);
  const previewBadgeLabel = variant ? t(variant.previewLabelKey) : "";
  const previewActionLabel = variantKey === "rewardsDaily" ? t("dailyRewardClaimHint") : null;
  const entryAnim = useRef(new Animated.Value(0)).current;
  const glowAnim = useRef(new Animated.Value(0)).current;
  const catFloatAnim = useRef(new Animated.Value(0)).current;
  useEffect(() => {
    entryAnim.setValue(0);
    glowAnim.setValue(0);
    catFloatAnim.setValue(0);
    const entry = Animated.spring(entryAnim, {
      toValue: 1,
      damping: 18,
      stiffness: 200,
      mass: 0.95,
      useNativeDriver: true,
    });
    const glow = Animated.loop(
      Animated.sequence([
        Animated.timing(glowAnim, {
          toValue: 1,
          duration: 1800,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(glowAnim, {
          toValue: 0,
          duration: 1800,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    const catFloat = Animated.loop(
      Animated.sequence([
        Animated.timing(catFloatAnim, {
          toValue: 1,
          duration: 1500,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(catFloatAnim, {
          toValue: 0,
          duration: 1500,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    entry.start();
    glow.start();
    catFloat.start();
    return () => {
      entry.stop();
      glow.stop();
      catFloat.stop();
    };
  }, [catFloatAnim, entryAnim, glowAnim]);
  const isDarkTheme = colors.background === THEMES.dark.background;
  const cardBg = isDarkTheme ? "rgba(10,17,32,0.94)" : "rgba(255,255,255,0.98)";
  const cardBorder = isDarkTheme ? "rgba(124,188,255,0.32)" : "rgba(73,141,248,0.26)";
  const sectionBg = isDarkTheme ? "rgba(255,255,255,0.04)" : "rgba(69,133,245,0.06)";
  const isPremiumVariant = FEATURE_UNLOCK_PREMIUM_VARIANTS.has(variantKey);
  const unlockLevel = FEATURE_UNLOCK_LEVELS[variantKey] || null;
  const heroBadgeText = isPremiumVariant
    ? t("featureLockedPremiumLabel")
    : unlockLevel
    ? t("featureLockedLevelLabel", { level: unlockLevel })
    : t("profileOk");
  const cardTranslateY = entryAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [26, 0],
  });
  const cardScale = entryAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0.94, 1],
  });
  const heroGlowOpacity = glowAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0.4, 0.78],
  });
  const heroGlowScale = glowAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0.9, 1.15],
  });
  const catTranslateY = catFloatAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0, -6],
  });
  const content = (
    <>
      <View style={styles.featureUnlockHeader}>
        <Animated.View
          pointerEvents="none"
          style={[
            styles.featureUnlockHeroGlow,
            {
              opacity: heroGlowOpacity,
              transform: [{ scale: heroGlowScale }],
              backgroundColor: isDarkTheme ? "rgba(104,181,255,0.36)" : "rgba(122,193,255,0.5)",
            },
          ]}
        />
        <View style={styles.featureUnlockHeroRow}>
          <Animated.Image
            source={happySource}
            style={[styles.featureUnlockCat, { transform: [{ translateY: catTranslateY }] }]}
            resizeMode="contain"
          />
          <View style={styles.featureUnlockHeroCopy}>
            <View style={[styles.featureUnlockBadge, { borderColor: cardBorder }]}>
              <Text style={[styles.featureUnlockBadgeText, { color: colors.text }]}>{heroBadgeText}</Text>
            </View>
            <Text
              style={[styles.featureUnlockMessage, { color: colors.text }]}
              numberOfLines={2}
            >
              {heroTitleText}
            </Text>
            {heroSubtitleText ? (
              <Text
                style={[styles.featureUnlockMessageSub, { color: colors.muted }]}
                numberOfLines={compactLayout ? 3 : 4}
              >
                {heroSubtitleText}
              </Text>
            ) : null}
          </View>
        </View>
      </View>
      {variant ? (
        <View style={[styles.featureUnlockSection, { backgroundColor: sectionBg, borderColor: cardBorder }]}>
          <Text style={[styles.featureUnlockSectionLabel, { color: colors.muted }]}>{whereLabel}</Text>
          <Text style={[styles.featureUnlockSectionTitle, { color: colors.text }]}>{sectionTitle}</Text>
          <Text
            style={[styles.featureUnlockSectionDescription, { color: colors.muted }]}
            numberOfLines={compactLayout ? 3 : 4}
          >
            {compactSectionDescription}
          </Text>
          <Text style={[styles.featureUnlockSectionLabel, { color: colors.muted, marginTop: 14 }]}>
            {previewSectionLabel}
          </Text>
          <FeatureUnlockIllustration
            variantKey={variantKey}
            colors={colors}
            label={previewBadgeLabel}
            actionLabel={previewActionLabel}
            t={t}
          />
        </View>
      ) : null}
      <TouchableOpacity style={[styles.featureUnlockButton, { backgroundColor: colors.text }]} onPress={onDismiss}>
        <Text style={[styles.featureUnlockButtonText, { color: colors.background }]}>
          {t("profileOk") || "ÐžÐº"}
        </Text>
      </TouchableOpacity>
    </>
  );
  return (
    <Animated.View
      style={[
        styles.featureUnlockCard,
        compactLayout && styles.featureUnlockCardCompact,
        {
          backgroundColor: cardBg,
          borderColor: cardBorder,
          opacity: entryAnim,
          transform: [{ translateY: cardTranslateY }, { scale: cardScale }],
        },
      ]}
    >
      <ScrollView
        contentContainerStyle={styles.featureUnlockCardScroll}
        showsVerticalScrollIndicator={false}
        keyboardShouldPersistTaps="handled"
        alwaysBounceVertical={false}
      >
        {content}
      </ScrollView>
    </Animated.View>
  );
};

const FeatureUnlockIllustration = ({ variantKey, colors, label, actionLabel, t }) => {
  if (!variantKey || !FEATURE_UNLOCK_VARIANT_CONFIG[variantKey]) return null;
  const pulseAnim = useRef(new Animated.Value(0)).current;
  useEffect(() => {
    pulseAnim.setValue(0);
    const pulse = Animated.loop(
      Animated.sequence([
        Animated.timing(pulseAnim, {
          toValue: 1,
          duration: 1500,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(pulseAnim, {
          toValue: 0,
          duration: 1500,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    pulse.start();
    return () => pulse.stop();
  }, [pulseAnim]);

  const resolveTabLabel = (key, fallback) => {
    const resolved = typeof t === "function" ? t(key) : fallback;
    const text = typeof resolved === "string" ? resolved.trim() : "";
    return text || fallback;
  };

  const isDarkTheme = colors.background === THEMES.dark.background;
  const variantPalette = {
    rewardsDaily: { accent: "#57B8FF", accentSoft: "#8EEBD2", emoji: "ðŸŽ", tabId: "feed" },
    feedFocus: { accent: "#7489FF", accentSoft: "#8EEBD2", emoji: "âš¡", tabId: "feed" },
    rewardsCustomization: { accent: "#F5A34C", accentSoft: "#FFD693", emoji: "ðŸ†", tabId: "purchases" },
    catCustomization: { accent: "#7AA7FF", accentSoft: "#A6F0D5", emoji: "ðŸ¾", tabId: "feed" },
    reports: { accent: "#6F9BFF", accentSoft: "#9FD3FF", emoji: "ðŸ“ˆ", tabId: "profile" },
    rewardsChallenges: { accent: "#F39A4E", accentSoft: "#FFD89B", emoji: "ðŸŽ¯", tabId: "purchases" },
    impulseMap: { accent: "#6E83FF", accentSoft: "#80E0FF", emoji: "ðŸ—ºï¸", tabId: "cart" },
    thinkingList: { accent: "#9B8BFF", accentSoft: "#A4F1D2", emoji: "ðŸ’­", tabId: "pending" },
    freeDay: { accent: "#5DB8FF", accentSoft: "#7DE8C2", emoji: "ðŸ”¥", tabId: "cart" },
  };
  const palette = variantPalette[variantKey] || variantPalette.rewardsCustomization;
  const accent = palette.accent;
  const accentSoft = palette.accentSoft;
  const baseLineColor = isDarkTheme ? "rgba(255,255,255,0.2)" : "rgba(14,32,64,0.14)";
  const borderColor = isDarkTheme ? "rgba(255,255,255,0.08)" : "rgba(43,74,126,0.12)";
  const surface = isDarkTheme ? "rgba(8,14,28,0.88)" : "rgba(255,255,255,0.96)";
  const phoneSurface = isDarkTheme ? "rgba(9,16,30,0.86)" : "#F8FBFF";
  const navSurface = isDarkTheme ? "rgba(255,255,255,0.03)" : "rgba(67,83,255,0.06)";
  const textPrimary = isDarkTheme ? "#EAF2FF" : "#1F2F56";
  const textMuted = isDarkTheme ? "rgba(220,234,255,0.72)" : "rgba(31,47,86,0.62)";
  const tabItems = [
    { id: "feed", label: resolveTabLabel("feedTab", "Feed") },
    { id: "cart", label: resolveTabLabel("wishlistTab", "Progress") },
    { id: "pending", label: resolveTabLabel("pendingTab", "Thinking") },
    { id: "purchases", label: resolveTabLabel("purchasesTitle", "Rewards") },
    { id: "profile", label: resolveTabLabel("profileTab", "Profile") },
  ];
  const glowScale = pulseAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0.92, 1.12],
  });
  const glowOpacity = pulseAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0.26, 0.56],
  });
  const badgeScale = pulseAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [1, 1.04],
  });

  const renderInfoRows = (rows = 2) =>
    Array.from({ length: rows }).map((_, index) => (
      <View
        key={`mini_line_${index}`}
        style={[
          styles.featureUnlockMiniLine,
          { width: `${88 - index * 12}%`, backgroundColor: baseLineColor },
        ]}
      />
    ));

  const renderMiniNavBar = (activeTabId) => (
    <View style={[styles.featureUnlockMiniNav, { backgroundColor: navSurface, borderColor }]}>
      {tabItems.map((tab) => {
        const active = tab.id === activeTabId;
        return (
          <View
            key={tab.id}
            style={[
              styles.featureUnlockMiniNavItem,
              active && styles.featureUnlockMiniNavItemActive,
              active && { backgroundColor: colorWithAlpha(accent, isDarkTheme ? 0.34 : 0.2) },
            ]}
          >
            <Text
              style={[
                styles.featureUnlockMiniNavLabel,
                { color: active ? textPrimary : textMuted },
                active && styles.featureUnlockMiniNavLabelActive,
              ]}
              numberOfLines={1}
            >
              {tab.label}
            </Text>
          </View>
        );
      })}
    </View>
  );

  const renderMiniScreen = (content, activeTabId, headerLabel) => (
    <View style={[styles.featureUnlockMiniPhone, { backgroundColor: phoneSurface, borderColor }]}>
      <View style={[styles.featureUnlockMiniStatusRow, { borderColor }]}>
        <View style={styles.featureUnlockMiniStatusDots}>
          <View style={[styles.featureUnlockMiniStatusDot, { backgroundColor: baseLineColor }]} />
          <View style={[styles.featureUnlockMiniStatusDot, { backgroundColor: baseLineColor }]} />
          <View style={[styles.featureUnlockMiniStatusDot, { backgroundColor: baseLineColor }]} />
        </View>
        <Text style={[styles.featureUnlockMiniStatusTitle, { color: textMuted }]} numberOfLines={1}>
          {headerLabel}
        </Text>
        <View style={styles.featureUnlockMiniStatusDots}>
          <View style={[styles.featureUnlockMiniStatusDot, { backgroundColor: baseLineColor }]} />
          <View style={[styles.featureUnlockMiniStatusDot, { backgroundColor: baseLineColor }]} />
        </View>
      </View>
      <View style={styles.featureUnlockMiniBody}>{content}</View>
      {renderMiniNavBar(activeTabId)}
    </View>
  );

  const rewardsDailyTitle = compactUnlockCopy(
    label || resolveTabLabel("featureUnlockRewardsDailyTitle", "Daily reward"),
    22
  );
  const rewardsDailyAction = compactUnlockCopy(
    actionLabel || resolveTabLabel("dailyRewardModalCTA", "Collect"),
    16
  );

  const renderVariantScene = () => {
    switch (variantKey) {
      case "rewardsDaily":
        return renderMiniScreen(
          <>
            <View style={[styles.featureUnlockMiniHeroCard, { borderColor, backgroundColor: colorWithAlpha(accent, isDarkTheme ? 0.18 : 0.1) }]}>
              <Image source={LEVEL_SHARE_CAT} style={styles.featureUnlockMiniHeroCat} />
              <View style={styles.featureUnlockMiniHeroCopy}>
                <Text style={[styles.featureUnlockMiniHeroTitle, { color: textPrimary }]}>
                  {resolveTabLabel("feedTab", "Feed")}
                </Text>
                <Text style={[styles.featureUnlockMiniHeroSubtitle, { color: textMuted }]}>
                  {compactUnlockCopy(resolveTabLabel("featureUnlockRewardsDailyPreview", "Daily reward"), 24)}
                </Text>
              </View>
            </View>
            <View style={[styles.featureUnlockMiniModalCard, { borderColor }]}>
              <Text style={[styles.featureUnlockMiniModalTitle, { color: textPrimary }]}>
                {rewardsDailyTitle}
              </Text>
              <View style={styles.featureUnlockMiniRewardRow}>
                <Image source={HEALTH_COIN_TIERS[0].asset} style={styles.featureUnlockRewardCoin} />
                <Text style={[styles.featureUnlockRewardAmount, { color: textPrimary }]}>+1</Text>
                <View style={[styles.featureUnlockMiniActionButton, { backgroundColor: accent }]}>
                  <Text style={styles.featureUnlockMiniActionText} numberOfLines={1}>
                    {rewardsDailyAction}
                  </Text>
                </View>
              </View>
            </View>
            {renderInfoRows(1)}
          </>,
          "feed",
          resolveTabLabel("feedTab", "Feed")
        );
      case "feedFocus":
        return renderMiniScreen(
          <>
            <View style={styles.featureUnlockMiniChipRow}>
              <View style={[styles.featureUnlockMiniChip, { backgroundColor: colorWithAlpha(accent, isDarkTheme ? 0.3 : 0.18), borderColor }]}>
                <Text style={[styles.featureUnlockMiniChipText, { color: textPrimary }]}>Focus</Text>
              </View>
              <View style={[styles.featureUnlockMiniChip, { backgroundColor: colorWithAlpha(accentSoft, isDarkTheme ? 0.26 : 0.2), borderColor }]}>
                <Text style={[styles.featureUnlockMiniChipText, { color: textPrimary }]}>Summary</Text>
              </View>
            </View>
            <View style={[styles.featureUnlockMiniModalCard, { borderColor }]}>
              {renderInfoRows(3)}
            </View>
          </>,
          "feed",
          resolveTabLabel("feedTab", "Feed")
        );
      case "rewardsCustomization":
        return renderMiniScreen(
          <>
            <View style={[styles.featureUnlockMiniGrid, { borderColor }]}>
              {["ðŸ†", "ðŸŽ–ï¸", "â­", "ðŸŽ¯"].map((emoji, idx) => (
                <View key={`reward_cell_${idx}`} style={[styles.featureUnlockMiniGridCell, { borderColor }]}>
                  <Text style={styles.featureUnlockMiniGridEmoji}>{emoji}</Text>
                </View>
              ))}
            </View>
            {renderInfoRows(2)}
          </>,
          "purchases",
          resolveTabLabel("purchasesTitle", "Rewards")
        );
      case "thinkingList":
        return renderMiniScreen(
          <>
            <View style={[styles.featureUnlockMiniList, { borderColor }]}>
              {Array.from({ length: 3 }).map((_, index) => (
                <View key={`thinking_row_${index}`} style={styles.featureUnlockMiniListRow}>
                  <View
                    style={[
                      styles.featureUnlockMiniListDot,
                      { backgroundColor: index === 0 ? accent : baseLineColor },
                    ]}
                  />
                  <View
                    style={[
                      styles.featureUnlockMiniLine,
                      { flex: 1, width: "auto", backgroundColor: baseLineColor },
                    ]}
                  />
                  <View
                    style={[
                      styles.featureUnlockMiniTag,
                      {
                        borderColor,
                        backgroundColor: colorWithAlpha(accent, isDarkTheme ? 0.28 : 0.16),
                      },
                    ]}
                  >
                    <Text style={[styles.featureUnlockMiniTagText, { color: textPrimary }]}>
                      {compactUnlockCopy(resolveTabLabel("maybeAction", "Think"), 10)}
                    </Text>
                  </View>
                </View>
              ))}
            </View>
          </>,
          "pending",
          resolveTabLabel("pendingTab", "Thinking")
        );
      case "impulseMap":
        return renderMiniScreen(
          <View style={[styles.featureUnlockMiniMap, { borderColor }]}>
            {Array.from({ length: 5 }).map((_, row) => (
              <View key={`map_row_${row}`} style={styles.featureUnlockMiniMapRow}>
                {Array.from({ length: 4 }).map((_, col) => {
                  const active = (row === 1 && col === 2) || (row === 3 && col === 1);
                  return (
                    <View
                      key={`map_dot_${row}_${col}`}
                      style={[
                        styles.featureUnlockMiniMapDot,
                        {
                          backgroundColor: active ? accent : baseLineColor,
                          opacity: active ? 1 : 0.65,
                        },
                      ]}
                    />
                  );
                })}
              </View>
            ))}
          </View>,
          "cart",
          resolveTabLabel("wishlistTab", "Progress")
        );
      case "freeDay":
        return renderMiniScreen(
          <>
            <View style={[styles.featureUnlockMiniChallengeCard, { borderColor }]}>
              <Text style={[styles.featureUnlockMiniChallengeTitle, { color: textPrimary }]}>
                {compactUnlockCopy(resolveTabLabel("featureUnlockFreeDayTitle", "Free-day streak"), 24)}
              </Text>
              <Text style={[styles.featureUnlockMiniChallengeMeta, { color: textMuted }]}>3 / 7 this week</Text>
            </View>
            <View style={styles.featureUnlockMiniCalendarRow}>
              {["M", "T", "W", "T", "F", "S", "S"].map((day, idx) => (
                <View
                  key={`day_${day}_${idx}`}
                  style={[
                    styles.featureUnlockMiniDay,
                    idx < 3 && styles.featureUnlockMiniDayActive,
                    idx < 3 && { backgroundColor: colorWithAlpha(accent, isDarkTheme ? 0.36 : 0.2), borderColor: accent },
                    idx >= 3 && { borderColor },
                  ]}
                >
                  <Text style={[styles.featureUnlockMiniDayText, { color: idx < 3 ? textPrimary : textMuted }]}>
                    {day}
                  </Text>
                </View>
              ))}
            </View>
          </>,
          "cart",
          resolveTabLabel("wishlistTab", "Progress")
        );
      case "reports":
        return renderMiniScreen(
          <View style={[styles.featureUnlockMiniProfileCard, { borderColor }]}>
            <Text style={[styles.featureUnlockMiniProfileTitle, { color: textPrimary }]}>
              {compactUnlockCopy(resolveTabLabel("featureUnlockReportsTitle", "Reports"), 24)}
            </Text>
            <View style={[styles.featureUnlockMiniProfileButton, { backgroundColor: colorWithAlpha(accent, isDarkTheme ? 0.34 : 0.18), borderColor }]}>
              <Text style={[styles.featureUnlockMiniProfileButtonText, { color: textPrimary }]}>
                {compactUnlockCopy(resolveTabLabel("reportsButton", "Reports"), 20)}
              </Text>
            </View>
            {renderInfoRows(2)}
          </View>,
          "profile",
          resolveTabLabel("profileTab", "Profile")
        );
      case "catCustomization":
        return renderMiniScreen(
          <>
            <View style={[styles.featureUnlockMiniHeroCard, { borderColor }]}>
              <Image source={LEVEL_SHARE_CAT} style={styles.featureUnlockMiniHeroCat} />
              <View style={styles.featureUnlockMiniHeroCopy}>
                <Text style={[styles.featureUnlockMiniHeroTitle, { color: textPrimary }]}>Almi</Text>
                <Text style={[styles.featureUnlockMiniHeroSubtitle, { color: textMuted }]}>Tap to open modal</Text>
              </View>
            </View>
            <View style={[styles.featureUnlockMiniProfileButton, { backgroundColor: colorWithAlpha(accent, isDarkTheme ? 0.34 : 0.18), borderColor }]}>
              <Text style={[styles.featureUnlockMiniProfileButtonText, { color: textPrimary }]}>Skins</Text>
            </View>
            {renderInfoRows(1)}
          </>,
          "feed",
          resolveTabLabel("feedTab", "Feed")
        );
      case "rewardsChallenges":
        return renderMiniScreen(
          <>
            <View style={[styles.featureUnlockMiniChallengeCard, { borderColor }]}>
              <Text style={[styles.featureUnlockMiniChallengeTitle, { color: textPrimary }]}>Challenge board</Text>
              <Text style={[styles.featureUnlockMiniChallengeMeta, { color: textMuted }]}>Start streak mission</Text>
            </View>
            {renderInfoRows(2)}
          </>,
          "purchases",
          resolveTabLabel("purchasesTitle", "Rewards")
        );
      default:
        return renderMiniScreen(
          <View style={[styles.featureUnlockMiniModalCard, { borderColor }]}>{renderInfoRows(3)}</View>,
          palette.tabId || "feed",
          resolveTabLabel("feedTab", "Feed")
        );
    }
  };

  return (
    <View style={[styles.featureUnlockIllustration, { backgroundColor: surface, borderColor }]}>
      <Animated.View
        pointerEvents="none"
        style={[
          styles.featureUnlockIllustrationGlow,
          {
            backgroundColor: colorWithAlpha(accentSoft, 0.38),
            opacity: glowOpacity,
            transform: [{ scale: glowScale }],
          },
        ]}
      />
      <View style={styles.featureUnlockIllustrationFrame}>
        <View style={styles.featureUnlockIllustrationHeader}>
          <Animated.View
            style={[
              styles.featureUnlockPreviewBadge,
              { backgroundColor: accent, transform: [{ scale: badgeScale }] },
            ]}
          >
            <Text style={styles.featureUnlockPreviewBadgeText}>{label}</Text>
          </Animated.View>
          <Text style={styles.featureUnlockIllustrationEmoji}>{palette.emoji}</Text>
        </View>
        {renderVariantScene()}
      </View>
    </View>
  );
};

const RewardHeart = ({ left, delay, duration }) => {
  const translateY = useRef(new Animated.Value(60)).current;
  const opacity = useRef(new Animated.Value(0)).current;
  useEffect(() => {
    const anim = Animated.sequence([
      Animated.delay(delay),
      Animated.parallel([
        Animated.timing(translateY, {
          toValue: -160,
          duration,
          useNativeDriver: true,
        }),
        Animated.sequence([
          Animated.timing(opacity, {
            toValue: 1,
            duration: duration * 0.4,
            useNativeDriver: true,
          }),
          Animated.timing(opacity, {
            toValue: 0,
            duration: duration * 0.6,
            useNativeDriver: true,
          }),
        ]),
      ]),
    ]);
    anim.start();
    return () => anim.stop();
  }, [delay, duration, opacity, translateY]);

  return (
    <AnimatedText
      pointerEvents="none"
      style={[
        styles.rewardHeart,
        {
          left,
          opacity,
          transform: [{ translateY }],
        },
      ]}
    >
      â¤ï¸
    </AnimatedText>
  );
};
