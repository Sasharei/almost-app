import React, { useCallback, useEffect, useMemo, useRef, useState, forwardRef, useImperativeHandle } from "react";
import {
  View,
  Text,
  FlatList,
  Image,
  TouchableOpacity,
  Modal,
  StyleSheet,
  SafeAreaView,
  ScrollView,
  TextInput,
  Alert,
  Keyboard,
  TouchableWithoutFeedback,
  Platform,
  Dimensions,
  Animated,
  Easing,
  Linking,
  PanResponder,
  LayoutAnimation,
  UIManager,
  StatusBar as RNStatusBar,
  AppState,
  Share,
  ActionSheetIOS,
  PixelRatio,
  InteractionManager,
  ActivityIndicator,
  Pressable,
} from "react-native";
import Svg, {
  Circle as SvgCircle,
  Defs,
  Mask,
  Rect as SvgRect,
  LinearGradient as SvgLinearGradient,
  Stop as SvgStop,
  Path as SvgPath,
} from "react-native-svg";
import AsyncStorage from "@react-native-async-storage/async-storage";
import ConfettiCannon from "react-native-confetti-cannon";
import * as Haptics from "expo-haptics";
import * as ImagePicker from "expo-image-picker";
import * as Notifications from "expo-notifications";
import * as NavigationBar from "expo-navigation-bar";
import * as FileSystem from "expo-file-system";
import { StatusBar } from "expo-status-bar";
import { BlurView as ExpoBlurView } from "expo-blur";
import * as SplashScreen from "expo-splash-screen";
let AudioModule = null;
try {
  // Optional native module â€“ may be missing in some builds (e.g. older Expo Go).
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  AudioModule = require("expo-av")?.Audio || null;
} catch (error) {
  console.warn("expo-av unavailable", error);
}
import {
  useFonts,
  Inter_300Light,
  Inter_400Regular,
  Inter_500Medium,
  Inter_600SemiBold,
  Inter_700Bold,
  Inter_800ExtraBold,
  Inter_900Black,
} from "@expo-google-fonts/inter";
import Sentry, { initSentry } from "./sentry";
import { SafeAreaProvider, useSafeAreaInsets } from "react-native-safe-area-context";
import ViewShot, { captureRef as captureViewShotRef } from "react-native-view-shot";
import {
  initAnalytics,
  initPerformanceMonitoring,
  logEvent,
  logScreenView,
  setAnalyticsOptOut as setAnalyticsOptOutFlag,
  setUserProperties,
} from "./analytics";
import { SavingsProvider, useRealSavedAmount } from "./src/hooks/useRealSavedAmount";
import { useSavingsSimulation } from "./src/hooks/useSavingsSimulation";
import { calcPotentialSaved } from "./src/utils/savingsSimulation";
import { TRANSLATIONS } from "./src/constants/translations";
import { DEFAULT_TEMPTATIONS } from "./src/constants/temptations";
import { PRIVACY_LINKS, TERMS_LINKS, TERMS_POINTS } from "./src/constants/legal";

let StoreReview = null;
try {
  // Optional native module â€“ older builds might not include it.
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  StoreReview = require("expo-store-review");
} catch (error) {
  console.warn("StoreReview unavailable", error);
}
let Sharing = null;
try {
  // Optional: module might be missing on some builds (e.g. Expo Go).
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  Sharing = require("expo-sharing");
} catch (error) {
  console.warn("Sharing unavailable", error);
}
let FacebookSettings = null;
try {
  // Optional: module might be missing on some builds (e.g. Expo Go).
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  FacebookSettings = require("react-native-fbsdk-next")?.Settings || null;
} catch (error) {
  console.warn("Facebook SDK unavailable", error);
}
let TrackingTransparency = null;
try {
  // Optional: module might be missing in older builds or Expo Go.
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  TrackingTransparency = require("expo-tracking-transparency") || null;
} catch (error) {
  console.warn("Tracking transparency unavailable", error);
}

Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowAlert: true,
    shouldPlaySound: false,
    shouldSetBadge: false,
  }),
});

let AndroidBlurView = null;
try {
  AndroidBlurView = require("@react-native-community/blur")?.BlurView || null;
} catch (error) {
  AndroidBlurView = null;
}

const BLUR_VIEW_MANAGER_NAMES = ["ViewManagerAdapter_ExpoBlurView", "ExpoBlurView"];
const isBlurViewAvailable = () => {
  if (Platform.OS === "android") return !!AndroidBlurView;
  if (!UIManager) return false;
  if (typeof UIManager.getViewManagerConfig === "function") {
    return BLUR_VIEW_MANAGER_NAMES.some((name) => !!UIManager.getViewManagerConfig(name));
  }
  return BLUR_VIEW_MANAGER_NAMES.some((name) => !!UIManager[name]);
};

const bootstrapMonitoring = (() => {
  let queued = false;
  return () => {
    if (queued) return;
    queued = true;
    InteractionManager.runAfterInteractions(() => {
      initSentry();
      initAnalytics();
      initPerformanceMonitoring();
    });
  };
})();
// Keep native splash visible until our custom LogoSplash is ready.
SplashScreen.preventAutoHideAsync().catch(() => {});

const STORAGE_KEYS = {
  PURCHASES: "@almost_purchases",
  PROFILE: "@almost_profile",
  THEME: "@almost_theme",
  LANGUAGE: "@almost_language",
  ONBOARDING: "@almost_onboarded",
  TERMS_ACCEPTED: "@almost_terms_accepted",
  CATALOG: "@almost_catalog_overrides",
  PRICE_PRECISION_OVERRIDES: "@almost_price_precision_overrides",
  TITLE_OVERRIDES: "@almost_title_overrides",
  EMOJI_OVERRIDES: "@almost_emoji_overrides",
  WISHES: "@almost_wishes",
  SAVED_TOTAL: "@almost_saved_total",
  DECLINES: "@almost_declines",
  PENDING: "@almost_pending",
  FREE_DAY: "@almost_free_day_stats",
  DECISION_STATS: "@almost_decision_stats",
  HISTORY: "@almost_history",
  REFUSE_STATS: "@almost_refuse_stats",
  REWARDS_CELEBRATED: "@almost_rewards_celebrated",
  HEALTH: "@almost_health_points",
  CLAIMED_REWARDS: "@almost_claimed_rewards",
  REWARD_TOTAL: "@almost_reward_total",
  ANALYTICS_OPT_OUT: "@almost_analytics_opt_out",
  TEMPTATION_GOALS: "@almost_temptation_goals",
  TEMPTATION_INTERACTIONS: "@almost_temptation_interactions",
  CUSTOM_TEMPTATIONS: "@almost_custom_temptations",
  HIDDEN_TEMPTATIONS: "@almost_hidden_temptations",
  IMPULSE_TRACKER: "@almost_impulse_tracker",
  MOOD_STATE: "@almost_mood_state",
  CHALLENGES: "@almost_challenges",
  CUSTOM_REMINDER: "@almost_custom_reminder",
  SMART_REMINDERS: "@almost_smart_reminders",
  DAILY_NUDGES: "@almost_daily_nudges",
  DAILY_NUDGE_SCHEDULE_SIGNATURE: "@almost_daily_nudge_schedule_signature",
  LANGUAGE_CURRENCY_NUDGE: "@almost_language_currency_nudge",
  TAMAGOTCHI: "@almost_tamagotchi_state",
  DAILY_SUMMARY: "@almost_daily_summary",
  POTENTIAL_PUSH_PROGRESS: "@almost_potential_push_progress",
  PUSH_NOTIFICATIONS_ENABLED_LOGGED: "@almost_push_notifications_enabled_logged",
  PUSH_DAY_THREE_PROMPT: "@almost_push_day_three_prompt",
  SPEND_LOGGING_REMINDER: "@almost_spend_logging_reminder",
  TUTORIAL: "@almost_tutorial_state",
  TEMPTATION_TUTORIAL: "@almost_temptation_cards_tutorial",
  COIN_VALUE_MODAL: "@almost_coin_value_modal",
  DAILY_CHALLENGE: "@almost_daily_challenge_state",
  DAILY_REWARD: "@almost_daily_reward",
  DAILY_REWARD_DAY_KEY: "@almost_daily_reward_day",
  FOCUS_TARGET: "@almost_focus_target",
  FOCUS_DIGEST: "@almost_focus_digest",
  CATEGORY_OVERRIDES: "@almost_category_overrides",
  CUSTOM_CATEGORIES: "@almost_custom_categories",
  DESCRIPTION_OVERRIDES: "@almost_description_overrides",
  FOCUS_DIGEST_PENDING: "@almost_focus_digest_pending",
  TAMAGOTCHI_SKIN: "@almost_tamagotchi_skin",
  TAMAGOTCHI_SKINS_UNLOCKED: "@almost_tamagotchi_skins_unlocked",
  TAMAGOTCHI_HUNGER_NOTIFICATIONS: "@almost_tamagotchi_hunger_notifications",
  TAMAGOTCHI_HUNGER_DAILY_COUNT: "@almost_tamagotchi_hunger_daily_count",
  TAMAGOTCHI_HUNGER_LAST_AT: "@almost_tamagotchi_hunger_last_at",
  SAVED_TOTAL_PEAK: "@almost_saved_total_peak",
  LAST_CELEBRATED_LEVEL: "@almost_last_celebrated_level",
  ACTIVE_GOAL: "@almost_active_goal",
  POTENTIAL_OPEN_SNAPSHOT: "@almost_potential_open_snapshot",
  COIN_SLIDER_MAX: "@almost_coin_slider_max",
  FAB_TUTORIAL: "@almost_fab_tutorial",
  RATING_PROMPT: "@almost_rating_prompt",
  NORTH_STAR_METRIC: "@almost_north_star_metric",
  DAY_TWO_ACTIVITY: "@almost_day_two_activity",
  DAY_THREE_ACTIVITY: "@almost_day_three_activity",
  PRIMARY_TEMPTATION_PROMPT: "@almost_primary_temptation_prompt",
  LAST_NOTIFICATION_AT: "@almost_last_notification_at",
  SOUND_ENABLED: "@almost_sound_enabled",
};

const COIN_VALUE_MODAL_STATUS = {
  PENDING: "pending",
  SHOWN: "shown",
};

const CELEBRATION_OVERLAY_GAP_MS = 15000;
const APP_RESUME_MODAL_GUARD_MS = 1500;

const DEFAULT_LANGUAGE = "en";
const FALLBACK_LANGUAGE = "en";
const SUPPORTED_LANGUAGES = ["en", "es", "fr", "ru"];
const SOUND_FILES = {
  coin: require("./assets/sounds/coin.wav"),
  tap: require("./assets/sounds/tap.wav"),
  counter: require("./assets/sounds/counter.wav"),
  cat: require("./assets/sounds/cat.wav"),
  challenge_accept: require("./assets/sounds/challenge_accept.wav"),
  focus_accept: require("./assets/sounds/focus_accept.wav"),
  reward: require("./assets/sounds/reward.wav"),
  thunder: require("./assets/sounds/thunder.wav"),
  daily_reward: require("./assets/sounds/daily_reward.wav"),
  level_up: require("./assets/sounds/level_up.wav"),
  streak_restore: require("./assets/sounds/streak_restore.wav"),
};
const PRELOAD_SOUND_KEYS = new Set(["coin", "tap", "counter", "level_up"]);
const SOUND_COOLDOWNS = {
  coin: 200,
  tap: 120,
  counter: 60,
  cat: 600,
  challenge_accept: 500,
  focus_accept: 500,
  reward: 600,
  thunder: 900,
  daily_reward: 900,
  level_up: 1200,
  streak_restore: 800,
};
const SOUND_VOLUMES = {
  coin: 0.85,
  tap: 0.75,
  counter: 1.0,
  cat: 0.8,
  challenge_accept: 0.85,
  focus_accept: 0.85,
  reward: 0.9,
  thunder: 0.85,
  daily_reward: 0.9,
  level_up: 0.9,
  streak_restore: 0.85,
};
const LANGUAGE_LABEL_KEYS = {
  ru: "languageRussian",
  en: "languageEnglish",
  es: "languageSpanish",
  fr: "languageFrench",
};
const LANGUAGE_NATIVE_LABELS = {
  ru: "Ð ÑƒÑÑÐºÐ¸Ð¹",
  en: "English",
  es: "EspaÃ±ol",
  fr: "FranÃ§ais",
};
const normalizeLanguage = (value) =>
  SUPPORTED_LANGUAGES.includes(value) ? value : DEFAULT_LANGUAGE;
const getLanguageLabelKey = (language) =>
  LANGUAGE_LABEL_KEYS[language] || LANGUAGE_LABEL_KEYS[FALLBACK_LANGUAGE];
const FORMAT_LOCALES = {
  ru: "ru-RU",
  en: "en-US",
  es: "es-ES",
  fr: "fr-FR",
};
const SHORT_LANGUAGE_MAP = {
  ru: "ru",
  en: "en",
  es: "es",
  fr: "fr",
};
const getFormatLocale = (language) =>
  FORMAT_LOCALES[language] || FORMAT_LOCALES[FALLBACK_LANGUAGE];
const getShortLanguageKey = (language) =>
  SHORT_LANGUAGE_MAP[language] || SHORT_LANGUAGE_MAP[FALLBACK_LANGUAGE];

const PURCHASE_GOAL = 20000;
const FALLBACK_SAVE_ACTION_USD = 20;
const FINANCIAL_QUOTES = [
  {
    id: "franklin",
    en: "â€œA penny saved is a penny earned.â€ Benjamin Franklin",
    ru: "Â«Ð¡Ð±ÐµÑ€ÐµÐ¶Ñ‘Ð½Ð½Ñ‹Ð¹ Ñ€ÑƒÐ±Ð»ÑŒ Ñ€Ð°Ð²ÐµÐ½ Ð·Ð°Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð½Ð¾Ð¼Ñƒ.Â» Ð‘ÐµÐ½Ð´Ð¶Ð°Ð¼Ð¸Ð½ Ð¤Ñ€Ð°Ð½ÐºÐ»Ð¸Ð½",
    es: "â€œUn centavo ahorrado es un centavo ganado.â€ Benjamin Franklin",
    fr: "Â«Un sou Ã©conomisÃ© est un sou gagnÃ©.Â» Benjamin Franklin",
  },
  {
    id: "seneca",
    en: "â€œWealth is the slave of a wise man and the master of a fool.â€ Seneca",
    ru: "Â«Ð‘Ð¾Ð³Ð°Ñ‚ÑÑ‚Ð²Ð¾ ÑÐ»ÑƒÐ¶Ð¸Ñ‚ Ð¼ÑƒÐ´Ñ€Ð¾Ð¼Ñƒ Ð¸ Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ Ð³Ð»ÑƒÐ¿Ñ†Ð¾Ð¼.Â» Ð¡ÐµÐ½ÐµÐºÐ°",
    es: "â€œLa riqueza es la esclava del sabio y la dueÃ±a del necio.â€ SÃ©neca",
    fr: "Â«La richesse est l'esclave du sage et la maÃ®tresse du fou.Â» SÃ©nÃ¨que",
  },
  {
    id: "buffett",
    en: "â€œDo not save what is left after spending; spend what is left after saving.â€ Warren Buffett",
    ru: "Â«ÐÐµ Ð¾Ñ‚ÐºÐ»Ð°Ð´Ñ‹Ð²Ð°Ð¹ Ñ‚Ð¾, Ñ‡Ñ‚Ð¾ Ð¾ÑÑ‚Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾ÑÐ»Ðµ Ñ€Ð°ÑÑ…Ð¾Ð´Ð¾Ð², Ñ‚Ñ€Ð°Ñ‚ÑŒ Ñ‚Ð¾, Ñ‡Ñ‚Ð¾ Ð¾ÑÑ‚Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾ÑÐ»Ðµ ÑÐ±ÐµÑ€ÐµÐ¶ÐµÐ½Ð¸Ð¹.Â» Ð£Ð¾Ñ€Ñ€ÐµÐ½ Ð‘Ð°Ñ„Ñ„ÐµÑ‚",
    es: "â€œNo ahorres lo que quede despuÃ©s de gastar; gasta lo que quede despuÃ©s de ahorrar.â€ Warren Buffett",
    fr: "Â«N'Ã©pargne pas ce qui reste aprÃ¨s avoir dÃ©pensÃ©, dÃ©pense ce qui reste aprÃ¨s avoir Ã©pargnÃ©.Â» Warren Buffett",
  },
  {
    id: "ramsey",
    en: "â€œYou must gain control over your money or the lack of it will forever control you.â€ Dave Ramsey",
    ru: "Â«Ð›Ð¸Ð±Ð¾ Ñ‚Ñ‹ ÑƒÐ¿Ñ€Ð°Ð²Ð»ÑÐµÑˆÑŒ Ð´ÐµÐ½ÑŒÐ³Ð°Ð¼Ð¸, Ð»Ð¸Ð±Ð¾ Ð¸Ñ… Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²Ð¸Ðµ Ð±ÑƒÐ´ÐµÑ‚ ÑƒÐ¿Ñ€Ð°Ð²Ð»ÑÑ‚ÑŒ Ñ‚Ð¾Ð±Ð¾Ð¹ Ð²ÑÐµÐ³Ð´Ð°.Â» Ð”ÐµÐ¹Ð² Ð ÑÐ¼ÑÐ¸",
    es: "â€œDebes controlar tu dinero o la falta de Ã©l te controlarÃ¡ para siempre.â€ Dave Ramsey",
    fr: "Â«Prends le contrÃ´le de ton argent sinon son absence te contrÃ´lera pour toujours.Â» Dave Ramsey",
  },
  {
    id: "orman",
    en: "â€œA big part of financial freedom is having your heart and mind free from worry about the what-ifs of life.â€ Suze Orman",
    ru: "Â«Ð¤Ð¸Ð½Ð°Ð½ÑÐ¾Ð²Ð°Ñ ÑÐ²Ð¾Ð±Ð¾Ð´Ð° Ð½Ð°Ñ‡Ð¸Ð½Ð°ÐµÑ‚ÑÑ, ÐºÐ¾Ð³Ð´Ð° ÑÐµÑ€Ð´Ñ†Ðµ Ð¸ Ñ€Ð°Ð·ÑƒÐ¼ ÑÐ²Ð¾Ð±Ð¾Ð´Ð½Ñ‹ Ð¾Ñ‚ Ñ‚Ñ€ÐµÐ²Ð¾Ð³Ð¸ Ð¾ Ñ‚Ð¾Ð¼, Ñ‡Ñ‚Ð¾ Ð±ÑƒÐ´ÐµÑ‚, ÐµÑÐ»Ð¸.Â» Ð¡ÑŒÑŽÐ· ÐžÑ€Ð¼Ð°Ð½",
    es: "â€œGran parte de la libertad financiera es tener la mente y el corazÃ³n libres de preocuparse por los Â«quÃ© pasarÃ­a siÂ».â€ Suze Orman",
    fr: "Â«Une grande part de la libertÃ© financiÃ¨re consiste Ã  avoir l'esprit et le cÅ“ur libÃ©rÃ©s des inquiÃ©tudes du et si.Â» Suze Orman",
  },
  {
    id: "lynch",
    en: "â€œKnow what you own, and know why you own it.â€ Peter Lynch",
    ru: "Â«Ð—Ð½Ð°Ð¹, Ñ‡ÐµÐ¼ Ð²Ð»Ð°Ð´ÐµÐµÑˆÑŒ, Ð¸ Ð¿Ð¾Ð½Ð¸Ð¼Ð°Ð¹, Ð·Ð°Ñ‡ÐµÐ¼ ÑÑ‚Ð¾ Ñ‚ÐµÐ±Ðµ.Â» ÐŸÐ¸Ñ‚ÐµÑ€ Ð›Ð¸Ð½Ñ‡",
    es: "â€œSabe quÃ© posees y por quÃ© lo posees.â€ Peter Lynch",
    fr: "Â«Sache ce que tu possÃ¨des et pourquoi tu le possÃ¨des.Â» Peter Lynch",
  },
  {
    id: "jefferson",
    en: "â€œNever spend your money before you have it.â€ Thomas Jefferson",
    ru: "Â«ÐÐ¸ÐºÐ¾Ð³Ð´Ð° Ð½Ðµ Ñ‚Ñ€Ð°Ñ‚ÑŒ Ð´ÐµÐ½ÑŒÐ³Ð¸ Ñ€Ð°Ð½ÑŒÑˆÐµ, Ñ‡ÐµÐ¼ Ð¾Ð½Ð¸ Ñƒ Ñ‚ÐµÐ±Ñ ÐµÑÑ‚ÑŒ.Â» Ð¢Ð¾Ð¼Ð°Ñ Ð”Ð¶ÐµÑ„Ñ„ÐµÑ€ÑÐ¾Ð½",
    es: "â€œNunca gastes tu dinero antes de tenerlo.â€ Thomas Jefferson",
    fr: "Â«Ne dÃ©pense jamais ton argent avant de l'avoir.Â» Thomas Jefferson",
  },
  {
    id: "thatcher",
    en: "â€œPennies do not come from heaven. They have to be earned here on earth.â€ Margaret Thatcher",
    ru: "Â«ÐœÐ¾Ð½ÐµÑ‚Ñ‹ Ð½Ðµ Ð¿Ð°Ð´Ð°ÑŽÑ‚ Ñ Ð½ÐµÐ±ÐµÑ, Ð¸Ñ… Ð½ÑƒÐ¶Ð½Ð¾ Ð·Ð°Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ñ‚ÑŒ Ð½Ð° Ð·ÐµÐ¼Ð»Ðµ.Â» ÐœÐ°Ñ€Ð³Ð°Ñ€ÐµÑ‚ Ð¢ÑÑ‚Ñ‡ÐµÑ€",
    es: "â€œLos centavos no caen del cielo, hay que ganarlos aquÃ­ en la tierra.â€ Margaret Thatcher",
    fr: "Â«Les piÃ¨ces ne tombent pas du ciel, il faut les gagner ici-bas.Â» Margaret Thatcher",
  },
  {
    id: "kiyosaki",
    en: "â€œIt's not how much money you make, but how much money you keep, how hard it works for you, and how many generations you keep it for.â€ Robert Kiyosaki",
    ru: "Â«Ð’Ð°Ð¶Ð½Ñ‹ Ð½Ðµ ÑÑ‚Ð¾Ð»ÑŒÐºÐ¾ Ð·Ð°Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð½Ñ‹Ðµ Ð´ÐµÐ½ÑŒÐ³Ð¸, ÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ñ‚Ð¾, ÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ñ‚Ñ‹ ÑÐ¾Ñ…Ñ€Ð°Ð½ÑÐµÑˆÑŒ, ÐºÐ°Ðº Ð¾Ð½Ð¸ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÑŽÑ‚ Ð½Ð° Ñ‚ÐµÐ±Ñ Ð¸ Ð½Ð° ÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ð¿Ð¾ÐºÐ¾Ð»ÐµÐ½Ð¸Ð¹ Ð¸Ñ… Ñ…Ð²Ð°Ñ‚Ð¸Ñ‚.Â» Ð Ð¾Ð±ÐµÑ€Ñ‚ ÐšÐ¸Ð¾ÑÐ°ÐºÐ¸",
    es: "â€œNo importa cuÃ¡nto dinero ganes, sino cuÃ¡nto conservas, quÃ© tan duro trabaja para ti y por cuÃ¡ntas generaciones lo mantienes.â€ Robert Kiyosaki",
    fr: "Â«Ce n'est pas ce que tu gagnes qui compte mais ce que tu conserves, la faÃ§on dont cet argent travaille pour toi et le nombre de gÃ©nÃ©rations qui en profitent.Â» Robert Kiyosaki",
  },
];
const MAX_ACTIVE_CHALLENGES = 3;
const MAX_ACTIVE_GOALS = 5;
const ANDROID_API_LEVEL =
  Platform.OS === "android"
    ? typeof Platform.Version === "string"
      ? parseInt(Platform.Version, 10) || 0
      : Number(Platform.Version) || 0
    : 0;
const SHOULD_USE_ANDROID_LEGACY_MEDIA_PICKER =
  Platform.OS === "android" && ANDROID_API_LEVEL > 0 && ANDROID_API_LEVEL < 33;
const CLASSIC_TAMAGOTCHI_ANIMATIONS = {
  idle: require("./assets/Cat_idle.gif"),
  curious: require("./assets/Cat_curious.gif"),
  follow: require("./assets/Cat_follows.gif"),
  speak: require("./assets/Cat_speaks.gif"),
  happy: require("./assets/Cat_happy.gif"),
  happyHeadshake: require("./assets/Cat_happy_headshake.gif"),
  sad: require("./assets/Cat_sad.gif"),
  ohno: require("./assets/Cat_oh_oh.gif"),
  cry: require("./assets/Cat_cry.gif"),
  waving: require("./assets/Cat_waving.gif"),
};
const GREEN_TAMAGOTCHI_ANIMATIONS = {
  idle: require("./assets/tamagotchi_skins/green/Cat_idle.gif"),
  curious: require("./assets/tamagotchi_skins/green/Cat_curious.gif"),
  follow: require("./assets/tamagotchi_skins/green/Cat_follows.gif"),
  speak: require("./assets/tamagotchi_skins/green/Cat_speaks.gif"),
  happy: require("./assets/tamagotchi_skins/green/Cat_happy.gif"),
  happyHeadshake: require("./assets/tamagotchi_skins/green/Cat_happy_headshake.gif"),
  sad: require("./assets/tamagotchi_skins/green/Cat_sad.gif"),
  ohno: require("./assets/tamagotchi_skins/green/Cat_oh_oh.gif"),
  cry: require("./assets/tamagotchi_skins/green/Cat_cry.gif"),
  waving: require("./assets/tamagotchi_skins/green/Cat_waving.gif"),
};
const TEAL_TAMAGOTCHI_ANIMATIONS = {
  idle: require("./assets/tamagotchi_skins/teal/Cat_idle.gif"),
  curious: require("./assets/tamagotchi_skins/teal/Cat_curious.gif"),
  follow: require("./assets/tamagotchi_skins/teal/Cat_follows.gif"),
  speak: require("./assets/tamagotchi_skins/teal/Cat_speaks.gif"),
  happy: require("./assets/tamagotchi_skins/teal/Cat_happy.gif"),
  happyHeadshake: require("./assets/tamagotchi_skins/teal/Cat_happy_headshake.gif"),
  sad: require("./assets/tamagotchi_skins/teal/Cat_sad.gif"),
  ohno: require("./assets/tamagotchi_skins/teal/Cat_oh_oh.gif"),
  cry: require("./assets/tamagotchi_skins/teal/Cat_cry.gif"),
  waving: require("./assets/tamagotchi_skins/teal/Cat_waving.gif"),
};
const PENDING_COUNTDOWN_FAST_MS = 1000;
const PENDING_BADGE_TICK_MS = 60000;
const PERSIST_DEBOUNCE_MS = 400;
const STORM_OVERLAY_DURATION_MS = 6000;

const stripEmojis = (text = "") =>
  text
    .replace(
      /(?:\uD83C[\uDF00-\uDFFF]|\uD83D[\uDC00-\uDE4F]|\uD83D[\uDE80-\uDEFF]|[\u2600-\u27BF])/g,
      ""
    )
    .replace(/\s{2,}/g, " ")
    .trim();
const YELLOW_TAMAGOTCHI_ANIMATIONS = {
  idle: require("./assets/tamagotchi_skins/yellow/Cat_idle.gif"),
  curious: require("./assets/tamagotchi_skins/yellow/Cat_curious.gif"),
  follow: require("./assets/tamagotchi_skins/yellow/Cat_follows.gif"),
  speak: require("./assets/tamagotchi_skins/yellow/Cat_speaks.gif"),
  happy: require("./assets/tamagotchi_skins/yellow/Cat_happy.gif"),
  happyHeadshake: require("./assets/tamagotchi_skins/yellow/Cat_happy_headshake.gif"),
  sad: require("./assets/tamagotchi_skins/yellow/Cat_sad.gif"),
  ohno: require("./assets/tamagotchi_skins/yellow/Cat_oh_oh.gif"),
  cry: require("./assets/tamagotchi_skins/yellow/Cat_cry.gif"),
  waving: require("./assets/tamagotchi_skins/yellow/Cat_waving.gif"),
};
const PURPLE_TAMAGOTCHI_ANIMATIONS = {
  idle: require("./assets/tamagotchi_skins/purple/Cat_idle.gif"),
  curious: require("./assets/tamagotchi_skins/purple/Cat_curious.gif"),
  follow: require("./assets/tamagotchi_skins/purple/Cat_follows.gif"),
  speak: require("./assets/tamagotchi_skins/purple/Cat_speaks.gif"),
  happy: require("./assets/tamagotchi_skins/purple/Cat_happy.gif"),
  happyHeadshake: require("./assets/tamagotchi_skins/purple/Cat_happy_headshake.gif"),
  sad: require("./assets/tamagotchi_skins/purple/Cat_sad.gif"),
  ohno: require("./assets/tamagotchi_skins/purple/Cat_oh_oh.gif"),
  cry: require("./assets/tamagotchi_skins/purple/Cat_cry.gif"),
  waving: require("./assets/tamagotchi_skins/purple/Cat_waving.gif"),
};
const TAMAGOTCHI_SKIN_OPTIONS = [
  {
    id: "classic",
    label: { ru: "ÐšÐ»Ð°ÑÑÐ¸Ñ‡ÐµÑÐºÐ¸Ð¹", en: "Classic", es: "ClÃ¡sico", fr: "Classique" },
    description: {
      ru: "Ð—Ð½Ð°ÐºÐ¾Ð¼Ñ‹Ð¹ Ð¾Ð±Ñ€Ð°Ð· ÐÐ»Ð¼Ð¸",
      en: "The original Almi look",
      es: "El estilo original de Almi",
      fr: "Le look original d'Almi",
    },
    preview: require("./assets/Cat_mascot.png"),
    avatar: require("./assets/Cat_mascot.png"),
    animations: CLASSIC_TAMAGOTCHI_ANIMATIONS,
  },
  {
    id: "green",
    label: { ru: "Ð›ÐµÑÐ½Ð¾Ð¹", en: "Forest", es: "Verde bosque", fr: "ForÃªt" },
    description: {
      ru: "ÐœÑÑ‚Ð½Ñ‹Ð¹ Ð¸ÑÑÐ»ÐµÐ´Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ",
      en: "Mint explorer",
      es: "Explorador mentolado",
      fr: "Exploratrice mentholÃ©e",
    },
    preview: require("./assets/tamagotchi_skins/green/Cat_idle.gif"),
    avatar: require("./assets/tamagotchi_skins/green/Cat_idle.gif"),
    animations: GREEN_TAMAGOTCHI_ANIMATIONS,
  },
  {
    id: "teal",
    label: { ru: "Ð›Ð°Ð·ÑƒÑ€Ð½Ñ‹Ð¹", en: "Teal breeze", es: "Brisa turquesa", fr: "Brise turquoise" },
    description: {
      ru: "Ð¡Ð²ÐµÐ¶Ð¸Ð¹ Ð¼Ð¾Ñ€ÑÐºÐ¾Ð¹ Ð¾Ñ‚Ñ‚ÐµÐ½Ð¾Ðº",
      en: "Ocean breeze palette",
      es: "Paleta brisa marina",
      fr: "Palette brise ocÃ©ane",
    },
    preview: require("./assets/tamagotchi_skins/teal/Cat_idle.gif"),
    avatar: require("./assets/tamagotchi_skins/teal/Cat_idle.gif"),
    animations: TEAL_TAMAGOTCHI_ANIMATIONS,
  },
  {
    id: "yellow",
    label: { ru: "Ð¡Ð¾Ð»Ð½ÐµÑ‡Ð½Ñ‹Ð¹", en: "Sunny", es: "Amarillo brillante", fr: "EnsoleillÃ©" },
    description: {
      ru: "Ð¢Ñ‘Ð¿Ð»Ñ‹Ð¹ Ð¸ ÑÐ½ÐµÑ€Ð³Ð¸Ñ‡Ð½Ñ‹Ð¹",
      en: "Bright and energising",
      es: "CÃ¡lido y lleno de energÃ­a",
      fr: "Chaud et plein d'Ã©nergie",
    },
    preview: require("./assets/tamagotchi_skins/yellow/Cat_idle.gif"),
    avatar: require("./assets/tamagotchi_skins/yellow/Cat_idle.gif"),
    animations: YELLOW_TAMAGOTCHI_ANIMATIONS,
  },
  {
    id: "purple",
    label: { ru: "Ð¡Ð¸Ñ€ÐµÐ½ÐµÐ²Ñ‹Ð¹", en: "Lavender", es: "Lavanda", fr: "Lavande" },
    description: {
      ru: "ÐÐµÐ¼Ð½Ð¾Ð³Ð¾ Ð·Ð°Ð³Ð°Ð´Ð¾Ñ‡Ð½Ñ‹Ð¹",
      en: "A dreamy violet vibe",
      es: "Un toque violeta soÃ±ador",
      fr: "Une touche violette rÃªveuse",
    },
    preview: require("./assets/tamagotchi_skins/purple/Cat_idle.gif"),
    avatar: require("./assets/tamagotchi_skins/purple/Cat_idle.gif"),
    animations: PURPLE_TAMAGOTCHI_ANIMATIONS,
  },
];
const TAMAGOTCHI_SKINS = TAMAGOTCHI_SKIN_OPTIONS.reduce((acc, skin) => {
  acc[skin.id] = skin;
  return acc;
}, {});
const DEFAULT_TAMAGOTCHI_SKIN = "classic";
const SUPPORT_EMAIL = "almostappsup@gmail.com";
const INSTAGRAM_URL =
  "https://www.instagram.com/almostsavings?igsh=YzZ5aXB5YWd5ODZy&utm_source=qr";
const FACEBOOK_APP_ID = "1653035139013896";
const HEALTH_COIN_TIERS = [
  { id: "green", value: 1, asset: require("./assets/coins/Coin_green.png") },
  { id: "blue", value: 10, asset: require("./assets/coins/Coin_blue.png") },
  { id: "orange", value: 100, asset: require("./assets/coins/Coin_orange.png") },
  { id: "red", value: 1000, asset: require("./assets/coins/Coin_red.png") },
  { id: "pink", value: 10000, asset: require("./assets/coins/Coin_pink.png") },
];
const BLUE_HEALTH_COIN_TIER =
  HEALTH_COIN_TIERS.find((tier) => tier.id === "blue") || HEALTH_COIN_TIERS[1];
const BLUE_HEALTH_COIN_ASSET = BLUE_HEALTH_COIN_TIER?.asset || null;
const BLUE_HEALTH_COIN_VALUE = BLUE_HEALTH_COIN_TIER?.value || 10;
const GOAL_COMPLETION_REWARD_COINS = 5;
const GOAL_COMPLETION_REWARD_TIER = BLUE_HEALTH_COIN_TIER || HEALTH_COIN_TIERS[1];
const GOAL_COMPLETION_REWARD_VALUE =
  GOAL_COMPLETION_REWARD_COINS * (GOAL_COMPLETION_REWARD_TIER?.value || 1);
const SCREEN_WIDTH = Dimensions.get("window").width;
const SCREEN_HEIGHT = Dimensions.get("window").height;
const SAVE_PROGRESS_BAR_WIDTH = Math.min(SCREEN_WIDTH - 80, 340);
const CTA_LETTER_SPACING = 0.4;
const FONT_SCALE = typeof PixelRatio.getFontScale === "function" ? PixelRatio.getFontScale() : 1;
const IS_EXTRA_COMPACT_DEVICE = SCREEN_WIDTH <= 375 || (SCREEN_WIDTH <= 390 && FONT_SCALE > 1.1);
const TYPOGRAPHY_SCALE = IS_EXTRA_COMPACT_DEVICE ? 0.92 : 1;
const scaleFontSize = (value) =>
  typeof value === "number" ? Number((value * TYPOGRAPHY_SCALE).toFixed(2)) : value;
const scaleLetterSpacing = (value) =>
  typeof value === "number" ? Number((value * TYPOGRAPHY_SCALE).toFixed(3)) : value;
const scaleTypographyOverrides = (overrides = {}) => {
  if (!overrides || typeof overrides !== "object") return overrides;
  let next = overrides;
  const applyScaled = (key, scaleFn) => {
    if (typeof overrides[key] === "number") {
      if (next === overrides) next = { ...overrides };
      next[key] = scaleFn(overrides[key]);
    }
  };
  applyScaled("fontSize", scaleFontSize);
  applyScaled("lineHeight", scaleFontSize);
  applyScaled("letterSpacing", scaleLetterSpacing);
  return next;
};
// Limit how far dialog-style cards can move when the keyboard is visible.
const MAX_MODAL_KEYBOARD_OFFSET = Math.min(SCREEN_HEIGHT * 0.45, 360);
const OVERLAY_CARD_MAX_WIDTH = Math.min(SCREEN_WIDTH - 40, 440);
const IS_COMPACT_DEVICE = SCREEN_WIDTH <= 380;
const SAVE_INTRO_STAGE_DURATION = 3400;
const SAVE_COUNTER_DIGIT_HEIGHT = 64;
const SAVE_COUNTER_SPIN_LOOPS = 2;
const SAVE_PROGRESS_DELAY_MS = 800;
const SAVE_PROGRESS_PULSE_SCALE = 1.08;
const SAVE_COUNTDOWN_ZOOM_DELAY_AFTER_SPIN = 1500;
const SAVE_COUNTDOWN_FINAL_HOLD_DELAY = 2600;
const PROFILE_SUBTITLE_FONT_SIZE = scaleFontSize(IS_COMPACT_DEVICE ? 12 : 13);
const PROFILE_SUBTITLE_LINE_HEIGHT = scaleFontSize(IS_COMPACT_DEVICE ? 16 : 18);
const PROFILE_STAT_LABEL_FONT_SIZE = scaleFontSize(IS_COMPACT_DEVICE ? 8.5 : 10);
const PROFILE_STAT_LETTER_SPACING = scaleLetterSpacing(
  IS_COMPACT_DEVICE ? CTA_LETTER_SPACING * 0.6 : CTA_LETTER_SPACING * 0.8
);
const CHALLENGE_TITLE_FONT_SIZE = scaleFontSize(IS_COMPACT_DEVICE ? 15 : 16);
const CHALLENGE_DESC_FONT_SIZE = scaleFontSize(IS_COMPACT_DEVICE ? 13 : 14);
const CHALLENGE_LINE_HEIGHT = scaleFontSize(IS_COMPACT_DEVICE ? 18 : 20);
const CHALLENGE_META_FONT_SIZE = scaleFontSize(IS_COMPACT_DEVICE ? 11.5 : 12);

const THEMES = {
  light: {
    background: "#F6F7FB",
    card: "#FFFFFF",
    text: "#1C1A2A",
    muted: "#7A7F92",
    border: "#E5E6ED",
    primary: "#111",
  },
  dark: {
    background: "#05070D",
    card: "#161B2A",
    text: "#F7F9FF",
    muted: "#A5B1CC",
    border: "#2E374F",
    primary: "#FFC857",
  },
};
const DEFAULT_THEME = "light";

const INTER_FONTS = {
  light: "Inter_300Light",
  regular: "Inter_400Regular",
  medium: "Inter_500Medium",
  semiBold: "Inter_600SemiBold",
  bold: "Inter_700Bold",
  extraBold: "Inter_800ExtraBold",
  black: "Inter_900Black",
};

const SMART_REMINDER_DELAY_MS = 23 * 60 * 60 * 1000;
const SMART_REMINDER_MIN_INTERVAL_MS = 60 * 60 * 1000;
const SMART_REMINDER_RETENTION_MS = 14 * 24 * 60 * 60 * 1000;
const SMART_REMINDER_LIMIT = 40;
const DAILY_NUDGE_REMINDERS = [
  { id: "morning", hour: 9, minute: 0, titleKey: "dailyNudgeMorningTitle", bodyKey: "dailyNudgeMorningBody" },
  { id: "daytime", hour: 12, minute: 30, titleKey: "dailyNudgeDayTitle", bodyKey: "dailyNudgeDayBody" },
  {
    id: "afternoon",
    hour: 15,
    minute: 30,
    titleKey: "dailyNudgeAfternoonTitle",
    bodyKey: "dailyNudgeAfternoonBody",
  },
  { id: "evening", hour: 19, minute: 0, titleKey: "dailyNudgeEveningTitle", bodyKey: "dailyNudgeEveningBody" },
];
const DAILY_NUDGE_TITLE_KEYS = [
  "dailyNudgeMorningTitle",
  "dailyNudgeDayTitle",
  "dailyNudgeAfternoonTitle",
  "dailyNudgeEveningTitle",
];
const DAILY_NUDGE_BODY_KEYS = [
  "dailyNudgeMorningBody",
  "dailyNudgeDayBody",
  "dailyNudgeAfternoonBody",
  "dailyNudgeEveningBody",
];
const DAILY_NUDGE_LANGUAGES = SUPPORTED_LANGUAGES;
const DAILY_NUDGE_NOTIFICATION_TAG = "daily_nudge";
const ANDROID_DAILY_NUDGE_CHANNEL_ID = "daily-nudges";
const ANDROID_TAMAGOTCHI_CHANNEL_ID = "tamagotchi-hunger";
const DAILY_CHALLENGE_MIN_SPEND_EVENTS = 2;
const DAILY_CHALLENGE_FIXED_REWARD = 2;
const DAILY_CHALLENGE_LOOKBACK_MS = 24 * 60 * 60 * 1000;
const DAILY_CHALLENGE_STATUS = {
  IDLE: "idle",
  OFFER: "offer",
  ACTIVE: "active",
  COMPLETED: "completed",
  FAILED: "failed",
};
const FOCUS_VICTORY_THRESHOLD = 3;
const FOCUS_VICTORY_REWARD = 3;
const FOCUS_LOSS_THRESHOLD = 3;
const FOCUS_RECENT_WINDOW_MS = 2 * 24 * 60 * 60 * 1000;
const CHALLENGE_REWARD_SCALE = 0.5;
const getScaledChallengeReward = (value = 0) =>
  Math.max(1, Math.round(Math.max(0, value) * CHALLENGE_REWARD_SCALE));
const PUSH_NOTIFICATION_COOLDOWN_MS = 30 * 60 * 1000;
const PUSH_DEDUPE_WINDOW_MS = 6 * 60 * 60 * 1000;
const ACTIONABLE_NOTIFICATION_CATEGORY_ID = "impulse_action";
const NOTIFICATION_ACTION_SAVE = "action_save";
const NOTIFICATION_ACTION_SPEND = "action_spend";

const buildTemptationPressureMap = (events = []) => {
  const map = {};
  (Array.isArray(events) ? events : []).forEach((event) => {
    if (!event?.templateId) return;
    const entry = map[event.templateId] || {
      spend: 0,
      save: 0,
      lastTimestamp: 0,
    };
    if (event.action === "spend") {
      entry.spend += 1;
      if (event.timestamp && event.timestamp > entry.lastTimestamp) {
        entry.lastTimestamp = event.timestamp;
      }
    } else if (event.action === "save") {
      entry.save += 1;
    }
    map[event.templateId] = entry;
  });
  return map;
};

const resolveDailyChallengeTemplateId = (
  pressureMap = {},
  minSpendEvents = DAILY_CHALLENGE_MIN_SPEND_EVENTS,
  isValidTemplate = null
) => {
  const ranked = Object.entries(pressureMap || {})
    .map(([templateId, stats]) => ({
      templateId,
      spend: stats?.spend || 0,
      save: stats?.save || 0,
      lastTimestamp: stats?.lastTimestamp || 0,
      score: (stats?.spend || 0) * 2 - (stats?.save || 0),
    }))
    .filter((entry) => entry.spend >= minSpendEvents && entry.spend > entry.save)
    .sort((a, b) => {
      if (b.score !== a.score) return b.score - a.score;
      if (b.spend !== a.spend) return b.spend - a.spend;
      return b.lastTimestamp - a.lastTimestamp;
    });
  for (const entry of ranked) {
    if (typeof isValidTemplate === "function" && !isValidTemplate(entry.templateId)) {
      continue;
    }
    return entry.templateId;
  }
  return null;
};

const createInitialDailyChallengeState = () => ({
  id: null,
  dateKey: null,
  templateId: null,
  templateTitle: "",
  emoji: "âœ¨",
  priceUSD: 0,
  rewardBonus: 0,
  baseReward: 0,
  templateLabel: "",
  target: 1,
  progress: 0,
  status: DAILY_CHALLENGE_STATUS.IDLE,
  acceptedAt: null,
  completedAt: null,
  failedAt: null,
  offerDismissed: false,
  rewardGranted: false,
});
const buildDailyNudgeTrigger = (hour, minute) => {
  if (Platform.OS === "android") {
    const now = new Date();
    const next = new Date(now);
    next.setHours(hour, minute, 0, 0);
    if (next.getTime() <= now.getTime()) {
      next.setDate(next.getDate() + 1);
    }
    return next;
  }
  return { hour, minute, second: 0, repeats: true };
};


const normalizeSmartReminderEntries = (list) => {
  const now = Date.now();
  const seen = new Set();
  const normalized = [];
  (Array.isArray(list) ? list : []).forEach((entry) => {
    if (!entry) return;
    const timestamp = Number(entry.timestamp);
    if (!Number.isFinite(timestamp)) return;
    if (now - timestamp > SMART_REMINDER_RETENTION_MS) return;
    const eventId = entry.eventId || entry.id;
    if (!eventId || seen.has(eventId)) return;
    seen.add(eventId);
    normalized.push({
      id: entry.id || `smart-${eventId}`,
      eventId,
      kind: typeof entry.kind === "string" ? entry.kind : "refuse_spend",
      title: typeof entry.title === "string" ? entry.title : "",
      timestamp,
      scheduledAt: Number(entry.scheduledAt) || timestamp + SMART_REMINDER_DELAY_MS,
      notificationId: entry.notificationId || null,
      templateId: typeof entry.templateId === "string" ? entry.templateId : null,
    });
  });
  normalized.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
  return normalized.slice(0, SMART_REMINDER_LIMIT);
};

const DEFERRED_STORAGE_PARSE_THRESHOLD = 120000;
const shouldDeferLargeParse = (raw) =>
  typeof raw === "string" && raw.length >= DEFERRED_STORAGE_PARSE_THRESHOLD;
const deferNonFeedHydration = (task) => {
  InteractionManager.runAfterInteractions(task);
};

const resolveInterFontFamily = (fontWeight) => {
  if (typeof fontWeight === "string") {
    if (fontWeight.toLowerCase() === "bold") return INTER_FONTS.bold;
    if (fontWeight.toLowerCase() === "normal") return INTER_FONTS.regular;
  }
  const numericWeight = Number(fontWeight) || 0;
  if (numericWeight >= 900) return INTER_FONTS.black;
  if (numericWeight >= 800) return INTER_FONTS.extraBold;
  if (numericWeight >= 700) return INTER_FONTS.bold;
  if (numericWeight >= 600) return INTER_FONTS.semiBold;
  if (numericWeight >= 500) return INTER_FONTS.medium;
  if (numericWeight >= 300) return INTER_FONTS.light;
  return INTER_FONTS.regular;
};

const withInterTypography = (Component) => {
  if (!Component?.render) return;
  const defaultRender = Component.render;
  Component.render = function render(props = {}, ref) {
    const styleProp = props.style;
    const baseStyles = Array.isArray(styleProp)
      ? styleProp.filter(Boolean)
      : styleProp
        ? [styleProp]
        : [];
    const flattened = StyleSheet.flatten(baseStyles) || {};
    if (flattened.fontFamily) {
      return defaultRender.apply(this, [props, ref]);
    }
    const resolvedFontFamily = resolveInterFontFamily(flattened.fontWeight);
    const fontStyle = { fontFamily: resolvedFontFamily };
    const nextStyle = baseStyles.length ? [...baseStyles, fontStyle] : fontStyle;
    return defaultRender.apply(this, [{ ...props, style: nextStyle }, ref]);
  };
};

const ensureGlobalInterTypography = (() => {
  let applied = false;
  return () => {
    if (applied) return;
    [Text, TextInput, Animated.Text].forEach(withInterTypography);
    applied = true;
  };
})();

const APP_TUTORIAL_BASE_STEPS = [
  {
    id: "feed",
    icon: "ðŸ§ ",
    titleKey: "tutorialFeedTitle",
    descriptionKey: "tutorialFeedDesc",
    tabs: ["feed"],
  },
  {
    id: "goals",
    icon: "ðŸŽ¯",
    titleKey: "tutorialGoalsTitle",
    descriptionKey: "tutorialGoalsDesc",
    tabs: ["cart"],
  },
  {
    id: "rewards",
    icon: "ðŸ†",
    titleKey: "tutorialRewardsTitle",
    descriptionKey: "tutorialRewardsDesc",
    tabs: ["purchases"],
    requiresRewards: true,
  },
  {
    id: "profile",
    icon: "âš™ï¸",
    titleKey: "tutorialProfileTitle",
    descriptionKey: "tutorialProfileDesc",
    tabs: ["profile"],
  },
];
const TEMPTATION_TUTORIAL_STEPS = [
  {
    id: "actions",
    icon: "ðŸ‘†",
    titleKey: "temptationTutorialActionsTitle",
    descriptionKey: "temptationTutorialActionsDesc",
  },
  {
    id: "swipe",
    icon: "â†”ï¸",
    titleKey: "temptationTutorialSwipeTitle",
    descriptionKey: "temptationTutorialSwipeDesc",
  },
];
const FAB_TUTORIAL_STATUS = {
  DONE: "done",
  PENDING: "pending",
  SHOWING: "showing",
};
const QUEUED_MODAL_TYPES = {
  FAB_TUTORIAL: "fab_tutorial",
  DAILY_CHALLENGE: "daily_challenge",
  FOCUS_DIGEST: "focus_digest",
  DAILY_SUMMARY: "daily_summary",
};
const CARD_TEXTURE_ACCENTS = ["#8AB9FF", "#FFA4C0", "#8CE7CF", "#FFD48A", "#BBA4FF", "#7FD8FF"];
const TEMPTATION_CARD_RADIUS = 28;
// Fine-tune Android highlight alignment when using measureInWindow (positive moves the cutout lower).
const ANDROID_TUTORIAL_HIGHLIGHT_OFFSET = 6;
const TAB_BAR_BASE_HEIGHT = 64;
const HERO_MASCOT_SIZE = 96;
const FAB_BUTTON_SIZE = 64;
const FAB_CONTAINER_BOTTOM = 96;
const FAB_TUTORIAL_MIN_SESSIONS = 2;
const FAB_TUTORIAL_HALO_SIZE = 128;
const FAB_TUTORIAL_CARD_SPACING = 140;
const FAB_TUTORIAL_HALO_INSET = (FAB_TUTORIAL_HALO_SIZE - FAB_BUTTON_SIZE) / 2;
const TUTORIAL_HIGHLIGHT_INSET = { x: 0, y: 0 };
const BACK_GESTURE_EDGE_WIDTH = 32;
const BACK_GESTURE_TRIGGER_DISTANCE = 60;
const BACK_GESTURE_VERTICAL_SLOP = 60;
const MAX_TAB_HISTORY = 12;

const CELEBRATION_BASE_RU = [
  "Ð¥Ð¾Ð¿! Ð•Ñ‰Ñ‘ Ð¾Ð´Ð½Ð° Ð¾ÑÐ¾Ð·Ð½Ð°Ð½Ð½Ð°Ñ ÑÐºÐ¾Ð½Ð¾Ð¼Ð¸Ñ",
  "ÐœÐµÐ½ÑŒÑˆÐµ Ð»Ð¸ÑˆÐ½Ð¸Ñ… Ð¿Ð¾ÐºÑƒÐ¿Ð¾Ðº, Ð±Ð¾Ð»ÑŒÑˆÐµ Ð¿Ð»Ð°Ð½Ð°",
  "ÐšÐ¾ÑˆÐµÐ»Ñ‘Ðº Ð²Ð·Ð´Ð¾Ñ…Ð½ÑƒÐ» ÑÐ¿Ð¾ÐºÐ¾Ð¹Ð½Ð¾",
];

const CELEBRATION_MESSAGES = {
  ru: {
    female: [...CELEBRATION_BASE_RU, "Ð¢Ñ‹ ÑÐ½Ð¾Ð²Ð° Ð²Ñ‹Ð±Ñ€Ð°Ð»Ð° ÑƒÐ¼Ð½Ñ‹Ð¹ ÑÐ²Ð¾Ð¿ Ð²Ð¼ÐµÑÑ‚Ð¾ Ñ€Ð°ÑÑ‚Ñ€Ð°Ñ‚"],
    male: [...CELEBRATION_BASE_RU, "Ð¢Ñ‹ ÑÐ½Ð¾Ð²Ð° Ð²Ñ‹Ð±Ñ€Ð°Ð» ÑƒÐ¼Ð½Ñ‹Ð¹ ÑÐ²Ð¾Ð¿ Ð²Ð¼ÐµÑÑ‚Ð¾ Ñ€Ð°ÑÑ‚Ñ€Ð°Ñ‚"],
    none: [...CELEBRATION_BASE_RU, "Ð¡Ð½Ð¾Ð²Ð° Ð²Ñ‹Ð±Ñ€Ð°Ð½ ÑƒÐ¼Ð½Ñ‹Ð¹ ÑÐ²Ð¾Ð¿ Ð²Ð¼ÐµÑÑ‚Ð¾ Ñ€Ð°ÑÑ‚Ñ€Ð°Ñ‚"],
    level: "Ð£Ñ€Ð¾Ð²ÐµÐ½ÑŒ {{level}}! Ð­ÐºÐ¾Ð½Ð¾Ð¼Ð¸Ñ ÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑÑ Ð¿Ñ€Ð¸Ð²Ñ‹Ñ‡ÐºÐ¾Ð¹ ðŸ’Ž",
  },
  en: {
    default: [
      "Boom! Another mindful deal",
      "Less impulse, more plan",
      "Wallet just sighed with relief",
      "Smart deal locked â€“ savings are safe",
    ],
    level: "Level {{level}}! Savings armor upgraded âœ¨",
  },
  fr: {
    default: [
      "Boom ! Encore un choix conscient",
      "Moins d'impulsions, plus de plan",
      "Le portefeuille respire enfin",
      "Accord malin verrouillÃ© â€“ l'Ã©pargne est en sÃ©curitÃ©",
    ],
    level: "Niveau {{level}} ! Armure d'Ã©pargne amÃ©liorÃ©e âœ¨",
  },
  es: {
    default: [
      "Â¡Boom! Otro ahorro consciente",
      "Menos impulso, mÃ¡s plan",
      "La cartera respira aliviada",
      "Intercambio inteligente: el ahorro estÃ¡ a salvo",
    ],
    female: [
      "Â¡Boom! Otro ahorro consciente",
      "Menos impulso, mÃ¡s plan",
      "La cartera respira aliviada",
      "Intercambio inteligente: el ahorro estÃ¡ a salvo",
    ],
    male: [
      "Â¡Boom! Otro ahorro consciente",
      "Menos impulso, mÃ¡s plan",
      "La cartera respira aliviada",
      "Intercambio inteligente: el ahorro estÃ¡ a salvo",
    ],
    none: [
      "Â¡Boom! Otro ahorro consciente",
      "Menos impulso, mÃ¡s plan",
      "La cartera respira aliviada",
      "Intercambio inteligente: el ahorro estÃ¡ a salvo",
    ],
    level: "Â¡Nivel {{level}}! Tu armadura de ahorro sube de rango âœ¨",
  },
};

const getCelebrationMessages = (language, gender = "none") => {
  const normalized = normalizeLanguage(language);
  const entry = CELEBRATION_MESSAGES[normalized] || CELEBRATION_MESSAGES[FALLBACK_LANGUAGE];
  if (!entry) return [];
  if (Array.isArray(entry)) return entry;
  if (Array.isArray(entry.default)) return entry.default;
  const variant =
    (gender && entry[gender]) ||
    entry.none ||
    entry.default ||
    Object.values(entry)[0];
  return Array.isArray(variant) ? variant : [];
};

const RAIN_DROPS = 20;
const LTR_MARK = "\u200E"; // keeps currency labels left-to-right even with RTL symbols
const RTL_CURRENCIES = new Set(["SAR"]);
const CURRENCY_RATES = {
  AED: 3.67,
  AUD: 1.5,
  BYN: 3.3,
  CAD: 1.35,
  EUR: 0.92,
  GBP: 0.79,
  JPY: 150,
  KZT: 450,
  KRW: 1350,
  MXN: 17,
  PLN: 4,
  RUB: 92,
  SAR: 3.75,
  USD: 1,
};
const CURRENCY_REWARD_STEPS = {
  AED: 20,
  AUD: 5,
  BYN: 5,
  CAD: 5,
  EUR: 5,
  GBP: 5,
  JPY: 750,
  KZT: 2000,
  KRW: 7000,
  MXN: 100,
  PLN: 20,
  RUB: 500,
  SAR: 20,
  USD: 5,
};
const DEFAULT_COIN_SLIDER_MAX_USD = 50;
const COIN_SLIDER_SIZE = 220;
const COIN_SLIDER_VALUE_DEADBAND = 0.01;
const COIN_SLIDER_STATE_MIN_INTERVAL = 16;
const COIN_SLIDER_HAPTIC_COOLDOWN_MS = 80;
const COIN_SLIDER_STEP_STICKINESS = 0.95;
const COIN_SLIDER_GESTURE_DEADBAND = 0.03;
const COIN_FILL_MIN_HEIGHT = 12;
const CURRENCY_SIGNS = {
  AED: "AED ",
  AUD: "A$",
  BYN: "Br",
  CAD: "C$",
  EUR: "â‚¬",
  GBP: "Â£",
  JPY: "Â¥",
  KZT: "â‚¸",
  KRW: "â‚©",
  MXN: "MX$",
  PLN: "zÅ‚",
  RUB: "â‚½",
  SAR: "ï·¼",
  USD: "$",
};
const CURRENCY_FINE_STEPS = {
  AED: 0.5,
  AUD: 0.5,
  BYN: 0.5,
  CAD: 0.5,
  EUR: 0.5,
  GBP: 0.5,
  JPY: 10,
  KZT: 10,
  KRW: 100,
  MXN: 0.5,
  PLN: 0.5,
  RUB: 5,
  SAR: 0.5,
  USD: 0.5,
};
const CURRENCY_DISPLAY_PRECISION = {
  AED: 0,
  AUD: 0,
  BYN: 0,
  CAD: 0,
  EUR: 0,
  GBP: 0,
  MXN: 0,
  PLN: 0,
  SAR: 0,
  USD: 0,
};
const ECONOMY_RULES = {
  saveRewardStepUSD: 5,
  minSaveReward: 1,
  maxSaveReward: 24,
  baseAchievementReward: 60,
  freeDayRescueCost: 60,
  tamagotchiFeedCost: 2,
  tamagotchiFeedBoost: 24,
  tamagotchiPartyCost: 40,
};
const DEFAULT_REMOTE_IMAGE =
  "https://images.unsplash.com/photo-1498050108023-c5249f4df085?auto=format&fit=crop&w=600&q=80";
const REMINDER_DAYS = 14;
const DAY_MS = 1000 * 60 * 60 * 24;
const CHALLENGE_REPEAT_COOLDOWN_MS = DAY_MS * 7;
const HOUR_MS = 1000 * 60 * 60;
const MINUTE_MS = 1000 * 60;
const REWARD_RESET_INTERVAL_MS = DAY_MS * 14;
const REMINDER_MS = REMINDER_DAYS * DAY_MS;
const PENDING_EXTENSION_DAYS = 7;
const PENDING_EXTENSION_MS = PENDING_EXTENSION_DAYS * DAY_MS;
const PENDING_REMINDER_LEAD_MS = HOUR_MS;
const PENDING_REMINDER_GRACE_MS = 30 * MINUTE_MS;
const SAVE_SPAM_WINDOW_MS = 1000 * 60 * 5;
const SAVED_TOTAL_RESET_GRACE_MS = 1000 * 5;
const SAVE_SPAM_ITEM_LIMIT = 3;
const SAVE_SPAM_GLOBAL_LIMIT = 5;
const NORTH_STAR_SAVE_THRESHOLD = 2;
const NORTH_STAR_WINDOW_MS = DAY_MS;
const SAVE_ACTION_COLOR = "#2EB873";
const SPEND_ACTION_COLOR = "#D94862";
// Android darkens translucent backgrounds when elevation is applied, so use opaque fallbacks there.
const COIN_ENTRY_SAVE_BACKGROUND =
  Platform.OS === "android" ? "#E6F6EE" : "rgba(46,184,115,0.12)";
const COIN_ENTRY_SPEND_BACKGROUND =
  Platform.OS === "android" ? "#FAE9EC" : "rgba(217,72,98,0.12)";
const GOAL_HIGHLIGHT_COLOR = "#F6C16B";
const GOAL_SWIPE_THRESHOLD = 80;
const DELETE_SWIPE_THRESHOLD = 130;
const CHALLENGE_SWIPE_ACTION_WIDTH = 120;
const BASELINE_SAMPLE_USD = 120;
const CUSTOM_SPEND_SAMPLE_USD = 7.5;
const RATING_PROMPT_DELAY_DAYS = 2; // show on the third calendar day (after two full days)
const RATING_PROMPT_ACTION_THRESHOLD = 3;
const RATING_PROMPT_ACTION_TYPES = new Set(["save", "spend", "wish", "pending"]);
const ANDROID_REVIEW_URL = "market://details?id=com.sasarei.almostclean";
const ANDROID_REVIEW_WEB_URL = "https://play.google.com/store/apps/details?id=com.sasarei.almostclean";
const IOS_REVIEW_URL = "itms-apps://itunes.apple.com/app/id6756276744?action=write-review";
const IOS_REVIEW_WEB_URL = "https://apps.apple.com/app/id6756276744?action=write-review";
const LEVEL_SHARE_CAT = require("./assets/Cat_mascot.png");
const LEVEL_SHARE_LOGO = require("./assets/Almost_icon.png");
const LEVEL_SHARE_ACCENT = "#FFB347";
const LEVEL_SHARE_BG = "#050C1A";
const LEVEL_SHARE_MUTED = "rgba(255,255,255,0.65)";
const createInitialRatingPromptState = () => ({
  firstOpenAt: new Date().toISOString(),
  completed: false,
  lastShownAt: null,
  lastAction: null,
  respondedAt: null,
  actionCount: 0,
  actionPrompted: false,
});

const getDayKey = (date) => {
  const d = new Date(date);
  if (Number.isNaN(d.getTime())) return "";
  d.setHours(0, 0, 0, 0);
  const year = d.getFullYear();
  const month = String(d.getMonth() + 1).padStart(2, "0");
  const day = String(d.getDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
};

const parseDayKey = (key) => {
  if (typeof key !== "string" || key.trim().length === 0) return null;
  const [yearStr, monthStr, dayStr] = key.split("-");
  const year = Number(yearStr);
  const month = Number(monthStr);
  const day = Number(dayStr);
  if (!year || !month || !day) return null;
  const date = new Date(year, month - 1, day);
  if (Number.isNaN(date.getTime())) return null;
  date.setHours(0, 0, 0, 0);
  return date;
};

const getDayDiff = (fromKey, toKey) => {
  const fromDate = parseDayKey(fromKey);
  const toDate = parseDayKey(toKey);
  if (!fromDate || !toDate) return null;
  return Math.round((toDate.getTime() - fromDate.getTime()) / DAY_MS);
};

const isSameDay = (tsA, tsB = Date.now()) => {
  if (!tsA) return false;
  return getDayKey(tsA) === getDayKey(tsB);
};
const WEEKDAY_FULL_LABELS = {
  ru: ["Ð²Ð¾ÑÐºÑ€ÐµÑÐµÐ½ÑŒÐµ", "Ð¿Ð¾Ð½ÐµÐ´ÐµÐ»ÑŒÐ½Ð¸Ðº", "Ð²Ñ‚Ð¾Ñ€Ð½Ð¸Ðº", "ÑÑ€ÐµÐ´Ð°", "Ñ‡ÐµÑ‚Ð²ÐµÑ€Ð³", "Ð¿ÑÑ‚Ð½Ð¸Ñ†Ð°", "ÑÑƒÐ±Ð±Ð¾Ñ‚Ð°"],
  en: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  es: ["domingo", "lunes", "martes", "miÃ©rcoles", "jueves", "viernes", "sÃ¡bado"],
  fr: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"],
};
const formatRelativeDayLabel = (timestamp, referenceTs, language = DEFAULT_LANGUAGE) => {
  if (!Number.isFinite(timestamp) || !Number.isFinite(referenceTs)) return null;
  const fromKey = getDayKey(timestamp);
  const toKey = getDayKey(referenceTs);
  const diff = getDayDiff(fromKey, toKey);
  if (diff === null) return null;
  const normalizedLanguage = normalizeLanguage(language);
  const weekdayLabels = WEEKDAY_FULL_LABELS[normalizedLanguage] || WEEKDAY_FULL_LABELS[DEFAULT_LANGUAGE];
  const weekday = weekdayLabels[new Date(timestamp).getDay()] || weekdayLabels[0];
  const formatDaysAgo = (count) => {
    if (!Number.isFinite(count) || count <= 0) return null;
    if (normalizedLanguage === "ru") {
      const mod10 = count % 10;
      const mod100 = count % 100;
      let unit = "Ð´Ð½ÐµÐ¹";
      if (mod10 === 1 && mod100 !== 11) {
        unit = "Ð´ÐµÐ½ÑŒ";
      } else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
        unit = "Ð´Ð½Ñ";
      }
      return `${count} ${unit} Ð½Ð°Ð·Ð°Ð´`;
    }
    if (normalizedLanguage === "es") {
      return `hace ${count} dÃ­a${count === 1 ? "" : "s"}`;
    }
    if (normalizedLanguage === "fr") {
      return `il y a ${count} jour${count === 1 ? "" : "s"}`;
    }
    return `${count} day${count === 1 ? "" : "s"} ago`;
  };
  const formatOnWeekday = (dayLabel) => {
    if (!dayLabel) return null;
    if (normalizedLanguage === "ru") return `Ð² ${dayLabel}`;
    if (normalizedLanguage === "es") return `el ${dayLabel}`;
    if (normalizedLanguage === "fr") return `le ${dayLabel}`;
    return `on ${dayLabel}`;
  };
  if (diff === 0) {
    if (normalizedLanguage === "ru") return "ÑÐµÐ³Ð¾Ð´Ð½Ñ";
    if (normalizedLanguage === "es") return "hoy";
    if (normalizedLanguage === "fr") return "aujourd'hui";
    return "today";
  }
  if (diff === 1) {
    if (normalizedLanguage === "ru") return "Ð²Ñ‡ÐµÑ€Ð°";
    if (normalizedLanguage === "es") return "ayer";
    if (normalizedLanguage === "fr") return "hier";
    return "yesterday";
  }
  if (diff === 2) {
    return formatDaysAgo(2);
  }
  if (diff > 2 && diff <= 6) {
    return formatOnWeekday(weekday);
  }
  if (diff < 0) {
    return formatOnWeekday(weekday);
  }
  return formatDaysAgo(Math.abs(diff));
};
const DEFAULT_TEMPTATION_EMOJI = "âœ¨";
const DEFAULT_GOAL_EMOJI = "ðŸŽ¯";
const MAX_HISTORY_EVENTS = 200;
const HISTORY_RETENTION_MS = DAY_MS * 31;
const SPEND_LOGGING_REMINDER_DELAY_MS = DAY_MS * 1.5;
const SPEND_LOGGING_REMINDER_COOLDOWN_MS = DAY_MS * 2;
const HISTORY_VIEWPORT_ROWS = 5;
const HISTORY_ITEM_HEIGHT = 60;
const HISTORY_VIEWPORT_HEIGHT = HISTORY_VIEWPORT_ROWS * HISTORY_ITEM_HEIGHT;
const HISTORY_SAVED_GAIN_EVENTS = new Set(["refuse_spend", "pending_to_decline"]);
const HISTORY_SAVED_LOSS_EVENTS = new Set(["spend"]);
const describeHistoryEntry = (entry, { t, formatLocalAmount }) => {
  if (!entry) return t("historyUnknown");
  const { kind, meta = {} } = entry;
  const title = meta.title || t("historyUnknown");
  switch (kind) {
    case "wish_added":
      return t("historyWishAdded", { title });
    case "wish_progress":
      return t("historyWishProgress", {
        title,
        amount: formatLocalAmount(meta.savedUSD),
        target: formatLocalAmount(meta.targetUSD),
      });
    case "wish_completed":
      return t("historyWishDone", { title });
    case "decline":
      return t("historyDecline", { title, amount: formatLocalAmount(meta.amountUSD) });
    case "refuse_spend":
      return t("historyRefuseSpend", { title, amount: formatLocalAmount(meta.amountUSD) });
    case "pending_added":
      return t("historyPendingAdded", { title });
    case "pending_to_wish":
      return t("historyPendingWant", { title });
    case "pending_to_decline":
      return t("historyPendingDecline", { title, amount: formatLocalAmount(meta.amountUSD) });
    case "pending_removed":
      return t("historyPendingRemoved", { title });
    case "free_day":
      return t("historyFreeDay", { total: meta.total || 0 });
    case "spend":
      return t("historySpend", { title, amount: formatLocalAmount(meta.amountUSD) });
    case "wish_removed":
      return t("historyWishRemoved", { title });
    case "goal_started":
      return t("historyGoalStarted", { title });
    case "goal_cancelled":
      return t("historyGoalCancelled", { title });
    case "reward_claimed":
      return t("historyRewardClaimed", { title: title || meta.rewardId || t("historyUnknown") });
    default:
      return t("historyUnknown");
  }
};
const formatHistoryEntryMeta = (entry, { t, locale }) => {
  if (!entry?.timestamp) return "";
  try {
    const date = new Date(entry.timestamp);
    const dateLabel = date.toLocaleDateString(locale, { day: "numeric", month: "short" });
    const timeLabel = date.toLocaleTimeString(locale, { hour: "2-digit", minute: "2-digit" });
    return t("historyTimestamp", { date: dateLabel, time: timeLabel });
  } catch {
    return "";
  }
};
const normalizeClaimedRewardEntry = (value, now = Date.now()) => {
  if (!value) return null;
  if (typeof value === "object" && Number.isFinite(value.claimedAt)) {
    return { claimedAt: value.claimedAt };
  }
  if (typeof value === "number" && Number.isFinite(value)) {
    return { claimedAt: value };
  }
  if (value === true) {
    return { claimedAt: now };
  }
  return null;
};
const normalizeClaimedRewardsMap = (map, now = Date.now()) => {
  if (!map || typeof map !== "object") return {};
  const normalized = {};
  Object.entries(map).forEach(([key, entry]) => {
    const normalizedEntry = normalizeClaimedRewardEntry(entry, now);
    if (!normalizedEntry) return;
    if (now - normalizedEntry.claimedAt < REWARD_RESET_INTERVAL_MS) {
      normalized[key] = normalizedEntry;
    }
  });
  return normalized;
};
const claimedRewardsEqual = (a = {}, b = {}) => {
  const aKeys = Object.keys(a || {});
  const bKeys = Object.keys(b || {});
  if (aKeys.length !== bKeys.length) return false;
  return aKeys.every((key) => {
    const aEntry = a[key];
    const bEntry = b[key];
    if (!bEntry || !aEntry) return false;
    return Number(aEntry.claimedAt) === Number(bEntry.claimedAt);
  });
};
const getHealthCoinTierForAmount = (amount = 0) => {
  const normalized = Math.max(0, Math.floor(amount));
  for (let i = HEALTH_COIN_TIERS.length - 1; i >= 0; i -= 1) {
    const tier = HEALTH_COIN_TIERS[i];
    if (normalized >= tier.value) {
      return tier;
    }
  }
  return HEALTH_COIN_TIERS[0];
};
const getHealthCoinBreakdown = (amount = 0) => {
  let remaining = Math.max(0, Math.floor(amount));
  const breakdown = {};
  for (let i = HEALTH_COIN_TIERS.length - 1; i >= 0; i -= 1) {
    const tier = HEALTH_COIN_TIERS[i];
    const count = Math.floor(remaining / tier.value);
    breakdown[tier.id] = count;
    remaining -= count * tier.value;
  }
  HEALTH_COIN_TIERS.forEach((tier) => {
    if (!breakdown[tier.id]) breakdown[tier.id] = 0;
  });
  return breakdown;
};
const buildHealthCoinEntries = (amount = 0) => {
  const breakdown = getHealthCoinBreakdown(amount);
  return HEALTH_COIN_TIERS.slice().reverse().map((tier) => ({
    ...tier,
    count: breakdown[tier.id] || 0,
  }));
};
const getLocalRewardStep = (currencyCode = activeCurrency) => {
  const code = typeof currencyCode === "string" && currencyCode.trim() ? currencyCode : activeCurrency;
  if (code && CURRENCY_REWARD_STEPS[code]) {
    return CURRENCY_REWARD_STEPS[code];
  }
  const rate = code ? CURRENCY_RATES[code] : null;
  if (rate && ECONOMY_RULES.saveRewardStepUSD > 0) {
    return ECONOMY_RULES.saveRewardStepUSD * rate;
  }
  return ECONOMY_RULES.saveRewardStepUSD;
};
const computeRefuseCoinReward = (amountUSD = 0, currencyCode = activeCurrency) => {
  if (!amountUSD || amountUSD <= 0) return 0;
  const localAmount = convertToCurrency(amountUSD, currencyCode);
  const localStep = getLocalRewardStep(currencyCode);
  if (!localStep || localStep <= 0) return 0;
  const normalized = Math.ceil(localAmount / localStep);
  if (normalized <= 0) return 0;
  const adjusted = Math.max(ECONOMY_RULES.minSaveReward, normalized);
  return Math.min(ECONOMY_RULES.maxSaveReward, adjusted);
};

const computeDailyChallengeBonus = (amountUSD = 0, currencyCode = activeCurrency) => {
  return computeRefuseCoinReward(amountUSD, currencyCode);
};

const computeLevelRewardCoins = (level) => {
  if (level <= 1) return 0;
  if (level <= 9) return Math.max(1, level - 1);
  return level;
};

const sumLevelRewardCoins = (level, levelsEarned = 1) => {
  if (level <= 1 || levelsEarned <= 0) return 0;
  const start = Math.max(2, level - levelsEarned + 1);
  let total = 0;
  for (let current = start; current <= level; current += 1) {
    total += computeLevelRewardCoins(current);
  }
  return total;
};

const DEFAULT_DAILY_REWARD_STATE = {
  lastKey: null,
  lastAmount: 0,
  lastClaimAt: 0,
  streak: 0,
};

const DAILY_REWARD_STREAK_LENGTH = 7;

const computeDailyAlmiReward = (savedUSD = 0) => {
  const normalized = Math.max(0, Number(savedUSD) || 0);
  if (normalized <= 0) return ECONOMY_RULES.minSaveReward;
  if (normalized < 50) return 2;
  if (normalized < 200) return 3;
  if (normalized < 500) return 4;
  if (normalized < 1000) return 6;
  return Math.min(12, Math.round(normalized / 200));
};

const buildDailyRewardSchedule = (baseAmount = 0) => {
  const base = Math.max(1, Math.round(baseAmount || 0));
  const rewards = Array.from({ length: DAILY_REWARD_STREAK_LENGTH - 1 }).map(
    (_, index) => base + index
  );
  const daySix = rewards[rewards.length - 1] || base;
  const superPrize = Math.max(daySix + 2, base + Math.round(base * 1.5));
  return [...rewards, superPrize];
};

const getDailyRewardForDay = (baseAmount = 0, day = 1) => {
  const schedule = buildDailyRewardSchedule(baseAmount);
  const index = Math.min(DAILY_REWARD_STREAK_LENGTH, Math.max(1, Number(day) || 1)) - 1;
  return schedule[index] || schedule[0] || Math.max(1, Math.round(baseAmount || 0));
};

const getTemptationPriceLimitForLevel = (level = 1) => {
  if (!Number.isFinite(level) || level <= 1) return 15;
  if (level < 4) return 50;
  if (level < 6) return 150;
  return Infinity;
};

const FEATURE_UNLOCK_STEPS = [
  { level: 2, messageKey: "level2UnlockMessage" },
  { level: 3, messageKey: "level3UnlockMessage" },
  { level: 4, messageKey: "level4ImpulseMapUnlockMessage" },
  { level: 5, messageKey: "level5UnlockMessage" },
  { level: 6, messageKey: "level6UnlockMessage" },
  { level: 7, messageKey: "level7UnlockMessage" },
];
const FEATURE_UNLOCK_VARIANT_MAP = {
  level2UnlockMessage: "rewardsDaily",
  level3UnlockMessage: "feedFocus",
  level4ImpulseMapUnlockMessage: "impulseMap",
  level5UnlockMessage: "rewardsCustomization",
  level6UnlockMessage: "catCustomization",
  level7UnlockMessage: "freeDay",
};
const FEATURE_UNLOCK_VARIANT_CONFIG = {
  rewardsDaily: {
    titleKey: "featureUnlockRewardsDailyTitle",
    descriptionKey: "featureUnlockRewardsDailyDescription",
    previewLabelKey: "featureUnlockRewardsDailyPreview",
  },
  feedFocus: {
    titleKey: "featureUnlockFeedFocusTitle",
    descriptionKey: "featureUnlockFeedFocusDescription",
    previewLabelKey: "featureUnlockFeedFocusPreview",
  },
  rewardsCustomization: {
    titleKey: "featureUnlockRewardsCustomizationTitle",
    descriptionKey: "featureUnlockRewardsCustomizationDescription",
    previewLabelKey: "featureUnlockRewardsCustomizationPreview",
  },
  catCustomization: {
    titleKey: "featureUnlockCatCustomizationTitle",
    descriptionKey: "featureUnlockCatCustomizationDescription",
    previewLabelKey: "featureUnlockCatCustomizationPreview",
  },
  rewardsChallenges: {
    titleKey: "featureUnlockRewardsChallengesTitle",
    descriptionKey: "featureUnlockRewardsChallengesDescription",
    previewLabelKey: "featureUnlockRewardsChallengesPreview",
  },
  impulseMap: {
    titleKey: "featureUnlockImpulseMapTitle",
    descriptionKey: "featureUnlockImpulseMapDescription",
    previewLabelKey: "featureUnlockImpulseMapPreview",
  },
  thinkingList: {
    titleKey: "featureUnlockThinkingTitle",
    descriptionKey: "featureUnlockThinkingDescription",
    previewLabelKey: "featureUnlockThinkingPreview",
  },
  freeDay: {
    titleKey: "featureUnlockFreeDayTitle",
    descriptionKey: "featureUnlockFreeDayDescription",
    previewLabelKey: "featureUnlockFreeDayTitle",
  },
};
const FEATURE_UNLOCK_LEVELS = {
  rewardsDaily: 2,
  feedFocus: 3,
  rewardsCustomization: 5,
  catCustomization: 6,
  rewardsChallenges: 1,
  impulseMap: 4,
  thinkingList: 3,
  freeDay: 7,
};

const HEALTH_COIN_LABELS = {
  ru: {
    pink: "Ñ€Ð¾Ð·Ð¾Ð²Ñ‹Ñ… Ð¼Ð¾Ð½ÐµÑ‚",
    red: "ÐºÑ€Ð°ÑÐ½Ñ‹Ñ… Ð¼Ð¾Ð½ÐµÑ‚",
    orange: "Ð¾Ñ€Ð°Ð½Ð¶ÐµÐ²Ñ‹Ñ… Ð¼Ð¾Ð½ÐµÑ‚",
    blue: "ÑÐ¸Ð½Ð¸Ñ… Ð¼Ð¾Ð½ÐµÑ‚",
    green: "Ð·ÐµÐ»Ñ‘Ð½Ñ‹Ñ… Ð¼Ð¾Ð½ÐµÑ‚",
  },
  en: {
    pink: "pink coins",
    red: "red coins",
    orange: "orange coins",
    blue: "blue coins",
    green: "green coins",
  },
  es: {
    pink: "monedas rosas",
    red: "monedas rojas",
    orange: "monedas naranjas",
    blue: "monedas azules",
    green: "monedas verdes",
  },
  fr: {
    pink: "piÃ¨ces roses",
    red: "piÃ¨ces rouges",
    orange: "piÃ¨ces orange",
    blue: "piÃ¨ces bleues",
    green: "piÃ¨ces vertes",
  },
};
const ZERO_HEALTH_REWARD_LABELS = {
  ru: "0 Ð¼Ð¾Ð½ÐµÑ‚",
  en: "0 coins",
  es: "0 monedas",
  fr: "0 piÃ¨ce",
};
const formatHealthRewardLabel = (amount = 0, language = DEFAULT_LANGUAGE) => {
  const entries = buildHealthCoinEntries(amount);
  const labels = HEALTH_COIN_LABELS[language] || HEALTH_COIN_LABELS.en;
  const parts = entries
    .filter((entry) => entry.count > 0)
    .map((entry) => `${entry.count} ${labels[entry.id] || entry.id}`);
  if (!parts.length) {
    return ZERO_HEALTH_REWARD_LABELS[language] || ZERO_HEALTH_REWARD_LABELS.en;
  }
  return parts.join(" Â· ");
};

const HealthRewardTokens = ({
  amount = 0,
  color = "#fff",
  iconSize = 18,
  maxItems = 3,
  zeroLabel = "0",
  textSize = 12,
  rowStyle = null,
  countStyle = null,
}) => {
  const entries = useMemo(
    () => buildHealthCoinEntries(amount).filter((entry) => entry.count > 0),
    [amount]
  );
  const visible = entries.slice(0, maxItems);
  const rowStyles = rowStyle ? [styles.healthRewardTokenRow, rowStyle] : [styles.healthRewardTokenRow];
  const countStyles = [
    styles.healthRewardTokenCount,
    { color, fontSize: textSize },
    ...(countStyle ? [countStyle] : []),
  ];
  if (!visible.length) {
    return (
      <View style={rowStyles}>
        <Text style={countStyles}>{zeroLabel}</Text>
      </View>
    );
  }
  return (
    <View style={rowStyles}>
      {visible.map((entry) => (
        <View key={`${entry.id}-${entry.count}`} style={styles.healthRewardToken}>
          <Image
            source={entry.asset}
            style={[styles.healthRewardTokenIcon, { width: iconSize, height: iconSize }]}
          />
          <Text style={countStyles}>{`Ã—${entry.count}`}</Text>
        </View>
      ))}
    </View>
  );
};
const INITIAL_DECISION_STATS = {
  resolvedToWishes: 0,
  resolvedToDeclines: 0,
};

const MOOD_IDS = {
  NEUTRAL: "neutral",
  FOCUSED: "focused",
  IMPULSIVE: "impulsive",
  DOUBTER: "doubter",
  TIRED: "tired",
  DREAMER: "dreamer",
};
const MOOD_MAX_EVENTS = 24;
const MOOD_ACTION_WINDOW_MS = 1000 * 60 * 60 * 48;
const MOOD_EVENT_THRESHOLD = 3;
const MOOD_PENDING_THRESHOLD = 4;
const MOOD_DREAM_WISH_THRESHOLD = 3;
const MOOD_INACTIVITY_THRESHOLD_MS = 1000 * 60 * 60 * 72;
const createMoodStateForToday = (overrides = {}) => ({
  current: MOOD_IDS.NEUTRAL,
  events: [],
  lastInteractionAt: null,
  lastVisitAt: null,
  pendingSnapshot: 0,
  dayKey: getDayKey(Date.now()),
  ...overrides,
});

const INITIAL_MOOD_STATE = createMoodStateForToday();

const MOOD_PRESETS = {
  [MOOD_IDS.NEUTRAL]: {
    label: { ru: "Ð ÐµÐ¶Ð¸Ð¼ Ð±Ð°Ð»Ð°Ð½ÑÐ°", en: "Balanced mode", es: "Modo balance", fr: "Mode Ã©quilibre" },
    hero: {
      ru: "Ð‘Ð°Ð»Ð°Ð½Ñ Ð´ÐµÑ€Ð¶Ð¸Ñ‚ÑÑ, Ð¿Ñ€Ð¾ÑÑ‚Ð¾ Ð¿Ñ€Ð¾Ð´Ð¾Ð»Ð¶Ð°Ð¹ Ð¾Ñ‚Ð¼ÐµÑ‡Ð°Ñ‚ÑŒ Ð¿Ð¾Ð±ÐµÐ´Ñ‹.",
      en: "Balance holds steady-keep logging the wins.",
      es: "El balance se mantiene: sigue registrando victorias.",
      fr: "L'Ã©quilibre tient bon : continue de noter tes victoires.",
    },
    heroComplete: {
      ru: "Ð ÐµÐ¶Ð¸Ð¼ ÑÐ¿Ð¾ÐºÐ¾Ð¹ÑÑ‚Ð²Ð¸Ñ Ñ„Ð¸ÐºÑÐ¸Ñ€ÑƒÐµÑ‚ ÐºÐ°Ð¶Ð´Ð¾Ðµ Ð´Ð¾ÑÑ‚Ð¸Ð¶ÐµÐ½Ð¸Ðµ.",
      en: "Calm mode celebrates each milestone.",
      es: "El modo calma celebra cada logro.",
      fr: "Le mode calme cÃ©lÃ¨bre chaque Ã©tape.",
    },
    motivation: {
      ru: "ÐÐµÐ±Ð¾Ð»ÑŒÑˆÐ¾Ð¹ ÑˆÐ°Ð³ ÑÐµÐ³Ð¾Ð´Ð½Ñ ÑÐ¿Ð°ÑÐ°ÐµÑ‚ Ð·Ð°Ð²Ñ‚Ñ€Ð°ÑˆÐ½Ð¸Ð¹ Ð¿Ð»Ð°Ð½.",
      en: "A tiny step today protects tomorrowâ€™s plan.",
      es: "Un paso pequeÃ±o hoy protege el plan de maÃ±ana.",
      fr: "Un petit pas aujourd'hui protÃ¨ge le plan de demain.",
    },
    saveOverlay: {
      ru: "Ð‘Ð°Ð»Ð°Ð½Ñ ÑƒÑÐ¸Ð»ÐµÐ½ ÐµÑ‰Ñ‘ Ð¾Ð´Ð½Ð¸Ð¼ Ð¾Ñ‚ÐºÐ°Ð·Ð¾Ð¼.",
      en: "Balance reinforced with another skip.",
      es: "El balance se refuerza con otro rechazo.",
      fr: "L'Ã©quilibre est renforcÃ© par un refus de plus.",
    },
    impulseOverlay: {
      ru: "Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ ÑÐ¿Ð¾ÐºÐ¾Ð¹ÑÑ‚Ð²Ð¸Ðµ Ð´Ð°Ð¶Ðµ Ð¿Ñ€Ð¸ ÑˆÑ‚Ð¾Ñ€Ð¼Ð°Ñ….",
      en: "Staying calm even when urges spike.",
      es: "Mantenemos la calma incluso cuando suben los impulsos.",
      fr: "On reste calme mÃªme quand les envies montent.",
    },
    pushPendingTitle: {
      ru: "Ð‘Ð°Ð»Ð°Ð½Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÑ‚ Ñ…Ð¾Ñ‚ÐµÐ»ÐºÑƒ ðŸ˜º",
      en: "Balance check-in ðŸ˜º",
      es: "Recordatorio de balance ðŸ˜º",
      fr: "ContrÃ´le Ã©quilibre ðŸ˜º",
    },
    pushPendingBody: {
      ru: "Â«{{title}}Â» Ð¶Ð´ÐµÑ‚ Ñ€ÐµÑˆÐµÐ½Ð¸Ñ. ÐŸÐ¾Ð´ÑƒÐ¼Ð°Ð¹, ÑÑ‚Ð¾Ð¸Ñ‚ Ð»Ð¸ Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ ÐºÑƒÑ€Ñ. ðŸ§­",
      en: "â€œ{{title}}â€ is waiting. Decide if it fits the plan. ðŸ§­",
      es: "â€œ{{title}}â€ sigue esperando. Decide si se queda en el plan. ðŸ§­",
      fr: "Â« {{title}} Â» attend. DÃ©cide si Ã§a reste dans le plan. ðŸ§­",
    },
    pushImpulseTitle: {
      ru: "Ð‘Ð°Ð»Ð°Ð½Ñ Ð² Ð´ÐµÐ»Ðµ ðŸ˜º",
      en: "Balance alert ðŸ˜º",
      es: "Aviso de balance ðŸ˜º",
      fr: "Alerte Ã©quilibre ðŸ˜º",
    },
    pushImpulseBody: {
      ru: "Ð’ ÑÑ‚Ð¾ Ð²Ñ€ÐµÐ¼Ñ Ñ…Ð¾Ñ‡ÐµÑ‚ÑÑ {{temptation}}, Ð½Ð¾ Ð±Ð°Ð»Ð°Ð½Ñ Ð¿Ñ€ÐµÐ´Ð»Ð°Ð³Ð°ÐµÑ‚ ÑÐ¿Ð°ÑÑ‚Ð¸ {{amount}}. ðŸ’§",
      en: "This hour usually tempts {{temptation}}, but balance can bank {{amount}}. ðŸ’§",
      es: "A esta hora suele ganar {{temptation}}, pero el balance puede guardar {{amount}}. ðŸ’§",
      fr: "Ã€ cette heure {{temptation}} appelle, mais l'Ã©quilibre peut mettre {{amount}} de cÃ´tÃ©. ðŸ’§",
    },
  },
  [MOOD_IDS.FOCUSED]: {
    label: { ru: "Ð’Ð¾Ð»ÐµÐ²Ð¾Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼", en: "Focused mode", es: "Modo enfoque", fr: "Mode focus" },
    hero: {
      ru: "Ð’Ð¾Ð»ÐµÐ²Ð¾Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ Ð°ÐºÑ‚Ð¸Ð²ÐµÐ½ - Ð¸ÑÐºÑƒÑˆÐµÐ½Ð¸Ñ ÑÐ°Ð¼Ð¸ Ð¿ÑƒÐ³Ð°ÑŽÑ‚ÑÑ.",
      en: "Focused mode is on-temptations get nervous.",
      es: "El modo enfoque estÃ¡ activo: las tentaciones se ponen nerviosas.",
      fr: "Le mode focus est activÃ© : les tentations se crispent.",
    },
    heroComplete: {
      ru: "Ð’Ð¾Ð»ÐµÐ²Ð¾Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ Ð¸ Ñ†ÐµÐ»ÑŒ ÑÐ´ÐµÐ»Ð°Ð½Ñ‹! ÐœÐ¾Ð¶Ð½Ð¾ Ð¿Ð»Ð°Ð½Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð±Ð¾Ð»ÑŒÑˆÐµ.",
      en: "Focused mode + goal complete! Time to plan even bigger.",
      es: "Modo enfoque + meta completa. Hora de un objetivo mÃ¡s grande.",
      fr: "Mode focus + objectif atteint ! Place Ã  un rÃªve plus grand.",
    },
    motivation: {
      ru: "Ð ÐµÐ¶Ð¸Ð¼ ÑÐ¸Ð»Ñ‹: ÑÐ¾Ð±ÐµÑ€Ð¸ ÐµÑ‰Ñ‘ Ð¾Ð´Ð½Ð¾ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ðµ Ð´Ð¸ÑÑ†Ð¸Ð¿Ð»Ð¸Ð½Ñ‹.",
      en: "Power mode: lock in one more proof of discipline.",
      es: "Modo potencia: suma otra prueba de disciplina.",
      fr: "Mode puissance : ajoute une preuve de discipline de plus.",
    },
    saveOverlay: {
      ru: "Ð’Ð¾Ð»ÐµÐ²Ð¾Ðµ Ñ€ÐµÑˆÐµÐ½Ð¸Ðµ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¾. Ð¢Ð°Ðº Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ!",
      en: "Willpower locked in. Keep it going!",
      es: "La fuerza de voluntad quedÃ³ registrada. Â¡Sigue asÃ­!",
      fr: "Force de volontÃ© verrouillÃ©e. Continue comme Ã§a !",
    },
    impulseOverlay: {
      ru: "Ð’Ð¾Ð»ÐµÐ²Ð¾Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ ÑƒÐ¼ÐµÐµÑ‚ Ñ‚Ð¾Ñ€Ð¼Ð¾Ð·Ð¸Ñ‚ÑŒ Ð¸Ð¼Ð¿ÑƒÐ»ÑŒÑÑ‹.",
      en: "Focused mode crushes impulse spikes.",
      es: "El modo enfoque aplasta los impulsos.",
      fr: "Le mode focus Ã©crase les pics d'impulsion.",
    },
    pushPendingTitle: {
      ru: "Ð’Ð¾Ð»ÐµÐ²Ð¾Ð¹ Ð¿Ð¸Ð½Ð³ ðŸ˜¼",
      en: "Focused ping ðŸ˜¼",
      es: "Ping de enfoque ðŸ˜¼",
      fr: "Ping focus ðŸ˜¼",
    },
    pushPendingBody: {
      ru: "Ð¢Ñ‹ Ð² Ð²Ð¾Ð»ÐµÐ²Ð¾Ð¼ Ñ€ÐµÐ¶Ð¸Ð¼Ðµ - Ñ€ÐµÑˆÐ¸, Ð¸Ð´ÐµÐ¼ Ð»Ð¸ Ð´Ð°Ð»ÑŒÑˆÐµ Ñ Â«{{title}}Â». ðŸ’ª",
      en: "Focused mode speaking-decide what to do with â€œ{{title}}â€. ðŸ’ª",
      es: "Modo enfoque al habla: decide quÃ© hacer con Â«{{title}}Â». ðŸ’ª",
      fr: "Le mode focus te parle : dÃ©cide quoi faire de Â« {{title}} Â». ðŸ’ª",
    },
    pushImpulseTitle: {
      ru: "Ð’Ð¾Ð»ÐµÐ²Ð¾Ð¹ ÑÐ¸Ð³Ð½Ð°Ð» ðŸ˜¼",
      en: "Focused alert ðŸ˜¼",
      es: "Alerta de enfoque ðŸ˜¼",
      fr: "Alerte focus ðŸ˜¼",
    },
    pushImpulseBody: {
      ru: "Ð¡ÐµÐ¹Ñ‡Ð°Ñ Ñ‡Ð°Ñ‰Ðµ Ñ…Ð¾Ñ‡ÐµÑ‚ÑÑ {{temptation}}, Ð½Ð¾ Ð²Ð¾Ð»ÐµÐ²Ð¾Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ Ð¼Ð¾Ð¶ÐµÑ‚ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ {{amount}} Ð² ÐºÐ¾Ð¿Ð¸Ð»ÐºÑƒ. ðŸ¦",
      en: "This hour begs for {{temptation}}, but focused mode can stash {{amount}}. ðŸ¦",
      es: "A esta hora pide {{temptation}}, pero el modo enfoque puede guardar {{amount}}. ðŸ¦",
      fr: "Ã€ cette heure {{temptation}} insiste, mais le mode focus peut mettre {{amount}} de cÃ´tÃ©. ðŸ¦",
    },
  },
  [MOOD_IDS.IMPULSIVE]: {
    label: { ru: "Ð˜Ð¼Ð¿ÑƒÐ»ÑŒÑÐ¸Ð²Ð½Ñ‹Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼", en: "Impulse mode", es: "Modo impulso", fr: "Mode impulsif" },
    hero: {
      ru: "Ð˜Ð¼Ð¿ÑƒÐ»ÑŒÑÐ¸Ð²Ð½Ñ‹Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ Ð²ÐºÐ»ÑŽÑ‡Ñ‘Ð½ - ÑÑ‚Ð¾Ð¸Ñ‚ Ð¿Ð¾Ð¹Ð¼Ð°Ñ‚ÑŒ Ð¿Ð°Ñ€Ñƒ Ð¿Ð¾Ð±ÐµÐ´.",
      en: "Impulse mode detected-time to capture a few wins.",
      es: "Modo impulso activado: toca atrapar un par de victorias.",
      fr: "Mode impulsif dÃ©tectÃ© : il est temps de dÃ©crocher quelques victoires.",
    },
    heroComplete: {
      ru: "Ð˜Ð¼Ð¿ÑƒÐ»ÑŒÑÑ‹ Ð±Ñ‹Ð»Ð¸ ÑÐ¸Ð»ÑŒÐ½Ñ‹Ð¼Ð¸, Ð½Ð¾ Ñ†ÐµÐ»ÑŒ Ð²ÑÑ‘ Ñ€Ð°Ð²Ð½Ð¾ Ð·Ð°ÐºÑ€Ñ‹Ñ‚Ð°.",
      en: "Impulses were strong, yet you still hit the target.",
      es: "El impulso fue fuerte, pero aun asÃ­ lograste la meta.",
      fr: "Les envies Ã©taient fortes, mais tu as quand mÃªme atteint la cible.",
    },
    motivation: {
      ru: "ÐœÐ°Ð»ÐµÐ½ÑŒÐºÐ¸Ð¹ Ð¾Ñ‚ÐºÐ°Ð· Ð¿Ñ€ÑÐ¼Ð¾ ÑÐµÐ¹Ñ‡Ð°Ñ Ð²ÐµÑ€Ð½Ñ‘Ñ‚ ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»ÑŒ.",
      en: "One tiny skip right now resets control.",
      es: "Un pequeÃ±o â€œnoâ€ ahora recupera el control.",
      fr: "Un petit Â« non Â» maintenant rend le contrÃ´le.",
    },
    saveOverlay: {
      ru: "Ð˜Ð¼Ð¿ÑƒÐ»ÑŒÑÑ‹ Ð¼ÐµÐ´Ð»ÑÑ‚ - Ñ‚Ñ‹ Ð¿ÐµÑ€ÐµÑ…Ð²Ð°Ñ‚Ð¸Ð» ÑƒÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ.",
      en: "Impulse paused-you took the controls back.",
      es: "El impulso se detuvo: retomaste el mando.",
      fr: "Impulsion stoppÃ©e : tu reprends les commandes.",
    },
    impulseOverlay: {
      ru: "ÐŸÐ¾Ð¹Ð¼Ð°Ð¹ ÐµÑ‰Ñ‘ Ð¾Ð´Ð¸Ð½ Ð¼Ð¾Ð¼ÐµÐ½Ñ‚ Ð¸ Ð¿ÐµÑ€ÐµÐ²ÐµÐ´Ð¸ ÐµÐ³Ð¾ Ð² ÐºÐ¾Ð¿Ð¸Ð»ÐºÑƒ.",
      en: "Catch the next urge and reroute it into savings.",
      es: "Atrapa el siguiente impulso y conviÃ©rtelo en ahorro.",
      fr: "Attrape la prochaine envie et transforme-la en Ã©pargne.",
    },
    pushPendingTitle: {
      ru: "Ð˜Ð¼Ð¿ÑƒÐ»ÑŒÑ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÑ‚ Â«{{title}}Â» ðŸ™€",
      en: "Impulse check-in ðŸ™€",
      es: "Aviso del impulso ðŸ™€",
      fr: "ContrÃ´le impulsif ðŸ™€",
    },
    pushPendingBody: {
      ru: "Ð˜Ð¼Ð¿ÑƒÐ»ÑŒÑÐ¸Ð²Ð½Ñ‹Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ Ð¿Ñ€Ð¾ÑÐ¸Ñ‚ ÑÑÐ½Ð¾ÑÑ‚Ð¸: Ð¾ÑÑ‚Ð°Ð²Ð»ÑÐµÐ¼ Â«{{title}}Â» Ð¸Ð»Ð¸ ÐºÐ¾Ð¿Ð¸Ð¼? ðŸ”¥",
      en: "Impulse mode needs clarity: keep â€œ{{title}}â€ or bank it? ðŸ”¥",
      es: "El modo impulso pide claridad: Â¿dejamos Â«{{title}}Â» o lo convertimos en ahorro? ðŸ”¥",
      fr: "Le mode impulsif demande une dÃ©cision : on garde Â« {{title}} Â» ou on le convertit en Ã©pargne ? ðŸ”¥",
    },
    pushImpulseTitle: {
      ru: "Ð˜Ð¼Ð¿ÑƒÐ»ÑŒÑ Ð½Ð° Ð¿Ð¾Ð´Ñ…Ð¾Ð´Ðµ ðŸ™€",
      en: "Impulse incoming ðŸ™€",
      es: "Impulso en camino ðŸ™€",
      fr: "Impulsion en approche ðŸ™€",
    },
    pushImpulseBody: {
      ru: "Ð§Ð°Ñ‰Ðµ Ð²ÑÐµÐ³Ð¾ ÑÐµÐ¹Ñ‡Ð°Ñ Ð±ÐµÑ€ÐµÑˆÑŒ {{temptation}}. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ {{amount}} Ð² ÐºÐ¾Ð¿Ð¸Ð»ÐºÑƒ. ðŸ§²",
      en: "{{temptation}} usually wins now. Try sending {{amount}} to savings instead. ðŸ§²",
      es: "Ahora suele ganar {{temptation}}. Intenta enviar {{amount}} al ahorro. ðŸ§²",
      fr: "{{temptation}} gagne souvent maintenant. Essaie d'envoyer {{amount}} vers l'Ã©pargne. ðŸ§²",
    },
  },
  [MOOD_IDS.DOUBTER]: {
    label: { ru: "Ð ÐµÐ¶Ð¸Ð¼ ÑÐ¾Ð¼Ð½ÐµÐ½Ð¸Ð¹", en: "Doubter mode", es: "Modo dudas", fr: "Mode doutes" },
    hero: {
      ru: "Ð ÐµÐ¶Ð¸Ð¼ ÑÐ¾Ð¼Ð½ÐµÐ½Ð¸Ð¹ Ð°ÐºÑ‚Ð¸Ð²ÐµÐ½ - Ð²Ñ‹Ð±ÐµÑ€Ð¸ Ñ…Ð¾Ñ‚Ñ Ð±Ñ‹ Ð¾Ð´Ð½Ð¾ ÑƒÐ²ÐµÑ€ÐµÐ½Ð½Ð¾Ðµ Ñ€ÐµÑˆÐµÐ½Ð¸Ðµ.",
      en: "Doubter mode is on-choose one confident move.",
      es: "Modo dudas activo: elige al menos un movimiento seguro.",
      fr: "Le mode doutes est activÃ© : choisis au moins un geste sÃ»r.",
    },
    heroComplete: {
      ru: "Ð¡Ð¾Ð¼Ð½ÐµÐ²Ð°ÐµÑˆÑŒÑÑ, Ð½Ð¾ Ñ†ÐµÐ»Ð¸ Ð´Ð¾ÑÑ‚Ð¸Ð³Ð°ÑŽÑ‚ÑÑ. Ð—Ð½Ð°Ñ‡Ð¸Ñ‚, ÐºÑƒÑ€Ñ Ð²ÐµÑ€Ð½Ñ‹Ð¹.",
      en: "Doubts aside, goals still get reached. The course works.",
      es: "Aun con dudas, las metas se cumplen. Vas en buen camino.",
      fr: "MÃªme avec des doutes, les objectifs avancent. Le cap est bon.",
    },
    motivation: {
      ru: "Ð’Ñ‹Ð±ÐµÑ€Ð¸ Ð¾Ð´Ð½Ñƒ Ð¼Ñ‹ÑÐ»ÑŒ Â«ÐºÐ¾Ð¿Ð¸Ñ‚ÑŒÂ» Ð¸ Ð·Ð°ÐºÑ€ÐµÐ¿Ð¸ ÑƒÐ²ÐµÑ€ÐµÐ½Ð½Ð¾ÑÑ‚ÑŒ.",
      en: "Pick one â€œsave itâ€ thought and lock it in.",
      es: "Elige un â€œahÃ³rraloâ€ y afianza la confianza.",
      fr: "Choisis un Â« j'Ã©conomise Â» et consolide ta confiance.",
    },
    saveOverlay: {
      ru: "Ð­Ñ‚Ð¾ Ñ€ÐµÑˆÐµÐ½Ð¸Ðµ ÑÐ½Ð¸Ð¼Ð°ÐµÑ‚ ÑÐ¾Ð¼Ð½ÐµÐ½Ð¸Ñ.",
      en: "That choice dissolves doubts.",
      es: "Esa decisiÃ³n disuelve las dudas.",
      fr: "Ce choix dissout les doutes.",
    },
    impulseOverlay: {
      ru: "Ð¡Ð¾Ð¼Ð½ÐµÐ½Ð¸Ñ Ð»ÑƒÑ‡ÑˆÐµ Ð¿ÐµÑ€ÐµÐ²Ð¾Ð´Ð¸Ñ‚ÑŒ Ð² Ñ†Ð¸Ñ„Ñ€Ñ‹, Ð° Ð½Ðµ Ð¿Ð¾ÐºÑƒÐ¿ÐºÐ¸.",
      en: "Turn doubts into numbers, not purchases.",
      es: "Convierte las dudas en nÃºmeros, no en compras.",
      fr: "Transforme les doutes en chiffres, pas en achats.",
    },
    pushPendingTitle: {
      ru: "Ð¡Ð¾Ð¼Ð½ÐµÐ½Ð¸Ñ Ð¿Ñ€Ð¾ÑÑÑ‚ Ð¾Ñ‚Ð²ÐµÑ‚Ð° ðŸ˜¿",
      en: "Doubter check ðŸ˜¿",
      es: "Chequeo de dudas ðŸ˜¿",
      fr: "ContrÃ´le des doutes ðŸ˜¿",
    },
    pushPendingBody: {
      ru: "Â«{{title}}Â» Ð²Ð¸ÑÐ¸Ñ‚ Ð² ÑÐ¾Ð¼Ð½ÐµÐ½Ð¸ÑÑ…. Ð ÐµÑˆÐ¸, ÐºÑƒÐ´Ð° ÐµÐ³Ð¾ Ð½Ð°Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ. ðŸ§©",
      en: "â€œ{{title}}â€ is stuck in limbo. Decide where it belongs. ðŸ§©",
      es: "â€œ{{title}}â€ sigue en duda. Decide adÃ³nde va. ðŸ§©",
      fr: "Â« {{title}} Â» plane encore. DÃ©cide oÃ¹ l'envoyer. ðŸ§©",
    },
    pushImpulseTitle: {
      ru: "Ð¡Ð¾Ð¼Ð½ÐµÐ²Ð°ÐµÑˆÑŒÑÑ? ðŸ˜¿",
      en: "Feeling unsure? ðŸ˜¿",
      es: "Â¿Con dudas? ðŸ˜¿",
      fr: "Un doute ? ðŸ˜¿",
    },
    pushImpulseBody: {
      ru: "ÐšÐ¾Ð³Ð´Ð° Ñ‚ÑÐ½ÐµÑ‚ Ðº {{temptation}}, Ð¿Ð¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹ Ð½Ð°Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ {{amount}} Ð² ÐºÐ¾Ð¿Ð¸Ð»ÐºÑƒ - ÑƒÐ²ÐµÑ€ÐµÐ½Ð½Ð¾ÑÑ‚ÑŒ Ð²ÐµÑ€Ð½Ñ‘Ñ‚ÑÑ. ðŸ§­",
      en: "When {{temptation}} calls, redirect {{amount}} to savings to regain certainty. ðŸ§­",
      es: "Cuando llame {{temptation}}, dirige {{amount}} al ahorro para recuperar seguridad. ðŸ§­",
      fr: "Quand {{temptation}} appelle, envoie {{amount}} vers l'Ã©pargne pour retrouver confiance. ðŸ§­",
    },
  },
  [MOOD_IDS.TIRED]: {
    label: { ru: "Ð ÐµÐ¶Ð¸Ð¼ Ð¾Ñ‚Ð´Ñ‹Ñ…Ð°", en: "Recharge mode", es: "Modo descanso", fr: "Mode recharge" },
    hero: {
      ru: "Ð”Ð°Ð²Ð½Ð¾ Ð½Ðµ Ð²Ð¸Ð´ÐµÐ»Ð¸ÑÑŒ - Ñ€ÐµÐ¶Ð¸Ð¼ Ð¾Ñ‚Ð´Ñ‹Ñ…Ð° Ð½Ð°Ð¿Ð¾Ð¼Ð¸Ð½Ð°ÐµÑ‚ Ð¾ Ð¼ÑÐ³ÐºÐ¾Ð¼ ÑÑ‚Ð°Ñ€Ñ‚Ðµ.",
      en: "Long time no see-recharge mode suggests a gentle restart.",
      es: "Tiempo sin verte: el modo descanso propone un reinicio suave.",
      fr: "Ã‡a faisait longtemps : le mode recharge propose un redÃ©marrage tout doux.",
    },
    heroComplete: {
      ru: "ÐŸÐ°ÑƒÐ·Ñ‹ Ñ‚Ð¾Ð¶Ðµ Ñ‡Ð°ÑÑ‚ÑŒ Ð¿ÑƒÑ‚Ð¸. Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°Ð¹ÑÑ, ÐºÐ¾Ð³Ð´Ð° Ð³Ð¾Ñ‚Ð¾Ð².",
      en: "Breaks are part of the path. Return when ready.",
      es: "Los descansos son parte del camino. Vuelve cuando estÃ©s listo.",
      fr: "Les pauses font partie du chemin. Reviens quand tu es prÃªtÂ·e.",
    },
    motivation: {
      ru: "ÐÐ°Ñ‡Ð½Ð¸ Ñ Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð¾Ñ‚ÐºÐ°Ð·Ð° ÑÐµÐ³Ð¾Ð´Ð½Ñ Ð¸ Ð¿Ð¾ÑÐ¼Ð¾Ñ‚Ñ€Ð¸, Ñ‡Ñ‚Ð¾ Ð¸Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑÑ.",
      en: "Start with one skip today and see the shift.",
      es: "Empieza con un rechazo hoy y nota el cambio.",
      fr: "Commence par un refus aujourd'hui et observe le dÃ©clic.",
    },
    saveOverlay: {
      ru: "Ð’Ð¾Ñ‚ Ð¸ Ð¼ÑÐ³ÐºÐ¸Ð¹ Ñ€ÐµÑÑ‚Ð°Ñ€Ñ‚. Ð¢Ð°Ðº Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ.",
      en: "Thereâ€™s the gentle restart. Nice.",
      es: "AsÃ­ se ve un reinicio suave. Bien hecho.",
      fr: "VoilÃ  un redÃ©marrage tout doux. Bravo.",
    },
    impulseOverlay: {
      ru: "ÐžÑ‚Ð´Ð¾Ñ…Ð½ÑƒÐ²ÑˆÐ°Ñ Ð²ÐµÑ€ÑÐ¸Ñ Ñ‚ÐµÐ±Ñ ÑƒÐ¼ÐµÐµÑ‚ Ð³Ð¾Ð²Ð¾Ñ€Ð¸Ñ‚ÑŒ Â«Ð¿Ð¾Ñ‚Ð¾Ð¼Â».",
      en: "Rested-you can say â€œlaterâ€ with ease.",
      es: "En modo descanso es mÃ¡s fÃ¡cil decir â€œluegoâ€.",
      fr: "ReposÃ©Â·e, tu peux dire \"plus tard\" sans effort.",
    },
    pushPendingTitle: {
      ru: "Ð’ÐµÑ€Ð½Ð¸ÑÑŒ Ðº Â«{{title}}Â» ðŸ˜½ðŸ’¤",
      en: "Come back to â€œ{{title}}â€ ðŸ˜½ðŸ’¤",
      es: "Vuelve a Â«{{title}}Â» ðŸ˜½ðŸ’¤",
      fr: "Reviens Ã  Â« {{title}} Â» ðŸ˜½ðŸ’¤",
    },
    pushPendingBody: {
      ru: "Ð ÐµÐ¶Ð¸Ð¼ Ð¾Ñ‚Ð´Ñ‹Ñ…Ð° Ð½Ðµ Ð²ÐµÑ‡Ð½Ñ‹Ð¹. Ð ÐµÑˆÐ¸, Ñ‡Ñ‚Ð¾ Ð´ÐµÐ»Ð°Ñ‚ÑŒ Ñ Â«{{title}}Â». ðŸ«¶",
      en: "Recharge mode isnâ€™t forever. Decide what to do with â€œ{{title}}â€. ðŸ«¶",
      es: "El modo descanso no es eterno. Decide quÃ© hacer con Â«{{title}}Â». ðŸ«¶",
      fr: "Le mode recharge n'est pas Ã©ternel. DÃ©cide quoi faire de Â« {{title}} Â». ðŸ«¶",
    },
    pushImpulseTitle: {
      ru: "ÐœÑÐ³ÐºÐ¸Ð¹ ÑÐ¸Ð³Ð½Ð°Ð» ðŸ˜½ðŸ’¤",
      en: "Gentle alert ðŸ˜½ðŸ’¤",
      es: "Alerta suave ðŸ˜½ðŸ’¤",
      fr: "Alerte douce ðŸ˜½ðŸ’¤",
    },
    pushImpulseBody: {
      ru: "ÐŸÐ°ÑƒÐ·Ñ‹ Ð±Ñ‹Ð»Ð¸ Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¼Ð¸, Ð½Ð¾ Ð´Ð°Ð¶Ðµ ÑÐµÐ¹Ñ‡Ð°Ñ Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ±ÐµÑ€ÐµÑ‡ÑŒ {{amount}} Ð¾Ñ‚ {{temptation}}. ðŸ’«",
      en: "Breaks ran long, yet this minute can still save {{amount}} from {{temptation}}. ðŸ’«",
      es: "El descanso fue largo, pero aÃºn puedes salvar {{amount}} de {{temptation}}. ðŸ’«",
      fr: "La pause a durÃ©, mais tu peux encore sauver {{amount}} de {{temptation}}. ðŸ’«",
    },
  },
  [MOOD_IDS.DREAMER]: {
    label: { ru: "ÐœÐµÑ‡Ñ‚Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼", en: "Dreamer mode", es: "Modo soÃ±ador", fr: "Mode rÃªveur" },
    hero: {
      ru: "ÐœÐµÑ‡Ñ‚Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ Ð°ÐºÑ‚Ð¸Ð²ÐµÐ½ - Ð² Â«Ð´ÑƒÐ¼Ð°ÐµÐ¼Â» ÑƒÐ¶Ðµ Ñ†ÐµÐ»Ð°Ñ Ð³Ð°Ð»ÐµÑ€ÐµÑ.",
      en: "Dreamer mode is on-your Thinking shelf is a gallery.",
      es: "Modo soÃ±ador activo: tu estante En pausa parece una galerÃ­a.",
      fr: "Le mode rÃªveur est activÃ© : ton onglet En pause ressemble Ã  une galerie.",
    },
    heroComplete: {
      ru: "Ð”Ð°Ð¶Ðµ Ð¼ÐµÑ‡Ñ‚Ð°Ñ‚ÐµÐ»Ð¸ Ð´Ð¾Ð²Ð¾Ð´ÑÑ‚ Ð¿Ð»Ð°Ð½Ñ‹ Ð´Ð¾ ÐºÐ¾Ð½Ñ†Ð°.",
      en: "Even dreamers finish their plans.",
      es: "Incluso los soÃ±adores concluyen sus planes.",
      fr: "MÃªme les rÃªveurs bouclent leurs plans.",
    },
    motivation: {
      ru: "Ð’Ñ‹Ð±ÐµÑ€Ð¸ Ð¾Ð´Ð½Ñƒ Ð¼ÐµÑ‡Ñ‚Ñƒ Ð¸ Ð½Ð°Ð¶Ð¼Ð¸ Â«ÐºÐ¾Ð¿Ð¸Ñ‚ÑŒÂ» ÑÐµÐ³Ð¾Ð´Ð½Ñ.",
      en: "Pick one dream and tap â€œsave itâ€ today.",
      es: "Elige un sueÃ±o y pulsa â€œahÃ³rraloâ€ hoy.",
      fr: "Choisis un rÃªve et appuie sur Â« j'Ã©conomise Â» aujourd'hui.",
    },
    saveOverlay: {
      ru: "ÐœÐµÑ‡Ñ‚Ð° Ð·Ð°Ñ„Ð¸ÐºÑÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð° Ñ€ÐµÐ°Ð»ÑŒÐ½Ñ‹Ð¼ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸ÐµÐ¼.",
      en: "Dream locked in with a real action.",
      es: "SueÃ±o asegurado con una acciÃ³n real.",
      fr: "RÃªve sÃ©curisÃ© par une vraie action.",
    },
    impulseOverlay: {
      ru: "ÐŸÑƒÑÑ‚ÑŒ Ð¼ÐµÑ‡Ñ‚Ñ‹ ÐºÐ¾Ð¿ÑÑ‚ÑÑ Ð² Ñ†Ð¸Ñ„Ñ€Ð°Ñ…, Ð° Ð½Ðµ Ñ€Ð°ÑÑ…Ð¾Ð´Ð°Ñ….",
      en: "Let dreams live in numbers, not expenses.",
      es: "Que los sueÃ±os vivan en cifras y no en gastos.",
      fr: "Que les rÃªves vivent en chiffres, pas en dÃ©penses.",
    },
    pushPendingTitle: {
      ru: "ÐœÐµÑ‡Ñ‚Ñ‹ Ð¶Ð´ÑƒÑ‚ ÑÑ‚Ð°Ñ€Ñ‚Ð° ðŸ˜»",
      en: "Dreams are waiting ðŸ˜»",
      es: "Los sueÃ±os esperan ðŸ˜»",
      fr: "Les rÃªves attendent ðŸ˜»",
    },
    pushPendingBody: {
      ru: "Ð’ Â«Ð´ÑƒÐ¼Ð°ÐµÐ¼Â» ÑƒÐ¶Ðµ Ð¾Ñ‡ÐµÑ€ÐµÐ´ÑŒ. Ð ÐµÑˆÐ¸, Ñ‡Ñ‚Ð¾ Ð´ÐµÐ»Ð°Ñ‚ÑŒ Ñ Â«{{title}}Â». ðŸŒˆ",
      en: "Thinking is crowded. Decide what to do with â€œ{{title}}â€. ðŸŒˆ",
      es: "Hay fila en En pausa. Decide quÃ© hacer con Â«{{title}}Â». ðŸŒˆ",
      fr: "L'onglet En pause est plein. DÃ©cide quoi faire de Â« {{title}} Â». ðŸŒˆ",
    },
    pushImpulseTitle: {
      ru: "ÐœÐµÑ‡Ñ‚Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ ÑÐ¸Ð³Ð½Ð°Ð» ðŸ˜»",
      en: "Dreamer alert ðŸ˜»",
      es: "Alerta soÃ±adora ðŸ˜»",
      fr: "Alerte rÃªveuse ðŸ˜»",
    },
    pushImpulseBody: {
      ru: "Ð›ÑƒÑ‡ÑˆÐµ Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ {{amount}} Ð² Ð¼ÐµÑ‡Ñ‚Ñƒ, Ñ‡ÐµÐ¼ ÑÐ½Ð¾Ð²Ð° Ð±Ñ€Ð°Ñ‚ÑŒ {{temptation}}. ðŸŒŸ",
      en: "Add {{amount}} to the dream instead of grabbing {{temptation}} again. ðŸŒŸ",
      es: "Mejor suma {{amount}} al sueÃ±o antes que volver a tomar {{temptation}}. ðŸŒŸ",
      fr: "Ajoute {{amount}} au rÃªve plutÃ´t que de reprendre {{temptation}}. ðŸŒŸ",
    },
  },
};

const lightenColor = (hex, amount = 0.25) => {
  if (typeof hex !== "string" || !hex.startsWith("#") || (hex.length !== 7 && hex.length !== 4)) {
    return hex;
  }
  const full = hex.length === 4 ? `#${hex[1]}${hex[1]}${hex[2]}${hex[2]}${hex[3]}${hex[3]}` : hex;
  const num = parseInt(full.slice(1), 16);
  if (Number.isNaN(num)) return hex;
  const adjust = (channel) => {
    const delta = 255 * amount;
    const next = channel + delta;
    return Math.max(0, Math.min(255, Math.round(next)));
  };
  const r = adjust((num >> 16) & 255);
  const g = adjust((num >> 8) & 255);
  const b = adjust(num & 255);
  return `rgb(${r}, ${g}, ${b})`;
};

const MOOD_GRADIENTS = {
  [MOOD_IDS.NEUTRAL]: {
    start: "#CDE6FF",
    end: "#F3F7FF",
    accent: "#A2C9FF",
  },
  [MOOD_IDS.FOCUSED]: {
    start: "#FFE8C7",
    end: "#FFD6E7",
    accent: "#FFB973",
  },
  [MOOD_IDS.IMPULSIVE]: {
    start: "#FFD1CC",
    end: "#FFF0DA",
    accent: "#FF8A7F",
  },
  [MOOD_IDS.DOUBTER]: {
    start: "#E3D8FF",
    end: "#F7E9FF",
    accent: "#C7B1FF",
  },
  [MOOD_IDS.TIRED]: {
    start: "#D5E0FF",
    end: "#ECEFF5",
    accent: "#9AB0FF",
  },
  [MOOD_IDS.DREAMER]: {
    start: "#CFF7F1",
    end: "#E9E2FF",
    accent: "#94D8C7",
  },
};

const getMoodGradient = (moodId = MOOD_IDS.NEUTRAL) =>
  MOOD_GRADIENTS[moodId] || MOOD_GRADIENTS[MOOD_IDS.NEUTRAL];

const applyThemeToMoodGradient = (palette, themeKey = "light") => {
  if (!palette) return getMoodGradient();
  if (themeKey !== "dark") return palette;
  return {
    start: lightenColor(palette.start, -0.55),
    end: lightenColor(palette.end, -0.65),
    accent: lightenColor(palette.accent, 0.35),
  };
};

const MoodGradientBlock = ({ colors: palette, style, children }) => {
  const gradientColors = palette || MOOD_GRADIENTS[MOOD_IDS.NEUTRAL];
  return (
    <View
      style={[
        styles.moodGradientBlock,
        { backgroundColor: gradientColors.start },
        style,
      ]}
    >
      <View
        pointerEvents="none"
        style={[
          styles.moodGradientOverlay,
          { backgroundColor: gradientColors.end },
        ]}
      />
      {children}
    </View>
  );
};

const CoinRainOverlay = React.memo(({ dropCount = 14 }) => {
  const drops = useRef(
    Array.from({ length: dropCount }).map((_, idx) => {
      const anim = new Animated.Value(Math.random());
      return {
        key: `coin_rain_${idx}`,
        anim,
        left: Math.random() * (SCREEN_WIDTH - 40),
        size: 20 + Math.random() * 14,
        duration: 4200 + Math.random() * 1800,
        delay: Math.random() * 1400,
      };
    })
  ).current;

  useEffect(() => {
    const loops = drops.map(({ anim, duration, delay }) => {
      const animation = Animated.loop(
        Animated.sequence([
          Animated.delay(delay),
          Animated.timing(anim, {
            toValue: 1,
            duration,
            easing: Easing.out(Easing.cubic),
            useNativeDriver: true,
          }),
          Animated.timing(anim, {
            toValue: 0,
            duration: 0,
            useNativeDriver: true,
          }),
        ])
      );
      animation.start();
      return animation;
    });
    return () => {
      loops.forEach((animation) => animation?.stop?.());
    };
  }, [drops]);

  return (
    <View pointerEvents="none" style={StyleSheet.absoluteFillObject}>
      {drops.map(({ key, anim, left, size }) => {
        const translateY = anim.interpolate({
          inputRange: [0, 1],
          outputRange: [-160, Dimensions.get("window").height + 120],
        });
        const translateX = anim.interpolate({
          inputRange: [0, 0.2, 0.5, 0.8, 1],
          outputRange: [left - 16, left + 12, left - 8, left + 6, left - 2],
        });
        const opacity = anim.interpolate({
          inputRange: [0, 0.15, 0.85, 1],
          outputRange: [0, 0.9, 0.8, 0],
        });
        const rotate = anim.interpolate({
          inputRange: [0, 1],
          outputRange: ["180deg", "540deg"],
        });
        return (
          <Animated.Image
            key={key}
            source={HEALTH_COIN_TIERS[0].asset}
            style={{
              position: "absolute",
              left: 0,
              width: size,
              height: size,
              opacity,
              transform: [
                { translateX },
                { translateY },
                { rotate },
              ],
            }}
            resizeMode="contain"
          />
        );
      })}
    </View>
  );
});

const PartyFirework = ({ color, size = 160, delay = 0, style }) => {
  const scale = useRef(new Animated.Value(0.2)).current;
  const opacity = useRef(new Animated.Value(0)).current;
  useEffect(() => {
    scale.setValue(0.2);
    opacity.setValue(0);
    const animation = Animated.loop(
      Animated.sequence([
        Animated.delay(delay),
        Animated.parallel([
          Animated.timing(scale, {
            toValue: 1,
            duration: 1100,
            easing: Easing.out(Easing.cubic),
            useNativeDriver: true,
          }),
          Animated.sequence([
            Animated.timing(opacity, {
              toValue: 0.85,
              duration: 220,
              useNativeDriver: true,
            }),
            Animated.timing(opacity, {
              toValue: 0,
              duration: 880,
              useNativeDriver: true,
            }),
          ]),
        ]),
        Animated.timing(scale, {
          toValue: 0.2,
          duration: 0,
          useNativeDriver: true,
        }),
      ])
    );
    animation.start();
    return () => animation.stop();
  }, [delay, opacity, scale]);
  return (
    <Animated.View
      pointerEvents="none"
      style={[
        styles.partyFireworkRing,
        style,
        {
          borderColor: color,
          width: size,
          height: size,
          borderRadius: size / 2,
          transform: [{ scale }],
          opacity,
        },
      ]}
    />
  );
};

const PartyFireworksLayer = ({ isDarkMode = false }) => {
  const palette = useMemo(
    () => (isDarkMode ? PARTY_FIREWORK_COLORS.dark : PARTY_FIREWORK_COLORS.light),
    [isDarkMode]
  );
  return (
    <View pointerEvents="none" style={styles.partyFireworksOverlay}>
      {PARTY_FIREWORK_CONFIGS.map((config, index) => (
        <PartyFirework
          key={`firework_${index}`}
          color={palette[index % palette.length]}
          size={config.size}
          delay={config.delay}
          style={{
            top: config.top,
            bottom: config.bottom,
            left: config.left,
            right: config.right,
          }}
        />
      ))}
    </View>
  );
};

const TAMAGOTCHI_IDLE_VARIANTS = ["idle", "idle", "curious", "follow", "speak"];
const TAMAGOTCHI_STARVING_VARIANTS = ["cry", "cry", "sad", "ohno", "idle"];
const TAMAGOTCHI_REACTION_DURATION = {
  happy: 3600,
  happyHeadshake: 3600,
  sad: 4200,
  ohno: 4000,
};
const TAMAGOTCHI_SPEECH_DURATION_MS = 7000;
const TAMAGOTCHI_SPEECH_COOLDOWN_MS = 9000;
const TAMAGOTCHI_SPEECH_ACTION_COOLDOWN_MS = 2500;
const TAMAGOTCHI_GREETING_SOON_MS = 1000 * 60 * 30;
const TAMAGOTCHI_GREETING_WARM_MS = 1000 * 60 * 60 * 6;
const TAMAGOTCHI_ACTION_SPEECH_REASONS = new Set([
  "save",
  "spend",
  "challenge_progress",
  "level_progress",
  "level_up",
  "focus_set",
  "feed",
]);
const TAMAGOTCHI_SPEECH_REASON_PRIORITY = {
  level_up: 5,
  spend: 4,
  save: 4,
  challenge_progress: 3,
  level_progress: 3,
  focus_set: 2,
  feed: 1,
};
const TAMAGOTCHI_DECAY_INTERVAL_MS = 1000 * 60 * 5;
const TAMAGOTCHI_DECAY_STEP = 2;
const TAMAGOTCHI_COIN_DECAY_TICKS = 6;
const TAMAGOTCHI_FEED_AMOUNT = ECONOMY_RULES.tamagotchiFeedBoost;
const TAMAGOTCHI_MAX_HUNGER = 100;
const TAMAGOTCHI_HUNGER_NOTIFICATION_DAILY_LIMIT = 3;
const TAMAGOTCHI_HUNGER_NOTIFICATION_WINDOW_MS = 1000 * 60 * 60 * 6;
const TAMAGOTCHI_FEED_COST = ECONOMY_RULES.tamagotchiFeedCost;
const TAMAGOTCHI_PARTY_COST = ECONOMY_RULES.tamagotchiPartyCost;
const PARTY_FIREWORK_CONFIGS = [
  { top: "12%", left: "18%", size: 150, delay: 0 },
  { top: "18%", right: "16%", size: 120, delay: 180 },
  { bottom: "26%", left: "20%", size: 170, delay: 360 },
  { bottom: "22%", right: "18%", size: 140, delay: 520 },
  { top: "30%", left: "40%", size: 110, delay: 420 },
];
const PARTY_FIREWORK_COLORS = {
  light: ["#FFB457", "#FF6FD8", "#7CDAFF", "#FFD36E"],
  dark: ["#FFD685", "#FF8FF3", "#7DC6FF", "#9BFFDA"],
};
const TAMAGOTCHI_PARTY_BLUE_COST = Math.max(
  1,
  Math.round(TAMAGOTCHI_PARTY_COST / HEALTH_COIN_TIERS[1].value)
);
const TAMAGOTCHI_FOOD_OPTIONS = [
  {
    id: "berries",
    tier: "snack",
    emoji: "ðŸ“",
    hungerBoost: Math.round(TAMAGOTCHI_FEED_AMOUNT * 0.55),
    cost: Math.max(1, Math.round(TAMAGOTCHI_FEED_COST)),
    label: { ru: "Ð¯Ð³Ð¾Ð´ÐºÐ¸", en: "Berries", es: "Frutos rojos", fr: "Baies" },
  },
  {
    id: "fish",
    tier: "treat",
    emoji: "ðŸŸ",
    hungerBoost: TAMAGOTCHI_FEED_AMOUNT,
    cost: Math.max(2, Math.round(TAMAGOTCHI_FEED_COST * 2)),
    label: { ru: "Ð Ñ‹Ð±ÐºÐ°", en: "Fish", es: "Pescado", fr: "Poisson" },
  },
  {
    id: "sushi",
    tier: "deluxe",
    emoji: "ðŸ£",
    hungerBoost: TAMAGOTCHI_FEED_AMOUNT + 12,
    cost: Math.max(4, Math.round(TAMAGOTCHI_FEED_COST * 4)),
    label: { ru: "Ð¡ÑƒÑˆÐ¸", en: "Sushi", es: "Sushi", fr: "Sushi" },
  },
  {
    id: "cake",
    tier: "deluxe",
    emoji: "ðŸ°",
    hungerBoost: TAMAGOTCHI_FEED_AMOUNT + 18,
    cost: Math.max(5, Math.round(TAMAGOTCHI_FEED_COST * 5)),
    label: { ru: "Ð”ÐµÑÐµÑ€Ñ‚", en: "Dessert", es: "Postre", fr: "Dessert" },
  },
];
const TAMAGOTCHI_FOOD_MAP = TAMAGOTCHI_FOOD_OPTIONS.reduce((acc, option) => {
  acc[option.id] = option;
  return acc;
}, {});
const TAMAGOTCHI_DEFAULT_FOOD_ID =
  TAMAGOTCHI_FOOD_OPTIONS[0]?.id || (TAMAGOTCHI_FOOD_OPTIONS[1]?.id ?? "berries");
const resolveTamagotchiFoodTier = (hunger = TAMAGOTCHI_MAX_HUNGER) => {
  const normalized = Math.max(0, Math.min(TAMAGOTCHI_MAX_HUNGER, hunger));
  if (normalized < 30) return "deluxe";
  if (normalized < 60) return "treat";
  return "snack";
};
const pickTamagotchiFoodByTier = (tier = "snack", excludeId = null) => {
  const pool = TAMAGOTCHI_FOOD_OPTIONS.filter((food) => food.tier === tier);
  const fallback = pool.length ? pool : TAMAGOTCHI_FOOD_OPTIONS;
  if (!fallback.length) return null;
  const candidates =
    excludeId && fallback.length > 1 ? fallback.filter((food) => food.id !== excludeId) : fallback;
  const list = candidates.length ? candidates : fallback;
  const randomIndex = Math.floor(Math.random() * list.length);
  return list[randomIndex]?.id || fallback[0].id;
};
const resolveNextTamagotchiFoodId = (
  hunger = TAMAGOTCHI_MAX_HUNGER,
  prevId = TAMAGOTCHI_DEFAULT_FOOD_ID,
  forceChange = false
) => {
  const nextTier = resolveTamagotchiFoodTier(hunger);
  const prevFood = TAMAGOTCHI_FOOD_MAP[prevId];
  const prevTier = prevFood?.tier || resolveTamagotchiFoodTier(TAMAGOTCHI_MAX_HUNGER);
  if (!forceChange && prevTier === nextTier && prevFood) {
    return prevId;
  }
  return pickTamagotchiFoodByTier(nextTier, forceChange ? prevId : null) || prevId;
};
const TAMAGOTCHI_HUNGER_LOW_THRESHOLD = Math.round(TAMAGOTCHI_MAX_HUNGER * 0.3);
const TAMAGOTCHI_START_STATE = {
  hunger: 80,
  coins: 5,
  lastFedAt: null,
  lastDecayAt: null,
  coinTick: 0,
  desiredFoodId: TAMAGOTCHI_DEFAULT_FOOD_ID,
};
const TAMAGOTCHI_NOTIFICATION_COPY = {
  ru: {
    low: "ÐÐ»Ð¼Ð¸ Ð¿Ñ€Ð¾Ð³Ð¾Ð»Ð¾Ð´Ð°Ð»ÑÑ - Ð·Ð°Ð³Ð»ÑÐ½Ð¸ Ð¸ Ð¿Ð¾ÐºÐ¾Ñ€Ð¼Ð¸ ÐµÐ³Ð¾. ðŸ˜ºðŸ¥£",
    starving: "ÐÐ»Ð¼Ð¸ ÑÐ¾Ð²ÑÐµÐ¼ Ð¾ÑÐ»Ð°Ð±. ÐžÑ‚ÐºÑ€Ð¾Ð¹ Almost Ð¸ Ð½Ð°ÐºÐ¾Ñ€Ð¼Ð¸ ÐµÐ³Ð¾ ÑÐºÐ¾Ñ€ÐµÐµ. ðŸ˜¿ðŸ«¶",
  },
  en: {
    low: "Almi is hungry - drop in and feed him. ðŸ˜ºðŸ¥£",
    starving: "Almi is starving. Open Almost and give him a snack. ðŸ˜¿ðŸ«¶",
  },
};

const computeTamagotchiDecay = (state = TAMAGOTCHI_START_STATE, timestamp = Date.now()) => {
  const source = state || {};
  const now = Number.isFinite(timestamp) ? timestamp : Date.now();
  const lastStored = source.lastDecayAt;
  let last =
    typeof lastStored === "number" && Number.isFinite(lastStored)
      ? lastStored
      : Number(lastStored) || now;
  if (last > now) {
    last = now;
  }
  const hunger = Math.min(TAMAGOTCHI_MAX_HUNGER, Math.max(0, Number(source.hunger) || 0));
  const coins = Math.max(0, Math.floor(Number(source.coins) || 0));
  const coinTick = Math.max(0, Number(source.coinTick) || 0);
  const elapsed = Math.max(0, now - last);
  const ticks = Math.floor(elapsed / TAMAGOTCHI_DECAY_INTERVAL_MS);
  if (ticks <= 0) {
    return {
      state: {
        ...source,
        hunger,
        coins,
        coinTick,
        lastDecayAt: last,
      },
      burnedCoins: 0,
    };
  }
  const hungerDrop = ticks * TAMAGOTCHI_DECAY_STEP;
  const nextHunger = Math.max(0, hunger - hungerDrop);
  const totalTicks = coinTick + ticks;
  const nextCoinTick = totalTicks % TAMAGOTCHI_COIN_DECAY_TICKS;
  const decayDuration = ticks * TAMAGOTCHI_DECAY_INTERVAL_MS;
  const hungerDelta = hunger - nextHunger;
  const tierChanged = resolveTamagotchiFoodTier(nextHunger) !== resolveTamagotchiFoodTier(hunger);
  const shouldRefreshCraving =
    !source?.desiredFoodId || tierChanged || hungerDelta >= TAMAGOTCHI_DECAY_STEP * 3;
  const desiredFoodId = shouldRefreshCraving
    ? resolveNextTamagotchiFoodId(nextHunger, source?.desiredFoodId, hungerDelta > 0)
    : source.desiredFoodId;
  return {
    state: {
      ...source,
      hunger: nextHunger,
      coins,
      lastDecayAt: last + decayDuration,
      coinTick: nextCoinTick,
      desiredFoodId: desiredFoodId || TAMAGOTCHI_DEFAULT_FOOD_ID,
    },
    burnedCoins: 0,
  };
};

const getTamagotchiMood = (hunger = 0, language = DEFAULT_LANGUAGE) => {
  const texts = {
    ru: {
      happy: "ÐÐ»Ð¼Ð¸ ÑÑ‹Ñ‚Ñ‹Ð¹ Ð¸ Ð´Ð¾Ð²Ð¾Ð»ÑŒÐ½Ñ‹Ð¹",
      calm: "ÐÐ»Ð¼Ð¸ Ñ‡ÑƒÑ‚ÑŒ Ð¿Ñ€Ð¾Ð³Ð¾Ð»Ð¾Ð´Ð°Ð»ÑÑ",
      sad: "ÐÐ»Ð¼Ð¸ Ð³Ñ€ÑƒÑÑ‚Ð¸Ñ‚, Ñ…Ð¾Ñ‡ÐµÑ‚ Ð¼Ð¾Ð½ÐµÑ‚ÐºÑƒ",
      urgent: "ÐÐ»Ð¼Ð¸ Ð¾Ñ‡ÐµÐ½ÑŒ Ð³Ð¾Ð»Ð¾Ð´Ð½Ñ‹Ð¹!",
    },
    en: {
      happy: "Almi is well-fed and happy",
      calm: "Almi is getting hungry",
      sad: "Almi is sad, needs a coin",
      urgent: "Almi is very hungry!",
    },
    es: {
      happy: "Almi estÃ¡ lleno y feliz",
      calm: "Almi empieza a tener hambre",
      sad: "Almi estÃ¡ triste, quiere una moneda",
      urgent: "Â¡Almi tiene mucha hambre!",
    },
    fr: {
      happy: "Almi est rassasiÃ© et heureux",
      calm: "Almi commence Ã  avoir faim",
      sad: "Almi est triste, il veut une piÃ¨ce",
      urgent: "Almi a trÃ¨s faim !",
    },
  };
  const dict = texts[language] || texts.ru;
  if (hunger >= 75) return { label: dict.happy, tone: "happy" };
  if (hunger >= 45) return { label: dict.calm, tone: "calm" };
  if (hunger >= 20) return { label: dict.sad, tone: "sad" };
  return { label: dict.urgent, tone: "urgent" };
};

function AlmiTamagotchi({
  override,
  onOverrideComplete,
  style,
  isStarving = false,
  animations = CLASSIC_TAMAGOTCHI_ANIMATIONS,
}) {
  const [currentKey, setCurrentKey] = useState("idle");
  const idleTimerRef = useRef(null);
  const overrideTimerRef = useRef(null);
  const idleVariants = useMemo(
    () => (isStarving ? TAMAGOTCHI_STARVING_VARIANTS : TAMAGOTCHI_IDLE_VARIANTS),
    [isStarving]
  );
  const resolveNextIdleKey = useCallback(() => {
    const pool = idleVariants.length ? idleVariants : TAMAGOTCHI_IDLE_VARIANTS;
    const index = Math.floor(Math.random() * pool.length);
    return pool[index] || "idle";
  }, [idleVariants]);

  const scheduleIdleCycle = useCallback(
    (delay = 4500) => {
      if (idleTimerRef.current) clearTimeout(idleTimerRef.current);
      idleTimerRef.current = setTimeout(() => {
        const next = resolveNextIdleKey();
        setCurrentKey(next);
        scheduleIdleCycle(5000 + Math.random() * 3000);
      }, delay);
    },
    [resolveNextIdleKey]
  );

  useEffect(() => {
    scheduleIdleCycle(2200);
    return () => {
      if (idleTimerRef.current) clearTimeout(idleTimerRef.current);
      if (overrideTimerRef.current) clearTimeout(overrideTimerRef.current);
    };
  }, [scheduleIdleCycle]);

  useEffect(() => {
    if (!override) return;
    if (idleTimerRef.current) clearTimeout(idleTimerRef.current);
    if (overrideTimerRef.current) clearTimeout(overrideTimerRef.current);
    const key = animations[override.type] ? override.type : "happy";
    setCurrentKey(key);
    overrideTimerRef.current = setTimeout(() => {
      onOverrideComplete?.();
      scheduleIdleCycle(2500);
    }, override.duration || 3200);
  }, [animations, override?.key, override?.type, override?.duration, onOverrideComplete, scheduleIdleCycle]);

  const source = animations[currentKey] || animations.idle;
  return (
    <View style={[styles.almiMascotWrap, style]}>
      <Image
        source={source}
        defaultSource={animations.idle}
        style={styles.almiMascotImage}
        resizeMode="contain"
        fadeDuration={0}
      />
    </View>
  );
}
const MAX_IMPULSE_EVENTS = 180;
const MIN_IMPULSE_EVENTS_FOR_MAP = 4;
const IMPULSE_SEQUENCE_WINDOW_MS = 12 * 60 * 60 * 1000;
const IMPULSE_SEQUENCE_MAX_FOLLOWUPS = 4;
const IMPULSE_SEQUENCE_MIN_HITS = 2;
const IMPULSE_SEQUENCE_MIN_WEIGHT = 2;
const IMPULSE_SEQUENCE_TOP_INSIGHTS = 2;
const IMPULSE_SEQUENCE_RECENCY_DAYS = 21;
const IMPULSE_ALERT_COOLDOWN_MS = 1000 * 60 * 45;
const IMPULSE_CATEGORY_DEFS = {
  food: { id: "food", ru: "Ð•Ð´Ð°", en: "Food", es: "Comida", fr: "Nourriture", emoji: "ðŸœ" },
  home: { id: "home", ru: "Ð”Ð¾Ð¼", en: "Home", es: "Hogar", fr: "Maison", emoji: "ðŸ " },
  transport: { id: "transport", ru: "Ð¢Ñ€Ð°Ð½ÑÐ¿Ð¾Ñ€Ñ‚", en: "Transport", es: "Transporte", fr: "Transport", emoji: "ðŸš‡" },
  health: { id: "health", ru: "Ð—Ð´Ð¾Ñ€Ð¾Ð²ÑŒÐµ", en: "Health", es: "Salud", fr: "SantÃ©", emoji: "ðŸ«§" },
  beauty: { id: "beauty", ru: "Ð‘ÑŒÑŽÑ‚Ð¸", en: "Beauty", es: "Belleza", fr: "BeautÃ©", emoji: "ðŸ’…" },
  fun: {
    id: "fun",
    ru: "Ð Ð°Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð¸Ñ",
    en: "Entertainment",
    es: "DiversiÃ³n",
    fr: "Divertissement",
    emoji: "ðŸŽ‰",
  },
  things: { id: "things", ru: "ÐŸÐ¾ÐºÑƒÐ¿ÐºÐ¸", en: "Shopping", es: "Compras", fr: "Achats", emoji: "ðŸ›ï¸" },
  clothing: { id: "clothing", ru: "ÐžÐ´ÐµÐ¶Ð´Ð°", en: "Clothing", es: "Ropa", fr: "VÃªtements", emoji: "ðŸ‘•" },
  education: { id: "education", ru: "ÐžÐ±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ", en: "Education", es: "EducaciÃ³n", fr: "Ã‰ducation", emoji: "ðŸŽ“" },
  pets: { id: "pets", ru: "ÐŸÐ¸Ñ‚Ð¾Ð¼Ñ†Ñ‹", en: "Pets", es: "Mascotas", fr: "Animaux", emoji: "ðŸ¾" },
  subscriptions: {
    id: "subscriptions",
    ru: "ÐŸÐ¾Ð´Ð¿Ð¸ÑÐºÐ¸",
    en: "Subscriptions",
    es: "Suscripciones",
    fr: "Abonnements",
    emoji: "ðŸ”",
  },
  vices: {
    id: "vices",
    ru: "Ð¡Ð»Ð°Ð±Ð¾ÑÑ‚Ð¸",
    en: "Small vices",
    es: "PequeÃ±os vicios",
    fr: "Petits vices",
    emoji: "âš¡ï¸",
  },
};
const IMPULSE_CATEGORY_ORDER = [
  "food",
  "home",
  "transport",
  "health",
  "beauty",
  "fun",
  "things",
  "clothing",
  "education",
  "pets",
  "subscriptions",
  "vices",
];
const DEFAULT_IMPULSE_CATEGORY = "vices";
const INITIAL_IMPULSE_TRACKER = {
  events: [],
  lastAlerts: {},
};

const padHour = (value) => value.toString().padStart(2, "0");
const formatImpulseWindowLabel = (hour, span = 2) => {
  if (!Number.isInteger(hour)) return null;
  const start = padHour(hour);
  const end = padHour((hour + span) % 24);
  return `${start}:00â€“${end}:00`;
};
const IMPULSE_DELAY_UNITS = {
  ru: { hour: "Ñ‡", minute: "Ð¼Ð¸Ð½" },
  en: { hour: "h", minute: "m" },
  es: { hour: "h", minute: "min" },
  fr: { hour: "h", minute: "min" },
};
const IMPULSE_REMINDER_MIN_DELAY_MS = 5 * 60 * 1000;
const formatImpulseDelayLabel = (minutes, language = DEFAULT_LANGUAGE) => {
  if (!Number.isFinite(minutes) || minutes <= 0) return null;
  const normalizedLanguage = normalizeLanguage(language);
  const units = IMPULSE_DELAY_UNITS[normalizedLanguage] || IMPULSE_DELAY_UNITS[DEFAULT_LANGUAGE];
  const totalMinutes = Math.max(1, Math.round(minutes));
  const hours = Math.floor(totalMinutes / 60);
  const mins = totalMinutes % 60;
  const parts = [];
  if (hours > 0) {
    parts.push(`${hours}${units.hour}`);
  }
  if (mins > 0) {
    parts.push(`${mins}${units.minute}`);
  }
  if (!parts.length) {
    parts.push(`1${units.minute}`);
  }
  return parts.join(" ");
};
const getImpulseReminderTimestamp = (timestamp) => {
  if (!Number.isFinite(timestamp)) return null;
  const base = new Date(timestamp);
  const reminder = new Date(base);
  reminder.setDate(base.getDate() + 1);
  const reminderHour = Math.max(0, base.getHours() - 1);
  reminder.setHours(reminderHour, base.getMinutes(), 0, 0);
  return reminder.getTime();
};

const resolveImpulseCategory = (item = {}) => {
  const override = typeof item?.impulseCategoryOverride === "string" ? item.impulseCategoryOverride : null;
  if (override && IMPULSE_CATEGORY_DEFS[override]) {
    return override;
  }
  const categories = Array.isArray(item.categories)
    ? item.categories.map((entry) => (entry || "").toLowerCase())
    : [];
  const price = Number(item.priceUSD ?? item.basePriceUSD ?? 0) || 0;
  const matches = (...keys) => categories.some((cat) => keys.includes(cat));
  if (matches("food", "groceries", "meal", "dining", "snack", "coffee", "tea")) return "food";
  if (matches("transport", "ride", "taxi", "uber", "bus", "metro", "train", "commute")) return "transport";
  if (matches("home", "rent", "utility", "utilities", "decor", "furniture", "appliance")) return "home";
  if (matches("health", "fitness", "gym", "doctor", "medicine", "wellness")) return "health";
  if (matches("beauty", "cosmetic", "cosmetics", "skincare", "makeup", "salon", "spa", "grooming")) return "beauty";
  if (matches("subscription", "subscriptions", "software", "streaming", "membership", "plan")) return "subscriptions";
  if (matches("travel", "wow", "game", "gaming", "fun", "experience", "movie", "concert", "event")) return "fun";
  if (matches("clothing", "apparel", "fashion", "style", "shoe", "shoes", "sneaker", "sneakers")) return "clothing";
  if (matches("tech", "phone", "wearable", "flagship", "gadget", "electronics")) return "things";
  if (matches("education", "course", "study", "learning", "school", "university", "tuition")) return "education";
  if (matches("pet", "pets", "animal", "vet", "veterinary")) return "pets";
  if (matches("lifestyle", "custom", "gift") && price <= 60) return "vices";
  if (price <= 18) return "vices";
  if (price <= 90) return "food";
  if (price <= 250) return "things";
  return "fun";
};

const normalizeImpulseCategoryId = (value) => {
  if (!value || typeof value !== "string") return DEFAULT_IMPULSE_CATEGORY;
  const normalized = value.trim().toLowerCase();
  if (!normalized) return DEFAULT_IMPULSE_CATEGORY;
  if (IMPULSE_CATEGORY_DEFS[normalized]) return normalized;
  if (["subscription", "subscriptions", "plan", "membership"].includes(normalized)) {
    return "subscriptions";
  }
  if (["entertainment", "fun", "experience", "movie", "gaming", "game", "event", "travel", "dream", "wow"].includes(normalized)) {
    return "fun";
  }
  if (["coffee", "food", "groceries", "meal", "dining", "snack", "tea"].includes(normalized)) {
    return "food";
  }
  if (["home", "rent", "utility", "utilities", "decor", "furniture", "appliance"].includes(normalized)) {
    return "home";
  }
  if (["transport", "ride", "taxi", "uber", "bus", "metro", "train", "commute", "car"].includes(normalized)) {
    return "transport";
  }
  if (["health", "fitness", "gym", "doctor", "medicine", "wellness"].includes(normalized)) {
    return "health";
  }
  if (["beauty", "cosmetic", "cosmetics", "skincare", "makeup", "salon", "spa", "grooming"].includes(normalized)) {
    return "beauty";
  }
  if (["clothing", "apparel", "fashion", "style", "shoe", "shoes", "sneaker", "sneakers"].includes(normalized)) {
    return "clothing";
  }
  if (["education", "course", "study", "learning", "school", "university", "tuition"].includes(normalized)) {
    return "education";
  }
  if (["pet", "pets", "animal", "vet", "veterinary"].includes(normalized)) {
    return "pets";
  }
  if (["tech", "phone", "wearable", "sport", "flagship", "gadget", "gift", "shopping", "things", "electronics"].includes(normalized)) {
    return "things";
  }
  if (["lifestyle", "custom", "vices", "vice"].includes(normalized)) {
    return "vices";
  }
  return DEFAULT_IMPULSE_CATEGORY;
};

const slugifyCategoryName = (value = "") =>
  value
    .toString()
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "_")
    .replace(/^_+|_+$/g, "");

const ensureUniqueCategoryId = (baseId) => {
  if (!baseId) return `custom_${Date.now()}`;
  if (!IMPULSE_CATEGORY_DEFS[baseId]) return baseId;
  let suffix = 2;
  let nextId = `${baseId}_${suffix}`;
  while (IMPULSE_CATEGORY_DEFS[nextId]) {
    suffix += 1;
    nextId = `${baseId}_${suffix}`;
  }
  return nextId;
};

const registerCustomCategory = (entry) => {
  if (!entry || typeof entry !== "object") return null;
  const baseId = slugifyCategoryName(entry.id || entry.en || entry.ru || entry.es || entry.fr || "");
  const id = ensureUniqueCategoryId(baseId);
  if (!id) return null;
  const normalized = {
    id,
    ru: entry.ru || entry.en || entry.es || entry.fr || "ÐšÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ",
    en: entry.en || entry.ru || entry.es || entry.fr || "Category",
    es: entry.es || entry.en || entry.ru || entry.fr || "Categoria",
    fr: entry.fr || entry.en || entry.ru || entry.es || "Categorie",
    emoji: entry.emoji || "âœ¨",
    custom: true,
  };
  IMPULSE_CATEGORY_DEFS[id] = normalized;
  if (!IMPULSE_CATEGORY_ORDER.includes(id)) {
    IMPULSE_CATEGORY_ORDER.push(id);
  }
  return normalized;
};

const resolveGoalTypeFromTarget = (targetUSD = 0) => {
  if (!Number.isFinite(targetUSD)) return "short_term";
  return targetUSD >= 1000 ? "long_term" : "short_term";
};

const isCustomTemptation = (item = null) => {
  if (!item) return false;
  const categories = Array.isArray(item.categories) ? item.categories : [];
  if (categories.includes("custom")) return true;
  if (typeof item.id === "string") {
    return item.id.startsWith("custom_") || item.id.startsWith("custom");
  }
  return false;
};

const buildImpulseInsights = (events = []) => {
  if (!Array.isArray(events) || !events.length) {
    const categories = IMPULSE_CATEGORY_ORDER.reduce((acc, id) => {
      acc[id] = { save: 0, spend: 0 };
      return acc;
    }, {});
    return {
      categories,
      hotLose: null,
      hotWin: null,
      activeRisk: null,
      hottestSpendCategory: null,
      eventCount: 0,
      sequenceInsights: [],
      sequenceHotspots: { slip: null, rebound: null },
    };
  }
  const categories = IMPULSE_CATEGORY_ORDER.reduce((acc, id) => {
    acc[id] = { save: 0, spend: 0 };
    return acc;
  }, {});
  const templateStats = new Map();
  let processedEvents = 0;
  let totalSaves = 0;
  let totalSpends = 0;
  const chronologicalEvents = [];
  events.forEach((event) => {
    if (!event || !event.templateId) return;
    if (Number.isFinite(event.timestamp)) {
      chronologicalEvents.push(event);
    }
    processedEvents += 1;
    const category = normalizeImpulseCategoryId(event.category);
    if (!categories[category]) {
      categories[category] = { save: 0, spend: 0 };
    }
    if (event.action === "save") {
      categories[category].save += 1;
      totalSaves += 1;
    } else if (event.action === "spend") {
      categories[category].spend += 1;
      totalSpends += 1;
    }
    const stat =
      templateStats.get(event.templateId) || {
        templateId: event.templateId,
        title: event.title,
        emoji: event.emoji,
        category,
        saveCount: 0,
        spendCount: 0,
        saveHours: Array(24).fill(0),
        spendHours: Array(24).fill(0),
        lastAmountUSD: event.amountUSD || 0,
      };
    if (event.action === "save") {
      stat.saveCount += 1;
      if (Number.isInteger(event.hour)) {
        stat.saveHours[event.hour] = (stat.saveHours[event.hour] || 0) + 1;
      }
    } else if (event.action === "spend") {
      stat.spendCount += 1;
      if (Number.isInteger(event.hour)) {
        stat.spendHours[event.hour] = (stat.spendHours[event.hour] || 0) + 1;
      }
      stat.lastAmountUSD = event.amountUSD || stat.lastAmountUSD;
    }
    templateStats.set(event.templateId, stat);
  });
  chronologicalEvents.sort((a, b) => {
    const tsA = Number(a.timestamp) || 0;
    const tsB = Number(b.timestamp) || 0;
    return tsA - tsB;
  });
  const sequenceStats = new Map();
  const sequenceEvents = chronologicalEvents.filter(
    (event) =>
      event &&
      event.templateId &&
      event.action &&
      Number.isFinite(event.timestamp)
  );
  const nowTimestamp = Date.now();
  const cleanSequenceTitle = (value) => {
    const stripped = stripEmojis(value || "");
    return stripped || value || "";
  };
  const addSequenceStat = (from, to, delayMs) => {
    if (!from || !to) return;
    const key = `${from.templateId}->${to.templateId}:${from.action}->${to.action}`;
    const weight =
      1 +
      Math.max(0, 1 - delayMs / IMPULSE_SEQUENCE_WINDOW_MS) * 0.4;
    const stat =
      sequenceStats.get(key) || {
        fromTemplateId: from.templateId,
        toTemplateId: to.templateId,
        fromTitle: cleanSequenceTitle(from.title),
        toTitle: cleanSequenceTitle(to.title),
        fromAction: from.action,
        toAction: to.action,
        count: 0,
        weightedCount: 0,
        lastTimestamp: 0,
        totalDelayMs: 0,
        toHours: Array(24).fill(0),
      };
    stat.count += 1;
    stat.weightedCount += weight;
    stat.totalDelayMs += delayMs;
    stat.lastTimestamp = Math.max(stat.lastTimestamp || 0, to.timestamp || 0);
    const hour =
      Number.isInteger(to.hour) ? to.hour : Number.isFinite(to.timestamp) ? new Date(to.timestamp).getHours() : null;
    if (Number.isInteger(hour)) {
      stat.toHours[hour] = (stat.toHours[hour] || 0) + 1;
    }
    sequenceStats.set(key, stat);
  };
  for (let i = 0; i < sequenceEvents.length; i += 1) {
    const from = sequenceEvents[i];
    let followups = 0;
    for (let j = i + 1; j < sequenceEvents.length; j += 1) {
      const to = sequenceEvents[j];
      const delay = (to.timestamp || 0) - (from.timestamp || 0);
      if (delay <= 0) continue;
      if (delay > IMPULSE_SEQUENCE_WINDOW_MS) break;
      if (!to.templateId || !to.action) continue;
      if (from.templateId === to.templateId) continue;
      addSequenceStat(from, to, delay);
      followups += 1;
      if (followups >= IMPULSE_SEQUENCE_MAX_FOLLOWUPS) break;
    }
  }
  const scoreSequence = (stat) => {
    if (!stat) return 0;
    const recencyDays = Number.isFinite(stat.lastTimestamp)
      ? (nowTimestamp - stat.lastTimestamp) / DAY_MS
      : Number.POSITIVE_INFINITY;
    const recencyBoost =
      Number.isFinite(recencyDays) && recencyDays >= 0
        ? Math.max(0, 1 - recencyDays / IMPULSE_SEQUENCE_RECENCY_DAYS) * 0.35
        : 0;
    return (stat.weightedCount || 0) + recencyBoost;
  };
  const sequenceCandidates = Array.from(sequenceStats.values()).filter((stat) => {
    if (!stat) return false;
    if ((stat.count || 0) < IMPULSE_SEQUENCE_MIN_HITS) return false;
    if ((stat.weightedCount || 0) < IMPULSE_SEQUENCE_MIN_WEIGHT) return false;
    return true;
  });
  const pickSequence = (predicate) => {
    let best = null;
    sequenceCandidates.forEach((stat) => {
      if (predicate && !predicate(stat)) return;
      const score = scoreSequence(stat);
      if (!best || score > best.score) {
        best = { ...stat, score };
        return;
      }
      if (score === best.score) {
        if ((stat.count || 0) > (best.count || 0)) {
          best = { ...stat, score };
          return;
        }
        if (
          (stat.count || 0) === (best.count || 0) &&
          (stat.lastTimestamp || 0) > (best.lastTimestamp || 0)
        ) {
          best = { ...stat, score };
        }
      }
    });
    return best;
  };
  const slipSequence = pickSequence(
    (stat) => stat.fromAction === "spend" && stat.toAction === "spend"
  );
  const reboundSequence = pickSequence(
    (stat) => stat.fromAction === "save" && stat.toAction === "save"
  );
  const makeSequencePayload = (stat) => {
    if (!stat) return null;
    return {
      fromTemplateId: stat.fromTemplateId,
      toTemplateId: stat.toTemplateId,
      fromTitle: stat.fromTitle,
      toTitle: stat.toTitle,
      fromAction: stat.fromAction,
      toAction: stat.toAction,
      count: stat.count,
      windowLabel: selectHotHour(stat.toHours || []).label || null,
    };
  };
  const selectHotHour = (hours = []) => {
    let chosen = null;
    let best = 0;
    hours.forEach((value, hour) => {
      if (value > best) {
        best = value;
        chosen = hour;
      }
    });
    return {
      hour: Number.isInteger(chosen) ? chosen : null,
      count: best,
      label: Number.isInteger(chosen) ? formatImpulseWindowLabel(chosen) : null,
    };
  };
  const sequenceInsights = sequenceCandidates
    .map((stat) => ({ ...stat, score: scoreSequence(stat) }))
    .sort((a, b) => {
      if (b.score !== a.score) return b.score - a.score;
      if ((b.count || 0) !== (a.count || 0)) return (b.count || 0) - (a.count || 0);
      return (b.lastTimestamp || 0) - (a.lastTimestamp || 0);
    })
    .slice(0, IMPULSE_SEQUENCE_TOP_INSIGHTS)
    .map((stat) => ({
      key: `${stat.fromTemplateId}-${stat.toTemplateId}-${stat.fromAction}-${stat.toAction}`,
      fromTitle: stat.fromTitle,
      toTitle: stat.toTitle,
      fromAction: stat.fromAction,
      toAction: stat.toAction,
      count: stat.count,
      windowLabel: selectHotHour(stat.toHours || []).label || null,
    }));
  let hotLose = null;
  let hotWin = null;
  templateStats.forEach((stat) => {
    const total = stat.saveCount + stat.spendCount;
    if (!total) return;
    const loseRate = stat.spendCount / total;
    if (stat.spendCount >= 1 && loseRate >= 0.5) {
      if (
        !hotLose ||
        total > hotLose.totalInteractions ||
        (total === hotLose.totalInteractions && stat.spendCount > hotLose.spendCount) ||
        (total === hotLose.totalInteractions &&
          stat.spendCount === hotLose.spendCount &&
          loseRate > hotLose.lossRate)
      ) {
        hotLose = {
          ...stat,
          totalInteractions: total,
          lossRate: loseRate,
          hotspot: selectHotHour(stat.spendHours),
        };
      }
    }
    const winRate = stat.saveCount / total;
    if (stat.saveCount >= 1 && winRate >= 0.5) {
      if (
        !hotWin ||
        total > hotWin.totalInteractions ||
        (total === hotWin.totalInteractions && stat.saveCount > hotWin.saveCount) ||
        (total === hotWin.totalInteractions &&
          stat.saveCount === hotWin.saveCount &&
          winRate > hotWin.winRate)
      ) {
        hotWin = {
          ...stat,
          totalInteractions: total,
          winRate,
          hotspot: selectHotHour(stat.saveHours),
        };
      }
    }
  });
  const nowHour = new Date().getHours();
  let activeRisk = null;
  templateStats.forEach((stat) => {
    const spendHits = stat.spendHours[nowHour] || 0;
    if (spendHits < 2) return;
    const saveHits = stat.saveHours[nowHour] || 0;
    if (saveHits >= spendHits) return;
    const total = stat.saveCount + stat.spendCount;
    if (!total) return;
    const lossRate = stat.spendCount / total;
    if (lossRate < 0.6) return;
    if (!activeRisk || spendHits > activeRisk.spendHits) {
      activeRisk = {
        templateId: stat.templateId,
        title: stat.title,
        emoji: stat.emoji,
        category: stat.category,
        spendHits,
        hour: nowHour,
        windowLabel: formatImpulseWindowLabel(nowHour),
        amountUSD: stat.lastAmountUSD,
      };
    }
  });
  const hottestSpendCategory = IMPULSE_CATEGORY_ORDER.reduce((best, id) => {
    const entry = categories[id] || { save: 0, spend: 0 };
    const spendCount = entry.spend || 0;
    const saveCount = entry.save || 0;
    const interactions = spendCount + saveCount;
    if (spendCount === 0) {
      return best;
    }
    if (
      !best ||
      spendCount > best.spendCount ||
      (spendCount === best.spendCount && interactions > (best.interactions || 0))
    ) {
      return { id, spendCount, interactions, saveCount };
    }
    return best;
  }, null);
  return {
    categories,
    hotLose: hotLose
      ? {
          templateId: hotLose.templateId,
          title: hotLose.title,
          emoji: hotLose.emoji,
          category: hotLose.category,
          count: hotLose.spendCount,
          rate: hotLose.lossRate,
          windowLabel: hotLose.hotspot?.label || null,
        }
      : null,
    hotWin: hotWin
      ? {
          templateId: hotWin.templateId,
          title: hotWin.title,
          emoji: hotWin.emoji,
          category: hotWin.category,
          count: hotWin.saveCount,
          rate: hotWin.winRate,
          windowLabel: hotWin.hotspot?.label || null,
        }
      : null,
    activeRisk,
    hottestSpendCategory,
    eventCount: processedEvents,
    totalSaveCount: totalSaves,
    totalSpendCount: totalSpends,
    sequenceInsights,
    sequenceHotspots: {
      slip: makeSequencePayload(slipSequence),
      rebound: makeSequencePayload(reboundSequence),
    },
  };
};

const renderTemplateString = (template, params = {}) => {
  if (!template || typeof template !== "string") return "";
  return template.replace(/\{\{(\w+)\}\}/g, (_, key) =>
    params[key] !== undefined && params[key] !== null ? String(params[key]) : ""
  );
};

const SwipeableChallengeCard = ({
  children,
  colors,
  cancelLabel,
  onCancel,
  onSwipeOpen,
  onSwipeClose,
}) => {
  const translateX = useRef(new Animated.Value(0)).current;
  const ACTION_WIDTH = CHALLENGE_SWIPE_ACTION_WIDTH;
  const gestureStartOffset = useRef(0);
  const closerRef = useRef(null);
  const isOpenRef = useRef(false);

  const closeRow = useCallback(
    (notify = true) => {
      isOpenRef.current = false;
      Animated.timing(translateX, {
        toValue: 0,
        duration: 150,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }).start(() => {
        if (notify) {
          onSwipeClose?.(closerRef.current);
          closerRef.current = null;
        }
      });
    },
    [onSwipeClose, translateX]
  );

  const openRow = useCallback(() => {
    isOpenRef.current = true;
    Animated.timing(translateX, {
      toValue: -ACTION_WIDTH,
      duration: 180,
      easing: Easing.out(Easing.quad),
      useNativeDriver: true,
    }).start(() => {
      const closer = () => closeRow();
      closerRef.current = closer;
      onSwipeOpen?.(closer);
    });
  }, [ACTION_WIDTH, closeRow, onSwipeOpen, translateX]);

  useEffect(() => {
    return () => {
      translateX.stopAnimation();
      translateX.setValue(0);
      if (closerRef.current) {
        onSwipeClose?.(closerRef.current);
        closerRef.current = null;
      }
    };
  }, [onSwipeClose, translateX]);

  const panResponder = useMemo(
    () =>
      PanResponder.create({
        onMoveShouldSetPanResponder: (_, gestureState) =>
          Math.abs(gestureState.dx) > Math.abs(gestureState.dy) && Math.abs(gestureState.dx) > 8,
        onMoveShouldSetPanResponderCapture: (_, gestureState) =>
          Math.abs(gestureState.dx) > Math.abs(gestureState.dy) && Math.abs(gestureState.dx) > 8,
        onPanResponderTerminationRequest: () => false,
        onPanResponderGrant: () => {
          translateX.stopAnimation((value) => {
            gestureStartOffset.current = value;
          });
        },
        onPanResponderMove: (_, gestureState) => {
          const base = gestureStartOffset.current || 0;
          const next = Math.max(-ACTION_WIDTH, Math.min(base + gestureState.dx, 0));
          translateX.setValue(next);
        },
        onPanResponderRelease: (_, gestureState) => {
          translateX.stopAnimation((value) => {
            const fastLeft = gestureState.vx < -0.5;
            const fastRight = gestureState.vx > 0.5;
            const shouldOpen = fastLeft || value < -ACTION_WIDTH * 0.45;
            const shouldClose = fastRight || value > -ACTION_WIDTH * 0.45;
            if (shouldOpen) {
              openRow();
              return;
            }
            if (shouldClose) {
              closeRow();
              return;
            }
            if (isOpenRef.current) {
              openRow();
            } else {
              closeRow();
            }
          });
        },
        onPanResponderTerminate: () => {
          closeRow();
        },
      }),
    [ACTION_WIDTH, closeRow, openRow, translateX]
  );

  return (
    <View style={styles.challengeSwipeWrapper}>
      <View style={[styles.challengeSwipeActions, { backgroundColor: SPEND_ACTION_COLOR }]}>
        <TouchableOpacity
          style={[styles.challengeSwipeButton, { backgroundColor: SPEND_ACTION_COLOR }]}
          onPress={() => {
            closeRow();
            onCancel?.();
          }}
          activeOpacity={0.85}
        >
          <Text style={[styles.challengeSwipeButtonText, { color: colors.background }]}>{cancelLabel}</Text>
        </TouchableOpacity>
      </View>
      <Animated.View style={{ transform: [{ translateX }] }} {...panResponder.panHandlers}>
        {children}
      </Animated.View>
    </View>
  );
};

const getMoodPreset = (moodId = MOOD_IDS.NEUTRAL, language = DEFAULT_LANGUAGE) => {
  const preset = MOOD_PRESETS[moodId] || MOOD_PRESETS[MOOD_IDS.NEUTRAL];
  const localize = (value) => {
    if (!value) return "";
    if (typeof value === "string") return value;
    return value[language] || value.en || "";
  };
  return {
    id: preset.id || moodId,
    label: localize(preset.label),
    hero: localize(preset.hero),
    heroComplete: localize(preset.heroComplete),
    motivation: localize(preset.motivation),
    saveOverlay: localize(preset.saveOverlay),
    impulseOverlay: localize(preset.impulseOverlay),
    pushPendingTitle: localize(preset.pushPendingTitle),
    pushPendingBody: localize(preset.pushPendingBody),
    pushImpulseTitle: localize(preset.pushImpulseTitle),
    pushImpulseBody: localize(preset.pushImpulseBody),
  };
};

const getLatestEventTimestamp = (events = [], type) => {
  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];
    if (event?.type === type && event.timestamp) {
      return event.timestamp;
    }
  }
  return null;
};

const evaluateMoodState = (state = createMoodStateForToday(), context = {}) => {
  const now = context.now || Date.now();
  const pendingCount =
    context.pendingCount !== undefined ? context.pendingCount : state.pendingSnapshot || 0;
  const filteredEvents = (state.events || []).filter(
    (event) => now - (event.timestamp || 0) <= MOOD_ACTION_WINDOW_MS
  );
  const counts = filteredEvents.reduce(
    (acc, event) => {
      if (event?.type && acc[event.type] !== undefined) {
        acc[event.type] += 1;
      }
      return acc;
    },
    { save: 0, spend: 0, maybe: 0, dream: 0 }
  );
  let nextMood = state.current || MOOD_IDS.NEUTRAL;
  const lastInteraction = state.lastInteractionAt || state.lastVisitAt || 0;
  if (lastInteraction && now - lastInteraction >= MOOD_INACTIVITY_THRESHOLD_MS) {
    nextMood = MOOD_IDS.TIRED;
  } else {
    const candidates = [];
    if (counts.spend >= MOOD_EVENT_THRESHOLD) {
      const timestamp = getLatestEventTimestamp(filteredEvents, "spend");
      if (timestamp) candidates.push({ mood: MOOD_IDS.IMPULSIVE, timestamp });
    }
    if (counts.save >= MOOD_EVENT_THRESHOLD) {
      const timestamp = getLatestEventTimestamp(filteredEvents, "save");
      if (timestamp) candidates.push({ mood: MOOD_IDS.FOCUSED, timestamp });
    }
    if (counts.maybe >= MOOD_EVENT_THRESHOLD) {
      const timestamp = getLatestEventTimestamp(filteredEvents, "maybe");
      if (timestamp) candidates.push({ mood: MOOD_IDS.DOUBTER, timestamp });
    }
    if (counts.dream >= MOOD_DREAM_WISH_THRESHOLD) {
      const timestamp = getLatestEventTimestamp(filteredEvents, "dream");
      if (timestamp) candidates.push({ mood: MOOD_IDS.DREAMER, timestamp });
    }
    if (pendingCount >= MOOD_PENDING_THRESHOLD) {
      candidates.push({ mood: MOOD_IDS.DREAMER, timestamp: now });
    }
    if (candidates.length) {
      candidates.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
      nextMood = candidates[0].mood;
    } else {
      nextMood = MOOD_IDS.NEUTRAL;
    }
  }
  return {
    ...state,
    current: nextMood,
    events: filteredEvents,
    pendingSnapshot: pendingCount,
  };
};

const mapHistoryEventsToMoodEvents = (history = [], now = Date.now()) =>
  history
    .filter((entry) => entry?.timestamp && now - entry.timestamp <= MOOD_ACTION_WINDOW_MS)
    .map((entry) => {
      if (entry.kind === "refuse_spend") return { type: "save", timestamp: entry.timestamp };
      if (entry.kind === "spend") return { type: "spend", timestamp: entry.timestamp };
      if (entry.kind === "pending_added") return { type: "maybe", timestamp: entry.timestamp };
      if (entry.kind === "wish_added") return { type: "dream", timestamp: entry.timestamp };
      return null;
    })
    .filter(Boolean)
    .slice(0, MOOD_MAX_EVENTS);

const WEEKDAY_LABELS = {
  ru: ["Ð’Ñ", "ÐŸÐ½", "Ð’Ñ‚", "Ð¡Ñ€", "Ð§Ñ‚", "ÐŸÑ‚", "Ð¡Ð±"],
  en: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  es: ["Dom", "Lun", "Mar", "MiÃ©", "Jue", "Vie", "SÃ¡b"],
  fr: ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"],
};
const WEEKDAY_LABELS_MONDAY_FIRST = {
  ru: ["ÐŸÐ½", "Ð’Ñ‚", "Ð¡Ñ€", "Ð§Ñ‚", "ÐŸÑ‚", "Ð¡Ð±", "Ð’Ñ"],
  en: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
  es: ["Lun", "Mar", "MiÃ©", "Jue", "Vie", "SÃ¡b", "Dom"],
  fr: ["Lun", "Mar", "Mer", "Jeu", "Ven", "Sam", "Dim"],
};
const PENDING_DAY_SUFFIX = { ru: "Ð´", en: "d", es: "d", fr: "j" };

const buildSavingsBreakdown = (
  history = [],
  currency = DEFAULT_PROFILE.currency,
  resolveTemplateTitle,
  language = DEFAULT_LANGUAGE
) => {
  const now = Date.now();
  const defaultDeclineTitle = resolveTranslationValueForLanguage(language, "defaultDeclineLabel") || "Skip";
  const otherLabel = resolveTranslationValueForLanguage(language, "savingsBreakdownOtherLabel") || "Other";
  const dayLabels = WEEKDAY_LABELS[language] || WEEKDAY_LABELS.en;
  const palette = ["#3E8EED", "#F6A23D", "#8F7CF6", "#2EB873", "#E15555", "#FFC857"];
  const totalsByTitle = {};
  const daysRaw = Array.from({ length: 7 }).map((_, idx) => {
    const dayStart = new Date(now - (6 - idx) * DAY_MS);
    dayStart.setHours(0, 0, 0, 0);
    const dayEnd = dayStart.getTime() + DAY_MS;
    const label = dayLabels[dayStart.getDay()];
    const stacks = {};
    history.forEach((entry) => {
      if (entry?.kind !== "refuse_spend") return;
      if (!entry?.timestamp || entry.timestamp < dayStart.getTime() || entry.timestamp >= dayEnd) return;
      const resolvedTitle =
        (resolveTemplateTitle &&
          resolveTemplateTitle(entry.meta?.templateId, entry.meta?.title || entry.title)) ||
        null;
      const baseTitle =
        (resolvedTitle ||
          entry.meta?.title ||
          entry.title ||
          entry.meta?.templateId ||
          entry.emoji ||
          entry.id ||
          defaultDeclineTitle)
          .toString()
          .slice(0, 42);
      const stripped = stripEmojis(baseTitle);
      const title = (stripped || baseTitle || defaultDeclineTitle).trim();
      const amount = Math.max(0, Number(entry.meta?.amountUSD) || 0);
      stacks[title] = (stacks[title] || 0) + amount;
      totalsByTitle[title] = (totalsByTitle[title] || 0) + amount;
    });
    const total = Object.values(stacks).reduce((sum, v) => sum + v, 0);
    return { label, stacks, total };
  });
  const sortedTitles = Object.entries(totalsByTitle)
    .sort((a, b) => b[1] - a[1])
    .map(([title]) => title);
  const topTitles = sortedTitles.slice(0, 5);
  const colorMap = {};
  topTitles.forEach((title, idx) => {
    colorMap[title] = palette[idx % palette.length];
  });
  const otherColor = "#F6C16B";
  const days = daysRaw.map((day) => {
    const stacksArray = [];
    const otherSum = Object.entries(day.stacks).reduce((acc, [title, value]) => {
      if (colorMap[title]) {
        stacksArray.push({ title, value, color: colorMap[title] });
        return acc;
      }
      return acc + value;
    }, 0);
    if (otherSum > 0) {
      stacksArray.push({ title: otherLabel, value: otherSum, color: otherColor });
    }
    return { label: day.label, total: day.total, stacks: stacksArray };
  });
  const grandTotal = Object.values(totalsByTitle).reduce((sum, v) => sum + v, 0) || 1;
  const legend = topTitles.map((title, idx) => ({
    id: title,
    label: title,
    value: totalsByTitle[title],
    percent: Math.round((totalsByTitle[title] / grandTotal) * 100),
    color: palette[idx % palette.length],
  }));
  const otherTotal = grandTotal - legend.reduce((sum, item) => sum + item.value, 0);
  if (otherTotal > 0) {
    legend.push({
      id: "other",
      label: otherLabel,
      value: otherTotal,
      percent: Math.max(1, Math.round((otherTotal / grandTotal) * 100)),
      color: otherColor,
    });
  }
  const formatLocal = (usd) => formatCurrency(convertToCurrency(usd || 0, currency), currency);
  return { days, legend, formatLocal };
};

const buildSpendingBreakdown = (
  history = [],
  currency = DEFAULT_PROFILE.currency,
  resolveTemplateTitle,
  language = DEFAULT_LANGUAGE,
  { range = "day", offset = 0 } = {}
) => {
  const resolveTemplate = (template, params = {}) => {
    if (!template) return "";
    return template.replace(/\{\{(\w+)\}\}/g, (match, key) =>
      Object.prototype.hasOwnProperty.call(params, key) ? params[key] : match
    );
  };
  const locale = getFormatLocale(language);
  const defaultSpendTitle = resolveTranslationValueForLanguage(language, "defaultSpendLabel") || "Spend";
  const otherLabel = resolveTranslationValueForLanguage(language, "savingsBreakdownOtherLabel") || "Other";
  const dayLabels = WEEKDAY_LABELS[language] || WEEKDAY_LABELS.en;
  const palette = ["#E15555", "#F6A23D", "#8F7CF6", "#3E8EED", "#2EB873", "#FFC857"];
  const spendEntries = Array.isArray(history)
    ? history.filter((entry) => entry?.kind === "spend" && entry?.timestamp)
    : [];
  const totalsByTitle = {};
  const buckets = [];
  const now = new Date();
  const startOfDay = (date) => {
    const next = new Date(date);
    next.setHours(0, 0, 0, 0);
    return next;
  };
  const getWeekStart = (date) => {
    const next = startOfDay(date);
    const weekday = (next.getDay() + 6) % 7;
    next.setDate(next.getDate() - weekday);
    return next;
  };
  const addMonths = (date, delta) => new Date(date.getFullYear(), date.getMonth() + delta, 1);
  const formatMonthLabel = (date) => {
    const raw = date.toLocaleDateString(locale, { month: "short" }).replace(".", "").trim();
    if (!raw) return "";
    return raw[0].toUpperCase() + raw.slice(1);
  };
  const formatWeekRangeLabel = (startDate, endDate) => {
    const startMonth = formatMonthLabel(startDate);
    const endMonth = formatMonthLabel(endDate);
    const startDay = startDate.getDate();
    const endDay = endDate.getDate();
    if (startMonth === endMonth) {
      return `${startMonth}${startDay}-${endDay}`;
    }
    return `${startMonth}${startDay}-${endMonth}${endDay}`;
  };
  const addBucket = (label, startMs, endMs, divisor = 1) => {
    const stacks = {};
    spendEntries.forEach((entry) => {
      const timestamp = Number(entry.timestamp) || 0;
      if (!timestamp || timestamp < startMs || timestamp >= endMs) return;
      const resolvedTitle =
        (resolveTemplateTitle &&
          resolveTemplateTitle(entry.meta?.templateId, entry.meta?.title || entry.title)) ||
        null;
      const baseTitle =
        (resolvedTitle ||
          entry.meta?.title ||
          entry.title ||
          entry.meta?.templateId ||
          entry.emoji ||
          entry.id ||
          defaultSpendTitle)
          .toString()
          .slice(0, 42);
      const stripped = stripEmojis(baseTitle);
      const title = (stripped || baseTitle || defaultSpendTitle).trim();
      const amount = Math.max(0, Number(entry.meta?.amountUSD) || 0) / divisor;
      stacks[title] = (stacks[title] || 0) + amount;
      totalsByTitle[title] = (totalsByTitle[title] || 0) + amount;
    });
    const total = Object.values(stacks).reduce((sum, v) => sum + v, 0);
    buckets.push({ label, stacks, total });
  };

  let rangeCount = 0;
  let isAverage = false;
  if (range === "week") {
    rangeCount = 4;
    isAverage = true;
    const baseEnd = new Date(getWeekStart(now).getTime() + DAY_MS * 7);
    const windowEnd = new Date(baseEnd.getTime() - offset * rangeCount * DAY_MS * 7);
    const windowStart = new Date(windowEnd.getTime() - rangeCount * DAY_MS * 7);
    Array.from({ length: rangeCount }).forEach((_, index) => {
      const weekStart = new Date(windowStart.getTime() + index * DAY_MS * 7);
      const weekEnd = new Date(weekStart.getTime() + DAY_MS * 7);
      const label = formatWeekRangeLabel(weekStart, new Date(weekEnd.getTime() - DAY_MS));
      addBucket(label, weekStart.getTime(), weekEnd.getTime(), 7);
    });
  } else if (range === "month") {
    rangeCount = 6;
    isAverage = true;
    const baseEnd = addMonths(addMonths(now, 0), 1);
    const windowEnd = addMonths(baseEnd, -offset * rangeCount);
    const windowStart = addMonths(windowEnd, -rangeCount);
    Array.from({ length: rangeCount }).forEach((_, index) => {
      const monthStart = addMonths(windowStart, index);
      const monthEnd = addMonths(monthStart, 1);
      const daysInMonth = Math.max(1, Math.round((monthEnd.getTime() - monthStart.getTime()) / DAY_MS));
      addBucket(formatMonthLabel(monthStart), monthStart.getTime(), monthEnd.getTime(), daysInMonth);
    });
  } else {
    rangeCount = 7;
    const baseEnd = new Date(startOfDay(now).getTime() + DAY_MS);
    const windowEnd = new Date(baseEnd.getTime() - offset * rangeCount * DAY_MS);
    const windowStart = new Date(windowEnd.getTime() - rangeCount * DAY_MS);
    Array.from({ length: rangeCount }).forEach((_, index) => {
      const dayStart = new Date(windowStart.getTime() + index * DAY_MS);
      const dayEnd = new Date(dayStart.getTime() + DAY_MS);
      const label = dayLabels[dayStart.getDay()] || "";
      addBucket(label, dayStart.getTime(), dayEnd.getTime(), 1);
    });
  }

  const sortedTitles = Object.entries(totalsByTitle)
    .sort((a, b) => b[1] - a[1])
    .map(([title]) => title);
  const topTitles = sortedTitles.slice(0, 5);
  const colorMap = {};
  topTitles.forEach((title, idx) => {
    colorMap[title] = palette[idx % palette.length];
  });
  const otherColor = "#F6C16B";
  const normalizedBuckets = buckets.map((bucket) => {
    const stacksArray = [];
    const otherSum = Object.entries(bucket.stacks).reduce((acc, [title, value]) => {
      if (colorMap[title]) {
        stacksArray.push({ title, value, color: colorMap[title] });
        return acc;
      }
      return acc + value;
    }, 0);
    if (otherSum > 0) {
      stacksArray.push({ title: otherLabel, value: otherSum, color: otherColor });
    }
    return { label: bucket.label, total: bucket.total, stacks: stacksArray };
  });
  const grandTotal = Object.values(totalsByTitle).reduce((sum, v) => sum + v, 0) || 1;
  const legend = topTitles.map((title, idx) => ({
    id: title,
    label: title,
    value: totalsByTitle[title],
    percent: Math.round((totalsByTitle[title] / grandTotal) * 100),
    color: palette[idx % palette.length],
  }));
  const otherTotal = grandTotal - legend.reduce((sum, item) => sum + item.value, 0);
  if (otherTotal > 0) {
    legend.push({
      id: "other",
      label: otherLabel,
      value: otherTotal,
      percent: Math.max(1, Math.round((otherTotal / grandTotal) * 100)),
      color: otherColor,
    });
  }
  const formatLocal = (usd) => formatCurrency(convertToCurrency(usd || 0, currency), currency);
  const rangeTitleKey =
    range === "week" ? "spendStatsRangeWeeks" : range === "month" ? "spendStatsRangeMonths" : "spendStatsRangeDays";
  const rangeTitleTemplate =
    resolveTranslationValueForLanguage(language, rangeTitleKey) || "Last {{count}}";
  const rangeTitle = resolveTemplate(rangeTitleTemplate, { count: rangeCount });
  const averageLabel =
    isAverage && (resolveTranslationValueForLanguage(language, "spendStatsAverageLabel") || "Daily average");
  return {
    buckets: normalizedBuckets,
    legend,
    formatLocal,
    rangeCount,
    rangeTitle,
    averageLabel: averageLabel || "",
  };
};

const computeRefuseStreak = (history = []) => {
  if (!Array.isArray(history)) return 0;
  const sorted = [...history]
    .filter((entry) => entry?.timestamp)
    .sort((a, b) => b.timestamp - a.timestamp);
  let streak = 0;
  for (const entry of sorted) {
    if (entry.kind === "refuse_spend") {
      streak += 1;
    } else {
      break;
    }
  }
  return streak;
};

const deriveMoodFromState = (state = createMoodStateForToday(), pendingCount = 0, now = Date.now()) => {
  const events = Array.isArray(state.events) ? state.events : [];
  const filtered = events.filter(
    (event) => event?.timestamp && now - event.timestamp <= MOOD_ACTION_WINDOW_MS
  );
  const counts = filtered.reduce(
    (acc, event) => {
      if (event?.type && acc[event.type] !== undefined) {
        acc[event.type] += 1;
      }
      return acc;
    },
    { save: 0, spend: 0, maybe: 0, dream: 0 }
  );
  const lastInteraction = state.lastInteractionAt || state.lastVisitAt || filtered[0]?.timestamp || 0;
  if (lastInteraction && now - lastInteraction >= MOOD_INACTIVITY_THRESHOLD_MS) {
    return MOOD_IDS.TIRED;
  }
  const candidates = [];
  if (counts.spend >= MOOD_EVENT_THRESHOLD) {
    const timestamp = getLatestEventTimestamp(filtered, "spend");
    if (timestamp) candidates.push({ mood: MOOD_IDS.IMPULSIVE, timestamp });
  }
  if (counts.save >= MOOD_EVENT_THRESHOLD) {
    const timestamp = getLatestEventTimestamp(filtered, "save");
    if (timestamp) candidates.push({ mood: MOOD_IDS.FOCUSED, timestamp });
  }
  if (counts.maybe >= MOOD_EVENT_THRESHOLD) {
    const timestamp = getLatestEventTimestamp(filtered, "maybe");
    if (timestamp) candidates.push({ mood: MOOD_IDS.DOUBTER, timestamp });
  }
  if (counts.dream >= MOOD_DREAM_WISH_THRESHOLD) {
    const timestamp = getLatestEventTimestamp(filtered, "dream");
    if (timestamp) candidates.push({ mood: MOOD_IDS.DREAMER, timestamp });
  }
  if (pendingCount >= MOOD_PENDING_THRESHOLD) {
    candidates.push({ mood: MOOD_IDS.DREAMER, timestamp: now });
  }
  if (candidates.length) {
    candidates.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
    return candidates[0].mood;
  }
  return MOOD_IDS.NEUTRAL;
};

const getImpulseCategoryLabel = (id, language = "en") => {
  const entry = IMPULSE_CATEGORY_DEFS[id];
  if (!entry) return id;
  const localeKey = getShortLanguageKey(language);
  return `${entry.emoji} ${entry[localeKey]}`;
};

const RainOverlay = ({ colors }) => {
  const drops = useMemo(
    () =>
      Array.from({ length: RAIN_DROPS }, (_, index) => ({
        id: index,
        left: Math.random() * SCREEN_WIDTH,
        delay: Math.random() * 800,
        height: 80 + Math.random() * 60,
      })),
    []
  );

  return (
    <View style={styles.rainLayer} pointerEvents="none">
      {drops.map((drop) => (
        <RainDrop key={drop.id} {...drop} colors={colors} />
      ))}
    </View>
  );
};

const RainDrop = ({ left, delay, height, colors }) => {
  const translateY = useRef(new Animated.Value(-120)).current;

  useEffect(() => {
    const loop = Animated.loop(
      Animated.sequence([
        Animated.delay(delay),
        Animated.timing(translateY, {
          toValue: 500,
          duration: 1400,
          useNativeDriver: true,
        }),
        Animated.timing(translateY, {
          toValue: -120,
          duration: 0,
          useNativeDriver: true,
        }),
      ])
    );
    loop.start();
    return () => loop.stop();
  }, [delay, translateY]);

  return (
    <Animated.View
      style={[
        styles.rainDrop,
        {
          left,
          height,
          backgroundColor: colors.muted,
          transform: [{ translateY }],
        },
      ]}
    />
  );
};

const AnimatedTouchableOpacity = Animated.createAnimatedComponent(TouchableOpacity);
const BASE_HORIZONTAL_PADDING = Platform.OS === "android" ? 20 : 30;

if (Platform.OS === "android" && UIManager.setLayoutAnimationEnabledExperimental) {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

const triggerHaptic = (style = Haptics.ImpactFeedbackStyle.Light) => {
  Haptics.impactAsync(style).catch(() => {});
};

const triggerSuccessHaptic = () => {
  Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success).catch(() => {});
};

const triggerSelectionHaptic = () => {
  Haptics.selectionAsync().catch(() => {});
};

const triggerCoinRewardHaptics = () => {
  const pulses = [0, 90, 180, 270];
  pulses.forEach((delay) => {
    setTimeout(() => {
      triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    }, delay);
  });
};

const convertToCurrency = (valueUSD = 0, currency = activeCurrency) => {
  if (!valueUSD) return 0;
  const rate = CURRENCY_RATES[currency] || 1;
  return valueUSD * rate;
};

const convertFromCurrency = (valueLocal = 0, currency = activeCurrency) => {
  if (!valueLocal) return 0;
  const rate = CURRENCY_RATES[currency] || 1;
  if (!rate) return valueLocal;
  return valueLocal / rate;
};

const STREAK_RECOVERY_COST_STEP_RUB = 500;
const computeStreakRecoveryCost = (amountUSD = 0) => {
  const rubValue = convertToCurrency(Math.max(amountUSD, 0), "RUB");
  if (!rubValue || rubValue <= 0) return 1;
  return Math.max(1, Math.ceil(rubValue / STREAK_RECOVERY_COST_STEP_RUB));
};

const INITIAL_STREAK_RECOVERY_PROMPT = {
  visible: false,
  item: null,
  templateId: null,
  coinCost: 0,
  options: null,
  recoverableStreak: 0,
  recoverableAmountUSD: 0,
  errorMessage: "",
};

const POTENTIAL_PUSH_STEP_EUR = 10;
const POTENTIAL_PUSH_STEP_USD = convertFromCurrency(POTENTIAL_PUSH_STEP_EUR, "EUR");
const POTENTIAL_PUSH_STEP_LOCAL_MAP = {
  AED: 10,
  AUD: 10,
  BYN: 10,
  CAD: 10,
  EUR: 10,
  GBP: 10,
  JPY: 1000,
  KZT: 3000,
  KRW: 15000,
  MXN: 100,
  PLN: 10,
  RUB: 1000,
  SAR: 10,
  USD: 10,
  DEFAULT: 10,
};
const POTENTIAL_PUSH_STEP_LOCAL_FALLBACK =
  POTENTIAL_PUSH_STEP_LOCAL_MAP.DEFAULT || POTENTIAL_PUSH_STEP_EUR;
const POTENTIAL_PUSH_MAX_MULTIPLIER = 5;
const POTENTIAL_PUSH_FAST_GAIN_WINDOW_MS = 2 * 60 * 60 * 1000;
const POTENTIAL_PUSH_COOLDOWN_WINDOW_MS = 36 * 60 * 60 * 1000;
const DEFAULT_POTENTIAL_PUSH_STATE = {
  lastStep: 0,
  lastStatus: null,
  baselineKey: null,
  stepMultiplier: 1,
  lastNotifiedAt: 0,
};

const getCurrencyPrecision = (currency = activeCurrency) => {
  if (
    currency === "AED" ||
    currency === "AUD" ||
    currency === "BYN" ||
    currency === "CAD" ||
    currency === "EUR" ||
    currency === "GBP" ||
    currency === "MXN" ||
    currency === "PLN" ||
    currency === "SAR" ||
    currency === "USD"
  )
    return 2;
  return 0;
};

const getCurrencyDisplayPrecision = (currency = activeCurrency) => {
  if (Object.prototype.hasOwnProperty.call(CURRENCY_DISPLAY_PRECISION, currency)) {
    return CURRENCY_DISPLAY_PRECISION[currency];
  }
  return getCurrencyPrecision(currency);
};

const getCurrencyFineStep = (currency = activeCurrency) => {
  if (CURRENCY_FINE_STEPS[currency]) return CURRENCY_FINE_STEPS[currency];
  const precision = getCurrencyPrecision(currency);
  return precision > 0 ? Math.pow(10, -precision) : 1;
};

const roundCurrencyValue = (value = 0, currency = activeCurrency, precisionOverride = null) => {
  const precision =
    typeof precisionOverride === "number" && Number.isFinite(precisionOverride)
      ? precisionOverride
      : getCurrencyPrecision(currency);
  const factor = Math.pow(10, precision);
  if (!Number.isFinite(factor) || factor <= 0) return Number(value) || 0;
  return Math.round(((Number(value) || 0) + Number.EPSILON) * factor) / factor;
};

const snapCurrencyValue = (value = 0, currency = activeCurrency) => {
  const step = CURRENCY_FINE_STEPS[currency];
  if (!step || step <= 0) {
    return roundCurrencyValue(value, currency);
  }
  const snapped = Math.round((Number(value) || 0) / step) * step;
  return roundCurrencyValue(snapped, currency);
};

const getFriendlyDisplayStep = (amount = 0) => {
  const value = Math.abs(amount);
  if (value === 0) return 1;
  if (value < 1) return 0.1;
  if (value < 5) return 0.25;
  if (value < 20) return 1;
  if (value < 50) return 2;
  if (value < 100) return 5;
  if (value < 250) return 10;
  if (value < 1000) return 25;
  if (value < 5000) return 50;
  if (value < 20000) return 100;
  if (value < 100000) return 250;
  return 500;
};

const applyFriendlyDisplayRounding = (value = 0, currency = activeCurrency) => {
  if (!Number.isFinite(value) || value === 0) return value || 0;
  const baseStep = getFriendlyDisplayStep(value);
  const fineStep = getCurrencyFineStep(currency) || 0;
  const step = Math.max(baseStep, fineStep || 0);
  if (!Number.isFinite(step) || step === 0) return value;
  return Math.round(value / step) * step;
};

const roundRemainingDisplayUSD = (value = 0, currency = activeCurrency) => {
  if (!Number.isFinite(value) || value <= 0) return 0;
  const localValue = convertToCurrency(value, currency);
  const baseStep = getFriendlyDisplayStep(localValue);
  const fineStep = getCurrencyFineStep(currency) || 0;
  const step = Math.max(baseStep, fineStep || 0);
  if (!Number.isFinite(step) || step <= 0) return value;
  const roundedLocal = Math.ceil(localValue / step) * step;
  return convertFromCurrency(roundedLocal, currency);
};

const formatSampleAmount = (valueUSD, currencyCode) =>
  formatCurrency(convertToCurrency(valueUSD, currencyCode), currencyCode);

const formatNumberInputValue = (value, precisionOverride = 2) => {
  if (!Number.isFinite(value)) return "";
  const precision =
    typeof precisionOverride === "number" && Number.isFinite(precisionOverride)
      ? Math.max(0, Math.min(6, precisionOverride))
      : 2;
  const formatted = value.toFixed(precision).replace(/\.?0+$/, "");
  return formatted;
};

const parseNumberInputValue = (value = "") => {
  if (typeof value !== "string") return NaN;
  const normalized = value.replace(/[^\d,.\s]/g, "").replace(",", ".");
  const parsed = parseFloat(normalized);
  return Number.isFinite(parsed) ? parsed : NaN;
};

const getManualInputPrecision = (value = "") => {
  if (typeof value !== "string") return 0;
  const normalized = value.replace(/[^\d,.\s]/g, "").replace(",", ".").trim();
  const [, fraction = ""] = normalized.split(".");
  if (!fraction) return 0;
  const digits = fraction.replace(/\D/g, "");
  return Math.max(0, Math.min(6, digits.length));
};

const formatLatestSavingTimestamp = (timestamp, language = DEFAULT_LANGUAGE) => {
  if (!timestamp) return null;
  try {
    const locale = getFormatLocale(language);
    const date = new Date(timestamp);
    const dateLabel = date.toLocaleDateString(locale, { day: "numeric", month: "short" });
    const timeLabel = date.toLocaleTimeString(locale, {
      hour: "2-digit",
      minute: "2-digit",
      hour12: false,
    });
    return `${dateLabel}, ${timeLabel}`;
  } catch {
    return null;
  }
};

const normalizeEmojiValue = (value, fallback) => {
  const trimmed = (value || "").trim();
  if (!trimmed) return fallback;
  const firstGrapheme = Array.from(trimmed)[0];
  return firstGrapheme || fallback;
};

const limitEmojiInput = (value) => {
  if (!value) return "";
  const trimmed = value.trim();
  const firstGrapheme = Array.from(trimmed)[0];
  return firstGrapheme || "";
};

const getPersonaPreset = (personaId) => PERSONA_PRESETS[personaId] || PERSONA_PRESETS[DEFAULT_PERSONA_ID];

const createPersonaTemptation = (preset) => {
  if (!preset?.habit) return null;
  const habit = preset.habit;
  return {
    id: `persona_${preset.id}`,
    emoji: habit.emoji || preset.emoji || "âœ¨",
    image: habit.image,
    color: habit.color || "#FFF5E6",
    categories: habit.categories || ["habit"],
    basePriceUSD: habit.basePriceUSD || 5,
    priceUSD: habit.basePriceUSD || 5,
    title: habit.title,
    description: habit.description,
    audience: preset.audience || habit.audience || null,
  };
};

const parseAmountValue = (value) => {
  if (value === null || value === undefined) return 0;
  if (typeof value === "number") return Number.isFinite(value) ? value : 0;
  if (typeof value === "string") {
    const parsed = Number(value.replace(",", "."));
    return Number.isFinite(parsed) ? parsed : 0;
  }
  return 0;
};

const resolveCustomPriceUSD = (customSpend, fallbackCurrency = DEFAULT_PROFILE.currency) => {
  const direct = parseAmountValue(customSpend?.amountUSD);
  if (direct > 0) return direct;
  const local = parseAmountValue(customSpend?.amount ?? customSpend?.amountLocal ?? customSpend?.price);
  if (local > 0) {
    const currencyCode = customSpend?.currency || fallbackCurrency || DEFAULT_PROFILE.currency;
    return convertFromCurrency(local, currencyCode);
  }
  return 0;
};

const buildCustomTemptationDescription = (gender = "none") => {
  const isFemale = gender === "female";
  const isMale = gender === "male";
  let ru = "Ð­Ñ‚Ð¾ Ð¸ÑÐºÑƒÑˆÐµÐ½Ð¸Ðµ Ñ‚Ñ‹ Ð´Ð¾Ð±Ð°Ð²Ð¸Ð»(Ð°) ÑÐ°Ð¼(Ð°). ÐžÑ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ð¹ ÐµÐ³Ð¾ Ð¸ Ð¿Ð¾Ð±ÐµÐ¶Ð´Ð°Ð¹ Ñ‡Ð°Ñ‰Ðµ.";
  if (isMale) {
    ru = "Ð­Ñ‚Ð¾ Ð¸ÑÐºÑƒÑˆÐµÐ½Ð¸Ðµ Ñ‚Ñ‹ Ð´Ð¾Ð±Ð°Ð²Ð¸Ð» ÑÐ°Ð¼. ÐžÑ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ð¹ ÐµÐ³Ð¾ Ð¸ Ð¿Ð¾Ð±ÐµÐ¶Ð´Ð°Ð¹ Ñ‡Ð°Ñ‰Ðµ.";
  } else if (isFemale) {
    ru = "Ð­Ñ‚Ð¾ Ð¸ÑÐºÑƒÑˆÐµÐ½Ð¸Ðµ Ñ‚Ñ‹ Ð´Ð¾Ð±Ð°Ð²Ð¸Ð»Ð° ÑÐ°Ð¼Ð°. ÐžÑ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ð¹ ÐµÐ³Ð¾ Ð¸ Ð¿Ð¾Ð±ÐµÐ¶Ð´Ð°Ð¹ Ñ‡Ð°Ñ‰Ðµ.";
  }
  const en = "You added this temptation yourself. Track it and beat it more often.";
  const esBase = "AÃ±adiste esta tentaciÃ³n tÃº misma. RegÃ­strala y supÃ©rala mÃ¡s seguido.";
  const es = isMale
    ? "AÃ±adiste esta tentaciÃ³n tÃº mismo. RegÃ­strala y supÃ©rala mÃ¡s seguido."
    : esBase;
  const fr = "Tu as ajoutÃ© cette tentation toi-mÃªme. Suis-la et bats-la plus souvent.";
  return {
    ru,
    en,
    es,
    fr,
  };
};

const CUSTOM_HABIT_FALLBACK_TITLES = {
  ru: "ÐœÐ¾Ñ Ð¿Ñ€Ð¸Ð²Ñ‹Ñ‡ÐºÐ°",
  en: "My impulse",
  es: "Mi impulso",
  fr: "Mon impulsion",
};

const createCustomHabitTemptation = (customSpend, fallbackCurrency = DEFAULT_PROFILE.currency, gender = "none") => {
  const price = resolveCustomPriceUSD(customSpend, fallbackCurrency) || CUSTOM_SPEND_SAMPLE_USD;
  const precision =
    typeof customSpend?.pricePrecision === "number" && Number.isFinite(customSpend.pricePrecision)
      ? Math.max(0, Math.min(6, customSpend.pricePrecision))
      : null;
  const resolvedTitle = customSpend?.title;
  const title =
    resolvedTitle && resolvedTitle.trim().length
      ? resolvedTitle.trim()
      : CUSTOM_HABIT_FALLBACK_TITLES.en;
  const description = buildCustomTemptationDescription(gender);
  const impulseCategory =
    customSpend?.impulseCategory && IMPULSE_CATEGORY_DEFS[customSpend.impulseCategory]
      ? customSpend.impulseCategory
      : null;
  const categories = ["habit", "custom"];
  if (impulseCategory) {
    categories.push(impulseCategory);
  }
  return {
    id: customSpend.id || "custom_habit",
    emoji: customSpend.emoji || "ðŸ’¡",
    color: "#FFF5E6",
    categories,
    basePriceUSD: price,
    priceUSD: price,
    pricePrecision: precision,
    title: {
      ru: resolvedTitle || CUSTOM_HABIT_FALLBACK_TITLES.ru,
      en: title || CUSTOM_HABIT_FALLBACK_TITLES.en,
      es: resolvedTitle || CUSTOM_HABIT_FALLBACK_TITLES.es,
      fr: resolvedTitle || CUSTOM_HABIT_FALLBACK_TITLES.fr,
    },
    description,
    impulseCategoryOverride: impulseCategory,
  };
};

const hasValidCustomPrice = (entry) => {
  if (!entry || typeof entry !== "object") return false;
  const price = Number(entry.priceUSD);
  if (Number.isFinite(price) && price > 0) return true;
  const basePrice = Number(entry.basePriceUSD);
  return Number.isFinite(basePrice) && basePrice > 0;
};

const normalizeCustomTemptationEntry = (
  entry,
  fallbackCurrency = DEFAULT_PROFILE.currency
) => {
  if (!entry || typeof entry !== "object") return null;
  const genderValue = entry?.gender || "none";
  if (hasValidCustomPrice(entry)) {
    const entryCategory =
      entry.impulseCategoryOverride || entry.impulseCategory || null;
    const normalizedCategory =
      entryCategory && IMPULSE_CATEGORY_DEFS[entryCategory] ? entryCategory : null;
    return {
      ...entry,
      description: buildCustomTemptationDescription(genderValue),
      impulseCategoryOverride: normalizedCategory,
      quickTemptation: true,
    };
  }
  const rebuilt = createCustomHabitTemptation(entry, fallbackCurrency, genderValue);
  if (!rebuilt) return null;
  const merged = { ...rebuilt, ...entry };
  merged.priceUSD = rebuilt.priceUSD;
  merged.basePriceUSD = rebuilt.basePriceUSD;
  merged.description = rebuilt.description;
  const entryCategory =
    entry.impulseCategoryOverride || entry.impulseCategory || rebuilt.impulseCategoryOverride;
  merged.impulseCategoryOverride =
    entryCategory && IMPULSE_CATEGORY_DEFS[entryCategory] ? entryCategory : rebuilt.impulseCategoryOverride || null;
  merged.quickTemptation = true;
  return merged;
};

const matchesGenderAudience = (card, gender = "none") => {
  if (!card || !card.audience || !gender || gender === "none") return true;
  const list = Array.isArray(card.audience) ? card.audience : [card.audience];
  return list.includes(gender);
};

const buildPersonalizedTemptations = (profile, baseList = DEFAULT_TEMPTATIONS) => {
  const preset = getPersonaPreset(profile?.persona);
  const personaExtras = PERSONA_TEMPTATION_PRESETS[preset?.id] || [];
  const customFirst = profile?.customSpend
    ? createCustomHabitTemptation(
        profile.customSpend,
        profile?.currency,
        profile?.gender
      )
    : null;
  const personaCard = createPersonaTemptation(preset);
  const priorityIds = ["coffee_to_go", "netflix_subscription"];
  const gender = profile?.gender || "none";
  const seen = new Set();
  const skippedIds = new Set();
  const result = [];
  const pushIfVisible = (card) => {
    if (!card || seen.has(card.id)) return;
    if (!matchesGenderAudience(card, gender)) return;
    seen.add(card.id);
    result.push(card);
  };

  // 1) ÐšÐ°ÑÑ‚Ð¾Ð¼Ð½Ð°Ñ ÐºÐ°Ñ€Ñ‚Ð° Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð²ÑÐµÐ³Ð´Ð° Ð¿ÐµÑ€Ð²Ð°Ñ, ÐµÑÐ»Ð¸ ÐµÑÑ‚ÑŒ.
  pushIfVisible(customFirst);
  // 2) ÐšÐ°Ñ€Ñ‚Ð° Ð¿ÐµÑ€ÑÐ¾Ð½Ñ‹ - ÑÑ€Ð°Ð·Ñƒ Ð¿Ð¾ÑÐ»Ðµ ÐºÐ°ÑÑ‚Ð¾Ð¼Ð½Ð¾Ð¹ Ð¸Ð»Ð¸ Ð¿ÐµÑ€Ð²Ð¾Ð¹, ÐµÑÐ»Ð¸ ÐºÐ°ÑÑ‚Ð¾Ð¼Ð½Ð¾Ð¹ Ð½ÐµÑ‚.
  const hasBaseCoffee = baseList.some((item) => item?.id === "coffee_to_go");
  const personaHasCoffee =
    preset?.id === "mindful_coffee" ||
    (personaCard && Array.isArray(personaCard.categories) && personaCard.categories.includes("coffee"));
  const shouldSkipPersona = !customFirst && hasBaseCoffee && personaHasCoffee;
  if (!shouldSkipPersona) {
    pushIfVisible(personaCard);
  }
  const sortedPersonaExtras = personaExtras
    .filter((card) => matchesGenderAudience(card, gender))
    .sort((a, b) => getTemptationPrice(a) - getTemptationPrice(b));
  sortedPersonaExtras.forEach((card) => pushIfVisible(card));
  // 3) Ð”ÐµÑ€Ð¶Ð¸Ð¼ ÐºÐ¾Ñ„Ðµ Ð½Ð°Ð²Ñ‹Ð½Ð¾Ñ Ð¸ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÑƒ Netflix ÑÑ€Ð°Ð·Ñƒ Ð¿Ð¾ÑÐ»Ðµ ÐºÐ°ÑÑ‚Ð¾Ð¼Ð½Ð¾Ð¹/Ð¿ÐµÑ€ÑÐ¾Ð½Ñ‹.
  const resolvedPriorityIds = [...priorityIds];
  if (!shouldSkipPersona && preset?.id === "mindful_coffee" && personaHasCoffee) {
    const altCoffee = baseList.find((item) => item?.id === "croissant_break")?.id || "croissant_break";
    resolvedPriorityIds.splice(0, 1, altCoffee);
    skippedIds.add("coffee_to_go");
  }
  resolvedPriorityIds.forEach((id) => {
    if (skippedIds.has(id)) return;
    const card = baseList.find((item) => item?.id === id);
    pushIfVisible(card);
  });

  // ÐžÑÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ðµ, Ð¾Ñ‚ÑÐ¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ Ð¿Ð¾ Ñ†ÐµÐ½Ðµ.
  const pool = [...baseList].filter((item) => item && !seen.has(item.id) && !skippedIds.has(item.id));
  const sortedPool = pool
    .filter((item) => matchesGenderAudience(item, gender))
    .sort((a, b) => {
      const priceA = a.priceUSD ?? a.basePriceUSD ?? Number.POSITIVE_INFINITY;
      const priceB = b.priceUSD ?? b.basePriceUSD ?? Number.POSITIVE_INFINITY;
      return priceA - priceB;
    });
  return [...result, ...sortedPool];
};

const mergeInteractionStatMaps = (base = {}, incoming = {}) => {
  const result = { ...(base || {}) };
  Object.entries(incoming || {}).forEach(([templateId, stats]) => {
    if (!stats) return;
    const current = result[templateId] || {};
    const merged = { ...current };
    merged.saveCount = (current.saveCount || 0) + (stats.saveCount || 0);
    merged.spendCount = (current.spendCount || 0) + (stats.spendCount || 0);
    merged.lastInteractionAt = Math.max(current.lastInteractionAt || 0, stats.lastInteractionAt || 0);
    const latestIsIncoming = (stats.lastInteractionAt || 0) >= (current.lastInteractionAt || 0);
    if (latestIsIncoming) {
      merged.previousInteractionAt = stats.previousInteractionAt || merged.previousInteractionAt || null;
      merged.secondPreviousInteractionAt =
        stats.secondPreviousInteractionAt ?? merged.secondPreviousInteractionAt ?? null;
      merged.detectedIntervalMs = stats.detectedIntervalMs ?? merged.detectedIntervalMs ?? null;
      merged.frequency = stats.frequency ?? merged.frequency ?? null;
      merged.intervalMs = stats.intervalMs ?? merged.intervalMs ?? null;
      merged.nextCheckAt = stats.nextCheckAt ?? merged.nextCheckAt ?? null;
      merged.lastTimerResetAt = stats.lastTimerResetAt ?? merged.lastTimerResetAt ?? null;
      merged.frequencyReminderId = stats.frequencyReminderId ?? merged.frequencyReminderId ?? null;
      merged.frequencyReminderIds = Array.isArray(stats.frequencyReminderIds)
        ? [...stats.frequencyReminderIds]
        : Array.isArray(merged.frequencyReminderIds)
        ? merged.frequencyReminderIds
        : [];
      merged.frequencyReminderScheduledAt =
        stats.frequencyReminderScheduledAt ?? merged.frequencyReminderScheduledAt ?? null;
      merged.frequencyReminderLocale =
        stats.frequencyReminderLocale ?? merged.frequencyReminderLocale ?? null;
      merged.frequencyReminderPlanKey =
        stats.frequencyReminderPlanKey ?? merged.frequencyReminderPlanKey ?? null;
      merged.templateTitle = stats.templateTitle ?? merged.templateTitle ?? null;
    } else {
      if (!merged.previousInteractionAt && stats.previousInteractionAt) {
        merged.previousInteractionAt = stats.previousInteractionAt;
      }
      if (!merged.secondPreviousInteractionAt && stats.secondPreviousInteractionAt) {
        merged.secondPreviousInteractionAt = stats.secondPreviousInteractionAt;
      }
    }
    merged.missedCycles = (current.missedCycles || 0) + (stats.missedCycles || 0);
    if (!merged.templateTitle && stats.templateTitle) {
      merged.templateTitle = stats.templateTitle;
    }
    if (!merged.frequencyReminderIds && Array.isArray(stats.frequencyReminderIds)) {
      merged.frequencyReminderIds = [...stats.frequencyReminderIds];
    }
    if (!merged.frequencyReminderPlanKey && stats.frequencyReminderPlanKey) {
      merged.frequencyReminderPlanKey = stats.frequencyReminderPlanKey;
    }
    result[templateId] = merged;
  });
  return result;
};

const useFadeIn = () => {
  const fade = useRef(new Animated.Value(0)).current;
  useEffect(() => {
    Animated.timing(fade, {
      toValue: 1,
      duration: 350,
      useNativeDriver: true,
    }).start();
  }, [fade]);
  return fade;
};

const FEED_FREQUENT_PIN_LIMIT = 5;
const DAILY_FREQUENCY_INTERVAL_MS = 26 * 60 * 60 * 1000;
const DAILY_SECOND_ACTION_THRESHOLD_MS = DAILY_FREQUENCY_INTERVAL_MS;
const DAILY_COOLDOWN_TO_WEEKLY_MS = 36 * 60 * 60 * 1000;
const WEEKLY_FREQUENCY_THRESHOLD_MS = DAY_MS * 7;
const BIWEEKLY_FREQUENCY_THRESHOLD_MS = DAY_MS * 14;
const MONTHLY_FREQUENCY_THRESHOLD_MS = DAY_MS * 14;
const TEMPTATION_FREQUENCY_BUCKETS = {
  daily: {
    id: "daily",
    intervalMs: DAILY_FREQUENCY_INTERVAL_MS,
    thresholdMs: DAILY_SECOND_ACTION_THRESHOLD_MS,
    sectionKey: "frequencySectionDaily",
    badgeKey: "frequencyBadgeDaily",
  },
  weekly: {
    id: "weekly",
    intervalMs: DAY_MS * 7,
    thresholdMs: WEEKLY_FREQUENCY_THRESHOLD_MS,
    sectionKey: "frequencySectionWeekly",
    badgeKey: "frequencyBadgeWeekly",
  },
  biweekly: {
    id: "biweekly",
    intervalMs: DAY_MS * 14,
    thresholdMs: MONTHLY_FREQUENCY_THRESHOLD_MS,
    sectionKey: "frequencySectionBiweekly",
    badgeKey: "frequencyBadgeBiweekly",
  },
  monthly: {
    id: "monthly",
    intervalMs: DAY_MS * 30,
    thresholdMs: Number.POSITIVE_INFINITY,
    sectionKey: "frequencySectionMonthly",
    badgeKey: "frequencyBadgeMonthly",
  },
};
const TEMPTATION_FREQUENCY_ORDER = ["daily", "weekly", "biweekly", "monthly"];
const FREQUENCY_DEMOTION_THRESHOLDS = {
  daily: DAILY_COOLDOWN_TO_WEEKLY_MS,
  weekly: BIWEEKLY_FREQUENCY_THRESHOLD_MS,
  biweekly: MONTHLY_FREQUENCY_THRESHOLD_MS,
};
const getDemotedFrequencyBucket = (bucketId, lastInteractionAt) => {
  if (!bucketId || !Number.isFinite(lastInteractionAt)) return bucketId;
  const threshold = FREQUENCY_DEMOTION_THRESHOLDS[bucketId];
  if (!threshold) return bucketId;
  if (Date.now() - lastInteractionAt < threshold) return bucketId;
  const index = TEMPTATION_FREQUENCY_ORDER.indexOf(bucketId);
  if (index < 0 || index >= TEMPTATION_FREQUENCY_ORDER.length - 1) return bucketId;
  return TEMPTATION_FREQUENCY_ORDER[index + 1];
};
const FREQUENCY_COUNTDOWN_TOKENS = {
  ru: { day: "Ð´", hour: "Ñ‡", minute: "Ð¼" },
  en: { day: "d", hour: "h", minute: "m" },
  es: { day: "d", hour: "h", minute: "m" },
  fr: { day: "j", hour: "h", minute: "m" },
};
const FREQUENCY_CRITICAL_WINDOW_MS = 2 * 60 * 60 * 1000;
const FREQUENCY_REMINDER_INTERVAL_MS = 30 * 60 * 1000;
const FREQUENCY_REMINDER_GRACE_MS = 30 * 60 * 1000;
const resolveTemptationFrequencyBucket = (intervalMs) => {
  if (!Number.isFinite(intervalMs) || intervalMs <= 0) return null;
  if (intervalMs <= DAILY_SECOND_ACTION_THRESHOLD_MS) return "daily";
  if (intervalMs <= WEEKLY_FREQUENCY_THRESHOLD_MS) return "weekly";
  if (intervalMs <= BIWEEKLY_FREQUENCY_THRESHOLD_MS) return "biweekly";
  return "monthly";
};
const getFrequencyIntervalMs = (bucketId) => {
  return TEMPTATION_FREQUENCY_BUCKETS[bucketId]?.intervalMs || null;
};
const formatFrequencyCountdown = (ms, language = DEFAULT_LANGUAGE) => {
  if (!Number.isFinite(ms) || ms <= 0) return "";
  const normalized = Math.max(0, Math.round(ms / (1000 * 60))); // minutes
  const tokens = FREQUENCY_COUNTDOWN_TOKENS[language] || FREQUENCY_COUNTDOWN_TOKENS[DEFAULT_LANGUAGE];
  const minutesInDay = 60 * 24;
  const days = Math.floor(normalized / minutesInDay);
  const hours = Math.floor((normalized % minutesInDay) / 60);
  const minutes = Math.max(0, normalized % 60);
  const parts = [];
  if (days > 0) {
    parts.push(`${days}${tokens.day}`);
  }
  if (hours > 0 && parts.length < 2) {
    parts.push(`${hours}${tokens.hour}`);
  }
  if (parts.length < 2 && minutes > 0) {
    parts.push(`${minutes}${tokens.minute}`);
  }
  if (!parts.length) {
    parts.push(`1${tokens.minute}`);
  }
  return parts.join(" ");
};

const buildFrequencyReminderSchedule = (nextCheckAt, now = Date.now()) => {
  if (!Number.isFinite(nextCheckAt)) return [];
  const windowStart = nextCheckAt - FREQUENCY_CRITICAL_WINDOW_MS;
  const windowEnd = nextCheckAt + FREQUENCY_REMINDER_GRACE_MS;
  if (!Number.isFinite(windowStart) || !Number.isFinite(windowEnd)) return [];
  if (now > windowEnd) return [];
  const triggers = [];
  for (
    let trigger = nextCheckAt - FREQUENCY_REMINDER_INTERVAL_MS;
    trigger <= windowEnd;
    trigger += FREQUENCY_REMINDER_INTERVAL_MS
  ) {
    if (trigger > now && trigger >= windowStart) {
      triggers.push(trigger);
    }
  }
  return triggers.sort((a, b) => a - b);
};

const normalizeInteractionKey = (value) => {
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  return trimmed.length ? trimmed : null;
};

const resolveEntryFrequency = (entry) => {
  if (!entry) return null;
  const lastInteractionAt = Number(entry.lastInteractionAt) || 0;
  const previousInteractionAt = Number(entry.previousInteractionAt) || 0;
  const secondPreviousInteractionAt = Number(entry.secondPreviousInteractionAt) || 0;
  if (
    lastInteractionAt &&
    previousInteractionAt &&
    lastInteractionAt - previousInteractionAt <= DAILY_SECOND_ACTION_THRESHOLD_MS
  ) {
    return "daily";
  }
  if (lastInteractionAt && previousInteractionAt) {
    const intervalMs = lastInteractionAt - previousInteractionAt;
    if (
      intervalMs > DAILY_SECOND_ACTION_THRESHOLD_MS &&
      intervalMs <= WEEKLY_FREQUENCY_THRESHOLD_MS
    ) {
      return "weekly";
    }
    if (
      intervalMs > WEEKLY_FREQUENCY_THRESHOLD_MS &&
      intervalMs <= BIWEEKLY_FREQUENCY_THRESHOLD_MS
    ) {
      return "biweekly";
    }
    if (intervalMs > BIWEEKLY_FREQUENCY_THRESHOLD_MS) {
      return "monthly";
    }
  }
  return null;
};

const buildHistoryInteractionMap = (entries = []) => {
  if (!Array.isArray(entries) || !entries.length) return {};
  const map = {};
  entries.forEach((entry) => {
    if (!entry || (entry.kind !== "refuse_spend" && entry.kind !== "spend")) return;
    const templateId =
      normalizeInteractionKey(entry?.meta?.templateId) ||
      normalizeInteractionKey(entry?.meta?.id) ||
      normalizeInteractionKey(entry?.meta?.template);
    if (!templateId) return;
    const timestamp = Number(entry.timestamp) || 0;
    if (!timestamp) return;
    const bucket = map[templateId] || {
      saveCount: 0,
      spendCount: 0,
      timestamps: [],
    };
    bucket.timestamps.push(timestamp);
    if (entry.kind === "refuse_spend") {
      bucket.saveCount += 1;
    } else if (entry.kind === "spend") {
      bucket.spendCount += 1;
    }
    map[templateId] = bucket;
  });
  Object.values(map).forEach((bucket) => {
    bucket.timestamps.sort((a, b) => b - a);
    bucket.lastInteractionAt = bucket.timestamps[0] || null;
    bucket.previousInteractionAt = bucket.timestamps[1] || null;
    bucket.secondPreviousInteractionAt = bucket.timestamps[2] || null;
    delete bucket.timestamps;
  });
  return map;
};

const LANGUAGE_OVERRIDES = {
  es: {
    languageLabel: "Idioma",
    languageTitle: "Elige idioma",
    languageSubtitle: "Configura el idioma y la moneda antes de empezar",
    languageRussian: "Ruso",
    languageEnglish: "InglÃ©s",
    languageSpanish: "EspaÃ±ol",
  },
  fr: {
    languageLabel: "Langue",
    languageTitle: "Choisir une langue",
    languageSubtitle: "Configure la langue et la devise avant de commencer",
    languageRussian: "Russe",
    languageEnglish: "Anglais",
    languageSpanish: "Espagnol",
    languageFrench: "FranÃ§ais",
  },
};
const resolveTranslationValueForLanguage = (language, key, gender = "none") => {
  const normalizedLanguage = normalizeLanguage(language);
  const override = LANGUAGE_OVERRIDES[normalizedLanguage]?.[key];
  const dictionary = TRANSLATIONS[normalizedLanguage] || {};
  let raw =
    override !== undefined
      ? override
      : dictionary[key] ??
        TRANSLATIONS[FALLBACK_LANGUAGE]?.[key] ??
        TRANSLATIONS[DEFAULT_LANGUAGE]?.[key];
  if (raw && typeof raw === "object" && !Array.isArray(raw)) {
    const genderValue = raw[gender];
    if (typeof genderValue === "string") {
      raw = genderValue;
    } else if (typeof raw.none === "string") {
      raw = raw.none;
    } else {
      const fallbackValue = Object.values(raw).find((value) => typeof value === "string");
      raw = fallbackValue !== undefined ? fallbackValue : undefined;
    }
  }
  return raw;
};

const resolveLanguageMapValue = (value, language) => {
  if (!value || typeof value !== "object" || Array.isArray(value)) return null;
  const normalizedLanguage = normalizeLanguage(language);
  const direct = value[normalizedLanguage];
  if (typeof direct === "string" && direct.length) {
    return direct;
  }
  const fallback = value[FALLBACK_LANGUAGE];
  if (typeof fallback === "string" && fallback.length) {
    return fallback;
  }
  const defaultValue = value[DEFAULT_LANGUAGE];
  if (typeof defaultValue === "string" && defaultValue.length) {
    return defaultValue;
  }
  const generic = Object.values(value).find((entry) => typeof entry === "string" && entry.length);
  return typeof generic === "string" ? generic : null;
};
const collectDailyNudgeVariants = (keys = []) => {
  const variants = new Set();
  DAILY_NUDGE_LANGUAGES.forEach((lng) => {
    const dict = TRANSLATIONS[lng] || TRANSLATIONS[FALLBACK_LANGUAGE] || {};
    keys.forEach((key) => {
      const raw = dict[key];
      if (Array.isArray(raw)) {
        raw.forEach((value) => {
          if (typeof value === "string") {
            const normalized = value.trim();
            if (normalized.length) {
              variants.add(normalized);
            }
          }
        });
      } else if (typeof raw === "string") {
        const normalized = raw.trim();
        if (normalized.length) {
          variants.add(normalized);
        }
      }
    });
  });
  return variants;
};
const DAILY_NUDGE_TITLE_VARIANTS = collectDailyNudgeVariants(DAILY_NUDGE_TITLE_KEYS);
const DAILY_NUDGE_BODY_VARIANTS = collectDailyNudgeVariants(DAILY_NUDGE_BODY_KEYS);
const matchesDailyNudgeText = (text, variants) => {
  if (typeof text !== "string") return false;
  const normalized = text.trim();
  return normalized.length > 0 && variants.has(normalized);
};
const isKnownDailyNudgeNotification = (content = {}) => {
  if (!content) return false;
  const data = content.data;
  if (data?.type === DAILY_NUDGE_NOTIFICATION_TAG || data?.tag === DAILY_NUDGE_NOTIFICATION_TAG) {
    return true;
  }
  return (
    matchesDailyNudgeText(content.title, DAILY_NUDGE_TITLE_VARIANTS) &&
    matchesDailyNudgeText(content.body, DAILY_NUDGE_BODY_VARIANTS)
  );
};

const CURRENCIES = ["USD", "AED", "AUD", "BYN", "CAD", "EUR", "GBP", "JPY", "KZT", "KRW", "MXN", "PLN", "RUB", "SAR"];

const CURRENCY_LOCALES = {
  AED: "en-AE",
  AUD: "en-AU",
  BYN: "be-BY",
  CAD: "en-CA",
  EUR: "de-DE",
  GBP: "en-GB",
  JPY: "ja-JP",
  KZT: "kk-KZ",
  KRW: "ko-KR",
  MXN: "es-MX",
  PLN: "pl-PL",
  RUB: "ru-RU",
  SAR: "en-US", // keep layout LTR; symbol handled manually
  USD: "en-US",
};

const HOW_IT_WORKS_STEPS = [
  { id: "track", emoji: "ðŸ“¸", titleKey: "guideStepTrackTitle", descKey: "guideStepTrackDesc" },
  { id: "decide", emoji: "ðŸŽ¯", titleKey: "guideStepDecisionTitle", descKey: "guideStepDecisionDesc" },
  { id: "reward", emoji: "ðŸ†", titleKey: "guideStepRewardTitle", descKey: "guideStepRewardDesc" },
];

const PERSONA_PRESETS = {
  mindful_coffee: {
    id: "mindful_coffee",
    emoji: "â˜•ï¸",
    title: {
      ru: "Ð›ÑŽÐ±Ð¸Ñ‚ÐµÐ»ÑŒ ÐºÐ¾Ñ„Ðµ",
      en: "Coffee devotee",
      es: "Fan del cafÃ©",
      fr: "Fan de cafÃ©",
    },
    description: {
      ru: "ÐŸÐµÑ€Ð²Ð°Ñ Ñ†ÐµÐ»ÑŒ: Ð·Ð°Ð¼ÐµÐ´Ð»Ð¸Ñ‚ÑŒ Ð¿Ð¾Ñ…Ð¾Ð´Ñ‹ Ð·Ð° ÐºÐ¾Ñ„Ðµ Ð½Ð°Ð²Ñ‹Ð½Ð¾Ñ.",
      en: "Goal one: slow down the take-away coffee habit.",
      es: "Primer paso: reducir los cafÃ©s para llevar.",
      fr: "Objectif nÂ°1 : freiner la manie du cafÃ© Ã  emporter.",
    },
    tagline: {
      ru: "ÐšÐ°Ð¶Ð´Ð°Ñ Ð½ÐµÐºÑƒÐ¿Ð»ÐµÐ½Ð½Ð°Ñ Ñ‡Ð°ÑˆÐºÐ° Ð´Ð°Ñ€Ð¸Ñ‚ +{{amount}} ÐºÐ¾Ð¿Ð¸Ð»ÐºÐµ.",
      en: "Every skipped cup adds +{{amount}} to the stash.",
      es: "Cada taza que saltas suma +{{amount}} al cofre.",
      fr: "Chaque tasse Ã©vitÃ©e ajoute +{{amount}} Ã  la cagnotte.",
    },
    habit: {
      emoji: "â˜•ï¸",
      color: "#FFF3E0",
      categories: ["habit", "food", "coffee"],
      basePriceUSD: 5,
      title: {
        ru: "ÐšÐ¾Ñ„Ðµ Ð½Ð°Ð²Ñ‹Ð½Ð¾Ñ",
        en: "Coffee run",
        es: "CafÃ© para llevar",
        fr: "Course cafÃ©",
      },
      description: {
        ru: "Ð¡Ð»Ð°Ð´ÐºÐ¸Ð¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ‚ ÑÐ»Ð°Ð±Ð¾ÑÑ‚Ð¸ ÐºÐ°Ð¶Ð´Ð¾Ðµ ÑƒÑ‚Ñ€Ð¾.",
        en: "Sweet little impulse every morning.",
        es: "Ese pequeÃ±o impulso dulce de cada maÃ±ana.",
        fr: "Petit Ã©cart sucrÃ© de chaque matin.",
      },
    },
  },
  habit_smoking: {
    id: "habit_smoking",
    emoji: "ðŸš¬",
    title: {
      ru: "ÐžÑ‚ÐºÐ°Ð· Ð¾Ñ‚ ÑÐ¸Ð³Ð°Ñ€ÐµÑ‚",
      en: "Quit smoking",
      es: "Dejar de fumar",
      fr: "ArrÃªter de fumer",
    },
    description: {
      ru: "ÐŸÐµÑ€Ð²Ð°Ñ ÑÑ‚ÑƒÐ¿ÐµÐ½ÑŒ: Ð¼ÐµÐ½ÑŒÑˆÐµ ÑÐ»ÑƒÑ‡Ð°Ð¹Ð½Ñ‹Ñ… ÑÐ¸Ð³Ð°Ñ€ÐµÑ‚ Ð¸ Ð¿ÐµÑ€ÐµÐºÑƒÑ€Ð¾Ð².",
      en: "First tier: fewer casual cigarettes and smoke breaks.",
      es: "Primer nivel: menos cigarrillos casuales y descansos de humo.",
      fr: "Premier palier : moins de cigarettes prises Â« au cas oÃ¹ Â» et de pauses clope.",
    },
    tagline: {
      ru: "ÐšÐ°Ð¶Ð´Ð°Ñ Ð¿Ñ€Ð¾Ð¿ÑƒÑ‰ÐµÐ½Ð½Ð°Ñ ÑÐ¸Ð³Ð°Ñ€ÐµÑ‚Ð° Ð´ÐµÑ€Ð¶Ð¸Ñ‚ Ð±ÑŽÐ´Ð¶ÐµÑ‚ Ð² Ñ‚Ð¾Ð½ÑƒÑÐµ.",
      en: "Every skipped cigarette keeps the budget sharp.",
      es: "Cada cigarro que saltas mantiene el presupuesto firme.",
      fr: "Chaque cigarette Ã©vitÃ©e garde ton budget affÃ»tÃ©.",
    },
    habit: {
      emoji: "ðŸš¬",
      color: "#FFE8E0",
      categories: ["habit", "vices"],
      basePriceUSD: 7,
      title: {
        ru: "ÐŸÐ°Ñ‡ÐºÐ° ÑÐ¸Ð³Ð°Ñ€ÐµÑ‚",
        en: "Pack of cigarettes",
        es: "Paquete de cigarrillos",
        fr: "Paquet de cigarettes",
      },
      description: {
        ru: "ÐŸÑ€Ð¾Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ Ð¿ÐµÑ€ÐµÐºÑƒÑ€ Ð·Ð½Ð°Ñ‡Ð¸Ñ‚ ÑƒÑÐºÐ¾Ñ€Ð¸Ñ‚ÑŒ Ð¿Ñ€Ð¾Ð³Ñ€ÐµÑÑ.",
        en: "Skip the smoke break, speed up the progress.",
        es: "Saltarte el cigarro acelera el progreso.",
        fr: "Sauter une pause clope accÃ©lÃ¨re le progrÃ¨s.",
      },
    },
  },
  glam_beauty: {
    id: "glam_beauty",
    emoji: "ðŸ’„",
    audience: ["female"],
    title: {
      ru: "Ð‘ÑŒÑŽÑ‚Ð¸-Ñ„Ð°Ð½Ð°Ñ‚",
      en: "Beauty fan",
      es: "FanÃ¡tica del beauty",
      fr: "Fan de beautÃ©",
    },
    description: {
      ru: "ÐšÐ¾Ð½Ñ‚Ñ€Ð¾Ð»Ð¸Ñ€ÑƒÐµÐ¼ ÑÐ¿Ð¾Ð½Ñ‚Ð°Ð½Ð½Ñ‹Ðµ Ð±ÑŒÑŽÑ‚Ð¸-Ð¿Ð¾ÐºÑƒÐ¿ÐºÐ¸ Ð¸ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ¸.",
      en: "Keep beauty splurges and subs in check.",
      es: "Domina las compras y suscripciones de belleza.",
      fr: "On garde les achats et abonnements beautÃ© sous contrÃ´le.",
    },
    tagline: {
      ru: "ÐžÐ´Ð¸Ð½ Ð¿Ñ€Ð¾Ð¿ÑƒÑ‰ÐµÐ½Ð½Ñ‹Ð¹ Ð±ÑŒÑŽÑ‚Ð¸-Ð´Ñ€Ð¾Ð¿ = {{amount}} Ð´Ð»Ñ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ð¹ Ñ†ÐµÐ»Ð¸.",
      en: "One skipped beauty drop = {{amount}} toward the big goal.",
      es: "Cada beauty drop que saltas suma {{amount}} a la meta mayor.",
      fr: "Chaque drop beautÃ© Ã©vitÃ© = {{amount}} en plus pour ton grand objectif.",
    },
    habit: {
      emoji: "ðŸ’„",
      color: "#FFE5F1",
      categories: ["habit", "beauty"],
      basePriceUSD: 18,
      title: {
        ru: "ÐœÐ¸Ð½Ð¸ Ð±ÑŒÑŽÑ‚Ð¸-Ð´Ñ€Ð¾Ð¿",
        en: "Mini beauty haul",
        es: "Mini compra beauty",
        fr: "Mini craquage beautÃ©",
      },
      description: {
        ru: "Ð¢ÐµÐ½Ð¸, Ð¿Ð¾Ð¼Ð°Ð´Ð° Ð¸ ÐµÑ‰Ñ‘ Ð¾Ð´Ð¸Ð½ Â«Ð½ÑƒÐ¶Ð½Ñ‹Ð¹Â» ÑƒÑ…Ð¾Ð´.",
        en: "Shadow, lipstick and yet another â€œneededâ€ serum.",
        es: "Sombras, labial y otro serum â€œimprescindibleâ€.",
        fr: "Fard, rouge et un Ã©niÃ¨me sÃ©rum soi-disant indispensable.",
      },
    },
  },
  gamer_loot: {
    id: "gamer_loot",
    emoji: "ðŸŽ®",
    audience: ["male"],
    title: {
      ru: "Ð“ÐµÐ¹Ð¼ÐµÑ€",
      en: "Gamer",
      es: "Gamer",
      fr: "Gamer",
    },
    description: {
      ru: "Ð—Ð°Ð¼ÐµÐ´Ð»ÑÐµÐ¼ Ð´Ð¾Ð½Ð°Ñ‚Ñ‹, Ð»ÑƒÑ‚Ð±Ð¾ÐºÑÑ‹ Ð¸ Ð½Ð¾Ñ‡Ð½Ñ‹Ðµ DLC.",
      en: "Cool down loot boxes, microtransactions and DLC binges.",
      es: "Baja el ritmo de loot boxes, DLC y microtransacciones.",
      fr: "On calme les loot boxes, microtransactions et DLC nocturnes.",
    },
    tagline: {
      ru: "ÐšÐ°Ð¶Ð´Ñ‹Ð¹ Ð¿Ñ€Ð¾Ð¿ÑƒÑ‰ÐµÐ½Ð½Ñ‹Ð¹ Ð´Ð¾Ð½Ð°Ñ‚ = {{amount}} Ð½Ð° Ð¼ÐµÑ‡Ñ‚Ñƒ IRL.",
      en: "Every skipped microtransaction frees {{amount}} for IRL goals.",
      es: "Cada donaciÃ³n que evitas libera {{amount}} para metas reales.",
      fr: "Chaque microtransaction Ã©vitÃ©e libÃ¨re {{amount}} pour tes buts IRL.",
    },
    habit: {
      emoji: "ðŸŽ®",
      color: "#D9F7FF",
      categories: ["habit", "fun"],
      basePriceUSD: 10,
      title: {
        ru: "Ð˜Ð³Ñ€Ð¾Ð²Ð¾Ð¹ Ð´Ð¾Ð½Ð°Ñ‚",
        en: "Game microtransaction",
        es: "MicrotransacciÃ³n",
        fr: "Microtransaction",
      },
      description: {
        ru: "ÐŸÐ°Ñ€Ð° Ð¿Ñ€Ð¾Ð¿ÑƒÑ‰ÐµÐ½Ð½Ñ‹Ñ… ÑÐºÐ¸Ð½Ð¾Ð² Ð´Ð°Ñ‘Ñ‚ Ð¿Ð»ÑŽÑ Ðº Ð¿Ñ€Ð¾Ð³Ñ€ÐµÑÑÑƒ.",
        en: "Skip a couple skins, gain momentum.",
        es: "Salta un par de skins y gana impulso.",
        fr: "Saute deux skins et tu gagnes en vitesse.",
      },
    },
  },
  foodie_delivery: {
    id: "foodie_delivery",
    emoji: "ðŸ•",
    title: {
      ru: "Ð›ÑŽÐ±Ð¸Ñ‚ÐµÐ»ÑŒ Ð´Ð¾ÑÑ‚Ð°Ð²ÐºÐ¸",
      en: "Delivery lover",
      es: "Fan de la entrega",
      fr: "Accro Ã  la livraison",
    },
    description: {
      ru: "ÐŸÐµÑ€Ð²Ð°Ñ Ð¼Ð¸ÑÑÐ¸Ñ: Ð¼ÐµÐ½ÑŒÑˆÐµ ÑÐ¿Ð¾Ð½Ñ‚Ð°Ð½Ð½Ð¾Ð¹ ÐµÐ´Ñ‹ Ð¸Ð· Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ.",
      en: "Mission one: fewer random delivery orders.",
      es: "MisiÃ³n uno: menos pedidos impulsivos en apps.",
      fr: "Mission 1 : moins de commandes impulsives via l'app.",
    },
    tagline: {
      ru: "ÐŸÐµÑ€ÐµÑÐºÐ¾Ñ‡Ð¸Ð» Ð´Ð¾ÑÑ‚Ð°Ð²ÐºÑƒ Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ð» {{amount}} Ð½Ð° Ñ€ÐµÐ°Ð»ÑŒÐ½ÑƒÑŽ Ñ†ÐµÐ»ÑŒ.",
      en: "Skip delivery, unlock {{amount}} for real goals.",
      es: "Saltarte la entrega libera {{amount}} para la meta real.",
      fr: "Saute une livraison et libÃ¨re {{amount}} pour ton vrai but.",
    },
    habit: {
      emoji: "ðŸ•",
      color: "#FFF8E3",
      categories: ["habit", "food"],
      basePriceUSD: 15,
      title: {
        ru: "Ð”Ð¾ÑÑ‚Ð°Ð²ÐºÐ° Ð²ÐµÑ‡ÐµÑ€ÐºÐ¾Ð¼",
        en: "Night delivery",
        es: "Delivery nocturno",
        fr: "Livraison nocturne",
      },
      description: {
        ru: "ÐŸÐ¸Ñ†Ñ†Ð°, Ð¿Ð¾ÐºÐµ Ð¸Ð»Ð¸ ÑÑƒÑˆÐ¸? Ð’Ñ‹Ð±Ð¸Ñ€Ð°ÐµÑˆÑŒ Ð¿Ñ€Ð¾Ð³Ñ€ÐµÑÑ.",
        en: "Pizza, poke or sushi? You choose progress.",
        es: "Â¿Pizza, poke o sushi? TÃº eliges el progreso.",
        fr: "Pizza, poke ou sushi ? Tu choisis le progrÃ¨s.",
      },
    },
  },
  online_impulse: {
    id: "online_impulse",
    emoji: "ðŸ“¦",
    title: {
      ru: "ÐžÐ½Ð»Ð°Ð¹Ð½-ÑˆÐ¾Ð¿ÐµÑ€",
      en: "Online shopper",
      es: "Comprador online",
      fr: "Shoppeur en ligne",
    },
    description: {
      ru: "Ð›ÑŽÐ±Ð¸Ñ‚ Ð¸Ð¼Ð¿ÑƒÐ»ÑŒÑÐ¸Ð²Ð½Ñ‹Ðµ Ð¾Ð½Ð»Ð°Ð¹Ð½-Ð¿Ð¾ÐºÑƒÐ¿ÐºÐ¸. ÐšÐ»Ð°Ð´Ñ‘Ð¼ Ð² ÑÐ¿Ð¸ÑÐ¾Ðº, Ð° Ð½Ðµ Ð² ÐºÐ¾Ñ€Ð·Ð¸Ð½Ñƒ.",
      en: "Loves impulse online buys. Park them in a list instead of checkout.",
      es: "Le encantan las compras impulsivas online. Mejor guÃ¡rdalas en una lista.",
      fr: "Fan des achats impulsifs en ligne. On les range dans une liste plutÃ´t que dans le panier.",
    },
    tagline: {
      ru: "ÐšÐ°Ð¶Ð´Ñ‹Ð¹ Ð½ÐµÑÐ¾ÑÑ‚Ð¾ÑÐ²ÑˆÐ¸Ð¹ÑÑ Ð·Ð°ÐºÐ°Ð· = {{amount}} Ð±Ð»Ð¸Ð¶Ðµ Ðº Ñ†ÐµÐ»Ð¸.",
      en: "Every skipped checkout moves {{amount}} closer to your goal.",
      es: "Cada carrito sin pagar acerca {{amount}} a tu meta.",
      fr: "Chaque panier abandonnÃ© rapproche de {{amount}} ta prochaine Ã©tape.",
    },
    habit: {
      emoji: "ðŸ“¦",
      color: "#E8F0FF",
      categories: ["habit", "clothing"],
      basePriceUSD: 25,
      title: {
        ru: "ÐžÐ½Ð»Ð°Ð¹Ð½-Ð¸Ð¼Ð¿ÑƒÐ»ÑŒÑ",
        en: "Online impulse",
        es: "Impulso online",
        fr: "Impulsion en ligne",
      },
      description: {
        ru: "Ð•Ñ‰Ñ‘ Ð¾Ð´Ð½Ð° Ð¿Ð¾ÑÑ‹Ð»ÐºÐ°, ÐºÐ¾Ñ‚Ð¾Ñ€Ð°Ñ Ð¼Ð¾Ð³Ð»Ð° ÑÑ‚Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¾Ð³Ñ€ÐµÑÑÐ¾Ð¼.",
        en: "Another package that could have been progress.",
        es: "Otro paquete que podrÃ­a haber sido progreso.",
        fr: "Un colis de plus qui aurait pu devenir du progrÃ¨s.",
      },
    },
  },
  anime_fan: {
    id: "anime_fan",
    emoji: "ðŸŽŒ",
    title: {
      ru: "Ð›ÑŽÐ±Ð¸Ñ‚ÐµÐ»ÑŒ Ð°Ð½Ð¸Ð¼Ðµ",
      en: "Anime fan",
      es: "Fan del anime",
      fr: "Fan d'anime",
    },
    description: {
      ru: "ÐœÐµÑ€Ñ‡, Ð¼Ð°Ð½Ð³Ð° Ð¸ Ñ„Ð¸Ð³ÑƒÑ€ÐºÐ¸. Ð¤Ð¸ÐºÑÐ¸Ñ€ÑƒÐµÐ¼ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ñ‚Ð¾, Ñ‡Ñ‚Ð¾ Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾ Ð²Ð°Ð¶Ð½Ð¾.",
      en: "Merch, manga, figures. Log only what truly matters.",
      es: "Merch, manga, figuras. Registra solo lo que importa.",
      fr: "Merch, manga et figurines : on ne garde que l'essentiel.",
    },
    tagline: {
      ru: "ÐŸÑ€Ð¾Ð¿ÑƒÑÑ‚Ð¸Ð» Ð¾Ñ‡ÐµÑ€ÐµÐ´Ð½Ð¾Ð¹ ÑÐµÑ‚ - {{amount}} Ð² ÐºÐ¾Ð¿Ð¸Ð»ÐºÑƒ Ð¼ÐµÑ‡Ñ‚Ñ‹.",
      en: "Skipped the next merch drop-{{amount}} to your dream.",
      es: "Saltarse el nuevo drop suma {{amount}} a tu sueÃ±o.",
      fr: "Skip le prochain drop = {{amount}} de plus pour ton rÃªve.",
    },
    habit: {
      emoji: "ðŸŽŒ",
      color: "#F2E8FF",
      categories: ["habit", "things"],
      basePriceUSD: 18,
      title: {
        ru: "ÐÐ½Ð¸Ð¼Ðµ-Ð¼ÐµÑ€Ñ‡",
        en: "Anime merch",
        es: "Merch anime",
        fr: "Merch anime",
      },
      description: {
        ru: "Ð¤Ð¸Ð³ÑƒÑ€ÐºÐ°, Ñ‚Ð¾Ð¼Ð¸Ðº Ð¸Ð»Ð¸ Ð±Ñ€ÐµÐ»Ð¾Ðº - Ñ€ÐµÑˆÐ°Ð¹ Ð¾ÑÐ¾Ð·Ð½Ð°Ð½Ð½Ð¾.",
        en: "Figure, volume, or keychain-choose mindfully.",
        es: "Figura, tomo o llavero: decide con consciencia.",
        fr: "Figurine, tome ou porte-clÃ©s : dÃ©cide en conscience.",
      },
    },
  },
  sub_lover: {
    id: "sub_lover",
    emoji: "ðŸ§¾",
    title: {
      ru: "Ð›ÑŽÐ±Ð¸Ñ‚ÐµÐ»ÑŒ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐ¾Ðº",
      en: "Subscription lover",
      es: "Fan de las suscripciones",
      fr: "Fan des abonnements",
    },
    description: {
      ru: "Ð¡Ñ‚Ñ€Ð¸Ð¼Ð¸Ð½Ð³, ÑÐµÑ€Ð²Ð¸ÑÑ‹, Ð´Ð¾Ð¿â€‘Ñ„Ð¸Ñ‡Ð¸. Ð”ÐµÑ€Ð¶Ð¸Ð¼ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ¸ Ð¿Ð¾Ð´ ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»ÐµÐ¼.",
      en: "Streaming, SaaS, extra features. Keep subs under control.",
      es: "Streaming, servicios, extras. MantÃ©n a raya las suscripciones.",
      fr: "Streaming, services et options : on garde les abonnements sous contrÃ´le.",
    },
    tagline: {
      ru: "ÐžÑ‚Ð¼ÐµÐ½Ð¸Ð» Ð»Ð¸ÑˆÐ½ÐµÐµ - {{amount}} Ð¾ÑÑ‚Ð°Ð»Ð°ÑÑŒ Ð² Ñ†ÐµÐ»ÑÑ….",
      en: "Cancel the extra sub-{{amount}} stays with your goals.",
      es: "Cancelar la suscripciÃ³n extra deja {{amount}} en tus metas.",
      fr: "Annule un abonnement de trop et {{amount}} reste pour tes objectifs.",
    },
    habit: {
      emoji: "ðŸ§¾",
      color: "#E9FFF3",
      categories: ["habit", "subscriptions"],
      basePriceUSD: 12,
      title: {
        ru: "Ð›Ð¸ÑˆÐ½ÑÑ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ°",
        en: "Extra subscription",
        es: "SuscripciÃ³n extra",
        fr: "Abonnement en trop",
      },
      description: {
        ru: "ÐœÐµÑÑÑ‡Ð½Ñ‹Ðµ Ð¿Ð»Ð°Ñ‚ÐµÐ¶Ð¸, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ Ð½ÐµÐ·Ð°Ð¼ÐµÑ‚Ð½Ð¾ ÑÑŠÐµÐ´Ð°ÑŽÑ‚ Ð±ÑŽÐ´Ð¶ÐµÑ‚.",
        en: "Monthly payments quietly draining the budget.",
        es: "Pagos mensuales que se comen el presupuesto sin avisar.",
        fr: "Des prÃ©lÃ¨vements mensuels qui mangent le budget sans prÃ©venir.",
      },
    },
  },
  fashion_fan: {
    id: "fashion_fan",
    emoji: "ðŸ‘—",
    title: {
      ru: "Ð›ÑŽÐ±Ð¸Ñ‚ÐµÐ»ÑŒ ÑˆÐ¼Ð¾Ñ‚Ð¾Ðº",
      en: "Fashion lover",
      es: "Fan de la moda",
      fr: "PassionnÃ©Â·e de mode",
    },
    description: {
      ru: "Ð¡Ð»ÐµÐ´Ð¸Ñ‚ Ð·Ð° Ð´Ñ€Ð¾Ð¿Ð°Ð¼Ð¸ Ð¸ ÑÐºÐ¸Ð´ÐºÐ°Ð¼Ð¸. Ð£Ñ‡Ð¸Ð¼ÑÑ Ñ‚Ð¾Ñ€Ð¼Ð¾Ð·Ð¸Ñ‚ÑŒ Ð¸Ð¼Ð¿ÑƒÐ»ÑŒÑÑ‹.",
      en: "Tracks drops and sales. Time to slow the impulses.",
      es: "Sigue drops y rebajas. Toca frenar los impulsos.",
      fr: "Scrute les drops et promos. On apprend Ã  freiner les impulsions.",
    },
    tagline: {
      ru: "ÐšÐ°Ð¶Ð´Ñ‹Ð¹ Ð½ÐµÑÐºÑƒÐ¿Ð»ÐµÐ½Ð½Ñ‹Ð¹ Ð´Ñ€Ð¾Ð¿ = {{amount}} Ðº Ð±Ð¾Ð»ÑŒÑˆÐ¾Ð¼Ñƒ Ð¿Ð»Ð°Ð½Ñƒ.",
      en: "Every unsnapped drop adds {{amount}} to the big plan.",
      es: "Cada drop que dejas pasar suma {{amount}} a tu plan grande.",
      fr: "Chaque drop laissÃ© passer ajoute {{amount}} au grand plan.",
    },
    habit: {
      emoji: "ðŸ‘œ",
      color: "#FFF0F2",
      categories: ["habit", "things"],
      basePriceUSD: 35,
      title: {
        ru: "Ð˜Ð¼Ð¿ÑƒÐ»ÑŒÑÐ½Ñ‹Ð¹ ÑˆÐ¾Ð¿Ð¿Ð¸Ð½Ð³",
        en: "Impulse fashion pick",
        es: "Antojo de moda",
        fr: "Craquage mode",
      },
      description: {
        ru: "Ð¡ÑƒÐ¼ÐºÐ°, Ñ…ÑƒÐ´Ð¸ Ð¸Ð»Ð¸ ÐºÑ€Ð¾ÑÑÑ‹ - Ñ„Ð¸ÐºÑÐ¸Ñ€ÑƒÐ¹, Ð° Ð½Ðµ Ñ…Ð²Ð°Ñ‚Ð°Ð¹.",
        en: "Bag, hoodie or sneakers-log it, don't grab it.",
        es: "Bolso, hoodie o sneakers: regÃ­stralo antes de comprar.",
        fr: "Sac, hoodie ou sneakers : note-le avant de craquer.",
      },
    },
  },
};

const PERSONA_TEMPTATION_PRESETS = {
  glam_beauty: [
    {
      id: "beauty_budget_dupe",
      emoji: "ðŸ’…",
      image:
        "https://images.unsplash.com/photo-1515377905703-c4788e51af15?auto=format&fit=crop&w=900&q=80",
      color: "#FFF0F7",
      categories: ["beauty"],
      audience: ["female"],
      basePriceUSD: 15,
      priceUSD: 15,
      title: {
        ru: "Ð‘ÑŽÐ´Ð¶ÐµÑ‚Ð½Ñ‹Ð¹ Ð±ÑŒÑŽÑ‚Ð¸-Ð´ÑŽÐ¿",
        en: "Budget beauty dupe",
        es: "Dupe beauty econÃ³mico",
        fr: "Dupe beautÃ© abordable",
      },
      description: {
        ru: "Â«ÐŸÐ¾Ñ‡Ñ‚Ð¸ ÐºÐ°Ðº Ð»ÑŽÐºÑÂ» Ð¸Ð· Ð¼Ð°ÑÑ-Ð¼Ð°Ñ€ÐºÐµÑ‚Ð°, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð»ÐµÐ³ÐºÐ¾ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ Ð² ÐºÐ¾Ð¿Ð¸Ð»ÐºÑƒ.",
        en: "A \"luxury lookalike\" from the drugstore that could go straight to savings.",
        es: "Ese \"casi lujo\" de farmacia que puede ir directo al ahorro.",
        fr: "Ce Â« faux luxe Â» de grande surface peut filer direct Ã  la cagnotte.",
      },
    },
    {
      id: "beauty_spa_break",
      emoji: "ðŸ§–â€â™€ï¸",
      image:
        "https://images.unsplash.com/photo-1506617420156-8e4536971650?auto=format&fit=crop&w=900&q=80",
      color: "#FFF7F1",
      categories: ["beauty"],
      audience: ["female"],
      basePriceUSD: 45,
      priceUSD: 45,
      title: {
        ru: "Ð¡Ð¿Ð¾Ð½Ñ‚Ð°Ð½Ð½Ñ‹Ð¹ ÑÐ°Ð»Ð¾Ð½",
        en: "Spontaneous salon day",
        es: "DÃ­a de salÃ³n espontÃ¡neo",
        fr: "Passage salon improvisÃ©",
      },
      description: {
        ru: "ÐœÐ°Ð½Ð¸ÐºÑŽÑ€ Ð¸Ð»Ð¸ ÑƒÑ…Ð¾Ð´ Â«Ð¿Ñ€Ð¾ÑÑ‚Ð¾ Ð¿Ð¾Ñ‚Ð¾Ð¼Ñƒ Ñ‡Ñ‚Ð¾Â». ÐœÐ¾Ð¶Ð½Ð¾ Ð¿Ð¾Ð¹Ð¼Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¾Ð³Ñ€ÐµÑÑ Ð²Ð¼ÐµÑÑ‚Ð¾ Ñ‡ÐµÐºÐ°.",
        en: "Mani or facial \"just because.\" Swap the receipt for progress instead.",
        es: "Mani o facial \"porque sÃ­\". Cambia el ticket por progreso.",
        fr: "Manucure ou soin Â« juste parce que Â». Remplace la note par du progrÃ¨s.",
      },
    },
    {
      id: "beauty_pro_gadget",
      emoji: "ðŸŒ¸",
      image:
        "https://images.unsplash.com/photo-1522335789203-aabd1fc54bc9?auto=format&fit=crop&w=900&q=80",
      color: "#F6ECFF",
      categories: ["beauty"],
      audience: ["female"],
      basePriceUSD: 140,
      priceUSD: 140,
      title: {
        ru: "Ð”Ð¾Ð¼Ð°ÑˆÐ½Ð¸Ð¹ Ð±ÑŒÑŽÑ‚Ð¸-Ð³Ð°Ð´Ð¶ÐµÑ‚",
        en: "At-home beauty gadget",
        es: "Gadget beauty en casa",
        fr: "Appareil beautÃ© maison",
      },
      description: {
        ru: "Ð©Ñ‘Ñ‚ÐºÐ°, LED-Ð¼Ð°ÑÐºÐ° Ð¸Ð»Ð¸ Ð´ÐµÐ²Ð°Ð¹Ñ, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð¼Ð¾Ð¶ÐµÑ‚ Ð¿Ð¾Ð´Ð¾Ð¶Ð´Ð°Ñ‚ÑŒ Ñ€Ð°Ð´Ð¸ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ð¹ Ñ†ÐµÐ»Ð¸.",
        en: "Cleansing brush, LED mask or device that can wait for the big goal.",
        es: "Cepillo, mÃ¡scara LED o gadget que puede esperar a la gran meta.",
        fr: "Brosse, masque LED ou gadget qui peut attendre lâ€™objectif majeur.",
      },
    },
  ],
};

const PERSONA_TEMPTATION_LOOKUP = Object.values(PERSONA_TEMPTATION_PRESETS).reduce(
  (acc, list) => acc.concat(list || []),
  []
);

const PERSONA_HABIT_TYPES = {
  mindful_coffee: "coffee",
  habit_smoking: "smoking",
  glam_beauty: "beauty",
  gamer_loot: "gaming",
  foodie_delivery: "delivery",
  online_impulse: "shopping",
  anime_fan: "anime",
  sub_lover: "subscriptions",
  fashion_fan: "fashion",
};

const PERSONA_SELECTED_EVENTS = {
  coffee: "persona_coffee_selected",
  smoking: "persona_smoking_selected",
  beauty: "persona_beauty_selected",
  gaming: "persona_gaming_selected",
  delivery: "persona_delivery_selected",
  shopping: "persona_shopping_selected",
  anime: "persona_anime_selected",
  subscriptions: "persona_subscriptions_selected",
  fashion: "persona_fashion_selected",
  custom: "persona_custom_selected",
};

const LANGUAGE_SELECTED_EVENTS = {
  ru: "language_ru_selected",
  en: "language_en_selected",
  es: "language_es_selected",
  fr: "language_fr_selected",
};

const GENDER_SELECTED_EVENTS = {
  female: "gender_female_selected",
  male: "gender_male_selected",
  none: "gender_none_selected",
};

const CURRENCY_SELECTED_EVENTS = {
  USD: "currency_usd_selected",
  AED: "currency_aed_selected",
  AUD: "currency_aud_selected",
  BYN: "currency_byn_selected",
  CAD: "currency_cad_selected",
  EUR: "currency_eur_selected",
  GBP: "currency_gbp_selected",
  JPY: "currency_jpy_selected",
  KZT: "currency_kzt_selected",
  KRW: "currency_krw_selected",
  MXN: "currency_mxn_selected",
  PLN: "currency_pln_selected",
  RUB: "currency_rub_selected",
  SAR: "currency_sar_selected",
};

const getPersonaSelectedEvent = (personaId) => {
  const habitType = PERSONA_HABIT_TYPES[personaId] || "custom";
  return PERSONA_SELECTED_EVENTS[habitType] || null;
};

const getLanguageSelectedEvent = (language) => {
  const normalized = normalizeLanguage(language);
  return LANGUAGE_SELECTED_EVENTS[normalized] || null;
};

const getGenderSelectedEvent = (gender) => {
  const normalized = gender || "none";
  return GENDER_SELECTED_EVENTS[normalized] || null;
};

const getCurrencySelectedEvent = (code) => {
  const normalized = (code || "").toUpperCase();
  return CURRENCY_SELECTED_EVENTS[normalized] || null;
};

const DEFAULT_PERSONA_ID = "mindful_coffee";

const GENDER_OPTIONS = [
  { id: "female", label: { ru: "Ð–ÐµÐ½Ñ‰Ð¸Ð½Ð°", en: "Female", es: "Mujer", fr: "Femme" }, emoji: "ðŸ’â€â™€ï¸" },
  { id: "male", label: { ru: "ÐœÑƒÐ¶Ñ‡Ð¸Ð½Ð°", en: "Male", es: "Hombre", fr: "Homme" }, emoji: "ðŸ§‘â€ðŸ¦±" },
  {
    id: "none",
    label: {
      ru: "ÐÐµ ÑƒÐºÐ°Ð·Ñ‹Ð²Ð°Ñ‚ÑŒ",
      en: "Prefer not to say",
      es: "Prefiero no decirlo",
      fr: "Je prÃ©fÃ¨re ne pas le dire",
    },
    emoji: "ðŸ¤«",
  },
];

const GOAL_PRESETS = [
  { id: "travel", ru: "ÐŸÑƒÑ‚ÐµÑˆÐµÑÑ‚Ð²Ð¸Ñ", en: "Travel", es: "Viajes", fr: "Voyages", emoji: "âœˆï¸", targetUSD: 1500 },
  { id: "tech", ru: "Ð¢ÐµÑ…Ð½Ð¸ÐºÐ°", en: "Tech upgrade", es: "TecnologÃ­a", fr: "Upgrade tech", emoji: "ðŸ’»", targetUSD: 900 },
  {
    id: "daily",
    ru: "Ð•Ð¶ÐµÐ´Ð½ÐµÐ²Ð½Ñ‹Ðµ Ñ†ÐµÐ»Ð¸",
    en: "Daily treats",
    es: "Caprichos diarios",
    fr: "Plaisirs quotidiens",
    emoji: "ðŸ©",
    targetUSD: 250,
  },
  {
    id: "save",
    ru: "ÐŸÑ€Ð¾ÑÑ‚Ð¾ ÐºÐ¾Ð¿Ð¸Ñ‚ÑŒ",
    en: "Rainy-day fund",
    es: "Fondo de respaldo",
    fr: "Fonds de secours",
    emoji: "ðŸ’°",
    targetUSD: 600,
  },
];

const PRIMARY_GOAL_KIND = "primary_goal";
const PRIMARY_GOAL_WISH_ID_LEGACY = "wish_primary_goal";
const getPrimaryGoalWishId = (goalId = "default") => `wish_primary_goal_${goalId}`;

const getGoalPreset = (goalId) => GOAL_PRESETS.find((goal) => goal.id === goalId);
const getGoalDefaultTargetUSD = (goalId) => {
  const preset = getGoalPreset(goalId);
  return preset?.targetUSD || 500;
};

const resolveProfileGoalId = (profile) => {
  if (!profile || typeof profile !== "object") return null;
  if (profile.goal) return profile.goal;
  if (Array.isArray(profile.primaryGoals)) {
    const first = profile.primaryGoals.find((entry) => entry?.id);
    if (first?.id) return first.id;
  }
  return null;
};

const insertWishAfterPrimary = (list = [], newWish) => {
  if (!newWish) return list;
  const lastPrimaryIndex = list.reduce(
    (lastIndex, wish, index) => (wish?.kind === PRIMARY_GOAL_KIND ? index : lastIndex),
    -1
  );
  if (lastPrimaryIndex === -1) {
    return [newWish, ...list];
  }
  const before = list.slice(0, lastPrimaryIndex + 1);
  const after = list.slice(lastPrimaryIndex + 1);
  return [...before, newWish, ...after];
};

const removePrimaryGoalFromProfile = (profileState = {}, goalId) => {
  if (!goalId) return profileState;
  const currentGoals = Array.isArray(profileState.primaryGoals) ? profileState.primaryGoals : [];
  const filtered = currentGoals.filter((goal) => goal.id !== goalId);
  const nextGoalId = filtered[0]?.id || profileState.goal || DEFAULT_PROFILE.goal;
  const nextGoalTarget = filtered[0]
    ? (Number.isFinite(filtered[0].targetUSD) && filtered[0].targetUSD > 0
        ? filtered[0].targetUSD
        : getGoalDefaultTargetUSD(filtered[0].id))
    : getGoalDefaultTargetUSD(nextGoalId);
  return {
    ...profileState,
    primaryGoals: filtered,
    goal: nextGoalId,
    goalTargetUSD: nextGoalTarget,
    goalCelebrated: filtered.length ? profileState.goalCelebrated : false,
  };
};

const updatePrimaryGoalTargetInProfile = (profileState = {}, goalId, targetUSD, extra = {}) => {
  if (!goalId) return profileState;
  const currentGoals = Array.isArray(profileState.primaryGoals) ? profileState.primaryGoals : [];
  const updated = currentGoals.map((goal) =>
    goal.id === goalId ? { ...goal, targetUSD, ...extra } : goal
  );
  const activeGoalId = profileState.goal || updated[0]?.id || goalId;
  const activeEntry = updated.find((goal) => goal.id === activeGoalId) || updated[0] || null;
  const nextTarget = activeEntry
    ? (Number.isFinite(activeEntry.targetUSD) && activeEntry.targetUSD > 0
        ? activeEntry.targetUSD
        : getGoalDefaultTargetUSD(activeEntry.id))
    : getGoalDefaultTargetUSD(activeGoalId);
  return {
    ...profileState,
    primaryGoals: updated,
    goal: activeEntry?.id || activeGoalId,
    goalTargetUSD: nextTarget,
  };
};

const PROFILE_BIO_FALLBACKS = {
  ru: "Ð›ÑŽÐ±Ð»ÑŽ ÐºÑ€Ð°ÑÐ¸Ð²Ñ‹Ðµ Ð²ÐµÑ‰Ð¸, Ð½Ð¾ Ð±Ð¾Ð»ÑŒÑˆÐµ Ð»ÑŽÐ±Ð»ÑŽ Ñ„Ð¸Ð½Ð°Ð½ÑÐ¾Ð²Ñ‹Ð¹ Ð¿Ð»Ð°Ð½",
  en: "I love nice things, but I love my money plan even more",
  es: "Me encantan las cosas bonitas, pero mÃ¡s mi plan financiero",
  fr: "Jâ€™aime les belles choses, mais jâ€™adore encore plus mon plan financier",
};
const PROFILE_BIO_FALLBACK_VALUES = Object.values(PROFILE_BIO_FALLBACKS);

const DEFAULT_PROFILE = {
  name: "Nina Cleanova",
  firstName: "Nina",
  lastName: "Cleanova",
  subtitle: "",
  motto: "",
  bio: PROFILE_BIO_FALLBACKS.en,
  avatar: "",
  currency: "USD",
  goal: "save",
  goalTargetUSD: getGoalDefaultTargetUSD("save"),
  primaryGoals: [{ id: "save", targetUSD: getGoalDefaultTargetUSD("save") }],
  goalCelebrated: false,
  goalRenewalPending: false,
  persona: "mindful_coffee",
  gender: "none",
  customSpend: null,
  spendReducesSavings: false,
  spendingProfile: {
    baselineMonthlyWasteUSD: 0,
    baselineStartAt: null,
  },
  joinedAt: null,
};

const DEFAULT_PROFILE_PLACEHOLDER = {
  ...DEFAULT_PROFILE,
  name: "",
  firstName: "",
  lastName: "",
  subtitle: "",
  motto: "",
  bio: "",
  goal: null,
  goalTargetUSD: 0,
  primaryGoals: [],
};

const resolvePotentialPushStepUSD = (currencyCode = DEFAULT_PROFILE.currency) => {
  const normalizedCode =
    typeof currencyCode === "string" && currencyCode.trim().length > 0
      ? currencyCode.trim().toUpperCase()
      : DEFAULT_PROFILE.currency;
  const convertCode = CURRENCIES.includes(normalizedCode) ? normalizedCode : DEFAULT_PROFILE.currency;
  const localStep =
    POTENTIAL_PUSH_STEP_LOCAL_MAP[normalizedCode] ??
    POTENTIAL_PUSH_STEP_LOCAL_MAP[convertCode] ??
    POTENTIAL_PUSH_STEP_LOCAL_FALLBACK;
  const resolvedUSD = convertFromCurrency(localStep, convertCode);
  if (Number.isFinite(resolvedUSD) && resolvedUSD > 0) {
    return resolvedUSD;
  }
  return POTENTIAL_PUSH_STEP_USD;
};

const INITIAL_REGISTRATION = {
  firstName: "",
  lastName: "",
  motto: "",
  avatar: "",
  currency: "USD",
  gender: "none",
  persona: "mindful_coffee",
  customSpendTitle: "",
  customSpendAmount: "",
  customSpendFrequency: "",
   customSpendCategory: DEFAULT_IMPULSE_CATEGORY,
  baselineMonthlyWaste: "",
  baselineCapturedAt: null,
  goalSelections: [],
  goalTargetMap: {},
  customGoals: [],
  goalTargetConfirmed: [],
};

const ONBOARDING_SCREEN_SEQUENCE = [
  "logo",
  "language",
  "analytics_consent",
  "guide",
  "register",
  "persona",
  "habit",
  "baseline",
  "goal",
  "goal_target",
  "push_optin",
];

const ONBOARDING_STEP_REACHED_EVENTS = {
  1: "onboarding_step_1_reached",
  2: "onboarding_step_2_reached",
  3: "onboarding_step_3_reached",
  4: "onboarding_step_4_reached",
  5: "onboarding_step_5_reached",
  6: "onboarding_step_6_reached",
  7: "onboarding_step_7_reached",
  8: "onboarding_step_8_reached",
  9: "onboarding_step_9_reached",
  10: "onboarding_step_10_reached",
  11: "onboarding_step_11_reached",
};

const resolveOnboardingScreenNumber = (step) => {
  const idx = ONBOARDING_SCREEN_SEQUENCE.indexOf(step);
  return idx >= 0 ? idx + 1 : null;
};

const getOnboardingStepReachedEvent = (stepNumber) =>
  ONBOARDING_STEP_REACHED_EVENTS[stepNumber] || null;

const findTemplateById = (id) =>
  DEFAULT_TEMPTATIONS.find((item) => item.id === id) ||
  PERSONA_TEMPTATION_LOOKUP.find((item) => item.id === id);

const INITIAL_FREE_DAY_STATS = {
  total: 0,
  current: 0,
  best: 0,
  lastDate: null,
  achievements: [],
  blockedDate: null,
};

const FREE_DAY_MILESTONES = [3, 7, 30];
const HEALTH_PER_REWARD = ECONOMY_RULES.baseAchievementReward;
const FREE_DAY_RESCUE_COST = ECONOMY_RULES.freeDayRescueCost;
const FREE_DAY_LOGIN_BLUE_COINS = 2;

let activeCurrency = DEFAULT_PROFILE.currency;
const setActiveCurrency = (code) => {
  activeCurrency = CURRENCIES.includes(code) ? code : DEFAULT_PROFILE.currency;
};

const GOALS = [
  {
    id: "starter",
    target: 250,
    copy: {
      ru: { title: "Ð—Ð°Ð±Ñ€Ð¾Ð½ÑŒ 250$", desc: "Ð¼ÐµÐ½ÑŒÑˆÐµ ÐºÐ¾Ñ„ÐµÐµÐ½, Ð±Ð¾Ð»ÑŒÑˆÐµ Ñ€ÐµÐ·ÐµÑ€Ð²Ð°" },
      en: { title: "Lock $250", desc: "skip cafÃ©s, build reserves" },
      es: { title: "Asegura $250", desc: "menos cafÃ©s, mÃ¡s reserva" },
      fr: { title: "Verrouille 250 $", desc: "moins de cafÃ©s, plus de rÃ©serve" },
    },
  },
  {
    id: "focus",
    target: 1000,
    copy: {
      ru: { title: "Ð¡Ð´ÐµÑ€Ð¶Ð¸ 1000$", desc: "Ð¾ÑÐ¾Ð·Ð½Ð°Ð½Ð½Ñ‹Ðµ Ð³Ð°Ð´Ð¶ÐµÑ‚Ñ‹ Ð²Ð¼ÐµÑÑ‚Ð¾ Ñ…Ð°Ð¾ÑÐ°" },
      en: { title: "Hold $1000", desc: "mindful tech deals only" },
      es: { title: "RetÃ©n $1000", desc: "gadgets con consciencia" },
      fr: { title: "Garde 1 000 $", desc: "des gadgets rÃ©flÃ©chis uniquement" },
    },
  },
  {
    id: "pro",
    target: 5000,
    copy: {
      ru: { title: "Ð“ÐµÑ€Ð¾Ð¹ ÑÐºÐ¾Ð½Ð¾Ð¼Ð¸Ð¸", desc: "Ñ‚Ñ‹ Ð·Ð°Ð¼ÐµÐ½ÑÐµÑˆÑŒ Ñ‚Ñ€Ð°Ñ‚Ñ‹ Ð¿Ñ€Ð¸Ð²Ñ‹Ñ‡ÐºÐ¾Ð¹" },
      en: { title: "Savings hero", desc: "deals became a habit" },
      es: { title: "HÃ©roe del ahorro", desc: "los rechazos son tu hÃ¡bito" },
      fr: { title: "HÃ©ros de l'Ã©pargne", desc: "les refus sont devenus ton habitude" },
    },
  },
];

const SAVINGS_TIERS = [10, 20, 50, 100, 250, 500, 1000, 2500, 5000, 10000, 20000, 50000, 100000, 250000];
const LEVEL_XP_BASE_USD = 5;
const LEVEL_XP_SCALE = 200;
const LEVEL_XP_STEP = 140;
const MAX_LEVEL = SAVINGS_TIERS.length + 1;
const getLevelXP = (savedUSD = 0) => {
  const normalized = Math.max(0, Number(savedUSD) || 0);
  return LEVEL_XP_SCALE * Math.log1p(normalized / LEVEL_XP_BASE_USD);
};
const getUSDFromLevelXP = (xp = 0) => {
  const normalizedXP = Math.max(0, Number(xp) || 0);
  return LEVEL_XP_BASE_USD * Math.expm1(normalizedXP / LEVEL_XP_SCALE);
};
const getTierTargetsXP = () =>
  Array.from({ length: Math.max(0, MAX_LEVEL - 1) }, (_, index) => (index + 1) * LEVEL_XP_STEP);
const getLevelTwoTargetUSD = (currencyCode = activeCurrency) => {
  const code = currencyCode || activeCurrency;
  const localTargetRounded = Math.round(convertToCurrency(10, code));
  return convertFromCurrency(localTargetRounded, code);
};
const getTierTargetsUSD = (currencyCode = activeCurrency) => {
  const code = currencyCode || activeCurrency;
  const levelTwoTarget = getLevelTwoTargetUSD(code);
  return [levelTwoTarget, ...SAVINGS_TIERS.slice(1)];
};

const intlFallbackWarnings = new Set();
const warnIntlFallback = (currency, locale, error) => {
  const key = `${currency || "unknown"}:${locale || "default"}`;
  if (intlFallbackWarnings.has(key)) return;
  intlFallbackWarnings.add(key);
  console.warn(
    "Intl.NumberFormat fallback",
    currency || "currency_unknown",
    locale || "locale_unknown",
    error?.message || error
  );
};

const formatNumberWithGrouping = (value, fractionDigits = 0) => {
  const safePrecision =
    typeof fractionDigits === "number" && Number.isFinite(fractionDigits)
      ? Math.max(0, Math.min(6, fractionDigits))
      : 0;
  const numericValue = Number(value) || 0;
  const absolute = Math.abs(numericValue);
  const fixed = absolute.toFixed(safePrecision);
  const [integerPart, decimalPart] = fixed.split(".");
  const groupedInteger = integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, " ");
  const sign = numericValue < 0 ? "-" : "";
  if (safePrecision > 0 && decimalPart) {
    return `${sign}${groupedInteger}.${decimalPart}`;
  }
  return `${sign}${groupedInteger}`;
};

const formatCurrencyFallback = (value, currency, fractionDigits = 0) => {
  const digits = formatNumberWithGrouping(value, fractionDigits);
  const isRtl = RTL_CURRENCIES.has(currency);
  const symbol = CURRENCY_SIGNS[currency] || (isRtl ? "" : "$");
  const prefix = isRtl ? `${LTR_MARK}${symbol}` : symbol;
  return `${prefix}${digits}`;
};

const formatCurrency = (value = 0, currency = activeCurrency, options = null) => {
  const locale = CURRENCY_LOCALES[currency] || "en-US";
  const displayPrecision = getCurrencyDisplayPrecision(currency);
  const precisionOverride =
    typeof options?.precisionOverride === "number" && Number.isFinite(options.precisionOverride)
      ? Math.max(0, Math.min(6, options.precisionOverride))
      : null;
  const friendlyRequested = Boolean(options?.friendly);
  const friendly = friendlyRequested && precisionOverride === null;
  const baseValue = Number(value) || 0;
  const adjusted = friendly ? applyFriendlyDisplayRounding(baseValue, currency) : baseValue;
  const precision = precisionOverride ?? displayPrecision;
  const normalized = roundCurrencyValue(adjusted, currency, precision);
  const minFractionDigits = precisionOverride !== null ? precision : 0;
  const maxFractionDigits = precision;
  try {
    if (RTL_CURRENCIES.has(currency)) {
      const digits = new Intl.NumberFormat("en-US", {
        minimumFractionDigits: minFractionDigits,
        maximumFractionDigits: maxFractionDigits,
      }).format(normalized);
      const symbol = CURRENCY_SIGNS[currency] || "";
      return `${LTR_MARK}${symbol}${digits}`;
    }
    return new Intl.NumberFormat(locale, {
      style: "currency",
      currency,
      minimumFractionDigits: minFractionDigits,
      maximumFractionDigits: maxFractionDigits,
    }).format(normalized);
  } catch (intlError) {
    warnIntlFallback(currency, locale, intlError);
    try {
      if (RTL_CURRENCIES.has(currency)) {
        const digits = normalized.toLocaleString("en-US", {
          minimumFractionDigits: minFractionDigits,
          maximumFractionDigits: maxFractionDigits,
        });
        const symbol = CURRENCY_SIGNS[currency] || "";
        return `${LTR_MARK}${symbol}${digits}`;
      }
      const digits = normalized.toLocaleString(locale, {
        minimumFractionDigits: minFractionDigits,
        maximumFractionDigits: maxFractionDigits,
      });
      const symbol = CURRENCY_SIGNS[currency] || "$";
      return `${symbol}${digits}`;
    } catch (localeError) {
      warnIntlFallback(currency, locale, localeError);
      return formatCurrencyFallback(normalized, currency, maxFractionDigits);
    }
  }
};

const formatCurrencyWhole = (value = 0, currency = activeCurrency, precisionOverride = null) => {
  const locale = CURRENCY_LOCALES[currency] || "en-US";
  const basePrecision = getCurrencyDisplayPrecision(currency);
  const normalizedPrecision =
    typeof precisionOverride === "number" && Number.isFinite(precisionOverride)
      ? Math.max(0, Math.min(6, precisionOverride))
      : basePrecision;
  const rounded = roundCurrencyValue(Number(value) || 0, currency, normalizedPrecision);
  try {
    if (RTL_CURRENCIES.has(currency)) {
      const digits = new Intl.NumberFormat("en-US", {
        minimumFractionDigits: normalizedPrecision,
        maximumFractionDigits: normalizedPrecision,
      }).format(rounded);
      const symbol = CURRENCY_SIGNS[currency] || "";
      return `${LTR_MARK}${symbol}${digits}`;
    }
    return new Intl.NumberFormat(locale, {
      style: "currency",
      currency,
      minimumFractionDigits: normalizedPrecision,
      maximumFractionDigits: normalizedPrecision,
    }).format(rounded);
  } catch (intlError) {
    warnIntlFallback(currency, locale, intlError);
    try {
      if (RTL_CURRENCIES.has(currency)) {
        const digits = rounded.toLocaleString("en-US", {
          minimumFractionDigits: normalizedPrecision,
          maximumFractionDigits: normalizedPrecision,
        });
        const symbol = CURRENCY_SIGNS[currency] || "";
        return `${LTR_MARK}${symbol}${digits}`;
      }
      const digits = rounded.toLocaleString(locale, {
        minimumFractionDigits: normalizedPrecision,
        maximumFractionDigits: normalizedPrecision,
      });
      const symbol = CURRENCY_SIGNS[currency] || "$";
      return `${symbol}${digits}`;
    } catch (localeError) {
      warnIntlFallback(currency, locale, localeError);
      return formatCurrencyFallback(rounded, currency, normalizedPrecision);
    }
  }
};

const splitCurrencyLabel = (label = "", currency = activeCurrency) => {
  if (!label) return { value: "", symbol: "" };
  const normalized = `${label}`.replace(/[\u00A0\u202F]/g, " ").trim();
  if (!normalized) return { value: "", symbol: "" };
  const preferredSymbol = CURRENCY_SIGNS[currency] || "";
  const hasPreferredSymbol = preferredSymbol && normalized.includes(preferredSymbol);
  const fallbackSymbol = normalized.replace(/[-\d\s.,]/g, "").trim();
  const symbol = hasPreferredSymbol ? preferredSymbol : fallbackSymbol;
  const value = symbol ? normalized.replace(symbol, "").trim() : normalized;
  return {
    value: value.replace(/\s{2,}/g, " "),
    symbol,
  };
};

const getCopyForPurchase = (item, language, t) => {
  if (item.copy?.[language]) return item.copy[language];
  const product = DEFAULT_TEMPTATIONS.find((prod) => prod.id === item.productId);
  if (product) {
    return {
      title: product.title?.[language] || product.title?.en || product.id,
      desc: product.description?.[language] || product.description?.en || t("defaultDealDesc"),
    };
  }
  return {
    title: t("defaultDealTitle"),
    desc: t("defaultDealDesc"),
  };
};

const parseColor = (value) => {
  if (typeof value !== "string") return { r: 0, g: 0, b: 0 };
  if (value.startsWith("#")) {
    const full =
      value.length === 4
        ? `#${value[1]}${value[1]}${value[2]}${value[2]}${value[3]}${value[3]}`
        : value;
    const num = parseInt(full.slice(1), 16);
    if (Number.isNaN(num)) return { r: 0, g: 0, b: 0 };
    return { r: (num >> 16) & 255, g: (num >> 8) & 255, b: num & 255 };
  }
  const rgbMatch = value.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/i);
  if (rgbMatch) {
    return { r: Number(rgbMatch[1]), g: Number(rgbMatch[2]), b: Number(rgbMatch[3]) };
  }
  return { r: 0, g: 0, b: 0 };
};

const blendColors = (colorA, colorB, ratio = 0.5) => {
  const clamp = (num) => Math.max(0, Math.min(255, Math.round(num)));
  const t = Math.max(0, Math.min(1, ratio));
  const a = parseColor(colorA);
  const b = parseColor(colorB);
  const r = clamp(a.r * (1 - t) + b.r * t);
  const g = clamp(a.g * (1 - t) + b.g * t);
  const bl = clamp(a.b * (1 - t) + b.b * t);
  return `rgb(${r}, ${g}, ${bl})`;
};

const blendHexColors = (colorA, colorB, ratio = 0.5) => {
  const clamp = (num) => Math.max(0, Math.min(255, Math.round(num)));
  const toHex = (num) => clamp(num).toString(16).padStart(2, "0");
  const t = Math.max(0, Math.min(1, ratio));
  const a = parseColor(colorA);
  const b = parseColor(colorB);
  const r = a.r * (1 - t) + b.r * t;
  const g = a.g * (1 - t) + b.g * t;
  const bl = a.b * (1 - t) + b.b * t;
  return `#${toHex(r)}${toHex(g)}${toHex(bl)}`;
};

const colorWithAlpha = (color, alpha = 1) => {
  const normalized = Math.max(0, Math.min(1, alpha));
  const { r, g, b } = parseColor(color);
  return `rgba(${r}, ${g}, ${b}, ${normalized})`;
};

const getTierProgress = (savedUSD = 0, currencyCode = activeCurrency) => {
  const tierTargetsXP = getTierTargetsXP();
  const savedXP = getLevelXP(savedUSD);
  let previousTargetXP = 0;
  for (let i = 0; i < tierTargetsXP.length; i += 1) {
    const targetXP = tierTargetsXP[i];
    if (savedXP < targetXP) {
      return {
        level: i + 1,
        prevTargetUSD: getUSDFromLevelXP(previousTargetXP),
        nextTargetUSD: getUSDFromLevelXP(targetXP),
      };
    }
    previousTargetXP = targetXP;
  }
  return {
    level: tierTargetsXP.length + 1,
    prevTargetUSD: getUSDFromLevelXP(previousTargetXP),
    nextTargetUSD: null,
  };
};

const resolveTemptationTitle = (item, language, override) => {
  if (override) return override;
  if (item.titleOverride) return item.titleOverride;
  const source = item.title;
  if (typeof source === "string") return source;
  return (
    source?.[language] ||
    source?.en ||
    (typeof source === "object" ? Object.values(source)[0] : null) ||
    "Goal"
  );
};

const buildTemptationDisplayTitle = (emojiValue, titleValue, fallbackTitle = "Goal") => {
  const emoji = (emojiValue || "").trim();
  const title = (titleValue || "").trim() || fallbackTitle || "";
  return emoji ? `${emoji} ${title}`.trim() : title;
};

const getTemptationPrice = (item) => {
  const price = typeof item?.priceUSD === "number" ? item.priceUSD : item?.basePriceUSD;
  if (typeof price === "number" && !Number.isNaN(price)) {
    return price;
  }
  return 0;
};

const getTemptationPricePrecision = (item) => {
  if (!item) return null;
  const precision = item.pricePrecision;
  if (typeof precision === "number" && Number.isFinite(precision) && precision >= 0) {
    return precision;
  }
  return null;
};

const formatTemptationPriceLabel = (item, currency) => {
  const priceUSD = getTemptationPrice(item);
  const precision = getTemptationPricePrecision(item);
  const hasOverride = precision !== null;
  return formatCurrency(convertToCurrency(priceUSD, currency), currency, {
    friendly: !hasOverride,
    precisionOverride: hasOverride ? precision : null,
  });
};

const filterTemptationsByPrice = (list, limitUSD) => {
  if (!Array.isArray(list)) return [];
  if (!Number.isFinite(limitUSD)) return list;
  return list.filter((item) => isCustomTemptation(item) || getTemptationPrice(item) <= limitUSD);
};

function TemptationCardComponent({
  item,
  language,
  colors,
  onAction,
  t,
  currency = activeCurrency,
  stats = {},
  feedback,
  titleOverride,
  descriptionOverride = null,
  goalLabel = null,
  isWishlistGoal = false,
  isFocusTarget = false,
  editCategoryValue = DEFAULT_IMPULSE_CATEGORY,
  onEditCategoryChange,
  onToggleEdit,
  isEditing = false,
  editTitleValue = "",
  editPriceValue = "",
  editGoalLabel = "",
  editEmojiValue = "",
  editDescriptionValue = "",
  onEditTitleChange,
  onEditPriceChange,
  onEditEmojiChange,
  onEditDescriptionChange,
  onEditSave,
  onEditCancel,
  onEditDelete,
  onEditGoalSelect,
  onSwipeDelete,
  onQuickGoalToggle,
  showEditorInline = false,
  cardStyle = null,
  isPrimaryTemptation = false,
  tutorialHighlightMode = null,
  tutorialHighlightMeasureTick = 0,
  tutorialHighlightOffset = null,
  onTutorialHighlightLayoutChange = null,
  interaction = null,
  timerNow = null,
  allowThinkAction = true,
  onFocusBadgePress,
}) {
  const title = resolveTemptationTitle(item, language, titleOverride);
  const isCustomCard =
    Array.isArray(item?.categories) && item.categories.some((category) => category === "custom");
  const descriptionString = typeof item.description === "string" ? item.description : null;
  const descriptionMap =
    item.description && typeof item.description === "object" && !Array.isArray(item.description)
      ? item.description
      : null;
  const customDescriptionFallback = isCustomCard
    ? buildCustomTemptationDescription(item?.gender || "none")
    : null;
  const customLanguageFallback = customDescriptionFallback
    ? resolveLanguageMapValue(customDescriptionFallback, language)
    : null;
  const descriptionLanguageValue = descriptionMap ? resolveLanguageMapValue(descriptionMap, language) : null;
  let resolvedDesc = descriptionOverride || null;
  if (!resolvedDesc) {
    const baseDescription = descriptionLanguageValue || descriptionString || "";
    resolvedDesc = isCustomCard ? baseDescription || customLanguageFallback || "" : baseDescription;
  }
  const desc = resolvedDesc || "";
  const tutorialHighlightActive = Boolean(tutorialHighlightMode);
  const tutorialHighlightActions = tutorialHighlightMode === "actions";
  const tutorialHighlightSwipe = tutorialHighlightMode === "swipe";
  const tutorialHighlightThink = tutorialHighlightMode === "think" && allowThinkAction;
  const tutorialHighlightFrame = tutorialHighlightSwipe || tutorialHighlightActions;
  const tutorialHighlightCardRef = useRef(null);
  const updateTutorialHighlightLayout = useCallback(() => {
    if (typeof onTutorialHighlightLayoutChange !== "function") return;
    if (!tutorialHighlightActive) {
      onTutorialHighlightLayoutChange(null);
      return;
    }
    const node = tutorialHighlightCardRef.current;
    const measureTarget = node && typeof node.measureInWindow !== "function"
      ? node.getNode?.()
      : node;
    if (!measureTarget || typeof measureTarget.measureInWindow !== "function") return;
    requestAnimationFrame(() => {
      measureTarget.measureInWindow((x, y, width, height) => {
        const androidFineTune =
          Platform.OS === "android"
            ? (Number.isFinite(tutorialHighlightOffset)
                ? tutorialHighlightOffset
                : ANDROID_TUTORIAL_HIGHLIGHT_OFFSET) + (RNStatusBar.currentHeight || 0)
            : 0;
        onTutorialHighlightLayoutChange({
          x,
          y: y + androidFineTune,
          width,
          height,
        });
      });
    });
  }, [onTutorialHighlightLayoutChange, tutorialHighlightActive]);
  const handleTutorialCardLayout = useCallback(() => {
    updateTutorialHighlightLayout();
  }, [updateTutorialHighlightLayout]);
  useEffect(() => {
    updateTutorialHighlightLayout();
    const timer = setTimeout(() => {
      updateTutorialHighlightLayout();
    }, 300);
    return () => clearTimeout(timer);
  }, [updateTutorialHighlightLayout]);
  useEffect(() => {
    if (!tutorialHighlightActive) return;
    const frame = requestAnimationFrame(() => updateTutorialHighlightLayout());
    return () => cancelAnimationFrame(frame);
  }, [tutorialHighlightActive, tutorialHighlightMeasureTick, updateTutorialHighlightLayout]);
  useEffect(() => {
    if (!tutorialHighlightActive) return;
    const subscription = Dimensions.addEventListener("change", updateTutorialHighlightLayout);
    return () => {
      if (subscription?.remove) {
        subscription.remove();
      } else if (typeof subscription === "function") {
        subscription();
      }
    };
  }, [tutorialHighlightActive, updateTutorialHighlightLayout]);
  useEffect(() => {
    return () => {
      if (typeof onTutorialHighlightLayoutChange === "function") {
        onTutorialHighlightLayoutChange(null);
      }
    };
  }, [onTutorialHighlightLayoutChange]);
  const priceLabel = formatTemptationPriceLabel(item, currency);
  const highlight = true;
  const isDarkTheme = colors.background === THEMES.dark.background;
  const baseColor = item.color || colors.card;
  const focusActive = isFocusTarget && !showEditorInline;
  const darkCardPalette = highlight
    ? {
        background: blendColors(baseColor, "#2B1A00", 0.4),
        border: "#F6C16B",
        text: "#FFEED0",
        muted: "rgba(255,238,208,0.75)",
        badgeBg: "rgba(255,255,255,0.2)",
        badgeBorder: "rgba(255,255,255,0.32)",
        swipeBg: "rgba(255,255,255,0.08)",
        swipeBorder: "rgba(255,255,255,0.18)",
      }
    : {
        background: "#101526",
        border: "rgba(255,255,255,0.08)",
        text: colors.text,
        muted: colors.muted,
        badgeBg: "rgba(255,255,255,0.08)",
        badgeBorder: "rgba(255,255,255,0.18)",
        swipeBg: "rgba(255,255,255,0.04)",
        swipeBorder: "rgba(255,255,255,0.08)",
      };
  const baseCardBackground = isDarkTheme
    ? blendColors(colors.card, baseColor, 0.2)
    : baseColor;
  const cardBackground = baseCardBackground;
  const cardSurfaceColor = isDarkTheme
    ? blendColors(cardBackground, "#FFFFFF", 0.08)
    : lightenColor(cardBackground, 0.18);
  const primaryHighlightColor = Platform.OS === "ios" ? "#FF6F7D" : "#FF4D5A";
  const cardTextColor = isDarkTheme ? darkCardPalette.text : colors.text;
  const cardMutedColor = isDarkTheme ? darkCardPalette.muted : colors.muted;
  const resolvedGoalLabel =
    typeof goalLabel === "string" && goalLabel.trim().length ? goalLabel.trim() : "";
  const coinBurstColor = isDarkTheme ? "#FFD78B" : "#FFF4B3";
  const effectiveWishlistGoal = isWishlistGoal && !isPrimaryTemptation;
  const highlightPinned = effectiveWishlistGoal && !showEditorInline;
  const textureSeedSource = item.id || title || "";
  const textureSeed = textureSeedSource
    ? textureSeedSource.split("").reduce((acc, char) => acc + char.charCodeAt(0), 0)
    : 0;
  const textureVariant = textureSeed % CARD_TEXTURE_ACCENTS.length;
  const accentPaletteColor = CARD_TEXTURE_ACCENTS[textureVariant];
  const textureShift = (textureSeed % 7) * 0.02;
  const texturePrimaryColor = blendColors(
    cardBackground,
    isDarkTheme ? "#080808" : "#FFFFFF",
    isDarkTheme ? 0.12 + textureShift : 0.42 + textureShift * 0.5
  );
  const textureAccentColor = blendColors(
    cardBackground,
    isPrimaryTemptation ? "#FF6B8F" : highlightPinned ? "#FFD36E" : accentPaletteColor,
    isDarkTheme ? 0.25 + textureShift : 0.5 + textureShift * 0.5
  );
  const textureHighlightColor = blendColors(
    cardBackground,
    highlightPinned ? "#FFF6C8" : isPrimaryTemptation ? "#FF9FB0" : "#D9F2FF",
    isDarkTheme ? 0.18 : 0.32
  );
  const showCardTexture = false;
  const defaultShadowColor = isDarkTheme ? "rgba(255,255,255,0.55)" : "rgba(15,23,42,0.22)";
  const redShadowColor = Platform.OS === "ios" ? "rgba(244,37,78,0.6)" : "rgba(244,37,78,0.88)";
  const goldShadowColor = "rgba(255,198,110,0.75)";
  const focusShadowColor = "rgba(255,92,92,0.85)";
  const shadowColor = isPrimaryTemptation
    ? redShadowColor
    : focusActive
    ? focusShadowColor
    : highlightPinned
    ? goldShadowColor
    : defaultShadowColor;
  const shadowRadius = isPrimaryTemptation
    ? Platform.OS === "ios" ? 28 : 36
    : focusActive
    ? 34
    : highlightPinned
    ? 30
    : isDarkTheme
    ? 28
    : 22;
  const shadowOpacity = isPrimaryTemptation
    ? Platform.OS === "ios" ? 0.6 : 0.8
    : focusActive
    ? 0.75
    : highlightPinned
    ? 0.6
    : isDarkTheme
    ? 0.55
    : 0.3;
  const shadowElevation = isPrimaryTemptation ? 16 : focusActive ? 18 : highlightPinned ? 14 : isDarkTheme ? 12 : 8;
  const shadowOffsetHeight = isPrimaryTemptation
    ? Platform.OS === "ios" ? 12 : 18
    : focusActive
    ? 16
    : highlightPinned
    ? 16
    : isDarkTheme
    ? 14
    : 12;
  const baseCardShadowStyle = Platform.select({
    ios: {
      shadowColor,
      shadowOpacity,
      shadowRadius,
      shadowOffset: { width: 0, height: shadowOffsetHeight },
    },
    android: {
      elevation: shadowElevation,
      shadowColor,
    },
    default: {},
  });
  const cardShadowStyle = tutorialHighlightActive ? null : baseCardShadowStyle;
  const defaultGoalBadgeBackground = isDarkTheme ? "rgba(255,255,255,0.08)" : "rgba(0,0,0,0.04)";
  const defaultGoalBadgeBorder = isDarkTheme ? "rgba(255,255,255,0.24)" : "rgba(0,0,0,0.08)";
  const defaultGoalBadgeText = isDarkTheme ? "#FFF7E1" : colors.text;
  const hasGoalAssigned = !!resolvedGoalLabel;
  const refuseCount = stats?.count || 0;
  const totalRefusedLabel = formatCurrency(
    convertToCurrency(stats?.totalUSD || 0, currency),
    currency
  );
  const priceUSD = getTemptationPrice(item);
  const showThinkAction = allowThinkAction && priceUSD > 50;
  const actionConfig = [];
  if (showThinkAction) {
    actionConfig.push({ type: "maybe", label: t("maybeAction"), variant: "outline" });
  }
  actionConfig.push(
    { type: "save", label: t("saveAction"), variant: "primary" },
    { type: "spend", label: t("spendAction"), variant: "ghost" }
  );
  const interactionEntry = interaction || {};
  const frequencyId = interactionEntry.frequency || null;
  const timerReference = timerNow || Date.now();
  const lastInteractionAt = Number(interactionEntry.lastInteractionAt) || 0;
  const effectiveIntervalMs =
    Number(interactionEntry.intervalMs) ||
    (frequencyId ? getFrequencyIntervalMs(frequencyId) : null) ||
    (lastInteractionAt ? DAILY_FREQUENCY_INTERVAL_MS : null);
  const rawDueAt =
    Number(interactionEntry.nextCheckAt) ||
    (effectiveIntervalMs && lastInteractionAt ? lastInteractionAt + effectiveIntervalMs : null);
  const hasTimerSource = Number.isFinite(rawDueAt) && Boolean(lastInteractionAt);
  const timerExpired = hasTimerSource && rawDueAt <= timerReference;
  const timeRemaining = hasTimerSource ? rawDueAt - timerReference : null;
  const timerCritical =
    hasTimerSource &&
    !timerExpired &&
    Number.isFinite(timeRemaining) &&
    timeRemaining <= FREQUENCY_CRITICAL_WINDOW_MS;
  const timerDanger = timerExpired || timerCritical;
  const countdownLabel =
    hasTimerSource && !timerExpired
      ? formatFrequencyCountdown(rawDueAt - timerReference, language)
      : "";
  const timerLabel = hasTimerSource
    ? timerExpired
      ? t("frequencyTimerDue")
      : t("frequencyTimerLabel", { time: countdownLabel })
    : null;
  const currentStreak = Math.max(0, stats?.currentStreak || 0);
  const bestStreak = Math.max(stats?.bestStreak || 0, currentStreak);
  const streakLastAction = stats?.lastAction || null;
  const showStreakBadge = currentStreak > 0 || (bestStreak > 0 && streakLastAction === "spend");
  const streakActive = currentStreak > 0;
  const streakBadgeLabel = streakActive
    ? t("streakBadgeActive", { count: currentStreak })
    : t("streakBadgeBest", { count: bestStreak });
  const showStreakFire = streakActive && currentStreak >= 3;
  const streakGlowStyle = useMemo(() => {
    if (!showStreakFire) return null;
    if (Platform.OS === "ios") {
      return {
        shadowColor: "rgba(255,180,0,0.9)",
        shadowOpacity: 0.9,
        shadowRadius: shadowRadius + 10,
        shadowOffset: { width: 0, height: shadowOffsetHeight + 4 },
      };
    }
    return {
      elevation: Math.max(shadowElevation, 22),
      shadowColor: "#FFB347",
    };
  }, [showStreakFire, shadowElevation, shadowOffsetHeight, shadowRadius]);
  const [coinBursts, setCoinBursts] = useState([]);
  const messageActive = feedback?.message;
  const burstKey = feedback?.burstKey;
  const translateX = useRef(new Animated.Value(0)).current;
  const streakFireAnim = useRef(new Animated.Value(0)).current;
  const swipeActionRef = useRef(false);
  useEffect(() => {
    if (!showStreakFire) {
      streakFireAnim.stopAnimation?.();
      streakFireAnim.setValue(0);
      return;
    }
    const loop = Animated.loop(
      Animated.sequence([
        Animated.timing(streakFireAnim, {
          toValue: 1,
          duration: 520,
          easing: Easing.out(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(streakFireAnim, {
          toValue: 0,
          duration: 520,
          easing: Easing.in(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    loop.start();
    return () => {
      loop.stop();
      streakFireAnim.setValue(0);
    };
  }, [showStreakFire, streakFireAnim]);
  const streakFlameStyle = {
    transform: [
      {
        scale: streakFireAnim.interpolate({
          inputRange: [0, 1],
          outputRange: [1, 1.2],
        }),
      },
      {
        translateY: streakFireAnim.interpolate({
          inputRange: [0, 1],
          outputRange: [0, -3],
        }),
      },
      {
        rotate: streakFireAnim.interpolate({
          inputRange: [0, 1],
          outputRange: ["0deg", "8deg"],
        }),
      },
    ],
  };

  useEffect(() => {
    translateX.setValue(0);
  }, [item.id, translateX]);

  const handleSwipeRelease = useCallback(
    (dx = 0) => {
      if (!showEditorInline) {
        if (dx > GOAL_SWIPE_THRESHOLD && onQuickGoalToggle) {
          if (!canAssignGoal) {
            Alert.alert(t("tamagotchiName"), t("goalMainTemptationError"));
          } else {
            swipeActionRef.current = true;
            onQuickGoalToggle(item);
          }
        } else if (dx < -DELETE_SWIPE_THRESHOLD && onSwipeDelete) {
          swipeActionRef.current = true;
          onSwipeDelete(item);
        }
      }
      Animated.timing(translateX, {
        toValue: 0,
        duration: 160,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }).start();
    },
    [item, onQuickGoalToggle, onSwipeDelete, showEditorInline, translateX]
  );

  const panResponder = useMemo(
    () =>
      PanResponder.create({
        onStartShouldSetPanResponder: () => false,
        onMoveShouldSetPanResponder: (_, gestureState) =>
          !showEditorInline &&
          Math.abs(gestureState.dx) > Math.abs(gestureState.dy) &&
          Math.abs(gestureState.dx) > 6,
        onPanResponderGrant: () => {
          translateX.stopAnimation();
        },
        onPanResponderMove: (_, gestureState) => {
          if (showEditorInline) return;
          const dx = Math.max(Math.min(gestureState.dx, 150), -180);
          translateX.setValue(dx);
        },
        onPanResponderRelease: (_, gestureState) => {
          handleSwipeRelease(gestureState.dx);
        },
        onPanResponderTerminationRequest: () => false,
        onPanResponderTerminate: () => handleSwipeRelease(0),
      }),
    [handleSwipeRelease, showEditorInline, translateX]
  );

  useEffect(() => {
  }, [messageActive]);

  useEffect(() => {
    if (!burstKey) return;
    const coins = Array.from({ length: 5 }).map((_, index) => ({
      id: `${burstKey}-${index}`,
      progress: new Animated.Value(0),
      offsetX: (Math.random() - 0.5) * 80,
      rotation: (Math.random() > 0.5 ? 1 : -1) * (200 + Math.random() * 160),
      delay: index * 80,
    }));
    setCoinBursts(coins);
    coins.forEach((coin) => {
      Animated.timing(coin.progress, {
        toValue: 1,
        duration: 900,
        delay: coin.delay,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }).start();
    });
    const timeout = setTimeout(() => setCoinBursts([]), 1100);
    return () => clearTimeout(timeout);
  }, [burstKey]);

  const handleCardPress = useCallback(() => {
    if (swipeActionRef.current) {
      swipeActionRef.current = false;
      return;
    }
    onToggleEdit?.(item);
  }, [item, onToggleEdit]);

  return (
    <View style={styles.temptationSwipeWrapper}>
      <View
        style={[
          styles.temptationSwipeBackground,
          tutorialHighlightFrame && styles.temptationTutorialSwipeHint,
        ]}
        pointerEvents="none"
      >
        <View
          style={[
            styles.swipeHint,
            styles.swipeHintLeft,
            {
              borderColor: isDarkTheme ? "rgba(255,255,255,0.12)" : colors.border,
              backgroundColor: isDarkTheme ? "rgba(246,193,107,0.2)" : "rgba(246,193,107,0.12)",
            },
          ]}
        >
          <Text style={[styles.swipeHintIcon, { color: GOAL_HIGHLIGHT_COLOR }]}>ðŸŽ¯</Text>
          <Text style={[styles.swipeHintText, { color: GOAL_HIGHLIGHT_COLOR }]}>
            {isWishlistGoal ? t("goalAssignClear") : t("goalSwipeAdd")}
          </Text>
        </View>
        <View
          style={[
            styles.swipeHint,
            styles.swipeHintRight,
            {
              borderColor: isDarkTheme ? "rgba(255,255,255,0.12)" : colors.border,
              backgroundColor: isDarkTheme ? "rgba(255,87,115,0.15)" : "rgba(233,61,87,0.12)",
            },
          ]}
        >
          <Text style={[styles.swipeHintIcon, { color: "#E15555" }]}>ðŸ—‘ï¸</Text>
          <Text style={[styles.swipeHintText, { color: "#E15555" }]}>{t("goalSwipeDelete")}</Text>
        </View>
      </View>
    <Animated.View
      ref={tutorialHighlightCardRef}
      onLayout={handleTutorialCardLayout}
      {...panResponder.panHandlers}
      style={[
        styles.temptationCard,
        cardShadowStyle,
        cardStyle,
        streakGlowStyle,
          {
            backgroundColor: cardSurfaceColor,
            transform: [{ translateX }],
          },
        ]}
      >
        <TouchableWithoutFeedback onPress={handleCardPress}>
          <View>
            {showCardTexture && (
              <View pointerEvents="none" style={styles.temptationTextureContainer}>
                <View
                  style={[
                    styles.temptationTextureOverlay,
                    { backgroundColor: texturePrimaryColor, opacity: isDarkTheme ? 0.08 : 0.18 },
                  ]}
                />
                <View
                  style={[
                    styles.temptationTextureOverlay,
                    styles.temptationTextureAccent,
                    { backgroundColor: textureAccentColor },
                  ]}
                />
                <View
                  style={[
                    styles.temptationTextureOverlay,
                    styles.temptationTextureHighlight,
                    { backgroundColor: textureHighlightColor },
                  ]}
                />
              </View>
            )}
      <View
        style={[
          styles.temptationHeader,
          !showEditorInline && effectiveWishlistGoal && canAssignGoal ? { paddingRight: 64 } : null,
        ]}
      >
        {showEditorInline ? (
          <View style={styles.titleEditWrapper}>
            <View
              style={[
                styles.emojiEditWrapper,
                { borderColor: colors.border, backgroundColor: colors.card },
              ]}
            >
              <TextInput
                style={[styles.emojiEditInput, { color: colors.text }]}
                value={editEmojiValue ?? ""}
                onChangeText={onEditEmojiChange}
                placeholder={item.emoji || DEFAULT_TEMPTATION_EMOJI}
                placeholderTextColor={colors.muted}
                selectTextOnFocus
                maxLength={2}
              />
            </View>
            <View style={styles.titleEditInputContainer}>
              <TextInput
                style={[
                  styles.titleEditInput,
                  {
                    borderColor: colors.border,
                    color: colors.text,
                    backgroundColor: colors.card,
                  },
                ]}
                value={editTitleValue}
                onChangeText={onEditTitleChange}
                placeholder={t("priceEditNameLabel")}
                placeholderTextColor={colors.muted}
              />
            </View>
          </View>
        ) : (
          <>
            <View style={styles.emojiDisplayWrapper}>
              <Text style={[styles.temptationEmoji, { color: cardTextColor }]}>{item.emoji || "âœ¨"}</Text>
            </View>
            <Text style={[styles.temptationTitle, { color: cardTextColor }]}>{title}</Text>
          </>
        )}
      </View>
      {!showEditorInline && effectiveWishlistGoal && canAssignGoal && (
        <View style={styles.temptationBadgeStack} pointerEvents="none">
          {hasGoalAssigned && (
            <View
              style={[
                styles.temptationGoalBadge,
                styles.temptationGoalBadgeFloating,
                {
                  backgroundColor: isDarkTheme ? "#F6C16B22" : "#FFF2CC",
                  borderColor: isDarkTheme ? "#F6C16B55" : "#F6C16B",
                },
              ]}
            >
              <Text style={[styles.temptationGoalBadgeText, { color: isDarkTheme ? "#FEEAC4" : "#5C3A00" }]}>
                {t("goalPinnedBadge")}
              </Text>
            </View>
          )}
          {isWishlistGoal && (
            <View
              style={[
                styles.temptationPinnedBadge,
                {
                  borderColor: GOAL_HIGHLIGHT_COLOR,
                  backgroundColor: isDarkTheme ? "rgba(246,193,107,0.2)" : "rgba(246,193,107,0.12)",
                },
              ]}
            >
              <Text style={[styles.temptationPinnedBadgeText, { color: GOAL_HIGHLIGHT_COLOR }]}>
                {t("goalPinnedBadge")}
              </Text>
            </View>
          )}
        </View>
      )}
      {focusActive && (
        <TouchableOpacity
          style={[
            styles.temptationFocusBadge,
            {
              backgroundColor: isDarkTheme ? "rgba(255,92,92,0.15)" : "rgba(255,92,92,0.12)",
              borderColor: isDarkTheme ? "rgba(255,92,92,0.5)" : "rgba(255,92,92,0.45)",
            },
          ]}
          onPress={() => onFocusBadgePress?.(item)}
          activeOpacity={onFocusBadgePress ? 0.7 : 1}
        >
          <Text style={[styles.temptationFocusBadgeText, { color: isDarkTheme ? "#FFC0C0" : "#C2153B" }]}>
            {t("focusBadgeLabel")}
          </Text>
        </TouchableOpacity>
      )}
  {timerLabel && (
        <View
          style={[
            styles.temptationTimerBlock,
            {
              borderColor: timerDanger
                ? "rgba(194,21,59,0.6)"
                : isDarkTheme
                ? "rgba(255,255,255,0.15)"
                : "rgba(0,0,0,0.08)",
              backgroundColor: timerDanger
                ? "rgba(255,92,92,0.12)"
                : isDarkTheme
                ? "rgba(0,0,0,0.25)"
                : "rgba(255,255,255,0.7)",
            },
          ]}
        >
          {timerLabel ? (
            <Text
              style={[
                styles.temptationTimerCountdown,
                { color: timerDanger ? (isDarkTheme ? "#FF9AA5" : "#C2153B") : cardMutedColor },
              ]}
            >
              {timerLabel}
            </Text>
          ) : null}
        </View>
      )}
      {showStreakBadge && (
        <View style={styles.temptationStreakBadgeFloating} pointerEvents="none">
          <View
            style={[
              styles.temptationStreakBadge,
              {
                borderColor: streakActive
                  ? "#F6A218"
                  : colors.border,
                backgroundColor: streakActive
                  ? "#FFF6DB"
                  : colors.card,
              },
            ]}
          >
            {showStreakFire ? (
              <Animated.Text style={[styles.temptationStreakEmoji, streakFlameStyle]}>ðŸ”¥</Animated.Text>
            ) : (
              <Text style={[styles.temptationStreakEmoji, { color: streakActive ? "#FF8C1A" : colors.muted }]}>
                {streakActive ? "âœ¨" : "â³"}
              </Text>
            )}
            <Text
              style={[
                styles.temptationStreakText,
                { color: streakActive ? "#5C2F00" : colors.muted },
              ]}
            >
              {streakBadgeLabel}
            </Text>
          </View>
        </View>
      )}
      {showEditorInline ? (
        <TouchableOpacity
          style={[
            styles.temptationGoalBadge,
            styles.temptationGoalBadgeEditable,
            { borderColor: colors.border, backgroundColor: colors.card },
          ]}
          onPress={onEditGoalSelect}
        >
          <Text style={[styles.temptationGoalBadgeText, { color: colors.text }]}>
            {goalLabel || t("goalAssignFieldLabel")}
          </Text>
        </TouchableOpacity>
      ) : null}
      {showEditorInline ? (
        <View style={styles.descriptionEditWrapper}>
          <TextInput
            multiline
            style={[
              styles.descriptionEditInput,
              {
                borderColor: colors.border,
                color: colors.text,
                backgroundColor: colors.card,
              },
            ]}
            value={editDescriptionValue ?? ""}
            onChangeText={onEditDescriptionChange}
            placeholder={t("priceEditDescriptionLabel")}
            placeholderTextColor={colors.muted}
          />
        </View>
      ) : desc ? (
        <Text style={[styles.temptationDesc, { color: cardMutedColor }]}>
          {desc}
        </Text>
      ) : null}
  {refuseCount > 0 && (
        <Text style={[styles.temptationRefuseMeta, { color: cardMutedColor }]}>
          {t("tileRefuseCount", { count: refuseCount, amount: totalRefusedLabel })}
        </Text>
      )}
  <View style={styles.temptationPriceRow}>
    {showEditorInline ? (
      <View
        style={[
          styles.temptationPricePill,
          { borderColor: colors.border, backgroundColor: colors.card },
        ]}
      >
        <TextInput
          style={[
            styles.pricePillInput,
            { color: colors.text },
          ]}
          value={editPriceValue ?? ""}
          onChangeText={onEditPriceChange}
          keyboardType="decimal-pad"
          placeholder={t("priceEditAmountLabel", { currency })}
          placeholderTextColor={colors.muted}
        />
      </View>
    ) : (
      <>
        <Text
          style={[
            styles.temptationPrice,
            { color: cardTextColor },
          ]}
        >
          {priceLabel}
        </Text>
        {hasGoalAssigned && (
          <View
            style={[
              styles.temptationGoalBadge,
              styles.temptationGoalBadgeInline,
              {
                backgroundColor: isDarkTheme ? "rgba(246,193,107,0.18)" : "rgba(246,193,107,0.12)",
                borderColor: isDarkTheme ? "rgba(246,193,107,0.55)" : "rgba(246,193,107,0.65)",
              },
            ]}
          >
            <Text style={[styles.temptationGoalBadgeText, { color: isDarkTheme ? "#FEEAC4" : "#5C3A00" }]}>
              {t("goalDestinationLabel")}: {resolvedGoalLabel}
            </Text>
          </View>
        )}
      </>
    )}
  </View>
      {showEditorInline && (
        <View style={styles.categoryEditSection}>
          <Text style={[styles.categoryEditLabel, { color: colors.muted }]}>
            {t("impulseCategoryLabel")}
          </Text>
          <ImpulseCategorySelector
            value={editCategoryValue || DEFAULT_IMPULSE_CATEGORY}
            onChange={onEditCategoryChange}
            colors={colors}
            language={language}
            compact
          />
        </View>
      )}
          </View>
        </TouchableWithoutFeedback>
      {!showEditorInline && (
        <View
          style={[
            styles.temptationActions,
            tutorialHighlightActions && styles.temptationTutorialAccent,
          ]}
        >
        {actionConfig.map((action) => {
          let buttonStyle;
          let textStyle;
          if (action.type === "save") {
            buttonStyle = [
              styles.temptationButtonPrimary,
              { backgroundColor: SAVE_ACTION_COLOR, opacity: action.disabled ? 0.4 : 1 },
            ];
            textStyle = [styles.temptationButtonPrimaryText, { color: "#FFFFFF" }];
          } else if (action.type === "spend") {
            buttonStyle = [
              styles.temptationButtonGhost,
              { borderColor: SPEND_ACTION_COLOR, opacity: action.disabled ? 0.4 : 1 },
            ];
            textStyle = [styles.temptationButtonGhostText, { color: SPEND_ACTION_COLOR }];
          } else if (action.variant === "primary") {
            buttonStyle = [
              styles.temptationButtonPrimary,
              { backgroundColor: colors.text, opacity: action.disabled ? 0.35 : 1 },
            ];
            textStyle = [styles.temptationButtonPrimaryText, { color: colors.background }];
          } else if (action.variant === "ghost") {
            buttonStyle = [styles.temptationButtonGhost, { borderColor: colors.text }];
            textStyle = [styles.temptationButtonGhostText, { color: colors.text }];
          } else {
            buttonStyle = [
              styles.temptationButtonOutline,
              {
                borderColor: isDarkTheme ? "rgba(255,255,255,0.22)" : colors.border,
                backgroundColor: isDarkTheme ? "rgba(255,255,255,0.08)" : "transparent",
              },
            ];
            textStyle = [
              styles.temptationButtonOutlineText,
              { color: isDarkTheme ? colors.text : colors.muted },
            ];
          }
          if (tutorialHighlightThink && action.type === "maybe") {
            buttonStyle = [
              ...buttonStyle,
              styles.temptationTutorialAccentButton,
            ];
            textStyle = [
              styles.temptationButtonPrimaryText,
              { color: colors.text },
            ];
          }
          return (
            <TouchableOpacity
              key={action.type}
              style={buttonStyle}
              onPress={() => onAction(action.type, item)}
            >
              <Text style={textStyle}>{action.label}</Text>
            </TouchableOpacity>
          );
        })}
        </View>
      )}
      {coinBursts.map((coin) => {
        const translateY = coin.progress.interpolate({
          inputRange: [0, 1],
          outputRange: [0, -140],
        });
        const translateXCoin = coin.progress.interpolate({
          inputRange: [0, 1],
          outputRange: [0, coin.offsetX],
        });
        const rotate = coin.progress.interpolate({
          inputRange: [0, 1],
          outputRange: ["0deg", `${coin.rotation}deg`],
        });
        const scale = coin.progress.interpolate({
          inputRange: [0, 0.3, 1],
          outputRange: [0.3, 1, 0.6],
        });
        const opacity = coin.progress.interpolate({
          inputRange: [0, 0.6, 1],
          outputRange: [1, 1, 0],
        });
        return (
          <Animated.View
            key={coin.id}
            pointerEvents="none"
            style={[
              styles.coinBurst,
              {
                opacity,
                transform: [{ translateX: translateXCoin }, { translateY }, { rotate }, { scale }],
              },
            ]}
          >
            <View style={[styles.coinBurstInner, { backgroundColor: coinBurstColor }]} />
          </Animated.View>
        );
      })}
      {messageActive && null}
      {showEditorInline && isEditing && (
        <View style={[styles.temptationEditor, { borderTopColor: colors.border }]}>
          <View style={styles.temptationEditorActions}>
            <TouchableOpacity
              style={[styles.priceModalPrimary, { backgroundColor: colors.text }]}
              onPress={onEditSave}
            >
              <Text style={[styles.priceModalPrimaryText, { color: colors.background }]}>
                {t("priceEditSave")}
              </Text>
            </TouchableOpacity>
            <TouchableOpacity onPress={onEditCancel}>
              <Text style={[styles.priceModalCancel, { color: colors.muted }]}>
                {t("priceEditCancel")}
              </Text>
            </TouchableOpacity>
            <TouchableOpacity onPress={onEditDelete}>
              <Text style={[styles.priceModalDeleteText, { color: "#E15555" }]}>
                {t("priceEditDelete")}
              </Text>
            </TouchableOpacity>
          </View>
        </View>
      )}
      </Animated.View>
    </View>
  );
}

const TemptationCard = React.memo(TemptationCardComponent);

let cachedLevelBadgeLayout = { width: 0, height: 0, y: 0 };

const FrequencySectionHeader = ({ title, count, collapsed, onToggle, colors, t }) => {
  const arrowIcon = collapsed ? "â–¾" : "â–´";
  const toggleLabel = collapsed ? t("frequencyExpandLabel") : t("frequencyCollapseLabel");

  return (
    <TouchableOpacity
      onPress={onToggle}
      style={[
        styles.frequencySectionHeader,
        { borderColor: colors.border, backgroundColor: colors.card },
      ]}
      activeOpacity={0.9}
    >
      <View style={styles.frequencySectionHeaderText}>
        <Text style={[styles.frequencySectionTitle, { color: colors.text }]}>{title}</Text>
        <Text style={[styles.frequencySectionCount, { color: colors.muted }]}>{count}</Text>
      </View>
      <View style={styles.frequencySectionToggle}>
        <Text style={[styles.frequencySectionToggleLabel, { color: colors.text }]}>
          {toggleLabel}
        </Text>
        <Text style={[styles.frequencySectionToggleArrow, { color: colors.text }]}>{arrowIcon}</Text>
      </View>
    </TouchableOpacity>
  );
};

const DailyRewardButton = React.memo(
  function DailyRewardButton({
    visible = false,
    width = 0,
    height = 0,
    top = 0,
    unlocked = false,
    ready = false,
    amount = 0,
    label = "",
    buttonBg,
    buttonBorder,
    buttonShadow,
    buttonText,
    lockedBg,
    lockedBorder,
    lockedText,
    onPress,
  }) {
    if (!visible) return null;
    return (
      <TouchableOpacity
        style={[
          styles.dailyRewardButton,
          styles.dailyRewardFloating,
          {
            width,
            height,
            minHeight: height,
            minWidth: width,
            top,
            backgroundColor: unlocked ? buttonBg : lockedBg,
            borderColor: unlocked ? buttonBorder : lockedBorder,
            shadowColor: unlocked ? buttonShadow : "transparent",
            shadowOpacity: unlocked && ready ? 0.2 : 0,
            shadowOffset: { width: 0, height: unlocked && ready ? 3 : 0 },
            shadowRadius: unlocked && ready ? 4 : 0,
            elevation: unlocked && ready ? 1 : 0,
          },
        ]}
        hitSlop={{ top: 8, bottom: 8, left: 8, right: 8 }}
        pressRetentionOffset={{ top: 10, bottom: 10, left: 10, right: 10 }}
        activeOpacity={unlocked && ready ? 0.85 : 1}
        onPress={unlocked ? onPress : undefined}
        disabled={!unlocked || !ready}
      >
        {unlocked ? (
          <>
            <Image
              source={(getHealthCoinTierForAmount(amount) || HEALTH_COIN_TIERS[0]).asset}
              style={styles.dailyRewardCoin}
            />
            {ready && amount > 0 && (
              <Text
                style={[
                  styles.dailyRewardAmount,
                  { color: buttonText },
                ]}
              >
                {`+${amount}`}
              </Text>
            )}
            <Text
              style={[
                styles.dailyRewardCaption,
                { color: buttonText },
              ]}
              numberOfLines={1}
              adjustsFontSizeToFit
              minimumFontScale={0.7}
              ellipsizeMode="clip"
            >
              {label}
            </Text>
          </>
        ) : (
          <>
            <Text style={[styles.dailyRewardLockedIcon, { color: lockedText }]}>
              ðŸ”’
            </Text>
            <Text
              style={[styles.dailyRewardLockedLabel, { color: lockedText }]}
              numberOfLines={1}
              adjustsFontSizeToFit
              minimumFontScale={0.7}
            >
              {label}
            </Text>
          </>
        )}
      </TouchableOpacity>
    );
  },
  (prev, next) =>
    prev.visible === next.visible &&
    prev.width === next.width &&
    prev.height === next.height &&
    prev.top === next.top &&
    prev.unlocked === next.unlocked &&
    prev.ready === next.ready &&
    prev.amount === next.amount &&
    prev.label === next.label &&
    prev.buttonBg === next.buttonBg &&
    prev.buttonBorder === next.buttonBorder &&
    prev.buttonShadow === next.buttonShadow &&
    prev.buttonText === next.buttonText &&
    prev.lockedBg === next.lockedBg &&
    prev.lockedBorder === next.lockedBorder &&
    prev.lockedText === next.lockedText &&
    prev.onPress === next.onPress
);

function SavingsHeroCard({
  goldPalette,
  isDarkMode = false,
  heroSpendCopy,
  heroRecentEvents = [],
  heroEncouragementLine,
  onRecentEventsPress = null,
  levelLabel,
  playerLevel = null,
  totalSavedLabel,
  progressPercent,
  progressPercentLabel,
  goalProgressLabel,
  isGoalComplete = false,
  completionLabel,
  t,
  analyticsPreview = [],
  baselineMonthlyWasteUSD = 0,
  baselineStartAt = null,
  actualSavedUSD = 0,
  potentialGrowthUSD = 0,
  showPotentialGrowth = false,
  currency,
  hasBaseline = false,
  hasActiveGoal = true,
  onBaselineSetup = () => {},
  onPotentialDetailsOpen = null,
  levelHasNext = false,
  levelRemainingLabel = "",
  levelTargetLabel = "",
  levelProgressValue = 0,
  healthPoints = 0,
  onBreakdownPress = () => {},
  dailyRewardUnlocked = false,
  dailyRewardReady = false,
  dailyRewardAmount = 0,
  dailyRewardBaseAmount = 0,
  dailyRewardDay = 1,
  onDailyRewardClaim = () => {},
  onDailyRewardModalVisibilityChange = null,
  activeChallenge = null,
  onActiveChallengePress = () => {},
}) {
  const [expanded, setExpanded] = useState(false);
  const [levelExpanded, setLevelExpanded] = useState(false);
  const [levelBadgeLayout, setLevelBadgeLayout] = useState(() => cachedLevelBadgeLayout);
  const isLevelBadgeReady = levelBadgeLayout.width > 0 && levelBadgeLayout.height > 0;
  const [isDailyRewardModalVisible, setDailyRewardModalVisible] = useState(false);
  const potentialSavedUSD = useSavingsSimulation(
    baselineMonthlyWasteUSD,
    baselineStartAt
  );
  const setDailyRewardModalState = useCallback(
    (visible) => {
      setDailyRewardModalVisible(visible);
      if (typeof onDailyRewardModalVisibilityChange === "function") {
        onDailyRewardModalVisibilityChange(visible);
      }
    },
    [onDailyRewardModalVisibilityChange]
  );
  const [potentialLayoutReady, setPotentialLayoutReady] = useState(false);
  const potentialGrowthAnim = useRef(new Animated.Value(0)).current;
  const potentialGrowthPlayedRef = useRef(false);
  const potentialLocal = formatCurrency(convertToCurrency(potentialSavedUSD || 0, currency), currency, {
    precisionOverride: getCurrencyPrecision(currency),
  });
  const actualLocal = formatCurrency(convertToCurrency(actualSavedUSD || 0, currency), currency, {
    precisionOverride: getCurrencyPrecision(currency),
  });
  const potentialGrowthLabel = useMemo(() => {
    const value = Math.max(0, Number(potentialGrowthUSD) || 0);
    if (!Number.isFinite(value) || value <= 0) return "";
    return formatCurrency(convertToCurrency(value, currency), currency, {
      precisionOverride: getCurrencyPrecision(currency),
    });
  }, [currency, potentialGrowthUSD]);
  const coinEntries = useMemo(() => buildHealthCoinEntries(healthPoints), [healthPoints]);
  const hasCoinInventory = coinEntries.some((entry) => entry.count > 0);
  const potentialRatio = potentialSavedUSD > 0 ? Math.min(actualSavedUSD / potentialSavedUSD, 1) : 0;
  const missedUSD = Math.max(0, potentialSavedUSD - actualSavedUSD);
  const statusKey =
    actualSavedUSD > potentialSavedUSD
      ? "potentialBlockStatusAhead"
      : actualSavedUSD <= 0
      ? "potentialBlockStatusStart"
      : potentialRatio >= 0.8
      ? "potentialBlockStatusOnTrack"
      : "potentialBlockStatusBehind";
  const handlePotentialDetailsOpen = useCallback(() => {
    if (!hasBaseline) return;
    if (typeof onPotentialDetailsOpen === "function") {
      onPotentialDetailsOpen();
    }
  }, [hasBaseline, onPotentialDetailsOpen]);
  useEffect(() => {
    if (!showPotentialGrowth) {
      potentialGrowthPlayedRef.current = false;
      return;
    }
    if (!potentialGrowthLabel) return;
    if (potentialGrowthPlayedRef.current) return;
    if (!potentialLayoutReady) return;
    potentialGrowthPlayedRef.current = true;
    const task = InteractionManager.runAfterInteractions(() => {
      setTimeout(() => {
        requestAnimationFrame(() => {
          potentialGrowthAnim.setValue(0);
          Animated.sequence([
            Animated.timing(potentialGrowthAnim, {
              toValue: 1,
              duration: 260,
              useNativeDriver: true,
            }),
            Animated.timing(potentialGrowthAnim, {
              toValue: 0,
              duration: 240,
              useNativeDriver: true,
            }),
          ]).start();
        });
      });
    });
    return () => task?.cancel?.();
  }, [potentialGrowthAnim, potentialGrowthLabel, potentialLayoutReady, showPotentialGrowth]);
  const potentialGrowthScale = potentialGrowthAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [1, 1.22],
  });
  const potentialGrowthOpacity = potentialGrowthAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0.65, 1],
  });
  const dailyRewardPreview = useMemo(() => {
    const schedule = buildDailyRewardSchedule(dailyRewardBaseAmount || dailyRewardAmount);
    return schedule.map((amount, index) => ({
      day: index + 1,
      amount,
      isSuper: index + 1 === DAILY_REWARD_STREAK_LENGTH,
    }));
  }, [dailyRewardAmount, dailyRewardBaseAmount]);
  const rewardTileSize = useMemo(() => {
    const badgeWidth = levelBadgeLayout.width || 0;
    return Math.min(Math.max(badgeWidth, 68), 80);
  }, [levelBadgeLayout.width]);
  const rewardTileHeight = useMemo(
    () => Math.max(44, rewardTileSize - 28),
    [rewardTileSize]
  );
  const rewardTileTop = useMemo(
    () => (levelBadgeLayout.y || 0) + (levelBadgeLayout.height || 0) - 6,
    [levelBadgeLayout.height, levelBadgeLayout.y]
  );
  const handleLevelBadgeLayout = useCallback(
    (event) => {
      const layout = event?.nativeEvent?.layout;
      if (!layout) return;
      setLevelBadgeLayout((prev) => {
        if (
          prev.width === layout.width &&
          prev.height === layout.height &&
          prev.y === layout.y
        ) {
          return prev;
        }
        const next = { width: layout.width, height: layout.height, y: layout.y };
        cachedLevelBadgeLayout = next;
        return next;
      });
    },
    []
  );
  const dailyRewardButtonColors = dailyRewardReady
    ? isDarkMode
      ? {
          background: "rgba(255,214,143,0.32)",
          border: "rgba(255,214,143,0.85)",
          shadow: "rgba(255,214,143,0.55)",
          text: "#FFEED0",
        }
      : {
          background: "rgba(255,173,74,0.25)",
          border: "rgba(255,173,74,0.55)",
          shadow: "rgba(255,160,80,0.4)",
          text: "#6A390C",
      }
    : isDarkMode
    ? {
        background: "rgba(255,255,255,0.08)",
        border: "rgba(255,214,143,0.45)",
        shadow: "transparent",
        text: "rgba(255,238,208,0.75)",
      }
    : {
        background: "rgba(130,130,130,0.25)",
        border: "rgba(130,130,130,0.5)",
        shadow: "transparent",
        text: "rgba(90,90,90,0.9)",
      };
  const dailyRewardLockedColors = isDarkMode
    ? {
        background: "rgba(0,0,0,0.35)",
        border: "rgba(255,255,255,0.2)",
        text: "rgba(255,238,208,0.9)",
      }
    : {
        background: "rgba(255,255,255,0.72)",
        border: "rgba(90,90,90,0.18)",
        text: "rgba(90,90,90,0.85)",
      };
  const dailyRewardModalPalette = isDarkMode
    ? {
        background: "#3A2405",
        border: "rgba(255,214,143,0.7)",
        subtext: "rgba(255,238,208,0.92)",
        text: "#FFEED0",
      }
    : {
        background: goldPalette.background,
        border: goldPalette.border,
        subtext: goldPalette.subtext,
        text: goldPalette.text,
      };
  const dailyRewardActiveAccent = isDarkMode ? "#7BFFB8" : "#1F7A4F";
  const dailyRewardActiveBorder = isDarkMode ? "rgba(123,255,184,0.85)" : "rgba(45,166,106,0.9)";
  const dailyRewardActiveBg = isDarkMode ? "rgba(123,255,184,0.18)" : "rgba(45,166,106,0.14)";
  const dailyRewardLabel = dailyRewardReady ? t("dailyRewardClaimHint") : t("dailyRewardCollectedLabel");
  const dailyRewardUnlockLevel = FEATURE_UNLOCK_LEVELS.rewardsDaily || 2;
  const dailyRewardLockedLabel = t("progressHeroLevel", { level: dailyRewardUnlockLevel });
  const handleDailyRewardPress = useCallback(() => {
    if (!dailyRewardReady) return;
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    const day = Math.min(DAILY_REWARD_STREAK_LENGTH, Math.max(1, dailyRewardDay || 1));
    logEvent("daily_reward_opened", {
      coins: dailyRewardAmount,
      day,
      level: playerLevel,
    });
    setDailyRewardModalState(true);
  }, [
    dailyRewardAmount,
    dailyRewardDay,
    dailyRewardReady,
    playerLevel,
    setDailyRewardModalState,
    triggerHaptic,
  ]);
  const handleDailyRewardCollect = useCallback(() => {
    if (!dailyRewardReady) {
      setDailyRewardModalState(false);
      return;
    }
    triggerSuccessHaptic();
    setDailyRewardModalState(false);
    onDailyRewardClaim?.();
  }, [dailyRewardReady, onDailyRewardClaim, setDailyRewardModalState, triggerSuccessHaptic]);
  const activeDailyRewardDay = dailyRewardReady
    ? Math.min(DAILY_REWARD_STREAK_LENGTH, Math.max(1, dailyRewardDay || 1))
    : null;
  const activeChallengeCount = activeChallenge?.targetValue || 0;
  const activeChallengeProgress = activeChallenge?.progressValue || 0;
  const showActiveChallenge =
    activeChallenge && activeChallenge.status === "active" && activeChallengeProgress > 0;
  const activeChallengePercent =
    activeChallenge && activeChallenge.targetValue
      ? Math.min(activeChallengeProgress / activeChallenge.targetValue, 1)
      : 0;
  const RecentEventsWrap = onRecentEventsPress ? TouchableOpacity : View;
  return (
    <View
      style={[
        styles.progressHeroCard,
        styles.savedHeroCard,
        {
          backgroundColor: goldPalette.background,
          borderColor: goldPalette.border,
          shadowColor: goldPalette.shadow,
        },
      ]}
    >
      <View pointerEvents="none" style={styles.savedHeroGlowWrap}>
        <View style={[styles.savedHeroGlow, { backgroundColor: goldPalette.glow }]} />
        <View
          style={[
            styles.savedHeroGlow,
            styles.savedHeroGlowBottom,
            { backgroundColor: goldPalette.glow },
          ]}
        />
      </View>
      <View style={styles.savedHeroContent}>
        <View style={styles.savedHeroHeader}>
          <View style={styles.savedHeroTitleWrap}>
            <Text style={[styles.progressHeroTitle, { color: goldPalette.text }]}>
              {t("progressHeroTitle")}
            </Text>
          </View>
          <TouchableOpacity
            style={styles.savedHeroLevelButton}
            hitSlop={{ top: 12, bottom: 12, left: 12, right: 12 }}
            activeOpacity={0.85}
            onPress={() => setLevelExpanded((prev) => !prev)}
          >
            <View
              onLayout={handleLevelBadgeLayout}
              style={[
                styles.savedHeroLevelBadge,
                {
                  backgroundColor: goldPalette.badgeBg,
                  borderColor: goldPalette.badgeBorder,
                },
              ]}
            >
              <Text style={[styles.savedHeroLevelText, { color: goldPalette.badgeText }]}>{levelLabel}</Text>
            </View>
          </TouchableOpacity>
        </View>
        <DailyRewardButton
          visible={!levelExpanded && isLevelBadgeReady}
          width={rewardTileSize}
          height={rewardTileHeight}
          top={rewardTileTop}
          unlocked={dailyRewardUnlocked}
          ready={dailyRewardReady}
          amount={dailyRewardAmount}
          label={dailyRewardUnlocked ? dailyRewardLabel : dailyRewardLockedLabel}
          buttonBg={dailyRewardButtonColors.background}
          buttonBorder={dailyRewardButtonColors.border}
          buttonShadow={dailyRewardButtonColors.shadow}
          buttonText={dailyRewardButtonColors.text}
          lockedBg={dailyRewardLockedColors.background}
          lockedBorder={dailyRewardLockedColors.border}
          lockedText={dailyRewardLockedColors.text}
          onPress={handleDailyRewardPress}
        />
        {levelExpanded && (
          <View
            style={[
              styles.heroLevelDetails,
              {
                backgroundColor: goldPalette.badgeBg,
                borderColor: goldPalette.badgeBorder,
              },
            ]}
          >
            <Text style={[styles.heroLevelTitle, { color: goldPalette.text }]}>
              {t("levelWidgetTitle")}
            </Text>
            <Text style={[styles.heroLevelSubtitle, { color: goldPalette.subtext }]}>
              {levelHasNext
                ? t("levelWidgetSubtitle", { amount: levelRemainingLabel })
                : t("levelWidgetMaxed")}
            </Text>
            <View style={[styles.levelWidgetBar, { backgroundColor: goldPalette.barBg }]}>
              <View
                style={[
                  styles.levelWidgetFill,
                  { backgroundColor: goldPalette.accent, width: `${Math.min(Math.max(levelProgressValue, 0), 1) * 100}%` },
                ]}
              />
            </View>
          </View>
        )}
        <View style={styles.savedHeroAmountWrap}>
          <Text style={[styles.progressHeroAmount, { color: goldPalette.text }]}>
            {totalSavedLabel}
          </Text>
        </View>
        {heroRecentEvents.length > 0 ? (
          <RecentEventsWrap
            style={styles.savedHeroRecentList}
            {...(onRecentEventsPress ? { activeOpacity: 0.85, onPress: onRecentEventsPress } : {})}
          >
            <Text style={[styles.savedHeroRecentTitle, { color: goldPalette.subtext }]}>
              {t("heroSpendRecentTitle")}
            </Text>
            {heroRecentEvents.map((entry) => (
              <Text
                key={entry.id}
                style={[
                  styles.savedHeroRecentItem,
                  { color: entry.isSpend ? goldPalette.danger : goldPalette.subtext },
                ]}
                numberOfLines={1}
                ellipsizeMode="tail"
              >
                {entry.label}
              </Text>
            ))}
          </RecentEventsWrap>
        ) : (
          <Text style={[styles.savedHeroSubtitle, { color: goldPalette.subtext }]}>
            {heroSpendCopy || heroEncouragementLine}
          </Text>
        )}

      {hasActiveGoal && (
        <View style={styles.savedHeroProgressRow}>
          <View
            style={[
              styles.progressHeroBar,
              styles.savedHeroBar,
              { backgroundColor: goldPalette.barBg },
            ]}
          >
            <View
              style={[
                styles.progressHeroFill,
                { backgroundColor: goldPalette.accent, width: `${progressPercent * 100}%` },
              ]}
            />
          </View>
          <View
            style={[
              styles.savedHeroPercentTag,
              { backgroundColor: goldPalette.badgeBg, borderColor: goldPalette.border },
            ]}
          >
            <Text style={[styles.savedHeroPercentText, { color: goldPalette.text }]}>
              {progressPercentLabel}%
            </Text>
          </View>
        </View>
      )}
      <View style={styles.savedHeroGoalRow}>
        <Text style={[styles.goalLabel, { color: goldPalette.subtext }]}>
          {hasActiveGoal ? t("goalWidgetTitle") : t("heroDailyTitle")}
        </Text>
      </View>
      {hasActiveGoal && (
        <View style={styles.savedHeroGoalMetaRow}>
          <Text style={[styles.savedHeroGoalLabel, { color: goldPalette.subtext }]}>{goalProgressLabel}</Text>
          {isGoalComplete && (
            <View
              style={[
                styles.goalCompleteBadge,
                { backgroundColor: goldPalette.badgeBg, borderColor: goldPalette.badgeBorder },
              ]}
            >
              <Text style={[styles.goalCompleteBadgeText, { color: goldPalette.badgeText }]}>
                {completionLabel}
              </Text>
            </View>
          )}
        </View>
      )}
      <TouchableOpacity
        style={[
          styles.heroPotentialCard,
          {
            backgroundColor: goldPalette.badgeBg,
            borderColor: goldPalette.badgeBorder,
          },
        ]}
        activeOpacity={0.9}
        onPress={handlePotentialDetailsOpen}
        onLayout={() => {
          if (!potentialLayoutReady) setPotentialLayoutReady(true);
        }}
      >
        {hasBaseline ? (
          <>
            <View style={styles.heroPotentialHeader}>
              <View style={styles.heroPotentialRow}>
                <Text style={[styles.heroPotentialLabel, { color: goldPalette.text }]}>
                  {t("potentialBlockTitle")}
                </Text>
                <Text style={[styles.heroPotentialValue, { color: goldPalette.text }]}>
                  {potentialLocal}
                </Text>
              </View>
              <View style={styles.heroPotentialRow}>
                <Text style={[styles.heroPotentialStatus, { color: goldPalette.subtext }]}>
                  {t(statusKey)}
                </Text>
                {showPotentialGrowth && potentialGrowthLabel ? (
                  <Animated.Text
                    style={[
                      styles.heroPotentialDelta,
                      {
                        color: SAVE_ACTION_COLOR,
                        transform: [{ scale: potentialGrowthScale }],
                        opacity: potentialGrowthOpacity,
                      },
                    ]}
                  >
                    {`+${potentialGrowthLabel}`}
                  </Animated.Text>
                ) : null}
              </View>
            </View>
          </>
        ) : (
          <>
            <Text style={[styles.heroPotentialBody, { color: goldPalette.text }]}>
              {t("potentialBlockCta")}
            </Text>
            <TouchableOpacity
              style={[
                styles.heroPotentialButton,
                {
                  borderColor: goldPalette.text,
                },
              ]}
              activeOpacity={0.85}
              onPress={onBaselineSetup}
            >
              <Text style={[styles.heroPotentialButtonText, { color: goldPalette.text }]}>
                {t("baselineCTA")}
              </Text>
            </TouchableOpacity>
          </>
        )}
      </TouchableOpacity>
      {showActiveChallenge && (
        <TouchableOpacity
          activeOpacity={0.9}
          onPress={() => onActiveChallengePress?.(activeChallenge.id)}
          style={[
            styles.heroChallengeBlock,
            { backgroundColor: goldPalette.badgeBg, borderColor: goldPalette.badgeBorder },
          ]}
        >
          <View style={styles.heroChallengeRow}>
            <View style={styles.heroChallengeTitleRow}>
              <Text style={styles.heroChallengeEmoji}>{activeChallenge.emoji}</Text>
              <Text style={[styles.heroChallengeName, { color: goldPalette.text }]} numberOfLines={1}>
                {activeChallenge.title}
              </Text>
            </View>
            <Text style={[styles.heroChallengeMeta, { color: goldPalette.subtext }]}>
              {activeChallenge.timerLabel}
            </Text>
          </View>
          <View style={styles.heroChallengeProgressRow}>
            <View style={[styles.heroChallengeBar, { backgroundColor: goldPalette.barBg }]}>
              <View
                style={[
                  styles.heroChallengeFill,
                  { backgroundColor: goldPalette.accent, width: `${activeChallengePercent * 100}%` },
                ]}
              />
            </View>
            <Text style={[styles.heroChallengeLabel, { color: goldPalette.subtext }]}>
              {activeChallenge.progressLabel}
            </Text>
          </View>
        </TouchableOpacity>
      )}
      {expanded && (
        <TouchableOpacity
          activeOpacity={0.9}
          onPress={onBreakdownPress}
          style={styles.savedHeroExpanded}
        >
          <View
            style={[
              styles.savedHeroCoinsCard,
              { backgroundColor: goldPalette.badgeBg, borderColor: goldPalette.badgeBorder },
            ]}
          >
            <View style={styles.savedHeroCoinsText}>
              <Text style={[styles.savedHeroCoinsLabel, { color: goldPalette.text }]}>
                {t("freeDayHealthTitle")}
              </Text>
              <Text style={[styles.savedHeroCoinsSubtitle, { color: goldPalette.subtext }]}>
                {t("freeDayHealthSubtitle")}
              </Text>
              {hasCoinInventory && (
                <View style={styles.freeDayCoinRow}>
                  {coinEntries.map((entry) =>
                    entry.count ? (
                      <View
                        key={entry.id}
                        style={[
                          styles.freeDayCoinBadge,
                          { borderColor: goldPalette.border, backgroundColor: goldPalette.background },
                        ]}
                      >
                        <Image source={entry.asset} style={styles.freeDayCoinImage} />
                        <Text style={[styles.freeDayCoinCount, { color: goldPalette.text }]}>Ã—{entry.count}</Text>
                      </View>
                    ) : null
                  )}
                </View>
              )}
            </View>
            <Text style={[styles.savedHeroCoinsValue, { color: goldPalette.accent }]}>
              {healthPoints}
            </Text>
          </View>

          <View style={styles.savedHeroDaily}>
            <Text style={[styles.savedHeroDailyTitle, { color: goldPalette.text }]}>
              {t("heroDailyTitle")}
            </Text>
            {analyticsPreview.length > 0 && (
              <View style={styles.savedHeroStatsRow}>
                {analyticsPreview.map((stat) => (
                  <View
                    key={stat.label}
                    style={[
                      styles.savedHeroStatsItem,
                      { backgroundColor: goldPalette.background, borderColor: goldPalette.border },
                    ]}
                  >
                    <Text style={[styles.savedHeroStatsValue, { color: goldPalette.text }]}>
                      {stat.value}
                    </Text>
                    <Text style={[styles.savedHeroStatsLabel, { color: goldPalette.subtext }]}>
                      {stat.label}
                    </Text>
                  </View>
                ))}
              </View>
            )}
          </View>
        </TouchableOpacity>
      )}
      <View style={styles.savedHeroToggleRow}>
        <TouchableOpacity
          style={styles.savedHeroToggleButton}
          onPress={() =>
            setExpanded((prev) => {
              const next = !prev;
              logEvent("hero_show_more_toggled", { expanded: next ? 1 : 0 });
              if (next) {
                logEvent("stats_screen_viewed", { tab: "feed" });
              }
              return next;
            })
          }
        >
          <Text style={[styles.savedHeroToggleText, { color: goldPalette.subtext }]}>
            {expanded ? t("heroCollapse") : t("heroExpand")}
          </Text>
        </TouchableOpacity>
      </View>
      <Modal
        visible={isDailyRewardModalVisible}
        transparent
        animationType="fade"
        statusBarTranslucent
        onRequestClose={() => setDailyRewardModalState(false)}
      >
        <TouchableWithoutFeedback onPress={() => setDailyRewardModalState(false)}>
          <View
            style={[
              styles.dailyRewardModalBackdrop,
              { backgroundColor: isDarkMode ? "rgba(0,0,0,0.55)" : "rgba(0,0,0,0.35)" },
            ]}
          />
        </TouchableWithoutFeedback>
        <View style={styles.dailyRewardModalWrap} pointerEvents="box-none">
          <View
            style={[
              styles.dailyRewardModalCard,
              {
                backgroundColor: dailyRewardModalPalette.background,
                borderColor: dailyRewardModalPalette.border,
              },
            ]}
          >
            <Text style={[styles.dailyRewardModalTitle, { color: dailyRewardModalPalette.text }]}>
              {t("dailyRewardModalTitle")}
            </Text>
            <Text
              style={[
                styles.dailyRewardModalSubtitle,
                { color: dailyRewardModalPalette.subtext },
              ]}
            >
              {t("dailyRewardModalDescription")}
            </Text>
            <View style={styles.dailyRewardCalendar}>
              {dailyRewardPreview.map((entry) => {
                const isActive = entry.day === activeDailyRewardDay;
                const isSuper = entry.isSuper;
                const dayBg = isSuper ? "rgba(255,214,143,0.2)" : goldPalette.badgeBg;
                const dayBorder = isSuper ? "rgba(255,171,64,0.85)" : goldPalette.border;
                const superDayStyle = isSuper
                  ? { minWidth: 72, maxWidth: 88, width: 80 }
                  : null;
                return (
                  <View
                    key={entry.day}
                    style={[
                      styles.dailyRewardCalendarDay,
                      superDayStyle,
                      {
                        backgroundColor: isActive ? dailyRewardActiveBg : dayBg,
                        borderWidth: isActive ? 1.5 : 1,
                        borderColor: isActive ? dailyRewardActiveBorder : dayBorder,
                      },
                    ]}
                  >
                    <Text
                      style={[
                        styles.dailyRewardCalendarDayLabel,
                        { color: isActive ? dailyRewardActiveAccent : dailyRewardModalPalette.subtext },
                      ]}
                      numberOfLines={1}
                    >
                      {t("dailyRewardModalDayLabel", { day: entry.day })}
                    </Text>
                    <Text
                      style={[
                        styles.dailyRewardCalendarAmount,
                        { color: isActive ? dailyRewardActiveAccent : dailyRewardModalPalette.text },
                      ]}
                    >
                      +{entry.amount}
                    </Text>
                    {isSuper && (
                      <Text
                        style={[
                          styles.dailyRewardCalendarSuperLabel,
                          { color: isActive ? dailyRewardActiveAccent : dailyRewardModalPalette.text },
                        ]}
                      >
                        {t("dailyRewardSuperLabel")}
                      </Text>
                    )}
                  </View>
                );
              })}
            </View>
            <Text style={[styles.dailyRewardModalNote, { color: dailyRewardModalPalette.subtext }]}>
              {t("dailyRewardModalGrowthNote")}
            </Text>
            <View style={styles.dailyRewardModalActions}>
              <TouchableOpacity
                style={[
                  styles.dailyRewardModalSecondary,
                  { borderColor: dailyRewardModalPalette.border },
                ]}
                onPress={() => setDailyRewardModalVisible(false)}
                activeOpacity={0.85}
              >
                <Text style={[styles.dailyRewardModalSecondaryText, { color: dailyRewardModalPalette.text }]}>
                  {t("dailyRewardModalLater")}
                </Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.dailyRewardModalPrimary, { backgroundColor: goldPalette.accent }]}
                onPress={handleDailyRewardCollect}
                activeOpacity={0.9}
              >
                <Text style={[styles.dailyRewardModalPrimaryText, { color: "#fff" }]}>
                  {t("dailyRewardModalCTA")}
                </Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
      </View>
    </View>
  );
}

const resolveFeatureUnlockCopy = (variantKey, t) => {
  const config = FEATURE_UNLOCK_VARIANT_CONFIG[variantKey];
  if (!config) {
    return { title: "", description: "" };
  }
  return {
    title: t(config.titleKey),
    description: t(config.descriptionKey),
  };
};

const LockedFeatureOverlay = ({
  locked,
  variantKey,
  level,
  colors,
  t,
  style,
  contentStyle,
  borderRadius = 20,
  blurIntensity = 18,
  compact = false,
  centered = false,
  children,
}) => {
  if (!locked) {
    return <View style={style}>{children}</View>;
  }
  const { title, description } = resolveFeatureUnlockCopy(variantKey, t);
  const unlockLevel = Number(level) || FEATURE_UNLOCK_LEVELS[variantKey] || null;
  const isDarkMode = colors?.background === THEMES.dark.background;
  const textColor = isDarkMode ? "#F7F2E6" : "#2A1C00";
  const subTextColor = isDarkMode ? "rgba(247,242,230,0.8)" : "rgba(42,28,0,0.7)";
  const badgeBg = isDarkMode ? "rgba(0,0,0,0.35)" : "rgba(255,255,255,0.8)";
  const badgeBorder = isDarkMode ? "rgba(255,255,255,0.2)" : "rgba(0,0,0,0.1)";
  const overlayScrim = isDarkMode
    ? Platform.OS === "android"
      ? "rgba(5,5,5,0.38)"
      : "rgba(5,5,5,0.58)"
    : Platform.OS === "android"
    ? "rgba(255,255,255,0.35)"
    : "rgba(255,255,255,0.7)";
  const radiusStyle = Number.isFinite(borderRadius) ? { borderRadius } : null;
  const compactOverlayStyle = compact ? styles.lockedFeatureOverlayCompact : null;
  const compactContentStyle = compact ? styles.lockedFeatureOverlayContentCompact : null;
  const compactTitleStyle = compact ? styles.lockedFeatureTitleCompact : null;
  const compactDescriptionStyle = compact ? styles.lockedFeatureDescriptionCompact : null;
  const compactBadgeStyle = compact ? styles.lockedFeatureLevelBadgeCompact : null;
  const compactBadgeTextStyle = compact ? styles.lockedFeatureLevelTextCompact : null;
  const compactLockStyle = compact ? styles.lockedFeatureLockIconCompact : null;
  const centeredOverlayStyle = centered ? styles.lockedFeatureOverlayCentered : null;
  const centeredContentStyle = centered ? styles.lockedFeatureOverlayContentCentered : null;
  const centeredTitleStyle = centered ? styles.lockedFeatureTitleCentered : null;
  const centeredDescriptionStyle = centered ? styles.lockedFeatureDescriptionCentered : null;
  const centeredLockRowStyle = centered ? styles.lockedFeatureLockRowCentered : null;
  const centeredBadgeStyle = centered ? styles.lockedFeatureLevelBadgeCentered : null;
  const centeredLockStyle = centered ? styles.lockedFeatureLockIconCentered : null;
  const blurAvailable = useMemo(() => isBlurViewAvailable(), []);
  const androidBlurAmount = Math.max(2, Math.round((Number(blurIntensity) || 0) * 0.3));
  const blurIntensityValue = Platform.OS === "android" ? androidBlurAmount : blurIntensity;
  const androidBlurFallback = isDarkMode ? "#0B0B0B" : "#F2F2F2";
  return (
    <View style={[styles.lockedFeatureWrap, radiusStyle, style]}>
      <View style={contentStyle} pointerEvents="none">
        {children}
      </View>
        <View
          style={[styles.lockedFeatureOverlay, radiusStyle, compactOverlayStyle, centeredOverlayStyle]}
          pointerEvents="auto"
        >
          {blurAvailable ? (
            Platform.OS === "android" && AndroidBlurView ? (
              <AndroidBlurView
                blurType={isDarkMode ? "dark" : "light"}
                blurAmount={androidBlurAmount}
                reducedTransparencyFallbackColor={androidBlurFallback}
                style={[StyleSheet.absoluteFill, styles.lockedFeatureBlur, radiusStyle]}
              />
            ) : (
              <ExpoBlurView
                tint={isDarkMode ? "dark" : "light"}
                intensity={blurIntensityValue}
                experimentalBlurMethod={Platform.OS === "android" ? "dimezisBlurView" : undefined}
                style={[StyleSheet.absoluteFill, styles.lockedFeatureBlur, radiusStyle]}
              />
            )
          ) : null}
          <View
            style={[styles.lockedFeatureScrim, styles.lockedFeatureBlur, radiusStyle, { backgroundColor: overlayScrim }]}
          />
          <View style={[styles.lockedFeatureOverlayContent, compactContentStyle, centeredContentStyle]}>
          <View style={[styles.lockedFeatureLockRow, centeredLockRowStyle]}>
            <Text style={[styles.lockedFeatureLockIcon, compactLockStyle, centeredLockStyle, { color: textColor }]}>ðŸ”’</Text>
          </View>
          <Text
            style={[
              styles.lockedFeatureTitle,
              compactTitleStyle,
              centeredTitleStyle,
              { color: textColor },
            ]}
            numberOfLines={compact ? 2 : undefined}
          >
            {title}
          </Text>
          <Text
            style={[
              styles.lockedFeatureDescription,
              compactDescriptionStyle,
              centeredDescriptionStyle,
              { color: subTextColor },
            ]}
            numberOfLines={compact ? 3 : undefined}
          >
            {description}
          </Text>
          {unlockLevel ? (
            <View
              style={[
                styles.lockedFeatureLevelBadge,
                compactBadgeStyle,
                centeredBadgeStyle,
                { backgroundColor: badgeBg, borderColor: badgeBorder },
              ]}
            >
              <Text style={[styles.lockedFeatureLevelText, compactBadgeTextStyle, { color: textColor }]}>
                {t("featureLockedLevelLabel", { level: unlockLevel })}
              </Text>
            </View>
          ) : null}
        </View>
      </View>
    </View>
  );
};

const LockedFeatureCard = ({
  variantKey,
  level,
  colors,
  t,
  style,
  compact = false,
  square = false,
  minHeight = null,
  blurIntensity = 18,
}) => {
  const baseLineColor = colors?.border || "rgba(0,0,0,0.12)";
  const placeholderStyle = compact ? styles.lockedFeaturePlaceholderCompact : styles.lockedFeaturePlaceholder;
  const squareStyle = square ? styles.lockedFeaturePlaceholderSquare : null;
  const sizeStyle = Number.isFinite(minHeight) ? { minHeight } : null;
  return (
    <LockedFeatureOverlay
      locked
      variantKey={variantKey}
      level={level}
      colors={colors}
      t={t}
      style={style}
      blurIntensity={blurIntensity}
      compact={compact}
    >
      <View
        style={[
          placeholderStyle,
          squareStyle,
          sizeStyle,
          { backgroundColor: colors?.card, borderColor: colors?.border },
        ]}
      >
        <View style={[styles.lockedFeaturePlaceholderLine, { width: "62%", backgroundColor: baseLineColor }]} />
        <View style={[styles.lockedFeaturePlaceholderLine, { width: "92%", backgroundColor: baseLineColor }]} />
        <View style={[styles.lockedFeaturePlaceholderLine, { width: "76%", backgroundColor: baseLineColor }]} />
      </View>
    </LockedFeatureOverlay>
  );
};

function FreeDayCard({
  colors,
  t,
  canLog,
  onLog,
  freeDayStats = INITIAL_FREE_DAY_STATS,
  todayKey,
  weekDays = [],
  weekCount = 0,
  canRescue = false,
  needsRescue = false,
  rescueStatus = null,
  rescueCost = FREE_DAY_RESCUE_COST,
  onRescue = () => {},
  hasRescueHealth = false,
}) {
  const [expanded, setExpanded] = useState(false);
  const streakActive = (freeDayStats.current || 0) > 0;
  const blockedToday = freeDayStats.blockedDate === todayKey;
  const palette = streakActive
    ? {
        background: "#E6F8EE",
        border: "#A8E5C5",
        accent: "#105B31",
      }
    : {
        background: colors.card,
        border: colors.border,
        accent: colors.text,
      };
  const buttonColor = streakActive ? palette.accent : "#20A36B";
  const statusLabel = canLog
    ? t("freeDayStatusAvailable")
    : freeDayStats.lastDate === todayKey
    ? t("freeDayStatusLogged")
    : blockedToday
    ? t("freeDayBlocked")
    : t("freeDayLocked");
  const stats = [
    { label: t("freeDayCurrentLabel"), value: `${freeDayStats.current || 0}` },
    { label: t("freeDayBestLabel"), value: `${freeDayStats.best || 0}` },
    { label: t("freeDayTotalShort"), value: `${freeDayStats.total || 0}` },
  ];
  const showRescueStatusAction = needsRescue && !canLog;
  const rescuePillDisabled = !hasRescueHealth;
  const rescuePillColor = "#FFD75E";
  const rescuePillTextColor = "#3C2A00";
  return (
    <View
      style={[
        styles.freeDayCard,
        {
          backgroundColor: palette.background,
          borderColor: palette.border,
        },
      ]}
    >
      <View style={styles.freeDayHeader}>
        <View style={styles.freeDayTitleBlock}>
          <Text style={[styles.freeDayLabel, { color: colors.text }]}>{t("freeDayCardTitle")}</Text>
        </View>
        {showRescueStatusAction ? (
          <TouchableOpacity
            style={[
              styles.freeDayStatusPill,
              { backgroundColor: rescuePillColor, borderColor: rescuePillColor },
              rescuePillDisabled && styles.freeDayStatusPillDisabled,
            ]}
            onPress={onRescue}
            disabled={rescuePillDisabled}
            activeOpacity={0.85}
          >
            <Text style={[styles.freeDayStatusText, { color: rescuePillTextColor }]}>
              {t("freeDayRescuePillLabel", { count: "1" })}
            </Text>
            {BLUE_HEALTH_COIN_ASSET ? (
              <Image source={BLUE_HEALTH_COIN_ASSET} style={styles.freeDayStatusCoin} />
            ) : null}
          </TouchableOpacity>
        ) : canLog ? (
          <TouchableOpacity
            style={[
              styles.freeDayStatusPill,
              { backgroundColor: buttonColor, borderColor: buttonColor },
            ]}
            onPress={onLog}
            activeOpacity={0.85}
          >
            <Text style={[styles.freeDayStatusText, { color: "#fff" }]}>{statusLabel}</Text>
          </TouchableOpacity>
        ) : (
          <View
            style={[
              styles.freeDayStatusPill,
              {
                borderColor: colors.border,
                backgroundColor: colors.background,
              },
            ]}
          >
            <Text style={[styles.freeDayStatusText, { color: colors.muted }]}>{statusLabel}</Text>
          </View>
        )}
      </View>
      <View style={styles.freeDaySummaryRow}>
        <View style={styles.freeDayChip}>
          <Text style={[styles.freeDayChipText, { color: palette.accent }]}>
            {t("freeDayWeekTitle")} Â· {weekCount}/7
          </Text>
        </View>
        <TouchableOpacity style={styles.freeDayToggle} onPress={() => setExpanded((prev) => !prev)}>
          <Text style={[styles.freeDayToggleText, { color: colors.muted }]}>
            {expanded ? t("freeDayCollapse") : t("freeDayExpand")}
          </Text>
        </TouchableOpacity>
      </View>
      {needsRescue && (
        <View
          style={[
            styles.freeDayRescueBanner,
            { borderColor: colors.border, backgroundColor: colors.background },
          ]}
        >
          <View style={{ flex: 1 }}>
            <Text style={[styles.freeDayRescueTitle, { color: colors.text }]}>
              {t("freeDayRescueTitle")}
            </Text>
            <Text style={[styles.freeDayRescueSubtitle, { color: colors.muted }]}>
              {canRescue
                ? t("freeDayRescueSubtitle", { cost: rescueCost })
                : rescueStatus || t("freeDayRescueSubtitle", { cost: rescueCost })}
            </Text>
          </View>
          <TouchableOpacity
            style={[
              styles.freeDayRescueButton,
              { backgroundColor: palette.accent },
              !canRescue && styles.freeDayRescueButtonDisabled,
            ]}
            onPress={onRescue}
            disabled={!canRescue}
          >
            <Text
              style={[
                styles.freeDayRescueButtonText,
                !canRescue && { color: palette.accent, opacity: 0.6 },
              ]}
            >
              {t("freeDayRescueButton")}
            </Text>
          </TouchableOpacity>
        </View>
      )}
      {expanded && (
        <>
          <View style={styles.freeDayStatsRow}>
            {stats.map((stat) => (
              <View key={stat.label} style={styles.freeDayStat}>
                <Text style={[styles.freeDayStatLabel, { color: colors.muted }]}>{stat.label}</Text>
                <Text style={[styles.freeDayStatValue, { color: palette.accent }]}>
                  {stat.value}
                </Text>
              </View>
            ))}
          </View>
          <View
            style={[
              styles.freeDayCalendar,
              { backgroundColor: streakActive ? "rgba(255,255,255,0.4)" : colors.card },
            ]}
          >
            <View style={styles.freeDayCalendarHeader}>
              <Text style={[styles.freeDayCalendarTitle, { color: colors.muted }]}>
                {t("freeDayWeekTitle")}
              </Text>
              <Text style={[styles.freeDayCalendarTitle, { color: colors.muted }]}>
                {weekCount}/7
              </Text>
            </View>
            <View style={styles.freeDayCalendarDays}>
              {weekDays.map((day) => (
                <View key={day.key} style={styles.freeDayCalendarDay}>
                  <Text style={[styles.freeDayCalendarLabel, { color: colors.muted }]}>
                    {day.label}
                  </Text>
                  <View
                    style={[
                      styles.freeDayCalendarDot,
                      day.active && styles.freeDayCalendarDotActive,
                      day.isToday && styles.freeDayCalendarDotToday,
                    ]}
                  />
                </View>
              ))}
            </View>
          </View>
        </>
      )}
    </View>
  );
}

function SpendConfirmSheet({
  visible,
  item,
  currency = DEFAULT_PROFILE.currency,
  language = DEFAULT_LANGUAGE,
  onCancel,
  onConfirm,
  colors,
  t,
  theme,
}) {
  const priceLabel = item
    ? formatTemptationPriceLabel(item, currency)
    : formatCurrency(0, currency, { friendly: true });
  const displayTitle =
    item?.title?.[language] || item?.title?.en || item?.title || t("defaultDealTitle");
  const cancelColor = theme === "dark" ? "#64F2B5" : "#1BA868";
  return (
    <Modal visible={visible} transparent animationType="fade" statusBarTranslucent>
      <View style={styles.payBackdrop}>
        <TouchableWithoutFeedback onPress={onCancel}>
          <View style={styles.payBackdropHit} />
        </TouchableWithoutFeedback>
        <View style={[styles.paySheet, { backgroundColor: colors.card }] }>
          <View style={styles.paySheetHandle} />
          <Text style={[styles.payBrand, { color: colors.text }]}>{t("spendSheetTitle")}</Text>
          <View style={[styles.payCard, { backgroundColor: colors.background }]}>
            <View style={styles.payCardIcon}>
              <Text style={styles.payCardEmoji}>{item?.emoji || "ðŸ’³"}</Text>
            </View>
            <View style={styles.payCardTexts}>
              <Text style={[styles.payCardTitle, { color: colors.text }]}>{displayTitle}</Text>
            </View>
            <Text style={[styles.payCardAmount, { color: colors.text }]}>{priceLabel}</Text>
          </View>
          <View style={styles.paySheetReminder}>
            <Text
              style={[styles.paySheetSubtitle, { color: colors.muted }]}
              numberOfLines={1}
              adjustsFontSizeToFit
              minimumFontScale={0.85}
              ellipsizeMode="tail"
            >
              {t("spendSheetSubtitle")}
            </Text>
          </View>
          <TouchableOpacity style={[styles.payConfirm, { backgroundColor: colors.text }]} onPress={onConfirm}>
            <Text style={[styles.payConfirmText, { color: colors.background }]}>
              {t("spendSheetConfirm")}
            </Text>
          </TouchableOpacity>
          <TouchableOpacity style={styles.payCancel} onPress={onCancel}>
            <Text style={[styles.payCancelText, { color: cancelColor }]}>
              {t("spendSheetCancel")}
            </Text>
          </TouchableOpacity>
        </View>
      </View>
    </Modal>
  );
}

const LightningBolt = ({ active, delay = 0, style }) => {
  const opacity = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    if (!active) {
      opacity.setValue(0);
      return;
    }
    const loop = Animated.loop(
      Animated.sequence([
        Animated.delay(delay),
        Animated.timing(opacity, { toValue: 1, duration: 120, useNativeDriver: true }),
        Animated.timing(opacity, { toValue: 0, duration: 280, useNativeDriver: true }),
        Animated.delay(900 + Math.random() * 500),
      ])
    );
    loop.start();
    return () => loop.stop();
  }, [active, delay, opacity]);

  return (
    <Animated.View pointerEvents="none" style={[styles.stormLightningBolt, style, { opacity }]}>
      <Svg width={60} height={140} viewBox="0 0 60 140">
        <SvgPath d="M24 0 L0 80 H18 L8 140 L60 55 H38 L48 0 Z" fill="rgba(255,255,255,0.95)" />
      </Svg>
    </Animated.View>
  );
};

function StormOverlay({ visible, t, catCrySource, colors, onDismiss }) {
  const flash = useRef(new Animated.Value(0)).current;
  const catBounce = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    if (!visible) {
      flash.setValue(0);
      return;
    }
    const loop = Animated.loop(
      Animated.sequence([
        Animated.delay(500),
        Animated.timing(flash, { toValue: 0.85, duration: 110, useNativeDriver: true }),
        Animated.timing(flash, { toValue: 0, duration: 360, useNativeDriver: true }),
        Animated.delay(700),
      ])
    );
    loop.start();
    return () => loop.stop();
  }, [flash, visible]);

  useEffect(() => {
    if (!visible) {
      catBounce.setValue(0);
      return;
    }
    const loop = Animated.loop(
      Animated.sequence([
        Animated.timing(catBounce, {
          toValue: 1,
          duration: 900,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(catBounce, {
          toValue: 0,
          duration: 900,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    loop.start();
    return () => loop.stop();
  }, [catBounce, visible]);

  if (!visible) return null;

  const handleDismiss = () => {
    if (typeof onDismiss === "function") {
      onDismiss();
    }
  };

  const rainColors =
    colors?.muted != null
      ? { muted: colorWithAlpha(colors.muted, 0.5) }
      : { muted: "rgba(173,196,255,0.5)" };
  const cardBackground = colorWithAlpha(colors?.card || "#0A0F23", 0.96);
  const borderColor = colorWithAlpha(colors?.text || "#FFFFFF", 0.18);
  const messageColor = colors?.text || "#F5F6FF";
  const comfortColor = colors?.muted || "rgba(245,246,255,0.75)";
  const catSource = catCrySource || CLASSIC_TAMAGOTCHI_ANIMATIONS.cry;
  const bobbing = catBounce.interpolate({
    inputRange: [0, 1],
    outputRange: [0, -10],
  });

  return (
    <Modal visible transparent animationType="fade" statusBarTranslucent>
      <TouchableWithoutFeedback onPress={handleDismiss}>
        <View style={styles.stormOverlay} pointerEvents="auto">
          <RainOverlay colors={rainColors} />
          <Animated.View style={[styles.stormFlash, { opacity: flash }]} />
          <LightningBolt
            active={visible}
            delay={150}
            style={{ left: 30, top: 80, transform: [{ rotate: "-10deg" }] }}
          />
          <LightningBolt
            active={visible}
            delay={640}
            style={{ right: 40, top: 130, transform: [{ rotate: "12deg" }] }}
          />
          <View style={[styles.stormMessageWrap, { backgroundColor: cardBackground, borderColor }]}>
            <Animated.View style={[styles.stormCatWrap, { transform: [{ translateY: bobbing }] }]}>
              <Image source={catSource} style={styles.stormCatImage} resizeMode="contain" />
            </Animated.View>
            <Text style={[styles.stormMessage, { color: messageColor }]}>{t("stormOverlayMessage")}</Text>
            <Text style={[styles.stormComfortText, { color: comfortColor }]}>
              {t("stormOverlayComfortMessage")}
            </Text>
          </View>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
}

const hasImpulseHistory = (insights) => {
  if (!insights?.categories) return false;
  if ((insights.eventCount || 0) < MIN_IMPULSE_EVENTS_FOR_MAP) return false;
  return IMPULSE_CATEGORY_ORDER.some((id) => {
    const entry = insights.categories[id];
    return (entry?.save || 0) + (entry?.spend || 0) > 0;
  });
};

function ImpulseMapCard({ insights, colors, t, language, expanded = false, onToggle }) {
  if (!insights) return null;
  const fallbackTime = t("impulseAnytimeLabel");
  const cleanTitle = (value) => {
    const stripped = stripEmojis(value || "");
    return stripped || value || "";
  };
  const formatInsightLine = (title, timeLabel) =>
    t("impulseInsightLine", {
      temptation: cleanTitle(title),
      time: timeLabel || fallbackTime,
    });
  const loseText = insights.hotLose
    ? formatInsightLine(insights.hotLose.title, insights.hotLose.windowLabel || fallbackTime)
    : t("impulseLoseEmptyShort");
  const winText = insights.hotWin
    ? formatInsightLine(insights.hotWin.title, insights.hotWin.windowLabel || fallbackTime)
    : t("impulseWinEmptyShort");
  const trendText =
    insights.hottestSpendCategory && insights.hottestSpendCategory.spendCount > 0
      ? t("impulseTrendShort", {
          category: getImpulseCategoryLabel(insights.hottestSpendCategory.id, language),
        })
      : null;
  const isDarkMode = colors.background === THEMES.dark.background;
  const cardBackground = isDarkMode ? lightenColor(colors.card, 0.12) : colors.card;
  const cardBorder = isDarkMode ? lightenColor(colors.border, 0.3) : colors.border;
  const dangerBg = isDarkMode ? "rgba(255,108,108,0.2)" : "#FFE6E6";
  const dangerBorder = isDarkMode ? "rgba(255,108,108,0.42)" : "rgba(255,108,108,0.35)";
  const successBg = isDarkMode ? "rgba(33,209,160,0.2)" : "#E6FBF2";
  const successBorder = isDarkMode ? "rgba(33,209,160,0.4)" : "rgba(33,209,160,0.32)";
  const neutralBg = isDarkMode ? "rgba(250,204,21,0.18)" : "#FFF5D9";
  const neutralBorder = isDarkMode ? "rgba(250,204,21,0.35)" : "rgba(250,204,21,0.3)";
  const toggleLabel = expanded ? t("impulseCollapse") : t("impulseExpand");
  const categories = IMPULSE_CATEGORY_ORDER.map((id, index) => {
    const entry = insights.categories?.[id] || { save: 0, spend: 0 };
    const save = entry.save || 0;
    const spend = entry.spend || 0;
    return {
      id,
      orderIndex: index,
      label: getImpulseCategoryLabel(id, language),
      save,
      spend,
      total: save + spend,
    };
  });
  const rankedCategories = [...categories].sort((a, b) => {
    if (b.total !== a.total) return b.total - a.total;
    return a.orderIndex - b.orderIndex;
  });
  const topRanked = rankedCategories.filter((entry) => entry.total > 0);
  const visibleCategories = expanded ? topRanked.slice(0, 4) : [];
  const sequenceEntries = [];
  const sequenceInsights = Array.isArray(insights.sequenceInsights) ? insights.sequenceInsights : [];
  const resolveBefore = (action) =>
    action === "save" ? t("impulseActionSaveBefore") : t("impulseActionSpendBefore");
  const resolveAfter = (action) =>
    action === "save" ? t("impulseActionSaveAfter") : t("impulseActionSpendAfter");
  if (sequenceInsights.length) {
    sequenceInsights.forEach((entry, index) => {
      sequenceEntries.push({
        key: entry.key || `sequence-${index}`,
        text: t("impulseSequenceInsight", {
          before: resolveBefore(entry.fromAction),
          after: resolveAfter(entry.toAction),
          from: entry.fromTitle || "",
          to: entry.toTitle || "",
          time: entry.windowLabel || fallbackTime,
        }),
      });
    });
  } else {
    const sequenceData = insights.sequenceHotspots || {};
    if (sequenceData.slip) {
      sequenceEntries.push({
        key: "slip",
        text: t("impulseSequenceInsight", {
          before: resolveBefore(sequenceData.slip.fromAction || "spend"),
          after: resolveAfter(sequenceData.slip.toAction || "spend"),
          from: sequenceData.slip.fromTitle || "",
          to: sequenceData.slip.toTitle || "",
          time: sequenceData.slip.windowLabel || fallbackTime,
        }),
      });
    }
    if (sequenceData.rebound) {
      sequenceEntries.push({
        key: "rebound",
        text: t("impulseSequenceInsight", {
          before: resolveBefore(sequenceData.rebound.fromAction || "save"),
          after: resolveAfter(sequenceData.rebound.toAction || "save"),
          from: sequenceData.rebound.fromTitle || "",
          to: sequenceData.rebound.toTitle || "",
          time: sequenceData.rebound.windowLabel || fallbackTime,
        }),
      });
    }
  }
  return (
    <View style={[styles.impulseCard, { backgroundColor: cardBackground, borderColor: cardBorder }]}>
      <View
        pointerEvents="none"
        style={[styles.impulseCardGlow, { backgroundColor: isDarkMode ? "#4A3A6E" : "#FFD8A9" }]}
      />
      <View style={styles.impulseHeaderRow}>
        <View style={styles.impulseHeader}>
          <Text style={[styles.impulseCardTitle, { color: colors.text }]}>{t("impulseCardTitle")}</Text>
          <Text style={[styles.impulseCardSubtitle, { color: colors.muted }]}>
            {t("impulseCardSubtitle")}
          </Text>
        </View>
        <TouchableOpacity
          onPress={onToggle}
          style={[
            styles.impulseToggle,
            { borderColor: cardBorder, backgroundColor: lightenColor(cardBackground, isDarkMode ? 0.08 : 0.2) },
          ]}
        >
          <Text style={[styles.impulseToggleText, { color: colors.text }]}>{toggleLabel}</Text>
        </TouchableOpacity>
      </View>
      <View style={styles.impulseSummaryGrid}>
        <View
          style={[
            styles.impulseBadge,
            { backgroundColor: dangerBg, borderColor: dangerBorder },
          ]}
        >
          <Text style={[styles.impulseSummaryLabel, { color: colors.text }]}>{t("impulseLoseLabel")}</Text>
          <Text style={[styles.impulseSummaryValue, { color: colors.text }]}>{loseText}</Text>
        </View>
        <View
          style={[
            styles.impulseBadge,
            { backgroundColor: successBg, borderColor: successBorder },
          ]}
        >
          <Text style={[styles.impulseSummaryLabel, { color: colors.text }]}>{t("impulseWinLabel")}</Text>
          <Text style={[styles.impulseSummaryValue, { color: colors.text }]}>{winText}</Text>
        </View>
      </View>
      {expanded && (
        <>
          {trendText ? (
            <View
              style={[
                styles.impulseTrendRow,
                { backgroundColor: neutralBg, borderColor: neutralBorder },
              ]}
            >
              <Text style={[styles.impulseTrendText, { color: colors.text }]}>{trendText}</Text>
            </View>
          ) : null}
          {visibleCategories.length ? (
            <View style={styles.impulseCategoryList}>
              {visibleCategories.map((category) => {
                const hasData = (category.save || 0) + (category.spend || 0) > 0;
                const isRisk = hasData && category.spend > category.save;
                const isWin = hasData && category.save > category.spend;
                let categoryBg = colors.card;
                let categoryBorder = colors.border;
                if (isRisk) {
                  categoryBg = dangerBg;
                  categoryBorder = dangerBorder;
                } else if (isWin) {
                  categoryBg = successBg;
                  categoryBorder = successBorder;
                }
                return (
                  <View
                    key={category.id}
                    style={[
                      styles.impulseCategoryRow,
                      {
                        borderColor: categoryBorder,
                        backgroundColor: categoryBg,
                      },
                    ]}
                  >
                  <Text style={[styles.impulseCategoryLabel, { color: colors.text }]}>
                    {category.label}
                  </Text>
                  <View style={styles.impulseCategoryStats}>
                    <Text style={[styles.impulseCategoryStat, { color: SAVE_ACTION_COLOR }]}>
                      {`â–² ${category.save}`}
                    </Text>
                    <Text style={[styles.impulseCategoryStat, { color: SPEND_ACTION_COLOR }]}>
                      {`â–¼ ${category.spend}`}
                    </Text>
                  </View>
                </View>
              );
            })}
          </View>
          ) : null}
          <View
            style={[
              styles.impulseSequenceSection,
              { borderColor: colors.border, backgroundColor: lightenColor(cardBackground, isDarkMode ? 0.08 : 0.16) },
            ]}
          >
            <Text style={[styles.impulseSequenceTitle, { color: colors.text }]}>{t("impulseSequenceTitle")}</Text>
            {sequenceEntries.length ? (
              sequenceEntries.map((entry) => (
                <Text key={entry.key} style={[styles.impulseSequenceEntry, { color: colors.muted }]}>
                  {entry.text}
                </Text>
              ))
            ) : (
              <Text style={[styles.impulseSequenceEntry, { color: colors.muted }]}>
                {t("impulseSequenceEmptyShort")}
              </Text>
            )}
          </View>
        </>
      )}
    </View>
  );
}

const HistoryModal = React.memo(function HistoryModal({
  visible = false,
  history = [],
  onClose = () => {},
  onHistoryDelete = () => {},
  t,
  colors,
  currency,
  language,
}) {
  const historyEntries = Array.isArray(history) ? history : [];
  const locale = getFormatLocale(language);
  const formatLocalAmount = useCallback(
    (valueUSD = 0) => formatCurrency(convertToCurrency(valueUSD || 0, currency), currency),
    [currency]
  );
  const describeHistory = useCallback(
    (entry) => describeHistoryEntry(entry, { t, formatLocalAmount }),
    [formatLocalAmount, t]
  );
  const formatHistoryMeta = useCallback(
    (entry) => formatHistoryEntryMeta(entry, { t, locale }),
    [locale, t]
  );
  const [modalHeight, setModalHeight] = useState(0);
  const modalOpacity = useMemo(() => {
    const screenHeight = Dimensions.get("window").height || 1;
    const ratio = Math.max(0, Math.min((modalHeight || 0) / screenHeight, 1));
    return Math.min(0.5, Math.max(0.22, 0.18 + ratio * 0.45));
  }, [modalHeight]);
  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      statusBarTranslucent
      onRequestClose={onClose}
    >
      <View style={styles.progressCategoryModalRoot}>
        <TouchableWithoutFeedback onPress={onClose}>
          <View
            style={[
              styles.progressCategoryBackdrop,
              { backgroundColor: `rgba(0,0,0,${modalOpacity})` },
            ]}
          />
        </TouchableWithoutFeedback>
        <View style={styles.progressCategoryModalWrap} pointerEvents="box-none">
          <View
            style={[
              styles.progressCategoryModalCard,
              { backgroundColor: colors.card, borderColor: colors.border },
            ]}
            onLayout={(event) => {
              const nextHeight = event?.nativeEvent?.layout?.height || 0;
              if (nextHeight && nextHeight !== modalHeight) {
                setModalHeight(nextHeight);
              }
            }}
          >
            <View style={styles.progressCategoryModalHeader}>
              <Text style={[styles.progressCategoryModalTitle, { color: colors.text }]}>
                {t("historyTitle")}
              </Text>
              <TouchableOpacity onPress={onClose} style={styles.progressCategoryModalClose}>
                <Text style={[styles.progressCategoryModalCloseText, { color: colors.muted }]}>âœ•</Text>
              </TouchableOpacity>
            </View>
            {historyEntries.length === 0 ? (
              <Text style={[styles.historyEmpty, { color: colors.muted }]}>
                {t("historyEmpty")}
              </Text>
            ) : (
              <ScrollView
                style={[styles.progressCategoryModalList, { borderColor: colors.border }]}
                contentContainerStyle={styles.historyListContent}
                showsVerticalScrollIndicator
              >
                {historyEntries.map((entry, index) => (
                  <View
                    key={entry.id}
                    style={[
                      styles.historyItem,
                      {
                        borderColor: colors.border,
                        borderBottomWidth:
                          index === historyEntries.length - 1 ? 0 : StyleSheet.hairlineWidth,
                      },
                    ]}
                  >
                    <View style={styles.historyRow}>
                      <View style={{ flex: 1 }}>
                        <Text style={[styles.historyItemTitle, { color: colors.text }]}>
                          {describeHistory(entry)}
                        </Text>
                        <Text style={[styles.historyItemMeta, { color: colors.muted }]}>
                          {formatHistoryMeta(entry)}
                        </Text>
                      </View>
                      <TouchableOpacity
                        style={[styles.historyDeleteBtn, { borderColor: colors.border }]}
                        onPress={() => onHistoryDelete?.(entry)}
                      >
                        <Text style={[styles.historyDeleteText, { color: colors.muted }]}>âœ•</Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                ))}
              </ScrollView>
            )}
          </View>
        </View>
      </View>
    </Modal>
  );
});

const FeedScreen = React.memo(
  forwardRef(function FeedScreen(
    {
  products,
  savedTotalUSD,
  wishes = [],
  onTemptationAction,
  onTemptationEditToggle,
  onTemptationQuickGoalToggle,
  onNewTemptation = () => {},
  t,
  tVariant,
  language,
  colors,
  currency,
  freeDayStats,
  onFreeDayLog,
  healthPoints = 0,
  onFreeDayRescue,
  freeDayRescueCost = FREE_DAY_RESCUE_COST,
  analyticsStats = [],
  refuseStats = {},
  cardFeedback = {},
  historyEvents = [],
  onHistoryDelete = () => {},
  profile,
  titleOverrides = {},
  descriptionOverrides = {},
  onBaselineSetup,
  goalAssignments = {},
  impulseInsights = null,
  moodPreset = null,
  onMoodDetailsOpen = () => {},
  onPotentialDetailsOpen = null,
  heroGoalTargetUSD = 0,
  heroGoalSavedUSD = 0,
  potentialGrowthUSD = 0,
  showPotentialGrowth = false,
  dailyRewardUnlocked = false,
  dailyRewardReady = false,
  dailyRewardAmount = 0,
  dailyRewardBaseAmount = 0,
  dailyRewardDay = 1,
  onDailyRewardClaim = () => {},
  onDailyRewardModalVisibilityChange = null,
  editingTemptationId = null,
  editingTitleValue = "",
  editingPriceValue = "",
  editingGoalLabel = "",
  editingEmojiValue = "",
  editingDescriptionValue = "",
  editingCategoryValue = DEFAULT_IMPULSE_CATEGORY,
  onTemptationEditTitleChange,
  onTemptationEditPriceChange,
  onTemptationEditEmojiChange,
  onTemptationEditDescriptionChange,
  onTemptationEditCategoryChange,
  onTemptationEditSave,
  onTemptationEditCancel,
  onTemptationEditDelete,
  onTemptationGoalSelect,
  onTemptationSwipeDelete,
  onSavingsBreakdownPress = () => {},
  mascotOverride = null,
  onMascotAnimationComplete = () => {},
  hideMascot = false,
  onMascotPress = () => {},
  resolveTemplateTitle = () => null,
  tamagotchiMood = null,
  tamagotchiDesiredFood = null,
  primaryTemptationId = null,
  primaryTemptationDescription = "",
  focusTemplateId = null,
  onFocusCancel = null,
  tamagotchiAnimations = CLASSIC_TAMAGOTCHI_ANIMATIONS,
  lifetimeSavedUSD = 0,
  playerLevel = 1,
  interactionStats = {},
  resolveCardRefuseStats = () => null,
  activeChallenge = null,
  onActiveChallengePress = () => {},
  homeSpeechTick = 0,
  homeSpeechReason = "unknown",
  speechAllowed = true,
  lastVisitAt = null,
  lastVisitAtSnapshot = null,
  tutorialTemptationStepId = null,
  tutorialHighlightMeasureTick = 0,
  onTutorialHighlightLayoutChange = null,
  allowThinkAction = true,
  },
    ref
  ) {
  const safeAreaInsets = useSafeAreaInsets();
  const tutorialHighlightOffset = useMemo(() => {
    if (Platform.OS !== "android") return 0;
    const bottomInset = Math.max(safeAreaInsets.bottom || 0, 0);
    return bottomInset <= 8 ? 0 : ANDROID_TUTORIAL_HIGHLIGHT_OFFSET;
  }, [safeAreaInsets.bottom]);
  const listRef = useRef(null);
  const heroSectionHeightRef = useRef(0);
  const scrollToTop = useCallback(
    ({ animated = false } = {}) => {
      if (!listRef.current) return false;
      try {
        listRef.current.scrollToOffset({ offset: 0, animated });
        return true;
      } catch (error) {
        return false;
      }
    },
    []
  );
  const scrollToTemptations = useCallback(
    ({ animated = true, extraOffset = 0 } = {}) => {
      if (!listRef.current) return false;
      const baseOffset = Math.max(0, (heroSectionHeightRef.current || 0) - 16);
      const offset = Math.max(0, baseOffset + (Number(extraOffset) || 0));
      try {
        listRef.current.scrollToOffset({ offset, animated });
        return true;
      } catch (error) {
        return false;
      }
    },
    []
  );
  const handleHeroLayout = useCallback((event) => {
    const height = event?.nativeEvent?.layout?.height || 0;
    if (!height) return;
    heroSectionHeightRef.current = height;
  }, []);
  useImperativeHandle(
    ref,
    () => ({
      scrollToTop,
      scrollToTemptations,
    }),
    [scrollToTop, scrollToTemptations]
  );
  const resolvedHistoryEvents = Array.isArray(historyEvents) ? historyEvents : [];
  const [historyModalVisible, setHistoryModalVisible] = useState(false);
  const openHistoryModal = useCallback(() => setHistoryModalVisible(true), []);
  const closeHistoryModal = useCallback(() => setHistoryModalVisible(false), []);
  const [frequencyCollapseMap, setFrequencyCollapseMap] = useState({
    daily: false,
    weekly: false,
    biweekly: false,
    monthly: false,
    unscheduled: false,
  });
  const toggleFrequencySection = useCallback((sectionId) => {
    setFrequencyCollapseMap((prev) => ({
      ...prev,
      [sectionId]: !prev?.[sectionId],
    }));
  }, []);
  const handleBaselineSetup = onBaselineSetup || (() => {});
  const realSavedUSD = useRealSavedAmount();
  const totalSavedLabel = useMemo(
    () => formatCurrency(convertToCurrency(realSavedUSD || 0, currency), currency),
    [realSavedUSD, currency]
  );
  const heroGoalSavedLabel = useMemo(
    () => formatCurrency(convertToCurrency(heroGoalSavedUSD || 0, currency), currency),
    [heroGoalSavedUSD, currency]
  );
  const heroTargetLabel = useMemo(
    () => formatCurrency(convertToCurrency(heroGoalTargetUSD || 0, currency), currency),
    [heroGoalTargetUSD, currency]
  );
  const heroHasActiveGoal =
    Boolean(profile?.goal) ||
    (Array.isArray(profile?.primaryGoals) && profile.primaryGoals.length > 0);
  const isGoalComplete = heroGoalTargetUSD > 0 && heroGoalSavedUSD >= heroGoalTargetUSD;
  const goalProgress = heroGoalTargetUSD > 0 ? heroGoalSavedUSD / heroGoalTargetUSD : 0;
  const remainingLocal = formatCurrency(
    convertToCurrency(Math.max(heroGoalTargetUSD - heroGoalSavedUSD, 0), currency),
    currency
  );
  const goalProgressLabel = heroGoalTargetUSD
    ? t("progressGoal", { current: heroGoalSavedLabel, goal: heroTargetLabel })
    : t("progressGoal", { current: heroGoalSavedLabel, goal: heroGoalSavedLabel });
  const personaPreset = useMemo(() => getPersonaPreset(profile?.persona), [profile?.persona]);
  const recentActivity = useMemo(() => {
    const filtered = resolvedHistoryEvents.filter(
      (entry) => entry.kind === "refuse_spend" || entry.kind === "spend"
    );
    filtered.sort((a, b) => {
      const aTime = Number(a?.timestamp) || 0;
      const bTime = Number(b?.timestamp) || 0;
      return bTime - aTime;
    });
    return filtered.slice(0, 3);
  }, [resolvedHistoryEvents]);
  const { latestSaveEvent, latestSpendEvent } = useMemo(() => {
    let latestSave = null;
    let latestSpend = null;
    resolvedHistoryEvents.forEach((entry) => {
      if (!entry || !entry.kind) return;
      const timestamp = Number(entry.timestamp) || 0;
      if (!timestamp) return;
      if (entry.kind === "refuse_spend") {
        if (!latestSave || timestamp > Number(latestSave.timestamp || 0)) {
          latestSave = entry;
        }
      } else if (entry.kind === "spend") {
        if (!latestSpend || timestamp > Number(latestSpend.timestamp || 0)) {
          latestSpend = entry;
        }
      }
    });
    return { latestSaveEvent: latestSave, latestSpendEvent: latestSpend };
  }, [resolvedHistoryEvents]);
  const heroRecentEvents = useMemo(
    () =>
      recentActivity.map((entry) => {
        const resolvedTitle =
          resolveTemplateTitle(entry?.meta?.templateId, entry?.meta?.title) ||
          entry?.title ||
          t("defaultDealTitle");
        const timestampLabel = formatLatestSavingTimestamp(entry?.timestamp, language);
        const isSpend = entry.kind === "spend";
        const prefix = isSpend ? "- " : "";
        return {
          id: entry.id,
          label: `${prefix}${resolvedTitle}${timestampLabel ? ` Â· ${timestampLabel}` : ""}`,
          isSpend,
        };
      }),
    [language, recentActivity, resolveTemplateTitle, t]
  );
  const resolveEventTitle = useCallback(
    (entry) =>
      resolveTemplateTitle(entry?.meta?.templateId, entry?.meta?.title) ||
      entry?.title ||
      t("defaultDealTitle"),
    [resolveTemplateTitle, t]
  );
  const resolveSpeechTitle = useCallback(
    (entry) => {
      const raw =
        resolveTemplateTitle(entry?.meta?.templateId, entry?.meta?.title) ||
        entry?.title ||
        t("defaultDealTitle");
      return String(raw || "")
        .replace(/^[^\p{L}\p{N}]+/gu, "")
        .replace(/^\s+/, "")
        .trim();
    },
    [resolveTemplateTitle, t]
  );
  const stripEmoji = useCallback((value) => {
    if (!value) return "";
    return String(value)
      .replace(/\p{Extended_Pictographic}+/gu, "")
      .replace(/\s{2,}/g, " ")
      .trim();
  }, []);
  const heroSpendCopy = useMemo(() => {
    if (heroRecentEvents.length > 0) {
      return "";
    }
    if (!realSavedUSD || realSavedUSD <= 0) {
      return t("heroSpendFallback");
    }
    const template = personaPreset?.tagline?.[language];
    if (template) {
      return template.replace("{{amount}}", totalSavedLabel);
    }
    return t("heroSpendFallback");
  }, [heroRecentEvents.length, language, personaPreset, realSavedUSD, t, totalSavedLabel]);
  const heroEncouragementLine = useMemo(() => {
    const heroLine = isGoalComplete
      ? moodPreset?.heroComplete || t("goalWidgetCompleteTagline")
      : moodPreset?.hero || t("heroEconomyContinues");
    if (moodPreset?.motivation) {
      return `${heroLine} ${moodPreset.motivation}`;
    }
    return heroLine;
  }, [isGoalComplete, moodPreset, t]);
  const historyInteractionMap = useMemo(
    () => buildHistoryInteractionMap(resolvedHistoryEvents),
    [resolvedHistoryEvents]
  );
  const resolveHistoryEntryForItem = useCallback(
    (item) => {
      if (!item) return null;
      const keys = [
        normalizeInteractionKey(item.id),
        normalizeInteractionKey(item.templateId),
      ].filter(Boolean);
      if (!keys.length) return null;
      let best = null;
      keys.forEach((key) => {
        const candidate = historyInteractionMap?.[key];
        if (!candidate) return;
        if (!best || (candidate.lastInteractionAt || 0) > (best.lastInteractionAt || 0)) {
          best = candidate;
        }
      });
      return best;
    },
    [historyInteractionMap]
  );
  const isDarkMode = colors === THEMES.dark;
  const moodGradient = useMemo(
    () => applyThemeToMoodGradient(getMoodGradient(moodPreset?.id), isDarkMode ? "dark" : "light"),
    [moodPreset?.id, isDarkMode]
  );
  const mainTemptationId = primaryTemptationId;
  const resolveInteractionEntry = useCallback(
    (item) => {
      if (!item) return null;
      const direct = interactionStats?.[item.id] || null;
      const templateId = typeof item.templateId === "string" ? item.templateId : null;
      const templated = templateId ? interactionStats?.[templateId] || null : null;
      const historyEntry = resolveHistoryEntryForItem(item);
      const base = direct || templated || historyEntry || null;
      if (!base) return null;
      const resolved = base.frequency
        ? base
        : (() => {
            const inferred = resolveEntryFrequency(base);
            return inferred ? { ...base, frequency: inferred } : base;
          })();
      if (resolved.frequency) return resolved;
      const fallback = historyEntry || templated || direct;
      if (!fallback || fallback === resolved) return resolved;
      if (fallback.frequency) return { ...resolved, frequency: fallback.frequency };
      const inferredFallback = resolveEntryFrequency(fallback);
      return inferredFallback ? { ...resolved, frequency: inferredFallback } : resolved;
    },
    [interactionStats, resolveHistoryEntryForItem]
  );
  const goldPalette = useMemo(
    () =>
      isGoalComplete
        ? isDarkMode
          ? {
              background: "#07281C",
              border: "rgba(134,255,192,0.4)",
              glow: "rgba(46,182,125,0.35)",
              accent: "#7BFFB8",
              text: "#E9FFF5",
              subtext: "rgba(233,255,245,0.8)",
              badgeBg: "rgba(0,0,0,0.45)",
              badgeBorder: "rgba(123,255,184,0.5)",
              badgeText: "#9FFFCF",
              barBg: "rgba(0,0,0,0.3)",
              shadow: "#032015",
              danger: "#FF9C9C",
            }
          : {
              background: "#E7FFE8",
              border: "rgba(107,201,128,0.7)",
              glow: "rgba(185,255,210,0.6)",
              accent: "#1C8F4A",
              text: "#064321",
              subtext: "rgba(6,67,33,0.75)",
              badgeBg: "rgba(255,255,255,0.92)",
              badgeBorder: "rgba(6,67,33,0.12)",
              badgeText: "#0E5B30",
              barBg: "rgba(255,255,255,0.65)",
              shadow: "#B2F8C3",
              danger: "#D63B3B",
            }
        : isDarkMode
        ? {
            background: "#2B1A00",
            border: "rgba(255,214,143,0.5)",
            glow: "rgba(255,184,0,0.25)",
            accent: "#FFCF6B",
            text: "#FFEED0",
            subtext: "rgba(255,238,208,0.8)",
            badgeBg: "rgba(0,0,0,0.35)",
            badgeBorder: "rgba(255,223,165,0.5)",
            badgeText: "#FFEED0",
            barBg: "rgba(0,0,0,0.3)",
            shadow: "#1B1100",
            danger: "#FF8F8F",
          }
        : {
            background: "#FFF6D5",
            border: "rgba(240,196,92,0.8)",
            glow: "rgba(255,255,255,0.8)",
            accent: "#D8960B",
            text: "#5C3300",
            subtext: "rgba(92,51,0,0.75)",
            badgeBg: "rgba(255,255,255,0.75)",
            badgeBorder: "rgba(255,255,255,0.9)",
            badgeText: "#7A4A00",
            barBg: "rgba(255,255,255,0.6)",
            shadow: "#F3C75A",
            danger: "#D63B3B",
          },
    [isDarkMode, isGoalComplete]
  );
  const heroMoodBadgeStyle = useMemo(
    () =>
      isDarkMode
        ? { backgroundColor: "rgba(0,0,0,0.45)", borderWidth: 1, borderColor: "rgba(255,255,255,0.15)" }
        : null,
    [isDarkMode]
  );
  const heroMoodBadgeTextColor = isDarkMode ? colors.text : moodGradient.accent;
  const heroMascotWrapStyle = useMemo(
    () =>
      isDarkMode
        ? { backgroundColor: "rgba(0,0,0,0.3)", borderColor: "rgba(255,255,255,0.12)" }
        : null,
    [isDarkMode]
  );
  const pickVariantText = useCallback(
    (key, replacements = {}) => (typeof tVariant === "function" ? tVariant(key, replacements) : t(key, replacements)),
    [t, tVariant]
  );
  const pickKeyText = useCallback(
    (keys = [], replacements = {}) => {
      if (!keys.length) return "";
      const key = keys[Math.floor(Math.random() * keys.length)] || keys[0];
      return t(key, replacements);
    },
    [t]
  );
  const shortenSpeechTitle = useCallback((value, maxLength = 20) => {
    if (!value) return "";
    const text = String(value).trim();
    if (text.length <= maxLength) return text;
    return `${text.slice(0, Math.max(1, maxLength - 1)).trim()}â€¦`;
  }, []);
  const [tamagotchiSpeech, setTamagotchiSpeech] = useState("");
  const [tamagotchiSpeechVisible, setTamagotchiSpeechVisible] = useState(false);
  const tamagotchiSpeechTimerRef = useRef(null);
  const tamagotchiSpeechLastAtRef = useRef(0);
  const tamagotchiSpeechLastTextRef = useRef("");
  const tamagotchiSpeechReadyShownRef = useRef(false);
  const [heroRowWidth, setHeroRowWidth] = useState(0);
  const [heroLogoRight, setHeroLogoRight] = useState(0);
  const heroBubbleMaxWidth = useMemo(() => {
    if (!heroRowWidth || !heroLogoRight) return 200;
    return Math.max(90, heroRowWidth - heroLogoRight + 16);
  }, [heroRowWidth, heroLogoRight]);
  const heroBubbleTextMaxWidth = Math.max(0, heroBubbleMaxWidth - 16);
  const clearTamagotchiSpeechTimer = useCallback(() => {
    if (tamagotchiSpeechTimerRef.current) {
      clearTimeout(tamagotchiSpeechTimerRef.current);
      tamagotchiSpeechTimerRef.current = null;
    }
  }, []);
  const getNextTamagotchiSpeech = useCallback(
    (reason = "unknown") => {
      let text = "";
      for (let i = 0; i < 4; i += 1) {
        const candidate = buildTamagotchiSpeech(reason);
        if (!candidate) continue;
        if (candidate === tamagotchiSpeechLastTextRef.current) {
          continue;
        }
        text = candidate;
        break;
      }
      if (!text) {
        const fallback = pickVariantText("tamagotchiSpeechGeneral");
        if (fallback && fallback !== tamagotchiSpeechLastTextRef.current) {
          text = fallback;
        }
      }
      if (!text) return "";
      tamagotchiSpeechLastTextRef.current = text;
      tamagotchiSpeechLastAtRef.current = Date.now();
      return text;
    },
    [buildTamagotchiSpeech, pickVariantText]
  );
  const scheduleNextTamagotchiSpeech = useCallback(() => {
    clearTamagotchiSpeechTimer();
    tamagotchiSpeechTimerRef.current = setTimeout(() => {
      if (!speechAllowed) {
        setTamagotchiSpeechVisible(false);
        return;
      }
      const nextText = getNextTamagotchiSpeech("unknown");
      if (!nextText) {
        setTamagotchiSpeechVisible(false);
        return;
      }
      setTamagotchiSpeech(nextText);
      setTamagotchiSpeechVisible(true);
      scheduleNextTamagotchiSpeech();
    }, TAMAGOTCHI_SPEECH_DURATION_MS);
  }, [clearTamagotchiSpeechTimer, getNextTamagotchiSpeech, speechAllowed]);
  useEffect(() => () => clearTamagotchiSpeechTimer(), [clearTamagotchiSpeechTimer]);
  useEffect(() => {
    if (!speechAllowed) {
      clearTamagotchiSpeechTimer();
      setTamagotchiSpeechVisible(false);
    }
  }, [clearTamagotchiSpeechTimer, speechAllowed]);
  const showTamagotchiSpeech = useCallback(
    (text) => {
      if (!text) return;
      setTamagotchiSpeech(text);
      setTamagotchiSpeechVisible(true);
      scheduleNextTamagotchiSpeech();
    },
    [scheduleNextTamagotchiSpeech]
  );
  const levelProgressUSD = Math.max(savedTotalUSD || 0, lifetimeSavedUSD || 0);
  const heroLevelCurrency = profile?.currency || DEFAULT_PROFILE.currency;
  const tierInfo = getTierProgress(levelProgressUSD || 0, heroLevelCurrency);
  const span = Math.max(
    (tierInfo.nextTargetUSD ?? tierInfo.prevTargetUSD ?? 1) -
      (tierInfo.prevTargetUSD ?? 0),
    1
  );
  const tierProgress = tierInfo.nextTargetUSD
    ? (levelProgressUSD - tierInfo.prevTargetUSD) / span
    : 1;
  const heroLevelHasNext = !!tierInfo.nextTargetUSD;
  const heroLevelRemainingUSD = heroLevelHasNext
    ? Math.max(tierInfo.nextTargetUSD - levelProgressUSD, 0)
    : 0;
  const heroLevelRemainingRoundedUSD = roundRemainingDisplayUSD(heroLevelRemainingUSD, heroLevelCurrency);
  const heroLevelRemainingLabel = heroLevelHasNext
    ? formatCurrency(convertToCurrency(heroLevelRemainingRoundedUSD, heroLevelCurrency), heroLevelCurrency)
    : "";
  const heroLevelTargetLabel = heroLevelHasNext
    ? formatCurrency(convertToCurrency(tierInfo.nextTargetUSD, heroLevelCurrency), heroLevelCurrency, {
        friendly: true,
      })
    : "";
  const heroLevelProgress = Math.min(Math.max(tierProgress, 0), 1);
  const buildTamagotchiSpeech = useCallback(
    (reason = "unknown") => {
      const tone = tamagotchiMood?.tone || "calm";
      const foodEmoji = tamagotchiDesiredFood?.emoji || t("tamagotchiHungryBubble");
      const now = Date.now();
      const lastVisitAtValue =
        reason === "ready" && lastVisitAtSnapshot ? lastVisitAtSnapshot : lastVisitAt;
      const lastVisitTimestamp = Number(lastVisitAtValue) || 0;
      const minutesAway =
        lastVisitTimestamp > 0 ? Math.floor((now - lastVisitTimestamp) / (1000 * 60)) : 0;
      const daysAway =
        lastVisitTimestamp > 0 ? Math.floor((now - lastVisitTimestamp) / DAY_MS) : 0;
      const awayLong =
        lastVisitTimestamp > 0 && now - lastVisitTimestamp >= DAY_MS * 2;
      const awayShort =
        lastVisitTimestamp > 0 && now - lastVisitTimestamp < TAMAGOTCHI_GREETING_SOON_MS;
      const awayWarm =
        lastVisitTimestamp > 0 && now - lastVisitTimestamp < TAMAGOTCHI_GREETING_WARM_MS;
      const firstVisit = lastVisitTimestamp <= 0;
      const greetingReason = reason === "ready" || reason === "resume";
      const saveTitleRaw = latestSaveEvent ? resolveSpeechTitle(latestSaveEvent) : "";
      const spendTitleRaw = latestSpendEvent ? resolveSpeechTitle(latestSpendEvent) : "";
      const saveTitle = shortenSpeechTitle(saveTitleRaw);
      const spendTitle = shortenSpeechTitle(spendTitleRaw);
      const recentEntry =
        recentActivity && recentActivity.length
          ? recentActivity[Math.floor(Math.random() * recentActivity.length)]
          : null;
      const recentTitleRaw = recentEntry ? resolveSpeechTitle(recentEntry) : "";
      const recentTitle = shortenSpeechTitle(recentTitleRaw);
      const focusTitleRaw = focusTemplateId
        ? stripEmoji(resolveTemplateTitle(focusTemplateId, ""))
        : "";
      const focusTitle = shortenSpeechTitle(focusTitleRaw);
      const recentKind = recentEntry?.kind || "";
      const recentTimestamp = Number(recentEntry?.timestamp) || 0;
      const yesterdayKey = getDayKey(now - DAY_MS);
      const saveIsYesterday =
        latestSaveEvent && getDayKey(Number(latestSaveEvent.timestamp) || 0) === yesterdayKey;
      const spendIsYesterday =
        latestSpendEvent && getDayKey(Number(latestSpendEvent.timestamp) || 0) === yesterdayKey;
      const recentIsYesterday =
        recentTimestamp && getDayKey(recentTimestamp) === yesterdayKey;
      const saveContextTitle =
        (recentKind === "refuse_spend" && recentTitle) || saveTitle;
      const spendContextTitle =
        (recentKind === "spend" && recentTitle) || spendTitle;
      const challengeTitle = activeChallenge?.title || t("defaultDealTitle");
      const challengeProgressLabel = activeChallenge?.progressLabel || "";
      const levelRemainingLabel = heroLevelHasNext ? heroLevelRemainingLabel : "";
      const levelTarget = heroLevelHasNext ? heroLevelTargetLabel : "";
      const heroLevel = tierInfo?.level || 1;

      if (greetingReason) {
        if (awayLong) {
          return tone === "urgent" || tone === "sad"
            ? pickVariantText("tamagotchiSpeechMissedHungry", { food: foodEmoji })
            : pickVariantText("tamagotchiSpeechMissed", { days: daysAway });
        }
        if (firstVisit) {
          return pickVariantText("tamagotchiSpeechGreetingFirst");
        }
        if (awayShort) {
          return tone === "urgent" || tone === "sad"
            ? pickVariantText("tamagotchiSpeechGreetingHungry", { food: foodEmoji })
            : pickVariantText("tamagotchiSpeechGreetingSoon", {
                minutes: Math.max(1, minutesAway || 1),
              });
        }
        if (awayWarm) {
          return tone === "urgent" || tone === "sad"
            ? pickVariantText("tamagotchiSpeechGreetingHungry", { food: foodEmoji })
            : pickVariantText("tamagotchiSpeechGreeting");
        }
        return pickVariantText("tamagotchiSpeechGreeting");
      }

      if (reason === "level_up") {
        return pickVariantText("tamagotchiSpeechLevelUp", { level: heroLevel });
      }

      if (reason === "feed") {
        return pickVariantText("tamagotchiSpeechFed", { food: foodEmoji });
      }

      if (reason === "focus_set" && focusTitle) {
        return pickVariantText("tamagotchiSpeechFocusActive", { title: focusTitle });
      }

      if (reason === "challenge_progress" && activeChallenge?.status === "active") {
        if (challengeProgressLabel) {
          return pickVariantText("tamagotchiSpeechChallengeProgress", {
            title: challengeTitle,
            progress: challengeProgressLabel,
          });
        }
      }

      if (reason === "level_progress" && levelRemainingLabel) {
        return pickVariantText("tamagotchiSpeechLevelProgress", {
          amount: levelRemainingLabel,
          target: levelTarget,
        });
      }

      if (reason === "save") {
        if (activeChallenge?.status === "active" && challengeProgressLabel) {
          return pickVariantText("tamagotchiSpeechChallengeProgress", {
            title: challengeTitle,
            progress: challengeProgressLabel,
          });
        }
        if (levelRemainingLabel && Math.random() < 0.45) {
          return pickVariantText("tamagotchiSpeechLevelProgress", {
            amount: levelRemainingLabel,
            target: levelTarget,
          });
        }
        if (saveContextTitle) {
          const key = recentIsYesterday || saveIsYesterday
            ? "tamagotchiSpeechPraiseSaveYesterday"
            : "tamagotchiSpeechPraiseSaveRecent";
          return pickVariantText(key, { title: saveContextTitle });
        }
        return pickVariantText("tamagotchiSpeechSaveWin");
      }

      if (reason === "spend") {
        if (spendContextTitle) {
          if (tone === "sad" || Math.random() < 0.35) {
            return pickVariantText("tamagotchiSpeechSpendRegret", { title: spendContextTitle });
          }
          const spendKeys = recentIsYesterday || spendIsYesterday
            ? [
                "tamagotchiSpeechTrollSpendYesterday1",
                "tamagotchiSpeechTrollSpendYesterday2",
                "tamagotchiSpeechTrollSpendYesterday3",
              ]
            : [
                "tamagotchiSpeechTrollSpendRecent1",
                "tamagotchiSpeechTrollSpendRecent2",
                "tamagotchiSpeechTrollSpendRecent3",
              ];
          return pickKeyText(spendKeys, { title: spendContextTitle });
        }
        return pickVariantText("tamagotchiSpeechSpendRegretGeneric");
      }

      if (awayLong) {
        return tone === "urgent" || tone === "sad"
          ? pickVariantText("tamagotchiSpeechMissedHungry", { food: foodEmoji })
          : pickVariantText("tamagotchiSpeechMissed", { days: daysAway });
      }

      if (focusTitle && Math.random() < 0.25) {
        return pickVariantText("tamagotchiSpeechFocus", { title: focusTitle });
      }
      if (levelRemainingLabel && Math.random() < 0.22) {
        return pickVariantText("tamagotchiSpeechLevelProgress", {
          amount: levelRemainingLabel,
          target: levelTarget,
        });
      }
      if (
        activeChallenge?.status === "active" &&
        challengeProgressLabel &&
        Math.random() < 0.2
      ) {
        return pickVariantText("tamagotchiSpeechChallengeProgress", {
          title: challengeTitle,
          progress: challengeProgressLabel,
        });
      }
      if (recentTitle && Math.random() < 0.2) {
        return pickVariantText("tamagotchiSpeechRemember", { title: recentTitle });
      }
      if (Math.random() < 0.2) {
        return pickVariantText("tamagotchiSpeechFriendly");
      }
      if (Math.random() < 0.18) {
        return pickVariantText("tamagotchiSpeechSelfCare");
      }
      if (focusTitle && Math.random() < 0.12) {
        return pickVariantText("tamagotchiSpeechFocus", { title: focusTitle });
      }

      if (tone === "urgent") {
        const spendContextTitleUrgent =
          (recentKind === "spend" && recentTitle) || spendTitle;
        if (spendContextTitleUrgent) {
          const spendKeys = recentIsYesterday || spendIsYesterday
            ? [
                "tamagotchiSpeechTrollSpendYesterday1",
                "tamagotchiSpeechTrollSpendYesterday2",
                "tamagotchiSpeechTrollSpendYesterday3",
              ]
            : [
                "tamagotchiSpeechTrollSpendRecent1",
                "tamagotchiSpeechTrollSpendRecent2",
                "tamagotchiSpeechTrollSpendRecent3",
              ];
          return pickKeyText(spendKeys, { title: spendContextTitleUrgent });
        }
        return pickVariantText("tamagotchiSpeechHungry", { food: foodEmoji });
      }

      if (tone === "sad") {
        const spendContextTitleSad =
          (recentKind === "spend" && recentTitle) || spendTitle;
        if (spendContextTitleSad && Math.random() < 0.45) {
          const spendKeys = recentIsYesterday || spendIsYesterday
            ? [
                "tamagotchiSpeechTrollSpendYesterday1",
                "tamagotchiSpeechTrollSpendYesterday2",
                "tamagotchiSpeechTrollSpendYesterday3",
              ]
            : [
                "tamagotchiSpeechTrollSpendRecent1",
                "tamagotchiSpeechTrollSpendRecent2",
                "tamagotchiSpeechTrollSpendRecent3",
              ];
          return pickKeyText(spendKeys, { title: spendContextTitleSad });
        }
        return pickVariantText("tamagotchiSpeechHungrySoft", { food: foodEmoji });
      }

      if (saveContextTitle) {
        const key = recentIsYesterday || saveIsYesterday
          ? "tamagotchiSpeechPraiseSaveYesterday"
          : "tamagotchiSpeechPraiseSaveRecent";
        return pickVariantText(key, { title: saveContextTitle });
      }

      if (activeChallenge?.status === "active") {
        const title = activeChallenge.title || t("defaultDealTitle");
        return pickVariantText("tamagotchiSpeechChallenge", { title });
      }

      if (isGoalComplete) {
        return pickVariantText("tamagotchiSpeechGoalComplete");
      }

      if (heroHasActiveGoal && heroGoalTargetUSD > 0) {
        return pickVariantText("tamagotchiSpeechGoalProgress", { amount: remainingLocal });
      }

      return pickVariantText("tamagotchiSpeechGeneral");
    },
    [
      activeChallenge,
      heroGoalTargetUSD,
      heroHasActiveGoal,
      heroLevelHasNext,
      heroLevelRemainingLabel,
      heroLevelTargetLabel,
      isGoalComplete,
      lastVisitAt,
      lastVisitAtSnapshot,
      latestSaveEvent,
      latestSpendEvent,
      recentActivity,
      pickKeyText,
      pickVariantText,
      remainingLocal,
      resolveTemplateTitle,
      resolveEventTitle,
      resolveSpeechTitle,
      stripEmoji,
      shortenSpeechTitle,
      t,
      tamagotchiDesiredFood,
      tamagotchiMood?.tone,
      focusTemplateId,
      tierInfo?.level,
    ]
  );
  const triggerTamagotchiSpeech = useCallback(
    (reason = "unknown") => {
      const now = Date.now();
      const sinceLast = now - tamagotchiSpeechLastAtRef.current;
      if (sinceLast < TAMAGOTCHI_SPEECH_COOLDOWN_MS) {
        const isActionReason = TAMAGOTCHI_ACTION_SPEECH_REASONS.has(reason);
        if (reason !== "ready" && (!isActionReason || sinceLast < TAMAGOTCHI_SPEECH_ACTION_COOLDOWN_MS)) {
          return;
        }
      }
      const text = getNextTamagotchiSpeech(reason);
      if (!text) return;
      showTamagotchiSpeech(text);
    },
    [getNextTamagotchiSpeech, showTamagotchiSpeech]
  );
  useEffect(() => {
    if (!homeSpeechTick) return;
    if (!speechAllowed) return;
    triggerTamagotchiSpeech(homeSpeechReason);
  }, [homeSpeechReason, homeSpeechTick, speechAllowed, triggerTamagotchiSpeech]);
  useEffect(() => {
    if (!speechAllowed) return;
    if (tamagotchiSpeechReadyShownRef.current) return;
    if (homeSpeechTick > 0 || tamagotchiSpeechVisible || tamagotchiSpeechLastAtRef.current > 0) {
      tamagotchiSpeechReadyShownRef.current = true;
      return;
    }
    tamagotchiSpeechReadyShownRef.current = true;
    triggerTamagotchiSpeech("ready");
  }, [homeSpeechTick, speechAllowed, tamagotchiSpeechVisible, triggerTamagotchiSpeech]);
  const showTamagotchiBubble = speechAllowed && tamagotchiSpeechVisible;
  const tamagotchiBubbleTheme = useMemo(
    () =>
      isDarkMode
        ? {
            backgroundColor: "rgba(5,7,15,0.92)",
            borderColor: "rgba(255,255,255,0.25)",
            textColor: "#F7F9FF",
            shadowColor: "rgba(0,0,0,0.6)",
          }
        : {
            backgroundColor: "rgba(255,255,255,0.96)",
            borderColor: "rgba(28,26,42,0.12)",
            textColor: "#1C1A2A",
            shadowColor: "rgba(218,171,86,0.35)",
          },
    [isDarkMode]
  );
  const previousSavedTotal = useRef(savedTotalUSD);
  useEffect(() => {
    if (savedTotalUSD > previousSavedTotal.current) {
      logEvent("savings_updated", {
        saved_usd_total: savedTotalUSD,
        tier_level: tierInfo.level,
        next_tier_usd: tierInfo.nextTargetUSD || null,
        profile_goal: resolveProfileGoalId(profile) || "none",
      });
    }
    previousSavedTotal.current = savedTotalUSD;
  }, [savedTotalUSD, tierInfo.level, tierInfo.nextTargetUSD, profile.goal, profile.primaryGoals]);
  const progressPercent = Math.min(Math.max(goalProgress, 0), 1);
  const progressPercentLabel = Math.round(progressPercent * 100);
  const levelLabel = t("progressHeroLevel", { level: tierInfo.level });
  const levelCurrency = profile?.currency || DEFAULT_PROFILE.currency;
  const levelProgress = Math.min(Math.max(tierProgress, 0), 1);
  const levelRemainingUSD = tierInfo.nextTargetUSD
    ? Math.max(tierInfo.nextTargetUSD - levelProgressUSD, 0)
    : 0;
  const levelRemainingRoundedUSD = roundRemainingDisplayUSD(levelRemainingUSD, levelCurrency);
  const levelRemainingLabel = formatCurrency(
    convertToCurrency(levelRemainingRoundedUSD, levelCurrency),
    levelCurrency
  );
  const levelTargetLabel = tierInfo.nextTargetUSD
    ? formatCurrency(convertToCurrency(tierInfo.nextTargetUSD, levelCurrency), levelCurrency, {
        friendly: true,
      })
    : "";
  const todayDate = new Date();
  const todayTimestamp = todayDate.getTime();
  const baselineMonthlyWasteUSD = Math.max(
    0,
    Number(profile?.spendingProfile?.baselineMonthlyWasteUSD) || 0
  );
  const baselineStartAt = profile?.spendingProfile?.baselineStartAt || null;
  const hasBaseline = !!(
    baselineMonthlyWasteUSD && baselineStartAt
  );
  const handlePotentialDetailsOpen = useCallback(() => {
    if (typeof onPotentialDetailsOpen === "function") {
      const currencyCode = profile?.currency || DEFAULT_PROFILE.currency;
      const formatLocal = (valueUSD = 0) =>
        formatCurrency(convertToCurrency(Math.max(valueUSD, 0), currencyCode), currencyCode, {
          precisionOverride: getCurrencyPrecision(currencyCode),
        });
      const potentialSavedUSD = calcPotentialSaved(baselineMonthlyWasteUSD, baselineStartAt);
      const potentialLocal = formatLocal(potentialSavedUSD);
      const actualLocal = formatLocal(realSavedUSD);
      const deltaLocal = formatLocal(Math.max(potentialSavedUSD - realSavedUSD, 0));
      onPotentialDetailsOpen(
        t("potentialBlockDetails", {
          potential: potentialLocal,
          actual: actualLocal,
          delta: deltaLocal,
        })
      );
    }
  }, [baselineMonthlyWasteUSD, baselineStartAt, onPotentialDetailsOpen, profile?.currency, realSavedUSD, t]);

  const orderedProducts = useMemo(() => {
    const entries = Array.isArray(products) ? [...products] : [];
    if (!entries.length) return entries;
    let primaryCard = null;
    if (mainTemptationId) {
      const primaryIndex = entries.findIndex((item) => item.id === mainTemptationId);
      if (primaryIndex >= 0) {
        primaryCard = entries.splice(primaryIndex, 1)[0];
      }
    }
    const sortedEntries = entries
      .sort((a, b) => {
        const priceDiff = getTemptationPrice(a) - getTemptationPrice(b);
        if (priceDiff !== 0) {
          return priceDiff;
        }
        return (a.id || "").localeCompare(b.id || "");
      })
      .map((item, index) => ({ item, baseIndex: index }));
    const frequentEntries = sortedEntries
      .map((entry) => {
        const stats = resolveInteractionEntry(entry.item);
        if (!stats) return null;
        const total = (stats.saveCount || 0) + (stats.spendCount || 0);
        if (!total) return null;
        return {
          ...entry,
          total,
          lastInteractionAt: stats.lastInteractionAt || 0,
        };
      })
      .filter(Boolean)
      .sort((a, b) => {
        if (b.total !== a.total) return b.total - a.total;
        if (b.lastInteractionAt !== a.lastInteractionAt) {
          return (b.lastInteractionAt || 0) - (a.lastInteractionAt || 0);
        }
        return a.baseIndex - b.baseIndex;
      })
      .slice(0, FEED_FREQUENT_PIN_LIMIT);
    const pinnedIds = new Set(frequentEntries.map((entry) => entry.item.id));
    const ordered = [];
    if (primaryCard) {
      ordered.push(primaryCard);
    }
    frequentEntries.forEach((entry) => ordered.push(entry.item));
    sortedEntries
      .filter((entry) => !pinnedIds.has(entry.item.id))
      .forEach((entry) => ordered.push(entry.item));
    return ordered;
  }, [products, mainTemptationId, resolveInteractionEntry]);

  const filteredProducts = orderedProducts;
  const frequencySections = useMemo(() => {
    const buckets = TEMPTATION_FREQUENCY_ORDER.map((bucketId) => ({
      id: bucketId,
      title: t(TEMPTATION_FREQUENCY_BUCKETS[bucketId].sectionKey),
      items: [],
    }));
    const bucketMap = buckets.reduce((acc, bucket) => {
      acc[bucket.id] = bucket;
      return acc;
    }, {});
    const unscheduled = [];
    filteredProducts.forEach((product) => {
      const entry = resolveInteractionEntry(product);
      const rawBucketId = entry?.frequency && bucketMap[entry.frequency] ? entry.frequency : null;
      const bucketId = rawBucketId
        ? getDemotedFrequencyBucket(rawBucketId, entry?.lastInteractionAt || 0)
        : null;
      if (bucketId) {
        bucketMap[bucketId].items.push(product);
      } else {
        unscheduled.push(product);
      }
    });
    return { buckets, unscheduled };
  }, [filteredProducts, resolveInteractionEntry, t]);
  const feedEntries = useMemo(() => {
    const entries = [];
    frequencySections.buckets.forEach((section) => {
      if (!section.items.length) return;
      entries.push({
        type: "section",
        id: `freq-${section.id}`,
        sectionId: section.id,
        title: section.title,
        count: section.items.length,
      });
      if (!frequencyCollapseMap[section.id]) {
        section.items.forEach((item) => {
          entries.push({
            type: "card",
            id: `${section.id}-${item.id}`,
            item,
            interaction: resolveInteractionEntry(item),
          });
        });
      }
    });
    if (frequencySections.unscheduled.length) {
      entries.push({
        type: "section",
        id: "freq-unscheduled",
        sectionId: "unscheduled",
        title: t("frequencySectionUnscheduled"),
        count: frequencySections.unscheduled.length,
      });
      if (!frequencyCollapseMap.unscheduled) {
        frequencySections.unscheduled.forEach((item) => {
          entries.push({
            type: "card",
            id: `unscheduled-${item.id}`,
            item,
            interaction: resolveInteractionEntry(item),
          });
        });
      }
    }
    return entries;
  }, [frequencyCollapseMap, frequencySections, resolveInteractionEntry, t]);
  const [timerNow, setTimerNow] = useState(Date.now());
  const hasCountdownTimers = useMemo(() => {
    return feedEntries.some((entry) => {
      if (entry?.type !== "card") return false;
      const interactionEntry = entry?.interaction || {};
      const lastInteractionAt = Number(interactionEntry.lastInteractionAt) || 0;
      if (!lastInteractionAt) return false;
      const hasNextCheckAt = Number.isFinite(Number(interactionEntry.nextCheckAt));
      const hasInterval =
        Number.isFinite(Number(interactionEntry.intervalMs)) || Boolean(interactionEntry.frequency);
      return hasNextCheckAt || hasInterval;
    });
  }, [feedEntries]);
  useEffect(() => {
    if (!hasCountdownTimers) return;
    let timeoutId = null;
    let intervalId = null;
    const scheduleTick = () => {
      const now = Date.now();
      setTimerNow(now);
      const delay = 60000 - (now % 60000);
      timeoutId = setTimeout(() => {
        const tick = () => setTimerNow(Date.now());
        tick();
        intervalId = setInterval(tick, 60000);
      }, delay);
    };
    scheduleTick();
    return () => {
      if (timeoutId) clearTimeout(timeoutId);
      if (intervalId) clearInterval(intervalId);
    };
  }, [hasCountdownTimers]);
  const firstVisibleTemptationId = useMemo(() => {
    const firstCard = feedEntries.find(
      (entry) => entry?.type === "card" && entry.item?.id
    );
    return firstCard?.item?.id || null;
  }, [feedEntries]);
  const tutorialHighlightTemptationId = tutorialTemptationStepId
    ? firstVisibleTemptationId || filteredProducts[0]?.id || orderedProducts[0]?.id || null
    : null;
  const feedKeyExtractor = useCallback((entry) => entry.id, []);
  const resolveAssignedGoalLabel = useCallback(
    (goalId, assignedGoal) => {
      if (assignedGoal) return getWishTitleWithoutEmoji(assignedGoal);
      if (!goalId || typeof goalId !== "string") return null;
      if (!goalId.startsWith("wish_primary_goal_")) return null;
      const primaryGoalId = goalId.replace("wish_primary_goal_", "");
      if (!primaryGoalId) return null;
      const primaryEntry = Array.isArray(profile.primaryGoals)
        ? profile.primaryGoals.find((goal) => goal?.id === primaryGoalId)
        : null;
      const customTitle =
        typeof primaryEntry?.customTitle === "string" ? primaryEntry.customTitle.trim() : "";
      const preset = getGoalPreset(primaryGoalId);
      return customTitle || preset?.[language] || preset?.en || primaryGoalId;
    },
    [language, profile.primaryGoals]
  );
  const renderTemptationCard = useCallback(
    (entry) => {
      const item = entry.item;
      const interactionEntry = entry.interaction;
      const templateKey =
        typeof item?.templateId === "string" && item.templateId.trim()
          ? item.templateId.trim()
          : item.id;
      const focusTargetKey =
        typeof focusTemplateId === "string" && focusTemplateId.trim()
          ? focusTemplateId.trim()
          : focusTemplateId;
      const isFocusTargetMatch =
        !!focusTargetKey && (templateKey === focusTargetKey || item?.id === focusTargetKey);
      const assignedGoalId = goalAssignments?.[templateKey] || goalAssignments?.[item.id];
      const assignedGoal = assignedGoalId ? wishesById[assignedGoalId] : null;
      const resolvedGoalLabel = resolveAssignedGoalLabel(assignedGoalId, assignedGoal);
      const wishlistEntry = swipePinnedByTemplate[item.id];
      const isWishlistGoal = !!wishlistEntry;
      const overrideDescription =
        (descriptionOverrides && descriptionOverrides[item.id]) || null;
      const resolvedDescriptionOverride =
        overrideDescription ||
        (item.id === mainTemptationId ? primaryTemptationDescription : null);
      const statsEntry = resolveCardRefuseStats(item);
      const isTutorialHighlightTarget = tutorialHighlightTemptationId === item.id;
      return (
        <TemptationCard
          item={item}
          language={language}
          colors={colors}
          t={t}
          allowThinkAction={allowThinkAction}
          descriptionOverride={resolvedDescriptionOverride}
          isFocusTarget={isFocusTargetMatch}
          onToggleEdit={() => onTemptationEditToggle?.(item)}
          currency={currency}
          stats={statsEntry}
          feedback={cardFeedback[item.id]}
          titleOverride={titleOverrides[item.id]}
          goalLabel={resolvedGoalLabel}
          isWishlistGoal={isWishlistGoal}
          isEditing={editingTemptationId === item.id}
          editTitleValue={editingTemptationId === item.id ? editingTitleValue : ""}
          editPriceValue={editingTemptationId === item.id ? editingPriceValue : ""}
          editGoalLabel={editingTemptationId === item.id ? editingGoalLabel : ""}
          editEmojiValue={editingTemptationId === item.id ? editingEmojiValue : ""}
          editDescriptionValue={editingTemptationId === item.id ? editingDescriptionValue : ""}
          editCategoryValue={
            editingTemptationId === item.id ? editingCategoryValue : DEFAULT_IMPULSE_CATEGORY
          }
          onEditTitleChange={onTemptationEditTitleChange}
          onEditPriceChange={onTemptationEditPriceChange}
          onEditEmojiChange={onTemptationEditEmojiChange}
          onEditDescriptionChange={onTemptationEditDescriptionChange}
          onEditCategoryChange={onTemptationEditCategoryChange}
          onEditSave={onTemptationEditSave}
          onEditCancel={onTemptationEditCancel}
          onEditDelete={() => onTemptationEditDelete?.(item)}
          onEditGoalSelect={() => onTemptationGoalSelect?.(item)}
          onSwipeDelete={() => onTemptationSwipeDelete?.(item)}
          onQuickGoalToggle={() => onTemptationQuickGoalToggle?.(item)}
          isPrimaryTemptation={item.id === mainTemptationId}
          onAction={async (type) => {
            await onTemptationAction(type, item);
          }}
          onFocusBadgePress={onFocusCancel}
          tutorialHighlightMode={isTutorialHighlightTarget ? tutorialTemptationStepId : null}
          tutorialHighlightMeasureTick={
            isTutorialHighlightTarget ? tutorialHighlightMeasureTick : 0
          }
          tutorialHighlightOffset={tutorialHighlightOffset}
          onTutorialHighlightLayoutChange={
            isTutorialHighlightTarget ? onTutorialHighlightLayoutChange : null
          }
          interaction={interactionEntry}
          timerNow={timerNow}
        />
      );
    },
    [
      cardFeedback,
      colors,
      currency,
      descriptionOverrides,
      editingCategoryValue,
      editingDescriptionValue,
      editingEmojiValue,
      editingGoalLabel,
      editingPriceValue,
      editingTemptationId,
      editingTitleValue,
      focusTemplateId,
      goalAssignments,
      language,
      mainTemptationId,
      onTemptationAction,
      onTemptationEditCancel,
      onTemptationEditDelete,
      onTemptationEditDescriptionChange,
      onTemptationEditEmojiChange,
      onTemptationEditPriceChange,
      onTemptationEditSave,
      onTemptationEditTitleChange,
      onTemptationEditToggle,
      onTemptationGoalSelect,
      onTemptationQuickGoalToggle,
      onTemptationSwipeDelete,
      onFocusCancel,
      primaryTemptationDescription,
      resolveCardRefuseStats,
      swipePinnedByTemplate,
      t,
      timerNow,
      titleOverrides,
      tutorialHighlightMeasureTick,
      tutorialHighlightOffset,
      resolveAssignedGoalLabel,
      wishesById,
      tutorialHighlightTemptationId,
      tutorialTemptationStepId,
      onTutorialHighlightLayoutChange,
    ]
  );
  const renderFeedItem = useCallback(
    ({ item: entry }) => {
      if (entry.type === "section") {
        const collapsed = !!frequencyCollapseMap[entry.sectionId];
        return (
          <FrequencySectionHeader
            title={entry.title}
            count={entry.count}
            collapsed={collapsed}
            onToggle={() => toggleFrequencySection(entry.sectionId)}
            colors={colors}
            t={t}
          />
        );
      }
      if (entry.type === "card") {
        return renderTemptationCard(entry);
      }
      return null;
    },
    [colors, frequencyCollapseMap, renderTemptationCard, t, toggleFrequencySection]
  );
  const analyticsPreview = analyticsStats.slice(0, 3);
  const { wishesById, swipePinnedByTemplate } = useMemo(() => {
    const byId = {};
    const swipePinned = {};
    (wishes || []).forEach((wish) => {
      if (wish?.id) {
        byId[wish.id] = wish;
      }
      if (wish?.templateId && wish?.pinnedSource === "swipe") {
        swipePinned[wish.templateId] = wish;
      }
    });
    return { wishesById: byId, swipePinnedByTemplate: swipePinned };
  }, [wishes]);

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: colors.background }] }>
      <FlatList
        ref={listRef}
        style={styles.feedList}
        data={feedEntries}
        keyExtractor={feedKeyExtractor}
        showsVerticalScrollIndicator={false}
        contentContainerStyle={styles.feedListContent}
        renderItem={renderFeedItem}
        initialNumToRender={6}
        maxToRenderPerBatch={6}
        windowSize={7}
        updateCellsBatchingPeriod={50}
        removeClippedSubviews={Platform.OS === "android"}
        ListEmptyComponent={
          <View style={styles.emptyState}>
            <Text style={[styles.emptyStateTitle, { color: colors.text }]}>{t("feedEmptyTitle")}</Text>
            <Text style={[styles.emptyStateText, { color: colors.muted }]}>{t("feedEmptySubtitle")}</Text>
          </View>
        }
        ListHeaderComponent={
          <View style={styles.feedHero} onLayout={handleHeroLayout}>
            <View style={styles.feedHeroTop}>
              <MoodGradientBlock colors={moodGradient} style={styles.heroMoodGradient}>
                <View
                  style={styles.heroMascotRow}
                  onLayout={(event) => setHeroRowWidth(event.nativeEvent.layout.width)}
                >
                  <View style={styles.heroTextWrap}>
                    <Text
                      style={[styles.appName, { color: colors.text }]}
                      onLayout={(event) => {
                        const { x, width } = event.nativeEvent.layout;
                        setHeroLogoRight(x + width);
                      }}
                    >
                      Almost
                    </Text>
                    <Text style={[styles.heroTagline, { color: colors.muted }]}>
                      {t("appTagline")}
                    </Text>
                  {moodPreset?.label && (
                    <TouchableOpacity
                      style={[styles.moodBadge, heroMoodBadgeStyle]}
                      onPress={onMoodDetailsOpen}
                    >
                      <Text style={[styles.moodBadgeText, { color: heroMoodBadgeTextColor }]}>
                        {moodPreset.label}
                      </Text>
                    </TouchableOpacity>
                  )}
                </View>
                {!hideMascot && (
                  <View style={styles.heroMascotContainer}>
                    {showTamagotchiBubble && (
                      <View pointerEvents="none" style={styles.mascotBubbleWrap}>
                        <View
                          style={[
                            styles.mascotBubble,
                            {
                              maxWidth: heroBubbleMaxWidth,
                              backgroundColor: tamagotchiBubbleTheme.backgroundColor,
                              borderColor: tamagotchiBubbleTheme.borderColor,
                              shadowColor: tamagotchiBubbleTheme.shadowColor,
                            },
                          ]}
                        >
                          <Text
                            style={[
                              styles.mascotBubbleText,
                              { color: tamagotchiBubbleTheme.textColor, maxWidth: heroBubbleTextMaxWidth },
                            ]}
                            numberOfLines={3}
                            ellipsizeMode="tail"
                          >
                            {tamagotchiSpeech}
                          </Text>
                          <View
                            style={[
                              styles.mascotBubbleTail,
                              { backgroundColor: tamagotchiBubbleTheme.backgroundColor },
                            ]}
                          />
                        </View>
                      </View>
                    )}
                    <TouchableOpacity onPress={onMascotPress} activeOpacity={0.9}>
                    <AlmiTamagotchi
                      style={heroMascotWrapStyle}
                      override={mascotOverride}
                      onOverrideComplete={onMascotAnimationComplete}
                      isStarving={tamagotchiMood?.tone === "urgent"}
                      animations={tamagotchiAnimations}
                    />
                    </TouchableOpacity>
                  </View>
                )}
              </View>
            </MoodGradientBlock>
          </View>
          <SavingsHeroCard
            goldPalette={goldPalette}
            isDarkMode={isDarkMode}
            heroSpendCopy={heroSpendCopy}
            heroRecentEvents={heroRecentEvents}
            heroEncouragementLine={heroEncouragementLine}
            onRecentEventsPress={openHistoryModal}
            levelLabel={levelLabel}
            playerLevel={playerLevel}
            totalSavedLabel={totalSavedLabel}
            progressPercent={progressPercent}
            progressPercentLabel={progressPercentLabel}
            goalProgressLabel={goalProgressLabel}
            isGoalComplete={isGoalComplete}
            completionLabel={t("goalWidgetComplete")}
            t={t}
            analyticsPreview={analyticsPreview}
            baselineMonthlyWasteUSD={baselineMonthlyWasteUSD}
            baselineStartAt={baselineStartAt}
            actualSavedUSD={realSavedUSD}
            potentialGrowthUSD={potentialGrowthUSD}
            showPotentialGrowth={showPotentialGrowth}
            currency={currency}
            hasBaseline={hasBaseline}
            hasActiveGoal={heroHasActiveGoal}
            onBaselineSetup={handleBaselineSetup}
            onPotentialDetailsOpen={handlePotentialDetailsOpen}
            levelHasNext={heroLevelHasNext}
            levelRemainingLabel={heroLevelRemainingLabel}
            levelTargetLabel={heroLevelTargetLabel}
            levelProgressValue={heroLevelProgress}
            healthPoints={healthPoints}
            onBreakdownPress={onSavingsBreakdownPress}
          dailyRewardUnlocked={dailyRewardUnlocked}
          dailyRewardReady={dailyRewardReady}
          dailyRewardAmount={dailyRewardAmount}
          dailyRewardBaseAmount={dailyRewardBaseAmount}
          dailyRewardDay={dailyRewardDay}
          onDailyRewardClaim={onDailyRewardClaim}
          onDailyRewardModalVisibilityChange={onDailyRewardModalVisibilityChange}
          activeChallenge={activeChallenge}
          onActiveChallengePress={onActiveChallengePress}
        />
          <View style={styles.feedTemptationHeader}>
            <Text style={[styles.feedTemptationTitle, { color: colors.text }]}>
              {t("tutorialFeedTitle")}
            </Text>
            <TouchableOpacity
                style={[
                  styles.feedTemptationAddButton,
                  { backgroundColor: colors.text, borderColor: colors.text },
                ]}
                onPress={onNewTemptation}
                activeOpacity={0.85}
              >
                <Text style={[styles.feedTemptationAddIcon, { color: colors.background }]}>+</Text>
              </TouchableOpacity>
            </View>
          </View>
        }
      />
      <HistoryModal
        visible={historyModalVisible}
        history={resolvedHistoryEvents}
        onClose={closeHistoryModal}
        onHistoryDelete={onHistoryDelete}
        t={t}
        colors={colors}
        currency={currency}
        language={language}
      />
    </SafeAreaView>
  );
})
);

const SwipeableGoalRow = ({
  children,
  colors,
  t,
  onEdit,
  onDelete,
  onSwipeOpen,
  onSwipeClose,
}) => {
  const translateX = useRef(new Animated.Value(0)).current;
  const ACTION_WIDTH = 160;
  const gestureStartOffset = useRef(0);
  const externalCloserRef = useRef(null);

  const closeRow = useCallback(
    (notify = true) => {
      Animated.timing(translateX, {
        toValue: 0,
        duration: 150,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }).start(() => {
        if (notify) {
          onSwipeClose?.(externalCloserRef.current);
          externalCloserRef.current = null;
        }
      });
    },
    [onSwipeClose, translateX]
  );

  const notifyOpen = useCallback(() => {
    const closer = () => closeRow();
    externalCloserRef.current = closer;
    onSwipeOpen?.(closer);
  }, [closeRow, onSwipeOpen]);

  const panResponder = useMemo(
    () =>
      PanResponder.create({
        onMoveShouldSetPanResponder: (_, gestureState) =>
          Math.abs(gestureState.dx) > Math.abs(gestureState.dy) && Math.abs(gestureState.dx) > 6,
        onPanResponderGrant: () => {
          translateX.stopAnimation((value) => {
            gestureStartOffset.current = value;
          });
        },
        onPanResponderMove: (_, gestureState) => {
          const base = gestureStartOffset.current || 0;
          const next = Math.max(0, Math.min(base + gestureState.dx, ACTION_WIDTH));
          translateX.setValue(next);
        },
        onPanResponderRelease: () => {
          translateX.stopAnimation((value) => {
            const shouldOpen = value > ACTION_WIDTH * 0.35;
            Animated.timing(translateX, {
              toValue: shouldOpen ? ACTION_WIDTH : 0,
              duration: 180,
              easing: Easing.out(Easing.quad),
              useNativeDriver: true,
            }).start(() => {
              if (shouldOpen) {
                notifyOpen();
              } else {
                closeRow();
              }
            });
          });
        },
        onPanResponderTerminate: () => {
          closeRow();
        },
      }),
    [ACTION_WIDTH, closeRow, notifyOpen, translateX]
  );

  const handleEdit = () => {
    closeRow();
    onEdit?.();
  };

  const handleDelete = () => {
    closeRow();
    onDelete?.();
  };

  return (
    <View style={[styles.goalSwipeRow, { backgroundColor: colors.background }]}>
      <View style={[styles.goalSwipeActions, { backgroundColor: colors.background }]}>
        <TouchableOpacity
          style={[styles.goalSwipeButton, !onEdit && styles.goalSwipeButtonDisabled]}
          onPress={handleEdit}
          disabled={!onEdit}
        >
          <Text style={[styles.goalSwipeButtonText, { color: colors.text }]}>{t("goalEditAction")}</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.goalSwipeButton, !onDelete && styles.goalSwipeButtonDisabled]}
          onPress={handleDelete}
          disabled={!onDelete}
        >
          <Text style={[styles.goalSwipeButtonText, { color: colors.text }]}>{t("goalDeleteAction")}</Text>
        </TouchableOpacity>
      </View>
      <Animated.View style={[styles.goalSwipeContent, { transform: [{ translateX }] }]} {...panResponder.panHandlers}>
        {children}
      </Animated.View>
    </View>
  );
};

const resolveWishEmoji = (wish) => {
  if (wish?.emoji) return wish.emoji;
  const title = (wish?.title || "").trim();
  if (title) {
    const firstChar = Array.from(title)[0];
    if (firstChar && !/[A-Za-zÐ-Ð¯Ð°-Ñ0-9]/.test(firstChar)) {
      return firstChar;
    }
  }
  return DEFAULT_GOAL_EMOJI;
};

const getWishTitleWithoutEmoji = (wish) => {
  const title = typeof wish?.title === "string" ? wish.title : "";
  if (!title) return "";
  const trimmed = title.trimStart();
  if (!trimmed) return "";
  const wishEmoji = resolveWishEmoji(wish);
  if (wishEmoji) {
    const emojiToken = wishEmoji.trim();
    if (emojiToken && trimmed.startsWith(emojiToken)) {
      return trimmed.slice(emojiToken.length).trimStart();
    }
  }
  const firstChar = Array.from(trimmed)[0];
  if (!firstChar) return trimmed;
  const isSymbol = !/[A-Za-zÐ-Ð¯Ð°-Ñ0-9]/.test(firstChar);
  if (isSymbol && wishEmoji) {
    const rest = Array.from(trimmed).slice(1).join("").trimStart();
    return rest || trimmed;
  }
  return trimmed;
};

const selectMainGoalWish = (wishes = [], activeGoalId = null) => {
  const list = Array.isArray(wishes) ? wishes : [];
  if (activeGoalId) {
    const pinned = list.find(
      (wish) =>
        wish?.goalId === activeGoalId ||
        wish?.id === activeGoalId
    );
    if (pinned) return pinned;
  }
  const primaryActive = list.find(
    (wish) => wish?.kind === PRIMARY_GOAL_KIND && wish.status !== "done"
  );
  if (primaryActive) return primaryActive;
  return list.find((wish) => wish?.status !== "done") || null;
};

const ProgressRing = React.memo(function ProgressRing({
  size = 76,
  strokeWidth = 8,
  progress = 0,
  trackColor = "rgba(0,0,0,0.08)",
  progressColor = "#111",
}) {
  const normalized = Math.min(Math.max(progress, 0), 1);
  const radius = (size - strokeWidth) / 2;
  const circumference = 2 * Math.PI * radius;
  const dashOffset = circumference * (1 - normalized);
  return (
    <Svg width={size} height={size}>
      <SvgCircle
        cx={size / 2}
        cy={size / 2}
        r={radius}
        stroke={trackColor}
        strokeWidth={strokeWidth}
        fill="none"
      />
      <SvgCircle
        cx={size / 2}
        cy={size / 2}
        r={radius}
        stroke={progressColor}
        strokeWidth={strokeWidth}
        fill="none"
        strokeDasharray={`${circumference} ${circumference}`}
        strokeDashoffset={dashOffset}
        strokeLinecap="round"
        transform={`rotate(-90 ${size / 2} ${size / 2})`}
      />
    </Svg>
  );
});

const ChallengeProgressDots = React.memo(function ChallengeProgressDots({
  total = 0,
  progress = 0,
  colors,
}) {
  const count = Math.max(0, Math.round(total));
  if (!count) return null;
  return (
    <View style={styles.challengeDotRow}>
      {Array.from({ length: count }).map((_, index) => {
        const filled = index < progress;
        return (
          <View
            key={`dot-${index}`}
            style={[
              styles.challengeDot,
              {
                borderColor: filled ? colors.text : colors.border,
                backgroundColor: filled ? colors.text : "transparent",
              },
            ]}
          >
            {filled ? (
              <Text style={[styles.challengeDotCheck, { color: colors.background }]}>âœ“</Text>
            ) : null}
          </View>
        );
      })}
    </View>
  );
});

const ProgressScreen = React.memo(function ProgressScreen({
  wishes,
  currency = DEFAULT_PROFILE.currency,
  t,
  colors,
  onRemoveWish,
  primaryGoals = [],
  onGoalLongPress = null,
  onGoalEdit = null,
  activeGoalId = null,
  onSetActiveGoal = null,
  language = DEFAULT_LANGUAGE,
  catCuriousSource,
  healthPoints = 0,
  freeDayStats = INITIAL_FREE_DAY_STATS,
  onFreeDayLog,
  onFreeDayRescue,
  freeDayRescueCost = FREE_DAY_RESCUE_COST,
  historyEvents = [],
  impulseInsights,
  showImpulseMap = false,
  showFreeDayCard = false,
  challenges = [],
  dailyChallenge = null,
  onChallengeAccept = () => {},
  onChallengeClaim = () => {},
  onChallengeCancel = () => {},
  onCreateGoal = () => {},
  onFocusCancel = null,
  focusChallengeId = null,
  onFocusHandled = () => {},
  challengeBadges = [],
  challengeBadgeCount = 0,
  playerLevel = 1,
  resolveTemplateCard = null,
  resolveTemptationCategory = null,
  customCategories = [],
  onWeeklySpendPress = null,
}) {
  const isDarkTheme = colors.background === THEMES.dark.background;
  const [impulseExpanded, setImpulseExpanded] = useState(false);
  const handleImpulseToggle = useCallback(() => {
    setImpulseExpanded((prev) => !prev);
  }, []);
  const primaryGoalIds = Array.isArray(primaryGoals)
    ? primaryGoals.map((goal) => goal?.id).filter(Boolean)
    : [];
  useEffect(() => {
    const primaryEntries = (wishes || []).filter((wish) => wish?.kind === PRIMARY_GOAL_KIND);
    if (primaryEntries.length) {
      const summary = primaryEntries.map((wish) => ({
        id: wish.id,
        goalId: wish.goalId,
        savedUSD: wish.savedUSD,
        targetUSD: wish.targetUSD,
        status: wish.status,
      }));
      console.warn("primary_goal_wishlist_state", summary);
    }
  }, [wishes]);
  const listData = useMemo(() => {
    if (!Array.isArray(wishes)) return [];
    return wishes
      .map((wish, index) => ({ wish, index }))
      .sort((a, b) => {
        const aDone = a.wish?.status === "done";
        const bDone = b.wish?.status === "done";
        if (aDone === bDone) {
          return a.index - b.index;
        }
        return aDone ? 1 : -1;
      })
      .map((entry) => entry.wish);
  }, [wishes]);
  const swipeCloserRef = useRef(null);
  const handleSwipeOpen = useCallback((closeFn) => {
    if (swipeCloserRef.current && swipeCloserRef.current !== closeFn) {
      swipeCloserRef.current();
    }
    swipeCloserRef.current = closeFn;
  }, []);
  const handleSwipeClose = useCallback((closeFn) => {
    if (!closeFn || swipeCloserRef.current === closeFn) {
      swipeCloserRef.current = null;
    }
  }, []);
  const totalTarget = formatCurrency(
    convertToCurrency(listData.reduce((sum, wish) => sum + (wish.targetUSD || 0), 0), currency),
    currency
  );
  const resolvedActiveGoalId = activeGoalId || primaryGoalIds[0] || null;
  const activeGoalEntry = Array.isArray(primaryGoals)
    ? primaryGoals.find((goal) => goal?.id === resolvedActiveGoalId)
    : null;
  const activeGoalWish = listData.find((wish) => (wish.goalId || wish.id) === resolvedActiveGoalId) || null;
  const goalPreset = resolvedActiveGoalId ? getGoalPreset(resolvedActiveGoalId) : null;
  const goalTitle = activeGoalWish
    ? getWishTitleWithoutEmoji(activeGoalWish)
    : activeGoalEntry?.customTitle
    ? activeGoalEntry.customTitle
    : resolvedActiveGoalId
    ? goalPreset?.[language] || goalPreset?.en || ""
    : t("wishlistEmptyTitle");
  const goalEmoji =
    activeGoalWish?.emoji ||
    (activeGoalWish ? resolveWishEmoji(activeGoalWish) : null) ||
    activeGoalEntry?.customEmoji ||
    goalPreset?.emoji ||
    "ðŸŽ¯";
  const goalTargetUSD =
    Number.isFinite(activeGoalEntry?.targetUSD) && activeGoalEntry.targetUSD > 0
      ? activeGoalEntry.targetUSD
      : activeGoalWish?.targetUSD || (resolvedActiveGoalId ? getGoalDefaultTargetUSD(resolvedActiveGoalId) : 0);
  const goalSavedUSD = Number.isFinite(activeGoalEntry?.savedUSD)
    ? Math.max(activeGoalEntry.savedUSD, 0)
    : Math.max(activeGoalWish?.savedUSD || 0, 0);
  const goalProgress = goalTargetUSD > 0 ? Math.min(goalSavedUSD / goalTargetUSD, 1) : 0;
  const goalTargetLabel = formatCurrency(convertToCurrency(goalTargetUSD || 0, currency), currency);
  const goalRemainingLabel = formatCurrency(
    convertToCurrency(Math.max(goalTargetUSD - goalSavedUSD, 0), currency),
    currency
  );
  const coinEntries = useMemo(() => buildHealthCoinEntries(healthPoints), [healthPoints]);
  const hasCoinInventory = coinEntries.some((entry) => entry.count > 0);
  const activeChallenges = challenges.filter(
    (entry) => entry.status === CHALLENGE_STATUS.ACTIVE
  );
  const bestActiveChallenge = activeChallenges.reduce((best, current) => {
    if (!best) return current;
    if ((current.progressPercent || 0) > (best.progressPercent || 0)) return current;
    if ((current.progressPercent || 0) < (best.progressPercent || 0)) return best;
    return (current.progressValue || 0) >= (best.progressValue || 0) ? current : best;
  }, null);
  const activeChallenge = bestActiveChallenge || null;
  const activeChallengeIsAmount = activeChallenge ? !activeChallenge.isCountMetric : false;
  const activeChallengeProgressValue = activeChallenge?.progressValue || 0;
  const activeChallengeTargetValue = activeChallenge?.targetValue || 0;
  const activeChallengePercent =
    activeChallenge && activeChallengeTargetValue
      ? Math.min(activeChallengeProgressValue / activeChallengeTargetValue, 1)
      : 0;
  const activeChallengeActionEnabled =
    activeChallenge?.canClaim || activeChallenge?.canStart || false;
  const dailyChallengeRewardLabel = useMemo(() => {
    const bonus = Number(dailyChallenge?.rewardBonus) || 0;
    return formatHealthRewardLabel(bonus * 2, language);
  }, [dailyChallenge?.rewardBonus, language]);

  const resolvedHistoryEvents = useMemo(
    () => (Array.isArray(historyEvents) ? historyEvents : []),
    [historyEvents]
  );
  const scrollRef = useRef(null);
  const challengeSwipeCloserRef = useRef(null);
  const handleChallengeSwipeOpen = useCallback((closeFn) => {
    if (challengeSwipeCloserRef.current && challengeSwipeCloserRef.current !== closeFn) {
      challengeSwipeCloserRef.current();
    }
    challengeSwipeCloserRef.current = closeFn;
  }, []);
  const handleChallengeSwipeClose = useCallback((closeFn) => {
    if (!closeFn || challengeSwipeCloserRef.current === closeFn) {
      challengeSwipeCloserRef.current = null;
    }
  }, []);
  const closeChallengeSwipe = useCallback(() => {
    if (challengeSwipeCloserRef.current) {
      challengeSwipeCloserRef.current();
    }
  }, []);
  const challengeLayoutsRef = useRef({});
  const registerChallengeLayout = useCallback(
    (challengeId, event) => {
      if (!challengeId || !event?.nativeEvent?.layout) return;
      const layout = event.nativeEvent.layout;
      challengeLayoutsRef.current[challengeId] = layout;
      if (focusChallengeId && challengeId === focusChallengeId && scrollRef.current) {
        const targetY = Math.max(layout.y - 16, 0);
        scrollRef.current.scrollTo({ y: targetY, animated: true });
        onFocusHandled?.();
      }
    },
    [focusChallengeId, onFocusHandled]
  );
  const freeDayEventKeys = useMemo(() => {
    const keys = new Set();
    resolvedHistoryEvents.forEach((entry) => {
      if (entry.kind === "free_day") {
        keys.add(getDayKey(entry.timestamp));
      }
    });
    return keys;
  }, [resolvedHistoryEvents]);
  const todayDate = new Date();
  const todayTimestamp = todayDate.getTime();
  const todayKey = getDayKey(todayDate);
  const dayBeforeYesterdayKey = getDayKey(new Date(todayDate.getTime() - DAY_MS * 2));
  const freeDayBlockedToday = freeDayStats?.blockedDate === todayKey;
  const isEvening = new Date().getHours() >= 18;
  const canLogFreeDay = isEvening && freeDayStats?.lastDate !== todayKey && !freeDayBlockedToday;
  const streakNeedsRescue =
    (freeDayStats?.current || 0) > 0 &&
    freeDayStats?.lastDate === dayBeforeYesterdayKey &&
    freeDayStats?.lastDate !== todayKey;
  const hasRescueHealth = healthPoints >= freeDayRescueCost;
  const canRescueFreeDay = streakNeedsRescue && hasRescueHealth;
  const rescueStatus = !streakNeedsRescue
    ? null
    : !hasRescueHealth
    ? t("freeDayRescueNeedHealth", { cost: freeDayRescueCost })
    : null;
  const weekLabels = WEEKDAY_LABELS_MONDAY_FIRST[language] || WEEKDAY_LABELS_MONDAY_FIRST.en;
  const weekDays = useMemo(() => {
    const today = new Date(todayTimestamp);
    const start = new Date(today);
    const weekday = (today.getDay() + 6) % 7;
    start.setDate(today.getDate() - weekday);
    return Array.from({ length: 7 }).map((_, index) => {
      const date = new Date(start);
      date.setDate(start.getDate() + index);
      const key = getDayKey(date);
      return {
        key,
        label: weekLabels[index],
        active: freeDayEventKeys.has(key),
        isToday: key === todayKey,
      };
    });
  }, [freeDayEventKeys, todayTimestamp, todayKey, weekLabels]);
  const weekSuccessCount = useMemo(
    () => weekDays.filter((day) => day.active).length,
    [weekDays]
  );
  const categoryData = useMemo(() => {
    const categories = IMPULSE_CATEGORY_ORDER.map((id, index) => {
      const entry = impulseInsights?.categories?.[id] || { save: 0, spend: 0 };
      const total = (entry.save || 0) + (entry.spend || 0);
      return {
        id,
        orderIndex: index,
        label: getImpulseCategoryLabel(id, language),
        save: entry.save || 0,
        spend: entry.spend || 0,
        total,
      };
    });
    const maxTotal = categories.reduce((max, entry) => Math.max(max, entry.total || 0), 0);
    const sorted = [...categories].sort((a, b) => {
      if (b.total !== a.total) return b.total - a.total;
      return a.orderIndex - b.orderIndex;
    });
    return { categories: sorted, maxTotal: Math.max(maxTotal, 1) };
  }, [customCategories, impulseInsights?.categories, language]);
  const categoryListHeight = useMemo(() => 64 * 5, []);
  const weeklyComparison = useMemo(() => {
    const today = new Date(todayTimestamp);
    const currentStart = new Date(today);
    currentStart.setDate(today.getDate() - 6);
    const prevStart = new Date(currentStart);
    prevStart.setDate(currentStart.getDate() - 7);
    const currentRange = { start: currentStart.getTime(), end: today.getTime() };
    const prevRange = { start: prevStart.getTime(), end: currentStart.getTime() - 1 };
    let currentSavings = 0;
    let currentSpending = 0;
    let prevSavings = 0;
    let prevSpending = 0;
    resolvedHistoryEvents.forEach((entry) => {
      const timestamp = entry?.timestamp;
      if (!timestamp) return;
      const amount = Math.max(0, Number(entry?.meta?.amountUSD) || 0);
      if (!amount) return;
      if (timestamp >= currentRange.start && timestamp <= currentRange.end) {
        if (entry.kind === "refuse_spend") {
          currentSavings += amount;
        } else if (entry.kind === "spend") {
          currentSpending += amount;
        }
      } else if (timestamp >= prevRange.start && timestamp <= prevRange.end) {
        if (entry.kind === "refuse_spend") {
          prevSavings += amount;
        } else if (entry.kind === "spend") {
          prevSpending += amount;
        }
      }
    });
    const buildDelta = (current, previous) => {
      const deltaUSD = current - previous;
      return {
        deltaUSD,
        previous,
      };
    };
    return {
      savings: buildDelta(currentSavings, prevSavings),
      spending: buildDelta(currentSpending, prevSpending),
      currentSavings,
      currentSpending,
    };
  }, [resolvedHistoryEvents, todayTimestamp]);
  const weeklyTrend = useMemo(() => {
    const formatEntry = (entry, type) => {
      const delta = Number(entry?.deltaUSD) || 0;
      const absDelta = Math.abs(delta);
      const localValue = formatCurrency(convertToCurrency(absDelta, currency), currency);
      const symbol = delta >= 0 ? "â–²" : "â–¼";
      let color = SAVE_ACTION_COLOR;
      if (type === "savings") {
        color = delta >= 0 ? SAVE_ACTION_COLOR : SPEND_ACTION_COLOR;
      } else {
        color = delta >= 0 ? SPEND_ACTION_COLOR : SAVE_ACTION_COLOR;
      }
      return {
        symbol,
        label: localValue,
        color,
      };
    };
    const base = weeklyComparison || {};
    const savingsTrend = formatEntry(base.savings, "savings");
    const spendingTrend = formatEntry(base.spending, "spending");
    return { savings: savingsTrend, spending: spendingTrend };
  }, [currency, weeklyComparison]);
  const weeklyDailySavings = useMemo(() => {
    const today = new Date(todayTimestamp);
    const start = new Date(today);
    start.setDate(today.getDate() - 6);
    const minTimestamp = start.getTime();
    const map = new Map();
    resolvedHistoryEvents.forEach((entry) => {
      if (!entry.timestamp || entry.timestamp < minTimestamp) return;
      if (entry.kind !== "refuse_spend" && entry.kind !== "spend") return;
      const amount = Math.max(0, Number(entry.meta?.amountUSD) || 0);
      if (!amount) return;
      const key = getDayKey(entry.timestamp);
      const current = map.get(key) || { saveUSD: 0, spendUSD: 0 };
      if (entry.kind === "refuse_spend") {
        current.saveUSD += amount;
      } else {
        current.spendUSD += amount;
      }
      map.set(key, current);
    });
    let maxSave = 0;
    const baseItems = Array.from({ length: 7 }).map((_, index) => {
      const date = new Date(start);
      date.setDate(start.getDate() + index);
      const key = getDayKey(date);
      const stats = map.get(key) || { saveUSD: 0, spendUSD: 0 };
      const saveUSD = stats.saveUSD || 0;
      const spendUSD = stats.spendUSD || 0;
      if (saveUSD > maxSave) maxSave = saveUSD;
      const weekdayIndex = (date.getDay() + 6) % 7;
      const label =
        WEEKDAY_LABELS_MONDAY_FIRST[language]?.[weekdayIndex] ||
        WEEKDAY_LABELS_MONDAY_FIRST.en[weekdayIndex];
      const saveLocal = convertToCurrency(saveUSD, currency);
      const spendLocal = convertToCurrency(spendUSD, currency);
      const amountLabel = saveUSD ? formatCurrency(saveLocal, currency) : formatCurrency(0, currency);
      const spendLabel = spendUSD ? `-${formatCurrency(spendLocal, currency)}` : formatCurrency(0, currency);
      const amountParts = splitCurrencyLabel(amountLabel, currency);
      const spendParts = splitCurrencyLabel(spendLabel, currency);
      const amountValueLabel =
        amountParts.value && typeof amountParts.value === "string"
          ? amountParts.value.replace(/ /g, "\u00A0")
          : amountParts.value;
      const spendValueLabel =
        spendParts.value && typeof spendParts.value === "string"
          ? spendParts.value.replace(/ /g, "\u00A0")
          : spendParts.value;
      return {
        key,
        label,
        amountUSD: saveUSD,
        saveUSD,
        spendUSD,
        amountLabel,
        amountValueLabel,
        amountCurrencySymbol: amountParts.symbol,
        spendLabel,
        spendValueLabel,
        spendCurrencySymbol: spendParts.symbol,
      };
    });
    const maxValue = Math.max(maxSave, 0.01);
    return baseItems.map((item) => {
      const percent = item.saveUSD > 0 ? Math.max((item.saveUSD / maxValue) * 100, 8) : 0;
      const spendPercent =
        item.saveUSD > 0 && item.spendUSD > 0
          ? Math.min(percent, Math.max((item.spendUSD / item.saveUSD) * percent, 2))
          : 0;
      return {
        ...item,
        percent,
        spendPercent,
        spendOverflow: item.spendUSD > item.saveUSD,
      };
    });
  }, [currency, language, resolvedHistoryEvents, todayTimestamp]);
  const weeklyCardPalette = isDarkTheme
    ? {
        background: "rgba(18,22,34,0.92)",
        border: "rgba(255,255,255,0.12)",
        text: "#F2F5FF",
        subtext: "rgba(242,245,255,0.62)",
        track: "rgba(255,255,255,0.08)",
        save: "#6BE2A1",
        spend: "#FF8F9A",
      }
    : {
        background: "#FFFFFF",
        border: "rgba(0,0,0,0.08)",
        text: "#2A1C00",
        subtext: "rgba(42,28,0,0.6)",
        track: "rgba(0,0,0,0.06)",
        save: SAVE_ACTION_COLOR,
        spend: SPEND_ACTION_COLOR,
      };
  const weeklyHasData = useMemo(
    () => weeklyDailySavings.some((day) => (day.amountUSD || 0) > 0 || (day.spendUSD || 0) > 0),
    [weeklyDailySavings]
  );
  const WeeklyCardWrap = onWeeklySpendPress ? TouchableOpacity : View;

  const renderWithLongPress = useCallback(
    (wish, content) => {
      if (typeof onGoalLongPress === "function") {
        return (
          <TouchableOpacity
            activeOpacity={0.96}
            delayLongPress={320}
            onLongPress={() => onGoalLongPress(wish)}
          >
            {content}
          </TouchableOpacity>
        );
      }
      return content;
    },
    [onGoalLongPress]
  );

  const renderWishRow = useCallback(
    ({ item: wish }) => {
        const targetLocal = formatCurrency(
          convertToCurrency(wish.targetUSD || 0, currency),
          currency
        );
        const progress = Math.min((wish.savedUSD || 0) / (wish.targetUSD || 1), 1);
        const progressLabel = t("wishlistProgress", {
          current: formatCurrency(convertToCurrency(wish.savedUSD || 0, currency), currency),
          target: targetLocal,
        });
        const isPrimaryGoal = wish.kind === PRIMARY_GOAL_KIND;
        const goalId = wish.goalId || wish.id;
        const isActiveGoal = !!activeGoalId && activeGoalId === goalId;
        const badgeText = isPrimaryGoal
          ? isActiveGoal
            ? t("goalPrimaryBadge")
            : t("goalPrimaryBadge")
          : wish.status === "done"
          ? t("wishlistDoneLabel")
          : `${Math.round(progress * 100)}%`;
        const remainingUSD = Math.max((wish.targetUSD || 0) - (wish.savedUSD || 0), 0);
        const remainingLabel = formatCurrency(convertToCurrency(remainingUSD, currency), currency);
        const displayTitle = getWishTitleWithoutEmoji(wish);
        if (isPrimaryGoal) {
          const preset = getGoalPreset(wish.goalId || primaryGoalIds[0]);
          const emblem = wish.emoji || resolveWishEmoji(wish) || preset?.emoji || "ðŸŽ¯";
          const secondaryColor = isDarkTheme
            ? "rgba(14,15,22,0.65)"
            : "rgba(246,247,251,0.8)";
          const badgeStyle = isDarkTheme
            ? {
                borderColor: "rgba(14,15,22,0.25)",
                backgroundColor: "rgba(14,15,22,0.08)",
              }
            : {
                borderColor: "rgba(246,247,251,0.35)",
                backgroundColor: "rgba(246,247,251,0.15)",
              };
          const trackColor = isDarkTheme
            ? "rgba(14,15,22,0.15)"
            : "rgba(246,247,251,0.2)";
          const fillColor = isDarkTheme
            ? "rgba(14,15,22,0.85)"
            : "rgba(246,247,251,0.95)";
          const cardContent = (
            <View
              style={[
                styles.primaryGoalCard,
                {
                  backgroundColor: colors.text,
                  borderColor: isActiveGoal ? GOAL_HIGHLIGHT_COLOR : colors.text,
                  borderWidth: isActiveGoal ? 2 : 0,
                },
              ]}
            >
              <View style={styles.primaryGoalTop}>
                <View style={{ flex: 1, gap: 8 }}>
                  <View
                    style={[
                      styles.primaryGoalBadge,
                      badgeStyle,
                    ]}
                  >
                    <Text style={[styles.primaryGoalBadgeText, { color: colors.background }]}>
                      {t("goalPrimaryBadge")}
                    </Text>
                  </View>
                  <Text style={[styles.primaryGoalTitle, { color: colors.background }]}>
                    {displayTitle}
                  </Text>
                </View>
                <View
                  style={[
                    styles.primaryGoalEmblem,
                    {
                      borderColor: badgeStyle.borderColor,
                      backgroundColor: badgeStyle.backgroundColor,
                    },
                  ]}
                >
                  <Text style={{ fontSize: 30 }}>{emblem}</Text>
                </View>
              </View>
              <Text style={[styles.primaryGoalSubtitle, { color: secondaryColor }]}>
                {t("primaryGoalRemaining", { amount: remainingLabel })}
              </Text>
              <Text style={[styles.primaryGoalSubtitle, { color: secondaryColor }]}>
                {progressLabel}
              </Text>
              <View style={styles.primaryGoalProgressRow}>
                <View
                  style={[
                    styles.primaryGoalProgressTrack,
                    {
                      backgroundColor: trackColor,
                    },
                  ]}
                >
                  <View
                    style={[
                      styles.primaryGoalProgressFill,
                      {
                        width: `${progress * 100}%`,
                        backgroundColor: fillColor,
                      },
                    ]}
                  />
                </View>
                <Text style={[styles.primaryGoalPercent, { color: colors.background }]}>
                  {`${Math.round(progress * 100)}%`}
                </Text>
              </View>
              <TouchableOpacity
                style={[
                  styles.goalSelectButton,
                  {
                    borderColor: isActiveGoal ? GOAL_HIGHLIGHT_COLOR : colors.border,
                    backgroundColor: isActiveGoal ? "rgba(246,193,107,0.15)" : colors.card,
                  },
                ]}
                activeOpacity={0.9}
                onPress={() => onSetActiveGoal?.(goalId)}
              >
                <Text
                  style={[
                    styles.goalSelectText,
                    { color: isActiveGoal ? GOAL_HIGHLIGHT_COLOR : colors.text },
                  ]}
                >
                  {isActiveGoal
                    ? (language || DEFAULT_LANGUAGE) === "ru"
                      ? "ÐÐºÑ‚Ð¸Ð²Ð½Ð°Ñ Ñ†ÐµÐ»ÑŒ"
                      : "Active goal"
                    : (language || DEFAULT_LANGUAGE) === "ru"
                    ? "Ð¡Ð´ÐµÐ»Ð°Ñ‚ÑŒ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð¾Ð¹"
                    : "Set active"}
                </Text>
              </TouchableOpacity>
            </View>
          );
          return (
            <SwipeableGoalRow
              colors={colors}
              t={t}
              onEdit={onGoalEdit ? () => onGoalEdit(wish) : undefined}
              onDelete={() => onRemoveWish(wish.id)}
              onSwipeOpen={handleSwipeOpen}
              onSwipeClose={handleSwipeClose}
            >
              {renderWithLongPress(wish, cardContent)}
            </SwipeableGoalRow>
          );
        }
        const wishEmoji = resolveWishEmoji(wish);
        const wishTitle = displayTitle;
        const cardContent = (
          <View
            style={[
              styles.wishCard,
              {
                backgroundColor: colors.card,
                borderColor: isActiveGoal ? GOAL_HIGHLIGHT_COLOR : colors.border,
                borderWidth: isActiveGoal ? 2 : 1,
              },
            ]}
          >
            <View style={styles.wishHeader}>
              <View style={styles.wishTitleWrap}>
                <Text style={[styles.wishEmoji, { color: colors.text }]}>{wishEmoji}</Text>
                <View style={{ flex: 1 }}>
                  <Text style={[styles.wishTitle, { color: colors.text }]}>{wishTitle}</Text>
                  <Text style={[styles.wishSavedHint, { color: colors.muted }]}>
                    {t("wishlistSavedHint")}
                  </Text>
                </View>
              </View>
              <View
                style={[
                  styles.wishBadge,
                  {
                    borderColor: isDarkTheme ? "rgba(255,255,255,0.18)" : "rgba(0,0,0,0.08)",
                    backgroundColor: isDarkTheme ? "rgba(255,255,255,0.08)" : "rgba(0,0,0,0.04)",
                  },
                ]}
              >
                <Text style={[styles.wishBadgeText, { color: colors.text }]}>{badgeText}</Text>
              </View>
            </View>
            <Text style={[styles.pendingPrice, { color: colors.text }]}>{targetLocal}</Text>
            <View style={styles.wishProgressRow}>
              <View style={[styles.wishProgressTrack, { backgroundColor: colors.border }]}>
                <View
                  style={[
                    styles.wishProgressFill,
                    {
                      width: `${progress * 100}%`,
                      backgroundColor: colors.text,
                    },
                  ]}
                />
              </View>
              <Text style={[styles.wishProgressLabel, { color: colors.muted }]}>{progressLabel}</Text>
            </View>
            <View style={styles.pendingButtons}>
              <TouchableOpacity
                style={[styles.pendingButtonPrimary, { backgroundColor: colors.text }]}
                onPress={() => {
                  if (!isActiveGoal) {
                    onSetActiveGoal?.(goalId);
                  }
                }}
                disabled={isActiveGoal}
              >
                <Text style={[styles.pendingButtonPrimaryText, { color: colors.background }]}>
                  {isActiveGoal ? t("wishlistActive") : t("wishlistSetActive")}
                </Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.pendingButtonSecondary, { borderColor: colors.border }]}
                onPress={() => onRemoveWish(wish.id)}
              >
                <Text style={{ color: colors.muted }}>{t("wishlistRemove")}</Text>
              </TouchableOpacity>
            </View>
          </View>
        );
        return (
          <SwipeableGoalRow
            colors={colors}
            t={t}
            onEdit={onGoalEdit ? () => onGoalEdit(wish) : undefined}
            onDelete={() => onRemoveWish(wish.id)}
            onSwipeOpen={handleSwipeOpen}
            onSwipeClose={handleSwipeClose}
          >
            {renderWithLongPress(wish, cardContent)}
          </SwipeableGoalRow>
        );
      },
      [
        activeGoalId,
        colors,
        currency,
        handleSwipeClose,
        handleSwipeOpen,
        isDarkTheme,
        onGoalEdit,
        onGoalLongPress,
        onRemoveWish,
        primaryGoalIds,
        renderWithLongPress,
        t,
      ]
    );

  const renderChallengeCard = useCallback(
    (challenge) => {
      const actionPalette = challenge.canClaim
        ? { background: SAVE_ACTION_COLOR, text: "#fff" }
        : challenge.canStart
        ? { background: colors.text, text: colors.background }
        : { background: colors.border, text: colors.muted };
      const confirmAccept = () => {
        Alert.alert(
          t("challengeAcceptConfirmTitle"),
          t("challengeAcceptConfirmMessage", { title: challenge.title }),
          [
            { text: t("challengeAcceptConfirmNo"), style: "cancel" },
            {
              text: t("challengeAcceptConfirmYes"),
              style: "default",
              onPress: () => onChallengeAccept?.(challenge.id),
            },
          ]
        );
      };
      const confirmCancel = () => {
        Alert.alert(
          t("challengeCancelConfirmTitle"),
          t("challengeCancelConfirmMessage", { title: challenge.title }),
          [
            { text: t("challengeCancelConfirmNo"), style: "cancel" },
            {
              text: t("challengeCancelConfirmYes"),
              style: "destructive",
              onPress: () => onChallengeCancel?.(challenge.id),
            },
          ]
        );
      };
      const handleActionPress = () => {
        if (challenge.canClaim) {
          onChallengeClaim?.(challenge.id);
        } else if (challenge.canStart) {
          confirmAccept();
        }
      };
      const isActionEnabled = challenge.canClaim || challenge.canStart;
      const isSwipeEnabled = challenge.status === CHALLENGE_STATUS.ACTIVE;
      const isCountMetric = challenge.isCountMetric;
      const isLocked = challenge.isLevelLocked;
      const cardBody = (
        <View
          style={[
            styles.challengeCard,
            { backgroundColor: colors.card, borderColor: colors.border },
            isLocked && styles.challengeCardLocked,
          ]}
          onLayout={(event) => registerChallengeLayout(challenge.id, event)}
        >
          <View
            style={[
              styles.challengeRewardChip,
              styles.challengeRewardChipFloating,
              { backgroundColor: colors.text },
            ]}
          >
            <HealthRewardTokens
              amount={challenge.rewardHealth}
              color={colors.background}
              iconSize={12}
              maxItems={2}
              textSize={10}
              rowStyle={styles.healthRewardTokenRowCompact}
            />
          </View>
          <View style={styles.challengeHeader}>
            <Text style={styles.challengeEmoji}>{challenge.emoji}</Text>
            <View style={{ flex: 1, gap: 4 }}>
              <Text
                style={[styles.challengeTitle, { color: colors.text }]}
                numberOfLines={2}
                adjustsFontSizeToFit
                minimumFontScale={0.9}
              >
                {challenge.title}
              </Text>
              <Text style={[styles.challengeDesc, { color: colors.muted }]} numberOfLines={3}>
                {challenge.description}
              </Text>
              {challenge.potentialSavingsLabel ? (
                <Text style={[styles.challengePotential, { color: colors.text }]}>
                  {t("challengePotentialSavings", { amount: challenge.potentialSavingsLabel })}
                </Text>
              ) : null}
            </View>
          </View>
          <View style={styles.challengeMetaRow}>
            <Text style={[styles.challengeStatus, { color: colors.muted }]}>{challenge.statusLabel}</Text>
            <Text style={[styles.challengeTimer, { color: colors.muted }]}>{challenge.timerLabel}</Text>
          </View>
          {isCountMetric ? (
            <ChallengeProgressDots total={challenge.targetValue} progress={challenge.progressValue} colors={colors} />
          ) : (
            <View style={[styles.challengeProgressBar, { backgroundColor: colors.border }]}>
              <View
                style={[
                  styles.challengeProgressFill,
                  { width: `${challenge.progressPercent * 100}%`, backgroundColor: colors.text },
                ]}
              />
            </View>
          )}
          <Text style={[styles.challengeProgressLabel, { color: colors.muted }]}>{challenge.progressLabel}</Text>
          {isLocked ? (
            <View style={styles.challengeLockRow}>
              <Text style={[styles.challengeLockText, { color: colors.muted }]}>
                {t("challengeLockedLevel", { level: challenge.unlockLevel || playerLevel })}
              </Text>
            </View>
          ) : (
            <TouchableOpacity
              style={[styles.challengeActionButton, { backgroundColor: actionPalette.background }]}
              activeOpacity={0.9}
              disabled={!isActionEnabled}
              onPress={handleActionPress}
            >
              <Text style={[styles.challengeActionText, { color: actionPalette.text }]}>
                {challenge.actionLabel}
              </Text>
            </TouchableOpacity>
          )}
        </View>
      );
      if (isSwipeEnabled) {
        return (
          <SwipeableChallengeCard
            key={challenge.id}
            colors={colors}
            cancelLabel={t("challengeCancelAction")}
            onCancel={confirmCancel}
            onSwipeOpen={handleChallengeSwipeOpen}
            onSwipeClose={handleChallengeSwipeClose}
          >
            {cardBody}
          </SwipeableChallengeCard>
        );
      }
      return (
        <View key={challenge.id}>
          {cardBody}
        </View>
      );
    },
    [
      colors,
      handleChallengeSwipeClose,
      handleChallengeSwipeOpen,
      onChallengeAccept,
      onChallengeCancel,
      onChallengeClaim,
      playerLevel,
      registerChallengeLayout,
      t,
    ]
  );
  const renderDailyChallengeWidget = useCallback(() => {
    if (!dailyChallenge) return null;
    const progress = Math.min(
      Math.max(Number(dailyChallenge.progress) || 0, 0),
      Number(dailyChallenge.target) || 1
    );
    const target = Math.max(Number(dailyChallenge.target) || 1, 1);
    const rewardLabel = dailyChallengeRewardLabel;
    const percent = Math.min(Math.max(progress / target, 0), 1);
    const widgetBackground = isDarkTheme ? "rgba(255,255,255,0.05)" : "#FFF7EA";
    const widgetBorder = isDarkTheme ? "rgba(255,255,255,0.15)" : "rgba(0,0,0,0.06)";
    return (
      <View
        style={[
          styles.dailyChallengeWidget,
          { backgroundColor: widgetBackground, borderColor: widgetBorder },
        ]}
      >
        <View style={styles.dailyChallengeWidgetHeader}>
          <View style={[styles.dailyChallengeBadge, { borderColor: widgetBorder }]}>
            <Text style={[styles.dailyChallengeBadgeText, { color: colors.text }]}>
              {t("dailyChallengeWidgetBadge")}
            </Text>
          </View>
          <View style={styles.dailyChallengeWidgetRewardRow}>
            <HealthRewardTokens amount={dailyChallenge.rewardBonus} color={colors.text} iconSize={16} />
            <View style={[styles.dailyChallengeMultiplierPill, { borderColor: widgetBorder }]}>
              <Text style={[styles.dailyChallengeMultiplierText, { color: colors.text }]}>Ã—2</Text>
            </View>
          </View>
        </View>
        <View style={styles.dailyChallengeWidgetBody}>
          <View style={styles.dailyChallengeEmojiPill}>
            <Text style={styles.dailyChallengeEmojiText}>{dailyChallenge.emoji || "âœ¨"}</Text>
          </View>
          <View style={{ flex: 1, gap: 2 }}>
            <Text style={[styles.dailyChallengeWidgetTitle, { color: colors.text }]}>
              {t("dailyChallengeWidgetTitle")}
            </Text>
            <Text style={[styles.dailyChallengeWidgetDesc, { color: colors.muted }]}>
              {t("dailyChallengeWidgetDesc", { temptation: dailyChallenge.title })}
            </Text>
          </View>
        </View>
        <View style={{ gap: 6 }}>
          <View style={[styles.dailyChallengeProgressBar, { backgroundColor: widgetBorder }]}>
            <View
              style={[
                styles.dailyChallengeProgressFill,
                { width: `${percent * 100}%`, backgroundColor: colors.text },
              ]}
            />
          </View>
          <View style={styles.dailyChallengeWidgetFooter}>
            <Text style={[styles.dailyChallengeProgressLabel, { color: colors.muted }]}>
              {t("dailyChallengeWidgetProgress", { current: `${progress}`, target: `${target}` })}
            </Text>
            <Text style={[styles.dailyChallengeRewardLabel, { color: colors.text }]}>
              {t("dailyChallengeWidgetReward", { amount: rewardLabel })}
            </Text>
          </View>
        </View>
      </View>
    );
  }, [colors, dailyChallenge, dailyChallengeRewardLabel, isDarkTheme, t]);

  const [activeCategoryId, setActiveCategoryId] = useState(null);
  const activeCategoryLabel = useMemo(() => {
    if (!activeCategoryId) return "";
    return getImpulseCategoryLabel(activeCategoryId, language);
  }, [activeCategoryId, language]);
  const formatLocalAmount = useCallback(
    (valueUSD = 0) => formatCurrency(convertToCurrency(valueUSD || 0, currency), currency),
    [currency]
  );
  const resolveHistoryCategoryId = useCallback(
    (entry) => {
      const metaCategory =
        entry?.meta?.category || entry?.meta?.impulseCategory || entry?.meta?.impulseCategoryOverride;
      if (metaCategory && IMPULSE_CATEGORY_DEFS[metaCategory]) return metaCategory;
      const templateId = entry?.meta?.templateId;
      if (!templateId || typeof resolveTemplateCard !== "function" || typeof resolveTemptationCategory !== "function") {
        return DEFAULT_IMPULSE_CATEGORY;
      }
      const template = resolveTemplateCard(templateId);
      if (!template) return DEFAULT_IMPULSE_CATEGORY;
      return resolveTemptationCategory(template);
    },
    [resolveTemplateCard, resolveTemptationCategory]
  );
  const categoryHistoryEntries = useMemo(() => {
    if (!activeCategoryId) return [];
    return resolvedHistoryEvents.filter((entry) => {
      if (!entry || (entry.kind !== "refuse_spend" && entry.kind !== "spend")) return false;
      return resolveHistoryCategoryId(entry) === activeCategoryId;
    });
  }, [activeCategoryId, resolvedHistoryEvents, resolveHistoryCategoryId]);
  const locale = useMemo(() => getFormatLocale(language), [language]);
  const describeCategoryHistory = useCallback(
    (entry) => {
      if (!entry) return t("historyUnknown");
      const title = entry?.meta?.title || t("historyUnknown");
      if (entry.kind === "refuse_spend") {
        return t("historyRefuseSpend", { title, amount: formatLocalAmount(entry.meta?.amountUSD) });
      }
      if (entry.kind === "spend") {
        return t("historySpend", { title, amount: formatLocalAmount(entry.meta?.amountUSD) });
      }
      return t("historyUnknown");
    },
    [formatLocalAmount, t]
  );
  const formatCategoryHistoryMeta = useCallback(
    (entry) => {
      if (!entry?.timestamp) return "";
      try {
        const date = new Date(entry.timestamp);
        const dateLabel = date.toLocaleDateString(locale, { day: "numeric", month: "short" });
        const timeLabel = date.toLocaleTimeString(locale, { hour: "2-digit", minute: "2-digit" });
        return t("historyTimestamp", { date: dateLabel, time: timeLabel });
      } catch {
        return "";
      }
    },
    [locale, t]
  );
  const closeCategoryHistory = useCallback(() => setActiveCategoryId(null), []);
  const [categoryModalHeight, setCategoryModalHeight] = useState(0);
  const categoryModalOpacity = useMemo(() => {
    const screenHeight = Dimensions.get("window").height || 1;
    const ratio = Math.max(0, Math.min((categoryModalHeight || 0) / screenHeight, 1));
    return Math.min(0.5, Math.max(0.22, 0.18 + ratio * 0.45));
  }, [categoryModalHeight]);

  return (
    <>
      <ScrollView
        ref={scrollRef}
        style={[styles.container, { backgroundColor: colors.background }]}
        contentContainerStyle={{ paddingBottom: 200, gap: 16 }}
        showsVerticalScrollIndicator={false}
        onScrollBeginDrag={closeChallengeSwipe}
      >
      <View>
        <Text style={[styles.header, { color: colors.text }]}>{t("wishlistTitle")}</Text>
        <Text style={[styles.purchasesSubtitle, { color: colors.muted }]}>
          {t("progressTabSubtitle")}
        </Text>
      </View>

      <View style={styles.progressHeroGrid}>
        <View style={[styles.progressGoalCard, { backgroundColor: colors.card, borderColor: colors.border }]}>
          <View style={styles.progressGoalHeader}>
            <Text style={[styles.progressGoalTitle, { color: colors.text }]}>{t("progressGoalTitle")}</Text>
            <Text style={styles.progressGoalEmoji}>{goalEmoji}</Text>
          </View>
          <Text style={[styles.progressGoalName, { color: colors.text }]} numberOfLines={2}>
            {goalTitle}
          </Text>
          <Text style={[styles.progressGoalMeta, { color: colors.muted }]}>
            {t("progressGoalRemaining", { amount: goalRemainingLabel })}
          </Text>
          <View style={styles.progressGoalRingRow}>
            <ProgressRing
              progress={goalProgress}
              trackColor={isDarkTheme ? "rgba(255,255,255,0.1)" : "rgba(0,0,0,0.08)"}
              progressColor={colors.text}
            />
            <View style={styles.progressGoalRingText}>
              <Text
                style={[styles.progressGoalPercent, { color: colors.text }]}
                numberOfLines={1}
                adjustsFontSizeToFit
                minimumFontScale={0.7}
              >
                {`${Math.round(goalProgress * 100)}%`}
              </Text>
              <Text
                style={[styles.progressGoalTarget, { color: colors.muted }]}
                numberOfLines={1}
                adjustsFontSizeToFit
                minimumFontScale={0.7}
              >
                {t("progressGoalTarget", { amount: goalTargetLabel })}
              </Text>
            </View>
          </View>
        </View>
        <View style={[styles.progressCoinCard, { backgroundColor: colors.card, borderColor: colors.border }]}>
          <View style={styles.progressCoinHeader}>
            <Text style={[styles.progressCoinTitle, { color: colors.text }]}>{t("freeDayHealthTitle")}</Text>
            <Text style={styles.progressCoinEmoji}>ðŸª™</Text>
          </View>
          <Text style={[styles.progressCoinValue, { color: colors.text }]}>{healthPoints}</Text>
          <Text style={[styles.progressCoinSubtitle, { color: colors.muted }]}>
            {t("freeDayHealthSubtitle")}
          </Text>
          {hasCoinInventory ? (
            <View style={styles.progressCoinRow}>
              {coinEntries.map((entry) =>
                entry.count ? (
                  <View
                    key={entry.id}
                    style={[
                      styles.progressCoinBadge,
                      { borderColor: colors.border, backgroundColor: colors.background },
                    ]}
                  >
                    <Image source={entry.asset} style={styles.progressCoinImage} />
                    <Text style={[styles.progressCoinCount, { color: colors.text }]}>Ã—{entry.count}</Text>
                  </View>
                ) : null
              )}
            </View>
          ) : null}
        </View>
      </View>

      <WeeklyCardWrap
        style={[
          styles.progressWeeklyCard,
          { backgroundColor: weeklyCardPalette.background, borderColor: weeklyCardPalette.border },
        ]}
        {...(onWeeklySpendPress ? { activeOpacity: 0.9, onPress: onWeeklySpendPress } : {})}
      >
        <Text style={[styles.progressWeeklyTitle, { color: weeklyCardPalette.text }]}>
          {t("heroDailyTitle")}
        </Text>
        {weeklyTrend && (
          <View style={styles.weeklyTrendRow}>
            {weeklyTrend.savings && (
              <View style={styles.weeklyTrendItem}>
                <Text style={[styles.weeklyTrendLabel, { color: weeklyCardPalette.subtext }]}>
                  {t("heroWeeklySavingsDelta")}
                </Text>
                <Text style={[styles.weeklyTrendValue, { color: weeklyTrend.savings.color }]}>
                  {weeklyTrend.savings.symbol} {weeklyTrend.savings.label}
                </Text>
              </View>
            )}
            {weeklyTrend.spending && (
              <View style={styles.weeklyTrendItem}>
                <Text style={[styles.weeklyTrendLabel, { color: weeklyCardPalette.subtext }]}>
                  {t("heroWeeklySpendingDelta")}
                </Text>
                <Text style={[styles.weeklyTrendValue, { color: weeklyTrend.spending.color }]}>
                  {weeklyTrend.spending.symbol} {weeklyTrend.spending.label}
                </Text>
              </View>
            )}
          </View>
        )}
        {weeklyHasData ? (
          <View style={styles.savedHeroBars}>
            {weeklyDailySavings.map((day) => (
              <View key={day.key} style={styles.savedHeroBarItem}>
                <View style={styles.savedHeroBarAmountWrap}>
                  {day.amountValueLabel ? (
                    <View style={styles.savedHeroBarAmountBlock}>
                      <Text
                        style={[styles.savedHeroBarAmount, { color: weeklyCardPalette.text }]}
                        numberOfLines={1}
                      >
                        {day.amountValueLabel}
                        {day.amountCurrencySymbol ? (
                          <Text
                            style={[styles.savedHeroBarCurrency, { color: weeklyCardPalette.text }]}
                          >
                            {"\u00A0"}
                            {day.amountCurrencySymbol}
                          </Text>
                        ) : null}
                      </Text>
                    </View>
                  ) : null}
                  {day.spendValueLabel ? (
                    <View style={styles.savedHeroBarAmountBlock}>
                      <Text
                        style={[styles.savedHeroBarSpend, { color: weeklyCardPalette.spend }]}
                        numberOfLines={1}
                      >
                        {day.spendValueLabel}
                        {day.spendCurrencySymbol ? (
                          <Text
                            style={[styles.savedHeroBarCurrency, { color: weeklyCardPalette.spend }]}
                          >
                            {"\u00A0"}
                            {day.spendCurrencySymbol}
                          </Text>
                        ) : null}
                      </Text>
                    </View>
                  ) : null}
                </View>
                <View style={[styles.savedHeroBarTrack, { backgroundColor: weeklyCardPalette.track }]}>
                  <View
                    style={[
                      styles.savedHeroBarColumn,
                      {
                        height: `${day.percent}%`,
                        backgroundColor: weeklyCardPalette.save,
                      },
                    ]}
                  />
                  {day.spendPercent > 0 ? (
                    <View
                      style={[
                        styles.savedHeroBarColumnSpend,
                        {
                          height: `${day.spendPercent}%`,
                          backgroundColor: weeklyCardPalette.spend,
                          opacity: day.spendOverflow ? 0.95 : 0.8,
                        },
                      ]}
                    />
                  ) : null}
                </View>
                <Text style={[styles.savedHeroBarLabel, { color: weeklyCardPalette.subtext }]}>
                  {day.label}
                </Text>
              </View>
            ))}
          </View>
        ) : (
          <Text style={[styles.savedHeroDailyEmpty, { color: weeklyCardPalette.subtext }]}>
            {t("heroDailyEmpty")}
          </Text>
        )}
      </WeeklyCardWrap>

      <View style={[styles.progressActiveChallenge, { backgroundColor: colors.card, borderColor: colors.border }]}>
        <View style={styles.progressActiveChallengeHeader}>
          <Text style={[styles.progressActiveChallengeTitle, { color: colors.text }]}>
            {t("progressActiveChallengeTitle")}
          </Text>
          {activeChallenge ? (
            <Text style={[styles.progressActiveChallengeMeta, { color: colors.muted }]}>
              {activeChallenge.timerLabel}
            </Text>
          ) : null}
        </View>
        {activeChallenge ? (
          <>
            <View style={styles.progressActiveChallengeRow}>
              <Text style={styles.challengeEmoji}>{activeChallenge.emoji}</Text>
              <View style={{ flex: 1 }}>
                <Text style={[styles.progressActiveChallengeName, { color: colors.text }]} numberOfLines={2}>
                  {activeChallenge.title}
                </Text>
                <Text style={[styles.progressActiveChallengeDesc, { color: colors.muted }]} numberOfLines={2}>
                  {activeChallenge.description}
                </Text>
                {activeChallenge.potentialSavingsLabel ? (
                  <Text style={[styles.challengePotential, { color: colors.text }]}>
                    {t("challengePotentialSavings", { amount: activeChallenge.potentialSavingsLabel })}
                  </Text>
                ) : null}
              </View>
            </View>
            {activeChallengeIsAmount ? (
              <View style={[styles.challengeProgressBar, { backgroundColor: colors.border }]}>
                <View
                  style={[
                    styles.challengeProgressFill,
                    { width: `${activeChallengePercent * 100}%`, backgroundColor: colors.text },
                  ]}
                />
              </View>
            ) : (
              <ChallengeProgressDots
                total={activeChallengeTargetValue}
                progress={activeChallengeProgressValue}
                colors={colors}
              />
            )}
            <Text style={[styles.challengeProgressLabel, { color: colors.muted }]}>
              {activeChallenge.progressLabel}
            </Text>
            <TouchableOpacity
              style={[
                styles.progressActiveChallengeButton,
                { backgroundColor: activeChallengeActionEnabled ? colors.text : colors.border },
              ]}
              activeOpacity={0.9}
              disabled={!activeChallengeActionEnabled}
              onPress={() => {
                if (activeChallenge.canClaim) {
                  onChallengeClaim?.(activeChallenge.id);
                } else if (activeChallenge.canStart) {
                  Alert.alert(
                    t("challengeAcceptConfirmTitle"),
                    t("challengeAcceptConfirmMessage", { title: activeChallenge.title }),
                    [
                      { text: t("challengeAcceptConfirmNo"), style: "cancel" },
                      {
                        text: t("challengeAcceptConfirmYes"),
                        style: "default",
                        onPress: () => onChallengeAccept?.(activeChallenge.id),
                      },
                    ]
                  );
                }
              }}
            >
              <Text
                style={[
                  styles.progressActiveChallengeButtonText,
                  { color: activeChallengeActionEnabled ? colors.background : colors.muted },
                ]}
              >
                {activeChallenge.actionLabel}
              </Text>
            </TouchableOpacity>
          </>
        ) : (
          <Text style={[styles.progressActiveChallengeEmpty, { color: colors.muted }]}>
            {t("progressNoActiveChallenge")}
          </Text>
        )}
      </View>

      <View style={[styles.progressAnalyticsCard, { backgroundColor: colors.card, borderColor: colors.border }]}>
        <View style={styles.progressAnalyticsHeader}>
          <Text style={[styles.progressAnalyticsTitle, { color: colors.text }]}>
            {t("progressCategoryTitle")}
          </Text>
          <View style={styles.progressAnalyticsLegend}>
            <View style={styles.progressAnalyticsLegendItem}>
              <View style={[styles.progressAnalyticsDot, { backgroundColor: SAVE_ACTION_COLOR }]} />
              <Text style={[styles.progressAnalyticsLegendText, { color: colors.muted }]}>
                {t("progressCategorySave")}
              </Text>
            </View>
            <View style={styles.progressAnalyticsLegendItem}>
              <View style={[styles.progressAnalyticsDot, { backgroundColor: SPEND_ACTION_COLOR }]} />
              <Text style={[styles.progressAnalyticsLegendText, { color: colors.muted }]}>
                {t("progressCategorySpend")}
              </Text>
            </View>
          </View>
        </View>
        <Text style={[styles.progressAnalyticsSubtitle, { color: colors.muted }]}>
          {t("progressCategorySubtitle")}
        </Text>
        {challengeBadges.length > 0 && (
          <View style={styles.progressBadgeRow}>
            <Text style={[styles.progressBadgeLabel, { color: colors.muted }]}>
              {t("progressBadgeTitle")}
            </Text>
            <View style={styles.progressBadgeList}>
              {challengeBadges.slice(0, 6).map((emoji, index) => (
                <Text key={`${emoji}-${index}`} style={styles.progressBadgeEmoji}>
                  {emoji}
                </Text>
              ))}
              {challengeBadgeCount > 6 && (
                <Text style={[styles.progressBadgeCount, { color: colors.muted }]}>
                  +{challengeBadgeCount - 6}
                </Text>
              )}
            </View>
          </View>
        )}
        <ScrollView
          style={[styles.progressAnalyticsScroll, { maxHeight: categoryListHeight }]}
          contentContainerStyle={styles.progressAnalyticsList}
          showsVerticalScrollIndicator={false}
          nestedScrollEnabled
        >
          {categoryData.categories.map((entry) => {
            const total = entry.save + entry.spend;
            const totalPercent = total > 0 ? (total / categoryData.maxTotal) * 100 : 4;
            const savePercent = total > 0 ? (entry.save / total) * 100 : 0;
            return (
              <TouchableOpacity
                key={entry.id}
                style={styles.progressAnalyticsRow}
                activeOpacity={0.86}
                onPress={() => {
                  logEvent("progress_analytics_opened", { category_id: entry.id });
                  setActiveCategoryId(entry.id);
                }}
              >
                <View style={styles.progressAnalyticsRowHeader}>
                  <Text style={[styles.progressAnalyticsLabel, { color: colors.text }]}>
                    {entry.label}
                  </Text>
                  <Text style={[styles.progressAnalyticsValue, { color: colors.muted }]}>
                    {`${entry.save} / ${entry.spend}`}
                  </Text>
                </View>
                <View style={[styles.progressAnalyticsTrack, { backgroundColor: colors.border }]}>
                  <View style={[styles.progressAnalyticsFill, { width: `${totalPercent}%` }]}>
                    <View
                      style={[
                        styles.progressAnalyticsSave,
                        { width: `${savePercent}%`, backgroundColor: SAVE_ACTION_COLOR },
                      ]}
                    />
                    <View
                      style={[
                        styles.progressAnalyticsSpend,
                        { width: `${100 - savePercent}%`, backgroundColor: SPEND_ACTION_COLOR },
                      ]}
                    />
                  </View>
                </View>
              </TouchableOpacity>
            );
          })}
        </ScrollView>
      </View>

      {showImpulseMap ? (
        <ImpulseMapCard
          insights={impulseInsights}
          colors={colors}
          t={t}
          language={language}
          expanded={impulseExpanded}
          onToggle={handleImpulseToggle}
        />
      ) : (
        <LockedFeatureCard
          variantKey="impulseMap"
          colors={colors}
          t={t}
          style={styles.lockedFeatureCard}
          minHeight={182}
          blurIntensity={10}
        />
      )}

      {showFreeDayCard ? (
        <FreeDayCard
          colors={colors}
          t={t}
          canLog={canLogFreeDay}
          onLog={onFreeDayLog}
          freeDayStats={freeDayStats}
          todayKey={todayKey}
          weekDays={weekDays}
          weekCount={weekSuccessCount}
          canRescue={canRescueFreeDay}
          needsRescue={streakNeedsRescue}
          rescueStatus={rescueStatus}
          rescueCost={freeDayRescueCost}
          onRescue={onFreeDayRescue}
          hasRescueHealth={hasRescueHealth}
        />
      ) : (
        <LockedFeatureCard
          variantKey="freeDay"
          colors={colors}
          t={t}
          style={styles.lockedFeatureCard}
          minHeight={182}
          blurIntensity={10}
        />
      )}

      <View style={styles.progressSectionHeader}>
        <Text style={[styles.progressSectionTitle, { color: colors.text }]}>{t("progressGoalsTitle")}</Text>
        <Text style={[styles.progressSectionSubtitle, { color: colors.muted }]}>
          {t("wishlistSummary", { amount: totalTarget })}
        </Text>
      </View>
      <ScrollView
        horizontal
        showsHorizontalScrollIndicator={false}
        contentContainerStyle={styles.progressGoalScroll}
      >
        {listData.map((wish) => {
          const goalId = wish.goalId || wish.id;
          const isActiveGoal = !!activeGoalId && activeGoalId === goalId;
          const isDoneGoal = wish?.status === "done";
          const title = getWishTitleWithoutEmoji(wish);
          const emoji = resolveWishEmoji(wish);
          const cardBackground = isDoneGoal
            ? SAVE_ACTION_COLOR
            : isActiveGoal
              ? colors.text
              : colors.card;
          const cardTextColor = isDoneGoal
            ? "#fff"
            : isActiveGoal
              ? colors.background
              : colors.text;
          const cardMetaColor = isDoneGoal
            ? "rgba(255,255,255,0.85)"
            : isActiveGoal
              ? "rgba(255,255,255,0.75)"
              : colors.muted;
          return (
            <TouchableOpacity
              key={wish.id}
              style={[
                styles.progressGoalMiniCard,
                {
                  borderColor: isActiveGoal ? colors.text : colors.border,
                  backgroundColor: cardBackground,
                },
              ]}
              activeOpacity={0.9}
              onPress={() => {
                if (isDoneGoal) {
                  Alert.alert(t("goalRepeatTitle"), t("goalRepeatMessage"), [
                    { text: t("goalRepeatCancel"), style: "cancel" },
                    {
                      text: t("goalRepeatAction"),
                      onPress: () => onCreateGoal?.(),
                    },
                  ]);
                  return;
                }
                if (!isActiveGoal) {
                  onSetActiveGoal?.(goalId);
                  return;
                }
                onGoalEdit?.(wish);
              }}
              onLongPress={() => onSetActiveGoal?.(goalId)}
            >
              <Text
                style={[styles.progressGoalMiniEmoji, { color: cardTextColor }]}
              >
                {emoji}
              </Text>
              <Text
                style={[styles.progressGoalMiniTitle, { color: cardTextColor }]}
                numberOfLines={2}
              >
                {title}
              </Text>
              <Text
                style={[styles.progressGoalMiniMeta, { color: cardMetaColor }]}
              >
                {isDoneGoal ? t("goalRepeatHint") : isActiveGoal ? t("wishlistActive") : t("wishlistSetActive")}
              </Text>
            </TouchableOpacity>
          );
        })}
        <TouchableOpacity
          style={[
            styles.progressGoalMiniCard,
            styles.progressGoalMiniPlaceholder,
            { borderColor: colors.border },
          ]}
          activeOpacity={0.9}
          onPress={() => onCreateGoal?.()}
        >
          <Text style={[styles.progressGoalMiniPlus, { color: colors.text }]}>+</Text>
          <Text style={[styles.progressGoalMiniMeta, { color: colors.muted, textAlign: "center" }]}>
            {t("goalCustomCreate")}
          </Text>
        </TouchableOpacity>
      </ScrollView>

      <View style={styles.progressSectionHeader}>
        <Text style={[styles.progressSectionTitle, { color: colors.text }]}>
          {t("challengeTabTitle")}
        </Text>
        <Text style={[styles.progressSectionSubtitle, { color: colors.muted }]}>
          {t("progressChallengesSubtitle")}
        </Text>
      </View>

      <View style={{ gap: 16 }}>
        {renderDailyChallengeWidget()}
        {challenges.map(renderChallengeCard)}
        {!challenges.length && !dailyChallenge && (
          <Text style={[styles.historyEmpty, { color: colors.muted }]}>
            {t("rewardsEmpty")}
          </Text>
        )}
      </View>
      </ScrollView>
      <Modal
        visible={!!activeCategoryId}
        transparent
        animationType="fade"
        statusBarTranslucent
        onRequestClose={closeCategoryHistory}
      >
        <View style={styles.progressCategoryModalRoot}>
          <TouchableWithoutFeedback onPress={closeCategoryHistory}>
            <View
              style={[
                styles.progressCategoryBackdrop,
                { backgroundColor: `rgba(0,0,0,${categoryModalOpacity})` },
              ]}
            />
          </TouchableWithoutFeedback>
          <View style={styles.progressCategoryModalWrap} pointerEvents="box-none">
            <View
              style={[styles.progressCategoryModalCard, { backgroundColor: colors.card, borderColor: colors.border }]}
              onLayout={(event) => {
                const nextHeight = event?.nativeEvent?.layout?.height || 0;
                if (nextHeight && nextHeight !== categoryModalHeight) {
                  setCategoryModalHeight(nextHeight);
                }
              }}
            >
              <View style={styles.progressCategoryModalHeader}>
                <Text style={[styles.progressCategoryModalTitle, { color: colors.text }]}>
                  {t("historyTitle")} Â· {activeCategoryLabel}
                </Text>
                <TouchableOpacity onPress={closeCategoryHistory} style={styles.progressCategoryModalClose}>
                  <Text style={[styles.progressCategoryModalCloseText, { color: colors.muted }]}>âœ•</Text>
                </TouchableOpacity>
              </View>
              {categoryHistoryEntries.length === 0 ? (
                <Text style={[styles.historyEmpty, { color: colors.muted }]}>{t("historyEmpty")}</Text>
              ) : (
                <ScrollView
                  style={[styles.progressCategoryModalList, { borderColor: colors.border }]}
                  contentContainerStyle={styles.historyListContent}
                  showsVerticalScrollIndicator
                >
                  {categoryHistoryEntries.map((entry, index) => (
                    <View
                      key={entry.id}
                      style={[
                        styles.historyItem,
                        {
                          borderColor: colors.border,
                          borderBottomWidth:
                            index === categoryHistoryEntries.length - 1 ? 0 : StyleSheet.hairlineWidth,
                        },
                      ]}
                    >
                      <View style={styles.historyRow}>
                        <View style={{ flex: 1 }}>
                          <Text style={[styles.historyItemTitle, { color: colors.text }]}>
                            {describeCategoryHistory(entry)}
                          </Text>
                          <Text style={[styles.historyItemMeta, { color: colors.muted }]}>
                            {formatCategoryHistoryMeta(entry)}
                          </Text>
                        </View>
                      </View>
                    </View>
                  ))}
                </ScrollView>
              )}
            </View>
          </View>
        </View>
      </Modal>
    </>
  );
});

function SwipeablePendingCard({ children, colors, t, onDelete, itemId, onLayout }) {
  const translateX = useRef(new Animated.Value(0)).current;
  const isDarkTheme = colors.background === THEMES.dark.background;

  const handleSwipeRelease = useCallback(
    (dx = 0) => {
      if (dx < -DELETE_SWIPE_THRESHOLD && onDelete) {
        onDelete();
      }
      Animated.timing(translateX, {
        toValue: 0,
        duration: 160,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }).start();
    },
    [onDelete, translateX]
  );

  const panResponder = useMemo(
    () =>
      PanResponder.create({
        onStartShouldSetPanResponder: () => false,
        onMoveShouldSetPanResponder: (_, gestureState) =>
          Math.abs(gestureState.dx) > Math.abs(gestureState.dy) && Math.abs(gestureState.dx) > 6,
        onPanResponderGrant: () => {
          translateX.stopAnimation();
        },
        onPanResponderMove: (_, gestureState) => {
          const dx = Math.max(Math.min(gestureState.dx, 60), -180);
          translateX.setValue(dx);
        },
        onPanResponderRelease: (_, gestureState) => {
          handleSwipeRelease(gestureState.dx);
        },
        onPanResponderTerminationRequest: () => false,
        onPanResponderTerminate: () => handleSwipeRelease(0),
      }),
    [handleSwipeRelease, translateX]
  );

  useEffect(() => {
    translateX.setValue(0);
  }, [itemId, translateX]);

  return (
    <View style={styles.pendingSwipeWrapper} onLayout={onLayout}>
      <View style={styles.pendingSwipeBackground} pointerEvents="none">
        <View
          style={[
            styles.swipeHint,
            styles.swipeHintRight,
            {
              borderColor: isDarkTheme ? "rgba(255,255,255,0.12)" : colors.border,
              backgroundColor: isDarkTheme ? "rgba(255,87,115,0.15)" : "rgba(233,61,87,0.12)",
            },
          ]}
        >
          <Text style={[styles.swipeHintIcon, { color: "#E15555" }]}>ðŸ—‘ï¸</Text>
          <Text style={[styles.swipeHintText, { color: "#E15555" }]}>{t("goalSwipeDelete")}</Text>
        </View>
      </View>
      <Animated.View style={{ transform: [{ translateX }] }} {...panResponder.panHandlers}>
        {children}
      </Animated.View>
    </View>
  );
}

const PendingScreen = React.memo(function PendingScreen({
  items,
  currency,
  t,
  colors,
  onResolve,
  onDelete,
  onExtend,
  language,
  catCuriousSource,
  locked = false,
  onItemLayout,
  scrollRef,
}) {
  const isDarkMode = colors.background === THEMES.dark.background;
  const curiousImage = catCuriousSource || CLASSIC_TAMAGOTCHI_ANIMATIONS.curious;
  const [nowTick, setNowTick] = useState(Date.now());
  const sorted = useMemo(
    () => [...items].sort((a, b) => (a.decisionDue || 0) - (b.decisionDue || 0)),
    [items]
  );
  useEffect(() => {
    if (!sorted.length) return undefined;
    const intervalId = setInterval(() => {
      setNowTick(Date.now());
    }, PENDING_COUNTDOWN_FAST_MS);
    return () => clearInterval(intervalId);
  }, [sorted.length]);

  const formatCountdown = useCallback(
    (ms) => {
      if (ms <= 0) return t("pendingExpired");
      const totalSeconds = Math.floor(ms / 1000);
      const days = Math.floor(totalSeconds / 86400);
      const hours = Math.floor((totalSeconds % 86400) / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      const hh = String(hours).padStart(2, "0");
      const mm = String(minutes).padStart(2, "0");
      const ss = String(seconds).padStart(2, "0");
      const daySuffix = resolveLanguageMapValue(PENDING_DAY_SUFFIX, language) || "d";
      return days > 0 ? `${days}${daySuffix} ${hh}:${mm}:${ss}` : `${hh}:${mm}:${ss}`;
    },
    [language, t]
  );

  const header = <Text style={[styles.header, { color: colors.text }]}>{t("pendingTitle")}</Text>;
  const emptyBody = (
    <View style={styles.cartEmptyState}>
      <Image source={curiousImage} style={[styles.catImage, styles.catImageLarge]} />
      <Text style={[styles.cartEmptyTitle, { color: colors.text }]}>{t("pendingEmptyTitle")}</Text>
      <Text style={[styles.cartEmptySubtitle, { color: colors.muted }]}>
        {t("pendingEmptySubtitle")}
      </Text>
    </View>
  );
  const listBody = (
    <ScrollView contentContainerStyle={{ paddingBottom: 160, gap: 16 }} ref={scrollRef}>
      {sorted.map((item) => {
        const diff = (item.decisionDue || 0) - nowTick;
        const countdownLabel = formatCountdown(diff);
        const overdue = diff <= 0;
        const priceLabel = formatTemptationPriceLabel(item, currency);
        const pendingCardBg = isDarkMode ? colors.card : "#D2E6FF";
        const pendingCardBorder = isDarkMode ? colors.border : "rgba(120,170,255,0.85)";
        const pendingCardShadow = isDarkMode ? "rgba(0,0,0,0.35)" : "rgba(120,170,255,0.45)";
        return (
          <SwipeablePendingCard
            key={item.id}
            colors={colors}
            t={t}
            onDelete={onDelete ? () => onDelete(item) : undefined}
            itemId={item.id}
            onLayout={
              onItemLayout
                ? (event) => {
                    onItemLayout(item.id, event.nativeEvent.layout);
                  }
                : undefined
            }
          >
            <View
              style={[
                styles.pendingCard,
                {
                  backgroundColor: pendingCardBg,
                  borderColor: pendingCardBorder,
                  borderWidth: 1,
                  shadowColor: pendingCardShadow,
                  shadowOpacity: 0.12,
                  shadowRadius: 10,
                  shadowOffset: { width: 0, height: 6 },
                  elevation: 3,
                },
              ]}
            >
              <View style={styles.pendingHeader}>
                <Text style={[styles.pendingTitle, { color: colors.text }]}>{item.title}</Text>
              </View>
              <Text
                style={[
                  styles.pendingCountdown,
                  { color: overdue ? "#D9534F" : colors.text, textAlign: "center", fontSize: 20 },
                ]}
              >
                {countdownLabel}
              </Text>
              <Text style={[styles.pendingPrice, { color: colors.text }]}>{priceLabel}</Text>
              <View style={styles.pendingButtons}>
                <TouchableOpacity
                  style={[styles.pendingButtonPrimary, { backgroundColor: colors.text }]}
                  onPress={() => onResolve(item, "spend")}
                >
                  <Text style={[styles.pendingButtonPrimaryText, { color: colors.background }]}>
                    {t("pendingActionWant")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.pendingButtonSecondary, { borderColor: colors.border }]}
                  onPress={() => onResolve(item, "decline")}
                >
                  <Text style={{ color: colors.muted }}>{t("pendingActionDecline")}</Text>
                </TouchableOpacity>
                {overdue && onExtend ? (
                  <TouchableOpacity
                    style={[styles.pendingButtonSecondary, { borderColor: colors.border }]}
                    onPress={() => onExtend(item)}
                  >
                    <Text style={{ color: colors.muted }}>{t("pendingActionExtend")}</Text>
                  </TouchableOpacity>
                ) : null}
              </View>
            </View>
          </SwipeablePendingCard>
        );
      })}
    </ScrollView>
  );
  const body = sorted.length ? listBody : emptyBody;

  if (!locked) {
    return (
      <View style={[styles.container, { backgroundColor: colors.background }] }>
        {header}
        {body}
      </View>
    );
  }

  return (
    <View style={[styles.container, { backgroundColor: colors.background }] }>
      {header}
      <LockedFeatureOverlay
        locked
        variantKey="thinkingList"
        colors={colors}
        t={t}
        style={styles.lockedFeatureScreen}
        contentStyle={styles.lockedFeatureScreenContent}
        borderRadius={0}
        centered
      >
        {body}
      </LockedFeatureOverlay>
    </View>
  );
});

const ACHIEVEMENT_METRIC_TYPES = {
  SAVED_AMOUNT: "SAVED_AMOUNT",
  FREE_DAYS_TOTAL: "FREE_DAYS_TOTAL",
  FREE_DAYS_STREAK: "FREE_DAYS_STREAK",
  REFUSE_COUNT: "REFUSE_COUNT",
  REFUSE_STREAK: "REFUSE_STREAK",
  FRIDGE_ITEMS_COUNT: "FRIDGE_ITEMS_COUNT",
  FRIDGE_DECISIONS: "FRIDGE_DECISIONS",
};
const ACHIEVEMENT_CONDITION_MAP = {
  [ACHIEVEMENT_METRIC_TYPES.SAVED_AMOUNT]: "amount_saved",
  [ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_TOTAL]: "streak_days",
  [ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_STREAK]: "streak_days",
  [ACHIEVEMENT_METRIC_TYPES.REFUSE_COUNT]: "saves_count",
  [ACHIEVEMENT_METRIC_TYPES.REFUSE_STREAK]: "saves_streak",
  [ACHIEVEMENT_METRIC_TYPES.FRIDGE_ITEMS_COUNT]: "pending_items",
  [ACHIEVEMENT_METRIC_TYPES.FRIDGE_DECISIONS]: "decisions_logged",
};

const ACHIEVEMENT_DEFS = [
  {
    id: "saved_50",
    metricType: ACHIEVEMENT_METRIC_TYPES.SAVED_AMOUNT,
    targetValue: 50,
    emoji: "ðŸ’¾",
    rewardHealth: 50,
    copy: {
      ru: { title: "ÐŸÐµÑ€Ð²Ñ‹Ðµ {{amount}}", desc: "ÐžÑ‚Ð»Ð¾Ð¶ÐµÐ½Ð¾ {{amount}} Ð½Ð° Ð¼Ð¸Ð½Ð¸-Ð¿Ð¾Ð´Ð°Ñ€Ð¾Ðº." },
      en: { title: "First {{amount}}", desc: "Already banked {{amount}} for a mini gift." },
      es: { title: "Primeros {{amount}}", desc: "Ya guardaste {{amount}} para un mini regalo." },
      fr: { title: "Premiers {{amount}}", desc: "DÃ©jÃ  mis de cÃ´tÃ© {{amount}} pour un mini cadeau." },
    },
  },
  {
    id: "saved_500",
    metricType: ACHIEVEMENT_METRIC_TYPES.SAVED_AMOUNT,
    targetValue: 500,
    emoji: "ðŸ’Ž",
    rewardHealth: 200,
    copy: {
      ru: { title: "Ð’ ÐºÐ¾Ð¿Ð¸Ð»ÐºÐµ ÑƒÐ¶Ðµ {{amount}}", desc: "ÐœÐ¾Ð¶Ð½Ð¾ ÑÑ‚Ñ€Ð¾Ð¸Ñ‚ÑŒ Ð¿Ð»Ð°Ð½Ñ‹ Ð½Ð° ÐºÑ€ÑƒÐ¿Ð½ÑƒÑŽ Ñ†ÐµÐ»ÑŒ." },
      en: { title: "{{amount}} saved already", desc: "Time to plan for a bigger goal." },
      es: { title: "Ya van {{amount}}", desc: "Hora de planear una meta mÃ¡s grande." },
      fr: { title: "{{amount}} dÃ©jÃ  Ã©pargnÃ©s", desc: "Il est temps de viser un objectif plus grand." },
    },
  },
  {
    id: "refuse_10",
    metricType: ACHIEVEMENT_METRIC_TYPES.REFUSE_STREAK,
    targetValue: 10,
    emoji: "ðŸ§ ",
    rewardHealth: 70,
    copy: {
      ru: { title: "Ð¡ÐµÑ€Ð¸Ñ Ã—10", desc: "10 Ð¾Ñ‚ÐºÐ°Ð·Ð¾Ð² Ð¿Ð¾Ð´Ñ€ÑÐ´ Ð½Ð° Ð¾Ð´Ð½Ð¾Ð¼ Ð¸ÑÐºÑƒÑˆÐµÐ½Ð¸Ð¸." },
      en: { title: "10-save streak", desc: "10 saves in a row on one temptation." },
      es: { title: "Racha Ã—10", desc: "10 rechazos seguidos en una misma tentaciÃ³n." },
      fr: { title: "SÃ©rie Ã—10", desc: "10 refus d'affilÃ©e sur une mÃªme tentation." },
    },
  },
  {
    id: "refuse_streak_20",
    metricType: ACHIEVEMENT_METRIC_TYPES.REFUSE_STREAK,
    targetValue: 20,
    emoji: "ðŸ”¥",
    rewardHealth: 120,
    copy: {
      ru: { title: "Ð¡ÐµÑ€Ð¸Ñ Ã—20", desc: "20 Ð¾Ñ‚ÐºÐ°Ð·Ð¾Ð² Ð¿Ð¾Ð´Ñ€ÑÐ´ Ð½Ð° Ð¾Ð´Ð½Ð¾Ð¼ Ð¸ÑÐºÑƒÑˆÐµÐ½Ð¸Ð¸." },
      en: { title: "20-save streak", desc: "20 saves in a row on one temptation." },
      es: { title: "Racha Ã—20", desc: "20 rechazos seguidos en una misma tentaciÃ³n." },
      fr: { title: "SÃ©rie Ã—20", desc: "20 refus d'affilÃ©e sur une mÃªme tentation." },
    },
  },
  {
    id: "refuse_streak_50",
    metricType: ACHIEVEMENT_METRIC_TYPES.REFUSE_STREAK,
    targetValue: 50,
    emoji: "ðŸ…",
    rewardHealth: 200,
    copy: {
      ru: { title: "Ð¡ÐµÑ€Ð¸Ñ Ã—50", desc: "50 Ð¾Ñ‚ÐºÐ°Ð·Ð¾Ð² Ð¿Ð¾Ð´Ñ€ÑÐ´ Ð½Ð° Ð¾Ð´Ð½Ð¾Ð¼ Ð¸ÑÐºÑƒÑˆÐµÐ½Ð¸Ð¸." },
      en: { title: "50-save streak", desc: "50 saves in a row on one temptation." },
      es: { title: "Racha Ã—50", desc: "50 rechazos seguidos en una misma tentaciÃ³n." },
      fr: { title: "SÃ©rie Ã—50", desc: "50 refus d'affilÃ©e sur une mÃªme tentation." },
    },
  },
  {
    id: "free_total_14",
    metricType: ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_STREAK,
    targetValue: 14,
    emoji: "ðŸ—“ï¸",
    rewardHealth: 70,
    copy: {
      ru: { title: "14 Ð´Ð½ÐµÐ¹ Ð±ÐµÐ· Ð¸Ð¼Ð¿ÑƒÐ»ÑŒÑÐ¾Ð²", desc: "Ð”Ð²Ðµ Ð±ÐµÑÐ¿Ð»Ð°Ñ‚Ð½Ñ‹Ñ… Ð½ÐµÐ´ÐµÐ»Ð¸ Ð¸ ÐºÐ¾ÑˆÐµÐ»Ñ‘Ðº Ð´Ð¾Ð²Ð¾Ð»ÐµÐ½." },
      en: { title: "14 impulse-free days", desc: "Two solid weeks of mindful focus." },
      es: { title: "14 dÃ­as sin impulsos", desc: "Dos semanas completas de enfoque consciente." },
      fr: { title: "14 jours sans impulsion", desc: "Deux semaines pleines de focus conscient." },
    },
  },
  {
    id: "free_streak_7",
    metricType: ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_STREAK,
    targetValue: 7,
    emoji: "âš¡ï¸",
    rewardHealth: 90,
    copy: {
      ru: { title: "Ð¡ÐµÑ€Ð¸Ñ Ð¸Ð· 7 Ð´Ð½ÐµÐ¹", desc: "ÐÐµÐ´ÐµÐ»Ñ Ð±ÐµÐ· Ñ‚Ñ€Ð°Ñ‚, Ñ‚Ñ‹ Ð² Ð¿Ð¾Ñ‚Ð¾ÐºÐµ." },
      en: { title: "7-day streak", desc: "A full week in the mindful zone." },
      es: { title: "Racha de 7 dÃ­as", desc: "Una semana completa en modo consciente." },
      fr: { title: "SÃ©rie de 7 jours", desc: "Une semaine entiÃ¨re en mode mindful." },
    },
  },
  {
    id: "fridge_items_10",
    metricType: ACHIEVEMENT_METRIC_TYPES.FRIDGE_ITEMS_COUNT,
    targetValue: 10,
    emoji: "ðŸ§Š",
    rewardHealth: 40,
    copy: {
      ru: { title: "10 Ñ…Ð¾Ñ‚ÐµÐ»Ð¾Ðº Ð² Â«Ð´ÑƒÐ¼Ð°ÐµÐ¼Â»", desc: "10 Ñ…Ð¾Ñ‚ÐµÐ»Ð¾Ðº Ð² Â«Ð´ÑƒÐ¼Ð°ÐµÐ¼Â»." },
      en: { title: "Thinking stash", desc: "10 temptations parked in Thinking." },
      es: { title: "Reserva en pausa", desc: "10 tentaciones estacionadas en En pausa." },
      fr: { title: "RÃ©serve en pause", desc: "10 tentations garÃ©es dans l'onglet En pause." },
    },
  },
  {
    id: "fridge_decisions_5",
    metricType: ACHIEVEMENT_METRIC_TYPES.FRIDGE_DECISIONS,
    targetValue: 5,
    emoji: "ðŸ¥¶",
    rewardHealth: 70,
    copy: {
      ru: { title: "Ð’Ð·Ð²ÐµÑˆÐµÐ½Ð½Ñ‹Ð¹ Ð²Ñ‹Ð±Ð¾Ñ€", desc: "Ð Ð°Ð·Ð¾Ð±Ñ€Ð°Ð»ÑÑ Ñ 5 Ñ…Ð¾Ñ‚ÐµÐ»ÐºÐ°Ð¼Ð¸ Ð¸Ð· Â«Ð´ÑƒÐ¼Ð°ÐµÐ¼Â»." },
      en: { title: "Clear-headed", desc: "Closed out 5 Thinking decisions with intent." },
      es: { title: "DecisiÃ³n clara", desc: "Resolviste 5 decisiones en En pausa con intenciÃ³n." },
      fr: { title: "Esprit clair", desc: "Tu as tranchÃ© 5 dÃ©cisions de l'onglet En pause en toute intention." },
    },
  },
];

const CHALLENGE_METRIC_TYPES = {
  SAVE_COUNT: "SAVE_COUNT",
  SAVE_AMOUNT: "SAVE_AMOUNT",
  FREE_DAY_STREAK: "FREE_DAY_STREAK",
  REFUSE_DAY_STREAK: "REFUSE_DAY_STREAK",
  PENDING_DECISIONS: "PENDING_DECISIONS",
  WISH_ADDED: "WISH_ADDED",
  PENDING_ADDED: "PENDING_ADDED",
  WEEKEND_SAVES: "WEEKEND_SAVES",
  MORNING_FREE_DAY: "MORNING_FREE_DAY",
  HIGH_VALUE_SAVE: "HIGH_VALUE_SAVE",
};

const CHALLENGE_STATUS = {
  IDLE: "idle",
  ACTIVE: "active",
  COMPLETED: "completed",
  CLAIMED: "claimed",
  EXPIRED: "expired",
};

const CHALLENGE_STATUS_ORDER = {
  [CHALLENGE_STATUS.COMPLETED]: 0,
  [CHALLENGE_STATUS.ACTIVE]: 1,
  [CHALLENGE_STATUS.IDLE]: 2,
  [CHALLENGE_STATUS.EXPIRED]: 3,
  [CHALLENGE_STATUS.CLAIMED]: 4,
};
const CHALLENGE_REMINDER_WINDOWS = [
  { hour: 9, minute: 0 },
  { hour: 12, minute: 30 },
  { hour: 16, minute: 0 },
  { hour: 19, minute: 30 },
  { hour: 21, minute: 15 },
];

const hashString = (value = "") => {
  const str = String(value);
  let hash = 0;
  for (let i = 0; i < str.length; i += 1) {
    hash = (hash << 5) - hash + str.charCodeAt(i);
    hash |= 0;
  }
  return Math.abs(hash);
};

const alignReminderSlotTime = (timestamp, slot, jitterMinutes = 0) => {
  if (!slot) return timestamp;
  const slotDate = new Date(timestamp);
  slotDate.setHours(slot.hour, slot.minute || 0, 0, 0);
  if (slotDate.getTime() < timestamp) {
    slotDate.setDate(slotDate.getDate() + 1);
  }
  if (jitterMinutes) {
    slotDate.setMinutes(slotDate.getMinutes() + jitterMinutes);
  }
  return slotDate.getTime();
};

const CHALLENGE_DEFS = [
  {
    id: "coffee_free_week",
    emoji: "ðŸ›¡ï¸",
    metricType: CHALLENGE_METRIC_TYPES.REFUSE_DAY_STREAK,
    targetValue: 7,
    durationDays: 12,
    unlockLevel: 2,
    rewardHealth: 140,
    reminderOffsetsHours: [24, 96, 168],
    copy: {
      ru: {
        title: "ÐÐµÐ´ÐµÐ»Ñ Ð¿Ñ€Ð¸Ð²Ñ‹Ñ‡ÐºÐ¸",
        desc: "ÐšÐ°Ð¶Ð´Ñ‹Ð¹ Ð´ÐµÐ½ÑŒ Ð² Ñ‚ÐµÑ‡ÐµÐ½Ð¸Ðµ Ð½ÐµÐ´ÐµÐ»Ð¸ Ð¾Ñ‚Ð¼ÐµÑ‚ÑŒ Ñ…Ð¾Ñ‚Ñ Ð±Ñ‹ Ð¾Ð´Ð¸Ð½ Ð¾Ñ‚ÐºÐ°Ð·.",
      },
      en: {
        title: "Habit week",
        desc: "Log at least one refusal every day for a full week.",
      },
      es: {
        title: "Semana del hÃ¡bito",
        desc: "Registra al menos un rechazo cada dÃ­a durante toda la semana.",
      },
      fr: {
        title: "Semaine habitude",
        desc: "Note au moins un refus par jour pendant toute une semaine.",
      },
    },
  },
  {
    id: "micro_detox",
    emoji: "ðŸŒ€",
    metricType: CHALLENGE_METRIC_TYPES.FREE_DAY_STREAK,
    targetValue: 3,
    durationDays: 5,
    unlockLevel: 7,
    rewardHealth: 80,
    reminderOffsetsHours: [24, 72],
    copy: {
      ru: {
        title: "Ð¢Ñ€Ð¸ Ð´Ð½Ñ ÑÑÐ½Ð¾ÑÑ‚Ð¸",
        desc: "Ð¡Ð¾Ð±ÐµÑ€Ð¸ {{count}} Ð±ÐµÑÐ¿Ð»Ð°Ñ‚Ð½Ñ‹Ñ… Ð´Ð½Ñ Ð¿Ð¾Ð´Ñ€ÑÐ´ Ð¸ Ð²ÑÑ‚Ñ€ÑÑ…Ð½Ð¸ Ð±ÑŽÐ´Ð¶ÐµÑ‚.",
      },
      en: {
        title: "Clarity streak",
        desc: "Log {{count}} impulse-free days in a row for a quick reset.",
      },
      es: {
        title: "Racha de claridad",
        desc: "Marca {{count}} dÃ­as sin impulsos seguidos para reiniciar tu enfoque.",
      },
      fr: {
        title: "SÃ©rie clartÃ©",
        desc: "Note {{count}} jours sans impulsion d'affilÃ©e pour un reset express.",
      },
    },
  },
  {
    id: "refuse_sprint",
    emoji: "âš”ï¸",
    metricType: CHALLENGE_METRIC_TYPES.SAVE_COUNT,
    targetValue: 6,
    durationDays: 4,
    unlockLevel: 1,
    rewardHealth: 60,
    reminderOffsetsHours: [24, 72],
    copy: {
      ru: {
        title: "Ð¡Ð¿Ñ€Ð¸Ð½Ñ‚ Ð¾Ñ‚ÐºÐ°Ð·Ð¾Ð²",
        desc: "Ð—Ð°Ñ„Ð¸ÐºÑÐ¸Ñ€ÑƒÐ¹ {{count}} Ð¾ÑÐ¾Ð·Ð½Ð°Ð½Ð½Ñ‹Ñ… Â«Ð½ÐµÑ‚Â» Ð¿Ð¾Ð´Ñ€ÑÐ´ Ð¸ ÑƒÐºÑ€ÐµÐ¿Ð¸ Ð¿Ñ€Ð¸Ð²Ñ‹Ñ‡ÐºÑƒ.",
      },
      en: {
        title: "Decline sprint",
        desc: "Record {{count}} mindful refusals in a row to lock the habit.",
      },
      es: {
        title: "Sprint de rechazos",
        desc: "Registra {{count}} Â«noÂ» conscientes seguidos para afianzar la costumbre.",
      },
      fr: {
        title: "Sprint de refus",
        desc: "Consigne {{count}} refus lucides d'affilÃ©e pour ancrer l'habitude.",
      },
    },
  },
  {
    id: "health_boost",
    emoji: "ðŸ’°",
    metricType: CHALLENGE_METRIC_TYPES.SAVE_AMOUNT,
    targetValue: 80,
    durationDays: 7,
    unlockLevel: 2,
    rewardHealth: 120,
    reminderOffsetsHours: [24, 96],
    copy: {
      ru: {
        title: "Ð£ÑÐºÐ¾Ñ€Ð¸Ñ‚ÐµÐ»ÑŒ Ð½Ð°ÐºÐ¾Ð¿Ð»ÐµÐ½Ð¸Ð¹",
        desc: "ÐÐ°Ð¿Ñ€Ð°Ð²ÑŒ Ð² ÐºÐ¾Ð¿Ð¸Ð»ÐºÑƒ {{amount}} Ð¾Ñ‚ÐºÐ°Ð·Ð°Ð¼Ð¸ Ð²ÑÐµÐ³Ð¾ Ð·Ð° Ð½ÐµÐ´ÐµÐ»ÑŽ.",
      },
      en: {
        title: "Savings boost",
        desc: "Route {{amount}} into savings through refusals this week.",
      },
      es: {
        title: "Impulso de ahorro",
        desc: "EnvÃ­a {{amount}} a la alcancÃ­a con tus rechazos esta semana.",
      },
      fr: {
        title: "Boost d'Ã©pargne",
        desc: "Dirige {{amount}} vers l'Ã©pargne grÃ¢ce Ã  tes refus cette semaine.",
      },
    },
  },
  {
    id: "fridge_cleaner",
    emoji: "ðŸ§Š",
    metricType: CHALLENGE_METRIC_TYPES.PENDING_DECISIONS,
    targetValue: 3,
    durationDays: 6,
    unlockLevel: 3,
    rewardHealth: 80,
    reminderOffsetsHours: [24, 72, 120],
    copy: {
      ru: {
        title: "Ð Ð°Ð·Ð³Ñ€ÑƒÐ·Ð¸ Â«Ð´ÑƒÐ¼Ð°ÐµÐ¼Â»",
        desc: "Ð Ð°Ð·Ñ€ÑƒÐ»Ð¸ {{count}} Ð¾Ñ‚Ð»Ð¾Ð¶ÐµÐ½Ð½Ñ‹Ñ… Ñ€ÐµÑˆÐµÐ½Ð¸Ð¹ Ð¸ Ð¾ÑÐ²Ð¾Ð±Ð¾Ð´Ð¸ Ð³Ð¾Ð»Ð¾Ð²Ñƒ.",
      },
      en: {
        title: "Clear the shelf",
        desc: "Resolve {{count}} items from the thinking list and free up focus.",
      },
      es: {
        title: "Limpia En pausa",
        desc: "Resuelve {{count}} elementos de En pausa y libera espacio mental.",
      },
      fr: {
        title: "Vider l'Ã©tagÃ¨re",
        desc: "RÃ©sous {{count}} Ã©lÃ©ments de la liste En pause et libÃ¨re ton esprit.",
      },
    },
  },
  {
    id: "goal_creator",
    emoji: "ðŸ§­",
    metricType: CHALLENGE_METRIC_TYPES.WISH_ADDED,
    targetValue: 2,
    durationDays: 4,
    unlockLevel: 4,
    rewardHealth: 60,
    reminderOffsetsHours: [24, 48],
    copy: {
      ru: {
        title: "ÐÐ¾Ð²Ð°Ñ ÐºÐ°Ñ€Ñ‚Ð° Ñ†ÐµÐ»ÐµÐ¹",
        desc: "Ð”Ð¾Ð±Ð°Ð²ÑŒ {{count}} ÑÐ²ÐµÐ¶Ð¸Ñ… Ñ†ÐµÐ»ÐµÐ¹ Ð¸ Ð½Ð°Ð¿Ð¾Ð¼Ð½Ð¸ ÑÐµÐ±Ðµ, Ñ€Ð°Ð´Ð¸ Ñ‡ÐµÐ³Ð¾ ÑÐºÐ¾Ð½Ð¾Ð¼Ð¸ÑˆÑŒ.",
      },
      en: {
        title: "Goal-mapping",
        desc: "Add {{count}} new goals to remember why you save.",
      },
      es: {
        title: "Mapa de metas",
        desc: "AÃ±ade {{count}} nuevas metas para recordar por quÃ© ahorras.",
      },
      fr: {
        title: "Carte des objectifs",
        desc: "Ajoute {{count}} nouveaux objectifs pour te rappeler pourquoi tu Ã©pargnes.",
      },
    },
  },
  {
    id: "weekend_focus",
    emoji: "ðŸ›¡ï¸",
    metricType: CHALLENGE_METRIC_TYPES.WEEKEND_SAVES,
    targetValue: 3,
    durationDays: 8,
    unlockLevel: 3,
    rewardHealth: 90,
    reminderOffsetsHours: [48, 96],
    copy: {
      ru: {
        title: "Ð’Ñ‹Ñ…Ð¾Ð´Ð½Ñ‹Ðµ Ð¿Ð¾Ð´ Ð·Ð°Ñ‰Ð¸Ñ‚Ð¾Ð¹",
        desc: "Ð¡Ð´ÐµÐ»Ð°Ð¹ {{count}} Ð¾Ñ‚ÐºÐ°Ð·Ð° Ð¸Ð¼ÐµÐ½Ð½Ð¾ Ð² Ð²Ñ‹Ñ…Ð¾Ð´Ð½Ñ‹Ðµ Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸ ÑÐ¿Ð¾ÐºÐ¾Ð¹ÑÑ‚Ð²Ð¸Ðµ.",
      },
      en: {
        title: "Weekend shield",
        desc: "Log {{count}} refusals during the weekend rush.",
      },
      es: {
        title: "Escudo de fin de semana",
        desc: "Registra {{count}} rechazos durante el rush del fin de semana.",
      },
      fr: {
        title: "Bouclier week-end",
        desc: "Consigne {{count}} refus pendant la folie du week-end.",
      },
    },
  },
  {
    id: "morning_free",
    emoji: "ðŸŒ…",
    metricType: CHALLENGE_METRIC_TYPES.MORNING_FREE_DAY,
    targetValue: 2,
    durationDays: 5,
    unlockLevel: 7,
    rewardHealth: 70,
    reminderOffsetsHours: [12, 48],
    copy: {
      ru: {
        title: "Ð£Ñ‚Ñ€ÐµÐ½Ð½Ð¸Ð¹ Ñ„Ð¾ÐºÑƒÑ",
        desc: "ÐžÑ‚Ð¼ÐµÑ‡Ð°Ð¹ Ð±ÐµÑÐ¿Ð»Ð°Ñ‚Ð½Ñ‹Ð¹ Ð´ÐµÐ½ÑŒ Ð´Ð¾ Ð¿Ð¾Ð»ÑƒÐ´Ð½Ñ {{count}} Ñ€Ð°Ð·Ð° - Ð½Ð°Ñ‡Ð½Ð¸ Ð´ÐµÐ½ÑŒ Ñ Ð¿Ð¾Ð±ÐµÐ´Ñ‹.",
      },
      en: {
        title: "Morning focus",
        desc: "Log a free day before noon {{count}} times.",
      },
      es: {
        title: "Enfoque matutino",
        desc: "Marca un dÃ­a gratis antes del mediodÃ­a {{count}} veces.",
      },
      fr: {
        title: "Focus matinal",
        desc: "Note un jour gratuit avant midi {{count}} fois.",
      },
    },
  },
  {
    id: "high_roller_shield",
    emoji: "ðŸ’Ž",
    metricType: CHALLENGE_METRIC_TYPES.HIGH_VALUE_SAVE,
    targetValue: 2,
    durationDays: 7,
    unlockLevel: 4,
    rewardHealth: 140,
    minAmountUSD: 35,
    reminderOffsetsHours: [48, 120],
    copy: {
      ru: {
        title: "Ð©Ð¸Ñ‚ Ð¾Ñ‚ Ð±Ð¾Ð»ÑŒÑˆÐ¸Ñ… Ñ‚Ñ€Ð°Ñ‚",
        desc: "ÐžÑ‚ÐºÐ°Ð¶Ð¸ÑÑŒ Ð¾Ñ‚ {{count}} ÐºÑ€ÑƒÐ¿Ð½Ñ‹Ñ… Ð¿Ð¾ÐºÑƒÐ¿Ð¾Ðº (Ð¾Ñ‚ {{limit}}) Ð¸ Ð´ÐµÑ€Ð¶Ð¸ ÐºÑƒÑ€Ñ.",
      },
      en: {
        title: "High-roller shield",
        desc: "Decline {{count}} big spends (over {{limit}}) to stay on track.",
      },
      es: {
        title: "Escudo anti derroche",
        desc: "Rechaza {{count}} compras grandes (mÃ¡s de {{limit}}) para mantener el rumbo.",
      },
      fr: {
        title: "Bouclier anti-gros achats",
        desc: "Dis non Ã  {{count}} grosses dÃ©penses (plus de {{limit}}) pour rester sur la voie.",
      },
    },
  },
  {
    id: "fridge_collector",
    emoji: "ðŸ“¥",
    metricType: CHALLENGE_METRIC_TYPES.PENDING_ADDED,
    targetValue: 3,
    durationDays: 5,
    unlockLevel: 3,
    rewardHealth: 60,
    reminderOffsetsHours: [24, 72],
    copy: {
      ru: {
        title: "ÐšÐ¾Ð»Ð»ÐµÐºÑ†Ð¸Ð¾Ð½ÐµÑ€ Ð¿Ð°ÑƒÐ·",
        desc: "ÐžÑ‚Ð¿Ñ€Ð°Ð²ÑŒ {{count}} Ð¸Ð¼Ð¿ÑƒÐ»ÑŒÑÐ¾Ð² Ð² Â«Ð¿Ð¾Ð´ÑƒÐ¼Ð°Ñ‚ÑŒ Ð¿Ð¾Ð·Ð¶ÐµÂ», Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð²Ñ‹Ð¸Ð³Ñ€Ð°Ñ‚ÑŒ Ð²Ñ€ÐµÐ¼Ñ.",
      },
      en: {
        title: "Pause collector",
        desc: "Park {{count}} temptations into â€œdecide laterâ€ to buy yourself time.",
      },
      es: {
        title: "Coleccionista de pausas",
        desc: "EnvÃ­a {{count}} tentaciones a â€œpensar despuÃ©sâ€ para ganar tiempo.",
      },
      fr: {
        title: "Collectionneur de pauses",
        desc: "Envoie {{count}} tentations dans Â« dÃ©cider plus tard Â» pour gagner du temps.",
      },
    },
  },
];

const CHALLENGE_DEF_MAP = CHALLENGE_DEFS.reduce((acc, def) => {
  acc[def.id] = def;
  return acc;
}, {});
const CHALLENGE_TYPE_LABELS = {
  [CHALLENGE_METRIC_TYPES.REFUSE_DAY_STREAK]: "no_spend_day",
  [CHALLENGE_METRIC_TYPES.FREE_DAY_STREAK]: "no_spend_day",
  [CHALLENGE_METRIC_TYPES.SAVE_COUNT]: "decline_count",
  [CHALLENGE_METRIC_TYPES.SAVE_AMOUNT]: "savings_amount",
};

const CHALLENGE_STATUS_LABELS = {
  [CHALLENGE_STATUS.IDLE]: "challengeStatusAvailable",
  [CHALLENGE_STATUS.ACTIVE]: "challengeStatusActive",
  [CHALLENGE_STATUS.COMPLETED]: "challengeStatusCompleted",
  [CHALLENGE_STATUS.EXPIRED]: "challengeStatusExpired",
  [CHALLENGE_STATUS.CLAIMED]: "challengeStatusClaimed",
};

const getActiveChallengesCount = (state) =>
  Object.values(state || {}).filter((entry) => entry?.status === CHALLENGE_STATUS.ACTIVE).length;

const createChallengeEntry = (id) => ({
  id,
  status: CHALLENGE_STATUS.IDLE,
  progress: 0,
  startedAt: null,
  expiresAt: null,
  completedAt: null,
  claimedAt: null,
  reminderNotificationIds: [],
  extra: {},
});

const createInitialChallengesState = () => {
  const base = {};
  CHALLENGE_DEFS.forEach((def) => {
    base[def.id] = createChallengeEntry(def.id);
  });
  return base;
};

const normalizeChallengesState = (rawState) => {
  const base = createInitialChallengesState();
  if (!rawState || typeof rawState !== "object") return base;
  Object.keys(base).forEach((id) => {
    const entry = rawState[id];
    if (!entry || typeof entry !== "object") return;
    base[id] = {
      ...base[id],
      ...entry,
      id,
      status: entry.status || CHALLENGE_STATUS.IDLE,
      progress: Number(entry.progress) || 0,
      extra: entry.extra && typeof entry.extra === "object" ? entry.extra : {},
      reminderNotificationIds: Array.isArray(entry.reminderNotificationIds)
        ? entry.reminderNotificationIds
        : [],
    };
  });
  return base;
};

const getChallengeCopy = (def, language = DEFAULT_LANGUAGE) => {
  const locale = getShortLanguageKey(language);
  return def.copy?.[locale] || def.copy?.en || {};
};

const isSaveEvent = (kind) => kind === "refuse_spend" || kind === "pending_to_decline";

const buildGoalCelebrationSummary = (history = [], goalId) => {
  if (!Array.isArray(history)) return null;
  const spendStats = {};
  history.forEach((entry) => {
    if (!entry || !Number.isFinite(entry.timestamp)) return;
    if (entry.kind !== "spend") return;
    const dayKey = getDayKey(entry.timestamp);
    if (!dayKey) return;
    const amount = Math.max(0, Number(entry.meta?.amountUSD) || 0);
    const current = spendStats[dayKey] || { spendUSD: 0, count: 0 };
    spendStats[dayKey] = {
      spendUSD: current.spendUSD + amount,
      count: current.count + 1,
    };
  });
  const collectSaveStats = (predicate) => {
    const dayStats = {};
    const titleTotals = {};
    const titleCounts = {};
    let totalSavedUSD = 0;
    let totalCount = 0;
    history.forEach((entry) => {
      if (!entry || !Number.isFinite(entry.timestamp)) return;
      if (!isSaveEvent(entry.kind)) return;
      if (predicate && !predicate(entry)) return;
      const meta = entry.meta || {};
      const amount = Math.max(0, Number(meta.amountUSD) || 0);
      if (!amount) return;
      const dayKey = getDayKey(entry.timestamp);
      if (!dayKey) return;
      totalSavedUSD += amount;
      totalCount += 1;
      const stats = dayStats[dayKey] || { savedUSD: 0, count: 0, titleTotals: {} };
      stats.savedUSD += amount;
      stats.count += 1;
      const title = typeof meta.title === "string" ? meta.title.trim() : "";
      if (title) {
        stats.titleTotals[title] = (stats.titleTotals[title] || 0) + amount;
        titleTotals[title] = (titleTotals[title] || 0) + amount;
        titleCounts[title] = (titleCounts[title] || 0) + 1;
      }
      dayStats[dayKey] = stats;
    });
    return { dayStats, titleTotals, titleCounts, totalSavedUSD, totalCount };
  };
  const isMatchingGoalId = (entryGoalId, targetGoalId) => {
    if (!entryGoalId || !targetGoalId) return false;
    if (entryGoalId === targetGoalId) return true;
    if (!targetGoalId.startsWith("wish_primary_goal_")) {
      return entryGoalId === getPrimaryGoalWishId(targetGoalId);
    }
    if (!entryGoalId.startsWith("wish_primary_goal_")) {
      return targetGoalId === getPrimaryGoalWishId(entryGoalId);
    }
    return false;
  };
  const goalStats = collectSaveStats((entry) => {
    if (!goalId) return false;
    const meta = entry.meta || {};
    const entryGoalId =
      meta.goalId || meta.goal_id || meta.savingTargetId || meta.saving_target_id || null;
    return isMatchingGoalId(entryGoalId, goalId);
  });
  const allStats = collectSaveStats(() => true);
  const activeStats = goalId ? goalStats : allStats;
  const usingFallback = false;
  const resolveTopTitle = (stats) => {
    if (!stats?.titleTotals) return "";
    let topTitle = "";
    let topValue = 0;
    Object.entries(stats.titleTotals).forEach(([title, value]) => {
      const amount = Number(value) || 0;
      if (amount > topValue) {
        topValue = amount;
        topTitle = title;
      }
    });
    return topTitle;
  };
  const getDayTimestamp = (key) => parseDayKey(key)?.getTime() || 0;
  const dayKeys = Object.keys(activeStats.dayStats || {});
  let strongDay = null;
  dayKeys.forEach((key) => {
    const stats = activeStats.dayStats[key];
    const savedUSD = stats?.savedUSD || 0;
    const dayTs = getDayTimestamp(key);
    if (
      !strongDay ||
      savedUSD > strongDay.savedUSD ||
      (savedUSD === strongDay.savedUSD && dayTs > strongDay.dayTs)
    ) {
      strongDay = {
        dayKey: key,
        dayTs,
        savedUSD,
        count: stats?.count || 0,
        topTitle: resolveTopTitle(stats),
      };
    }
  });
  const hasSpendOnGoalDays = dayKeys.some((key) => (spendStats[key]?.count || 0) > 0);
  let weakDay = null;
  if (hasSpendOnGoalDays) {
    dayKeys.forEach((key) => {
      const spend = spendStats[key];
      if (!spend || spend.count <= 0) return;
      const stats = activeStats.dayStats[key] || {};
      const dayTs = getDayTimestamp(key);
      if (
        !weakDay ||
        spend.count > weakDay.spendCount ||
        (spend.count === weakDay.spendCount && spend.spendUSD > weakDay.spendUSD) ||
        (spend.count === weakDay.spendCount &&
          spend.spendUSD === weakDay.spendUSD &&
          dayTs > weakDay.dayTs)
      ) {
        weakDay = {
          dayKey: key,
          dayTs,
          savedUSD: stats.savedUSD || 0,
          count: stats.count || 0,
          spendCount: spend.count,
          spendUSD: spend.spendUSD || 0,
          topTitle: resolveTopTitle(stats),
        };
      }
    });
  } else {
    dayKeys.forEach((key) => {
      const stats = activeStats.dayStats[key];
      const savedUSD = stats?.savedUSD || 0;
      const dayTs = getDayTimestamp(key);
      if (
        !weakDay ||
        savedUSD < weakDay.savedUSD ||
        (savedUSD === weakDay.savedUSD && dayTs > weakDay.dayTs)
      ) {
        weakDay = {
          dayKey: key,
          dayTs,
          savedUSD,
          count: stats?.count || 0,
          spendCount: 0,
          spendUSD: 0,
          topTitle: resolveTopTitle(stats),
        };
      }
    });
  }
  const now = Date.now();
  const lastSevenDays = [];
  let maxWeekSavedUSD = 0;
  for (let i = 6; i >= 0; i -= 1) {
    const dayKey = getDayKey(now - i * DAY_MS);
    const stats = activeStats.dayStats[dayKey] || {};
    const savedUSD = stats.savedUSD || 0;
    const count = stats.count || 0;
    maxWeekSavedUSD = Math.max(maxWeekSavedUSD, savedUSD);
    lastSevenDays.push({ dayKey, savedUSD, count });
  }
  const breakdown = Object.keys(activeStats.titleTotals || {})
    .map((title) => ({
      title,
      savedUSD: activeStats.titleTotals[title] || 0,
      count: activeStats.titleCounts?.[title] || 0,
    }))
    .sort((a, b) => {
      if (b.savedUSD !== a.savedUSD) return b.savedUSD - a.savedUSD;
      return b.count - a.count;
    })
    .slice(0, 6);
  return {
    totalSavedUSD: activeStats.totalSavedUSD,
    totalCount: activeStats.totalCount,
    daysCount: dayKeys.length,
    strongDay,
    weakDay,
    weakMode: hasSpendOnGoalDays ? "spend" : "low",
    lastSevenDays,
    maxWeekSavedUSD,
    breakdown,
    usingFallback,
  };
};

const getDayIndexFromTimestamp = (timestamp) => {
  const date = new Date(timestamp);
  date.setHours(0, 0, 0, 0);
  return Math.floor(date.getTime() / DAY_MS);
};

const isWeekendTimestamp = (timestamp) => {
  const day = new Date(timestamp).getDay();
  return day === 0 || day === 6;
};

const isMorningTimestamp = (timestamp) => {
  const hours = new Date(timestamp).getHours();
  return hours < 12;
};

const finalizeChallengeEntry = (entry, def, timestamp) => {
  if ((entry.progress || 0) >= def.targetValue) {
    return {
      ...entry,
      progress: def.targetValue,
      status: CHALLENGE_STATUS.COMPLETED,
      completedAt: timestamp,
    };
  }
  return entry;
};

const applyChallengeEvent = (state = createInitialChallengesState(), event) => {
  if (!event) return state;
  let changed = false;
  const now = event.timestamp || Date.now();
  const nextState = { ...state };
  Object.keys(nextState).forEach((id) => {
    const entry = state[id] || createChallengeEntry(id);
    const def = CHALLENGE_DEF_MAP[id];
    if (!def || entry.status !== CHALLENGE_STATUS.ACTIVE) return;
    if (entry.expiresAt && now > entry.expiresAt) return;
    const updated = processChallengeEvent(entry, def, event, now);
    if (updated !== entry) {
      nextState[id] = updated;
      changed = true;
    }
  });
  return changed ? nextState : state;
};

const processChallengeEvent = (entry, def, event, now) => {
  const timestamp = event.timestamp || now;
  const meta = event.meta || {};
  let delta = 0;
  switch (def.metricType) {
    case CHALLENGE_METRIC_TYPES.SAVE_COUNT:
      if (isSaveEvent(event.kind)) {
        delta = 1;
      }
      break;
    case CHALLENGE_METRIC_TYPES.SAVE_AMOUNT:
      if (isSaveEvent(event.kind)) {
        const amount = Number(meta.amountUSD) || 0;
        if (amount > 0) {
          delta = amount;
        }
      }
      break;
    case CHALLENGE_METRIC_TYPES.PENDING_DECISIONS:
      if (event.kind === "pending_to_decline") {
        delta = 1;
      }
      break;
    case CHALLENGE_METRIC_TYPES.WISH_ADDED:
      if (event.kind === "wish_added") {
        delta = 1;
      }
      break;
    case CHALLENGE_METRIC_TYPES.PENDING_ADDED:
      if (event.kind === "pending_added") {
        delta = 1;
      }
      break;
    case CHALLENGE_METRIC_TYPES.WEEKEND_SAVES:
      if (isSaveEvent(event.kind) && isWeekendTimestamp(timestamp)) {
        delta = 1;
      }
      break;
    case CHALLENGE_METRIC_TYPES.HIGH_VALUE_SAVE:
      if (isSaveEvent(event.kind)) {
        const highAmount = Number(meta.amountUSD) || 0;
        if (highAmount >= (def.minAmountUSD || 0)) {
          delta = 1;
        }
      }
      break;
    case CHALLENGE_METRIC_TYPES.FREE_DAY_STREAK:
      if (event.kind === "free_day") {
        const dayIndex = getDayIndexFromTimestamp(timestamp);
        const lastDay =
          typeof entry.extra?.lastDayIndex === "number" ? entry.extra.lastDayIndex : null;
        const prevStreak = entry.extra?.currentStreak || 0;
        let nextStreak = 1;
        if (lastDay === dayIndex) {
          nextStreak = prevStreak;
        } else if (lastDay === dayIndex - 1) {
          nextStreak = prevStreak + 1;
        }
        const nextExtra = { ...entry.extra, lastDayIndex: dayIndex, currentStreak: nextStreak };
        if (nextStreak === prevStreak && lastDay === dayIndex) {
          return entry;
        }
        return finalizeChallengeEntry(
          {
            ...entry,
            progress: Math.min(def.targetValue, nextStreak),
            extra: nextExtra,
          },
          def,
          now
        );
      }
      break;
    case CHALLENGE_METRIC_TYPES.REFUSE_DAY_STREAK:
      if (isSaveEvent(event.kind)) {
        const dayIndex = getDayIndexFromTimestamp(timestamp);
        const lastDay =
          typeof entry.extra?.lastRefuseDayIndex === "number"
            ? entry.extra.lastRefuseDayIndex
            : null;
        const prevStreak = entry.extra?.refuseStreak ?? 0;
        let nextStreak = 1;
        if (lastDay === dayIndex) {
          nextStreak = prevStreak;
        } else if (lastDay === dayIndex - 1) {
          nextStreak = prevStreak + 1;
        }
        const nextExtra = {
          ...entry.extra,
          lastRefuseDayIndex: dayIndex,
          refuseStreak: nextStreak,
        };
        if (nextStreak === prevStreak && lastDay === dayIndex) {
          return entry;
        }
        return finalizeChallengeEntry(
          {
            ...entry,
            progress: Math.min(def.targetValue, nextStreak),
            extra: nextExtra,
          },
          def,
          now
        );
      }
      break;
    case CHALLENGE_METRIC_TYPES.MORNING_FREE_DAY:
      if (event.kind === "free_day" && isMorningTimestamp(timestamp)) {
        const dayIndex = getDayIndexFromTimestamp(timestamp);
        const seenDays = Array.isArray(entry.extra?.morningDays) ? entry.extra.morningDays : [];
        if (seenDays.includes(dayIndex)) {
          return entry;
        }
        const updatedDays = [...seenDays, dayIndex];
        return finalizeChallengeEntry(
          {
            ...entry,
            progress: Math.min(def.targetValue, (entry.progress || 0) + 1),
            extra: { ...entry.extra, morningDays: updatedDays },
          },
          def,
          now
        );
      }
      break;
    default:
      break;
  }
  if (!delta) return entry;
  return finalizeChallengeEntry(
    {
      ...entry,
      progress: Math.min(def.targetValue, (entry.progress || 0) + delta),
    },
    def,
    now
  );
};

const expireChallenges = (state = createInitialChallengesState(), now = Date.now()) => {
  let changed = false;
  const next = { ...state };
  Object.keys(next).forEach((id) => {
    const entry = next[id];
    if (
      entry?.status === CHALLENGE_STATUS.ACTIVE &&
      entry.expiresAt &&
      now > entry.expiresAt
    ) {
      next[id] = {
        ...entry,
        status: CHALLENGE_STATUS.EXPIRED,
      };
      changed = true;
    }
  });
  return changed ? next : state;
};

const rebuildChallengeProgressFromHistory = (history = [], state = createInitialChallengesState()) => {
  if (!Array.isArray(history) || !state) return state;
  const sortedEvents = history
    .filter((event) => event && typeof event.timestamp === "number")
    .sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
  if (!sortedEvents.length) return state;
  let changed = false;
  const nextState = { ...state };
  Object.keys(nextState).forEach((id) => {
    const entry = nextState[id];
    const def = CHALLENGE_DEF_MAP[id];
    if (
      !entry ||
      !def ||
      !entry.startedAt ||
      (entry.status !== CHALLENGE_STATUS.ACTIVE && entry.status !== CHALLENGE_STATUS.COMPLETED)
    ) {
      return;
    }
    let rebuilt = {
      ...entry,
      progress: 0,
      completedAt: null,
      status: CHALLENGE_STATUS.ACTIVE,
      extra: {},
    };
    sortedEvents.forEach((event) => {
      if (!event) return;
      const ts = event.timestamp || 0;
      if (ts < entry.startedAt) return;
      if (entry.expiresAt && ts > entry.expiresAt) return;
      rebuilt = processChallengeEvent(rebuilt, def, event, ts);
    });
    const extraChanged =
      JSON.stringify(rebuilt.extra || {}) !== JSON.stringify(entry.extra || {});
    if (
      rebuilt.progress !== entry.progress ||
      rebuilt.status !== entry.status ||
      (rebuilt.completedAt || null) !== (entry.completedAt || null) ||
      extraChanged
    ) {
      nextState[id] = {
        ...entry,
        progress: rebuilt.progress,
        status: rebuilt.status,
        completedAt: rebuilt.completedAt,
        extra: rebuilt.extra,
        claimedAt: rebuilt.status === CHALLENGE_STATUS.COMPLETED ? entry.claimedAt : null,
      };
      changed = true;
    }
  });
  return changed ? nextState : state;
};

const formatChallengeTimeLeft = (ms, t) => {
  if (ms <= 0) return t("challengeTimeExpired");
  const days = Math.floor(ms / DAY_MS);
  const hours = Math.floor((ms % DAY_MS) / (1000 * 60 * 60));
  const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
  if (days > 0) {
    return `${days}${t("challengeTimeDayShort")}${hours > 0 ? ` ${hours}${t("challengeTimeHourShort")}` : ""}`.trim();
  }
  if (hours > 0) {
    return `${hours}${t("challengeTimeHourShort")}${
      minutes > 0 ? ` ${minutes}${t("challengeTimeMinuteShort")}` : ""
    }`.trim();
  }
  return `${Math.max(minutes, 1)}${t("challengeTimeMinuteShort")}`;
};

const getChallengeCooldownRemaining = (entry, now = Date.now()) => {
  if (!entry) return 0;
  const completedAt = Number(entry.completedAt || entry.claimedAt || 0) || 0;
  if (!completedAt) return 0;
  return Math.max(0, completedAt + CHALLENGE_REPEAT_COOLDOWN_MS - now);
};

const getChallengeSortGroup = (challenge) => {
  if (!challenge) return 3;
  if (challenge.status === CHALLENGE_STATUS.ACTIVE) return 0;
  if (!challenge.isLevelLocked) return 1;
  return 2;
};

const compareChallengesForDisplay = (a, b) => {
  const groupA = getChallengeSortGroup(a);
  const groupB = getChallengeSortGroup(b);
  if (groupA !== groupB) return groupA - groupB;
  const orderA = CHALLENGE_STATUS_ORDER[a.status] ?? 99;
  const orderB = CHALLENGE_STATUS_ORDER[b.status] ?? 99;
  if (orderA !== orderB) return orderA - orderB;
  if (a.unlockLevel !== b.unlockLevel) return a.unlockLevel - b.unlockLevel;
  if (a.durationDays !== b.durationDays) return a.durationDays - b.durationDays;
  if (a.targetValue !== b.targetValue) return a.targetValue - b.targetValue;
  return 0;
};

const sortChallengesForDisplay = (list) => list.sort(compareChallengesForDisplay);

const buildChallengesDisplay = ({
  state,
  currency,
  language,
  t,
  maxActiveChallenges = Infinity,
  averageSaveActionUSD = FALLBACK_SAVE_ACTION_USD,
  playerLevel = 1,
}) => {
  const currencyCode = currency || DEFAULT_PROFILE.currency;
  const now = Date.now();
  const limitThreshold = Number.isFinite(maxActiveChallenges) ? maxActiveChallenges : Infinity;
  const activeCount = getActiveChallengesCount(state);
  const isLimitBlockingNewStart = Number.isFinite(limitThreshold) && activeCount >= limitThreshold;
  const list = CHALLENGE_DEFS.map((def) => {
    const entry = state?.[def.id] || createChallengeEntry(def.id);
    const progressValue = entry.progress || 0;
    const percent = def.targetValue > 0 ? Math.min(1, progressValue / def.targetValue) : 0;
    const copy = getChallengeCopy(def, language);
    const targetLabel =
      def.metricType === CHALLENGE_METRIC_TYPES.SAVE_AMOUNT
        ? formatCurrency(convertToCurrency(def.targetValue, currencyCode), currencyCode, { friendly: true })
        : `${def.targetValue}`;
    const progressLabelValue =
      def.metricType === CHALLENGE_METRIC_TYPES.SAVE_AMOUNT
        ? formatCurrency(convertToCurrency(progressValue, currencyCode), currencyCode)
        : `${Math.floor(progressValue)}`;
    const amountLabel =
      def.metricType === CHALLENGE_METRIC_TYPES.SAVE_AMOUNT
        ? targetLabel
        : "";
    const limitLabel = def.minAmountUSD
      ? formatCurrency(convertToCurrency(def.minAmountUSD, currencyCode), currencyCode, { friendly: true })
      : "";
    const description =
      copy.desc && copy.desc.length
        ? renderTemplateString(copy.desc, {
            count: def.targetValue,
            days: def.durationDays,
            amount: amountLabel,
            limit: limitLabel,
          })
        : "";
    const unlockLevel = def.unlockLevel || 1;
    const isLevelLocked = playerLevel < unlockLevel;
    let timerLabel = t("challengeDurationLabel", { days: def.durationDays });
    const cooldownRemaining =
      entry.status === CHALLENGE_STATUS.CLAIMED ? getChallengeCooldownRemaining(entry, now) : 0;
    const cooldownLabel = cooldownRemaining
      ? t("challengeCooldownLabel", {
          time: formatChallengeTimeLeft(cooldownRemaining, t),
        })
      : "";
    if (entry.status === CHALLENGE_STATUS.ACTIVE && entry.expiresAt) {
      timerLabel = t("challengeTimeLeftLabel", {
        time: formatChallengeTimeLeft(Math.max(0, entry.expiresAt - now), t),
      });
    } else if (entry.status === CHALLENGE_STATUS.COMPLETED) {
      timerLabel = t("challengeReadyToClaim");
    } else if (entry.status === CHALLENGE_STATUS.CLAIMED) {
      timerLabel = cooldownLabel || t("challengeRestartHint", { days: def.durationDays });
    }
    const baseCanStart =
      entry.status === CHALLENGE_STATUS.IDLE ||
      entry.status === CHALLENGE_STATUS.EXPIRED ||
      entry.status === CHALLENGE_STATUS.CLAIMED;
    const cooldownBlocksStart =
      entry.status === CHALLENGE_STATUS.CLAIMED && cooldownRemaining > 0;
    const limitBlocksStart = baseCanStart && isLimitBlockingNewStart;
    const canStart = baseCanStart && !limitBlocksStart && !isLevelLocked && !cooldownBlocksStart;
    const canClaim = entry.status === CHALLENGE_STATUS.COMPLETED;
    let actionLabel = t("challengeActiveCta");
    if (isLevelLocked) {
      actionLabel = t("challengeLockedLevel", { level: unlockLevel });
    }
    if (limitBlocksStart) {
      actionLabel = t("challengeLimitReachedAction", { limit: maxActiveChallenges });
    } else if (cooldownBlocksStart) {
      actionLabel = cooldownLabel;
    } else if (canClaim) {
      actionLabel = t("challengeClaimCta");
    } else if (canStart) {
      actionLabel = t("challengeStartCta");
    }
    const scaledReward = getScaledChallengeReward(def.rewardHealth);
    const potentialSavingsUSD =
      def.metricType === CHALLENGE_METRIC_TYPES.SAVE_AMOUNT
        ? def.targetValue
        : def.metricType === CHALLENGE_METRIC_TYPES.SAVE_COUNT
        ? Math.max(1, averageSaveActionUSD) * def.targetValue
        : 0;
    const potentialSavingsLabel =
      potentialSavingsUSD > 0
        ? formatCurrency(convertToCurrency(potentialSavingsUSD, currencyCode), currencyCode)
        : "";
    return {
      id: def.id,
      emoji: def.emoji,
      title: copy.title || "",
      description,
      rewardHealth: scaledReward,
      rewardLabel: formatHealthRewardLabel(scaledReward, language),
      status: entry.status,
      statusLabel: t(CHALLENGE_STATUS_LABELS[entry.status] || CHALLENGE_STATUS_LABELS[CHALLENGE_STATUS.IDLE]),
      progressPercent: percent,
      progressValue,
      targetValue: def.targetValue,
      durationDays: def.durationDays,
      metricType: def.metricType,
      isCountMetric: def.metricType !== CHALLENGE_METRIC_TYPES.SAVE_AMOUNT,
      progressLabel: t("challengeProgressLabel", {
        current: progressLabelValue,
        target: targetLabel,
      }),
      timerLabel,
      canStart,
      canClaim,
      isLevelLocked,
      unlockLevel,
      actionLabel,
      potentialSavingsLabel,
    };
  });
  return sortChallengesForDisplay(list);
};

const getAchievementRemainingLabel = (metricType, remaining, currency, t) => {
  if (!remaining || remaining <= 0) return "";
  const count = Math.max(1, Math.ceil(remaining));
  switch (metricType) {
    case ACHIEVEMENT_METRIC_TYPES.SAVED_AMOUNT:
      return t("rewardRemainingAmount", {
        amount: formatCurrency(convertToCurrency(remaining, currency), currency, { friendly: true }),
      });
    case ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_TOTAL:
    case ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_STREAK:
      return t("rewardRemainingDays", { count });
    case ACHIEVEMENT_METRIC_TYPES.REFUSE_COUNT:
    case ACHIEVEMENT_METRIC_TYPES.REFUSE_STREAK:
      return t("rewardRemainingRefuse", { count });
    case ACHIEVEMENT_METRIC_TYPES.FRIDGE_ITEMS_COUNT:
      return t("rewardRemainingFridge", { count });
    case ACHIEVEMENT_METRIC_TYPES.FRIDGE_DECISIONS:
      return t("rewardRemainingDecisions", { count });
    default:
      return t("rewardLockedGeneric", { count });
  }
};

const buildAchievements = ({
  savedTotalUSD,
  declineCount,
  freeDayStats,
  declineStreak = 0,
  refuseStreak = 0,
  pendingCount,
  decisionStats,
  currency,
  t,
  language,
}) => {
  const fridgeDecisionsResolved =
    (decisionStats?.resolvedToDeclines || 0) + (decisionStats?.resolvedToWishes || 0);
  const metricValues = {
    [ACHIEVEMENT_METRIC_TYPES.SAVED_AMOUNT]: savedTotalUSD,
    [ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_TOTAL]: freeDayStats?.total || 0,
    [ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_STREAK]: freeDayStats?.current || 0,
    [ACHIEVEMENT_METRIC_TYPES.REFUSE_COUNT]: declineStreak || 0,
    [ACHIEVEMENT_METRIC_TYPES.REFUSE_STREAK]: refuseStreak || 0,
    [ACHIEVEMENT_METRIC_TYPES.FRIDGE_ITEMS_COUNT]: pendingCount,
    [ACHIEVEMENT_METRIC_TYPES.FRIDGE_DECISIONS]: fridgeDecisionsResolved,
  };

  return ACHIEVEMENT_DEFS.map((def) => {
    const value = metricValues[def.metricType] || 0;
    const target = def.targetValue || 0;
    const unlocked = target ? value >= target : true;
    const progress = target ? Math.min(value / target, 1) : 1;
    const remaining = target ? Math.max(target - value, 0) : 0;
    const amountLabel =
      def.metricType === ACHIEVEMENT_METRIC_TYPES.SAVED_AMOUNT
        ? formatCurrency(convertToCurrency(def.targetValue || 0, currency), currency, { friendly: true })
        : null;
    const copySource = def.copy[language] || def.copy.en;
    const applyAmount = (text) =>
      typeof text === "string" && amountLabel ? text.replace("{{amount}}", amountLabel) : text || "";
    const remainingLabel = getAchievementRemainingLabel(def.metricType, remaining, currency, t);
    return {
      id: def.id,
      emoji: def.emoji,
      title: applyAmount(copySource.title),
      desc: applyAmount(copySource.desc),
      unlocked,
      progress,
      currentValue: value,
      targetValue: target,
      metricType: def.metricType,
      remainingLabel,
      rewardHealth: def.rewardHealth || HEALTH_PER_REWARD,
    };
  });
};

const RewardsScreen = React.memo(function RewardsScreen({
  achievements = [],
  challenges = [],
  activePane = "challenges",
  onPaneChange = () => {},
  onChallengeAccept = () => {},
  onChallengeClaim = () => {},
  onChallengeCancel = () => {},
  t,
  colors,
  savedTotalUSD = 0,
  currency = DEFAULT_PROFILE.currency,
  onRewardClaim = () => {},
  healthRewardAmount = HEALTH_PER_REWARD,
  language = DEFAULT_LANGUAGE,
  dailyChallenge = null,
  showChallenges = true,
  showDailyChallengeWidget = true,
  rewardsLocked = false,
  challengesLocked = false,
  dailyChallengeLocked = false,
}) {
  const rewardList = Array.isArray(achievements) ? achievements.filter(Boolean) : [];
  const displayRewards = rewardsLocked ? rewardList.slice(0, 2) : rewardList;
  const challengeList = useMemo(() => {
    const list = Array.isArray(challenges) ? challenges.filter(Boolean) : [];
    return list
      .map((entry, index) => ({ entry, index }))
      .sort((a, b) => {
        const base = compareChallengesForDisplay(a.entry, b.entry);
        if (base !== 0) return base;
        return a.index - b.index;
      })
      .map((item) => item.entry);
  }, [challenges]);
  const isDarkTheme = colors.background === THEMES.dark.background;
  const pane = activePane === "challenges" ? "challenges" : "rewards";
  const challengeSwipeCloserRef = useRef(null);
  const handleChallengeSwipeOpen = useCallback((closer) => {
    if (challengeSwipeCloserRef.current && challengeSwipeCloserRef.current !== closer) {
      challengeSwipeCloserRef.current();
    }
    challengeSwipeCloserRef.current = closer;
  }, []);
  const handleChallengeSwipeClose = useCallback((closer) => {
    if (!closer || challengeSwipeCloserRef.current === closer) {
      challengeSwipeCloserRef.current = null;
    }
  }, []);
  const formatRewardLabel = useCallback(
    (amount) => formatHealthRewardLabel(amount, language),
    [language]
  );
  const dailyChallengeRewardLabel = useMemo(() => {
    const bonus = Number(dailyChallenge?.rewardBonus) || 0;
    return formatHealthRewardLabel(bonus * 2, language);
  }, [dailyChallenge?.rewardBonus, language]);

  const renderChallengeCard = (challenge) => {
    const isLocked = challenge.isLevelLocked;
    const actionPalette = challenge.canClaim && !isLocked
      ? { background: SAVE_ACTION_COLOR, text: "#fff" }
      : challenge.canStart && !isLocked
      ? { background: colors.text, text: colors.background }
      : { background: colors.border, text: colors.muted };
    const confirmAccept = () => {
      Alert.alert(
        t("challengeAcceptConfirmTitle"),
        t("challengeAcceptConfirmMessage", { title: challenge.title }),
        [
          { text: t("challengeAcceptConfirmNo"), style: "cancel" },
          {
            text: t("challengeAcceptConfirmYes"),
            style: "default",
            onPress: () => onChallengeAccept?.(challenge.id),
          },
        ]
      );
    };
    const confirmCancel = () => {
      Alert.alert(
        t("challengeCancelConfirmTitle"),
        t("challengeCancelConfirmMessage", { title: challenge.title }),
        [
          { text: t("challengeCancelConfirmNo"), style: "cancel" },
          {
            text: t("challengeCancelConfirmYes"),
            style: "destructive",
            onPress: () => onChallengeCancel?.(challenge.id),
          },
        ]
      );
    };
    const handleActionPress = () => {
      if (challenge.canClaim) {
        onChallengeClaim?.(challenge.id);
      } else if (challenge.canStart) {
        confirmAccept();
      }
    };
    const isActionEnabled = !isLocked && (challenge.canClaim || challenge.canStart);
    const isSwipeEnabled = challenge.status === CHALLENGE_STATUS.ACTIVE;
    const cardBody = (
      <View
        style={[
          styles.challengeCard,
          { backgroundColor: colors.card, borderColor: colors.border },
          isLocked && styles.challengeCardLocked,
        ]}
      >
        <View
          style={[
            styles.challengeRewardChip,
            styles.challengeRewardChipFloating,
            { backgroundColor: colors.text },
          ]}
        >
          <HealthRewardTokens
            amount={challenge.rewardHealth}
            color={colors.background}
            iconSize={12}
            maxItems={2}
            textSize={10}
            rowStyle={styles.healthRewardTokenRowCompact}
          />
        </View>
        <View style={styles.challengeHeader}>
          <Text style={styles.challengeEmoji}>{challenge.emoji}</Text>
            <View style={{ flex: 1, gap: 4 }}>
              <Text
                style={[styles.challengeTitle, { color: colors.text }]}
                numberOfLines={2}
              adjustsFontSizeToFit
              minimumFontScale={0.9}
            >
              {challenge.title}
              </Text>
              <Text style={[styles.challengeDesc, { color: colors.muted }]} numberOfLines={3}>
                {challenge.description}
              </Text>
              {challenge.potentialSavingsLabel ? (
                <Text style={[styles.challengePotential, { color: colors.text }]}>
                  {t("challengePotentialSavings", { amount: challenge.potentialSavingsLabel })}
                </Text>
              ) : null}
            </View>
          </View>
        <View style={styles.challengeMetaRow}>
          <Text style={[styles.challengeStatus, { color: colors.muted }]}>{challenge.statusLabel}</Text>
          <Text style={[styles.challengeTimer, { color: colors.muted }]}>{challenge.timerLabel}</Text>
        </View>
        {challenge.isCountMetric ? (
          <ChallengeProgressDots total={challenge.targetValue} progress={challenge.progressValue} colors={colors} />
        ) : (
          <View style={[styles.challengeProgressBar, { backgroundColor: colors.border }]}>
            <View
              style={[
                styles.challengeProgressFill,
                { width: `${challenge.progressPercent * 100}%`, backgroundColor: colors.text },
              ]}
            />
          </View>
        )}
        <Text style={[styles.challengeProgressLabel, { color: colors.muted }]}>{challenge.progressLabel}</Text>
        {isLocked ? (
          <View style={styles.challengeLockRow}>
            <Text style={[styles.challengeLockText, { color: colors.muted }]}>
              {t("challengeLockedLevel", { level: challenge.unlockLevel })}
            </Text>
          </View>
        ) : (
          <TouchableOpacity
            style={[styles.challengeActionButton, { backgroundColor: actionPalette.background }]}
            activeOpacity={0.9}
            disabled={!isActionEnabled}
            onPress={handleActionPress}
          >
            <Text style={[styles.challengeActionText, { color: actionPalette.text }]}>
              {challenge.actionLabel}
            </Text>
          </TouchableOpacity>
        )}
      </View>
    );
    if (isSwipeEnabled) {
      return (
        <SwipeableChallengeCard
          key={challenge.id}
          colors={colors}
          cancelLabel={t("challengeCancelAction")}
          onCancel={confirmCancel}
          onSwipeOpen={handleChallengeSwipeOpen}
          onSwipeClose={handleChallengeSwipeClose}
        >
          {cardBody}
        </SwipeableChallengeCard>
      );
    }
    return (
      <View key={challenge.id}>
        {cardBody}
      </View>
    );
  };

  const renderRewardCard = (reward) => {
    const rewardPayout = reward.rewardHealth || healthRewardAmount;
    const rewardLabel = formatRewardLabel(rewardPayout);
    const rewardPalette = reward.unlocked
      ? isDarkTheme
        ? {
            background: "rgba(8,48,30,0.9)",
            border: "rgba(74,221,152,0.6)",
            text: "#D6FFE8",
            badgeBg: "rgba(74,221,152,0.2)",
            badgeText: "#82FFC6",
          }
        : {
            background: "#E6F9EE",
            border: "rgba(58,174,120,0.45)",
            text: "#0E512F",
            badgeBg: "rgba(58,174,120,0.15)",
            badgeText: "#0F5C35",
          }
      : {
          background: colors.card,
          border: colors.border,
          text: colors.text,
          badgeBg: colors.text,
          badgeText: colors.background,
        };
    const cardContent = (
      <View
        style={[
          styles.goalCard,
          {
            backgroundColor: rewardPalette.background,
            borderColor: rewardPalette.border,
            borderWidth: reward.unlocked ? 2 : 1,
            shadowOpacity: reward.unlocked ? 0.15 : 0,
            shadowColor: rewardPalette.border,
            shadowOffset: { width: 0, height: reward.unlocked ? 6 : 0 },
            shadowRadius: reward.unlocked ? 12 : 0,
            elevation: reward.unlocked ? 4 : 0,
          },
        ]}
      >
        <View style={styles.rewardHeader}>
          <View style={{ flexDirection: "row", gap: 12, alignItems: "center", flex: 1 }}>
            <Text style={{ fontSize: 28 }}>{reward.emoji}</Text>
            <View style={{ flex: 1 }}>
              <Text style={[styles.goalTitle, { color: rewardPalette.text }]}>{reward.title}</Text>
              <Text style={[styles.goalDesc, { color: colors.muted }]}>{reward.desc}</Text>
            </View>
          </View>
        {reward.unlocked && (
          <View style={styles.rewardBadgeContainer}>
            <View
              style={[
                styles.rewardBadge,
                styles.rewardBadgeFloating,
                { backgroundColor: rewardPalette.badgeBg },
              ]}
            >
              {reward.claimed ? (
                <Text style={[styles.rewardBadgeText, { color: rewardPalette.badgeText }]}>
                  {t("rewardBadgeClaimed")}
                </Text>
              ) : (
                <HealthRewardTokens
                  amount={rewardPayout}
                  color={rewardPalette.badgeText}
                  iconSize={18}
                  maxItems={3}
                />
              )}
            </View>
          </View>
        )}
        </View>
        <View style={[styles.goalProgressBar, { backgroundColor: colors.border }]}>
          <View
            style={[
              styles.goalProgressFill,
              {
                width: `${reward.progress * 100}%`,
                backgroundColor: reward.unlocked ? rewardPalette.badgeText : colors.muted,
              },
            ]}
          />
        </View>
        <Text style={[styles.goalDesc, { color: colors.muted }]}>
          {reward.unlocked
            ? reward.claimed
              ? t("rewardClaimedStatus")
              : t("rewardClaimHint", { amount: rewardLabel })
            : reward.remainingLabel || t("rewardLockedGeneric", { count: 1 })}
        </Text>
        {reward.unlocked && !reward.claimed && (
          <TouchableOpacity
            style={[styles.rewardClaimButton, { backgroundColor: rewardPalette.badgeText }]}
            onPress={(event) => {
              event?.stopPropagation?.();
              onRewardClaim?.(reward);
            }}
          >
            <Text style={[styles.rewardClaimButtonText, { color: rewardPalette.background }]}>
              {t("rewardClaimCta")}
            </Text>
          </TouchableOpacity>
        )}
      </View>
    );
    const isClaimable = reward.unlocked && !reward.claimed;
    return (
      <TouchableOpacity
        key={reward.id}
        activeOpacity={isClaimable ? 0.85 : 1}
        onPress={() => (isClaimable ? onRewardClaim?.(reward) : undefined)}
        disabled={!isClaimable}
      >
        {cardContent}
      </TouchableOpacity>
    );
  };
  const renderDailyChallengeWidget = () => {
    if (dailyChallengeLocked) {
      return (
        <LockedFeatureCard
          variantKey="rewardsDaily"
          colors={colors}
          t={t}
          style={styles.lockedFeatureInlineCard}
        />
      );
    }
    if (!showDailyChallengeWidget || !dailyChallenge) return null;
    const progress = Math.min(
      Math.max(Number(dailyChallenge.progress) || 0, 0),
      Number(dailyChallenge.target) || 1
    );
    const target = Math.max(Number(dailyChallenge.target) || 1, 1);
    const rewardLabel = dailyChallengeRewardLabel;
    const percent = Math.min(Math.max(progress / target, 0), 1);
    const widgetBackground = colors.background === THEMES.dark.background ? "rgba(255,255,255,0.05)" : "#FFF7EA";
    const widgetBorder = colors.background === THEMES.dark.background ? "rgba(255,255,255,0.15)" : "rgba(0,0,0,0.06)";
    return (
      <View
        style={[
          styles.dailyChallengeWidget,
          { backgroundColor: widgetBackground, borderColor: widgetBorder },
        ]}
      >
        <View style={styles.dailyChallengeWidgetHeader}>
          <View style={[styles.dailyChallengeBadge, { borderColor: widgetBorder }]}>
            <Text style={[styles.dailyChallengeBadgeText, { color: colors.text }]}>
              {t("dailyChallengeWidgetBadge")}
            </Text>
          </View>
          <View style={styles.dailyChallengeWidgetRewardRow}>
            <HealthRewardTokens amount={dailyChallenge.rewardBonus} color={colors.text} iconSize={16} />
            <View style={[styles.dailyChallengeMultiplierPill, { borderColor: widgetBorder }]}>
              <Text style={[styles.dailyChallengeMultiplierText, { color: colors.text }]}>Ã—2</Text>
            </View>
          </View>
        </View>
        <View style={styles.dailyChallengeWidgetBody}>
          <View style={styles.dailyChallengeEmojiPill}>
            <Text style={styles.dailyChallengeEmojiText}>{dailyChallenge.emoji || "âœ¨"}</Text>
          </View>
          <View style={{ flex: 1, gap: 2 }}>
            <Text style={[styles.dailyChallengeWidgetTitle, { color: colors.text }]}>
              {t("dailyChallengeWidgetTitle")}
            </Text>
            <Text style={[styles.dailyChallengeWidgetDesc, { color: colors.muted }]}>
              {t("dailyChallengeWidgetDesc", { temptation: dailyChallenge.title })}
            </Text>
          </View>
        </View>
        <View style={{ gap: 6 }}>
          <View style={[styles.dailyChallengeProgressBar, { backgroundColor: widgetBorder }]}>
            <View
              style={[
                styles.dailyChallengeProgressFill,
                { width: `${percent * 100}%`, backgroundColor: colors.text },
              ]}
            />
          </View>
          <View style={styles.dailyChallengeWidgetFooter}>
            <Text style={[styles.dailyChallengeProgressLabel, { color: colors.muted }]}>
              {t("dailyChallengeWidgetProgress", { current: `${progress}`, target: `${target}` })}
            </Text>
            <Text style={[styles.dailyChallengeRewardLabel, { color: colors.text }]}>
              {t("dailyChallengeWidgetReward", { amount: rewardLabel })}
            </Text>
          </View>
        </View>
      </View>
    );
  };

  const tabItems = useMemo(() => {
    const tabs = [{ id: "rewards", label: t("challengeRewardsTabTitle") }];
    if (showChallenges) {
      tabs.unshift({ id: "challenges", label: t("challengeTabTitle") });
    }
    return tabs;
  }, [showChallenges, t]);

  return (
    <ScrollView
      style={[styles.container, { backgroundColor: colors.background }]}
      contentContainerStyle={{ paddingBottom: 200, gap: 16 }}
      showsVerticalScrollIndicator={false}
    >
      <View>
        <Text style={[styles.header, { color: colors.text }]}>{t("purchasesTitle")}</Text>
        <Text style={[styles.purchasesSubtitle, { color: colors.muted }]}>
          {t("purchasesSubtitle")}
        </Text>
      </View>
      {tabItems.length > 1 && (
        <View style={styles.rewardsTabs}>
          {tabItems.map((tab) => {
            const isActive = pane === tab.id;
            return (
              <TouchableOpacity
                key={tab.id}
                style={[
                  styles.rewardsTabButton,
                  {
                    backgroundColor: isActive ? colors.text : "transparent",
                    borderColor: isActive ? colors.text : colors.border,
                  },
                ]}
                activeOpacity={0.85}
                onPress={() => {
                  if (tab.id !== pane) {
                    onPaneChange?.(tab.id);
                  }
                }}
              >
                <Text
                  style={[
                    styles.rewardsTabText,
                    { color: isActive ? colors.background : colors.text },
                  ]}
                >
                  {tab.label}
                </Text>
              </TouchableOpacity>
            );
          })}
        </View>
      )}
      {showChallenges && pane === "challenges" ? (
        challengesLocked ? (
          <LockedFeatureOverlay
            locked
            variantKey="rewardsChallenges"
            colors={colors}
            t={t}
            style={styles.lockedFeaturePane}
            contentStyle={styles.lockedFeaturePaneContent}
            centered
          >
            <View style={{ gap: 16 }}>
              {renderDailyChallengeWidget()}
              {challengeList.map(renderChallengeCard)}
              {!challengeList.length && !dailyChallenge && (
                <Text style={[styles.historyEmpty, { color: colors.muted }]}>
                  {t("rewardsEmpty")}
                </Text>
              )}
            </View>
          </LockedFeatureOverlay>
        ) : (
          <View style={{ gap: 16 }}>
            {renderDailyChallengeWidget()}
            {challengeList.map(renderChallengeCard)}
            {!challengeList.length && !dailyChallenge && (
              <Text style={[styles.historyEmpty, { color: colors.muted }]}>
                {t("rewardsEmpty")}
              </Text>
            )}
          </View>
        )
      ) : rewardsLocked ? (
        <LockedFeatureOverlay
          locked
          variantKey="rewardsCustomization"
          colors={colors}
          t={t}
          style={styles.lockedFeaturePane}
          contentStyle={styles.lockedFeaturePaneContent}
          centered
        >
          <View style={{ gap: 16 }}>
            {displayRewards.map(renderRewardCard)}
            {!displayRewards.some((item) => item.unlocked) && (
              <Text style={[styles.historyEmpty, { color: colors.muted }]}>{t("rewardsEmpty")}</Text>
            )}
          </View>
        </LockedFeatureOverlay>
      ) : (
        <View style={{ gap: 16 }}>
          {displayRewards.map(renderRewardCard)}
          {!displayRewards.some((item) => item.unlocked) && (
            <Text style={[styles.historyEmpty, { color: colors.muted }]}>{t("rewardsEmpty")}</Text>
          )}
        </View>
      )}
    </ScrollView>
  );
});

const ProfileScreen = React.memo(function ProfileScreen({
  profile,
  stats,
  isEditing,
  onFieldChange,
  onEditPress,
  onCancelEdit,
  onSaveEdit,
  onThemeToggle,
  onLanguageChange,
  onCurrencyChange,
  soundEnabled = true,
  onSoundToggle,
  spendReducesSavings = false,
  onSpendReductionToggle,
  onResetData,
  onPickImage,
  onHistoryDelete = () => {},
  theme,
  language,
  currencyValue,
  history = [],
  freeDayStats = INITIAL_FREE_DAY_STATS,
  rewardBadgeCount = 0,
  challengeBadges = [],
  challengeBadgeCount = 0,
  t,
  colors,
  moodPreset = null,
  mascotImageSource,
  openAddCategoryModal,
}) {
  const fallbackAvatar = mascotImageSource || CLASSIC_TAMAGOTCHI_ANIMATIONS.idle;
  const currentCurrency = currencyValue || profile.currency || DEFAULT_PROFILE.currency;
  const isDarkTheme = theme === "dark";
  const normalizedLanguageValue = normalizeLanguage(language || DEFAULT_LANGUAGE);
  const isRomanceLocale = normalizedLanguageValue === "es" || normalizedLanguageValue === "fr";
  const historyEntries = Array.isArray(history) ? history : [];
  const locale = getFormatLocale(language);
  const formatLocalAmount = (valueUSD = 0) =>
    formatCurrency(convertToCurrency(valueUSD || 0, currentCurrency), currentCurrency);
  const [baselineInput, setBaselineInput] = useState("");
  const [customSpendInputs, setCustomSpendInputs] = useState({
    title: "",
    amount: "",
    frequency: "",
  });
  const profileEditingRef = useRef(isEditing);
  const profileCurrencyRef = useRef(currentCurrency);
  const profileCurrencyScrollRef = useRef(null);
  const profileCurrencyNudgeRan = useRef(false);
  useEffect(() => {
    if (profileCurrencyNudgeRan.current) return undefined;
    profileCurrencyNudgeRan.current = true;
    let backTimeout;
    const forwardTimeout = setTimeout(() => {
      profileCurrencyScrollRef.current?.scrollTo({ x: 48, animated: true });
      backTimeout = setTimeout(() => {
        profileCurrencyScrollRef.current?.scrollTo({ x: 0, animated: true });
      }, 650);
    }, 900);
    return () => {
      clearTimeout(forwardTimeout);
      if (backTimeout) clearTimeout(backTimeout);
    };
  }, []);
  useEffect(() => {
    const editingJustOpened = isEditing && !profileEditingRef.current;
    const currencyChanged = isEditing && profileCurrencyRef.current !== currentCurrency;
    profileEditingRef.current = isEditing;
    profileCurrencyRef.current = currentCurrency;
    if (!editingJustOpened && !currencyChanged) return;
    const baselineUSD = profile.spendingProfile?.baselineMonthlyWasteUSD || 0;
    setBaselineInput(
      baselineUSD > 0 ? formatNumberInputValue(convertToCurrency(baselineUSD, currentCurrency)) : ""
    );
    const customAmountUSD = resolveCustomPriceUSD(
      profile.customSpend,
      profile.currency || DEFAULT_PROFILE.currency
    );
    const customPrecision =
      typeof profile.customSpend?.pricePrecision === "number" && Number.isFinite(profile.customSpend.pricePrecision)
        ? Math.max(0, Math.min(6, profile.customSpend.pricePrecision))
        : null;
    const customInputPrecision =
      customPrecision !== null ? customPrecision : getCurrencyDisplayPrecision(currentCurrency);
    setCustomSpendInputs({
      title: profile.customSpend?.title || "",
      amount:
        customAmountUSD > 0
          ? formatNumberInputValue(convertToCurrency(customAmountUSD, currentCurrency), customInputPrecision)
          : "",
      frequency: profile.customSpend?.frequencyPerWeek
        ? `${profile.customSpend.frequencyPerWeek}`
        : "",
    });
  }, [
    currentCurrency,
    isEditing,
    profile.currency,
    profile.customSpend,
    profile.spendingProfile?.baselineMonthlyWasteUSD,
  ]);
  const baselineDisplayUSD = profile.spendingProfile?.baselineMonthlyWasteUSD || 0;
  const baselineLocalDisplay = baselineDisplayUSD
    ? formatCurrency(convertToCurrency(baselineDisplayUSD, currentCurrency), currentCurrency)
    : null;
  const customSpendAmountUSD = resolveCustomPriceUSD(
    profile.customSpend,
    profile.currency || DEFAULT_PROFILE.currency
  );
  const customSpendAmountDisplay =
    customSpendAmountUSD > 0
      ? formatCurrency(convertToCurrency(customSpendAmountUSD, currentCurrency), currentCurrency)
      : null;
  const customSpendFrequency = profile.customSpend?.frequencyPerWeek || null;
  const customSpendPlaceholderLabel = formatSampleAmount(CUSTOM_SPEND_SAMPLE_USD, currentCurrency);
  const baselinePlaceholderLabel = formatSampleAmount(BASELINE_SAMPLE_USD, currentCurrency);
  const avatarEditBadgeColors = useMemo(
    () => {
      const dark = theme === "dark";
      return {
        background: dark ? "rgba(0,0,0,0.6)" : "rgba(255,255,255,0.92)",
        border: dark ? "rgba(255,255,255,0.2)" : "rgba(0,0,0,0.08)",
        icon: dark ? colors.card : colors.text,
      };
    },
    [theme, colors.card, colors.text]
  );
  const handleBaselineInputChange = useCallback(
    (text) => {
      setBaselineInput(text);
      const trimmed = text.trim();
      const baseProfile = profile.spendingProfile || { ...DEFAULT_PROFILE.spendingProfile };
      if (!trimmed) {
        onFieldChange?.("spendingProfile", {
          ...baseProfile,
          baselineMonthlyWasteUSD: 0,
          baselineStartAt: null,
        });
        return;
      }
      const parsed = parseNumberInputValue(text);
      if (!Number.isFinite(parsed) || parsed <= 0) return;
      onFieldChange?.("spendingProfile", {
        ...baseProfile,
        baselineMonthlyWasteUSD: convertFromCurrency(parsed, currentCurrency),
        baselineStartAt: new Date().toISOString(),
      });
    },
    [currentCurrency, onFieldChange, profile.spendingProfile]
  );
  const applyCustomSpendDraft = useCallback(
    (nextState) => {
      const trimmedTitle = nextState.title.trim();
      const parsedAmount = parseNumberInputValue(nextState.amount);
      const frequencyValue = parseFloat((nextState.frequency || "").replace(",", "."));
      const hasAmount = Number.isFinite(parsedAmount) && parsedAmount > 0;
      const hasFrequency = Number.isFinite(frequencyValue) && frequencyValue > 0;
      if (!trimmedTitle && !hasAmount && !hasFrequency) {
        onFieldChange?.("customSpend", null);
        return;
      }
      const existing = profile.customSpend || {};
      const next = {
        ...existing,
      };
      next.id = next.id || existing.id || "custom_habit";
      if (trimmedTitle) {
        next.title = trimmedTitle;
      } else {
        delete next.title;
      }
      if (hasAmount) {
        next.amountUSD = convertFromCurrency(parsedAmount, currentCurrency);
        next.currency = currentCurrency;
        next.pricePrecision = getManualInputPrecision(nextState.amount);
      } else {
        delete next.amountUSD;
        delete next.currency;
        delete next.pricePrecision;
      }
      if (hasFrequency) {
        next.frequencyPerWeek = Math.max(1, Math.round(frequencyValue));
      } else {
        delete next.frequencyPerWeek;
      }
      if (!next.title && !next.amountUSD && !next.frequencyPerWeek) {
        onFieldChange?.("customSpend", null);
        return;
      }
      onFieldChange?.("customSpend", next);
    },
    [currentCurrency, onFieldChange, profile.customSpend]
  );
  const handleCustomSpendInputChange = useCallback(
    (field, value) => {
      setCustomSpendInputs((prev) => {
        const nextState = { ...prev, [field]: value };
        applyCustomSpendDraft(nextState);
        return nextState;
      });
    },
    [applyCustomSpendDraft]
  );
  const describeHistory = (entry) => describeHistoryEntry(entry, { t, formatLocalAmount });
  const formatHistoryMeta = (entry) => formatHistoryEntryMeta(entry, { t, locale });
  const joinDateLabel = useMemo(() => {
    const stamp = profile.joinedAt || profile.spendingProfile?.baselineStartAt;
    if (!stamp) return null;
    try {
      const joinedDate = new Date(stamp);
      const dateLabel = joinedDate.toLocaleDateString(locale, {
        day: "numeric",
        month: "long",
        year: "numeric",
      });
      return t("profileJoinDate", { date: dateLabel });
    } catch {
      return null;
    }
  }, [profile.joinedAt, profile.spendingProfile?.baselineStartAt, locale, t]);
  const profileNamePlaceholder = t("profileNamePlaceholder");
  const profileBioPlaceholder = t("profileBioPlaceholder");
  const profileBioValue = typeof profile?.bio === "string" ? profile.bio : "";
  const profileBioText = useMemo(() => {
    const raw = profileBioValue.trim();
    if (!raw) return "";
    if (PROFILE_BIO_FALLBACK_VALUES.includes(raw)) return "";
    return raw;
  }, [profileBioValue]);
  const profileNameDisplay = (profile?.name || "").trim();
  const profileNameText = profileNameDisplay || profileNamePlaceholder;
  const profileBioDisplay = profileBioText || profileBioPlaceholder;
  const profileBioColor = profileBioText ? colors.muted : colorWithAlpha(colors.muted, 0.7);
  const profileSubtitleAdjustments = useMemo(() => {
    if (!isRomanceLocale) return null;
    return {
      fontSize: PROFILE_SUBTITLE_FONT_SIZE * 0.9,
      lineHeight: PROFILE_SUBTITLE_LINE_HEIGHT * 0.9,
    };
  }, [isRomanceLocale]);
  const profileMoodGradient = useMemo(
    () =>
      applyThemeToMoodGradient(getMoodGradient(moodPreset?.id), isDarkTheme ? "dark" : "light"),
    [moodPreset?.id, isDarkTheme]
  );
  const handlePrivacyPolicyOpen = useCallback(() => {
    const normalizedLanguage = normalizeLanguage(language);
    const url = PRIVACY_LINKS[normalizedLanguage] || PRIVACY_LINKS.en;
    if (!url) return;
    triggerHaptic();
    Linking.openURL(url).catch((error) => console.warn("privacy policy", error));
  }, [language]);
  const handleSupportPress = useCallback(() => {
    triggerHaptic();
    Linking.openURL(`mailto:${SUPPORT_EMAIL}`).catch((error) => console.warn("support mail", error));
  }, []);
  const handleInstagramPress = useCallback(() => {
    triggerHaptic();
    Linking.openURL(INSTAGRAM_URL).catch((error) => console.warn("instagram link", error));
  }, []);
  return (
    <View style={[styles.container, { backgroundColor: colors.background }] }>
      <ScrollView
        style={{ flex: 1 }}
        contentContainerStyle={styles.profileScrollContent}
        keyboardShouldPersistTaps="handled"
        showsVerticalScrollIndicator={false}
      >
        <View style={[styles.profileCard, { backgroundColor: colors.card }] }>
          <View style={styles.profileMoodAura}>
            <MoodGradientBlock colors={profileMoodGradient} style={styles.profileMoodGradient}>
              <TouchableOpacity
                style={styles.profileAvatarWrap}
                activeOpacity={isEditing ? 0.85 : 1}
                onPress={() => isEditing && onPickImage?.()}
              >
                <Image
                  source={profile.avatar ? { uri: profile.avatar } : fallbackAvatar}
                  style={styles.profileAvatar}
                  resizeMode="cover"
                />
                {isEditing && (
                  <View
                    style={[
                      styles.profileAvatarEditBadge,
                      { backgroundColor: avatarEditBadgeColors.background, borderColor: avatarEditBadgeColors.border },
                    ]}
                  >
                    <Text style={[styles.profileAvatarEditIcon, { color: avatarEditBadgeColors.icon }]}>âœï¸Ž</Text>
                  </View>
                )}
              </TouchableOpacity>
            </MoodGradientBlock>
            {isEditing && (
              <Text style={[styles.profileAvatarHint, { color: colors.muted }]}>{t("photoTapHint")}</Text>
            )}
            {moodPreset?.label && (
              <Text style={[styles.profileMoodStatus, { color: profileMoodGradient.accent }]}>
                {moodPreset.label}
              </Text>
            )}
          </View>
          {isEditing ? (
            <>
              <TextInput
                style={[
                  styles.profileInput,
                  { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                ]}
                value={profile.name}
                onChangeText={(text) => onFieldChange("name", text)}
                placeholder={t("profileNamePlaceholder")}
                placeholderTextColor={colors.muted}
              />
              <TextInput
                style={[
                  styles.profileInput,
                  styles.profileBioInput,
                  { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                ]}
                value={profile.bio}
                onChangeText={(text) => onFieldChange("bio", text)}
                placeholder={t("profileBioPlaceholder")}
                multiline
                placeholderTextColor={colors.muted}
              />
            </>
          ) : (
            <>
            <View style={styles.profileNameRow}>
              <Text
                style={[
                  styles.profileName,
                  { color: profileNameDisplay ? colors.text : colorWithAlpha(colors.muted, 0.8) },
                ]}
              >
                {profileNameText}
              </Text>
              <View style={styles.profileBadgeRow}>
                {challengeBadgeCount > 0 && (
                  <View style={[styles.profileChallengeBadge, { borderColor: colors.border }]}>
                    <View style={styles.profileChallengeBadgeList}>
                      {challengeBadges.slice(0, 3).map((emoji, index) => (
                        <Text key={`${emoji}-${index}`} style={styles.profileChallengeBadgeEmoji}>
                          {emoji}
                        </Text>
                      ))}
                    </View>
                    <Text style={[styles.profileChallengeBadgeCount, { color: colors.muted }]}>
                      {challengeBadgeCount}
                    </Text>
                  </View>
                )}
              </View>
            </View>
            {joinDateLabel && (
              <Text
                style={[styles.profileSubtitle, { color: colors.muted }, profileSubtitleAdjustments]}
                numberOfLines={1}
                ellipsizeMode="tail"
              >
                {joinDateLabel}
              </Text>
            )}
            <Text style={[styles.profileBio, { color: profileBioColor }]}>
              {profileBioDisplay}
            </Text>
          </>
        )}

          <View style={styles.profileStatsRow}>
            {stats.map((stat) => (
              <View key={stat.label} style={styles.profileStat}>
                <View style={styles.profileStatValueRow}>
                  <Text style={[styles.profileStatValue, { color: colors.text }]}>{stat.value}</Text>
                  {!!stat.suffix && (
                    <Text style={[styles.profileStatValueSuffix, { color: colors.text }]}>
                      {stat.suffix}
                    </Text>
                  )}
                </View>
                <Text style={[styles.profileStatLabel, { color: colors.muted }]} numberOfLines={1}>
                  {stat.label}
                </Text>
              </View>
            ))}
          </View>

          <View style={styles.profileActions}>
            {isEditing ? (
              <>
                <TouchableOpacity
                  style={[styles.profileActionPrimary, { backgroundColor: colors.text }]}
                  onPress={onSaveEdit}
                >
                  <Text style={[styles.profileActionPrimaryText, { color: colors.background }]}>
                    {t("profileSave")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.profileActionSecondary, { borderColor: colors.border }]}
                  onPress={onCancelEdit}
                >
                  <Text style={[styles.profileActionSecondaryText, { color: colors.muted }]}>
                    {t("profileCancel")}
                  </Text>
                </TouchableOpacity>
              </>
            ) : (
              <TouchableOpacity
                style={[styles.profileActionPrimary, { backgroundColor: colors.text }]}
                onPress={onEditPress}
              >
                <Text style={[styles.profileActionPrimaryText, { color: colors.background }]}>
                  {t("profileEdit")}
                </Text>
              </TouchableOpacity>
            )}
          </View>
        </View>

        <View style={[styles.settingsCard, { backgroundColor: colors.card }] }>
          <View style={styles.profileSection}>
            <Text style={[styles.settingLabel, { color: colors.muted }]}>{t("customSpendTitle")}</Text>
            {isEditing ? (
              <View style={{ gap: 10 }}>
                <TextInput
                  style={[
                    styles.profileInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  value={customSpendInputs.title}
                  onChangeText={(text) => handleCustomSpendInputChange("title", text)}
                  placeholder={t("customSpendNamePlaceholder")}
                  placeholderTextColor={colors.muted}
                />
                <TextInput
                  style={[
                    styles.profileInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  value={customSpendInputs.amount}
                  onChangeText={(text) => handleCustomSpendInputChange("amount", text)}
                  placeholder={t("customSpendAmountPlaceholder", { amount: customSpendPlaceholderLabel })}
                  keyboardType="decimal-pad"
                  placeholderTextColor={colors.muted}
                />
                <TextInput
                  style={[
                    styles.profileInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  value={customSpendInputs.frequency}
                  onChangeText={(text) => handleCustomSpendInputChange("frequency", text)}
                  placeholder={t("customSpendFrequencyPlaceholder")}
                  keyboardType="number-pad"
                  placeholderTextColor={colors.muted}
                />
              </View>
            ) : profile.customSpend ? (
              <View style={{ gap: 4 }}>
                <Text style={[styles.profileSettingValue, { color: colors.text }]}>
                  {profile.customSpend.title}
                </Text>
                {customSpendAmountDisplay && (
                  <Text style={[styles.profileHintText, { color: colors.muted }]}>
                    {t("customSpendAmountLabel")}: {customSpendAmountDisplay}
                  </Text>
                )}
                {customSpendFrequency ? (
                  <Text style={[styles.profileHintText, { color: colors.muted }]}>
                    {t("customSpendFrequencyLabel")}: {customSpendFrequency}
                  </Text>
                ) : null}
              </View>
            ) : (
              <Text style={[styles.profileHintText, { color: colors.muted }]}>{t("customSpendHint")}</Text>
            )}
          </View>
          <View style={styles.profileSection}>
            <Text style={[styles.settingLabel, { color: colors.muted }]}>{t("baselineTitle")}</Text>
            {isEditing ? (
              <View style={{ gap: 10 }}>
                <TextInput
                  style={[
                    styles.profileInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  value={baselineInput}
                  onChangeText={handleBaselineInputChange}
                  placeholder={t("baselinePlaceholder", { amount: baselinePlaceholderLabel })}
                  keyboardType="decimal-pad"
                  placeholderTextColor={colors.muted}
                />
              </View>
            ) : baselineLocalDisplay ? (
              <Text style={[styles.profileSettingValue, { color: colors.text }]}>
                {baselineLocalDisplay}
              </Text>
            ) : (
              <Text style={[styles.profileHintText, { color: colors.muted }]}>{t("baselineHint")}</Text>
            )}
          </View>

          <View style={[styles.settingsDivider, { backgroundColor: colors.border }]} />

          <Text style={[styles.settingsTitle, { color: colors.text }]}>{t("settingsTitle")}</Text>
        <View style={styles.settingRow}>
          <Text style={[styles.settingLabel, { color: colors.muted }]}>{t("themeLabel")}</Text>
          <View style={styles.settingChoices}>
            {(["light", "dark"]).map((mode) => (
              <TouchableOpacity
                key={mode}
                style={[
                  styles.settingChip,
                  {
                    backgroundColor: theme === mode ? colors.text : "transparent",
                    borderColor: colors.border,
                  },
                ]}
                onPress={() => onThemeToggle(mode)}
              >
                <Text
                  style={{
                    color: theme === mode ? colors.background : colors.muted,
                    fontWeight: "600",
                  }}
                >
                  {mode === "light" ? t("themeLight") : t("themeDark")}
                </Text>
              </TouchableOpacity>
            ))}
          </View>
        </View>
        <View style={styles.settingRow}>
          <Text style={[styles.settingLabel, { color: colors.muted }]}>{t("languageLabel")}</Text>
          <View style={styles.settingChoices}>
            {SUPPORTED_LANGUAGES.map((lng) => {
              const active = language === lng;
              return (
                <TouchableOpacity
                  key={lng}
                  style={[
                    styles.settingChip,
                    {
                      backgroundColor: active ? colors.text : "transparent",
                      borderColor: colors.border,
                    },
                  ]}
                  onPress={() => onLanguageChange(lng)}
                >
                  <Text
                    style={{
                      color: active ? colors.background : colors.muted,
                      fontWeight: "600",
                    }}
                  >
                    {t(getLanguageLabelKey(lng))}
                  </Text>
                </TouchableOpacity>
              );
            })}
          </View>
        </View>
        <View style={styles.settingRow}>
          <Text style={[styles.settingLabel, { color: colors.muted }]}>
            {t("currencyLabel")} <Text style={{ fontSize: 16 }}>â†’</Text>
          </Text>
          <View style={styles.settingCurrencyScrollWrapper}>
            <ScrollView
              ref={profileCurrencyScrollRef}
              horizontal
              showsHorizontalScrollIndicator={false}
              style={styles.settingCurrencyScroll}
              contentContainerStyle={styles.settingCurrencyScrollContent}
            >
              {CURRENCIES.map((code) => (
                <TouchableOpacity
                  key={code}
                  style={[
                    styles.settingChip,
                    {
                      backgroundColor: currentCurrency === code ? colors.text : "transparent",
                      borderColor: colors.border,
                    },
                  ]}
                  onPress={() => onCurrencyChange?.(code)}
                >
                  <Text
                    style={{
                      color: currentCurrency === code ? colors.background : colors.muted,
                      fontWeight: "600",
                    }}
                  >
                    {code}
                  </Text>
                </TouchableOpacity>
              ))}
            </ScrollView>
          </View>
        </View>
        <View style={styles.settingRow}>
          <View style={styles.settingRowContent}>
            <View style={{ flex: 1 }}>
              <Text style={[styles.settingLabel, { color: colors.muted }]}>{t("addCategoryLabel")}</Text>
              <Text style={[styles.profileHintText, { color: colors.muted }]}>{t("addCategoryHint")}</Text>
            </View>
            <TouchableOpacity
              style={[styles.settingChip, { borderColor: colors.border, backgroundColor: colors.text }]}
              onPress={openAddCategoryModal}
            >
              <Text style={{ color: colors.background, fontWeight: "600" }}>
                {t("addCategoryButton")}
              </Text>
            </TouchableOpacity>
          </View>
        </View>
        <View style={styles.settingRow}>
          <View style={styles.settingRowContent}>
            <View style={{ flex: 1 }}>
              <Text style={[styles.settingLabel, { color: colors.muted }]}>{t("spendReductionLabel")}</Text>
              <Text style={[styles.profileHintText, { color: colors.muted }]}>{t("spendReductionHint")}</Text>
            </View>
            <Pressable
              onPress={() => onSpendReductionToggle?.(!spendReducesSavings)}
              style={[
                styles.settingToggle,
                {
                  backgroundColor: spendReducesSavings
                    ? colors.text
                    : colorWithAlpha(colors.text, 0.15),
                  borderColor: colors.border,
                },
              ]}
            >
              <View
                style={[
                  styles.settingToggleHandle,
                  {
                    backgroundColor: spendReducesSavings ? colors.background : colors.card,
                    transform: [{ translateX: spendReducesSavings ? 20 : 0 }],
                  },
                ]}
              />
            </Pressable>
          </View>
        </View>
        <View style={styles.settingRow}>
          <View style={styles.settingRowContent}>
            <View style={{ flex: 1 }}>
              <Text style={[styles.settingLabel, { color: colors.muted }]}>{t("soundLabel")}</Text>
              <Text style={[styles.profileHintText, { color: colors.muted }]}>{t("soundHint")}</Text>
            </View>
            <Pressable
              onPress={() => onSoundToggle?.(!soundEnabled)}
              style={[
                styles.settingToggle,
                {
                  backgroundColor: soundEnabled
                    ? colors.text
                    : colorWithAlpha(colors.text, 0.15),
                  borderColor: colors.border,
                },
              ]}
            >
              <View
                style={[
                  styles.settingToggleHandle,
                  {
                    backgroundColor: soundEnabled ? colors.background : colors.card,
                    transform: [{ translateX: soundEnabled ? 20 : 0 }],
                  },
                ]}
              />
            </Pressable>
          </View>
        </View>
        <TouchableOpacity
          style={[styles.resetButton, { borderColor: colors.border }]}
          onPress={onResetData}
        >
          <Text style={[styles.resetButtonText, { color: colors.muted }]}>
            {t("developerReset")}
          </Text>
        </TouchableOpacity>
        </View>

        <View style={[styles.historyCard, { backgroundColor: colors.card }] }>
          <Text style={[styles.historyTitle, { color: colors.text }]}>{t("historyTitle")}</Text>
          {historyEntries.length === 0 ? (
            <Text style={[styles.historyEmpty, { color: colors.muted }]}>{t("historyEmpty")}</Text>
          ) : (
            <ScrollView
              style={[
                styles.historyList,
                {
                  borderColor: colors.border,
                  height: HISTORY_VIEWPORT_HEIGHT,
                },
              ]}
              contentContainerStyle={styles.historyListContent}
              showsVerticalScrollIndicator
              nestedScrollEnabled
              scrollEventThrottle={16}
            >
              {historyEntries.map((entry, index) => (
                <View
                  key={entry.id}
                  style={[
                    styles.historyItem,
                    {
                      borderColor: colors.border,
                      borderBottomWidth:
                        index === historyEntries.length - 1 ? 0 : StyleSheet.hairlineWidth,
                    },
                  ]}
                >
                  <View style={styles.historyRow}>
                    <View style={{ flex: 1 }}>
                      <Text style={[styles.historyItemTitle, { color: colors.text }]}>
                        {describeHistory(entry)}
                      </Text>
                      <Text style={[styles.historyItemMeta, { color: colors.muted }]}>
                        {formatHistoryMeta(entry)}
                      </Text>
                    </View>
                    <TouchableOpacity
                      style={[styles.historyDeleteBtn, { borderColor: colors.border }]}
                      onPress={() => onHistoryDelete?.(entry)}
                    >
                      <Text style={[styles.historyDeleteText, { color: colors.muted }]}>âœ•</Text>
                    </TouchableOpacity>
                  </View>
                </View>
              ))}
            </ScrollView>
          )}
        </View>
        <TouchableOpacity
          style={[
            styles.profileLinkButton,
            { borderColor: colors.border, backgroundColor: colors.card },
          ]}
          activeOpacity={0.85}
          onPress={handlePrivacyPolicyOpen}
        >
          <Text style={[styles.profileLinkText, { color: colors.text }]}>{t("privacyPolicyLink")}</Text>
          <Text style={[styles.profileLinkHint, { color: colors.muted }]}>{t("privacyPolicyHint")}</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[
            styles.profileLinkButton,
            { borderColor: colors.border, backgroundColor: colors.card },
          ]}
          activeOpacity={0.85}
          onPress={handleInstagramPress}
        >
          <Text style={[styles.profileLinkText, { color: colors.text }]}>{t("instagramLink")}</Text>
          <Text style={[styles.profileLinkHint, { color: colors.muted }]}>{t("instagramHint")}</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[
            styles.profileLinkButton,
            { borderColor: colors.border, backgroundColor: colors.card },
          ]}
          activeOpacity={0.85}
          onPress={handleSupportPress}
        >
          <Text style={[styles.profileLinkText, { color: colors.text }]}>{t("supportLink")}</Text>
          <Text style={[styles.profileLinkHint, { color: colors.muted }]}>{t("supportHint")}</Text>
        </TouchableOpacity>
      </ScrollView>
    </View>
  );
});

function AppContent() {
  const [fontsLoaded, fontsError] = useFonts({
    Inter_300Light,
    Inter_400Regular,
    Inter_500Medium,
    Inter_600SemiBold,
    Inter_700Bold,
    Inter_800ExtraBold,
    Inter_900Black,
  });
  const soundsRef = useRef({});
  const soundCooldownRef = useRef({});
  const soundModeReadyRef = useRef(false);
  const [soundEnabled, setSoundEnabled] = useState(true);
  const [soundEnabledHydrated, setSoundEnabledHydrated] = useState(false);
  const resolveInterruptionModeIOS = useCallback(() => {
    return (
      AudioModule?.InterruptionModeIOS?.MixWithOthers ??
      AudioModule?.INTERRUPTION_MODE_IOS_MIX_WITH_OTHERS ??
      2
    );
  }, []);
  const resolveInterruptionModeAndroid = useCallback(() => {
    return (
      AudioModule?.InterruptionModeAndroid?.DuckOthers ??
      AudioModule?.INTERRUPTION_MODE_ANDROID_DUCK_OTHERS ??
      1
    );
  }, []);
  const stopAllSounds = useCallback(() => {
    Object.values(soundsRef.current).forEach((sound) => {
      sound?.stopAsync?.().catch(() => {});
    });
  }, []);
  const playSound = useCallback(async (key, options = {}) => {
    if (!AudioModule) return;
    if (!key) return;
    if (!soundEnabled) return;
    const now = Date.now();
    const cooldown = SOUND_COOLDOWNS[key] || 0;
    const lastPlayed = soundCooldownRef.current[key] || 0;
    const skipCooldown = !!options?.skipCooldown;
    if (!skipCooldown && cooldown && now - lastPlayed < cooldown) return;
    if (!skipCooldown) {
      soundCooldownRef.current[key] = now;
    }
    if (!soundModeReadyRef.current) {
      const interruptionModeIOS = resolveInterruptionModeIOS();
      const interruptionModeAndroid = resolveInterruptionModeAndroid();
      try {
        await AudioModule.setAudioModeAsync({
          playsInSilentModeIOS: false,
          interruptionModeIOS,
          interruptionModeAndroid,
          shouldDuckAndroid: true,
          staysActiveInBackground: false,
        });
        soundModeReadyRef.current = true;
      } catch (error) {
        console.warn("sound mode", error);
      }
    }
    const volume = SOUND_VOLUMES[key] ?? 0.8;
    let sound = soundsRef.current[key];
    if (!sound && SOUND_FILES[key]) {
      try {
        const loaded = await AudioModule.Sound.createAsync(SOUND_FILES[key], {
          shouldPlay: false,
          volume,
        });
        sound = loaded.sound;
        soundsRef.current[key] = sound;
      } catch (error) {
        console.warn("sound lazy load", error);
        return;
      }
    }
    if (!sound) return;
    try {
      if (sound.setVolumeAsync) {
        await sound.setVolumeAsync(volume);
      }
      await sound.setPositionAsync(0);
      await sound.playAsync();
    } catch (error) {
      console.warn("sound play", error);
    }
  }, [soundEnabled]);
  useEffect(() => {
    let active = true;
    const task = InteractionManager.runAfterInteractions(() => {
      (async () => {
        try {
          if (!AudioModule) return;
          const interruptionModeIOS = resolveInterruptionModeIOS();
          const interruptionModeAndroid = resolveInterruptionModeAndroid();
          try {
            await AudioModule.setAudioModeAsync({
              playsInSilentModeIOS: false,
              interruptionModeIOS,
              interruptionModeAndroid,
              shouldDuckAndroid: true,
              staysActiveInBackground: false,
            });
            soundModeReadyRef.current = true;
          } catch (error) {
            console.warn("sound mode", error);
          }
          const entries = Object.entries(SOUND_FILES).filter(([key]) => PRELOAD_SOUND_KEYS.has(key));
          let loadedCount = 0;
          for (const [key, asset] of entries) {
            const volume = SOUND_VOLUMES[key] ?? 0.8;
            const { sound } = await AudioModule.Sound.createAsync(asset, {
              shouldPlay: false,
              volume,
            });
            if (!active) {
              await sound.unloadAsync();
              continue;
            }
            soundsRef.current[key] = sound;
            loadedCount += 1;
          }
        } catch (error) {
          console.warn("sound init", error);
        }
      })();
    });
    return () => {
      active = false;
      task?.cancel?.();
      Object.values(soundsRef.current).forEach((sound) => {
        sound?.unloadAsync?.().catch(() => {});
      });
      soundsRef.current = {};
    };
  }, []);
  const [wishes, setWishes] = useState([]);
  const [wishesHydrated, setWishesHydrated] = useState(false);
  const wishesRef = useRef(wishes);
  const [freeDayHydrated, setFreeDayHydrated] = useState(false);
  const [purchases, setPurchases] = useState([]);
  const [purchasesHydrated, setPurchasesHydrated] = useState(false);
  const deferredHydrationPayloadRef = useRef(null);
  const deferredHydrationReadyRef = useRef(false);
  const deferredHydrationInFlightRef = useRef(false);
  const [deferredHydrationReady, setDeferredHydrationReady] = useState(false);
  const [activeTab, setActiveTabState] = useState("feed");
  const [tabHistory, setTabHistoryState] = useState([]);
  const tabHistoryRef = useRef(tabHistory);
  const pendingScrollRef = useRef(null);
  const pendingCardLayoutsRef = useRef(new Map());
  const [pendingFocusId, setPendingFocusId] = useState(null);
  const persistQueueRef = useRef(new Map());
  const persistTimerRef = useRef(null);
  const flushPersistQueue = useCallback(
    (immediate = false) => {
      if (persistTimerRef.current) {
        clearTimeout(persistTimerRef.current);
        persistTimerRef.current = null;
      }
      const entries = Array.from(persistQueueRef.current.entries());
      if (!entries.length) return;
      persistQueueRef.current.clear();
      const write = () => {
        AsyncStorage.multiSet(entries).catch(() => {});
      };
      if (immediate) {
        write();
        return;
      }
      InteractionManager.runAfterInteractions(write);
    },
    []
  );
  const queuePersist = useCallback(
    (key, value) => {
      if (!key || typeof value === "undefined") return;
      const stringValue = typeof value === "string" ? value : String(value);
      persistQueueRef.current.set(key, stringValue);
      if (persistTimerRef.current) {
        clearTimeout(persistTimerRef.current);
      }
      persistTimerRef.current = setTimeout(() => {
        flushPersistQueue(false);
      }, PERSIST_DEBOUNCE_MS);
    },
    [flushPersistQueue]
  );
  useEffect(() => () => flushPersistQueue(true), [flushPersistQueue]);
  const [homeSpeechTrigger, setHomeSpeechTrigger] = useState({ tick: 0, reason: "init" });
  const homeSpeechReadyRef = useRef(false);
  const homeSpeechBootedRef = useRef(false);
  const triggerHomeSpeech = useCallback((reason = "unknown") => {
    setHomeSpeechTrigger((prev) => ({ tick: prev.tick + 1, reason }));
  }, []);
  const onboardingCompletedRef = useRef(false);
  useEffect(() => {
    wishesRef.current = wishes;
  }, [wishes]);

  useEffect(() => {
    tabHistoryRef.current = tabHistory;
  }, [tabHistory]);
  const updateTabHistory = useCallback((updater) => {
    setTabHistoryState((prev) => {
      const next = typeof updater === "function" ? updater(prev) : updater;
      tabHistoryRef.current = next;
      return next;
    });
  }, []);
  const goToTab = useCallback(
    (tabKey, { recordHistory = true, resetHistory = false } = {}) => {
      setActiveTabState((current) => {
        if (resetHistory) {
          updateTabHistory([]);
        }
        if (current === tabKey) {
          return current;
        }
        if (recordHistory && current && !resetHistory) {
          updateTabHistory((prev) => {
            const trimmed =
              prev.length >= MAX_TAB_HISTORY ? prev.slice(prev.length - (MAX_TAB_HISTORY - 1)) : prev;
            return [...trimmed, current];
          });
        }
        return tabKey;
      });
    },
    [updateTabHistory]
  );
  const registerPendingCardLayout = useCallback((id, layout) => {
    if (!id || !layout) return;
    pendingCardLayoutsRef.current.set(id, layout.y);
  }, []);
  const handleProgressChallengeOpen = useCallback(
    (challengeId) => {
      if (challengeId) {
        setProgressFocusChallengeId(challengeId);
      }
      goToTab("cart");
    },
    [goToTab]
  );
  const [catalogOverrides, setCatalogOverrides] = useState({});
  const [catalogHydrated, setCatalogHydrated] = useState(false);
  const [pricePrecisionOverrides, setPricePrecisionOverrides] = useState({});
  const [pricePrecisionOverridesHydrated, setPricePrecisionOverridesHydrated] = useState(false);
  const [titleOverrides, setTitleOverrides] = useState({});
  const [titleOverridesHydrated, setTitleOverridesHydrated] = useState(false);
  const [emojiOverrides, setEmojiOverrides] = useState({});
  const [emojiOverridesHydrated, setEmojiOverridesHydrated] = useState(false);
  const [categoryOverrides, setCategoryOverrides] = useState({});
  const [categoryOverridesHydrated, setCategoryOverridesHydrated] = useState(false);
  const [customCategories, setCustomCategories] = useState([]);
  const [customCategoriesHydrated, setCustomCategoriesHydrated] = useState(false);
  const [descriptionOverrides, setDescriptionOverrides] = useState({});
  const [descriptionOverridesHydrated, setDescriptionOverridesHydrated] = useState(false);
  const [temptations, setTemptations] = useState(DEFAULT_TEMPTATIONS);
  const [quickTemptations, setQuickTemptations] = useState([]);
  const [quickTemptationsHydrated, setQuickTemptationsHydrated] = useState(false);
  const [hiddenTemptations, setHiddenTemptations] = useState([]);
  const [hiddenTemptationsHydrated, setHiddenTemptationsHydrated] = useState(false);
  const [priceEditor, setPriceEditor] = useState({
    item: null,
    value: "",
    title: "",
    emoji: "",
    category: DEFAULT_IMPULSE_CATEGORY,
    description: "",
  });
  const [customReminderId, setCustomReminderId] = useState(null);
  const [customReminderHydrated, setCustomReminderHydrated] = useState(false);
  const [smartReminders, setSmartReminders] = useState([]);
  const [smartRemindersHydrated, setSmartRemindersHydrated] = useState(false);
  const [potentialPushProgress, setPotentialPushProgress] = useState({
    ...DEFAULT_POTENTIAL_PUSH_STATE,
  });
  const [potentialPushHydrated, setPotentialPushHydrated] = useState(false);
  const [dailyNudgeNotificationIds, setDailyNudgeNotificationIds] = useState({});
  const [dailyNudgesHydrated, setDailyNudgesHydrated] = useState(false);
  const [dailyChallenge, setDailyChallenge] = useState(() => createInitialDailyChallengeState());
  const [dailyChallengeHydrated, setDailyChallengeHydrated] = useState(false);
  const [savedTotalUSD, setSavedTotalUSD] = useState(0);
  const [savedTotalHydrated, setSavedTotalHydrated] = useState(false);
  const [lastCelebratedLevel, setLastCelebratedLevel] = useState(1);
  const [lastCelebratedLevelHydrated, setLastCelebratedLevelHydrated] = useState(false);
  const persistLastCelebratedLevel = useCallback(
    (nextLevel) => {
      const normalized = Math.max(1, Number(nextLevel) || 1);
      setLastCelebratedLevel(normalized);
      AsyncStorage.setItem(
        STORAGE_KEYS.LAST_CELEBRATED_LEVEL,
        String(normalized)
      ).catch(() => {});
    },
    []
  );
  const [lifetimeSavedUSD, setLifetimeSavedUSD] = useState(0);
  const [lifetimeSavedHydrated, setLifetimeSavedHydrated] = useState(false);
  const [declineCount, setDeclineCount] = useState(0);
  const [declinesHydrated, setDeclinesHydrated] = useState(false);
  const [pendingList, setPendingList] = useState([]);
  const [pendingBadgeTick, setPendingBadgeTick] = useState(0);
  const [pendingHydrated, setPendingHydrated] = useState(false);
  useEffect(() => {
    pendingCardLayoutsRef.current.clear();
  }, [pendingList]);
  const [freeDayStats, setFreeDayStats] = useState({ ...INITIAL_FREE_DAY_STATS });
  const [healthPoints, setHealthPoints] = useState(0);
  const [healthHydrated, setHealthHydrated] = useState(false);
  const [dailyRewardState, setDailyRewardState] = useState({ ...DEFAULT_DAILY_REWARD_STATE });
  const [dailyRewardHydrated, setDailyRewardHydrated] = useState(false);
  const [dailyRewardModalVisible, setDailyRewardModalVisible] = useState(false);
  const [currentDayKey, setCurrentDayKey] = useState(() => getDayKey(Date.now()));
  const [claimedRewards, setClaimedRewards] = useState({});
  const [claimedRewardsHydrated, setClaimedRewardsHydrated] = useState(false);
  const safeClaimedRewards = useMemo(
    () => (claimedRewards && typeof claimedRewards === "object" ? claimedRewards : {}),
    [claimedRewards]
  );
  const [rewardClaimTotal, setRewardClaimTotal] = useState(0);
  const [rewardTotalHydrated, setRewardTotalHydrated] = useState(false);
  const pruneClaimedRewards = useCallback(() => {
    setClaimedRewards((prev) => {
      const normalized = normalizeClaimedRewardsMap(prev || {});
      if (claimedRewardsEqual(prev || {}, normalized)) {
        return prev;
      }
      return normalized;
    });
  }, []);
  useEffect(() => {
    pruneClaimedRewards();
    const interval = setInterval(pruneClaimedRewards, DAY_MS);
    return () => clearInterval(interval);
  }, [pruneClaimedRewards]);
  const dayRolloverTimerRef = useRef(null);
  useEffect(() => {
    const scheduleNextMidnight = () => {
      if (dayRolloverTimerRef.current) {
        clearTimeout(dayRolloverTimerRef.current);
      }
      const now = Date.now();
      const nextMidnight = new Date(now);
      nextMidnight.setHours(24, 0, 0, 0);
      const delay = Math.max(1000, nextMidnight.getTime() - now);
      dayRolloverTimerRef.current = setTimeout(() => {
        setCurrentDayKey(getDayKey(Date.now()));
        scheduleNextMidnight();
      }, delay);
    };
    scheduleNextMidnight();
    return () => {
      if (dayRolloverTimerRef.current) {
        clearTimeout(dayRolloverTimerRef.current);
      }
    };
  }, []);
  const [challengesState, setChallengesState] = useState(() => createInitialChallengesState());
  const [challengesHydrated, setChallengesHydrated] = useState(false);
  const [rewardsPane, setRewardsPane] = useState("rewards");
  useEffect(() => {
    if (challengesUnlocked) return;
    if (rewardsPane !== "rewards") {
      setRewardsPane("rewards");
    }
  }, [challengesUnlocked, rewardsPane]);
  const [decisionStats, setDecisionStats] = useState({ ...INITIAL_DECISION_STATS });
  const [decisionStatsHydrated, setDecisionStatsHydrated] = useState(false);
  const [historyEvents, setHistoryEvents] = useState([]);
  const [historyHydrated, setHistoryHydrated] = useState(false);
  const resolvedHistoryEvents = Array.isArray(historyEvents) ? historyEvents : [];
  const [progressFocusChallengeId, setProgressFocusChallengeId] = useState(null);
  const declineStreak = useMemo(() => computeRefuseStreak(resolvedHistoryEvents), [resolvedHistoryEvents]);
  const levelProgressUSD = Math.max(savedTotalUSD || 0, lifetimeSavedUSD || 0);
  const profileCurrencyCode = profile?.currency || DEFAULT_PROFILE.currency;
  const fabMainIcon = useMemo(() => {
    if (activeTab === "feed") {
      const label = formatCurrency(0, profileCurrencyCode);
      const parts = splitCurrencyLabel(label, profileCurrencyCode);
      return parts.symbol || "$";
    }
    return "+";
  }, [activeTab, profileCurrencyCode]);
  const playerTierInfo = useMemo(
    () => getTierProgress(levelProgressUSD || 0, profileCurrencyCode),
    [levelProgressUSD, profileCurrencyCode]
  );
  const playerLevel = playerTierInfo.level;
  const hasSpendHistory = useMemo(
    () => resolvedHistoryEvents.some((entry) => entry.kind === "spend"),
    [resolvedHistoryEvents]
  );
  const dailyChallengeUnlocked = playerLevel >= 2 && hasSpendHistory;
  const dailyRewardUnlocked = playerLevel >= 2;
  const focusModeUnlocked = playerLevel >= 3;
  const dailySummaryUnlocked = playerLevel >= 3;
  const focusTargetsUnlocked = playerLevel >= 5;
  const catCustomizationUnlocked = playerLevel >= 6;
  const rewardsUnlocked = playerLevel >= 5;
  const challengesUnlocked = true;
  const impulseFeaturesUnlocked = playerLevel >= 4;
  const freeDayUnlocked = playerLevel >= 7;
  const thinkingUnlocked = playerLevel >= 3;
  const todayKey = currentDayKey;
  const baseDailyRewardAmount = useMemo(
    () => (dailyRewardUnlocked ? computeDailyAlmiReward(levelProgressUSD) : 0),
    [dailyRewardUnlocked, levelProgressUSD]
  );
  const dailyRewardLastKey = useMemo(() => {
    if (dailyRewardState.lastKey) return dailyRewardState.lastKey;
    if (Number.isFinite(dailyRewardState.lastClaimAt) && dailyRewardState.lastClaimAt > 0) {
      return getDayKey(dailyRewardState.lastClaimAt);
    }
    return null;
  }, [dailyRewardState.lastClaimAt, dailyRewardState.lastKey]);
  const dailyRewardDay = useMemo(() => {
    if (!dailyRewardHydrated) return 1;
    if (!dailyRewardLastKey) return 1;
    const dayDiff = getDayDiff(dailyRewardLastKey, todayKey);
    const currentStreak = Math.max(1, dailyRewardState.streak || 1);
    const normalizedStreak =
      ((currentStreak - 1) % DAILY_REWARD_STREAK_LENGTH) + 1;
    if (dayDiff === 0) {
      return normalizedStreak;
    }
    if (dayDiff === 1) {
      return (normalizedStreak % DAILY_REWARD_STREAK_LENGTH) + 1;
    }
    return 1;
  }, [dailyRewardHydrated, dailyRewardLastKey, dailyRewardState.streak, todayKey]);
  const dailyRewardAmount = useMemo(
    () => (dailyRewardUnlocked ? getDailyRewardForDay(baseDailyRewardAmount, dailyRewardDay) : 0),
    [baseDailyRewardAmount, dailyRewardDay, dailyRewardUnlocked]
  );
  const dailyRewardReady =
    dailyRewardUnlocked &&
    dailyRewardHydrated &&
    healthHydrated &&
    dailyRewardLastKey !== todayKey &&
    dailyRewardAmount > 0;
  const dailyRewardDisplayAmount =
    dailyRewardReady ? dailyRewardAmount : dailyRewardState.lastAmount || dailyRewardAmount || 0;
  useEffect(() => {
    if (!dailyRewardHydrated || !dailyRewardLastKey) return;
    const dayDiff = getDayDiff(dailyRewardLastKey, todayKey);
    if (!Number.isFinite(dayDiff) || dayDiff <= 1) return;
    setDailyRewardState((prev) => {
      if (!prev) return prev;
      if (
        (prev.streak || 0) === 0 &&
        (prev.lastAmount || 0) === 0 &&
        !prev.lastKey &&
        !prev.lastClaimAt
      ) {
        return prev;
      }
      return {
        ...prev,
        streak: 0,
        lastAmount: 0,
        lastKey: null,
        lastClaimAt: 0,
      };
    });
  }, [dailyRewardHydrated, dailyRewardLastKey, todayKey]);
  const handleDailyRewardClaim = useCallback(async () => {
    if (!dailyRewardUnlocked || dailyRewardAmount <= 0) return;
    const claimTimestamp = Date.now();
    const claimKey = getDayKey(claimTimestamp);
    const storedRaw = await AsyncStorage.getItem(STORAGE_KEYS.DAILY_REWARD).catch(() => null);
    const storedDayKey = await AsyncStorage.getItem(STORAGE_KEYS.DAILY_REWARD_DAY_KEY).catch(
      () => null
    );
    if (storedDayKey && storedDayKey === claimKey) {
      return;
    }
    if (storedRaw) {
      try {
        const parsed = JSON.parse(storedRaw);
        const storedKey =
          typeof parsed?.lastKey === "string" && parsed.lastKey
            ? parsed.lastKey
            : Number(parsed?.lastClaimAt)
            ? getDayKey(Number(parsed.lastClaimAt))
            : null;
        if (storedKey === claimKey) {
          return;
        }
      } catch (error) {
        console.warn("daily reward claim read", error);
      }
    }
    if (!dailyRewardReady) return;
    const rewardLabel = formatHealthRewardLabel(dailyRewardAmount, language);
    const dayDiff = getDayDiff(dailyRewardLastKey, claimKey);
    const normalizedStreak =
      ((Math.max(1, dailyRewardState.streak || 1) - 1) % DAILY_REWARD_STREAK_LENGTH) + 1;
    const nextStreak = dayDiff === 1 ? (normalizedStreak % DAILY_REWARD_STREAK_LENGTH) + 1 : 1;
    const nextDailyRewardState = {
      lastKey: claimKey,
      lastAmount: dailyRewardAmount,
      lastClaimAt: claimTimestamp,
      streak: nextStreak,
    };
    setDailyRewardState(nextDailyRewardState);
    AsyncStorage.setItem(
      STORAGE_KEYS.DAILY_REWARD,
      JSON.stringify(nextDailyRewardState)
    ).catch(() => {});
    AsyncStorage.setItem(STORAGE_KEYS.DAILY_REWARD_DAY_KEY, claimKey).catch(() => {});
    setHealthPoints((prev) => prev + dailyRewardAmount);
    triggerCoinRewardHaptics();
    ensureOverlayEnvironmentReady();
    triggerOverlayState(
      "daily_reward",
      {
        amount: rewardLabel,
        amountValue: dailyRewardAmount,
        reason: t("dailyRewardReason", { amount: rewardLabel }),
      },
      { force: true }
    );
    logEvent("daily_reward_claimed", {
      coins: dailyRewardAmount,
      level: playerLevel,
      day: nextStreak,
    });
    if (nextStreak >= 1 && nextStreak <= DAILY_REWARD_STREAK_LENGTH) {
      logEvent(`daily_reward_collected_day_${nextStreak}`, {
        coins: dailyRewardAmount,
        level: playerLevel,
      });
    }
  }, [
    dailyRewardAmount,
    dailyRewardReady,
    dailyRewardUnlocked,
    dailyRewardLastKey,
    dailyRewardState.streak,
    ensureOverlayEnvironmentReady,
    language,
    logEvent,
    playSound,
    playerLevel,
    setDailyRewardState,
    setHealthPoints,
    t,
    triggerOverlayState,
  ]);
  const appTutorialSteps = useMemo(
    () =>
      APP_TUTORIAL_BASE_STEPS.filter((step) => {
        if (step.requiresRewards && !rewardsUnlocked) {
          return false;
        }
        return true;
      }),
    [rewardsUnlocked]
  );
  const priceLimitUSD = getTemptationPriceLimitForLevel(playerLevel);
  const previousPlayerLevelRef = useRef(playerLevel);
  const resetInProgressRef = useRef(false);
  const [coinEntryVisible, setCoinEntryVisible] = useState(false);
  const coinEntryContextRef = useRef({ source: null, openedAt: 0, submitted: false });
  const [coinSliderMaxUSD, setCoinSliderMaxUSD] = useState(DEFAULT_COIN_SLIDER_MAX_USD);
  const [coinSliderHydrated, setCoinSliderHydrated] = useState(false);
  const [savingsBreakdownVisible, setSavingsBreakdownVisible] = useState(false);
  const [spendBreakdownVisible, setSpendBreakdownVisible] = useState(false);
  const [spendBreakdownRange, setSpendBreakdownRange] = useState("week");
  const [spendBreakdownOffset, setSpendBreakdownOffset] = useState(0);
  const products = useMemo(
    () => filterTemptationsByPrice(temptations, priceLimitUSD),
    [temptations, priceLimitUSD]
  );
  const [profile, setProfile] = useState(() => ({
    ...DEFAULT_PROFILE_PLACEHOLDER,
    joinedAt: new Date().toISOString(),
  }));
  const spendReducesSavings = !!(profile && profile.spendReducesSavings);
  const [profileHydrated, setProfileHydrated] = useState(false);
  const [profileDraft, setProfileDraft] = useState(() => ({
    ...DEFAULT_PROFILE_PLACEHOLDER,
    joinedAt: new Date().toISOString(),
  }));
  const [primaryTemptationPromptState, setPrimaryTemptationPromptState] = useState("done");
  const [primaryTemptationPromptHydrated, setPrimaryTemptationPromptHydrated] = useState(false);
  const markPrimaryTemptationPromptDone = useCallback(() => {
    setPrimaryTemptationPromptState("done");
    AsyncStorage.setItem(STORAGE_KEYS.PRIMARY_TEMPTATION_PROMPT, "done").catch(() => {});
  }, []);
  const schedulePrimaryTemptationPrompt = useCallback(() => {
    setPrimaryTemptationPromptState("pending");
    setPrimaryTemptationPromptHydrated(true);
    setTemptationTutorialCompleted(false);
    setTemptationTutorialStatus("pending");
    setTemptationTutorialSeen(false);
    AsyncStorage.setItem(STORAGE_KEYS.PRIMARY_TEMPTATION_PROMPT, "pending").catch(() => {});
  }, []);
  const [northStarLogged, setNorthStarLogged] = useState(false);
  const [northStarHydrated, setNorthStarHydrated] = useState(false);
  const northStarLoggedRef = useRef(false);
  const [northStar2Logged, setNorthStar2Logged] = useState(false);
  const northStar2LoggedRef = useRef(false);
  const potentialOpenSnapshotRef = useRef(null);
  const potentialGrowthInitialCheckRef = useRef(false);
  const [potentialSnapshotHydrated, setPotentialSnapshotHydrated] = useState(false);
  const [potentialGrowthUSD, setPotentialGrowthUSD] = useState(0);
  const [potentialGrowthVisible, setPotentialGrowthVisible] = useState(false);
  const baselineMonthlyWasteUSD = Math.max(
    0,
    Number(profile?.spendingProfile?.baselineMonthlyWasteUSD) || 0
  );
  const baselineStartAt = profile?.spendingProfile?.baselineStartAt || null;
  const getPotentialSavedNow = useCallback(
    () => calcPotentialSaved(baselineMonthlyWasteUSD, baselineStartAt),
    [baselineMonthlyWasteUSD, baselineStartAt]
  );
  const profileJoinedAt = profile?.joinedAt || null;
  const dayMilestonesLoggedRef = useRef({ day2: false, day3: false });
  useEffect(() => {
    let cancelled = false;
    AsyncStorage.multiGet([STORAGE_KEYS.DAY_TWO_ACTIVITY, STORAGE_KEYS.DAY_THREE_ACTIVITY])
      .then((entries) => {
        if (cancelled || !Array.isArray(entries)) return;
        const logged = { ...dayMilestonesLoggedRef.current };
        entries.forEach(([key, value]) => {
          if (key === STORAGE_KEYS.DAY_TWO_ACTIVITY && value) {
            logged.day2 = true;
          }
          if (key === STORAGE_KEYS.DAY_THREE_ACTIVITY && value) {
            logged.day3 = true;
          }
        });
        dayMilestonesLoggedRef.current = logged;
      })
      .catch(() => {});
    return () => {
      cancelled = true;
    };
  }, []);
  const maybeLogDayMilestone = useCallback(
    (actionType) => {
      if (actionType !== "save" && actionType !== "spend") return;
      if (!profileJoinedAt) return;
      const joinedAtTimestamp = new Date(profileJoinedAt).getTime();
      if (!Number.isFinite(joinedAtTimestamp)) return;
      const ordinalDay = Math.floor((Date.now() - joinedAtTimestamp) / DAY_MS) + 1;
      if (ordinalDay === 2 && !dayMilestonesLoggedRef.current.day2) {
        dayMilestonesLoggedRef.current = { ...dayMilestonesLoggedRef.current, day2: true };
        AsyncStorage.setItem(STORAGE_KEYS.DAY_TWO_ACTIVITY, "1").catch(() => {});
        logEvent("day_2");
      } else if (ordinalDay === 3 && !dayMilestonesLoggedRef.current.day3) {
        dayMilestonesLoggedRef.current = { ...dayMilestonesLoggedRef.current, day3: true };
        AsyncStorage.setItem(STORAGE_KEYS.DAY_THREE_ACTIVITY, "1").catch(() => {});
        logEvent("day_3");
      }
    },
    [profileJoinedAt, logEvent]
  );
  const potentialBaselineKey =
    baselineMonthlyWasteUSD > 0 && baselineStartAt
      ? `${baselineStartAt}:${baselineMonthlyWasteUSD}`
      : null;
  const dismissPotentialGrowth = useCallback(() => {
    setPotentialGrowthVisible(false);
  }, []);
  const storePotentialSnapshot = useCallback((valueUSD) => {
    const normalized = Number(valueUSD);
    if (!Number.isFinite(normalized)) return;
    potentialOpenSnapshotRef.current = normalized;
    AsyncStorage.setItem(STORAGE_KEYS.POTENTIAL_OPEN_SNAPSHOT, String(normalized)).catch(() => {});
  }, []);
  const maybeShowPotentialGrowth = useCallback(
    (currentUSD) => {
      const normalized = Number(currentUSD);
      if (!Number.isFinite(normalized)) return;
      if (!potentialBaselineKey) {
        storePotentialSnapshot(normalized);
        return;
      }
      const previous = Number(potentialOpenSnapshotRef.current);
      storePotentialSnapshot(normalized);
      if (!Number.isFinite(previous)) return;
      const delta = normalized - previous;
      if (delta <= 0.01) return;
      setPotentialGrowthUSD(delta);
      setPotentialGrowthVisible(true);
    },
    [potentialBaselineKey, storePotentialSnapshot]
  );
  const prevActiveTabRef = useRef(activeTab);
  useEffect(() => {
    if (prevActiveTabRef.current && prevActiveTabRef.current !== activeTab) {
      dismissPotentialGrowth();
    }
    if (activeTab === "feed" && prevActiveTabRef.current && prevActiveTabRef.current !== "feed") {
      triggerHomeSpeech("tab");
    }
    prevActiveTabRef.current = activeTab;
  }, [activeTab, dismissPotentialGrowth, triggerHomeSpeech]);
  const prevOnboardingStepRef = useRef(onboardingStep);
  useEffect(() => {
    if (prevOnboardingStepRef.current && prevOnboardingStepRef.current !== onboardingStep) {
      dismissPotentialGrowth();
    }
    prevOnboardingStepRef.current = onboardingStep;
  }, [dismissPotentialGrowth, onboardingStep]);
  useEffect(() => {
    let cancelled = false;
    AsyncStorage.getItem(STORAGE_KEYS.POTENTIAL_OPEN_SNAPSHOT)
      .then((value) => {
        if (cancelled) return;
        if (typeof value === "string" && value.length > 0) {
          const parsed = Number(value);
          if (Number.isFinite(parsed)) {
            potentialOpenSnapshotRef.current = parsed;
          }
        }
        setPotentialSnapshotHydrated(true);
      })
      .catch(() => {
        setPotentialSnapshotHydrated(true);
      });
    return () => {
      cancelled = true;
    };
  }, []);
  useEffect(() => {
    if (!potentialSnapshotHydrated) return;
    const normalized = Number(getPotentialSavedNow());
    if (!Number.isFinite(normalized)) return;
    if (Number.isFinite(potentialOpenSnapshotRef.current)) return;
    storePotentialSnapshot(normalized);
  }, [getPotentialSavedNow, potentialSnapshotHydrated, storePotentialSnapshot]);
  const [language, setLanguage] = useState(DEFAULT_LANGUAGE);
  const [languageHydrated, setLanguageHydrated] = useState(false);
  const normalizedLanguageValue = normalizeLanguage(language);
  const isRomanceLocale = normalizedLanguageValue === "es" || normalizedLanguageValue === "fr";
  const baseTabFontSize = Platform.OS === "ios" ? 12 : 13;
  const tabLabelFontSize = isRomanceLocale ? baseTabFontSize - 1 : baseTabFontSize;
  const tabOrder = ["feed", "cart", "pending", "purchases", "profile"];
  const [homeLayoutReady, setHomeLayoutReady] = useState(false);
  const [startupHydrated, setStartupHydrated] = useState(false);
  const fontsReady = fontsLoaded || Boolean(fontsError);
  const startupLogoReady = fontsReady && startupHydrated;
  useEffect(() => {
    if (potentialGrowthInitialCheckRef.current) return;
    if (!startupHydrated) return;
    if (!potentialSnapshotHydrated) return;
    const normalized = Number(getPotentialSavedNow());
    if (!Number.isFinite(normalized)) return;
    potentialGrowthInitialCheckRef.current = true;
    maybeShowPotentialGrowth(normalized);
  }, [getPotentialSavedNow, maybeShowPotentialGrowth, potentialSnapshotHydrated, startupHydrated]);
  const primaryTemptationId = profile.customSpend?.id || "custom_habit";
  const primaryTemptationDescription = useMemo(() => {
    const gender = profile?.gender || "none";
    const description = buildCustomTemptationDescription(gender);
    return description?.[language] || description?.en || "";
  }, [language, profile?.gender]);
  const [activeGoalId, setActiveGoalId] = useState(null);
  const [activeGoalHydrated, setActiveGoalHydrated] = useState(false);
  const [isEditingProfile, setIsEditingProfile] = useState(false);
  const [theme, setTheme] = useState(DEFAULT_THEME);
  const [themeHydrated, setThemeHydrated] = useState(false);
  const isAndroid = Platform.OS === "android";
  const androidVersion = isAndroid ? Number(Platform.Version) : null;
  const canSetSystemBarColors =
    isAndroid && typeof androidVersion === "number" && !Number.isNaN(androidVersion) && androidVersion < 35;
  const canToggleNavVisibility =
    isAndroid && typeof androidVersion === "number" && !Number.isNaN(androidVersion) && androidVersion < 35;
  const resolveTemplateCard = useCallback(
    (templateId) => {
      if (!templateId) return null;
      const findInList = (list) => (list || []).find((card) => card?.id === templateId);
      return findInList(quickTemptations) || findInList(temptations) || findTemplateById(templateId) || null;
    },
    [quickTemptations, temptations]
  );
  const resolveTemplateTitle = useCallback(
    (templateId, fallback = null) => {
      if (!templateId) return fallback;
      const source = resolveTemplateCard(templateId);
      if (!source) return fallback;
      const overrideTitle =
        typeof titleOverrides?.[templateId] === "string" && titleOverrides[templateId].trim()
          ? titleOverrides[templateId].trim()
          : null;
      const rawTitle =
        overrideTitle ||
        source.titleOverride ||
        (typeof source.title === "string"
          ? source.title
          : source.title?.[language] || source.title?.en || source.title?.ru || source.title) ||
        fallback;
      const decorated = `${source.emoji || ""} ${rawTitle || ""}`.trim();
      return decorated || fallback;
    },
    [language, resolveTemplateCard, titleOverrides]
  );
  const [overlay, setOverlay] = useState(null);
  const [pendingGoalCelebration, setPendingGoalCelebration] = useState(null);
  const [confettiKey, setConfettiKey] = useState(0);
  const overlayTimer = useRef(null);
  const overlayRetryTimerRef = useRef(null);
  const feedScreenRef = useRef(null);

  const overlayQueueRef = useRef([]);
  const overlayActiveRef = useRef(false);
  const lastOverlayDismissedAtRef = useRef(0);
  const lastSaveOverlayDismissedAtRef = useRef(0);
  const pendingLevelCelebrationRef = useRef(null);
  const levelCelebrationQueuedRef = useRef(0);
  const celebrationGapTimerRef = useRef(null);
  const celebrationQueueRef = useRef([]);
  const lastCelebrationAtRef = useRef(0);
  const queueCelebrationOverlayRef = useRef(null);
  const [dailySummaryVisible, setDailySummaryVisible] = useState(false);
  const [dailySummaryData, setDailySummaryData] = useState(null);
  const [dailySummarySeenKey, setDailySummarySeenKey] = useState(null);
  const [pendingDailySummaryData, setPendingDailySummaryData] = useState(null);
  const [dailySummaryOpenToken, setDailySummaryOpenToken] = useState(0);
  const dailySummaryOpenProcessedRef = useRef(0);
  const queuedModalQueueRef = useRef([]);
  const queuedModalActiveRef = useRef(null);
  const [queuedModalType, setQueuedModalType] = useState(null);
  const [queuedModalProcessTick, setQueuedModalProcessTick] = useState(0);
  const markDailySummaryOpen = useCallback(() => {
    setDailySummaryOpenToken((prev) => prev + 1);
  }, []);
  const [focusTemplateId, setFocusTemplateId] = useState(null);
  const [focusStateHydrated, setFocusStateHydrated] = useState(false);
  const [focusDigestSeenKey, setFocusDigestSeenKey] = useState(null);
  const [focusDigestHydrated, setFocusDigestHydrated] = useState(false);
  const [pendingFocusDigest, setPendingFocusDigest] = useState(null);
  const [focusDigestPromptShown, setFocusDigestPromptShown] = useState(false);
  const [focusSaveCount, setFocusSaveCount] = useState(0);
  const appStateRef = useRef(AppState.currentState || "active");
  const suppressResumeOnceRef = useRef(false);
  const appResumeAtRef = useRef(null);
  const focusLossCountersRef = useRef({});
  const focusPromptActiveRef = useRef(false);
  const homeSessionRef = useRef({
    dateKey: getDayKey(Date.now()),
    sessionCount: 0,
    pendingIndex: null,
  });
  const isDailyChallengePromptPending =
    dailyChallengeUnlocked &&
    dailyChallenge.status === DAILY_CHALLENGE_STATUS.OFFER &&
    !dailyChallenge.offerDismissed;
  const [dailyChallengePromptGate, setDailyChallengePromptGate] = useState(false);
  const dailyChallengePromptQueuedRef = useRef(false);
  const dailyChallengePendingRef = useRef(false);
  const dailyChallengeOfferDeferredRef = useRef(false);
  const dailyChallengePendingPrevRef = useRef(false);
  const dailyNudgeIdsRef = useRef({});
  const smartRemindersRef = useRef([]);
  const smartReminderScheduleTailRef = useRef(0);
  const requestQueuedModalProcess = useCallback(() => {
    setQueuedModalProcessTick((prev) => prev + 1);
  }, []);
  const enqueueQueuedModal = useCallback(
    (type) => {
      if (!type) return;
      if (queuedModalActiveRef.current === type) return;
      const queue = queuedModalQueueRef.current;
      if (queue.includes(type)) return;
      queue.push(type);
      requestQueuedModalProcess();
    },
    [requestQueuedModalProcess]
  );
  const refreshQueuedModalsOnResume = useCallback(() => {
    if (dailySummaryUnlocked && pendingDailySummaryData) {
      enqueueQueuedModal(QUEUED_MODAL_TYPES.DAILY_SUMMARY);
    }
    if (dailyChallengePromptAllowed && isDailyChallengePromptPending) {
      dailyChallengeOfferDeferredRef.current = false;
      setDailyChallengePromptGate(true);
      enqueueQueuedModal(QUEUED_MODAL_TYPES.DAILY_CHALLENGE);
    }
    if (focusModeUnlocked && pendingFocusDigest && !focusDigestPromptShown) {
      enqueueQueuedModal(QUEUED_MODAL_TYPES.FOCUS_DIGEST);
    }
    if (
      fabTutorialState === FAB_TUTORIAL_STATUS.SHOWING &&
      onboardingStep === "done" &&
      tutorialSeen &&
      homeLayoutReady &&
      !startupLogoVisible &&
      !fabTutorialBlocked &&
      activeTab === "feed"
    ) {
      enqueueQueuedModal(QUEUED_MODAL_TYPES.FAB_TUTORIAL);
    }
    requestQueuedModalProcess();
  }, [
    activeTab,
    dailyChallengePromptAllowed,
    dailySummaryUnlocked,
    enqueueQueuedModal,
    fabTutorialBlocked,
    fabTutorialState,
    focusDigestPromptShown,
    focusModeUnlocked,
    homeLayoutReady,
    isDailyChallengePromptPending,
    onboardingStep,
    pendingDailySummaryData,
    pendingFocusDigest,
    requestQueuedModalProcess,
    startupLogoVisible,
    tutorialSeen,
  ]);
  const clearQueuedModal = useCallback(
    (type) => {
      if (queuedModalActiveRef.current !== type) return;
      queuedModalActiveRef.current = null;
      setQueuedModalType(null);
      requestQueuedModalProcess();
    },
    [requestQueuedModalProcess]
  );
  const handleDailySummaryContinue = useCallback(() => {
    setDailySummaryVisible(false);
    clearQueuedModal(QUEUED_MODAL_TYPES.DAILY_SUMMARY);
    const todayKey = dailySummaryData?.todayKey || getDayKey(Date.now());
    if (!todayKey) return;
    setDailySummarySeenKey(todayKey);
    AsyncStorage.setItem(STORAGE_KEYS.DAILY_SUMMARY, todayKey).catch(() => {});
  }, [clearQueuedModal, dailySummaryData]);
  const [tutorialSeen, setTutorialSeen] = useState(false);
  const [tutorialHydrated, setTutorialHydrated] = useState(false);
  const [tutorialVisible, setTutorialVisible] = useState(false);
  const [tutorialStepIndex, setTutorialStepIndex] = useState(0);
  const [temptationTutorialSeen, setTemptationTutorialSeen] = useState(false);
  const [temptationTutorialVisible, setTemptationTutorialVisible] = useState(false);
  const [temptationTutorialStepIndex, setTemptationTutorialStepIndex] = useState(0);
  const [temptationTutorialHydrated, setTemptationTutorialHydrated] = useState(false);
  const [temptationTutorialStatus, setTemptationTutorialStatus] = useState("pending");
  const [temptationTutorialQueued, setTemptationTutorialQueued] = useState(false);
  const [temptationTutorialCompleted, setTemptationTutorialCompleted] = useState(false);
  const tutorialVisiblePrevRef = useRef(false);
  const availableTabs = useMemo(() => {
    if (!tutorialVisible) return tabOrder;
    return tabOrder.filter((tab) => {
      if (tab === "pending" && !thinkingUnlocked) return false;
      if (tab === "purchases" && !rewardsUnlocked) return false;
      return true;
    });
  }, [rewardsUnlocked, tabOrder, thinkingUnlocked, tutorialVisible]);
  useEffect(() => {
    if (availableTabs.includes(activeTab)) return;
    if (availableTabs.length) {
      setActiveTabState(availableTabs[0]);
    }
  }, [activeTab, availableTabs]);
  const [tutorialHighlightRect, setTutorialHighlightRect] = useState(null);
  const [tutorialHighlightMeasureTick, setTutorialHighlightMeasureTick] = useState(0);
  const tutorialHighlightMeasureTimerRef = useRef(null);
  const tutorialHighlightAdjustCountRef = useRef(0);
  const tutorialHighlightAlignAttemptsRef = useRef(0);
  const [ratingPromptState, setRatingPromptState] = useState(() => createInitialRatingPromptState());
  const [ratingPromptHydrated, setRatingPromptHydrated] = useState(false);
  const [ratingPromptVisible, setRatingPromptVisible] = useState(false);
  const ratingPromptCompleted =
    ratingPromptState.completed || ratingPromptState.lastAction === "rate";
  const ratingPromptFirstOpenAt = ratingPromptState.firstOpenAt;
  const ratingPromptActionCount = ratingPromptState.actionCount || 0;
  const ratingPromptActionPrompted = ratingPromptState.actionPrompted;
  const ratingPromptLastAction = ratingPromptState.lastAction;
  const ratingPromptRespondedAt = ratingPromptState.respondedAt;
  const ratingPromptCatFloat = useRef(new Animated.Value(0)).current;
  const ratingPromptCatBob = ratingPromptCatFloat.interpolate({
    inputRange: [0, 1],
    outputRange: [0, -8],
  });
  useEffect(() => {
    if (!ratingPromptVisible) {
      ratingPromptCatFloat.setValue(0);
      return;
    }
    const loop = Animated.loop(
      Animated.sequence([
        Animated.timing(ratingPromptCatFloat, {
          toValue: 1,
          duration: 900,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(ratingPromptCatFloat, {
          toValue: 0,
          duration: 900,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    loop.start();
    return () => loop.stop();
  }, [ratingPromptCatFloat, ratingPromptVisible]);
  const [levelShareModal, setLevelShareModal] = useState({ visible: false, level: 1 });
  const [levelShareSharing, setLevelShareSharing] = useState(false);
  const levelShareCardRef = useRef(null);
  const [tabBarHeight, setTabBarHeight] = useState(0);
  const [fabTutorialState, setFabTutorialState] = useState(FAB_TUTORIAL_STATUS.DONE);
  const [fabTutorialVisible, setFabTutorialVisible] = useState(false);
  const fabTutorialStateRef = useRef(FAB_TUTORIAL_STATUS.DONE);
  const fabTutorialLoggedRef = useRef(false);
  const fabButtonWrapperRef = useRef(null);
  const [fabTutorialAnchor, setFabTutorialAnchor] = useState(null);
  const [fabTutorialEligible, setFabTutorialEligible] = useState(false);
  useEffect(() => {
    if (!appTutorialSteps.length) {
      setTutorialStepIndex(0);
      return;
    }
    if (tutorialStepIndex >= appTutorialSteps.length) {
      setTutorialStepIndex(appTutorialSteps.length - 1);
    }
  }, [appTutorialSteps.length, tutorialStepIndex]);
  const finishTutorial = useCallback(() => {
    setTutorialVisible(false);
    setTutorialSeen(true);
    setHomeLayoutReady(true);
    setTutorialStepIndex(0);
    setTemptationTutorialSeen(false);
    setTemptationTutorialStatus("pending");
    setTemptationTutorialStepIndex(0);
    setTemptationTutorialQueued(true);
    setTemptationTutorialCompleted(false);
    AsyncStorage.setItem(STORAGE_KEYS.TEMPTATION_TUTORIAL, "pending").catch(() => {});
    AsyncStorage.setItem(STORAGE_KEYS.TUTORIAL, "done").catch(() => {});
  }, [setHomeLayoutReady]);
  const handleTutorialNext = useCallback(() => {
    if (appTutorialSteps.length === 0) {
      finishTutorial();
      return;
    }
    if (tutorialStepIndex < appTutorialSteps.length - 1) {
      setTutorialStepIndex((prev) =>
        Math.min(prev + 1, Math.max(appTutorialSteps.length - 1, 0))
      );
      return;
    }
    finishTutorial();
  }, [appTutorialSteps.length, finishTutorial, tutorialStepIndex]);
  const handleTutorialSkip = useCallback(() => {
    finishTutorial();
  }, [finishTutorial]);
  const finishTemptationTutorial = useCallback(() => {
    setTemptationTutorialVisible(false);
    setTemptationTutorialSeen(true);
    setTemptationTutorialStatus("done");
    setTemptationTutorialStepIndex(0);
    setTemptationTutorialQueued(false);
    setTemptationTutorialCompleted(true);
    AsyncStorage.setItem(STORAGE_KEYS.TEMPTATION_TUTORIAL, "done").catch(() => {});
  }, []);
  const handleTemptationTutorialNext = useCallback(() => {
    if (temptationTutorialStepIndex < TEMPTATION_TUTORIAL_STEPS.length - 1) {
      setTemptationTutorialStepIndex((prev) =>
        Math.min(prev + 1, TEMPTATION_TUTORIAL_STEPS.length - 1)
      );
      return;
    }
    finishTemptationTutorial();
  }, [temptationTutorialStepIndex, finishTemptationTutorial]);
  const handleTemptationTutorialSkip = useCallback(() => {
    finishTemptationTutorial();
  }, [finishTemptationTutorial]);
  useEffect(() => {
    if (!tutorialSeen) return;
    AsyncStorage.setItem(STORAGE_KEYS.TUTORIAL, "done").catch(() => {});
  }, [tutorialSeen]);
  useEffect(() => {
    const wasVisible = tutorialVisiblePrevRef.current;
    if (
      wasVisible &&
      !tutorialVisible &&
      tutorialSeen &&
      temptationTutorialHydrated &&
      temptationTutorialStatus === "pending"
    ) {
      setTemptationTutorialQueued(true);
    }
    tutorialVisiblePrevRef.current = tutorialVisible;
  }, [
    temptationTutorialHydrated,
    temptationTutorialStatus,
    tutorialSeen,
    tutorialVisible,
  ]);
  const handleTutorialHighlightLayoutChange = useCallback((rect) => {
    setTutorialHighlightRect(rect);
  }, []);
  const scheduleTutorialHighlightMeasure = useCallback((delay = 0) => {
    if (tutorialHighlightMeasureTimerRef.current) {
      clearTimeout(tutorialHighlightMeasureTimerRef.current);
    }
    tutorialHighlightMeasureTimerRef.current = setTimeout(() => {
      setTutorialHighlightMeasureTick((prev) => prev + 1);
    }, Math.max(0, delay));
  }, []);
  useEffect(() => {
    return () => {
      if (tutorialHighlightMeasureTimerRef.current) {
        clearTimeout(tutorialHighlightMeasureTimerRef.current);
      }
    };
  }, []);
  const tutorialScrollExtraRef = useRef(0);
  const updateFabAnchor = useCallback(() => {
    const node = fabButtonWrapperRef.current;
    if (!node || typeof node.measureInWindow !== "function") return;
    node.measureInWindow((x, y, width, height) => {
      const centerX = x + width / 2;
      const androidStatusBarOffset = Platform.OS === "android" ? RNStatusBar.currentHeight || 0 : 0;
      const centerY = y + height / 2 + androidStatusBarOffset;
      setFabTutorialAnchor((prev) => {
        if (prev && Math.abs(prev.x - centerX) < 0.5 && Math.abs(prev.y - centerY) < 0.5) {
          return prev;
        }
        return { x: centerX, y: centerY };
      });
    });
  }, []);
  const handleFabWrapperLayout = useCallback(() => {
    updateFabAnchor();
  }, [updateFabAnchor]);
  const handleTabBarLayout = useCallback((event) => {
    const height = event?.nativeEvent?.layout?.height;
    if (!height || height <= 0) return;
    setTabBarHeight((prev) => (Math.abs(prev - height) < 1 ? prev : height));
  }, []);
  const handleHomeLayout = useCallback(() => {
    setHomeLayoutReady((ready) => (ready ? ready : true));
  }, []);
  const setFabTutorialStateAndPersist = useCallback((nextState) => {
    fabTutorialStateRef.current = nextState;
    setFabTutorialState(nextState);
    AsyncStorage.setItem(STORAGE_KEYS.FAB_TUTORIAL, nextState).catch(() => {});
  }, []);
  const handleFabTutorialDismiss = useCallback(
    (source = "dismiss") => {
      if (fabTutorialStateRef.current !== FAB_TUTORIAL_STATUS.SHOWING) {
        setFabTutorialVisible(false);
        return;
      }
      setFabTutorialVisible(false);
      clearQueuedModal(QUEUED_MODAL_TYPES.FAB_TUTORIAL);
      setFabTutorialStateAndPersist(FAB_TUTORIAL_STATUS.DONE);
      logEvent("fab_tutorial_completed", { source });
    },
    [clearQueuedModal, logEvent, setFabTutorialStateAndPersist]
  );
  const updateRatingPromptState = useCallback((updater) => {
    setRatingPromptState((prev) => {
      const nextState = typeof updater === "function" ? updater(prev) : updater;
      AsyncStorage.setItem(STORAGE_KEYS.RATING_PROMPT, JSON.stringify(nextState)).catch(() => {});
      return nextState;
    });
  }, []);
  const ratingPromptQueuedRef = useRef(false);
  const ratingPromptSourceRef = useRef(null);
  const ratingPromptCheckTimerRef = useRef(null);
  const storeReviewQueuedRef = useRef(false);
  const storeReviewCheckTimerRef = useRef(null);
  const canShowRatingPromptNowRef = useRef(() => false);
  const canTriggerStoreReviewNowRef = useRef(() => false);
  const showRatingPrompt = useCallback(
    (source = "time") => {
      if (ratingPromptVisible) return;
      setRatingPromptVisible(true);
      updateRatingPromptState((prev) => ({
        ...prev,
        lastShownAt: new Date().toISOString(),
        actionPrompted: source === "actions" ? true : prev.actionPrompted,
      }));
    },
    [ratingPromptVisible, updateRatingPromptState]
  );
  const queueRatingPrompt = useCallback(
    (source = "time") => {
      if (ratingPromptQueuedRef.current) {
        if (!ratingPromptSourceRef.current || source === "actions") {
          ratingPromptSourceRef.current = source;
        }
        return;
      }
      ratingPromptQueuedRef.current = true;
      ratingPromptSourceRef.current = source;
      const checkAndShow = () => {
        if (!ratingPromptQueuedRef.current) return;
        if (canShowRatingPromptNowRef.current()) {
          ratingPromptQueuedRef.current = false;
          const resolvedSource = ratingPromptSourceRef.current || source;
          ratingPromptSourceRef.current = null;
          showRatingPrompt(resolvedSource);
          return;
        }
        ratingPromptCheckTimerRef.current = setTimeout(checkAndShow, 250);
      };
      checkAndShow();
    },
    [showRatingPrompt]
  );
  useEffect(() => {
    return () => {
      if (ratingPromptCheckTimerRef.current) {
        clearTimeout(ratingPromptCheckTimerRef.current);
        ratingPromptCheckTimerRef.current = null;
      }
      if (storeReviewCheckTimerRef.current) {
        clearTimeout(storeReviewCheckTimerRef.current);
        storeReviewCheckTimerRef.current = null;
      }
    };
  }, []);
  const triggerStoreReview = useCallback(async (source = "rating_prompt") => {
    const isAndroid = Platform.OS === "android";
    const primaryUrl = isAndroid ? ANDROID_REVIEW_URL : IOS_REVIEW_URL;
    const fallbackUrl = isAndroid ? ANDROID_REVIEW_WEB_URL : IOS_REVIEW_WEB_URL;
    const openStoreReview = async () => {
      if (!primaryUrl && !fallbackUrl) return;
      try {
        if (primaryUrl) {
          const canOpen = await Linking.canOpenURL(primaryUrl);
          if (canOpen) {
            logEvent("store_review_redirect", {
              source,
              platform: isAndroid ? "android" : "ios",
              method: "native",
            });
            if (source === "rating_prompt" || source === "rating_prompt_modal") {
              logEvent("rating_prompt_store_redirect", {
                platform: isAndroid ? "android" : "ios",
                method: "native",
              });
            }
            await Linking.openURL(primaryUrl);
            return;
          }
        }
      } catch (error) {
        console.warn(`${isAndroid ? "android" : "ios"} review intent`, error);
      }
      if (fallbackUrl) {
        logEvent("store_review_redirect", {
          source,
          platform: isAndroid ? "android" : "ios",
          method: "web",
        });
        if (source === "rating_prompt" || source === "rating_prompt_modal") {
          logEvent("rating_prompt_store_redirect", {
            platform: isAndroid ? "android" : "ios",
            method: "web",
          });
        }
        Linking.openURL(fallbackUrl).catch(() => {});
      }
    };
    try {
      if (StoreReview && typeof StoreReview.isAvailableAsync === "function") {
        const available = await StoreReview.isAvailableAsync();
        if (available && typeof StoreReview.requestReview === "function") {
          // Play review can silently no-op; fallback to the store link if it returns too quickly.
          const startedAt = Date.now();
          logEvent("store_review_prompt_requested", {
            source,
            platform: isAndroid ? "android" : "ios",
          });
          await StoreReview.requestReview();
          const elapsedMs = Date.now() - startedAt;
          if (!isAndroid || elapsedMs > 1200) {
            return;
          }
        }
      }
    } catch (error) {
      console.warn("store review prompt", error);
    }
    return openStoreReview();
  }, [logEvent]);
  const requestStoreReviewWhenReady = useCallback(
    (source = "rating_prompt") => {
      if (storeReviewQueuedRef.current) return;
      storeReviewQueuedRef.current = true;
      const checkAndRun = () => {
        if (!storeReviewQueuedRef.current) return;
        if (canTriggerStoreReviewNowRef.current()) {
          storeReviewQueuedRef.current = false;
          InteractionManager.runAfterInteractions(() => {
            triggerStoreReview(source);
          });
          return;
        }
        storeReviewCheckTimerRef.current = setTimeout(checkAndRun, 250);
      };
      checkAndRun();
    },
    [triggerStoreReview]
  );
  const handleRatingPromptLater = useCallback(() => {
    setRatingPromptVisible(false);
    const respondedAt = new Date().toISOString();
    updateRatingPromptState((prev) => ({
      ...prev,
      completed: prev.completed,
      lastAction: "later",
      respondedAt,
    }));
    logEvent("rating_prompt_action", { action: "later" });
  }, [logEvent, updateRatingPromptState]);
  const handleRatingPromptConfirm = useCallback(() => {
    setRatingPromptVisible(false);
    const respondedAt = new Date().toISOString();
    updateRatingPromptState((prev) => ({
      ...prev,
      completed: true,
      lastAction: "rate",
      respondedAt,
    }));
    logEvent("rating_prompt_action", { action: "rate" });
    requestStoreReviewWhenReady("rating_prompt_modal");
  }, [logEvent, requestStoreReviewWhenReady, updateRatingPromptState]);
  const openLevelShareModal = useCallback(
    (level = 1) => {
      setLevelShareModal({ visible: true, level });
      logEvent("level_share_opened", { level });
    },
    [logEvent]
  );
  const closeLevelShareModal = useCallback(() => {
    setLevelShareModal((prev) => ({ ...prev, visible: false }));
  }, []);
  const handleLevelSharePress = useCallback(
    (level) => {
      dismissOverlay();
      openLevelShareModal(level);
    },
    [dismissOverlay, openLevelShareModal]
  );
  const handleLevelShareConfirm = useCallback(async () => {
    if (!levelShareCardRef.current || levelShareSharing) return;
    let cleanupUri = null;
    try {
      setLevelShareSharing(true);
      await new Promise((resolve) => requestAnimationFrame(resolve));
      let sharingAvailable = false;
      if (Sharing && typeof Sharing.isAvailableAsync === "function" && typeof Sharing.shareAsync === "function") {
        try {
          sharingAvailable = await Sharing.isAvailableAsync();
        } catch (availabilityError) {
          console.warn("sharing availability", availabilityError);
          sharingAvailable = false;
        }
      }
      const captureOptions = sharingAvailable
        ? { format: "png", quality: 0.96, result: "tmpfile" }
        : { format: "png", quality: 0.96, result: "base64" };
      const captureResult = await captureViewShotRef(levelShareCardRef, captureOptions);
      if (!captureResult) {
        throw new Error("capture_failed");
      }
      let normalizedUri = captureResult;
      if (captureOptions.result === "base64") {
        const baseDir = FileSystem.cacheDirectory || FileSystem.documentDirectory || "";
        const targetUri = `${baseDir}almost-level-share-${Date.now()}.png`;
        await FileSystem.writeAsStringAsync(targetUri, captureResult, {
          encoding: FileSystem.EncodingType.Base64,
        });
        normalizedUri = targetUri.startsWith("file://") ? targetUri : `file://${targetUri}`;
      } else if (!normalizedUri.startsWith("file://")) {
        normalizedUri = `file://${normalizedUri}`;
      }
      cleanupUri = normalizedUri;
      const shareTitle = `${t("levelShareModalTitle")} Â· ${t("levelShareFooterBrand")}`;
      const message = t("levelShareShareMessage", { level: levelShareModal.level });
      let sharedSuccessfully = false;
      if (sharingAvailable) {
        try {
          await Sharing.shareAsync(normalizedUri, {
            dialogTitle: shareTitle,
            mimeType: "image/png",
            UTI: "public.png",
          });
          sharedSuccessfully = true;
        } catch (sharingError) {
          console.warn("expo sharing failed", sharingError);
        }
      }
      if (!sharedSuccessfully) {
        if (Platform.OS === "ios" && ActionSheetIOS && typeof ActionSheetIOS.showShareActionSheetWithOptions === "function") {
          await new Promise((resolve, reject) => {
            ActionSheetIOS.showShareActionSheetWithOptions(
              {
                url: normalizedUri,
                subject: shareTitle,
              },
              (error) => {
                if (error) {
                  reject(error);
                } else {
                  resolve();
                }
              },
              () => resolve()
            );
          });
        } else {
          let fallbackUri = normalizedUri;
          if (Platform.OS === "android" && typeof FileSystem.getContentUriAsync === "function") {
            fallbackUri = await FileSystem.getContentUriAsync(normalizedUri);
          }
          await Share.share({
            url: fallbackUri,
            message,
            subject: Platform.OS === "ios" ? shareTitle : undefined,
          });
        }
      }
      logEvent("level_share_sent", { level: levelShareModal.level });
      closeLevelShareModal();
    } catch (error) {
      console.warn("level share", error);
      Alert.alert(t("levelShareModalTitle"), t("levelShareError") || "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹ Ð¿Ð¾Ð·Ð¶Ðµ.");
    } finally {
      if (cleanupUri) {
        setTimeout(() => {
          FileSystem.deleteAsync(cleanupUri, { idempotent: true }).catch(() => {});
        }, 3500);
      }
      setLevelShareSharing(false);
    }
  }, [closeLevelShareModal, levelShareModal.level, levelShareSharing, logEvent, t]);
  const clearCompletedPrimaryGoal = useCallback(
    (goalId) => {
      if (!goalId) return;
      setWishes((prev) =>
        prev.filter(
          (w) => !(w.kind === PRIMARY_GOAL_KIND && (w.goalId || w.id) === goalId && w.status === "done")
        )
      );
    },
    [setWishes]
  );
  const ensureActiveGoalForNewWish = useCallback(
    (newWish) => {
      if (!newWish) return;
      const shouldActivate =
        !mainGoalWish ||
        !profile.goal ||
        mainGoalWish.status === "done" ||
        profile.goalCelebrated;
      if (!shouldActivate) return;
      const targetUSD =
        Number.isFinite(newWish.targetUSD) && newWish.targetUSD > 0
          ? newWish.targetUSD
          : getGoalDefaultTargetUSD(newWish.goalId || newWish.id);
      const previousGoalId = activeGoalId || profile.goal;
      clearCompletedPrimaryGoal(previousGoalId);
      setActiveGoalId(newWish.id);
      const newPrimaryEntry = {
        id: newWish.id,
        targetUSD,
        savedUSD: Math.max(0, Number(newWish.savedUSD) || 0),
        status: newWish.status || "active",
        createdAt: newWish.createdAt || Date.now(),
        customTitle: getWishTitleWithoutEmoji(newWish) || newWish.title || "",
        customEmoji: normalizeEmojiValue(newWish.emoji, DEFAULT_GOAL_EMOJI),
      };
      const mergePrimaryGoals = (prevGoals = []) => {
        const dedup = new Map();
        const list = Array.isArray(prevGoals) ? prevGoals : [];
        list.forEach((entry) => {
          if (!entry?.id) return;
          if (dedup.has(entry.id)) return;
          dedup.set(entry.id, { ...entry });
        });
        dedup.set(newPrimaryEntry.id, {
          ...newPrimaryEntry,
          ...(dedup.get(newPrimaryEntry.id) || {}),
        });
        return Array.from(dedup.values());
      };
      setProfile((prev) => ({
        ...prev,
        primaryGoals: mergePrimaryGoals(prev.primaryGoals),
        goal: newWish.id,
        goalTargetUSD: targetUSD,
        goalCelebrated: false,
        goalRenewalPending: false,
      }));
      setProfileDraft((prev) => ({
        ...prev,
        primaryGoals: mergePrimaryGoals(prev.primaryGoals),
        goal: newWish.id,
        goalTargetUSD: targetUSD,
        goalCelebrated: false,
        goalRenewalPending: false,
      }));
      ensurePrimaryGoalWish(mergePrimaryGoals(profile.primaryGoals), language, newWish.id);
      dismissGoalRenewalPrompt();
    },
    [
      activeGoalId,
      clearCompletedPrimaryGoal,
      dismissGoalRenewalPrompt,
      mainGoalWish?.status,
      profile.goal,
      profile.goalCelebrated,
      profile.primaryGoals,
      ensurePrimaryGoalWish,
      language,
    ]
  );
  const ensureGoalManualTracking = useCallback((wishId) => {
    if (!wishId) return;
    setWishes((prev) => {
      let changed = false;
      const next = prev.map((wish) => {
        if (wish.id === wishId && wish.autoManaged !== false) {
          changed = true;
          return { ...wish, autoManaged: false };
        }
        return wish;
      });
      return changed ? next : prev;
    });
  }, []);
  const [mascotOverride, setMascotOverride] = useState(null);
  const mascotQueueRef = useRef([]);
  const mascotBusyRef = useRef(false);
  const [tamagotchiState, setTamagotchiState] = useState({ ...TAMAGOTCHI_START_STATE });
  const [tamagotchiVisible, setTamagotchiVisible] = useState(false);
  const [tamagotchiSkinId, setTamagotchiSkinId] = useState(DEFAULT_TAMAGOTCHI_SKIN);
  const [tamagotchiSkinHydrated, setTamagotchiSkinHydrated] = useState(false);
  const [tamagotchiSkinsUnlocked, setTamagotchiSkinsUnlocked] = useState(false);
  const [tamagotchiSkinsUnlockHydrated, setTamagotchiSkinsUnlockHydrated] = useState(false);
  const [skinPickerVisible, setSkinPickerVisible] = useState(false);
  const tamagotchiSkin =
    TAMAGOTCHI_SKINS[tamagotchiSkinId] || TAMAGOTCHI_SKINS[DEFAULT_TAMAGOTCHI_SKIN];
  const tamagotchiAnimations = tamagotchiSkin.animations;
  const tamagotchiAvatarSource = tamagotchiSkin.avatar;
  const tamagotchiSkinsLocked = !tamagotchiSkinsUnlocked;
  const tamagotchiHydratedRef = useRef(false);
  const tamagotchiHungerPrevRef = useRef(
    Math.min(TAMAGOTCHI_MAX_HUNGER, Math.max(0, TAMAGOTCHI_START_STATE.hunger))
  );
  const tamagotchiHungerNotificationIdsRef = useRef([]);
  const tamagotchiHungerDailyCountRef = useRef({
    dayKey: getDayKey(Date.now()),
    count: 0,
  });
  const tamagotchiHungerLastAtRef = useRef(0);
  const tamagotchiModalAnim = useRef(new Animated.Value(0)).current;
  const partyGlow = useRef(new Animated.Value(0)).current;
  const [partyActive, setPartyActive] = useState(false);
  const [partyBurstKey, setPartyBurstKey] = useState(0);
  const partyGlowAnimRef = useRef(null);
  const processTamagotchiDecay = useCallback(
    (timestamp = Date.now()) => {
      setTamagotchiState((prev) => {
        const { state: nextState } = computeTamagotchiDecay(prev, timestamp);
        return nextState;
      });
    },
    [setTamagotchiState]
  );
  const saveActionLogRef = useRef([]);
  const lastSaveActionAtRef = useRef(0);
  const cartBadgeScale = useRef(new Animated.Value(1)).current;
  useEffect(() => {
    const pulse = Animated.loop(
      Animated.sequence([
        Animated.delay(4200),
        Animated.timing(cartBadgeScale, {
          toValue: 1.08,
          duration: 400,
          easing: Easing.out(Easing.ease),
          useNativeDriver: true,
        }),
        Animated.timing(cartBadgeScale, {
          toValue: 1,
          duration: 420,
          easing: Easing.out(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    pulse.start();
    return () => pulse.stop();
  }, [cartBadgeScale]);
  const openSkinPicker = useCallback(() => {
    if (!catCustomizationUnlocked) return;
    triggerHaptic();
    setTamagotchiVisible(false);
    setSkinPickerVisible(true);
  }, [catCustomizationUnlocked]);
  const closeSkinPicker = useCallback(() => setSkinPickerVisible(false), []);
  const handleSkinSelect = useCallback(
    (skinId) => {
      if (!skinId || !TAMAGOTCHI_SKINS[skinId]) return;
      if (!tamagotchiSkinsUnlocked && skinId !== DEFAULT_TAMAGOTCHI_SKIN) {
        triggerHaptic();
        return;
      }
      setTamagotchiSkinId(skinId);
      setSkinPickerVisible(false);
      logEvent("tamagotchi_skin_selected", { skin_id: skinId });
    },
    [logEvent, tamagotchiSkinsUnlocked]
  );
  const handleUnlockSkinsPress = useCallback(() => {
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    const subject = t("tamagotchiSkinFeedbackSubject");
    const body = t("tamagotchiSkinFeedbackBody");
    const mailLink = `mailto:${SUPPORT_EMAIL}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(
      body
    )}`;
    Linking.openURL(mailLink).catch((error) => console.warn("tamagotchi skin unlock mail", error));
    setTamagotchiSkinsUnlocked(true);
    logEvent("tamagotchi_skin_unlock_feedback", { method: "support_mail" });
  }, [logEvent, t]);
  const [onboardingStep, setOnboardingStep] = useState("logo");
  const onboardingStepRef = useRef("logo");
  const onboardingHistoryRef = useRef([]);
  const [canGoBackOnboarding, setCanGoBackOnboarding] = useState(false);
  const [onboardingSkipLocked, setOnboardingSkipLocked] = useState(false);
  const onboardingSkippedRef = useRef(false);
  const [registrationData, setRegistrationData] = useState(INITIAL_REGISTRATION);
  const goalTargetFocusRef = useRef(null);
  const [termsModalVisible, setTermsModalVisible] = useState(false);
  const [termsAccepted, setTermsAccepted] = useState(false);
  const [termsContinuePending, setTermsContinuePending] = useState(false);
  const [showImageSourceSheet, setShowImageSourceSheet] = useState(false);
  const [showCustomSpend, setShowCustomSpend] = useState(false);
  const [quickSpendDraft, setQuickSpendDraft] = useState({
    title: "",
    amount: "",
    emoji: DEFAULT_TEMPTATION_EMOJI,
    category: DEFAULT_IMPULSE_CATEGORY,
  });
  useEffect(() => {
    onboardingStepRef.current = onboardingStep;
  }, [onboardingStep]);
  useEffect(() => {
    if (onboardingStep === "done") {
      if (!onboardingCompletedRef.current) {
        onboardingCompletedRef.current = true;
        goToTab("feed", { recordHistory: false, resetHistory: true });
      }
    } else {
      onboardingCompletedRef.current = false;
    }
  }, [goToTab, onboardingStep]);
  useEffect(() => {
    if (onboardingStep === "done") {
      setOnboardingSkipLocked(false);
    }
  }, [onboardingStep]);
  useEffect(() => {
    if (fontsLoaded) {
      ensureGlobalInterTypography();
    }
  }, [fontsLoaded]);
  useEffect(() => {
    if (fontsError) {
      console.warn("Inter font load error", fontsError);
    }
  }, [fontsError]);
  useEffect(() => {
    if (!coinSliderHydrated) return;
    AsyncStorage.setItem(STORAGE_KEYS.COIN_SLIDER_MAX, String(coinSliderMaxUSD)).catch(() => {});
  }, [coinSliderHydrated, coinSliderMaxUSD]);
  useEffect(() => {
    beginHomeSession();
  }, [beginHomeSession]);
  useEffect(() => {
    tryLogHomeOpened();
  }, [tryLogHomeOpened]);
  useEffect(() => {
    if (!fabTutorialVisible) return;
    const timer = setTimeout(updateFabAnchor, 100);
    return () => clearTimeout(timer);
  }, [fabTutorialVisible, updateFabAnchor]);
  const fabTutorialBlocked = Boolean(overlay || dailySummaryVisible || priceEditor.item);
  const fabTutorialReady =
    fabTutorialState === FAB_TUTORIAL_STATUS.SHOWING &&
    onboardingStep === "done" &&
    tutorialSeen &&
    !tutorialOverlayVisible &&
    homeLayoutReady &&
    !startupLogoVisible &&
    !fabTutorialBlocked;
  useEffect(() => {
    if (!fabTutorialReady) return;
    enqueueQueuedModal(QUEUED_MODAL_TYPES.FAB_TUTORIAL);
  }, [enqueueQueuedModal, fabTutorialReady]);
  useEffect(() => {
    if (queuedModalType !== QUEUED_MODAL_TYPES.FAB_TUTORIAL || !fabTutorialReady) {
      fabTutorialLoggedRef.current = false;
      if (fabTutorialVisible) {
        setFabTutorialVisible(false);
      }
      return;
    }
    const shouldShow = activeTab === "feed";
    if (fabTutorialVisible !== shouldShow) {
      setFabTutorialVisible(shouldShow);
    }
    if (shouldShow && !fabTutorialLoggedRef.current) {
      logEvent("fab_tutorial_shown");
      fabTutorialLoggedRef.current = true;
    }
  }, [
    activeTab,
    fabTutorialVisible,
    fabTutorialReady,
    logEvent,
    queuedModalType,
  ]);
  useEffect(() => {
    const handleAppStateChange = (nextState) => {
      const previousState = appStateRef.current;
      const wasBackground = previousState === "background";
      appStateRef.current = nextState;
      if (nextState !== "active") {
        Keyboard.dismiss();
        setKeyboardInset(0);
        setKeyboardVisible(false);
        appResumeAtRef.current = Date.now();
        setFabTutorialVisible(false);
        storePotentialSnapshot(getPotentialSavedNow());
        return;
      }
      if (wasBackground && nextState === "active") {
        soundModeReadyRef.current = false;
        const resumedAt = appResumeAtRef.current || 0;
        appResumeAtRef.current = null;
        const suppressResumeOnce = suppressResumeOnceRef.current;
        if (suppressResumeOnce) {
          suppressResumeOnceRef.current = false;
        }
        const isTransientResume =
          suppressResumeOnce ||
          (resumedAt && Date.now() - resumedAt < APP_RESUME_MODAL_GUARD_MS);
        if (!isTransientResume) {
          if (dailyChallengePromptQueuedRef.current && dailyChallengePendingRef.current) {
            setDailyChallengePromptGate(true);
            dailyChallengeOfferDeferredRef.current = false;
          }
          setCurrentDayKey(getDayKey(Date.now()));
          processTamagotchiDecay();
          beginHomeSession();
          tryLogHomeOpened();
          if (activeTab === "feed") {
            triggerHomeSpeech("resume");
          }
          markDailySummaryOpen();
          maybeShowPotentialGrowth(getPotentialSavedNow());
          if (pendingFocusDigest) {
            setFocusDigestPromptShown(false);
          }
          refreshQueuedModalsOnResume();
          if (!overlayActiveRef.current && !overlay && overlayQueueRef.current.length) {
            processOverlayQueue();
          }
        }
      }
    };
    const subscription = AppState.addEventListener("change", handleAppStateChange);
    return () => subscription.remove();
  }, [
    activeTab,
    beginHomeSession,
    getPotentialSavedNow,
    maybeShowPotentialGrowth,
    overlay,
    processOverlayQueue,
    refreshQueuedModalsOnResume,
    storePotentialSnapshot,
    setDailyChallengePromptGate,
    markDailySummaryOpen,
    pendingFocusDigest,
    processTamagotchiDecay,
    setCurrentDayKey,
    triggerHomeSpeech,
    tryLogHomeOpened,
    setFabTutorialVisible,
    setKeyboardInset,
    setKeyboardVisible,
  ]);
  useEffect(() => {
    markDailySummaryOpen();
  }, [markDailySummaryOpen]);
  useEffect(() => {
    if (!ratingPromptHydrated) return;
    if (ratingPromptCompleted) return;
    if (ratingPromptVisible) return;
    if (onboardingStep !== "done") return;
    const firstOpenDate = new Date(ratingPromptFirstOpenAt || "");
    if (Number.isNaN(firstOpenDate.getTime())) return;
    const day3AtMs = firstOpenDate.getTime() + RATING_PROMPT_DELAY_DAYS * DAY_MS;
    if (ratingPromptLastAction === "later" && ratingPromptRespondedAt) {
      const respondedAtDate = new Date(ratingPromptRespondedAt);
      if (!Number.isNaN(respondedAtDate.getTime()) && respondedAtDate.getTime() >= day3AtMs) {
        return;
      }
    }
    const daysElapsed = Math.floor((Date.now() - firstOpenDate.getTime()) / DAY_MS);
    if (daysElapsed < RATING_PROMPT_DELAY_DAYS) return;
    queueRatingPrompt("time");
  }, [
    onboardingStep,
    ratingPromptHydrated,
    ratingPromptCompleted,
    ratingPromptFirstOpenAt,
    ratingPromptLastAction,
    ratingPromptRespondedAt,
    ratingPromptVisible,
    queueRatingPrompt,
  ]);
  const ratingPromptActionEligible =
    ratingPromptHydrated &&
    !ratingPromptCompleted &&
    !ratingPromptVisible &&
    !ratingPromptActionPrompted &&
    ratingPromptActionCount >= RATING_PROMPT_ACTION_THRESHOLD;
  useEffect(() => {
    if (!ratingPromptActionEligible) return;
    queueRatingPrompt("actions");
  }, [queueRatingPrompt, ratingPromptActionEligible]);
  useEffect(() => {
    if (!ratingPromptVisible) return;
    if (!ratingPromptQueuedRef.current) return;
    ratingPromptQueuedRef.current = false;
    ratingPromptSourceRef.current = null;
    if (ratingPromptCheckTimerRef.current) {
      clearTimeout(ratingPromptCheckTimerRef.current);
      ratingPromptCheckTimerRef.current = null;
    }
  }, [ratingPromptVisible]);
  useEffect(() => {
    if (!ratingPromptVisible) return;
    logEvent("rating_prompt_shown");
  }, [logEvent, ratingPromptVisible]);
  useEffect(() => {
    if (!focusStateHydrated) return;
    if (!focusTemplateId) {
      AsyncStorage.removeItem(STORAGE_KEYS.FOCUS_TARGET).catch(() => {});
      return;
    }
    AsyncStorage.setItem(
      STORAGE_KEYS.FOCUS_TARGET,
      JSON.stringify({ templateId: focusTemplateId, saveCount: focusSaveCount, updatedAt: Date.now() })
    ).catch(() => {});
  }, [focusSaveCount, focusStateHydrated, focusTemplateId]);
  useEffect(() => {
    if (!focusDigestHydrated) return;
    if (!focusDigestSeenKey) {
      AsyncStorage.removeItem(STORAGE_KEYS.FOCUS_DIGEST).catch(() => {});
      return;
    }
    AsyncStorage.setItem(STORAGE_KEYS.FOCUS_DIGEST, focusDigestSeenKey).catch(() => {});
  }, [focusDigestSeenKey, focusDigestHydrated]);
  useEffect(() => {
    if (!focusDigestHydrated) return;
    if (!pendingFocusDigest) {
      AsyncStorage.removeItem(STORAGE_KEYS.FOCUS_DIGEST_PENDING).catch(() => {});
      return;
    }
    AsyncStorage.setItem(STORAGE_KEYS.FOCUS_DIGEST_PENDING, JSON.stringify(pendingFocusDigest)).catch(() => {});
  }, [pendingFocusDigest, focusDigestHydrated]);
  const openTamagotchiOverlay = useCallback(() => {
    setTamagotchiVisible((prev) => {
      if (!prev) {
        logEvent("tamagotchi_pressed");
        logEvent("tamagotchi_opened");
      }
      return true;
    });
  }, [logEvent]);
  const closeTamagotchiOverlay = useCallback(() => setTamagotchiVisible(false), []);
  const [fabMenuVisible, setFabMenuVisible] = useState(false);
  const fabMenuAnim = useRef(new Animated.Value(0)).current;
  const tamagotchiMood = useMemo(
    () => getTamagotchiMood(tamagotchiState.hunger, language),
    [tamagotchiState.hunger, language]
  );
  const beginHomeSession = useCallback(() => {
    const todayKey = getDayKey(Date.now());
    if (homeSessionRef.current.dateKey !== todayKey) {
      homeSessionRef.current.dateKey = todayKey;
      homeSessionRef.current.sessionCount = 0;
    }
    homeSessionRef.current.sessionCount += 1;
    const sessionCount = homeSessionRef.current.sessionCount;
    setFabTutorialEligible((prev) => {
      if (prev) return prev;
      return sessionCount >= FAB_TUTORIAL_MIN_SESSIONS;
    });
    homeSessionRef.current.pendingIndex = homeSessionRef.current.sessionCount;
  }, []);
  const tryLogHomeOpened = useCallback(() => {
    if (activeTab !== "feed") return;
    const pendingIndex = homeSessionRef.current.pendingIndex;
    if (!pendingIndex) return;
    logEvent("home_opened", { session_index: pendingIndex });
    homeSessionRef.current.pendingIndex = null;
  }, [activeTab, logEvent]);
  const isFabTutorialEnvironmentReady = useMemo(
    () =>
      onboardingStep === "done" &&
      tutorialSeen &&
      homeLayoutReady &&
      !tutorialOverlayVisible &&
      !startupLogoVisible,
    [homeLayoutReady, onboardingStep, startupLogoVisible, tutorialOverlayVisible, tutorialSeen]
  );
  useEffect(() => {
    if (
      fabTutorialState === FAB_TUTORIAL_STATUS.PENDING &&
      fabTutorialEligible &&
      isFabTutorialEnvironmentReady
    ) {
      setFabTutorialStateAndPersist(FAB_TUTORIAL_STATUS.SHOWING);
    }
  }, [
    fabTutorialEligible,
    fabTutorialState,
    isFabTutorialEnvironmentReady,
    setFabTutorialStateAndPersist,
  ]);
  const tamagotchiHungerPercent = useMemo(
    () => Math.min(TAMAGOTCHI_MAX_HUNGER, Math.max(0, tamagotchiState.hunger)),
    [tamagotchiState.hunger]
  );
  const tamagotchiIsFull = tamagotchiHungerPercent >= TAMAGOTCHI_MAX_HUNGER;
  const tamagotchiCoins = healthPoints;
  const tamagotchiDesiredFood =
    TAMAGOTCHI_FOOD_MAP[tamagotchiState.desiredFoodId] ||
    TAMAGOTCHI_FOOD_MAP[TAMAGOTCHI_DEFAULT_FOOD_ID];
  const [newPendingModal, setNewPendingModal] = useState({
    visible: false,
    title: "",
    amount: "",
    emoji: DEFAULT_TEMPTATION_EMOJI,
  });
  const [newGoalModal, setNewGoalModal] = useState({
    visible: false,
    name: "",
    target: "",
    emoji: DEFAULT_GOAL_EMOJI,
    makePrimary: false,
    source: "unknown",
  });
  const activeGoalCount = useMemo(() => {
    if (!Array.isArray(wishes)) return 0;
    return wishes.filter((wish) => wish && wish.status !== "done").length;
  }, [wishes]);
  const openNewPendingModal = useCallback(
    () =>
      setNewPendingModal({
        visible: true,
        title: "",
        amount: "",
        emoji: DEFAULT_TEMPTATION_EMOJI,
      }),
    []
  );
  const openNewGoalModal = useCallback(
    (makePrimary = false, source = "unknown") => {
      if (activeGoalCount >= MAX_ACTIVE_GOALS) {
        Alert.alert(
          t("goalLimitReachedTitle", { limit: MAX_ACTIVE_GOALS }),
          t("goalLimitReachedMessage", { limit: MAX_ACTIVE_GOALS })
        );
        return;
      }
      setNewGoalModal({
        visible: true,
        name: "",
        target: "",
        emoji: DEFAULT_GOAL_EMOJI,
        makePrimary,
        source,
      });
      logEvent("goal_creator_opened", {
        source,
        make_primary: makePrimary ? 1 : 0,
      });
    },
    [activeGoalCount, logEvent, t]
  );
  const handleNewPendingChange = useCallback((field, value) => {
    setNewPendingModal((prev) => ({
      ...prev,
      [field]: field === "emoji" ? limitEmojiInput(value) : value,
    }));
  }, []);
  const handleNewPendingCancel = useCallback(() => {
    setNewPendingModal({ visible: false, title: "", amount: "", emoji: DEFAULT_TEMPTATION_EMOJI });
  }, []);
  const [onboardingGoalModal, setOnboardingGoalModal] = useState({
    visible: false,
    name: "",
    target: "",
    emoji: DEFAULT_GOAL_EMOJI,
  });
  const goalSelectionTouchedRef = useRef(false);
  const openFabMenu = useCallback(() => {
    if (fabMenuVisible) return;
    setFabMenuVisible(true);
    Animated.spring(fabMenuAnim, {
      toValue: 1,
      friction: 7,
      tension: 120,
      useNativeDriver: true,
    }).start();
  }, [fabMenuAnim, fabMenuVisible]);
  const closeFabMenu = useCallback(() => {
    Animated.timing(fabMenuAnim, {
      toValue: 0,
      duration: 160,
      easing: Easing.out(Easing.quad),
      useNativeDriver: true,
    }).start(() => setFabMenuVisible(false));
  }, [fabMenuAnim]);
  const handleFabPress = useCallback(() => {
    Keyboard.dismiss();
    handleFabTutorialDismiss("tap");
    triggerHaptic();
    if (fabMenuVisible) {
      closeFabMenu();
    }
    if (activeTab === "cart") {
      openNewGoalModal(false, "fab_cart");
    } else if (activeTab === "pending") {
      openNewPendingModal();
    } else {
      openCoinEntry(activeTab || "unknown");
    }
  }, [
    activeTab,
    closeFabMenu,
    fabMenuVisible,
    handleFabTutorialDismiss,
    openCoinEntry,
    openNewGoalModal,
    openNewPendingModal,
    triggerHaptic,
  ]);
  const handleFabLongPress = useCallback(() => {
    Keyboard.dismiss();
    handleFabTutorialDismiss("hold");
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    if (fabMenuVisible) {
      closeFabMenu();
    } else {
      openFabMenu();
    }
  }, [closeFabMenu, fabMenuVisible, handleFabTutorialDismiss, openFabMenu, triggerHaptic]);
  useEffect(() => {
    if (activeTab === "profile" && fabMenuVisible) {
      closeFabMenu();
    }
  }, [activeTab, closeFabMenu, fabMenuVisible]);
  const imagePickerResolver = useRef(null);
  const [refuseStats, setRefuseStats] = useState({});
  const [refuseStatsHydrated, setRefuseStatsHydrated] = useState(false);
  const resolveCardRefuseStats = useCallback(
    (card) => {
      if (!card) return null;
      const directKey = typeof card.id === "string" ? card.id : null;
      if (directKey && refuseStats[directKey]) {
        return refuseStats[directKey];
      }
      const templateKey =
        typeof card.templateId === "string" && card.templateId.trim().length
          ? card.templateId.trim()
          : null;
      if (templateKey && refuseStats[templateKey]) {
        return refuseStats[templateKey];
      }
      if (isCustomTemptation(card)) {
        const isQuickCustom =
          Boolean(
            card.quickTemptation ||
              card.quickCreate ||
              card.origin === "quick_custom" ||
              card.source === "quick_custom"
          ) ||
          (typeof card.id === "string" && card.id.startsWith("custom_habit_"));
        if (!isQuickCustom) {
          const fallbackKeys = [];
          if (profile.customSpend?.id) {
            fallbackKeys.push(profile.customSpend.id);
          }
          fallbackKeys.push("custom_habit", "undefined");
          for (let index = 0; index < fallbackKeys.length; index += 1) {
            const key = fallbackKeys[index];
            if (key && refuseStats[key]) {
              return refuseStats[key];
            }
          }
        }
      }
      return null;
    },
    [profile.customSpend?.id, refuseStats]
  );
  const [temptationInteractions, setTemptationInteractions] = useState({});
  const [temptationInteractionsHydrated, setTemptationInteractionsHydrated] = useState(false);
  const [impulseTracker, setImpulseTracker] = useState({ ...INITIAL_IMPULSE_TRACKER });
  const [impulseTrackerHydrated, setImpulseTrackerHydrated] = useState(false);
  const [moodState, setMoodState] = useState(() => createMoodStateForToday());
  const [cardFeedback, setCardFeedback] = useState({});
  const [moodHydrated, setMoodHydrated] = useState(false);
  const lastVisitAtSnapshotRef = useRef(null);
  const editOverlayAnim = useRef(new Animated.Value(0)).current;
  const [editOverlayVisible, setEditOverlayVisible] = useState(false);
  const cardFeedbackTimers = useRef({});
  const pendingStreakRecoveryRef = useRef({});
  const streakRecoveryOverrideRef = useRef({});
  const impulseAlertCooldownRef = useRef({});
  const lastInstantNotificationRef = useRef(0);
  const resolveNotificationTriggerTime = useCallback((trigger, nowTs = Date.now()) => {
    if (!trigger) return nowTs;
    if (trigger instanceof Date) return trigger.getTime();
    if (typeof trigger === "number") return trigger;
    if (typeof trigger === "string") {
      const parsed = Date.parse(trigger);
      if (!Number.isNaN(parsed)) return parsed;
    }
    if (typeof trigger === "object") {
      if (typeof trigger.seconds === "number") {
        return nowTs + trigger.seconds * 1000;
      }
      if (typeof trigger.value === "number") return trigger.value;
      if (typeof trigger.value === "string") {
        const parsedValue = Date.parse(trigger.value);
        if (!Number.isNaN(parsedValue)) return parsedValue;
      }
      const calendarSource = trigger.dateComponents || trigger;
      const nowDate = new Date(nowTs);
      if (
        typeof calendarSource.hour === "number" &&
        typeof calendarSource.minute === "number"
      ) {
        const next = new Date(nowDate);
        next.setHours(calendarSource.hour, calendarSource.minute, calendarSource.second || 0, 0);
        if (next.getTime() <= nowTs) {
          next.setDate(next.getDate() + 1);
        }
        return next.getTime();
      }
      if (
        typeof calendarSource.year === "number" ||
        typeof calendarSource.month === "number" ||
        typeof calendarSource.day === "number"
      ) {
        const computed = new Date(
          typeof calendarSource.year === "number" ? calendarSource.year : nowDate.getFullYear(),
          typeof calendarSource.month === "number" ? Math.max(0, calendarSource.month - 1) : nowDate.getMonth(),
          typeof calendarSource.day === "number" ? calendarSource.day : nowDate.getDate(),
          typeof calendarSource.hour === "number" ? calendarSource.hour : 0,
          typeof calendarSource.minute === "number" ? calendarSource.minute : 0,
          typeof calendarSource.second === "number" ? calendarSource.second : 0,
          0
        );
        const ts = computed.getTime();
        return Number.isFinite(ts) ? ts : null;
      }
    }
    return null;
  }, []);
  const readScheduledNotificationTimes = useCallback(async () => {
    try {
      const scheduled = await Notifications.getAllScheduledNotificationsAsync();
      const nowTs = Date.now();
      return (Array.isArray(scheduled) ? scheduled : [])
        .map((entry) => resolveNotificationTriggerTime(entry?.trigger, nowTs))
        .filter((value) => Number.isFinite(value) && value >= nowTs)
        .sort((a, b) => a - b);
    } catch (error) {
      console.warn("scheduled notifications read", error);
      return [];
    }
  }, [resolveNotificationTriggerTime]);
  const findScheduledNotificationByDedupeKey = useCallback(
    async (dedupeKey) => {
      if (!dedupeKey) return null;
      try {
        const scheduled = await Notifications.getAllScheduledNotificationsAsync();
        const entries = Array.isArray(scheduled) ? scheduled : [];
        for (let idx = 0; idx < entries.length; idx += 1) {
          const entry = entries[idx];
          const entryKey = entry?.content?.data?.dedupeKey;
          if (entryKey && entryKey === dedupeKey) {
            return entry;
          }
        }
      } catch (error) {
        console.warn("scheduled notifications read", error);
      }
      return null;
    },
    []
  );
  const getScheduledTamagotchiHungerCounts = useCallback(async () => {
    try {
      const scheduled = await Notifications.getAllScheduledNotificationsAsync();
      const nowTs = Date.now();
      return (Array.isArray(scheduled) ? scheduled : []).reduce((acc, entry) => {
        if (entry?.content?.data?.kind !== "tamagotchi_hunger") return acc;
        const triggerTs = resolveNotificationTriggerTime(entry?.trigger, nowTs);
        if (!Number.isFinite(triggerTs)) return acc;
        const dayKey = getDayKey(triggerTs);
        if (!dayKey) return acc;
        acc[dayKey] = (acc[dayKey] || 0) + 1;
        return acc;
      }, {});
    } catch (error) {
      console.warn("scheduled tamagotchi hunger count", error);
      return {};
    }
  }, [resolveNotificationTriggerTime]);
  const isNotificationOnCooldown = useCallback(
    async (targetTime = Date.now()) => {
      const lastSent = Number(lastInstantNotificationRef.current) || 0;
      if (lastSent > 0 && targetTime - lastSent < PUSH_NOTIFICATION_COOLDOWN_MS) {
        return true;
      }
      const scheduledTimes = await readScheduledNotificationTimes();
      return scheduledTimes.some(
        (scheduledAt) => Math.abs(scheduledAt - targetTime) < PUSH_NOTIFICATION_COOLDOWN_MS
      );
    },
    [readScheduledNotificationTimes]
  );
  const scheduleNotificationWithCooldown = useCallback(
    async (request) => {
      if (!request?.content) return null;
      const dedupeKey = request?.content?.data?.dedupeKey || null;
      if (dedupeKey) {
        const existing = await findScheduledNotificationByDedupeKey(dedupeKey);
        if (existing) {
          const scheduledFor = resolveNotificationTriggerTime(existing?.trigger);
          return {
            id: existing?.identifier || existing?.id || null,
            scheduledFor: Number.isFinite(scheduledFor) ? scheduledFor : null,
          };
        }
      }
      const triggerInput = request.trigger;
      const repeats = triggerInput && typeof triggerInput === "object" && triggerInput.repeats;
      let finalTrigger = triggerInput ?? null;
      let scheduledFor = resolveNotificationTriggerTime(triggerInput);
      const requestedTime = scheduledFor;
      if (!repeats && Number.isFinite(requestedTime)) {
        const scheduledTimes = await readScheduledNotificationTimes();
        const lastSent = Number(lastInstantNotificationRef.current) || 0;
        let adjustedTime = Math.max(requestedTime, Date.now());
        if (lastSent > 0 && adjustedTime - lastSent < PUSH_NOTIFICATION_COOLDOWN_MS) {
          adjustedTime = lastSent + PUSH_NOTIFICATION_COOLDOWN_MS;
        }
        for (let idx = 0; idx < scheduledTimes.length; idx += 1) {
          const scheduledAt = scheduledTimes[idx];
          if (Math.abs(adjustedTime - scheduledAt) < PUSH_NOTIFICATION_COOLDOWN_MS) {
            adjustedTime = scheduledAt + PUSH_NOTIFICATION_COOLDOWN_MS;
          }
        }
        if (adjustedTime !== requestedTime) {
          finalTrigger = new Date(adjustedTime);
        }
        scheduledFor = adjustedTime;
      }
      const id = await Notifications.scheduleNotificationAsync({
        ...request,
        trigger: finalTrigger,
      });
      const resolvedTrigger = resolveNotificationTriggerTime(finalTrigger);
      const finalScheduledFor = Number.isFinite(resolvedTrigger) ? resolvedTrigger : scheduledFor;
      return { id, scheduledFor: finalScheduledFor };
    },
    [findScheduledNotificationByDedupeKey, readScheduledNotificationTimes, resolveNotificationTriggerTime]
  );
  const [notificationPermissionGranted, setNotificationPermissionGranted] = useState(null);
  const [pushOptInHydrated, setPushOptInHydrated] = useState(false);
  const pushOptInLoggedRef = useRef(false);
  const [pushDayThreePromptVisible, setPushDayThreePromptVisible] = useState(false);
  const [pushDayThreePromptHydrated, setPushDayThreePromptHydrated] = useState(false);
  const pushDayThreePromptShownRef = useRef(false);
  const [spendLoggingReminderHydrated, setSpendLoggingReminderHydrated] = useState(false);
  const lastSpendLoggingReminderRef = useRef(0);
  const handledNotificationResponseIdsRef = useRef(new Set());
  const notificationActionHandlerRef = useRef(null);
  const notificationDedupeRef = useRef(new Map());
  const pendingListRef = useRef([]);
  const [spendPrompt, setSpendPrompt] = useState({ visible: false, item: null });
  const [categoryPrompt, setCategoryPrompt] = useState({ visible: false, item: null, action: null, options: null });
  const [categoryPromptSelection, setCategoryPromptSelection] = useState(DEFAULT_IMPULSE_CATEGORY);
  const [addCategoryModalVisible, setAddCategoryModalVisible] = useState(false);
  const [addCategoryName, setAddCategoryName] = useState("");
  const [addCategoryEmoji, setAddCategoryEmoji] = useState("âœ¨");
  const [addCategoryError, setAddCategoryError] = useState(false);
  const [coinValueModalStatus, setCoinValueModalStatus] = useState("none");
  const [coinValueModalHydrated, setCoinValueModalHydrated] = useState(false);
  const [coinValueModalVisible, setCoinValueModalVisible] = useState(false);
  const coinValueModalStatusRef = useRef("none");
  const coinBalancePrevRef = useRef(0);
  const tutorialSeenPrevRef = useRef(false);
  const coinValueModalCheckTimerRef = useRef(null);
  const resetCounterRef = useRef(0);
  const spendPromptLockRef = useRef(false);
  const spendExecutionLockRef = useRef(false);
  const [stormActive, setStormActive] = useState(false);
  const safeAreaInsets = useSafeAreaInsets();
  const iosTabInset = Platform.OS === "ios" ? Math.max((safeAreaInsets.bottom || 0) - 8, 0) : 0;
  const androidNavInset = Platform.OS === "android" ? Math.max(safeAreaInsets.bottom || 0, 0) : 0;
  const tabBarBottomInset = Platform.OS === "ios" ? iosTabInset : androidNavInset;
  const resolvedTabBarHeight = tabBarHeight || tabBarBottomInset + TAB_BAR_BASE_HEIGHT;
  const tutorialOverlayInset = resolvedTabBarHeight;
  const tutorialCardOffset = resolvedTabBarHeight + (Platform.OS === "ios" ? 64 : 72);
  const topSafeInset =
    Platform.OS === "android" ? RNStatusBar.currentHeight || 24 : safeAreaInsets.top || 0;
  const [keyboardInset, setKeyboardInset] = useState(0);
  const [keyboardVisible, setKeyboardVisible] = useState(false);

  useEffect(() => {
    const showEvent = Platform.OS === "ios" ? "keyboardWillShow" : "keyboardDidShow";
    const hideEvent = Platform.OS === "ios" ? "keyboardWillHide" : "keyboardDidHide";
    const handleKeyboardShow = (event = {}) => {
      const keyboardHeight = event.endCoordinates?.height || 0;
      const safeGap = Math.max(0, keyboardHeight - tabBarBottomInset);
      const buffer = Platform.OS === "ios" ? 12 : 0;
      setKeyboardInset(safeGap ? safeGap + buffer : buffer);
      setKeyboardVisible(true);
    };
    const handleKeyboardHide = () => {
      setKeyboardInset(0);
      setKeyboardVisible(false);
    };
    const showSub = Keyboard.addListener(showEvent, handleKeyboardShow);
    const hideSub = Keyboard.addListener(hideEvent, handleKeyboardHide);
    return () => {
      showSub.remove();
      hideSub.remove();
    };
  }, [tabBarBottomInset]);
  const shouldRenderStatusGlass = topSafeInset > 0;
  const statusBlurAvailable = useMemo(() => {
    if (!shouldRenderStatusGlass) return false;
    return isBlurViewAvailable();
  }, [shouldRenderStatusGlass]);
  const screenKeyboardAdjustmentStyle = useMemo(() => {
    if (Platform.OS === "ios") return null;
    return keyboardInset ? { paddingBottom: keyboardInset } : null;
  }, [keyboardInset]);

  const keyboardModalOffset = useMemo(() => {
    if (!keyboardInset) return 0;
    const effectiveInset =
      Platform.OS === "ios" ? keyboardInset * 0.6 : keyboardInset;
    return Math.min(effectiveInset, MAX_MODAL_KEYBOARD_OFFSET);
  }, [keyboardInset]);

  const modalKeyboardPaddingStyle = useMemo(
    () => (keyboardModalOffset ? { paddingBottom: keyboardModalOffset } : null),
    [keyboardModalOffset]
  );

  const fabTutorialCutout = useMemo(() => {
    const radius = FAB_TUTORIAL_HALO_SIZE / 2;
    const fallbackCenterX = SCREEN_WIDTH / 2;
    const androidStatusBarOffset = Platform.OS === "android" ? RNStatusBar.currentHeight || 0 : 0;
    const fallbackCenterY =
      SCREEN_HEIGHT - (tabBarBottomInset + FAB_CONTAINER_BOTTOM + FAB_BUTTON_SIZE / 2) + androidStatusBarOffset;
    const centerX = fabTutorialAnchor?.x ?? fallbackCenterX;
    const centerY = fabTutorialAnchor?.y ?? fallbackCenterY;
    const top = Math.max(0, centerY - radius);
    const bottom = Math.min(SCREEN_HEIGHT, centerY + radius);
    const left = Math.max(0, centerX - radius);
    const right = Math.min(SCREEN_WIDTH, centerX + radius);
    return {
      top,
      bottom,
      left,
      right,
      height: Math.max(0, bottom - top),
      width: Math.max(0, right - left),
      centerX,
      centerY,
    };
  }, [fabTutorialAnchor, tabBarBottomInset]);
  const [analyticsOptOut, setAnalyticsOptOutState] = useState(null);
  const facebookInitRef = useRef(false);
  const analyticsConsentGateRef = useRef(false);
  const profileSelectionRef = useRef({ gender: null, persona: null });
  useEffect(() => {
    if (analyticsOptOut === null) return;
    bootstrapMonitoring();
  }, [analyticsOptOut]);
  useEffect(() => {
    if (facebookInitRef.current) return;
    if (__DEV__) return;
    if (analyticsOptOut !== false) return;
    if (!FacebookSettings || typeof FacebookSettings.initializeSDK !== "function") return;
    facebookInitRef.current = true;
    try {
      if (typeof FacebookSettings.setAppID === "function") {
        FacebookSettings.setAppID(FACEBOOK_APP_ID);
      }
      FacebookSettings.initializeSDK();
      if (typeof FacebookSettings.setAdvertiserTrackingEnabled === "function") {
        const trackingPromise = FacebookSettings.setAdvertiserTrackingEnabled(true);
        if (trackingPromise?.catch) {
          trackingPromise.catch(() => {});
        }
      }
    } catch (error) {
      console.warn("facebook sdk init", error);
    }
  }, [analyticsOptOut]);
  const [startupLogoVisible, setStartupLogoVisible] = useState(false);
  const startupLogoDismissedRef = useRef(false);
  const markStartupLogoDismissed = useCallback(() => {
    startupLogoDismissedRef.current = true;
    setStartupLogoVisible(false);
  }, []);
  const interfaceReady = useMemo(
    () =>
      onboardingStep === "done" &&
      startupHydrated &&
      fontsReady &&
      homeLayoutReady &&
      !startupLogoVisible,
    [fontsReady, homeLayoutReady, onboardingStep, startupHydrated, startupLogoVisible]
  );
  const speechAllowed = useMemo(
    () =>
      interfaceReady &&
      activeTab === "feed" &&
      !overlay &&
      !dailySummaryVisible &&
      !tutorialOverlayVisible &&
      !tamagotchiVisible &&
      !skinPickerVisible &&
      !coinEntryVisible &&
      !savingsBreakdownVisible &&
      !spendBreakdownVisible &&
      !editOverlayVisible &&
      !priceEditor.item &&
      !newPendingModal.visible &&
      !newGoalModal.visible &&
      !ratingPromptVisible &&
      !termsModalVisible &&
      !fabMenuVisible &&
      !coinValueModalVisible &&
      !dailyRewardModalVisible &&
      !goalRenewalPromptVisible &&
      !moodDetailsVisible &&
      !potentialDetailsVisible &&
      !addCategoryModalVisible &&
      !pushDayThreePromptVisible &&
      !potentialGrowthVisible &&
      !tutorialVisible &&
      !temptationTutorialVisible &&
      !fabTutorialVisible &&
      !queuedModalType &&
      !levelShareModal.visible &&
      !startupLogoVisible &&
      !keyboardVisible,
    [
      activeTab,
      addCategoryModalVisible,
      coinEntryVisible,
      coinValueModalVisible,
      dailyRewardModalVisible,
      dailySummaryVisible,
      editOverlayVisible,
      fabMenuVisible,
      fabTutorialVisible,
      goalRenewalPromptVisible,
      interfaceReady,
      keyboardVisible,
      levelShareModal.visible,
      moodDetailsVisible,
      newGoalModal.visible,
      newPendingModal.visible,
      overlay,
      potentialDetailsVisible,
      potentialGrowthVisible,
      priceEditor.item,
      pushDayThreePromptVisible,
      queuedModalType,
      ratingPromptVisible,
      savingsBreakdownVisible,
      spendBreakdownVisible,
      skinPickerVisible,
      startupLogoVisible,
      tamagotchiVisible,
      temptationTutorialVisible,
      termsModalVisible,
      tutorialOverlayVisible,
      tutorialVisible,
    ]
  );
  const pendingHomeSpeechRef = useRef(null);
  const queueHomeSpeech = useCallback(
    (reason = "unknown") => {
      if (!reason) return;
      if (speechAllowed) {
        triggerHomeSpeech(reason);
        return;
      }
      const current = pendingHomeSpeechRef.current;
      if (!current) {
        pendingHomeSpeechRef.current = reason;
        return;
      }
      const currentPriority = TAMAGOTCHI_SPEECH_REASON_PRIORITY[current] || 0;
      const nextPriority = TAMAGOTCHI_SPEECH_REASON_PRIORITY[reason] || 0;
      if (nextPriority >= currentPriority) {
        pendingHomeSpeechRef.current = reason;
      }
    },
    [speechAllowed, triggerHomeSpeech]
  );
  useEffect(() => {
    if (!speechAllowed) return;
    if (!pendingHomeSpeechRef.current) return;
    const reason = pendingHomeSpeechRef.current;
    pendingHomeSpeechRef.current = null;
    triggerHomeSpeech(reason);
  }, [speechAllowed, triggerHomeSpeech]);
  useEffect(() => {
    if (activeTab !== "feed") return;
    if (homeSpeechBootedRef.current) return;
    homeSpeechBootedRef.current = true;
    triggerHomeSpeech("ready");
  }, [activeTab, triggerHomeSpeech]);
  useEffect(() => {
    if (!speechAllowed) return;
    if (homeSpeechReadyRef.current) return;
    if (homeSpeechTrigger.tick > 0) return;
    const timer = setTimeout(() => {
      if (!speechAllowed) return;
      if (homeSpeechReadyRef.current) return;
      if (homeSpeechTrigger.tick > 0) return;
      homeSpeechReadyRef.current = true;
      triggerHomeSpeech("ready");
    }, 200);
    return () => clearTimeout(timer);
  }, [homeSpeechTrigger.tick, speechAllowed, triggerHomeSpeech]);
  useEffect(() => {
    coinValueModalStatusRef.current = coinValueModalStatus;
  }, [coinValueModalStatus]);
  const canQueueCoinValueModal = useCallback(() => {
    if (!coinValueModalHydrated) return false;
    if (!tutorialSeen) return false;
    if (coinValueModalStatusRef.current !== "none") return false;
    const currentCoins = Math.max(0, Number(tamagotchiState?.coins) || 0);
    if (currentCoins <= 0) return false;
    const lastSaveAt = Number(lastSaveActionAtRef.current) || 0;
    const lastSaveDismissedAt = Number(lastSaveOverlayDismissedAtRef.current) || 0;
    if (!lastSaveAt || lastSaveDismissedAt < lastSaveAt) return false;
    return true;
  }, [coinValueModalHydrated, tamagotchiState?.coins, tutorialSeen]);
  useEffect(() => {
    if (tutorialSeen && !tutorialSeenPrevRef.current) {
      coinBalancePrevRef.current = 0;
    }
    tutorialSeenPrevRef.current = tutorialSeen;
  }, [tutorialSeen]);
  useEffect(() => {
    const currentCoins = Math.max(0, Number(tamagotchiState?.coins) || 0);
    const previousCoins = Math.max(0, Number(coinBalancePrevRef.current) || 0);
    coinBalancePrevRef.current = currentCoins;
    if (!coinValueModalHydrated) return;
    if (!tutorialSeen) return;
    if (previousCoins <= 0 && currentCoins > 0 && canQueueCoinValueModal()) {
      queueCoinValueModal();
    }
  }, [canQueueCoinValueModal, coinValueModalHydrated, queueCoinValueModal, tamagotchiState?.coins, tutorialSeen]);
  useEffect(() => {
    if (!canQueueCoinValueModal()) return;
    queueCoinValueModal();
  }, [canQueueCoinValueModal, queueCoinValueModal, overlay]);
  const overlayEnvironmentReady = interfaceReady && !dailySummaryVisible && !tutorialOverlayVisible;
  const ensureOverlayEnvironmentReady = useCallback(() => {
    if (
      onboardingStep === "done" &&
      !homeLayoutReady &&
      !startupLogoVisible &&
      !dailySummaryVisible
    ) {
      setHomeLayoutReady(true);
    }
  }, [dailySummaryVisible, homeLayoutReady, onboardingStep, startupLogoVisible]);
  useEffect(() => {
    if (onboardingStep !== "done") return;
    if (!primaryTemptationPromptHydrated) return;
    if (primaryTemptationPromptState !== "pending") return;
    if (!profile?.customSpend) return;
    const hasPrimaryGoal = Array.isArray(profile.primaryGoals) && profile.primaryGoals.length > 0;
    const primaryGoalReady = !hasPrimaryGoal || !!mainGoalWish?.id;
    if (!primaryGoalReady) return;
    if (!primaryTemptationId) {
      markPrimaryTemptationPromptDone();
      return;
    }
    if (!tutorialSeen || tutorialVisible) return;
    if (tutorialOverlayVisible) return;
    if (temptationTutorialStatus !== "done") return;
    if (!temptationTutorialCompleted || temptationTutorialVisible) return;
    triggerOverlayState("primary_temptation", { templateId: primaryTemptationId });
    markPrimaryTemptationPromptDone();
  }, [
    markPrimaryTemptationPromptDone,
    onboardingStep,
    primaryTemptationId,
    primaryTemptationPromptHydrated,
    primaryTemptationPromptState,
    mainGoalWish?.id,
    profile?.customSpend,
    profile.primaryGoals,
    temptationTutorialCompleted,
    temptationTutorialStatus,
    temptationTutorialVisible,
    triggerOverlayState,
    tutorialSeen,
    tutorialVisible,
    tutorialOverlayVisible,
  ]);

  const goToOnboardingStep = useCallback(
    (nextStep, { recordHistory = true, resetHistory = false } = {}) => {
      if (resetHistory) {
        onboardingHistoryRef.current = [];
        setCanGoBackOnboarding(false);
      }
      setOnboardingStep((prev) => {
        if (recordHistory && prev && prev !== nextStep) {
          const nextHistory = [...onboardingHistoryRef.current, prev];
          onboardingHistoryRef.current = nextHistory;
          setCanGoBackOnboarding(nextHistory.length > 0);
        }
        return nextStep;
      });
    },
    []
  );

  const handleOnboardingBack = useCallback(() => {
    if (!onboardingHistoryRef.current.length) return;
    const history = [...onboardingHistoryRef.current];
    const prevStep = history.pop();
    onboardingHistoryRef.current = history;
    setCanGoBackOnboarding(history.length > 0);
    setOnboardingStep(prevStep);
  }, []);
  const canShowOnboardingSkip =
    !onboardingSkipLocked &&
    onboardingStep !== "done" &&
    onboardingStep !== "logo" &&
    onboardingStep !== "language" &&
    onboardingStep !== "analytics_consent";
  useEffect(() => {
    if (onboardingStep !== "goal") return;
    if (goalSelectionTouchedRef.current) return;
    setRegistrationData((prev) => {
      const hasSelections = Array.isArray(prev.goalSelections) && prev.goalSelections.length > 0;
      const hasTargets = prev.goalTargetMap && Object.keys(prev.goalTargetMap).length > 0;
      const hasConfirmed =
        Array.isArray(prev.goalTargetConfirmed) && prev.goalTargetConfirmed.length > 0;
      if (!hasSelections && !hasTargets && !hasConfirmed) {
        return prev;
      }
      return {
        ...prev,
        goalSelections: [],
        goalTargetMap: {},
        goalTargetConfirmed: [],
      };
    });
  }, [onboardingStep, setRegistrationData]);
  const stormTimerRef = useRef(null);
  const [rewardCelebratedMap, setRewardCelebratedMap] = useState({});
  const [rewardCelebratedHydrated, setRewardCelebratedHydrated] = useState(false);
  const persistRewardCelebrations = useCallback(
    (updater) => {
      setRewardCelebratedMap((prev) => {
        const source = prev && typeof prev === "object" ? prev : {};
        const next = typeof updater === "function" ? updater(source) : updater || {};
        if (rewardCelebratedHydrated) {
          AsyncStorage.setItem(
            STORAGE_KEYS.REWARDS_CELEBRATED,
            JSON.stringify(next)
          ).catch(() => {});
        }
        return next;
      });
    },
    [rewardCelebratedHydrated]
  );
  const [rewardsReady, setRewardsReady] = useState(false);
  const challengesPrevRef = useRef(challengesState);
  const [temptationGoalMap, setTemptationGoalMap] = useState({});
  const [temptationGoalMapHydrated, setTemptationGoalMapHydrated] = useState(false);
  const [goalLinkPrompt, setGoalLinkPrompt] = useState({
    visible: false,
    item: null,
    intent: null,
    streakRecoveryValue: null,
  });
  const [streakRecoveryPrompt, setStreakRecoveryPrompt] = useState({
    ...INITIAL_STREAK_RECOVERY_PROMPT,
  });
  const streakRestoreSoundPendingRef = useRef(false);
  const streakRestoreSoundTaskRef = useRef(null);
  const hideStreakRecoveryPrompt = useCallback(
    () => setStreakRecoveryPrompt({ ...INITIAL_STREAK_RECOVERY_PROMPT }),
    []
  );
  const [goalTemptationPrompt, setGoalTemptationPrompt] = useState({ visible: false, wish: null });
  const [goalEditorPrompt, setGoalEditorPrompt] = useState({
    visible: false,
    wish: null,
    name: "",
    target: "",
    emoji: DEFAULT_GOAL_EMOJI,
  });
  const [baselinePrompt, setBaselinePrompt] = useState({
    visible: false,
    value: "",
    currency: DEFAULT_PROFILE.currency,
  });
  const [goalRenewalPromptVisible, setGoalRenewalPromptVisible] = useState(false);
  const goalRenewalPromptPendingRef = useRef(false);
  const goalRenewalPromptAfterGoalRef = useRef(false);
  const dismissGoalRenewalPrompt = useCallback(() => {
    goalRenewalPromptPendingRef.current = false;
    setGoalRenewalPromptVisible(false);
  }, []);
  const requestGoalRenewalPrompt = useCallback(() => {
    if (goalRenewalPromptVisible) return;
    if (overlay) {
      goalRenewalPromptPendingRef.current = true;
      return;
    }
    goalRenewalPromptPendingRef.current = false;
    setGoalRenewalPromptVisible(true);
  }, [goalRenewalPromptVisible, overlay]);
  const dailyChallengePromptAllowed = useMemo(
    () =>
      interfaceReady &&
      activeTab === "feed" &&
      !dailySummaryVisible &&
      !tutorialOverlayVisible &&
      !overlay &&
      !tamagotchiVisible &&
      !newGoalModal.visible &&
      !onboardingGoalModal.visible &&
      !goalTemptationPrompt.visible &&
      !goalEditorPrompt.visible &&
      !baselinePrompt.visible &&
      !goalRenewalPromptVisible &&
      !goalLinkPrompt.visible &&
      !streakRecoveryPrompt.visible &&
      !skinPickerVisible &&
      !priceEditor.item &&
      !savingsBreakdownVisible &&
      !spendBreakdownVisible,
    [
      activeTab,
      baselinePrompt.visible,
      dailySummaryVisible,
      goalEditorPrompt.visible,
      goalLinkPrompt.visible,
      goalRenewalPromptVisible,
      goalTemptationPrompt.visible,
      interfaceReady,
      newGoalModal.visible,
      onboardingGoalModal.visible,
      overlay,
      priceEditor.item,
      savingsBreakdownVisible,
      spendBreakdownVisible,
      skinPickerVisible,
      streakRecoveryPrompt.visible,
      tamagotchiVisible,
      tutorialOverlayVisible,
    ]
  );
  const dailyChallengePromptVisible = queuedModalType === QUEUED_MODAL_TYPES.DAILY_CHALLENGE;
  const coinValueModalAllowed = useMemo(
    () =>
      interfaceReady &&
      onboardingStep === "done" &&
      tutorialSeen &&
      activeTab === "feed" &&
      !dailySummaryVisible &&
      !tutorialOverlayVisible &&
      !overlay &&
      !tamagotchiVisible &&
      !newGoalModal.visible &&
      !onboardingGoalModal.visible &&
      !goalTemptationPrompt.visible &&
      !goalEditorPrompt.visible &&
      !baselinePrompt.visible &&
      !goalRenewalPromptVisible &&
      !goalLinkPrompt.visible &&
      !streakRecoveryPrompt.visible &&
      !skinPickerVisible &&
      !priceEditor.item &&
      !savingsBreakdownVisible &&
      !spendBreakdownVisible &&
      !spendPrompt.visible &&
      !dailyChallengePromptVisible,
    [
      activeTab,
      baselinePrompt.visible,
      dailyChallengePromptVisible,
      dailySummaryVisible,
      goalEditorPrompt.visible,
      goalLinkPrompt.visible,
      goalRenewalPromptVisible,
      goalTemptationPrompt.visible,
      interfaceReady,
      newGoalModal.visible,
      onboardingGoalModal.visible,
      onboardingStep,
      overlay,
      priceEditor.item,
      savingsBreakdownVisible,
      spendBreakdownVisible,
      skinPickerVisible,
      spendPrompt.visible,
      streakRecoveryPrompt.visible,
      tamagotchiVisible,
      tutorialOverlayVisible,
      tutorialSeen,
    ]
  );
  const canShowCoinValueModalNow = useCallback(() => {
    if (!coinValueModalAllowed || coinValueModalVisible) return false;
    if (overlay || overlayActiveRef.current) return false;
    if (overlayQueueRef.current.length) return false;
    if (celebrationQueueRef.current.length) return false;
    if (celebrationGapTimerRef.current) return false;
    if (blockingModalVisible) return false;
    const lastSaveAt = Number(lastSaveActionAtRef.current) || 0;
    const lastSaveDismissedAt = Number(lastSaveOverlayDismissedAtRef.current) || 0;
    if (lastSaveAt > lastSaveDismissedAt && Date.now() - lastSaveAt < 15000) {
      return false;
    }
    const lastDismissedAt = lastOverlayDismissedAtRef.current || 0;
    if (Date.now() - lastDismissedAt < 600) return false;
    if (Date.now() - lastSaveDismissedAt < 900) return false;
    return true;
  }, [blockingModalVisible, coinValueModalAllowed, coinValueModalVisible, overlay]);
  useEffect(() => {
    if (!coinValueModalHydrated) return undefined;
    if (coinValueModalStatus !== COIN_VALUE_MODAL_STATUS.PENDING) {
      if (coinValueModalCheckTimerRef.current) {
        clearTimeout(coinValueModalCheckTimerRef.current);
        coinValueModalCheckTimerRef.current = null;
      }
      return undefined;
    }
    const checkAndShow = () => {
      if (canShowCoinValueModalNow()) {
        setCoinValueModalVisible(true);
        coinValueModalCheckTimerRef.current = null;
        return;
      }
      coinValueModalCheckTimerRef.current = setTimeout(checkAndShow, 250);
    };
    checkAndShow();
    return () => {
      if (coinValueModalCheckTimerRef.current) {
        clearTimeout(coinValueModalCheckTimerRef.current);
        coinValueModalCheckTimerRef.current = null;
      }
    };
  }, [canShowCoinValueModalNow, coinValueModalHydrated, coinValueModalStatus]);
  const dismissCoinValueModal = useCallback(() => {
    setCoinValueModalVisible(false);
    if (coinValueModalStatusRef.current === COIN_VALUE_MODAL_STATUS.SHOWN) return;
    coinValueModalStatusRef.current = COIN_VALUE_MODAL_STATUS.SHOWN;
    setCoinValueModalStatus(COIN_VALUE_MODAL_STATUS.SHOWN);
    AsyncStorage.setItem(
      STORAGE_KEYS.COIN_VALUE_MODAL,
      COIN_VALUE_MODAL_STATUS.SHOWN
    ).catch(() => {});
  }, []);
  useEffect(() => {
    if (!coinValueModalVisible) return undefined;
    if (activeTab !== "feed") return undefined;
    const task = InteractionManager.runAfterInteractions(() => {
      const scroller = feedScreenRef.current;
      if (scroller && typeof scroller.scrollToTop === "function") {
        scroller.scrollToTop({ animated: false });
      }
    });
    return () => task?.cancel?.();
  }, [activeTab, coinValueModalVisible]);
  const openBaselinePrompt = useCallback(() => {
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const existingUSD = Math.max(0, Number(profile.spendingProfile?.baselineMonthlyWasteUSD) || 0);
    const existingLocal =
      existingUSD > 0
        ? formatNumberInputValue(convertToCurrency(existingUSD, currencyCode))
        : "";
    setBaselinePrompt({
      visible: true,
      value: existingLocal,
      currency: currencyCode,
    });
  }, [profile.currency, profile.spendingProfile?.baselineMonthlyWasteUSD]);
  const closeBaselinePrompt = useCallback(() => {
    setBaselinePrompt((prev) => ({ ...prev, visible: false }));
  }, []);
  const handleBaselinePromptChange = useCallback((text) => {
    setBaselinePrompt((prev) => ({ ...prev, value: text }));
  }, []);
  const handleBaselinePromptSubmit = useCallback(() => {
    const trimmed = (baselinePrompt.value || "").trim();
    const parsed = parseNumberInputValue(trimmed);
    if (!Number.isFinite(parsed) || parsed <= 0) {
      Alert.alert("Almost", t("baselineInputError"));
      return;
    }
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const baselineMonthlyWasteUSD = convertFromCurrency(parsed, currencyCode);
    const timestamp = new Date().toISOString();
    const nextSpendingProfile = {
      ...(profile.spendingProfile || { ...DEFAULT_PROFILE.spendingProfile }),
      baselineMonthlyWasteUSD,
      baselineStartAt: timestamp,
    };
    const previousBaselineUSD = Math.max(
      0,
      Number(profile.spendingProfile?.baselineMonthlyWasteUSD) || 0
    );
    if (previousBaselineUSD !== baselineMonthlyWasteUSD) {
      logEvent("profile_baseline_updated", {
        previous_usd: previousBaselineUSD,
        baseline_usd: baselineMonthlyWasteUSD,
        currency: currencyCode,
      });
    }
    setProfile((prev) => ({
      ...prev,
      spendingProfile: nextSpendingProfile,
    }));
    setProfileDraft((prev) => ({
      ...prev,
      spendingProfile: nextSpendingProfile,
    }));
    setBaselinePrompt((prev) => ({ ...prev, visible: false }));
  }, [
    baselinePrompt.value,
    logEvent,
    profile.currency,
    profile.spendingProfile,
    setProfile,
    setProfileDraft,
    t,
    focusModeUnlocked,
  ]);
  const [moodDetailsVisible, setMoodDetailsVisible] = useState(false);
  const [potentialDetailsVisible, setPotentialDetailsVisible] = useState(false);
  const [potentialDetailsText, setPotentialDetailsText] = useState("");
  const tutorialBlockingVisible = useMemo(
    () =>
      blockingModalVisible ||
      overlay ||
      dailySummaryVisible ||
      ratingPromptVisible ||
      pushDayThreePromptVisible ||
      levelShareModal.visible ||
      coinEntryVisible ||
      showCustomSpend ||
      newPendingModal.visible ||
      showImageSourceSheet ||
      termsModalVisible ||
      spendPrompt.visible ||
      stormActive ||
      moodDetailsVisible ||
      potentialDetailsVisible ||
      fabMenuVisible ||
      editOverlayVisible,
    [
      blockingModalVisible,
      coinEntryVisible,
      dailySummaryVisible,
      editOverlayVisible,
      fabMenuVisible,
      levelShareModal.visible,
      moodDetailsVisible,
      newPendingModal.visible,
      overlay,
      potentialDetailsVisible,
      pushDayThreePromptVisible,
      ratingPromptVisible,
      showCustomSpend,
      showImageSourceSheet,
      spendPrompt.visible,
      stormActive,
      termsModalVisible,
    ]
  );
  useEffect(() => {
    if (!streakRestoreSoundPendingRef.current) return;
    if (tutorialBlockingVisible) return;
    streakRestoreSoundPendingRef.current = false;
    if (streakRestoreSoundTaskRef.current) {
      streakRestoreSoundTaskRef.current.cancel?.();
      streakRestoreSoundTaskRef.current = null;
    }
    streakRestoreSoundTaskRef.current = InteractionManager.runAfterInteractions(() => {
      playSound("streak_restore");
      streakRestoreSoundTaskRef.current = null;
    });
  }, [playSound, tutorialBlockingVisible]);
  useEffect(() => {
    return () => {
      if (streakRestoreSoundTaskRef.current) {
        streakRestoreSoundTaskRef.current.cancel?.();
        streakRestoreSoundTaskRef.current = null;
      }
    };
  }, []);
  const openMoodDetails = useCallback(() => setMoodDetailsVisible(true), []);
  const closeMoodDetails = useCallback(() => setMoodDetailsVisible(false), []);
  const openPotentialDetails = useCallback((description) => {
    setPotentialDetailsText(description);
    setPotentialDetailsVisible(true);
  }, []);
  const closePotentialDetails = useCallback(() => setPotentialDetailsVisible(false), []);
  const openSavingsBreakdown = useCallback(() => {
    setSpendBreakdownVisible(false);
    setSavingsBreakdownVisible(true);
  }, []);
  const closeSavingsBreakdown = useCallback(() => setSavingsBreakdownVisible(false), []);
  const openSpendBreakdown = useCallback(() => {
    setSavingsBreakdownVisible(false);
    setSpendBreakdownRange("week");
    setSpendBreakdownOffset(0);
    setSpendBreakdownVisible(true);
  }, []);
  const closeSpendBreakdown = useCallback(() => setSpendBreakdownVisible(false), []);
  const setSpendBreakdownRangeMode = useCallback((next) => {
    setSpendBreakdownRange(next);
    setSpendBreakdownOffset(0);
  }, []);
  const handleSpendBreakdownPrev = useCallback(() => {
    setSpendBreakdownOffset((prev) => prev + 1);
  }, []);
  const handleSpendBreakdownNext = useCallback(() => {
    setSpendBreakdownOffset((prev) => Math.max(0, prev - 1));
  }, []);
  const blockingModalVisible = useMemo(
    () =>
      savingsBreakdownVisible ||
      spendBreakdownVisible ||
      dailyChallengePromptVisible ||
      tamagotchiVisible ||
      levelShareModal.visible ||
      newGoalModal.visible ||
      onboardingGoalModal.visible ||
      goalTemptationPrompt.visible ||
      goalEditorPrompt.visible ||
      baselinePrompt.visible ||
      goalRenewalPromptVisible ||
      goalLinkPrompt.visible ||
      streakRecoveryPrompt.visible ||
      skinPickerVisible ||
      priceEditor.item,
    [
      baselinePrompt.visible,
      dailyChallengePromptVisible,
      levelShareModal.visible,
      goalEditorPrompt.visible,
      goalLinkPrompt.visible,
      goalRenewalPromptVisible,
      goalTemptationPrompt.visible,
      newGoalModal.visible,
      onboardingGoalModal.visible,
      priceEditor.item,
      savingsBreakdownVisible,
      spendBreakdownVisible,
      skinPickerVisible,
      streakRecoveryPrompt.visible,
      tamagotchiVisible,
    ]
  );
  canShowRatingPromptNowRef.current = () => {
    if (onboardingStep !== "done") return false;
    if (!interfaceReady) return false;
    if (tutorialBlockingVisible) return false;
    if (overlayActiveRef.current) return false;
    if (overlayQueueRef.current.length) return false;
    if (celebrationQueueRef.current.length) return false;
    if (celebrationGapTimerRef.current) return false;
    if (overlay?.type === "goal_complete" || pendingGoalCelebration) return false;
    return true;
  };
  canTriggerStoreReviewNowRef.current = () => {
    if (!canShowRatingPromptNowRef.current()) return false;
    return true;
  };
  const canShowQueuedModal = useCallback(
    (type) => {
      if (appStateRef.current !== "active") return false;
      if (!interfaceReady) return false;
      if (tutorialOverlayVisible) return false;
      if (overlay) return false;
      if (coinValueModalVisible) return false;
      if (tutorialBlockingVisible) return false;
      switch (type) {
        case QUEUED_MODAL_TYPES.DAILY_SUMMARY:
          return dailySummaryUnlocked && !!pendingDailySummaryData;
        case QUEUED_MODAL_TYPES.DAILY_CHALLENGE:
          return (
            dailyChallengePromptAllowed &&
            isDailyChallengePromptPending &&
            dailyChallengePromptGate
          );
        case QUEUED_MODAL_TYPES.FOCUS_DIGEST:
          return (
            focusModeUnlocked &&
            !!pendingFocusDigest &&
            !focusDigestPromptShown
          );
        case QUEUED_MODAL_TYPES.FAB_TUTORIAL:
          return (
            fabTutorialState === FAB_TUTORIAL_STATUS.SHOWING &&
            onboardingStep === "done" &&
            tutorialSeen &&
            homeLayoutReady &&
            !startupLogoVisible &&
            !fabTutorialBlocked &&
            activeTab === "feed"
          );
        default:
          return false;
      }
    },
    [
      activeTab,
      coinValueModalVisible,
      dailyChallengePromptAllowed,
      dailyChallengePromptGate,
      dailySummaryUnlocked,
      fabTutorialBlocked,
      fabTutorialState,
      focusDigestPromptShown,
      focusModeUnlocked,
      homeLayoutReady,
      interfaceReady,
      isDailyChallengePromptPending,
      onboardingStep,
      overlay,
      pendingDailySummaryData,
      pendingFocusDigest,
      startupLogoVisible,
      tutorialBlockingVisible,
      tutorialOverlayVisible,
      tutorialSeen,
    ]
  );
  useEffect(() => {
    if (queuedModalActiveRef.current || queuedModalType) return;
    const queue = queuedModalQueueRef.current;
    if (!queue.length) return;
    const nextIndex = queue.findIndex((candidate) => canShowQueuedModal(candidate));
    if (nextIndex < 0) return;
    const [nextType] = queue.splice(nextIndex, 1);
    queuedModalActiveRef.current = nextType;
    setQueuedModalType(nextType);
  }, [canShowQueuedModal, queuedModalProcessTick, queuedModalType]);
  const openGoalLinkPrompt = useCallback((item, intent = "edit") => {
    if (!item) return;
    setGoalLinkPrompt({ visible: true, item, intent, streakRecoveryValue: null });
  }, []);
  const [moodGradient, setMoodGradient] = useState(() =>
    applyThemeToMoodGradient(getMoodGradient(), theme)
  );
  const mainGoalWish = useMemo(
    () => selectMainGoalWish(wishes, activeGoalId || profile.goal),
    [wishes, activeGoalId, profile.goal]
  );
  const resolvedHeroGoalId =
    mainGoalWish?.goalId || mainGoalWish?.id || activeGoalId || profile.goal || null;
  useEffect(() => {
    if (mainGoalWish?.id) {
      ensureGoalManualTracking(mainGoalWish.id);
    }
  }, [mainGoalWish?.id, ensureGoalManualTracking]);
  const savingsBreakdown = useMemo(
    () =>
      buildSavingsBreakdown(
        resolvedHistoryEvents,
        profile.currency || DEFAULT_PROFILE.currency,
        resolveTemplateTitle,
        language
      ),
    [resolvedHistoryEvents, profile.currency, resolveTemplateTitle, language]
  );
  const spendBreakdown = useMemo(
    () =>
      buildSpendingBreakdown(
        resolvedHistoryEvents,
        profile.currency || DEFAULT_PROFILE.currency,
        resolveTemplateTitle,
        language,
        { range: spendBreakdownRange, offset: spendBreakdownOffset }
      ),
    [resolvedHistoryEvents, profile.currency, resolveTemplateTitle, language, spendBreakdownRange, spendBreakdownOffset]
  );
  const fallbackGoalTargetUSD = useMemo(() => {
    if (Number.isFinite(profile?.goalTargetUSD) && profile.goalTargetUSD > 0) {
      return profile.goalTargetUSD;
    }
    if (profile?.goal) {
      return getGoalDefaultTargetUSD(profile.goal);
    }
    return 0;
  }, [profile?.goalTargetUSD, profile?.goal]);
  const primaryGoalSavedUSD = useMemo(() => {
    const goalId = resolvedHeroGoalId;
    if (!goalId) return 0;
    const entry = Array.isArray(profile.primaryGoals)
      ? profile.primaryGoals.find((goal) => goal?.id === goalId)
      : null;
    return Number.isFinite(entry?.savedUSD) ? entry.savedUSD : 0;
  }, [profile.primaryGoals, resolvedHeroGoalId]);
  const heroGoalTargetUSD = useMemo(() => {
    const wishTarget = mainGoalWish?.targetUSD;
    if (Number.isFinite(wishTarget) && wishTarget > 0) {
      return wishTarget;
    }
    const goalEntry = Array.isArray(profile.primaryGoals)
      ? profile.primaryGoals.find((goal) => goal?.id === resolvedHeroGoalId)
      : null;
    if (goalEntry) {
      const targetUSD =
        Number.isFinite(goalEntry.targetUSD) && goalEntry.targetUSD > 0
          ? goalEntry.targetUSD
          : getGoalDefaultTargetUSD(goalEntry.id);
      return targetUSD;
    }
    return resolvedHeroGoalId ? getGoalDefaultTargetUSD(resolvedHeroGoalId) : fallbackGoalTargetUSD;
  }, [fallbackGoalTargetUSD, mainGoalWish?.targetUSD, profile.primaryGoals, resolvedHeroGoalId]);
  const heroGoalSavedUSD = useMemo(() => {
    const wishSaved = Number.isFinite(mainGoalWish?.savedUSD) ? Math.max(mainGoalWish.savedUSD, 0) : 0;
    const primarySaved = Number.isFinite(primaryGoalSavedUSD) ? Math.max(primaryGoalSavedUSD, 0) : 0;
    return Math.max(wishSaved, primarySaved);
  }, [mainGoalWish?.savedUSD, primaryGoalSavedUSD]);
  const goalCelebrationSummary = useMemo(
    () => buildGoalCelebrationSummary(resolvedHistoryEvents, resolvedHeroGoalId),
    [resolvedHistoryEvents, resolvedHeroGoalId]
  );
  const heroGoalProgressRatio = heroGoalTargetUSD > 0 ? heroGoalSavedUSD / heroGoalTargetUSD : 0;
  const remainingGoalUSD = Math.max(heroGoalTargetUSD - heroGoalSavedUSD, 0);
  const averageSaveActionUSD = useMemo(() => {
    if (!resolvedHistoryEvents.length) return FALLBACK_SAVE_ACTION_USD;
    let total = 0;
    let count = 0;
    resolvedHistoryEvents.forEach((entry) => {
      if (!entry || entry.kind !== "refuse_spend") return;
      const amountUSD = Math.max(0, Number(entry.meta?.amountUSD) || 0);
      if (amountUSD <= 0) return;
      total += amountUSD;
      count += 1;
    });
    if (!count || total <= 0) {
      return FALLBACK_SAVE_ACTION_USD;
    }
    return total / count;
  }, [resolvedHistoryEvents]);
  const remainingGoalActions = useMemo(() => {
    if (remainingGoalUSD <= 0) return 0;
    const divisor = averageSaveActionUSD > 0 ? averageSaveActionUSD : FALLBACK_SAVE_ACTION_USD;
    return Math.max(1, Math.ceil(remainingGoalUSD / divisor));
  }, [averageSaveActionUSD, remainingGoalUSD]);
  const activeGender = profile.gender || registrationData.gender || DEFAULT_PROFILE.gender || "none";
  const safeAppTutorialIndex = Math.min(
    tutorialStepIndex,
    Math.max(appTutorialSteps.length - 1, 0)
  );
  const tutorialContext = tutorialVisible
    ? {
        type: "app",
        steps: appTutorialSteps,
        stepIndex: safeAppTutorialIndex,
      }
    : temptationTutorialVisible
    ? {
        type: "temptation",
        steps: TEMPTATION_TUTORIAL_STEPS,
        stepIndex: temptationTutorialStepIndex,
      }
    : null;
  const tutorialStepCount = tutorialContext?.steps.length || 0;
  const tutorialCurrentIndex = tutorialContext?.stepIndex || 0;
  const tutorialAdvanceHandler =
    tutorialContext?.type === "app" ? handleTutorialNext : handleTemptationTutorialNext;
  const tutorialSkipHandler =
    tutorialContext?.type === "app" ? handleTutorialSkip : handleTemptationTutorialSkip;
  const activeTutorialStep = tutorialContext
    ? tutorialContext.steps[tutorialContext.stepIndex] ||
      tutorialContext.steps[tutorialContext.steps.length - 1] ||
      null
    : null;
  const tutorialIsTemptation = tutorialContext?.type === "temptation";
  const tutorialTemptationStepId = tutorialIsTemptation ? activeTutorialStep?.id || null : null;
  const tutorialBackdropPlacementStyle = tutorialIsTemptation
    ? {
        justifyContent: "flex-end",
        alignItems: "stretch",
        paddingTop: Math.max(topSafeInset + 16, 32),
      }
    : null;
  const tutorialCardPositionStyle = tutorialIsTemptation
    ? {
        alignSelf: "center",
        marginBottom: 24,
        marginTop: Platform.OS === "android" ? 24 : 0,
      }
    : null;
  // Push the temptation tutorial dialog lower on Android so it doesn't cover the highlighted card.
  const baseTutorialBackdropPaddingBottom = 24 + tutorialCardOffset;
  const androidGestureNav = Platform.OS === "android" && tabBarBottomInset <= 0;
  const tutorialBackdropPaddingBottom =
    tutorialIsTemptation && Platform.OS === "android"
      ? Math.max(
          24,
          baseTutorialBackdropPaddingBottom - (androidGestureNav ? 0 : 120)
        )
      : baseTutorialBackdropPaddingBottom;
  const tutorialBackdropBottomInset = tutorialIsTemptation ? 0 : tutorialOverlayInset;
  const tutorialHighlightTabs = useMemo(() => {
    if (!tutorialContext) return null;
    if (tutorialContext.type !== "app") return null;
    const step = tutorialContext.steps[tutorialContext.stepIndex] || null;
    if (!step?.tabs?.length) return null;
    return new Set(step.tabs);
  }, [tutorialContext]);
  const tutorialHighlightMaskRect = useMemo(() => {
    if (!tutorialIsTemptation || !tutorialHighlightRect) return null;
    return {
      x: tutorialHighlightRect.x,
      y: tutorialHighlightRect.y,
      width: tutorialHighlightRect.width,
      height: tutorialHighlightRect.height,
      radius: TEMPTATION_CARD_RADIUS,
    };
  }, [tutorialHighlightRect, tutorialIsTemptation]);
  const fabOverlayColor = theme === "dark" ? "rgba(5,7,13,0.78)" : "rgba(5,7,13,0.55)";
  const resolveTranslationValue = useCallback((key) => {
    const normalizedLanguage = normalizeLanguage(language);
    const override = LANGUAGE_OVERRIDES[normalizedLanguage]?.[key];
    const dictionary = TRANSLATIONS[normalizedLanguage] || {};
    let raw =
      override !== undefined
        ? override
        : dictionary[key] ??
          TRANSLATIONS[FALLBACK_LANGUAGE]?.[key] ??
          TRANSLATIONS[DEFAULT_LANGUAGE]?.[key];
    if (raw && typeof raw === "object" && !Array.isArray(raw)) {
      const genderValue = raw[activeGender];
      if (typeof genderValue === "string") {
        raw = genderValue;
      } else if (typeof raw.none === "string") {
        raw = raw.none;
      } else {
        const fallbackValue = Object.values(raw).find((value) => typeof value === "string");
        raw = fallbackValue !== undefined ? fallbackValue : undefined;
      }
    }
    return raw;
  }, [activeGender, language]);

  const formatTranslationText = useCallback((value, replacements = {}) => {
    let text = value;
    if (text === undefined || text === null) {
      text = "";
    }
    text = String(text);
    Object.entries(replacements).forEach(([token, tokenValue]) => {
      text = text.replace(`{{${token}}}`, tokenValue);
    });
    return text;
  }, []);

  const t = useCallback(
    (key, replacements = {}) => {
      const resolved = resolveTranslationValue(key);
      const base = Array.isArray(resolved) ? resolved[0] : resolved;
      const fallback = base === undefined || base === null ? key : base;
      return formatTranslationText(fallback, replacements);
    },
    [formatTranslationText, resolveTranslationValue]
  );

  const tVariant = useCallback(
    (key, replacements = {}) => {
      const resolved = resolveTranslationValue(key);
      const pool = Array.isArray(resolved)
        ? resolved.filter((value) => typeof value === "string" && value.trim().length > 0)
        : typeof resolved === "string"
        ? [resolved]
        : [];
      const pickSource = pool.length ? pool : [resolved ?? key];
      const choice = pickSource[Math.floor(Math.random() * pickSource.length)] ?? key;
      const fallback = choice === undefined || choice === null ? key : choice;
      return formatTranslationText(fallback, replacements);
    },
    [formatTranslationText, resolveTranslationValue]
  );
  const formatHealthRewardText = useCallback(
    (amount) => formatHealthRewardLabel(amount, language),
    [language]
  );
  const dailyChallengeTemplate = useMemo(
    () => (dailyChallenge.templateId ? resolveTemplateCard(dailyChallenge.templateId) : null),
    [dailyChallenge.templateId, resolveTemplateCard]
  );
  const dailyChallengeDisplayTitle = useMemo(() => {
    if (dailyChallengeTemplate) {
      return (
        resolveTemptationTitle(
          dailyChallengeTemplate,
          language,
          titleOverrides[dailyChallengeTemplate.id]
        ) || t("defaultDealTitle")
      );
    }
    return (
      dailyChallenge.templateLabel ||
      dailyChallenge.templateTitle ||
      t("defaultDealTitle")
    );
  }, [
    dailyChallenge.templateLabel,
    dailyChallenge.templateTitle,
    dailyChallengeTemplate,
    language,
    t,
    titleOverrides,
  ]);
  const dailyChallengePriceUSD = useMemo(() => {
    if (dailyChallengeTemplate) {
      const currentPrice = getTemptationPrice(dailyChallengeTemplate);
      if (currentPrice > 0) return currentPrice;
    }
    return Number(dailyChallenge.priceUSD) || 0;
  }, [dailyChallenge.priceUSD, dailyChallengeTemplate]);
  const dailyChallengeRewardBonus = useMemo(
    () => computeDailyChallengeBonus(dailyChallengePriceUSD, profile.currency || DEFAULT_PROFILE.currency),
    [dailyChallengePriceUSD, profile.currency]
  );
  const dailyChallengeRewardLabel = useMemo(
    () => formatHealthRewardText(dailyChallengeRewardBonus || 0),
    [dailyChallengeRewardBonus, formatHealthRewardText]
  );
  const currentMood = useMemo(
    () => deriveMoodFromState(moodState, pendingList.length),
    [moodState.events, moodState.lastInteractionAt, moodState.lastVisitAt, pendingList.length]
  );
  const moodPreset = useMemo(() => getMoodPreset(currentMood, language), [currentMood, language]);
  useEffect(() => {
    setMoodGradient(applyThemeToMoodGradient(getMoodGradient(moodPreset?.id), theme));
  }, [moodPreset?.id, theme]);
  const moodGoalInfo = useMemo(() => {
    const aggregatedTargetUSD = heroGoalTargetUSD || 0;
    const savedUSD = heroGoalSavedUSD || 0;
    const isComplete = aggregatedTargetUSD > 0 && savedUSD >= aggregatedTargetUSD;
    return { aggregatedTargetUSD, savedUSD, isComplete };
  }, [heroGoalTargetUSD, heroGoalSavedUSD]);
  const moodDescription = useMemo(() => {
    if (!moodPreset) return "";
    const baseLine = moodGoalInfo.isComplete
      ? moodPreset.heroComplete || t("goalWidgetCompleteTagline")
      : moodPreset.hero || t("heroEconomyContinues");
    return moodPreset.motivation ? `${baseLine} ${moodPreset.motivation}` : baseLine;
  }, [moodGoalInfo.isComplete, moodPreset, t]);
  const moodSessionRecordedRef = useRef(false);
  useEffect(() => {
    if (moodSessionRecordedRef.current) return;
    moodSessionRecordedRef.current = true;
    const now = Date.now();
    setMoodState((prev) =>
      evaluateMoodState(
        {
          ...prev,
          lastVisitAt: now,
        },
        { now, pendingCount: pendingList.length }
      )
    );
  }, [pendingList.length]);
  useEffect(() => {
    if (!moodHydrated) return;
    AsyncStorage.setItem(STORAGE_KEYS.MOOD_STATE, JSON.stringify(moodState)).catch(() => {});
  }, [moodState, moodHydrated]);

  useEffect(() => {
    const now = Date.now();
    const mappedEvents = mapHistoryEventsToMoodEvents(resolvedHistoryEvents, now);
    const latestTimestamp = mappedEvents[0]?.timestamp || null;
    setMoodState((prev) =>
      evaluateMoodState(
        {
          ...prev,
          events: mappedEvents,
          lastInteractionAt: latestTimestamp || prev.lastInteractionAt,
        },
        { now, pendingCount: pendingList.length }
      )
    );
  }, [resolvedHistoryEvents, pendingList.length]);

  useEffect(() => {
    setMoodState((prev) =>
      evaluateMoodState(
        { ...prev, pendingSnapshot: pendingList.length },
        { pendingCount: pendingList.length }
      )
    );
  }, [pendingList.length]);

  const refreshMoodForToday = useCallback(() => {
    const todayKey = getDayKey(Date.now());
    setMoodState((prev) => {
      if (prev.dayKey === todayKey) return prev;
      const refreshed = evaluateMoodState(
        createMoodStateForToday({
          pendingSnapshot: pendingList.length,
          lastVisitAt: Date.now(),
          dayKey: todayKey,
        }),
        { pendingCount: pendingList.length }
      );
      return refreshed;
    });
  }, [pendingList.length]);

  useEffect(() => {
    let timer = null;
    const scheduleNextUpdate = () => {
      const now = new Date();
      const nextMidnight = new Date(now);
      nextMidnight.setHours(24, 0, 0, 0);
      const delay = Math.max(nextMidnight.getTime() - now.getTime() + 1000, 60 * 1000);
      timer = setTimeout(() => {
        refreshMoodForToday();
        scheduleNextUpdate();
      }, delay);
    };
    refreshMoodForToday();
    scheduleNextUpdate();
    return () => {
      if (timer) {
        clearTimeout(timer);
      }
    };
  }, [refreshMoodForToday]);
  const ensureNotificationPermission = useCallback(async ({ request = true } = {}) => {
    try {
      let settings = await Notifications.getPermissionsAsync();
      let granted =
        settings.granted ||
        settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL;
      if (!granted && request) {
        suppressResumeOnceRef.current = true;
        settings = await Notifications.requestPermissionsAsync();
        if (appStateRef.current === "active") {
          suppressResumeOnceRef.current = false;
        }
        granted =
          settings.granted ||
          settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL;
      }
      setNotificationPermissionGranted(granted);
      return granted;
    } catch (error) {
      console.warn("notifications", error);
      setNotificationPermissionGranted(false);
      return false;
    }
  }, []);

  useEffect(() => {
    if (!dailySummaryUnlocked) return;
    if (onboardingStep !== "done") return;
    const task = InteractionManager.runAfterInteractions(() => {
      ensureNotificationPermission({ request: false });
    });
    return () => {
      task?.cancel?.();
    };
  }, [ensureNotificationPermission, onboardingStep]);
  const getReminderAnalyticsPayload = useCallback((notification) => {
    const data = notification?.request?.content?.data || {};
    const reminderType = typeof data.kind === "string" && data.kind.trim() ? data.kind : "generic";
    const targetScreen =
      typeof data.targetScreen === "string" && data.targetScreen.trim()
        ? data.targetScreen
        : typeof data.target_screen === "string" && data.target_screen.trim()
        ? data.target_screen
        : null;
    return { reminder_type: reminderType, target_screen: targetScreen || undefined };
  }, []);
  const applyDailySummaryFromNotification = useCallback(
    (data) => {
      if (!dailySummaryUnlocked) return false;
      if (!data || typeof data !== "object") return false;
      const hasPayload =
        data.todayKey != null ||
        data.today_key != null ||
        data.savedUSD != null ||
        data.saved_usd != null ||
        data.declines != null ||
        data.spends != null;
      if (!hasPayload) return false;
      const rawKey =
        typeof data.todayKey === "string" && data.todayKey.trim()
          ? data.todayKey.trim()
          : typeof data.today_key === "string" && data.today_key.trim()
          ? data.today_key.trim()
          : null;
      const todayKey = rawKey || getDayKey(Date.now());
      if (!todayKey) return false;
      if (dailySummarySeenKey === todayKey) return false;
      const savedUSD = Math.max(
        0,
        Number(
          data.savedUSD ??
            data.saved_usd ??
            data.saved ??
            data.amountUSD ??
            data.amount
        ) || 0
      );
      const declines = Math.max(0, Number(data.declines) || 0);
      const spends = Math.max(0, Number(data.spends) || 0);
      const summaryPayload = { savedUSD, declines, spends, todayKey };
      setPendingDailySummaryData((prev) =>
        prev?.todayKey === todayKey ? prev : summaryPayload
      );
      enqueueQueuedModal(QUEUED_MODAL_TYPES.DAILY_SUMMARY);
      return true;
    },
    [dailySummarySeenKey, dailySummaryUnlocked, enqueueQueuedModal, getDayKey]
  );
  const handleNotificationOpenFromPush = useCallback(
    (response) => {
      if (!response?.notification?.request) return;
      const identifier = response.notification.request.identifier;
      if (identifier && handledNotificationResponseIdsRef.current.has(identifier)) return;
      if (identifier) {
        handledNotificationResponseIdsRef.current.add(identifier);
      }
      const actionIdentifier = response?.actionIdentifier;
      const isDefaultTap =
        !actionIdentifier || actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER;
      if (!isDefaultTap) {
        notificationActionHandlerRef.current?.({
          actionIdentifier,
          notification: response.notification,
        });
      }
      if (isDefaultTap) {
        const data = response.notification.request.content?.data || {};
        const targetScreen =
          typeof data.targetScreen === "string" && data.targetScreen.trim()
            ? data.targetScreen.trim()
            : typeof data.target_screen === "string" && data.target_screen.trim()
            ? data.target_screen.trim()
            : null;
        const pendingId = typeof data.pendingId === "string" ? data.pendingId : null;
        if (data.kind === "daily_summary") {
          applyDailySummaryFromNotification(data);
        } else if ((targetScreen === "pending" || data.kind === "pending_decision") && pendingId) {
          setPendingFocusId(pendingId);
          goToTab("pending");
        }
      }
      const reminderPayload = getReminderAnalyticsPayload(response.notification);
      logEvent("push_notification_open");
      logEvent("reminder_clicked", reminderPayload);
    },
    [applyDailySummaryFromNotification, getReminderAnalyticsPayload, goToTab, logEvent]
  );
  useEffect(() => {
    let isMounted = true;
    Notifications.getLastNotificationResponseAsync()
      .then((response) => {
        if (!isMounted) return;
        handleNotificationOpenFromPush(response);
      })
      .catch(() => {});
    const subscription = Notifications.addNotificationResponseReceivedListener(
      handleNotificationOpenFromPush
    );
    return () => {
      isMounted = false;
      if (subscription?.remove) {
        subscription.remove();
      }
    };
  }, [handleNotificationOpenFromPush]);
  useEffect(() => {
    const subscription = Notifications.addNotificationReceivedListener((notification) => {
      const now = Date.now();
      lastInstantNotificationRef.current = now;
      AsyncStorage.setItem(STORAGE_KEYS.LAST_NOTIFICATION_AT, String(now)).catch(() => {});
      const kind = notification?.request?.content?.data?.kind;
      if (kind === "tamagotchi_hunger") {
        tamagotchiHungerLastAtRef.current = now;
        AsyncStorage.setItem(STORAGE_KEYS.TAMAGOTCHI_HUNGER_LAST_AT, String(now)).catch(() => {});
      }
      const reminderPayload = getReminderAnalyticsPayload(notification);
      logEvent("reminder_shown", reminderPayload);
    });
    return () => {
      if (subscription?.remove) {
        subscription.remove();
      }
    };
  }, [getReminderAnalyticsPayload, logEvent]);
  useEffect(() => {
    let cancelled = false;
    AsyncStorage.getItem(STORAGE_KEYS.PUSH_NOTIFICATIONS_ENABLED_LOGGED)
      .then((value) => {
        if (cancelled) return;
        pushOptInLoggedRef.current = value === "1";
        setPushOptInHydrated(true);
      })
      .catch(() => {
        if (cancelled) return;
        setPushOptInHydrated(true);
      });
    return () => {
      cancelled = true;
    };
  }, []);
  useEffect(() => {
    let cancelled = false;
    AsyncStorage.getItem(STORAGE_KEYS.PUSH_DAY_THREE_PROMPT)
      .then((value) => {
        if (cancelled) return;
        pushDayThreePromptShownRef.current = value === "1";
        setPushDayThreePromptHydrated(true);
      })
      .catch(() => {
        if (cancelled) return;
        setPushDayThreePromptHydrated(true);
      });
    return () => {
      cancelled = true;
    };
  }, []);
  useEffect(() => {
    let cancelled = false;
    AsyncStorage.getItem(STORAGE_KEYS.SPEND_LOGGING_REMINDER)
      .then((value) => {
        if (cancelled) return;
        lastSpendLoggingReminderRef.current = Number(value) || 0;
        setSpendLoggingReminderHydrated(true);
      })
      .catch(() => {
        if (cancelled) return;
        setSpendLoggingReminderHydrated(true);
      });
    return () => {
      cancelled = true;
    };
  }, []);
  useEffect(() => {
    let cancelled = false;
    AsyncStorage.getItem(STORAGE_KEYS.LAST_NOTIFICATION_AT)
      .then((value) => {
        if (cancelled) return;
        const parsed = Number(value) || 0;
        if (parsed > 0) {
          lastInstantNotificationRef.current = parsed;
        }
      })
      .catch(() => {});
    return () => {
      cancelled = true;
    };
  }, []);
  useEffect(() => {
    if (!pushOptInHydrated) return;
    if (notificationPermissionGranted !== true) return;
    if (pushOptInLoggedRef.current) return;
    pushOptInLoggedRef.current = true;
    AsyncStorage.setItem(STORAGE_KEYS.PUSH_NOTIFICATIONS_ENABLED_LOGGED, "1").catch(() => {});
    logEvent("push_notifications_enabled");
  }, [notificationPermissionGranted, pushOptInHydrated]);
  useEffect(() => {
    if (!pushDayThreePromptHydrated) return;
    if (pushDayThreePromptShownRef.current) return;
    if (notificationPermissionGranted !== false) return;
    if (!profileHydrated) return;
    if (!profileJoinedAt) return;
    if (onboardingStep !== "done") return;
    const joinedAtTimestamp = new Date(profileJoinedAt).getTime();
    if (!Number.isFinite(joinedAtTimestamp)) return;
    const ordinalDay = Math.floor((Date.now() - joinedAtTimestamp) / DAY_MS) + 1;
    if (ordinalDay < 3) return;
    pushDayThreePromptShownRef.current = true;
    AsyncStorage.setItem(STORAGE_KEYS.PUSH_DAY_THREE_PROMPT, "1").catch(() => {});
    setPushDayThreePromptVisible(true);
  }, [
    notificationPermissionGranted,
    dailySummaryUnlocked,
    onboardingStep,
    profileHydrated,
    profileJoinedAt,
    pushDayThreePromptHydrated,
  ]);
  const handlePushDayThreePromptLater = useCallback(() => {
    setPushDayThreePromptVisible(false);
  }, []);
  const handlePushDayThreePromptEnable = useCallback(async () => {
    setPushDayThreePromptVisible(false);
    await ensureNotificationPermission();
  }, [ensureNotificationPermission]);

  const sendImmediateNotification = useCallback(
    async (content, options = {}) => {
      if (!content) return false;
      const now = Date.now();
      const dedupeKey = options?.dedupeKey || content?.data?.dedupeKey || null;
      const dedupeWindowMs = Number(options?.dedupeWindowMs) || PUSH_DEDUPE_WINDOW_MS;
      if (dedupeKey) {
        const lastSent = Number(notificationDedupeRef.current.get(dedupeKey)) || 0;
        if (lastSent > 0 && now - lastSent < dedupeWindowMs) {
          return false;
        }
      }
      const blocked = await isNotificationOnCooldown(now);
      if (blocked) {
        return false;
      }
      const allowed = await ensureNotificationPermission({ request: false });
      if (!allowed) return false;
      try {
        await Notifications.scheduleNotificationAsync({
          content,
          trigger: null,
        });
        lastInstantNotificationRef.current = now;
        if (dedupeKey) {
          notificationDedupeRef.current.set(dedupeKey, now);
        }
        AsyncStorage.setItem(STORAGE_KEYS.LAST_NOTIFICATION_AT, String(now)).catch(() => {});
        return true;
      } catch (error) {
        console.warn("immediate notification", error);
        return false;
      }
    },
    [ensureNotificationPermission, isNotificationOnCooldown]
  );

  useEffect(() => {
    if (Platform.OS !== "android") return;
    Notifications.setNotificationChannelAsync(ANDROID_DAILY_NUDGE_CHANNEL_ID, {
      name: "Daily nudges",
      importance: Notifications.AndroidImportance.HIGH,
      sound: true,
      vibrationPattern: [250, 250, 250],
      lockscreenVisibility: Notifications.AndroidNotificationVisibility.PUBLIC,
    }).catch(() => {});
    Notifications.setNotificationChannelAsync(ANDROID_TAMAGOTCHI_CHANNEL_ID, {
      name: "Tamagotchi hunger",
      importance: Notifications.AndroidImportance.HIGH,
      sound: true,
      vibrationPattern: [250, 250, 250],
      lockscreenVisibility: Notifications.AndroidNotificationVisibility.PUBLIC,
    }).catch(() => {});
  }, []);
  useEffect(() => {
    const actions = [
      {
        identifier: NOTIFICATION_ACTION_SAVE,
        buttonTitle: t("pushActionSave"),
        options: { opensAppToForeground: true },
      },
      {
        identifier: NOTIFICATION_ACTION_SPEND,
        buttonTitle: t("pushActionSpend"),
        options: { opensAppToForeground: true },
      },
    ];
    Notifications.setNotificationCategoryAsync(ACTIONABLE_NOTIFICATION_CATEGORY_ID, actions).catch(() => {});
  }, [t]);

  useEffect(() => {
    dailyNudgeIdsRef.current = dailyNudgeNotificationIds || {};
  }, [dailyNudgeNotificationIds]);
  useEffect(() => {
    pendingListRef.current = Array.isArray(pendingList) ? pendingList : [];
  }, [pendingList]);
  useEffect(() => {
    if (Platform.OS !== "ios") return;
    if (!pendingList?.length) {
      setPendingBadgeTick(0);
      return undefined;
    }
    const intervalId = setInterval(() => {
      setPendingBadgeTick((prev) => prev + 1);
    }, PENDING_BADGE_TICK_MS);
    return () => clearInterval(intervalId);
  }, [pendingList?.length]);
  const pendingActionCount = useMemo(() => {
    const now = Date.now();
    return (Array.isArray(pendingList) ? pendingList : []).reduce((count, item) => {
      const dueAt = Number(item?.decisionDue) || 0;
      if (dueAt > 0 && dueAt <= now) return count + 1;
      return count;
    }, 0);
  }, [pendingBadgeTick, pendingList]);
  useEffect(() => {
    if (Platform.OS !== "ios") return;
    const count = Math.max(0, pendingActionCount || 0);
    Notifications.setBadgeCountAsync(count).catch(() => {});
  }, [pendingActionCount]);

  useEffect(() => {
    smartRemindersRef.current = smartReminders || [];
    const now = Date.now();
    const lastFutureReminder = (smartReminders || []).reduce((latest, reminder) => {
      const scheduledAt = Number(reminder?.scheduledAt) || 0;
      return scheduledAt > now ? Math.max(latest, scheduledAt) : latest;
    }, 0);
    smartReminderScheduleTailRef.current = lastFutureReminder;
  }, [smartReminders]);

  useEffect(() => {
    if (!potentialPushHydrated) return;
    const currencyForStep = profile?.currency || DEFAULT_PROFILE.currency;
    const stepUSD = resolvePotentialPushStepUSD(currencyForStep);
    if (!Number.isFinite(stepUSD) || stepUSD <= 0) return;
    if (!potentialBaselineKey) {
      if (
        potentialPushProgress.baselineKey ||
        potentialPushProgress.lastStep ||
        potentialPushProgress.lastStatus ||
        potentialPushProgress.stepMultiplier !== 1 ||
        potentialPushProgress.lastNotifiedAt
      ) {
        setPotentialPushProgress({ ...DEFAULT_POTENTIAL_PUSH_STATE });
      }
      return;
    }
    const resolvedPotential = Number(getPotentialSavedNow()) || 0;
    const currentStep = Math.max(0, Math.floor(resolvedPotential / stepUSD));
    const lastStep = Math.max(0, Number(potentialPushProgress.lastStep) || 0);
    const now = Date.now();
    const lastNotifiedAt = Number(potentialPushProgress.lastNotifiedAt) || 0;
    const rawMultiplier = Math.max(1, Number(potentialPushProgress.stepMultiplier) || 1);
    const cooledDown =
      rawMultiplier > 1 &&
      lastNotifiedAt > 0 &&
      now - lastNotifiedAt > POTENTIAL_PUSH_COOLDOWN_WINDOW_MS;
    const stepMultiplier = cooledDown
      ? 1
      : Math.min(rawMultiplier, POTENTIAL_PUSH_MAX_MULTIPLIER);
    if (cooledDown) {
      setPotentialPushProgress((prev) => {
        if (prev.baselineKey !== potentialBaselineKey || prev.stepMultiplier <= 1) return prev;
        return { ...prev, stepMultiplier: 1 };
      });
    }
    if (potentialPushProgress.baselineKey !== potentialBaselineKey) {
      setPotentialPushProgress({
        ...DEFAULT_POTENTIAL_PUSH_STATE,
        lastStep: currentStep,
        baselineKey: potentialBaselineKey,
      });
      return;
    }
    if (currentStep < lastStep) {
      setPotentialPushProgress((prev) => ({
        ...prev,
        lastStep: currentStep,
      }));
      return;
    }
    if (!profileHydrated || !savedTotalHydrated) return;
    if (currentStep <= 0 || currentStep <= lastStep) return;
    const stepGap = currentStep - lastStep;
    const requiredGap = stepMultiplier;
    if (stepGap < requiredGap) return;
    const fastGain =
      lastNotifiedAt > 0 && now - lastNotifiedAt < POTENTIAL_PUSH_FAST_GAIN_WINDOW_MS;
    if (fastGain && stepMultiplier < POTENTIAL_PUSH_MAX_MULTIPLIER) {
      setPotentialPushProgress((prev) => {
        if (prev.baselineKey !== potentialBaselineKey) return prev;
        if (prev.stepMultiplier >= POTENTIAL_PUSH_MAX_MULTIPLIER) return prev;
        return { ...prev, stepMultiplier: POTENTIAL_PUSH_MAX_MULTIPLIER };
      });
      return;
    }
    let cancelled = false;
    const notify = async () => {
      const ahead = savedTotalUSD >= resolvedPotential && savedTotalUSD > 0;
      const status = ahead ? "ahead" : "behind";
      const formatLocal = (valueUSD = 0) =>
        formatCurrency(convertToCurrency(Math.max(valueUSD, 0), currencyForStep), currencyForStep);
      const replacements = {
        potential: formatLocal(resolvedPotential),
        actual: formatLocal(savedTotalUSD),
        shortfall: formatLocal(Math.max(resolvedPotential - savedTotalUSD, 0)),
      };
      const dedupeKey = `potential:${potentialBaselineKey}:${status}:${currentStep}`;
      await sendImmediateNotification(
        {
          title: t(
            status === "ahead" ? "potentialPushAheadTitle" : "potentialPushBehindTitle",
            replacements
          ),
          body: t(
            status === "ahead" ? "potentialPushAheadBody" : "potentialPushBehindBody",
            replacements
          ),
          data: { kind: "potential_push", status, dedupeKey },
        },
        { dedupeKey, dedupeWindowMs: POTENTIAL_PUSH_COOLDOWN_WINDOW_MS }
      );
      if (cancelled) return;
      setPotentialPushProgress({
        lastStep: currentStep,
        lastStatus: status,
        baselineKey: potentialBaselineKey,
        stepMultiplier,
        lastNotifiedAt: now,
      });
    };
    notify().catch(() => {});
    return () => {
      cancelled = true;
    };
  }, [
    potentialBaselineKey,
    potentialPushHydrated,
    potentialPushProgress.baselineKey,
    potentialPushProgress.lastNotifiedAt,
    potentialPushProgress.lastStatus,
    potentialPushProgress.lastStep,
    potentialPushProgress.stepMultiplier,
    getPotentialSavedNow,
    profile?.currency,
    profileHydrated,
    savedTotalHydrated,
    savedTotalUSD,
    sendImmediateNotification,
    t,
  ]);

  useEffect(() => {
    if (!profileHydrated || !customReminderHydrated) return;
    schedulePersonalTemptationReminder(profile.customSpend);
  }, [
    customReminderHydrated,
    notificationPermissionGranted,
    profile.customSpend,
    profileHydrated,
    schedulePersonalTemptationReminder,
  ]);

  useEffect(() => {
    const tick = () => {
      setChallengesState((prev) => expireChallenges(prev));
    };
    tick();
    const interval = setInterval(tick, 60000);
    return () => clearInterval(interval);
  }, []);

  useEffect(() => {
    const staleEntries = Object.values(challengesState).filter(
      (entry) => entry?.reminderNotificationIds?.length && entry.status !== CHALLENGE_STATUS.ACTIVE
    );
    if (!staleEntries.length) return;
    staleEntries.forEach((entry) => {
      entry.reminderNotificationIds.forEach((id) => {
        Notifications.cancelScheduledNotificationAsync(id).catch(() => {});
      });
    });
    setChallengesState((prev) => {
      let changed = false;
      const next = { ...prev };
      staleEntries.forEach((entry) => {
        if (next[entry.id]?.reminderNotificationIds?.length) {
          next[entry.id] = { ...next[entry.id], reminderNotificationIds: [] };
          changed = true;
        }
      });
      return changed ? next : prev;
    });
  }, [challengesState]);

  useEffect(() => {
    const prev = challengesPrevRef.current || {};
    const completedIds = [];
    const expiredIds = [];
    const allowSpeech = challengesHydrated;
    let progressBumped = false;
    Object.keys(challengesState).forEach((id) => {
      const previousStatus = prev[id]?.status;
      const nextStatus = challengesState[id]?.status;
      const previousProgress = Number(prev[id]?.progress) || 0;
      const nextProgress = Number(challengesState[id]?.progress) || 0;
      if (nextStatus === CHALLENGE_STATUS.COMPLETED && previousStatus !== CHALLENGE_STATUS.COMPLETED) {
        completedIds.push(id);
      } else if (
        nextStatus === CHALLENGE_STATUS.EXPIRED &&
        previousStatus === CHALLENGE_STATUS.ACTIVE
      ) {
        expiredIds.push(id);
      } else if (
        nextStatus === CHALLENGE_STATUS.ACTIVE &&
        nextProgress > previousProgress
      ) {
        progressBumped = true;
      }
    });
    completedIds.forEach((challengeId) => {
      const def = CHALLENGE_DEF_MAP[challengeId];
      if (!def) return;
      const copy = getChallengeCopy(def, language);
      const title = copy.title || challengeId;
      triggerOverlayState("reward", t("challengeCompletedOverlay", { title }));
      logEvent("challenge_completed", { challenge_id: challengeId, success: true });
    });
    expiredIds.forEach((challengeId) => {
      logEvent("challenge_completed", { challenge_id: challengeId, success: false });
    });
    if (allowSpeech && progressBumped) {
      queueHomeSpeech("challenge_progress");
    }
    challengesPrevRef.current = challengesState;
  }, [
    challengesHydrated,
    challengesState,
    language,
    logEvent,
    queueHomeSpeech,
    t,
    triggerOverlayState,
  ]);

  useEffect(() => {
    impulseAlertCooldownRef.current = impulseTracker.lastAlerts || {};
  }, [impulseTracker.lastAlerts]);


  useEffect(() => {
    return () => {
      if (stormTimerRef.current) {
        clearTimeout(stormTimerRef.current);
        stormTimerRef.current = null;
      }
    };
  }, []);

  const schedulePendingReminder = useCallback(
    async (title, dueDate, meta = {}) => {
      try {
        const allowed = await ensureNotificationPermission({ request: false });
        if (!allowed) return null;
        const dueTimestamp = Number(dueDate);
        if (!Number.isFinite(dueTimestamp)) return null;
        const now = Date.now();
        const latestAllowed = dueTimestamp + PENDING_REMINDER_GRACE_MS;
        if (now > latestAllowed) return null;
        const triggerAt = Math.max(dueTimestamp - PENDING_REMINDER_LEAD_MS, now);
        if (triggerAt > latestAllowed) return null;
        const trigger = triggerAt <= now + 1000 ? null : new Date(triggerAt);
        const pendingTitle =
          moodPreset?.pushPendingTitle && moodPreset.pushPendingTitle.trim()
            ? renderTemplateString(moodPreset.pushPendingTitle, { title })
            : t("pendingNotificationTitle");
        const pendingBody =
          moodPreset?.pushPendingBody && moodPreset.pushPendingBody.trim()
            ? renderTemplateString(moodPreset.pushPendingBody, { title })
            : t("pendingNotificationBody", { title });
        const dedupeKey =
          meta?.dedupeKey ||
          (typeof meta?.pendingId === "string" && meta.pendingId
            ? `pending:${meta.pendingId}`
            : null);
        const scheduledId = await Notifications.scheduleNotificationAsync({
          content: {
            title: pendingTitle,
            body: pendingBody,
            data: {
              kind: "pending_decision",
              pendingId: meta?.pendingId || null,
              templateId: meta?.templateId || null,
              title: meta?.title || title,
              emoji: meta?.emoji || null,
              amountUSD: Number(meta?.amountUSD) || null,
              targetScreen: "pending",
              dedupeKey,
            },
            categoryIdentifier: ACTIONABLE_NOTIFICATION_CATEGORY_ID,
          },
          trigger,
        });
        return scheduledId || null;
      } catch (error) {
        console.warn("pending reminder", error);
        return null;
      }
    },
    [ensureNotificationPermission, t, moodPreset]
  );

  const scheduleChallengeReminders = useCallback(
    async (challengeId, def, startAt, expiresAt) => {
      if (!def?.reminderOffsetsHours?.length) return [];
      const permitted = await ensureNotificationPermission({ request: false });
      if (!permitted) return [];
      const copy = getChallengeCopy(def, language);
      const title = t("challengeReminderTitle", { title: copy.title || challengeId });
      const body = t("challengeReminderBody", { title: copy.title || challengeId });
      const scheduled = [];
      const challengeHash = hashString(challengeId || "");
      const jitterMinutes = challengeHash % 11;
      const windows =
        CHALLENGE_REMINDER_WINDOWS.length > 0
          ? [
              ...CHALLENGE_REMINDER_WINDOWS.slice(challengeHash % CHALLENGE_REMINDER_WINDOWS.length),
              ...CHALLENGE_REMINDER_WINDOWS.slice(0, challengeHash % CHALLENGE_REMINDER_WINDOWS.length),
            ]
          : [];
      for (let index = 0; index < def.reminderOffsetsHours.length; index += 1) {
        const offsetHours = def.reminderOffsetsHours[index];
        const triggerTime = startAt + offsetHours * 60 * 60 * 1000;
        if (!Number.isFinite(triggerTime) || triggerTime <= Date.now()) continue;
        if (expiresAt && triggerTime >= expiresAt) continue;
        const slot = windows[index % (windows.length || 1)];
        let scheduledTime = alignReminderSlotTime(triggerTime, slot, jitterMinutes);
        if (expiresAt && scheduledTime >= expiresAt) {
          scheduledTime = triggerTime + jitterMinutes * 60 * 1000;
        }
        if (!Number.isFinite(scheduledTime)) continue;
        if (expiresAt && scheduledTime >= expiresAt) continue;
        try {
          const scheduledEntry = await scheduleNotificationWithCooldown({
            content: { title, body },
            trigger: new Date(scheduledTime),
          });
          const notificationId = scheduledEntry?.id;
          if (notificationId) {
            scheduled.push(notificationId);
          }
        } catch (error) {
          console.warn("challenge reminder", error);
        }
      }
      return scheduled;
    },
    [ensureNotificationPermission, language, scheduleNotificationWithCooldown, t]
  );

  const customGoalMap = useMemo(() => {
    const entries = registrationData.customGoals || [];
    return entries.reduce((acc, goal) => {
      acc[goal.id] = goal;
      return acc;
    }, {});
  }, [registrationData.customGoals]);

  const colors = THEMES[theme];
  const isDarkTheme = theme === "dark";
  const overlayDimColor = isDarkTheme ? "rgba(0,0,0,0.65)" : "rgba(5,6,15,0.2)";
  const overlaySystemColor = useMemo(
    () => blendHexColors(colors.background, isDarkTheme ? "#000000" : "#05060F", isDarkTheme ? 0.5 : 0.15),
    [colors.background, isDarkTheme]
  );
  const overlayCardBackground = isDarkTheme ? lightenColor(colors.card, 0.18) : colors.card;
  const overlayBorderColor = isDarkTheme ? lightenColor(colors.border, 0.25) : colors.border;
  const impulseAlertPayload = useMemo(() => {
    if (overlay?.type !== "impulse_alert") return null;
    if (overlay?.message && typeof overlay.message === "object") {
      return overlay.message;
    }
    if (!overlay?.message) return null;
    return { body: overlay.message };
  }, [overlay]);
  const isFeatureUnlockOverlay =
    overlay?.type === "cart" && overlay?.message && typeof overlay.message === "object" && overlay.message.featureUnlock;
  const systemOverlayActive = Boolean(overlay || fabMenuVisible);

  useEffect(() => {
    if (!isAndroid || !canSetSystemBarColors) return;
    const targetNavColor = systemOverlayActive ? overlaySystemColor : colors.card;
    const targetButtonStyle = systemOverlayActive ? "light" : isDarkTheme ? "light" : "dark";
    const targetStatusColor = systemOverlayActive ? overlaySystemColor : colors.background;
    const targetNavVisibility = systemOverlayActive ? "hidden" : "visible";
    const applyNav = async () => {
      try {
        await NavigationBar.setBackgroundColorAsync(targetNavColor);
        await NavigationBar.setButtonStyleAsync(targetButtonStyle);
        if (canToggleNavVisibility) {
          await NavigationBar.setVisibilityAsync(targetNavVisibility);
        }
      } catch (err) {
        console.warn("navigation bar color", err);
      }
    };
    applyNav();
    RNStatusBar.setBackgroundColor(targetStatusColor, true);
  }, [
    canSetSystemBarColors,
    canToggleNavVisibility,
    colors.card,
    colors.background,
    isAndroid,
    isDarkTheme,
    overlayDimColor,
    overlaySystemColor,
    systemOverlayActive,
  ]);
  const saveOverlayPayload =
    overlay?.type === "save"
      ? typeof overlay.message === "object" && overlay.message !== null
        ? overlay.message
        : { title: overlay.message }
      : null;
  const saveCelebrationRef = useRef(null);
  const saveOverlayShownAtRef = useRef(0);
  useEffect(() => {
    if (overlay?.type !== "save") return;
    saveOverlayShownAtRef.current = Date.now();
  }, [overlay?.type]);
  const overlaySoundKeyRef = useRef(null);
  const overlaySoundTimersRef = useRef([]);
  const clearOverlaySoundTimers = useCallback(() => {
    if (!overlaySoundTimersRef.current.length) return;
    overlaySoundTimersRef.current.forEach((timerId) => clearTimeout(timerId));
    overlaySoundTimersRef.current = [];
  }, []);
  useEffect(() => {
    if (!overlay?.type) {
      overlaySoundKeyRef.current = null;
      clearOverlaySoundTimers();
      return undefined;
    }
    const message = overlay.message;
    const soundKey = (() => {
      if (overlay.type === "level") return `level:${message ?? ""}`;
      if (overlay.type === "health") return `health:${message?.amount ?? ""}:${message?.displayCoins ?? ""}`;
      if (overlay.type === "daily_reward") return `daily_reward:${message?.amount ?? ""}`;
      if (typeof message === "string") return `${overlay.type}:${message.slice(0, 32)}`;
      return overlay.type;
    })();
    if (overlaySoundKeyRef.current === soundKey) {
      return undefined;
    }
    overlaySoundKeyRef.current = soundKey;
    clearOverlaySoundTimers();
    const scheduleSound = (delay, key, options = undefined) => {
      if (!key) return;
      const timerId = setTimeout(() => {
        playSound(key, options);
      }, Math.max(0, delay));
      overlaySoundTimersRef.current.push(timerId);
    };
    if (overlay.type === "level") {
      scheduleSound(140, "level_up", { skipCooldown: true });
    } else if (overlay.type === "reward") {
      scheduleSound(180, "reward");
    } else if (overlay.type === "daily_reward") {
      scheduleSound(180, "daily_reward");
      scheduleSound(300, "coin");
    } else if (overlay.type === "health") {
      scheduleSound(140, "coin");
    } else if (overlay.type === "goal_complete") {
      scheduleSound(220, "level_up");
    }
    return () => {
      clearOverlaySoundTimers();
    };
  }, [clearOverlaySoundTimers, overlay, playSound]);
  const handleSaveOverlayPress = useCallback(() => {
    if (overlay?.type === "save" && Date.now() - saveOverlayShownAtRef.current < 350) {
      return;
    }
    const triggerPendingLevelCelebrate = () => {
      const queuedLevel = levelCelebrationQueuedRef.current || 0;
      const celebratedLevel = Math.max(1, Number(lastCelebratedLevel) || 1);
      if (
        !pendingLevelCelebrationRef.current &&
        playerLevel <= Math.max(queuedLevel, celebratedLevel)
      ) {
        return;
      }
      if (!pendingLevelCelebrationRef.current) {
        const baseLevel = Math.max(
          1,
          Number(lastCelebratedLevel) || 1,
          levelCelebrationQueuedRef.current || 0
        );
        if (playerLevel > baseLevel) {
          pendingLevelCelebrationRef.current = {
            level: playerLevel,
            levelsEarned: playerLevel - baseLevel,
          };
          levelCelebrationQueuedRef.current = Math.max(
            levelCelebrationQueuedRef.current || 0,
            playerLevel
          );
        }
      }
      const pending = pendingLevelCelebrationRef.current;
      if (pending && pending.level > Math.max(1, Number(lastCelebratedLevel) || 1)) {
        persistLastCelebratedLevel(pending.level);
        previousPlayerLevelRef.current = Math.max(
          previousPlayerLevelRef.current || 1,
          pending.level
        );
      }
      runPendingLevelCelebration();
    };
    if (overlay?.type === "save" && pendingLevelCelebrationRef.current) {
      // Make sure level celebration sequence isn't lost behind the save overlay.
      const dismissedAt = Date.now();
      lastOverlayDismissedAtRef.current = dismissedAt;
      lastSaveOverlayDismissedAtRef.current = dismissedAt;
      setOverlay(null);
      overlayActiveRef.current = false;
    }
    if (saveCelebrationRef.current?.skipToCountdown?.()) {
      triggerPendingLevelCelebrate();
      return;
    }
    const hasPendingLevel = !!pendingLevelCelebrationRef.current;
    dismissOverlay({ clearQueue: hasPendingLevel ? false : true });
    triggerPendingLevelCelebrate();
  }, [
    dismissOverlay,
    lastCelebratedLevel,
    overlay,
    persistLastCelebratedLevel,
    playerLevel,
    runPendingLevelCelebration,
  ]);
  const assignableGoals = useMemo(
    () => (wishes || []).filter((wish) => wish.status !== "done"),
    [wishes]
  );
  const assignableGoalsCount = assignableGoals.length;
  const handlePrimaryTemptationOverlayAction = useCallback(
    async (type, sourceItem = null) => {
      const targetItem = sourceItem || primaryTemptationOverlayItem;
      if (!targetItem) return;
      let activePrimaryGoalId = null;
      if (typeof activeGoalId === "string" && activeGoalId.startsWith("wish_primary_goal_")) {
        activePrimaryGoalId = activeGoalId.replace("wish_primary_goal_", "");
      } else if (
        typeof activeGoalId === "string" &&
        Array.isArray(profile.primaryGoals) &&
        profile.primaryGoals.some((goal) => goal?.id === activeGoalId)
      ) {
        activePrimaryGoalId = activeGoalId;
      } else if (profile.goal) {
        activePrimaryGoalId = profile.goal;
      } else if (Array.isArray(profile.primaryGoals) && profile.primaryGoals[0]?.id) {
        activePrimaryGoalId = profile.primaryGoals[0].id;
      } else {
        activePrimaryGoalId = DEFAULT_PROFILE.goal;
      }
      const forcedGoalId =
        activePrimaryGoalId && !activePrimaryGoalId.startsWith("wish_primary_goal_")
          ? getPrimaryGoalWishId(activePrimaryGoalId)
          : activePrimaryGoalId;
      const actionOptions =
        type === "save"
          ? {
              skipPrompt: true,
              goalId: forcedGoalId,
              shouldAssign: true,
              forcePrimaryGoal: true,
              forceOverlay: true,
            }
          : {};
      dismissOverlay({ clearQueue: false });
      await new Promise((resolve) => {
        InteractionManager.runAfterInteractions(() => {
          setTimeout(resolve, 140);
        });
      });
      await handleTemptationAction(type, targetItem, actionOptions);
    },
    [
      activeGoalId,
      dismissOverlay,
      handleTemptationAction,
      primaryTemptationOverlayItem,
      profile.goal,
      profile.primaryGoals,
    ]
  );
  const hasPendingGoals = assignableGoalsCount > 0;
  const resolveTemptationGoalId = useCallback(
    (templateId) => {
      if (!templateId) return null;
      const assigned = temptationGoalMap[templateId];
      if (!assigned) return null;
      const assignedWish = wishes.find((wish) => wish.id === assigned);
      if (assignedWish && assignedWish.status !== "done") {
        return assignedWish.id;
      }
      return null;
    },
    [temptationGoalMap, wishes]
  );
  const getFallbackGoalId = useCallback(() => {
    if (assignableGoals.length > 0) return assignableGoals[0].id;
    return wishes[0]?.id || null;
  }, [assignableGoals, wishes]);
  const primaryTemptationOverlayItem = useMemo(() => {
    if (overlay?.type !== "primary_temptation") return null;
    const payload = overlay?.message;
    let templateId = null;
    if (payload && typeof payload === "object") {
      if (payload.templateId) {
        templateId = payload.templateId;
      } else if (payload.id) {
        templateId = payload.id;
      }
    } else if (typeof payload === "string") {
      templateId = payload;
    }
    const resolvedTemplateId = templateId || primaryTemptationId;
    const resolved = resolveTemplateCard(resolvedTemplateId);
    if (resolved) return resolved;
    if (profile.customSpend) {
      return createCustomHabitTemptation(
        profile.customSpend,
        profile.currency || DEFAULT_PROFILE.currency,
        profile.gender || "none"
      );
    }
    return null;
  }, [
    overlay,
    primaryTemptationId,
    profile.customSpend,
    profile.currency,
    profile.gender,
    resolveTemplateCard,
  ]);
  const primaryTemptationOverlayGoalLabel = useMemo(() => {
    if (!primaryTemptationOverlayItem) return null;
    const assignedGoalId = resolveTemptationGoalId(primaryTemptationOverlayItem.id);
    if (!assignedGoalId) return null;
    const assignedWish = (wishes || []).find((wish) => wish.id === assignedGoalId);
    return assignedWish ? getWishTitleWithoutEmoji(assignedWish) : null;
  }, [primaryTemptationOverlayItem, resolveTemptationGoalId, wishes]);
  const primaryTemptationOverlayStats = useMemo(
    () =>
      primaryTemptationOverlayItem ? resolveCardRefuseStats(primaryTemptationOverlayItem) : null,
    [primaryTemptationOverlayItem, resolveCardRefuseStats]
  );
  const primaryTemptationOverlayDescription = primaryTemptationOverlayItem
    ? descriptionOverrides[primaryTemptationOverlayItem.id] ||
      (primaryTemptationOverlayItem.id === primaryTemptationId ? primaryTemptationDescription : null)
    : null;
  const primaryTemptationOverlayTitle = primaryTemptationOverlayItem
    ? titleOverrides[primaryTemptationOverlayItem.id]
    : null;
  useEffect(() => {
    const activeGoalIds = new Set(
      (wishes || [])
        .filter((wish) => wish.status !== "done")
        .map((wish) => wish.id)
    );
    let changed = false;
    const nextMap = {};
    Object.entries(temptationGoalMap || {}).forEach(([templateId, goalId]) => {
      if (goalId && activeGoalIds.has(goalId)) {
        nextMap[templateId] = goalId;
      } else {
        changed = true;
      }
    });
    if (changed) {
      setTemptationGoalMap(nextMap);
    }
  }, [temptationGoalMap, wishes]);
  const syncPrimaryGoalProgress = useCallback(
    (goalId, savedUSD, status = "active") => {
      if (!goalId) return;
      const normalizedSaved = Number.isFinite(savedUSD) ? Math.max(savedUSD, 0) : 0;
      const fallbackTargetUSD =
        profile.goal === goalId &&
        Number.isFinite(profile.goalTargetUSD) &&
        profile.goalTargetUSD > 0
          ? profile.goalTargetUSD
          : getGoalDefaultTargetUSD(goalId);
      const updateEntry = (profileState = {}) => {
        const goals = Array.isArray(profileState.primaryGoals) ? profileState.primaryGoals : [];
        let changed = false;
        let hasMatch = false;
        const nextGoals = goals.map((entry) => {
          if (entry.id !== goalId) return entry;
          hasMatch = true;
          const nextEntry = { ...entry };
          if (nextEntry.savedUSD !== normalizedSaved) {
            nextEntry.savedUSD = normalizedSaved;
            changed = true;
          }
          if (status && nextEntry.status !== status) {
            nextEntry.status = status;
            changed = true;
          }
          return nextEntry;
        });
        if (!hasMatch) {
          const primaryWish =
            Array.isArray(wishesRef.current) &&
            wishesRef.current.find(
              (wish) =>
                wish?.kind === PRIMARY_GOAL_KIND &&
                (wish.goalId === goalId || wish.id === getPrimaryGoalWishId(goalId))
            );
          const targetUSD =
            primaryWish && Number.isFinite(primaryWish.targetUSD) && primaryWish.targetUSD > 0
              ? primaryWish.targetUSD
              : fallbackTargetUSD;
          nextGoals.unshift({
            id: goalId,
            targetUSD,
            savedUSD: normalizedSaved,
            status: status || "active",
            createdAt: primaryWish?.createdAt || Date.now(),
          });
          changed = true;
        }
        return changed ? { ...profileState, primaryGoals: nextGoals } : profileState;
      };
      setProfile((prev) => updateEntry(prev));
      setProfileDraft((prev) => updateEntry(prev));
      setWishes((prev) => {
        const targetWishId = getPrimaryGoalWishId(goalId);
        let changed = false;
        const next = prev.map((wish) => {
          if (!wish) return wish;
          if (wish.id !== targetWishId && wish.goalId !== goalId) return wish;
          const updated = { ...wish };
          if (updated.savedUSD !== normalizedSaved) {
            updated.savedUSD = normalizedSaved;
            changed = true;
          }
          if (status && updated.status !== status) {
            updated.status = status;
            changed = true;
          }
          if (updated.goalId !== goalId) {
            updated.goalId = goalId;
            changed = true;
          }
          if (updated.kind !== PRIMARY_GOAL_KIND) {
            updated.kind = PRIMARY_GOAL_KIND;
            changed = true;
          }
          return updated;
        });
        if (!next.some((wish) => wish?.id === targetWishId)) {
          return next;
        }
        return changed ? next : prev;
      });
    },
    [language, profile.goal, profile.goalTargetUSD, setProfile, setProfileDraft, setWishes]
  );

  const assignTemptationGoal = useCallback(
    (templateId, wishId = null) => {
      if (!templateId) return;
      setTemptationGoalMap((prev) => {
        const currentAssignment = prev[templateId];
        if (wishId && currentAssignment === wishId) {
          return prev;
        }
        if (!wishId && !currentAssignment) {
          return prev;
        }
        const next = { ...prev };
        if (wishId) {
          next[templateId] = wishId;
        } else {
          delete next[templateId];
        }
        return next;
      });
    },
    []
  );

  const applySavingsToWish = useCallback(
    (wishId, amountUSD) => {
      if (!wishId || !Number.isFinite(amountUSD) || amountUSD <= 0) return 0;
      let applied = 0;
      let goalSyncMeta = null;
      let completedGoalMeta = null;
      const normalizedGoalId =
        typeof wishId === "string" && wishId.startsWith("wish_primary_goal_")
          ? wishId.replace("wish_primary_goal_", "")
          : null;
      const buildPrimaryGoalWishFromId = (targetWishId) => {
        if (!targetWishId || typeof targetWishId !== "string") return null;
        if (!targetWishId.startsWith("wish_primary_goal_")) return null;
        const goalId = targetWishId.replace("wish_primary_goal_", "");
        const primaryEntries = Array.isArray(profile.primaryGoals) ? profile.primaryGoals : [];
        const primaryEntry = primaryEntries.find((entry) => entry?.id === goalId);
        const canFallbackToProfileGoal = profile.goal === goalId;
        if (!primaryEntry && !canFallbackToProfileGoal) return null;
        const fallbackTargetUSD =
          profile.goal === goalId &&
          Number.isFinite(profile.goalTargetUSD) &&
          profile.goalTargetUSD > 0
            ? profile.goalTargetUSD
            : getGoalDefaultTargetUSD(goalId);
        const ensuredEntry =
          primaryEntry || {
            id: goalId,
            targetUSD: fallbackTargetUSD,
            savedUSD: 0,
            status: "active",
            createdAt: Date.now(),
          };
        const goalPreset = getGoalPreset(goalId);
        const languageKey = language || "en";
        const customTitle =
          typeof ensuredEntry?.customTitle === "string" ? ensuredEntry.customTitle.trim() : "";
        const hasCustomTitle = !!customTitle;
        const customEmoji = ensuredEntry?.customEmoji
          ? normalizeEmojiValue(ensuredEntry.customEmoji, DEFAULT_GOAL_EMOJI)
          : null;
        const resolvedEmoji =
          hasCustomTitle ? customEmoji || DEFAULT_GOAL_EMOJI : goalPreset?.emoji || DEFAULT_GOAL_EMOJI;
        const presetLabel = goalPreset?.[languageKey] || goalPreset?.en || goalId;
        const resolvedLabel = hasCustomTitle ? customTitle : presetLabel || goalId;
        const title = `${resolvedEmoji} ${resolvedLabel}`.trim();
        const targetUSD =
          Number.isFinite(ensuredEntry?.targetUSD) && ensuredEntry.targetUSD > 0
            ? ensuredEntry.targetUSD
            : getGoalDefaultTargetUSD(goalId);
        const createdAt = ensuredEntry?.createdAt || Date.now();
        return {
          id: targetWishId,
          templateId: `goal_${goalId}`,
          title,
          emoji: resolvedEmoji,
          targetUSD,
          savedUSD: 0,
          status: "active",
          createdAt,
          autoManaged: true,
          kind: PRIMARY_GOAL_KIND,
          goalId,
        };
      };
      setWishes((prev) => {
        let changed = false;
        let found = false;
        const next = prev.map((wish) => {
          const isMatchById = wish.id === wishId;
          const isMatchByGoal =
            normalizedGoalId &&
            (wish.goalId === normalizedGoalId ||
              (wish.kind === PRIMARY_GOAL_KIND && wish.id === PRIMARY_GOAL_WISH_ID_LEGACY));
          if (!isMatchById && !isMatchByGoal) return wish;
          found = true;
          const current = wish.savedUSD || 0;
          const target = wish.targetUSD || 0;
          const desired = current + amountUSD;
          const capTarget = target > 0 ? target : Number.POSITIVE_INFINITY;
          const nextSaved = Math.min(desired, capTarget);
          applied = nextSaved - current;
          const status = target > 0 && nextSaved >= target ? "done" : "active";
          const becameDone = status === "done" && wish.status !== "done";
          const hasPrimaryWishId =
            typeof wish.id === "string" && wish.id.startsWith("wish_primary_goal_");
          const derivedGoalId =
            wish.goalId || (hasPrimaryWishId ? wish.id.replace("wish_primary_goal_", "") : null);
          if (
            nextSaved !== current ||
            wish.status !== status ||
            wish.autoManaged !== false ||
            (!!derivedGoalId && derivedGoalId !== wish.goalId) ||
            (hasPrimaryWishId && wish.kind !== PRIMARY_GOAL_KIND)
          ) {
            changed = true;
            if (derivedGoalId) {
              goalSyncMeta = { goalId: derivedGoalId, savedUSD: nextSaved, status };
            }
          if (becameDone) {
            completedGoalMeta = {
              goalId: wish.goalId || wish.id,
              wishId: wish.id,
              templateId: wish.templateId || null,
              targetUSD: target,
              createdAt: wish.createdAt || wish.metaCreatedAt || null,
            };
          }
            const updatedWish = {
              ...wish,
              savedUSD: nextSaved,
              status,
              autoManaged: false,
              ...(derivedGoalId ? { goalId: derivedGoalId } : {}),
              ...(hasPrimaryWishId ? { kind: PRIMARY_GOAL_KIND } : {}),
            };
            if (__DEV__ && wishId.startsWith("wish_primary_goal_")) {
              console.warn("primary_temptation_goal_update", {
                wishId,
                current,
                nextSaved,
                targetUSD: target,
                applied,
              });
            }
            return updatedWish;
          }
          return wish;
        });
        if (!found) {
          const created = buildPrimaryGoalWishFromId(wishId);
          if (created) {
            const target = created.targetUSD || 0;
            const capTarget = target > 0 ? target : Number.POSITIVE_INFINITY;
            const nextSaved = Math.min(Math.max(amountUSD, 0), capTarget);
            applied = nextSaved;
            const status = target > 0 && nextSaved >= target ? "done" : "active";
            const becameDone = status === "done";
            const nextCreated = {
              ...created,
              savedUSD: nextSaved,
              status,
            };
            if (__DEV__ && wishId.startsWith("wish_primary_goal_")) {
              console.warn("primary_temptation_goal_created", {
                wishId,
                nextSaved,
                targetUSD: target,
                applied,
              });
            }
            changed = true;
            if (nextCreated.kind === PRIMARY_GOAL_KIND && nextCreated.goalId) {
              goalSyncMeta = {
                goalId: nextCreated.goalId,
                savedUSD: nextSaved,
                status,
              };
            }
            if (becameDone) {
              completedGoalMeta = {
                goalId: nextCreated.goalId || nextCreated.id,
                wishId: nextCreated.id,
                templateId: nextCreated.templateId || null,
                targetUSD: target,
                createdAt: nextCreated.createdAt || null,
              };
            }
            return [nextCreated, ...prev];
          }
        }
        if (__DEV__ && (wishId.startsWith("wish_primary_goal_") || normalizedGoalId)) {
          const trackedWish =
            next.find((w) => w?.id === wishId) ||
            (normalizedGoalId
              ? next.find((w) => w?.goalId === normalizedGoalId || w?.id === PRIMARY_GOAL_WISH_ID_LEGACY)
              : null);
          if (trackedWish) {
            console.warn("primary_temptation_goal_state", {
              wishId,
              goalId: normalizedGoalId,
              savedUSD: trackedWish.savedUSD,
              targetUSD: trackedWish.targetUSD,
              status: trackedWish.status,
            });
          } else {
            console.warn("primary_temptation_goal_state", {
              wishId,
              goalId: normalizedGoalId,
              savedUSD: null,
              targetUSD: null,
              status: null,
              note: "not found in wishes",
            });
          }
        }
        return changed ? next : prev;
      });
      if (goalSyncMeta) {
        syncPrimaryGoalProgress(goalSyncMeta.goalId, goalSyncMeta.savedUSD, goalSyncMeta.status);
      }
      if (completedGoalMeta) {
        const targetAmountLocal = convertToCurrency(
          completedGoalMeta.targetUSD || 0,
          profile.currency || DEFAULT_PROFILE.currency
        );
        let daysToComplete = null;
        if (completedGoalMeta.createdAt) {
          const createdAtTs = new Date(completedGoalMeta.createdAt).getTime();
          if (Number.isFinite(createdAtTs)) {
            daysToComplete = Math.max(1, Math.round((Date.now() - createdAtTs) / DAY_MS));
          }
        }
        logEvent("goal_completed", {
          goal_id: completedGoalMeta.goalId,
          target_amount: targetAmountLocal,
          days_to_complete: daysToComplete,
        });
      }
      return applied;
    },
    [
      language,
      logEvent,
      profile.currency,
      profile.goal,
      profile.goalTargetUSD,
      profile.primaryGoals,
      syncPrimaryGoalProgress,
    ]
  );
  const getWishTitleById = useCallback(
    (wishId) => wishes.find((wish) => wish.id === wishId)?.title || "",
    [wishes]
  );
  const goalSelectionList = useMemo(
    () => (assignableGoals.length > 0 ? assignableGoals : wishes),
    [assignableGoals, wishes]
  );
  const currentGoalTitle = useMemo(() => {
    if (saveOverlayPayload?.goalTitle) {
      return saveOverlayPayload.goalTitle;
    }
    if (assignableGoals.length > 0) {
      const primaryGoal = assignableGoals[0];
      const baseTitle =
        (primaryGoal && getWishTitleWithoutEmoji(primaryGoal)) ||
        getWishTitleById(assignableGoals[0].id);
      return (baseTitle || "").trim();
    }
    return null;
  }, [assignableGoals, getWishTitleById, saveOverlayPayload]);
  const saveOverlayGoalText =
    currentGoalTitle && saveOverlayPayload?.goalComplete
      ? t("saveGoalComplete", { goal: currentGoalTitle })
      : currentGoalTitle;
  const saveOverlayGoalPrefix =
    currentGoalTitle &&
    !saveOverlayPayload?.goalComplete &&
    Number.isFinite(saveOverlayPayload?.remainingTemptations) &&
    saveOverlayPayload?.remainingTemptations > 0
      ? t("saveGoalRemaining")
      : null;
  const maxTemptationStreak = useMemo(() => {
    const entries = Object.values(refuseStats || {});
    if (!entries.length) return 0;
    return entries.reduce((max, entry) => {
      const best = Number(entry?.bestStreak) || 0;
      const current = Number(entry?.currentStreak) || 0;
      return Math.max(max, best, current);
    }, 0);
  }, [refuseStats]);
  const achievements = useMemo(() => {
    const built = buildAchievements({
      savedTotalUSD,
      declineCount,
      freeDayStats,
      declineStreak,
      refuseStreak: maxTemptationStreak,
      pendingCount: pendingList.length,
      decisionStats,
      currency: profile.currency || DEFAULT_PROFILE.currency,
      t,
      language,
    });
    const normalizedList = Array.isArray(built) ? built.filter(Boolean) : [];
    return normalizedList.map((reward) => ({
      ...reward,
      claimed: !!safeClaimedRewards[reward.id],
    }));
  }, [
    savedTotalUSD,
    declineCount,
    freeDayStats,
    pendingList.length,
    decisionStats,
    profile.currency,
    t,
    language,
    maxTemptationStreak,
    safeClaimedRewards,
  ]);


  const challengeList = useMemo(
    () =>
      buildChallengesDisplay({
        state: challengesState,
        currency: profile.currency || DEFAULT_PROFILE.currency,
        language,
        t,
        maxActiveChallenges: MAX_ACTIVE_CHALLENGES,
        averageSaveActionUSD,
        playerLevel,
      }),
    [challengesState, profile.currency, language, t, averageSaveActionUSD, playerLevel]
  );
  const challengeBadgeEmojis = useMemo(
    () =>
      challengeList
        .filter(
          (challenge) =>
            challenge.status === CHALLENGE_STATUS.COMPLETED || challenge.status === CHALLENGE_STATUS.CLAIMED
        )
        .map((challenge) => challenge.emoji)
        .filter(Boolean),
    [challengeList]
  );
  const challengeBadgeCount = challengeBadgeEmojis.length;
  const activeChallenge = useMemo(() => {
    const activeChallenges = challengeList.filter(
      (challenge) => challenge.status === CHALLENGE_STATUS.ACTIVE
    );
    if (!activeChallenges.length) return null;
    return activeChallenges.reduce((best, current) => {
      if (!best) return current;
      if ((current.progressPercent || 0) > (best.progressPercent || 0)) return current;
      if ((current.progressPercent || 0) < (best.progressPercent || 0)) return best;
      return (current.progressValue || 0) >= (best.progressValue || 0) ? current : best;
    }, null);
  }, [challengeList]);
  const rewardsBadgeCount = useMemo(() => {
    if (!rewardsReady || !rewardsUnlocked) return 0;
    return achievements.filter((reward) => reward.unlocked && !reward.claimed).length;
  }, [achievements, rewardsReady, rewardsUnlocked]);
  const challengeRewardsBadgeCount = useMemo(() => {
    if (!rewardsReady || !challengesUnlocked) return 0;
    return challengeList.filter((challenge) => challenge.canClaim).length;
  }, [challengeList, rewardsReady, challengesUnlocked]);
  const activeDailyChallenge = useMemo(() => {
    if (dailyChallenge.status !== DAILY_CHALLENGE_STATUS.ACTIVE) return null;
    const targetValue = dailyChallenge.target || 1;
    return {
      id: dailyChallenge.id,
      emoji: dailyChallengeTemplate?.emoji || dailyChallenge.emoji || "âœ¨",
      title: dailyChallengeDisplayTitle,
      rewardBonus: dailyChallengeRewardBonus || ECONOMY_RULES.minSaveReward,
      progress: Math.min(dailyChallenge.progress || 0, targetValue),
      target: targetValue,
    };
  }, [
    dailyChallenge,
    dailyChallengeDisplayTitle,
    dailyChallengeRewardBonus,
    dailyChallengeTemplate,
  ]);
  const resolvedDailyChallenge = dailyChallengeUnlocked ? activeDailyChallenge : null;

  const profileStats = useMemo(() => {
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const totalSavedConverted = formatCurrency(
      convertToCurrency(savedTotalUSD, currencyCode),
      currencyCode
    );
    const spendCount = purchases.length;
    return [
      { label: t("statsSaved"), value: totalSavedConverted },
      { label: t("statsDeclines"), value: `${declineCount}` },
      { label: t("statsSpends"), value: `${spendCount}` },
      { label: t("statsFreeDays"), value: `${freeDayStats.current}`, suffix: "ðŸ”¥" },
    ];
  }, [savedTotalUSD, declineCount, freeDayStats.current, purchases.length, t, profile.currency]);

  const analyticsStats = useMemo(
    () => [
      { label: t("analyticsPendingToBuy"), value: `${wishes.length}` },
      { label: t("analyticsPendingToDecline"), value: `${declineCount}` },
      { label: t("analyticsFridgeCount"), value: `${purchases.length}` },
    ],
    [wishes.length, declineCount, purchases.length, t]
  );
  const impulseInsights = useMemo(() => {
    const raw = buildImpulseInsights(impulseTracker.events);
    if (!raw) return raw;
    const resolveTitle = (templateId, fallbackTitle) => {
      if (!templateId) return fallbackTitle || "";
      const template = resolveTemplateCard(templateId);
      if (!template) return fallbackTitle || "";
      return (
        resolveTemptationTitle(template, language, titleOverrides[template.id]) ||
        fallbackTitle ||
        ""
      );
    };
    const resolveEmoji = (templateId, fallbackEmoji) => {
      if (!templateId) return fallbackEmoji || "";
      const template = resolveTemplateCard(templateId);
      return template?.emoji || fallbackEmoji || "";
    };
    const resolveAmountUSD = (templateId, fallbackAmount) => {
      if (!templateId) return fallbackAmount;
      const template = resolveTemplateCard(templateId);
      const price = template ? getTemptationPrice(template) : null;
      return Number.isFinite(price) && price > 0 ? price : fallbackAmount;
    };
    const resolveHotItem = (item) => {
      if (!item) return null;
      return {
        ...item,
        title: resolveTitle(item.templateId, item.title),
        emoji: resolveEmoji(item.templateId, item.emoji),
      };
    };
    const resolveSequence = (entry) => {
      if (!entry) return null;
      return {
        ...entry,
        fromTitle: resolveTitle(entry.fromTemplateId, entry.fromTitle),
        toTitle: resolveTitle(entry.toTemplateId, entry.toTitle),
      };
    };
    const activeRisk = raw.activeRisk
      ? {
          ...raw.activeRisk,
          title: resolveTitle(raw.activeRisk.templateId, raw.activeRisk.title),
          emoji: resolveEmoji(raw.activeRisk.templateId, raw.activeRisk.emoji),
          amountUSD: resolveAmountUSD(raw.activeRisk.templateId, raw.activeRisk.amountUSD),
        }
      : null;
    return {
      ...raw,
      hotLose: resolveHotItem(raw.hotLose),
      hotWin: resolveHotItem(raw.hotWin),
      activeRisk,
      sequenceHotspots: {
        slip: resolveSequence(raw.sequenceHotspots?.slip),
        rebound: resolveSequence(raw.sequenceHotspots?.rebound),
      },
    };
  }, [impulseTracker.events, language, resolveTemplateCard, titleOverrides]);
  const focusRecentSpends = useMemo(() => {
    const now = Date.now();
    const cutoff = now - FOCUS_RECENT_WINDOW_MS;
    const recent = [];
    (impulseTracker.events || []).forEach((event) => {
      if (!event || event.action !== "spend" || !event.templateId) return;
      const timestamp = Number(event.timestamp);
      if (!Number.isFinite(timestamp) || timestamp < cutoff) return;
      const rawAmount = Number(event.amountUSD) || 0;
      const template = resolveTemplateCard(event.templateId);
      const templateAmount = Number(template?.priceUSD || template?.basePriceUSD || 0);
      const amountUSD = rawAmount > 0 ? rawAmount : templateAmount;
      if (!amountUSD) return;
      recent.push({
        templateId: event.templateId,
        amountUSD,
        timestamp,
        eventTitle: event.title,
        eventEmoji: event.emoji,
      });
    });
    if (!recent.length) return [];
    const resolved = recent.map((entry) => {
      const template = resolveTemplateCard(entry.templateId);
      const templateLabel =
        (typeof template?.title === "string"
          ? template.title
          : template?.title?.[language] || template?.title?.en || template?.title?.ru || "") || "";
      const resolvedTitle =
        resolveTemplateTitle(entry.templateId, templateLabel) ||
        templateLabel ||
        entry.eventTitle ||
        t("defaultDealTitle");
      const resolvedEmoji = template?.emoji || entry.eventEmoji || "âœ¨";
      return { ...entry, title: resolvedTitle, emoji: resolvedEmoji };
    });
    resolved.sort((a, b) => {
      if (b.amountUSD !== a.amountUSD) return b.amountUSD - a.amountUSD;
      return (b.timestamp || 0) - (a.timestamp || 0);
    });
    return resolved;
  }, [impulseTracker.events, language, resolveTemplateCard, resolveTemplateTitle, t]);
  const dailyChallengePressure = useMemo(() => {
    const cutoff = Date.now() - DAILY_CHALLENGE_LOOKBACK_MS;
    const recentEvents = (impulseTracker.events || []).filter((event) => {
      const timestamp = Number(event?.timestamp);
      return Number.isFinite(timestamp) && timestamp >= cutoff;
    });
    return buildTemptationPressureMap(recentEvents);
  }, [impulseTracker.events, todayKey]);

  useEffect(() => {
    if (!impulseFeaturesUnlocked) return;
    if (!impulseInsights.activeRisk) return;
    notifyImpulseRisk(impulseInsights.activeRisk);
  }, [impulseFeaturesUnlocked, impulseInsights.activeRisk, notifyImpulseRisk]);
  useEffect(() => {
    if (!focusDigestHydrated) return;
    if (!focusModeUnlocked) return;
    const todayKey = getDayKey(Date.now());
    if (focusDigestSeenKey === todayKey) return;
    if (pendingFocusDigest?.dateKey === todayKey) return;
    if (!impulseInsights || (impulseInsights.eventCount || 0) < 1) return;
    if (!purchases.length) return;
    if (!focusRecentSpends.length) return;
    const strong = impulseInsights.hotWin || null;
    const weak = strong?.templateId
      ? focusRecentSpends.find((entry) => entry.templateId !== strong.templateId) || null
      : focusRecentSpends[0] || null;
    if (!weak) return;
    const positive =
      !!strong && (impulseInsights.totalSpendCount || 0) <= (impulseInsights.totalSaveCount || 0);
    const strongTitle = strong?.title || t("focusDigestMissing");
    const weakTitle = weak?.title || t("focusDigestMissing");
    const payload = {
      title: positive ? t("focusDigestPositiveTitle") : t("focusDigestNegativeTitle"),
      body: positive
        ? t("focusDigestPositiveBody", { strong: strongTitle, weak: weakTitle })
        : t("focusDigestNegativeBody", { weak: weakTitle }),
      strong,
      weak,
      positive,
      targetId: weak?.templateId || strong?.templateId || null,
    };
    setPendingFocusDigest({ dateKey: todayKey, payload });
    setFocusDigestPromptShown(false);
  }, [
    focusDigestHydrated,
    focusDigestSeenKey,
    focusModeUnlocked,
    focusRecentSpends,
    impulseInsights,
    pendingFocusDigest,
    purchases.length,
    t,
  ]);

  useEffect(() => {
    if (!pendingFocusDigest) return;
    if (focusDigestPromptShown) return;
    if (!focusModeUnlocked) return;
    enqueueQueuedModal(QUEUED_MODAL_TYPES.FOCUS_DIGEST);
  }, [
    enqueueQueuedModal,
    focusModeUnlocked,
    pendingFocusDigest,
    focusDigestPromptShown,
  ]);
  useEffect(() => {
    if (queuedModalType !== QUEUED_MODAL_TYPES.FOCUS_DIGEST) return;
    if (!pendingFocusDigest || !focusModeUnlocked) {
      clearQueuedModal(QUEUED_MODAL_TYPES.FOCUS_DIGEST);
      return;
    }
    triggerOverlayState("focus_digest", pendingFocusDigest.payload);
    setFocusDigestPromptShown(true);
  }, [
    clearQueuedModal,
    focusModeUnlocked,
    pendingFocusDigest,
    queuedModalType,
    triggerOverlayState,
  ]);
  useEffect(() => {
    if (focusModeUnlocked) return;
    setPendingFocusDigest(null);
    setFocusDigestPromptShown(false);
  }, [focusModeUnlocked]);
  useEffect(() => {
    if (!dailyChallengeHydrated) return;
    if (!dailyChallengeUnlocked) return;
    const resolvedTodayKey = todayKey || getDayKey(Date.now());
    if (dailyChallenge.dateKey === resolvedTodayKey && dailyChallenge.templateId) return;
    const targetId = resolveDailyChallengeTemplateId(dailyChallengePressure, 1, (templateId) => {
      const template = resolveTemplateCard(templateId);
      if (!template) return false;
      const rawTitle =
        template.titleOverride ||
        (typeof template.title === "string"
          ? template.title
          : template.title?.[language] || template.title?.en || template.title?.ru || template.title);
      return typeof rawTitle === "string" && rawTitle.trim().length > 0;
    });
    if (!targetId) {
      setDailyChallenge((prev) => ({
        ...createInitialDailyChallengeState(),
        dateKey: resolvedTodayKey,
        status: DAILY_CHALLENGE_STATUS.IDLE,
      }));
      return;
    }
    const template = resolveTemplateCard(targetId);
    const priceUSD = template?.priceUSD || template?.basePriceUSD || 0;
    const templateLabel =
      (typeof template?.title === "string"
        ? template.title
        : template?.title?.[language] || template?.title?.en || template?.title?.ru || "") || "";
    const templateTitle = resolveTemplateTitle(targetId, templateLabel) || templateLabel;
    const baseReward = computeRefuseCoinReward(priceUSD, profile.currency || DEFAULT_PROFILE.currency);
    const rewardBonus = computeDailyChallengeBonus(priceUSD, profile.currency || DEFAULT_PROFILE.currency);
    setDailyChallenge({
      ...createInitialDailyChallengeState(),
      id: `daily-${resolvedTodayKey}-${targetId}`,
      dateKey: resolvedTodayKey,
      templateId: targetId,
      templateTitle,
      templateLabel,
      emoji: template?.emoji || "âœ¨",
      priceUSD,
      baseReward,
      rewardBonus,
      status: DAILY_CHALLENGE_STATUS.OFFER,
      offerDismissed: false,
    });
  }, [
    dailyChallenge.dateKey,
    dailyChallenge.templateId,
    dailyChallengeHydrated,
    language,
    dailyChallengePressure,
    profile.currency,
    resolveTemplateCard,
    resolveTemplateTitle,
    todayKey,
  ]);
  useEffect(() => {
    if (!dailyChallengeHydrated) return;
    if (!historyHydrated) return;
    if (dailyChallengeUnlocked) return;
    if (
      dailyChallenge.status === DAILY_CHALLENGE_STATUS.IDLE &&
      !dailyChallenge.templateId
    ) {
      return;
    }
    setDailyChallenge(createInitialDailyChallengeState());
  }, [
    dailyChallenge.status,
    dailyChallenge.templateId,
    dailyChallengeHydrated,
    dailyChallengeUnlocked,
    historyHydrated,
  ]);
  const handleDailyChallengeAccept = useCallback(() => {
    if (!dailyChallengeUnlocked) return;
    if (!dailyChallenge.templateId) return;
    setDailyChallenge((prev) => {
      if (!prev || prev.status !== DAILY_CHALLENGE_STATUS.OFFER) return prev;
      return {
        ...prev,
        status: DAILY_CHALLENGE_STATUS.ACTIVE,
        acceptedAt: Date.now(),
        offerDismissed: true,
      };
    });
    clearQueuedModal(QUEUED_MODAL_TYPES.DAILY_CHALLENGE);
    logEvent("daily_challenge_accepted", { template_id: dailyChallenge.templateId });
  }, [clearQueuedModal, dailyChallenge.templateId, dailyChallengeUnlocked, logEvent]);
  const handleDailyChallengeLater = useCallback(() => {
    if (!dailyChallengeUnlocked) return;
    setDailyChallenge((prev) => {
      if (!prev || prev.offerDismissed) return prev || createInitialDailyChallengeState();
      return { ...prev, offerDismissed: true };
    });
    clearQueuedModal(QUEUED_MODAL_TYPES.DAILY_CHALLENGE);
  }, [clearQueuedModal, dailyChallengeUnlocked]);
  const completeDailyChallenge = useCallback(() => {
    if (!dailyChallengeUnlocked) return;
    if (!dailyChallenge.templateId) return;
    const rewardBonus = dailyChallengeRewardBonus || 0;
    setDailyChallenge((prev) => {
      if (!prev || prev.status !== DAILY_CHALLENGE_STATUS.ACTIVE) return prev;
      return {
        ...prev,
        status: DAILY_CHALLENGE_STATUS.COMPLETED,
        progress: prev.target,
        completedAt: Date.now(),
        rewardGranted: true,
        rewardBonus,
      };
    });
    if (rewardBonus > 0) {
      setHealthPoints((coins) => coins + rewardBonus);
      if (queueCelebrationOverlayRef.current) {
        queueCelebrationOverlayRef.current("health", {
          amount: rewardBonus,
          reason: t("dailyChallengeRewardReason", {
            temptation: dailyChallengeDisplayTitle,
          }),
        });
      }
      playSound("reward");
    }
    sendImmediateNotification({
      title: t("dailyChallengeRewardNotificationTitle"),
      body: t("dailyChallengeRewardNotificationBody", {
        temptation: dailyChallengeDisplayTitle || t("defaultDealTitle"),
        amount: dailyChallengeRewardLabel,
      }),
    });
    logEvent("daily_challenge_completed", {
      template_id: dailyChallenge.templateId,
      reward_bonus: rewardBonus,
    });
  }, [
    dailyChallengeUnlocked,
    dailyChallengeDisplayTitle,
    dailyChallengeRewardBonus,
    dailyChallenge.templateId,
    dailyChallengeRewardLabel,
    sendImmediateNotification,
    logEvent,
    playSound,
    setHealthPoints,
    t,
  ]);
  const failDailyChallenge = useCallback(() => {
    if (!dailyChallengeUnlocked) return;
    if (!dailyChallenge.templateId) return;
    setDailyChallenge((prev) => {
      if (!prev || prev.status !== DAILY_CHALLENGE_STATUS.ACTIVE) return prev;
      return {
        ...prev,
        status: DAILY_CHALLENGE_STATUS.FAILED,
        failedAt: Date.now(),
      };
    });
    triggerOverlayState(
      "cancel",
      t("dailyChallengeFailedText", { temptation: dailyChallengeDisplayTitle })
    );
    logEvent("daily_challenge_failed", { template_id: dailyChallenge.templateId });
  }, [
    dailyChallengeUnlocked,
    dailyChallenge.templateId,
    dailyChallengeDisplayTitle,
    logEvent,
    t,
    triggerOverlayState,
  ]);
  useEffect(() => {
    if (!dailyChallengeHydrated) return;
    if (!dailyChallengeUnlocked) return;
    if (dailyChallenge.status !== DAILY_CHALLENGE_STATUS.ACTIVE) return;
    if (!dailyChallenge.templateId || !dailyChallenge.dateKey) return;
    const acceptedAt = dailyChallenge.acceptedAt || 0;
    const hasRefuse = resolvedHistoryEvents.some((entry) => {
      if (entry.kind !== "refuse_spend") return false;
      if (entry.meta?.templateId !== dailyChallenge.templateId) return false;
      if (getDayKey(entry.timestamp) !== dailyChallenge.dateKey) return false;
      if (acceptedAt && entry.timestamp < acceptedAt) return false;
      return true;
    });
    if (hasRefuse) {
      completeDailyChallenge();
    }
  }, [
    completeDailyChallenge,
    dailyChallengeUnlocked,
    dailyChallenge.acceptedAt,
    dailyChallenge.dateKey,
    dailyChallenge.status,
    dailyChallenge.templateId,
    dailyChallengeHydrated,
    resolvedHistoryEvents,
  ]);
  useEffect(() => {
    if (!dailyChallengeHydrated) return;
    if (!dailyChallengeUnlocked) return;
    if (dailyChallenge.status !== DAILY_CHALLENGE_STATUS.ACTIVE) return;
    if (!dailyChallenge.templateId || !dailyChallenge.dateKey) return;
    const acceptedAt = dailyChallenge.acceptedAt || 0;
    const lost = (impulseTracker.events || []).some((event) => {
      if (event.action !== "spend") return false;
      if (event.templateId !== dailyChallenge.templateId) return false;
      if (getDayKey(event.timestamp) !== dailyChallenge.dateKey) return false;
      if (acceptedAt && event.timestamp < acceptedAt) return false;
      return true;
    });
    if (lost) {
      failDailyChallenge();
    }
  }, [
    dailyChallenge.acceptedAt,
    dailyChallenge.dateKey,
    dailyChallenge.status,
    dailyChallenge.templateId,
    dailyChallengeHydrated,
    dailyChallengeUnlocked,
    failDailyChallenge,
    impulseTracker.events,
  ]);

  const persistCustomReminderId = useCallback(
    (id) => {
      setCustomReminderId(id);
      if (id) {
        AsyncStorage.setItem(STORAGE_KEYS.CUSTOM_REMINDER, id).catch(() => {});
      } else {
        AsyncStorage.removeItem(STORAGE_KEYS.CUSTOM_REMINDER).catch(() => {});
      }
    },
    []
  );

  const schedulePersonalTemptationReminder = useCallback(
    async (customSpend) => {
      if (
        !customSpend?.title ||
        !Number.isFinite(customSpend.frequencyPerWeek) ||
        customSpend.frequencyPerWeek <= 0
      ) {
        if (customReminderId) {
          Notifications.cancelScheduledNotificationAsync(customReminderId).catch(() => {});
          persistCustomReminderId(null);
        }
        return;
      }
      const permitted = await ensureNotificationPermission({ request: false });
      if (!permitted) return;
      if (customReminderId) {
        await Notifications.cancelScheduledNotificationAsync(customReminderId).catch(() => {});
      }
      const frequency = Math.max(1, customSpend.frequencyPerWeek);
      const intervalDays = Math.max(1, Math.round(7 / frequency));
      const seconds = Math.max(6 * 60 * 60, intervalDays * 24 * 60 * 60);
      const title = tVariant("smartReminderTitle", { temptation: customSpend.title });
      const body = tVariant("smartReminderBody", { temptation: customSpend.title });
      try {
        const scheduled = await scheduleNotificationWithCooldown({
          content: { title, body },
          trigger: { seconds, repeats: true },
        });
        persistCustomReminderId(scheduled?.id || null);
      } catch (error) {
        console.warn("custom reminder", error);
        persistCustomReminderId(null);
      }
    },
    [customReminderId, ensureNotificationPermission, persistCustomReminderId, scheduleNotificationWithCooldown, tVariant]
  );
  const clearLegacyDailyNudges = useCallback(async () => {
    try {
      const scheduled = await Notifications.getAllScheduledNotificationsAsync();
      if (!Array.isArray(scheduled) || !scheduled.length) return;
      const identifiers = scheduled
        .filter((entry) => isKnownDailyNudgeNotification(entry?.content))
        .map((entry) => entry?.identifier)
        .filter(Boolean);
      if (!identifiers.length) return;
      await Promise.all(
        identifiers.map((id) =>
          Notifications.cancelScheduledNotificationAsync(id).catch(() => {})
        )
      );
    } catch (error) {
      console.warn("daily nudge cleanup", error);
    }
  }, []);

  const rescheduleDailyNudgeNotifications = useCallback(async () => {
    if (!dailyNudgesHydrated || !DAILY_NUDGE_REMINDERS.length) return;
    const signatureVersion = "v1";
    const signaturePayload = {
      version: signatureVersion,
      language,
      reminders: DAILY_NUDGE_REMINDERS.map((def) => ({
        id: def.id,
        hour: def.hour,
        minute: def.minute,
        titleKey: def.titleKey,
        bodyKey: def.bodyKey,
      })),
    };
    const signature = JSON.stringify(signaturePayload);
    const existingIds = Object.values(dailyNudgeIdsRef.current || {}).filter(Boolean);
    const storedSignature = await AsyncStorage.getItem(
      STORAGE_KEYS.DAILY_NUDGE_SCHEDULE_SIGNATURE
    ).catch(() => null);
    if (storedSignature === signature && existingIds.length) {
      return;
    }
    const permitted = await ensureNotificationPermission({ request: false });
    if (!permitted) return;
    const existing = Object.values(dailyNudgeIdsRef.current || {});
    if (existing.length) {
      await Promise.all(
        existing.map((notificationId) =>
          Notifications.cancelScheduledNotificationAsync(notificationId).catch(() => {})
        )
      );
    }
    await clearLegacyDailyNudges();
    const nextMap = {};
    for (const def of DAILY_NUDGE_REMINDERS) {
      try {
        const trigger = buildDailyNudgeTrigger(def.hour, def.minute);
        if (!trigger) continue;
        const scheduledEntry = await scheduleNotificationWithCooldown({
          content: {
            title: tVariant(def.titleKey),
            body: tVariant(def.bodyKey),
            data: { type: DAILY_NUDGE_NOTIFICATION_TAG, locale: language },
            ...(Platform.OS === "android" ? { channelId: ANDROID_DAILY_NUDGE_CHANNEL_ID } : null),
          },
          trigger,
        });
        if (scheduledEntry?.id) {
          nextMap[def.id] = scheduledEntry.id;
        }
      } catch (error) {
        console.warn("daily nudge schedule", error);
      }
    }
    setDailyNudgeNotificationIds(nextMap);
    AsyncStorage.setItem(STORAGE_KEYS.DAILY_NUDGE_SCHEDULE_SIGNATURE, signature).catch(() => {});
  }, [
    clearLegacyDailyNudges,
    dailyNudgesHydrated,
    ensureNotificationPermission,
    language,
    scheduleNotificationWithCooldown,
    tVariant,
  ]);

  useEffect(() => {
    if (!dailyNudgesHydrated) return;
    rescheduleDailyNudgeNotifications();
  }, [
    dailyNudgesHydrated,
    language,
    notificationPermissionGranted,
    rescheduleDailyNudgeNotifications,
    tVariant,
  ]);

  const runDeferredHydration = useCallback(() => {
      if (deferredHydrationReadyRef.current || deferredHydrationInFlightRef.current) return;
      const payload = deferredHydrationPayloadRef.current;
      if (!payload) return;
      deferredHydrationInFlightRef.current = true;
      try {
        const { decisionStatsRaw } = payload;
        if (decisionStatsRaw) {
          try {
            setDecisionStats({ ...INITIAL_DECISION_STATS, ...JSON.parse(decisionStatsRaw) });
          } catch (error) {
            console.warn("decision stats parse", error);
            setDecisionStats({ ...INITIAL_DECISION_STATS });
          }
        } else {
          setDecisionStats({ ...INITIAL_DECISION_STATS });
        }
        setDecisionStatsHydrated(true);
      } finally {
        deferredHydrationPayloadRef.current = null;
        deferredHydrationInFlightRef.current = false;
        deferredHydrationReadyRef.current = true;
        setDeferredHydrationReady(true);
      }
  }, []);

  const loadStoredData = async () => {
    const resetCounterAtStart = resetCounterRef.current;
    let resolvedHealthPoints = null;
    let tutorialRaw = null;
    let temptationTutorialRaw = null;
    try {
      tutorialRaw = await AsyncStorage.getItem(STORAGE_KEYS.TUTORIAL);
    } catch (error) {
      console.warn("tutorial hydrate", error);
    }
    try {
      temptationTutorialRaw = await AsyncStorage.getItem(STORAGE_KEYS.TEMPTATION_TUTORIAL);
    } catch (error) {
      console.warn("temptation tutorial hydrate", error);
    }
    setTutorialSeen((prev) => prev || tutorialRaw === "done");
    setTutorialHydrated(true);
    const normalizedTemptationTutorial =
      temptationTutorialRaw === "done" ? "done" : "pending";
    setTemptationTutorialStatus((prev) =>
      prev === "done" ? prev : normalizedTemptationTutorial
    );
    setTemptationTutorialSeen((prev) => prev || normalizedTemptationTutorial === "done");
    setTemptationTutorialCompleted(normalizedTemptationTutorial === "done");
    if (normalizedTemptationTutorial !== temptationTutorialRaw) {
      AsyncStorage.setItem(
        STORAGE_KEYS.TEMPTATION_TUTORIAL,
        normalizedTemptationTutorial
      ).catch(() => {});
    }
    setTemptationTutorialHydrated(true);
    try {
      const hydrationKeys = [
        STORAGE_KEYS.WISHES,
        STORAGE_KEYS.PENDING,
        STORAGE_KEYS.PURCHASES,
        STORAGE_KEYS.PROFILE,
        STORAGE_KEYS.THEME,
        STORAGE_KEYS.LANGUAGE,
        STORAGE_KEYS.SOUND_ENABLED,
        STORAGE_KEYS.ONBOARDING,
        STORAGE_KEYS.CATALOG,
        STORAGE_KEYS.PRICE_PRECISION_OVERRIDES,
        STORAGE_KEYS.TITLE_OVERRIDES,
        STORAGE_KEYS.EMOJI_OVERRIDES,
        STORAGE_KEYS.CATEGORY_OVERRIDES,
        STORAGE_KEYS.CUSTOM_CATEGORIES,
        STORAGE_KEYS.DESCRIPTION_OVERRIDES,
        STORAGE_KEYS.SAVED_TOTAL,
        STORAGE_KEYS.DECLINES,
        STORAGE_KEYS.FREE_DAY,
        STORAGE_KEYS.DECISION_STATS,
        STORAGE_KEYS.HISTORY,
        STORAGE_KEYS.REFUSE_STATS,
        STORAGE_KEYS.TEMPTATION_INTERACTIONS,
        STORAGE_KEYS.REWARDS_CELEBRATED,
        STORAGE_KEYS.ANALYTICS_OPT_OUT,
        STORAGE_KEYS.TEMPTATION_GOALS,
        STORAGE_KEYS.CUSTOM_TEMPTATIONS,
        STORAGE_KEYS.HIDDEN_TEMPTATIONS,
        STORAGE_KEYS.HEALTH,
        STORAGE_KEYS.CLAIMED_REWARDS,
        STORAGE_KEYS.REWARD_TOTAL,
        STORAGE_KEYS.IMPULSE_TRACKER,
        STORAGE_KEYS.MOOD_STATE,
        STORAGE_KEYS.CHALLENGES,
        STORAGE_KEYS.CUSTOM_REMINDER,
        STORAGE_KEYS.DAILY_NUDGES,
        STORAGE_KEYS.SMART_REMINDERS,
        STORAGE_KEYS.POTENTIAL_PUSH_PROGRESS,
        STORAGE_KEYS.TAMAGOTCHI,
        STORAGE_KEYS.TAMAGOTCHI_HUNGER_NOTIFICATIONS,
        STORAGE_KEYS.TAMAGOTCHI_HUNGER_DAILY_COUNT,
        STORAGE_KEYS.TAMAGOTCHI_HUNGER_LAST_AT,
        STORAGE_KEYS.DAILY_CHALLENGE,
        STORAGE_KEYS.DAILY_REWARD,
        STORAGE_KEYS.DAILY_REWARD_DAY_KEY,
        STORAGE_KEYS.DAILY_SUMMARY,
        STORAGE_KEYS.TERMS_ACCEPTED,
        STORAGE_KEYS.FOCUS_TARGET,
        STORAGE_KEYS.FOCUS_DIGEST,
        STORAGE_KEYS.FOCUS_DIGEST_PENDING,
        STORAGE_KEYS.TAMAGOTCHI_SKIN,
        STORAGE_KEYS.TAMAGOTCHI_SKINS_UNLOCKED,
        STORAGE_KEYS.SAVED_TOTAL_PEAK,
        STORAGE_KEYS.LAST_CELEBRATED_LEVEL,
        STORAGE_KEYS.ACTIVE_GOAL,
        STORAGE_KEYS.COIN_SLIDER_MAX,
        STORAGE_KEYS.FAB_TUTORIAL,
        STORAGE_KEYS.NORTH_STAR_METRIC,
        STORAGE_KEYS.PRIMARY_TEMPTATION_PROMPT,
        STORAGE_KEYS.COIN_VALUE_MODAL,
        STORAGE_KEYS.RATING_PROMPT,
      ];
      const storedPairs = await AsyncStorage.multiGet(hydrationKeys);
      const storedMap = Object.fromEntries(storedPairs || []);
      const wishesRaw = storedMap[STORAGE_KEYS.WISHES] ?? null;
      const pendingRaw = storedMap[STORAGE_KEYS.PENDING] ?? null;
      const purchasesRaw = storedMap[STORAGE_KEYS.PURCHASES] ?? null;
      const profileRaw = storedMap[STORAGE_KEYS.PROFILE] ?? null;
      const themeRaw = storedMap[STORAGE_KEYS.THEME] ?? null;
      const languageRaw = storedMap[STORAGE_KEYS.LANGUAGE] ?? null;
      const soundEnabledRaw = storedMap[STORAGE_KEYS.SOUND_ENABLED] ?? null;
      const onboardingRaw = storedMap[STORAGE_KEYS.ONBOARDING] ?? null;
      const catalogRaw = storedMap[STORAGE_KEYS.CATALOG] ?? null;
      const pricePrecisionRaw = storedMap[STORAGE_KEYS.PRICE_PRECISION_OVERRIDES] ?? null;
      const titleRaw = storedMap[STORAGE_KEYS.TITLE_OVERRIDES] ?? null;
      const emojiOverridesRaw = storedMap[STORAGE_KEYS.EMOJI_OVERRIDES] ?? null;
      const categoryOverridesRaw = storedMap[STORAGE_KEYS.CATEGORY_OVERRIDES] ?? null;
      const customCategoriesRaw = storedMap[STORAGE_KEYS.CUSTOM_CATEGORIES] ?? null;
      const descriptionOverridesRaw = storedMap[STORAGE_KEYS.DESCRIPTION_OVERRIDES] ?? null;
      const savedTotalRaw = storedMap[STORAGE_KEYS.SAVED_TOTAL] ?? null;
      const declinesRaw = storedMap[STORAGE_KEYS.DECLINES] ?? null;
      const freeDayRaw = storedMap[STORAGE_KEYS.FREE_DAY] ?? null;
      const decisionStatsRaw = storedMap[STORAGE_KEYS.DECISION_STATS] ?? null;
      const historyRaw = storedMap[STORAGE_KEYS.HISTORY] ?? null;
      const refuseStatsRaw = storedMap[STORAGE_KEYS.REFUSE_STATS] ?? null;
      const temptationInteractionsRaw = storedMap[STORAGE_KEYS.TEMPTATION_INTERACTIONS] ?? null;
      const rewardsCelebratedRaw = storedMap[STORAGE_KEYS.REWARDS_CELEBRATED] ?? null;
      const analyticsOptOutRaw = storedMap[STORAGE_KEYS.ANALYTICS_OPT_OUT] ?? null;
      const goalMapRaw = storedMap[STORAGE_KEYS.TEMPTATION_GOALS] ?? null;
      const customTemptationsRaw = storedMap[STORAGE_KEYS.CUSTOM_TEMPTATIONS] ?? null;
      const hiddenTemptationsRaw = storedMap[STORAGE_KEYS.HIDDEN_TEMPTATIONS] ?? null;
      const healthRaw = storedMap[STORAGE_KEYS.HEALTH] ?? null;
      const claimedRewardsRaw = storedMap[STORAGE_KEYS.CLAIMED_REWARDS] ?? null;
      const rewardTotalRaw = storedMap[STORAGE_KEYS.REWARD_TOTAL] ?? null;
      const impulseTrackerRaw = storedMap[STORAGE_KEYS.IMPULSE_TRACKER] ?? null;
      const moodRaw = storedMap[STORAGE_KEYS.MOOD_STATE] ?? null;
      const challengesRaw = storedMap[STORAGE_KEYS.CHALLENGES] ?? null;
      const customReminderRaw = storedMap[STORAGE_KEYS.CUSTOM_REMINDER] ?? null;
      const dailyNudgesRaw = storedMap[STORAGE_KEYS.DAILY_NUDGES] ?? null;
      const smartRemindersRaw = storedMap[STORAGE_KEYS.SMART_REMINDERS] ?? null;
      const potentialPushProgressRaw = storedMap[STORAGE_KEYS.POTENTIAL_PUSH_PROGRESS] ?? null;
      const tamagotchiRaw = storedMap[STORAGE_KEYS.TAMAGOTCHI] ?? null;
      const tamagotchiHungerNotificationsRaw = storedMap[STORAGE_KEYS.TAMAGOTCHI_HUNGER_NOTIFICATIONS] ?? null;
      const tamagotchiHungerDailyCountRaw = storedMap[STORAGE_KEYS.TAMAGOTCHI_HUNGER_DAILY_COUNT] ?? null;
      const tamagotchiHungerLastAtRaw = storedMap[STORAGE_KEYS.TAMAGOTCHI_HUNGER_LAST_AT] ?? null;
      const dailyChallengeRaw = storedMap[STORAGE_KEYS.DAILY_CHALLENGE] ?? null;
      const dailyRewardRaw = storedMap[STORAGE_KEYS.DAILY_REWARD] ?? null;
      const dailyRewardDayKeyRaw = storedMap[STORAGE_KEYS.DAILY_REWARD_DAY_KEY] ?? null;
      const dailySummaryRaw = storedMap[STORAGE_KEYS.DAILY_SUMMARY] ?? null;
      const termsAcceptedRaw = storedMap[STORAGE_KEYS.TERMS_ACCEPTED] ?? null;
      const focusTargetRaw = storedMap[STORAGE_KEYS.FOCUS_TARGET] ?? null;
      const focusDigestRaw = storedMap[STORAGE_KEYS.FOCUS_DIGEST] ?? null;
      const focusDigestPendingRaw = storedMap[STORAGE_KEYS.FOCUS_DIGEST_PENDING] ?? null;
      const tamagotchiSkinRaw = storedMap[STORAGE_KEYS.TAMAGOTCHI_SKIN] ?? null;
      const tamagotchiSkinsUnlockedRaw = storedMap[STORAGE_KEYS.TAMAGOTCHI_SKINS_UNLOCKED] ?? null;
      const savedPeakRaw = storedMap[STORAGE_KEYS.SAVED_TOTAL_PEAK] ?? null;
      const lastCelebratedLevelRaw = storedMap[STORAGE_KEYS.LAST_CELEBRATED_LEVEL] ?? null;
      const activeGoalRaw = storedMap[STORAGE_KEYS.ACTIVE_GOAL] ?? null;
      const coinSliderMaxRaw = storedMap[STORAGE_KEYS.COIN_SLIDER_MAX] ?? null;
      const fabTutorialRaw = storedMap[STORAGE_KEYS.FAB_TUTORIAL] ?? null;
      const northStarMetricRaw = storedMap[STORAGE_KEYS.NORTH_STAR_METRIC] ?? null;
      const primaryTemptationPromptRaw = storedMap[STORAGE_KEYS.PRIMARY_TEMPTATION_PROMPT] ?? null;
      const coinValueModalRaw = storedMap[STORAGE_KEYS.COIN_VALUE_MODAL] ?? null;
      const ratingPromptRaw = storedMap[STORAGE_KEYS.RATING_PROMPT] ?? null;
      const deferWishesHydration = shouldDeferLargeParse(wishesRaw);
      const hydrateWishes = () => {
        try {
          if (wishesRaw) {
            setWishes(JSON.parse(wishesRaw));
          } else {
            setWishes([]);
          }
        } catch (error) {
          console.warn("wishes parse", error);
          setWishes([]);
        } finally {
          setWishesHydrated(true);
        }
      };
      if (deferWishesHydration) {
        setWishes([]);
        deferNonFeedHydration(hydrateWishes);
      } else {
        hydrateWishes();
      }
      const hydratePending = () => {
        try {
          if (pendingRaw) {
            setPendingList(JSON.parse(pendingRaw));
          } else {
            setPendingList([]);
          }
        } catch (error) {
          console.warn("pending parse", error);
          setPendingList([]);
        } finally {
          setPendingHydrated(true);
        }
      };
      deferNonFeedHydration(hydratePending);
      deferredHydrationPayloadRef.current = { decisionStatsRaw };
      deferredHydrationReadyRef.current = false;
      setDeferredHydrationReady(false);
      const hydratePurchases = () => {
        try {
          if (purchasesRaw) {
            setPurchases(JSON.parse(purchasesRaw));
          } else {
            setPurchases([]);
          }
        } catch (error) {
          console.warn("purchases parse", error);
          setPurchases([]);
        } finally {
          setPurchasesHydrated(true);
        }
      };
      setPurchases([]);
      deferNonFeedHydration(hydratePurchases);
      let parsedProfile = null;
      const storedActiveGoalId = activeGoalRaw || null;
      let hydratedGoalId = storedActiveGoalId;
      if (profileRaw) {
        const rawProfile = JSON.parse(profileRaw);
        parsedProfile = { ...DEFAULT_PROFILE, ...rawProfile };
        if (!Object.prototype.hasOwnProperty.call(rawProfile, "goal")) {
          parsedProfile.goal = null;
        }
        if (!Object.prototype.hasOwnProperty.call(rawProfile, "primaryGoals")) {
          parsedProfile.primaryGoals = [];
        }
        if (!Object.prototype.hasOwnProperty.call(rawProfile, "goalTargetUSD")) {
          parsedProfile.goalTargetUSD = 0;
        }
        const trimmedFirstName = (parsedProfile.firstName || "").trim();
        const trimmedLastName = (parsedProfile.lastName || "").trim();
        const trimmedName = (parsedProfile.name || "").trim();
        if (!trimmedFirstName && !trimmedLastName && trimmedName === DEFAULT_PROFILE.name) {
          parsedProfile.name = "";
        } else if (!trimmedName) {
          parsedProfile.name = [trimmedFirstName, trimmedLastName].filter(Boolean).join(" ").trim();
        } else {
          parsedProfile.name = trimmedName;
        }
        const trimmedBio = (parsedProfile.bio || "").trim();
        if (!trimmedBio || PROFILE_BIO_FALLBACK_VALUES.includes(trimmedBio)) {
          parsedProfile.bio = "";
        } else {
          parsedProfile.bio = trimmedBio;
        }
        const normalizedPrimaryGoals = Array.isArray(parsedProfile.primaryGoals)
          ? parsedProfile.primaryGoals
              .map((entry) => {
                const goalId = entry?.id || parsedProfile.goal || DEFAULT_PROFILE.goal;
                if (!goalId) return null;
                const targetUSD =
                  Number.isFinite(entry?.targetUSD) && entry.targetUSD > 0
                    ? entry.targetUSD
                    : getGoalDefaultTargetUSD(goalId);
                const normalized = {
                  id: goalId,
                  targetUSD,
                  savedUSD: Number.isFinite(entry?.savedUSD) ? entry.savedUSD : 0,
                  status: entry?.status && entry.status !== "done" ? entry.status : "active",
                  createdAt: entry?.createdAt || null,
                };
                const customTitle =
                  typeof entry?.customTitle === "string" ? entry.customTitle.trim() : "";
                if (customTitle) {
                  normalized.customTitle = customTitle;
                }
                if (entry?.customEmoji) {
                  normalized.customEmoji = normalizeEmojiValue(entry.customEmoji, DEFAULT_GOAL_EMOJI);
                }
                return normalized;
              })
              .filter((entry) => {
                if (!entry?.id) return false;
                const customTitle =
                  typeof entry.customTitle === "string" ? entry.customTitle.trim() : "";
                return !!customTitle || !!getGoalPreset(entry.id);
              })
          : [];
        const hasPrimaryGoals = normalizedPrimaryGoals.length > 0;
        const storedGoalId = hasPrimaryGoals ? activeGoalRaw || parsedProfile.goal || null : null;
        const activeGoalEntry =
          hasPrimaryGoals && storedGoalId
            ? normalizedPrimaryGoals.find((goal) => goal.id === storedGoalId)
            : null;
        const orderedPrimaryGoals = hasPrimaryGoals
          ? activeGoalEntry
            ? [activeGoalEntry, ...normalizedPrimaryGoals.filter((goal) => goal.id !== activeGoalEntry.id)]
            : normalizedPrimaryGoals
          : [];
        if (orderedPrimaryGoals.length) {
          const profileGoalId = activeGoalEntry?.id || orderedPrimaryGoals[0]?.id || null;
          hydratedGoalId = profileGoalId;
          parsedProfile.primaryGoals = orderedPrimaryGoals;
          parsedProfile.goal = profileGoalId;
          const activeTargetEntry =
            orderedPrimaryGoals.find((goal) => goal.id === profileGoalId) || orderedPrimaryGoals[0];
          const activeTargetUSD =
            Number.isFinite(activeTargetEntry?.targetUSD) && activeTargetEntry.targetUSD > 0
              ? activeTargetEntry.targetUSD
              : parsedProfile.goalTargetUSD ||
                getGoalDefaultTargetUSD(profileGoalId || activeTargetEntry?.id || DEFAULT_PROFILE.goal);
          parsedProfile.goalTargetUSD = activeTargetUSD;
        } else {
          const fallbackGoalId = parsedProfile.goal || storedActiveGoalId || null;
          hydratedGoalId = fallbackGoalId;
          parsedProfile.primaryGoals = [];
          parsedProfile.goal = fallbackGoalId;
          parsedProfile.goalTargetUSD =
            Number.isFinite(parsedProfile.goalTargetUSD) && parsedProfile.goalTargetUSD > 0
              ? parsedProfile.goalTargetUSD
              : 0;
        }
        parsedProfile.goalCelebrated = !!parsedProfile.goalCelebrated;
        parsedProfile.spendingProfile = {
          baselineMonthlyWasteUSD: Math.max(
            0,
            Number(parsedProfile.spendingProfile?.baselineMonthlyWasteUSD) || 0
          ),
          baselineStartAt: parsedProfile.spendingProfile?.baselineStartAt || null,
        };
        if (!parsedProfile.joinedAt) {
          parsedProfile.joinedAt =
            parsedProfile.spendingProfile?.baselineStartAt || new Date().toISOString();
        }
        setProfile(parsedProfile);
        setProfileDraft(parsedProfile);
        setRegistrationData((prev) => ({
          ...prev,
          firstName: parsedProfile.firstName || prev.firstName,
          lastName: parsedProfile.lastName || prev.lastName,
          motto: parsedProfile.motto || parsedProfile.subtitle || prev.motto,
          avatar: parsedProfile.avatar || prev.avatar,
          currency: parsedProfile.currency || prev.currency,
          gender: parsedProfile.gender || prev.gender,
          persona: parsedProfile.persona || prev.persona,
        }));
        setActiveCurrency(parsedProfile.currency || DEFAULT_PROFILE.currency);
      } else {
        const freshProfile = { ...DEFAULT_PROFILE_PLACEHOLDER, joinedAt: new Date().toISOString() };
        setProfile(freshProfile);
        setProfileDraft(freshProfile);
        setActiveCurrency(DEFAULT_PROFILE.currency);
      }
      if (customReminderRaw) {
        setCustomReminderId(customReminderRaw);
      } else {
        setCustomReminderId(null);
      }
      setCustomReminderHydrated(true);
      if (dailyNudgesRaw) {
        try {
          const parsed = JSON.parse(dailyNudgesRaw);
          if (parsed && typeof parsed === "object") {
            setDailyNudgeNotificationIds(parsed);
            dailyNudgeIdsRef.current = parsed;
          } else {
            setDailyNudgeNotificationIds({});
            dailyNudgeIdsRef.current = {};
          }
        } catch (err) {
          console.warn("daily nudges parse", err);
          setDailyNudgeNotificationIds({});
          dailyNudgeIdsRef.current = {};
        }
      } else {
        setDailyNudgeNotificationIds({});
        dailyNudgeIdsRef.current = {};
      }
      if (smartRemindersRaw) {
        try {
          const parsed = JSON.parse(smartRemindersRaw);
          setSmartReminders((prev) =>
            normalizeSmartReminderEntries([
              ...(Array.isArray(parsed) ? parsed : []),
              ...prev,
            ])
          );
        } catch (err) {
          console.warn("smart reminders parse", err);
          setSmartReminders((prev) => normalizeSmartReminderEntries(prev));
        }
      }
      if (potentialPushProgressRaw) {
        try {
          const parsed = JSON.parse(potentialPushProgressRaw);
          setPotentialPushProgress({
            lastStep: Math.max(0, Number(parsed?.lastStep) || 0),
            lastStatus:
              parsed?.lastStatus === "ahead" || parsed?.lastStatus === "behind"
                ? parsed.lastStatus
                : null,
            baselineKey:
              typeof parsed?.baselineKey === "string" && parsed.baselineKey.trim()
                ? parsed.baselineKey
                : null,
            stepMultiplier: Math.min(
              POTENTIAL_PUSH_MAX_MULTIPLIER,
              Math.max(1, Number(parsed?.stepMultiplier) || 1)
            ),
            lastNotifiedAt:
              Number.isFinite(Number(parsed?.lastNotifiedAt)) && Number(parsed?.lastNotifiedAt) > 0
                ? Number(parsed.lastNotifiedAt)
                : 0,
          });
        } catch (err) {
          console.warn("potential push progress parse", err);
          setPotentialPushProgress({ ...DEFAULT_POTENTIAL_PUSH_STATE });
        }
      } else {
        setPotentialPushProgress({ ...DEFAULT_POTENTIAL_PUSH_STATE });
      }
      setPotentialPushHydrated(true);
      if (tamagotchiRaw) {
        try {
          const parsed = JSON.parse(tamagotchiRaw);
          const parsedHunger = Math.min(
            TAMAGOTCHI_MAX_HUNGER,
            Math.max(0, Number(parsed?.hunger) || 0)
          );
          const parsedCoins = Math.max(
            0,
            Math.floor(Number(parsed?.coins) || TAMAGOTCHI_START_STATE.coins)
          );
          const baseState = {
            ...TAMAGOTCHI_START_STATE,
            ...parsed,
            hunger: parsedHunger,
            coins: parsedCoins,
            lastDecayAt:
              typeof parsed?.lastDecayAt === "number" && Number.isFinite(parsed.lastDecayAt)
                ? parsed.lastDecayAt
                : Number(parsed?.lastDecayAt) || Date.now(),
            coinTick: Math.max(0, Number(parsed?.coinTick) || 0),
          };
          const { state: hydratedState } = computeTamagotchiDecay(baseState);
          setTamagotchiState(hydratedState);
          tamagotchiHungerPrevRef.current = hydratedState.hunger;
          tamagotchiHydratedRef.current = true;
          if (!healthRaw && resolvedHealthPoints === null) {
            resolvedHealthPoints = hydratedState.coins;
          }
        } catch (err) {
          setTamagotchiState({ ...TAMAGOTCHI_START_STATE });
          tamagotchiHungerPrevRef.current = TAMAGOTCHI_START_STATE.hunger;
          tamagotchiHydratedRef.current = true;
        }
      } else {
        tamagotchiHungerPrevRef.current = TAMAGOTCHI_START_STATE.hunger;
        tamagotchiHydratedRef.current = true;
      }
      if (tamagotchiHungerNotificationsRaw) {
        try {
          const parsedIds = JSON.parse(tamagotchiHungerNotificationsRaw);
          tamagotchiHungerNotificationIdsRef.current = Array.isArray(parsedIds) ? parsedIds : [];
        } catch (err) {
          tamagotchiHungerNotificationIdsRef.current = [];
        }
      } else {
        tamagotchiHungerNotificationIdsRef.current = [];
      }
      const todayKey = getDayKey(Date.now());
      if (tamagotchiHungerDailyCountRaw) {
        try {
          const parsed = JSON.parse(tamagotchiHungerDailyCountRaw);
          const storedDayKey = typeof parsed?.dayKey === "string" ? parsed.dayKey : "";
          const storedCount = Math.max(0, Number(parsed?.count) || 0);
          if (storedDayKey === todayKey) {
            tamagotchiHungerDailyCountRef.current = {
              dayKey: storedDayKey,
              count: Math.min(TAMAGOTCHI_HUNGER_NOTIFICATION_DAILY_LIMIT, storedCount),
            };
          } else {
            tamagotchiHungerDailyCountRef.current = { dayKey: todayKey, count: 0 };
          }
        } catch (err) {
          tamagotchiHungerDailyCountRef.current = { dayKey: todayKey, count: 0 };
        }
      } else {
        tamagotchiHungerDailyCountRef.current = { dayKey: todayKey, count: 0 };
      }
      if (tamagotchiHungerLastAtRaw) {
        const parsedLastAt = Number(tamagotchiHungerLastAtRaw) || 0;
        tamagotchiHungerLastAtRef.current = parsedLastAt > 0 ? parsedLastAt : 0;
      } else {
        tamagotchiHungerLastAtRef.current = 0;
      }
      if (dailyChallengeRaw) {
        try {
          const parsed = JSON.parse(dailyChallengeRaw);
          setDailyChallenge({
            ...createInitialDailyChallengeState(),
            ...(parsed && typeof parsed === "object" ? parsed : {}),
          });
        } catch (err) {
          console.warn("daily challenge parse", err);
          setDailyChallenge(createInitialDailyChallengeState());
        }
      } else {
        setDailyChallenge(createInitialDailyChallengeState());
      }
      setDailyChallengeHydrated(true);
      if (dailyRewardRaw || dailyRewardDayKeyRaw) {
        try {
          const parsed = dailyRewardRaw ? JSON.parse(dailyRewardRaw) : null;
          const parsedLastClaimAt = Number(parsed?.lastClaimAt) || 0;
          const parsedLastKey = typeof parsed?.lastKey === "string" ? parsed.lastKey : null;
          const fallbackDayKey =
            typeof dailyRewardDayKeyRaw === "string" && dailyRewardDayKeyRaw.trim()
              ? dailyRewardDayKeyRaw.trim()
              : null;
          setDailyRewardState({
            lastKey:
              parsedLastKey ||
              (parsedLastClaimAt ? getDayKey(parsedLastClaimAt) : null) ||
              fallbackDayKey,
            lastAmount: Math.max(0, Number(parsed?.lastAmount) || 0),
            lastClaimAt: parsedLastClaimAt,
            streak: Math.max(0, Number(parsed?.streak) || 0),
          });
        } catch (err) {
          console.warn("daily reward parse", err);
          const fallbackDayKey =
            typeof dailyRewardDayKeyRaw === "string" && dailyRewardDayKeyRaw.trim()
              ? dailyRewardDayKeyRaw.trim()
              : null;
          setDailyRewardState({
            ...DEFAULT_DAILY_REWARD_STATE,
            lastKey: fallbackDayKey || null,
          });
        }
      } else {
        setDailyRewardState({ ...DEFAULT_DAILY_REWARD_STATE });
      }
      setDailyRewardHydrated(true);
      if (themeRaw) {
        setTheme(themeRaw === "dark" ? "dark" : "light");
      } else {
        setTheme(DEFAULT_THEME);
      }
      setThemeHydrated(true);
      if (languageRaw) {
        setLanguage(normalizeLanguage(languageRaw));
      } else {
        setLanguage(DEFAULT_LANGUAGE);
      }
      setLanguageHydrated(true);
      if (soundEnabledRaw === "0") {
        setSoundEnabled(false);
      } else {
        setSoundEnabled(true);
      }
      setSoundEnabledHydrated(true);
      if (coinSliderMaxRaw) {
        const parsedSliderMax = parseFloat(coinSliderMaxRaw);
        if (Number.isFinite(parsedSliderMax) && parsedSliderMax > 0) {
          setCoinSliderMaxUSD(parsedSliderMax);
        }
      } else {
        setCoinSliderMaxUSD(DEFAULT_COIN_SLIDER_MAX_USD);
      }
      setCoinSliderHydrated(true);
      const normalizedCoinValueModal =
        coinValueModalRaw === COIN_VALUE_MODAL_STATUS.SHOWN
          ? COIN_VALUE_MODAL_STATUS.SHOWN
          : coinValueModalRaw === COIN_VALUE_MODAL_STATUS.PENDING
          ? COIN_VALUE_MODAL_STATUS.PENDING
          : "none";
      setCoinValueModalStatus(normalizedCoinValueModal);
      coinValueModalStatusRef.current = normalizedCoinValueModal;
      setCoinValueModalHydrated(true);
      let normalizedRatingPrompt = createInitialRatingPromptState();
      let ratingPromptNeedsRewrite = false;
      if (ratingPromptRaw) {
        try {
          const parsed = JSON.parse(ratingPromptRaw);
          const fallback = createInitialRatingPromptState();
          const parsedLastAction = typeof parsed?.lastAction === "string" ? parsed.lastAction : null;
          const normalizedCompleted = parsedLastAction
            ? parsedLastAction === "rate"
            : Boolean(parsed?.completed);
          normalizedRatingPrompt = {
            firstOpenAt:
              typeof parsed?.firstOpenAt === "string" ? parsed.firstOpenAt : fallback.firstOpenAt,
            completed: normalizedCompleted,
            lastShownAt: typeof parsed?.lastShownAt === "string" ? parsed.lastShownAt : null,
            lastAction: parsedLastAction,
            respondedAt: typeof parsed?.respondedAt === "string" ? parsed.respondedAt : null,
            actionCount: Math.max(0, Number(parsed?.actionCount) || 0),
            actionPrompted: Boolean(parsed?.actionPrompted),
          };
          ratingPromptNeedsRewrite =
            normalizedRatingPrompt.firstOpenAt !== parsed?.firstOpenAt ||
            normalizedRatingPrompt.lastShownAt !== parsed?.lastShownAt ||
            normalizedRatingPrompt.lastAction !== parsed?.lastAction ||
            normalizedRatingPrompt.respondedAt !== parsed?.respondedAt ||
            normalizedRatingPrompt.completed !== Boolean(parsed?.completed) ||
            normalizedRatingPrompt.actionCount !== Math.max(0, Number(parsed?.actionCount) || 0) ||
            normalizedRatingPrompt.actionPrompted !== Boolean(parsed?.actionPrompted);
        } catch (error) {
          console.warn("rating prompt hydrate", error);
          normalizedRatingPrompt = createInitialRatingPromptState();
          ratingPromptNeedsRewrite = true;
        }
      } else {
        ratingPromptNeedsRewrite = true;
      }
      setRatingPromptState(normalizedRatingPrompt);
      if (ratingPromptNeedsRewrite) {
        AsyncStorage.setItem(
          STORAGE_KEYS.RATING_PROMPT,
          JSON.stringify(normalizedRatingPrompt)
        ).catch(() => {});
      }
      setRatingPromptHydrated(true);
      if (
        fabTutorialRaw === FAB_TUTORIAL_STATUS.PENDING ||
        fabTutorialRaw === FAB_TUTORIAL_STATUS.SHOWING
      ) {
        setFabTutorialState(fabTutorialRaw);
        fabTutorialStateRef.current = fabTutorialRaw;
      } else {
        setFabTutorialState(FAB_TUTORIAL_STATUS.DONE);
        fabTutorialStateRef.current = FAB_TUTORIAL_STATUS.DONE;
      }
      if (northStarMetricRaw) {
        let logged = false;
        let northStar2Logged = false;
        try {
          const parsedNorthStar = JSON.parse(northStarMetricRaw);
          logged = !!parsedNorthStar?.logged;
          northStar2Logged = !!parsedNorthStar?.northStar2Logged;
        } catch (error) {
          logged = northStarMetricRaw === "1";
        }
        setNorthStarLogged(logged);
        northStarLoggedRef.current = logged;
        setNorthStar2Logged(northStar2Logged);
        northStar2LoggedRef.current = northStar2Logged;
      } else {
        setNorthStarLogged(false);
        northStarLoggedRef.current = false;
        setNorthStar2Logged(false);
        northStar2LoggedRef.current = false;
      }
      setNorthStarHydrated(true);
      if (primaryTemptationPromptRaw === "pending") {
        setPrimaryTemptationPromptState("pending");
      } else {
        setPrimaryTemptationPromptState("done");
      }
      setPrimaryTemptationPromptHydrated(true);
      if (dailySummaryRaw) setDailySummarySeenKey(dailySummaryRaw);
      if (termsAcceptedRaw === "1") {
        setTermsAccepted(true);
      }
      if (focusTargetRaw) {
        try {
          const parsedFocus = JSON.parse(focusTargetRaw);
          if (parsedFocus && typeof parsedFocus === "object" && typeof parsedFocus.templateId === "string") {
            setFocusTemplateId(parsedFocus.templateId);
            setFocusSaveCount(Math.max(0, Number(parsedFocus.saveCount) || 0));
          } else {
            setFocusTemplateId(null);
            setFocusSaveCount(0);
          }
        } catch (error) {
          setFocusTemplateId(null);
          setFocusSaveCount(0);
        }
      } else {
        setFocusTemplateId(null);
        setFocusSaveCount(0);
      }
      setFocusStateHydrated(true);
      if (focusDigestRaw) {
        setFocusDigestSeenKey(focusDigestRaw || null);
      } else {
        setFocusDigestSeenKey(null);
      }
      setFocusDigestHydrated(true);
      if (focusDigestPendingRaw) {
        try {
          const parsedPending = JSON.parse(focusDigestPendingRaw);
          if (parsedPending && typeof parsedPending === "object" && parsedPending.payload) {
            setPendingFocusDigest(parsedPending);
          } else {
            setPendingFocusDigest(null);
          }
        } catch (error) {
          setPendingFocusDigest(null);
        }
      } else {
        setPendingFocusDigest(null);
      }
      const skinsUnlocked = tamagotchiSkinsUnlockedRaw === "1";
      setTamagotchiSkinsUnlocked(skinsUnlocked);
      setTamagotchiSkinsUnlockHydrated(true);
      if (
        tamagotchiSkinRaw &&
        TAMAGOTCHI_SKINS[tamagotchiSkinRaw] &&
        (skinsUnlocked || tamagotchiSkinRaw === DEFAULT_TAMAGOTCHI_SKIN)
      ) {
        setTamagotchiSkinId(tamagotchiSkinRaw);
      } else {
        setTamagotchiSkinId(DEFAULT_TAMAGOTCHI_SKIN);
      }
      setTamagotchiSkinHydrated(true);
      setActiveGoalId(hydratedGoalId);
      setActiveGoalHydrated(true);
      if (catalogRaw) {
        try {
          setCatalogOverrides(JSON.parse(catalogRaw));
        } catch (error) {
          console.warn("catalog overrides parse", error);
          setCatalogOverrides({});
        }
      } else {
        setCatalogOverrides({});
      }
      setCatalogHydrated(true);
      if (pricePrecisionRaw) {
        try {
          setPricePrecisionOverrides(JSON.parse(pricePrecisionRaw));
        } catch (error) {
          console.warn("price precision overrides parse", error);
          setPricePrecisionOverrides({});
        }
      } else {
        setPricePrecisionOverrides({});
      }
      setPricePrecisionOverridesHydrated(true);
      if (titleRaw) {
        try {
          setTitleOverrides(JSON.parse(titleRaw));
        } catch (error) {
          console.warn("title overrides parse", error);
          setTitleOverrides({});
        }
      } else {
        setTitleOverrides({});
      }
      setTitleOverridesHydrated(true);
      if (emojiOverridesRaw) {
        try {
          setEmojiOverrides(JSON.parse(emojiOverridesRaw));
        } catch (error) {
          console.warn("emoji overrides parse", error);
          setEmojiOverrides({});
        }
      } else {
        setEmojiOverrides({});
      }
      setEmojiOverridesHydrated(true);
      if (categoryOverridesRaw) {
        try {
          setCategoryOverrides(JSON.parse(categoryOverridesRaw));
        } catch (error) {
          console.warn("category overrides parse", error);
          setCategoryOverrides({});
        }
      } else {
        setCategoryOverrides({});
      }
      setCategoryOverridesHydrated(true);
      if (customCategoriesRaw) {
        try {
          const parsed = JSON.parse(customCategoriesRaw);
          const normalizedList = Array.isArray(parsed) ? parsed : [];
          const registered = normalizedList
            .map((entry) => registerCustomCategory(entry))
            .filter(Boolean);
          setCustomCategories(registered);
        } catch (error) {
          console.warn("custom categories parse", error);
          setCustomCategories([]);
        }
      } else {
        setCustomCategories([]);
      }
      setCustomCategoriesHydrated(true);
      if (descriptionOverridesRaw) {
        try {
          setDescriptionOverrides(JSON.parse(descriptionOverridesRaw));
        } catch (error) {
          console.warn("description overrides parse", error);
          setDescriptionOverrides({});
        }
      } else {
        setDescriptionOverrides({});
      }
      setDescriptionOverridesHydrated(true);
      let resolvedSavedTotal = 0;
      if (savedTotalRaw) {
        resolvedSavedTotal = Number(savedTotalRaw) || 0;
        setSavedTotalUSD(resolvedSavedTotal);
      } else {
        setSavedTotalUSD(0);
      }
      setSavedTotalHydrated(true);
      const parsedPeak = savedPeakRaw ? Number(savedPeakRaw) || 0 : Math.max(0, resolvedSavedTotal);
      const resolvedPeakValue = Math.max(parsedPeak, resolvedSavedTotal);
      setLifetimeSavedUSD(resolvedPeakValue);
      setLifetimeSavedHydrated(true);
      const levelBaselineCurrency =
        typeof parsedProfile?.currency === "string" && parsedProfile.currency.trim()
          ? parsedProfile.currency
          : DEFAULT_PROFILE.currency;
      const resolvedLevelBaseline = getTierProgress(resolvedPeakValue, levelBaselineCurrency).level;
      const storedCelebratedLevel =
        lastCelebratedLevelRaw !== null && lastCelebratedLevelRaw !== undefined
          ? Math.max(1, Number(lastCelebratedLevelRaw) || 1)
          : Math.max(1, resolvedLevelBaseline);
      const syncedCelebratedLevel =
        storedCelebratedLevel < resolvedLevelBaseline
          ? Math.max(1, resolvedLevelBaseline)
          : storedCelebratedLevel;
      if (syncedCelebratedLevel !== storedCelebratedLevel) {
        AsyncStorage.setItem(
          STORAGE_KEYS.LAST_CELEBRATED_LEVEL,
          String(syncedCelebratedLevel)
        ).catch(() => {});
      }
      setLastCelebratedLevel(syncedCelebratedLevel);
      previousPlayerLevelRef.current = syncedCelebratedLevel;
      setLastCelebratedLevelHydrated(true);
      if (declinesRaw) {
        setDeclineCount(Number(declinesRaw) || 0);
      } else {
        setDeclineCount(0);
      }
      setDeclinesHydrated(true);
      if (freeDayRaw) {
        setFreeDayStats({ ...INITIAL_FREE_DAY_STATS, ...JSON.parse(freeDayRaw) });
      }
      const deferHistoryHydration = shouldDeferLargeParse(historyRaw);
      const hydrateHistory = () => {
        try {
          if (historyRaw) {
            const parsedHistory = JSON.parse(historyRaw);
            const now = Date.now();
            const filteredHistory = (Array.isArray(parsedHistory) ? parsedHistory : [])
              .filter((entry) => entry?.timestamp && now - entry.timestamp <= HISTORY_RETENTION_MS)
              .slice(0, MAX_HISTORY_EVENTS);
            setHistoryEvents(filteredHistory);
          } else {
            setHistoryEvents([]);
          }
        } catch (err) {
          console.warn("history parse", err);
          setHistoryEvents([]);
        } finally {
          setHistoryHydrated(true);
        }
      };
      if (deferHistoryHydration) {
        setHistoryEvents([]);
        InteractionManager.runAfterInteractions(hydrateHistory);
      } else {
        hydrateHistory();
      }
      if (refuseStatsRaw) {
        setRefuseStats(JSON.parse(refuseStatsRaw));
      } else {
        setRefuseStats({});
      }
      setRefuseStatsHydrated(true);
      if (temptationInteractionsRaw) {
        try {
          const parsedInteractions = JSON.parse(temptationInteractionsRaw);
          setTemptationInteractions((prev) =>
            mergeInteractionStatMaps(parsedInteractions || {}, prev || {})
          );
        } catch (err) {
          console.warn("temptation interactions parse", err);
        }
      }
      setTemptationInteractionsHydrated(true);
      if (rewardsCelebratedRaw) {
        try {
          const parsedCelebrated = JSON.parse(rewardsCelebratedRaw);
          setRewardCelebratedMap(parsedCelebrated && typeof parsedCelebrated === "object" ? parsedCelebrated : {});
        } catch (err) {
          console.warn("rewards celebrated parse", err);
          setRewardCelebratedMap({});
        }
      } else {
        setRewardCelebratedMap({});
      }
      setRewardCelebratedHydrated(true);
      const hasAnalyticsConsent =
        analyticsOptOutRaw === "1" ||
        analyticsOptOutRaw === "0" ||
        analyticsOptOutRaw === "true" ||
        analyticsOptOutRaw === "false";
      if (hasAnalyticsConsent) {
        setAnalyticsOptOutState(analyticsOptOutRaw === "1" || analyticsOptOutRaw === "true");
      } else {
        setAnalyticsOptOutState(null);
      }
      if (goalMapRaw) {
        try {
          setTemptationGoalMap(JSON.parse(goalMapRaw));
        } catch (err) {
          console.warn("goal map parse", err);
          setTemptationGoalMap({});
        }
      } else {
        setTemptationGoalMap({});
      }
      setTemptationGoalMapHydrated(true);
      if (customTemptationsRaw) {
        try {
          const parsedCustom = JSON.parse(customTemptationsRaw);
          const fallbackCurrency = parsedProfile?.currency || DEFAULT_PROFILE.currency;
          const normalizedCustom = (Array.isArray(parsedCustom) ? parsedCustom : [parsedCustom])
            .map((entry) => normalizeCustomTemptationEntry(entry, fallbackCurrency))
            .filter(Boolean);
          setQuickTemptations(normalizedCustom);
        } catch (err) {
          console.warn("custom temptations parse", err);
        }
      }
      if (hiddenTemptationsRaw) {
        try {
          setHiddenTemptations(JSON.parse(hiddenTemptationsRaw) || []);
        } catch (err) {
          console.warn("hidden temptations parse", err);
          setHiddenTemptations([]);
        }
      } else {
        setHiddenTemptations([]);
      }
      setHiddenTemptationsHydrated(true);
      if (healthRaw) {
        const parsedHealth = Number(healthRaw) || 0;
        resolvedHealthPoints = Math.max(0, parsedHealth);
      } else if (resolvedHealthPoints === null) {
        resolvedHealthPoints = 0;
      }
      let initialClaimedCount = 0;
      if (claimedRewardsRaw) {
        try {
          const parsedClaimed = JSON.parse(claimedRewardsRaw);
          const normalizedClaimed = normalizeClaimedRewardsMap(parsedClaimed);
          initialClaimedCount = Object.keys(normalizedClaimed).length;
          setClaimedRewards(normalizedClaimed);
        } catch (err) {
          console.warn("claimed rewards parse", err);
          setClaimedRewards({});
        }
      } else {
        setClaimedRewards({});
      }
      setClaimedRewardsHydrated(true);
      if (rewardTotalRaw) {
        const parsedRewardTotal = Number(rewardTotalRaw);
        setRewardClaimTotal(Number.isFinite(parsedRewardTotal) ? Math.max(parsedRewardTotal, 0) : 0);
      } else {
        setRewardClaimTotal(initialClaimedCount);
      }
      setRewardTotalHydrated(true);
      if (impulseTrackerRaw) {
        try {
          const parsed = JSON.parse(impulseTrackerRaw);
          const normalizedEvents = Array.isArray(parsed?.events)
            ? parsed.events.slice(0, MAX_IMPULSE_EVENTS).map((event) => {
                if (!event) return event;
                const normalizedCategory = normalizeImpulseCategoryId(event.category);
                if (!normalizedCategory) return event;
                if (event.category === normalizedCategory) return event;
                return { ...event, category: normalizedCategory };
              })
            : [];
          setImpulseTracker({
            ...INITIAL_IMPULSE_TRACKER,
            ...parsed,
            events: normalizedEvents,
            lastAlerts: parsed?.lastAlerts || {},
          });
        } catch (err) {
          console.warn("impulse tracker parse", err);
          setImpulseTracker({ ...INITIAL_IMPULSE_TRACKER });
        }
      } else {
        setImpulseTracker({ ...INITIAL_IMPULSE_TRACKER });
      }
      setImpulseTrackerHydrated(true);
      if (challengesRaw) {
        try {
          const parsed = JSON.parse(challengesRaw);
          const normalized = normalizeChallengesState(parsed);
          challengesPrevRef.current = normalized;
          setChallengesState(normalized);
        } catch (err) {
          console.warn("challenges parse", err);
          const fallback = createInitialChallengesState();
          challengesPrevRef.current = fallback;
          setChallengesState(fallback);
        }
      } else {
        const fallback = createInitialChallengesState();
        challengesPrevRef.current = fallback;
        setChallengesState(fallback);
      }
      setChallengesHydrated(true);
      if (moodRaw) {
        try {
          const parsed = JSON.parse(moodRaw);
          lastVisitAtSnapshotRef.current = parsed?.lastVisitAt || null;
          const normalizedEvents = Array.isArray(parsed?.events)
            ? parsed.events.slice(0, MOOD_MAX_EVENTS)
            : [];
          const todayKey = getDayKey(Date.now());
          if (parsed?.dayKey === todayKey) {
            setMoodState({
              ...parsed,
              dayKey: todayKey,
              events: normalizedEvents,
              current: parsed.current || MOOD_IDS.NEUTRAL,
              pendingSnapshot:
                typeof parsed.pendingSnapshot === "number" ? parsed.pendingSnapshot : pendingList.length,
            });
          } else {
            setMoodState(createMoodStateForToday());
          }
        } catch (err) {
          console.warn("mood state parse", err);
          lastVisitAtSnapshotRef.current = null;
        }
      } else {
        lastVisitAtSnapshotRef.current = null;
      }
      if (onboardingRaw === "done") {
        if (hasAnalyticsConsent) {
          goToOnboardingStep("done", { recordHistory: false, resetHistory: true });
        } else {
          analyticsConsentGateRef.current = true;
          goToOnboardingStep("analytics_consent", { recordHistory: false, resetHistory: true });
        }
      } else {
        const placeholderProfile = { ...DEFAULT_PROFILE_PLACEHOLDER, joinedAt: new Date().toISOString() };
        setProfile(placeholderProfile);
        setProfileDraft(placeholderProfile);
        setActiveGoalId(null);
        setRegistrationData((prev) => ({
          ...prev,
          firstName: "",
          lastName: "",
          motto: "",
          avatar: "",
          currency: placeholderProfile.currency,
          gender: placeholderProfile.gender,
        }));
        setActiveCurrency(DEFAULT_PROFILE.currency);
        goToOnboardingStep("logo", { recordHistory: false, resetHistory: true });
        setOnboardingStep("logo");
        setActiveGoalHydrated(true);
      }
      setProfileHydrated(true);
    } catch (error) {
      console.warn("load error", error);
      setAnalyticsOptOutState((prev) => (prev === null ? null : prev));
      setRatingPromptState(createInitialRatingPromptState());
      setTutorialHydrated(true);
      setClaimedRewardsHydrated(true);
      setChallengesHydrated(true);
      setPendingList([]);
      setPendingHydrated(true);
      setDecisionStats({ ...INITIAL_DECISION_STATS });
      setDecisionStatsHydrated(true);
      setPurchases([]);
      setPurchasesHydrated(true);
      setTemptationGoalMap({});
      setTemptationGoalMapHydrated(true);
      deferredHydrationPayloadRef.current = null;
      deferredHydrationReadyRef.current = true;
      setDeferredHydrationReady(true);
    } finally {
      setHistoryHydrated(true);
      const safeHealthPoints =
        typeof resolvedHealthPoints === "number" && !Number.isNaN(resolvedHealthPoints)
          ? resolvedHealthPoints
          : 0;
      if (resetCounterRef.current === resetCounterAtStart) {
        setHealthPoints((prev) => (prev === safeHealthPoints ? prev : safeHealthPoints));
      }
      setHealthHydrated(true);
      setNorthStarHydrated(true);
      setWishesHydrated(true);
      setSavedTotalHydrated(true);
      setRewardsReady(true);
      setMoodHydrated(true);
      setFreeDayHydrated(true);
      setCustomReminderHydrated(true);
      setPotentialPushHydrated(true);
      setSmartRemindersHydrated(true);
      setDailyNudgesHydrated(true);
      setCatalogHydrated(true);
      setTitleOverridesHydrated(true);
      setEmojiOverridesHydrated(true);
      setCategoryOverridesHydrated(true);
      setDescriptionOverridesHydrated(true);
      setTamagotchiSkinHydrated(true);
      setLifetimeSavedHydrated(true);
      setTemptationTutorialHydrated(true);
      setProfileHydrated(true);
      setPrimaryTemptationPromptHydrated(true);
      setRatingPromptHydrated(true);
      setClaimedRewardsHydrated(true);
      setChallengesHydrated(true);
      setRefuseStatsHydrated(true);
      setQuickTemptationsHydrated(true);
      setStartupHydrated(true);
    }
  };

  useEffect(() => {
    let cancelled = false;
    const task = InteractionManager.runAfterInteractions(() => {
      if (!cancelled) {
        loadStoredData();
      }
    });
    return () => {
      cancelled = true;
      task?.cancel?.();
    };
  }, []);
  useEffect(() => {
    if (!startupHydrated) return;
    let cancelled = false;
    const task = InteractionManager.runAfterInteractions(() => {
      if (!cancelled) {
        runDeferredHydration();
      }
    });
    return () => {
      cancelled = true;
      task?.cancel?.();
    };
  }, [runDeferredHydration, startupHydrated]);
  useEffect(() => {
    if (activeTab === "feed") return;
    runDeferredHydration();
  }, [activeTab, runDeferredHydration]);
  useEffect(() => {
    northStarLoggedRef.current = northStarLogged;
  }, [northStarLogged]);
  useEffect(() => {
    northStar2LoggedRef.current = northStar2Logged;
  }, [northStar2Logged]);
  useEffect(() => {
    if (onboardingStep !== "done") {
      setHomeLayoutReady(false);
      setTutorialVisible(false);
    }
  }, [onboardingStep]);

  useEffect(() => {
    if (
      onboardingStep === "done" &&
      startupLogoReady &&
      !startupLogoDismissedRef.current &&
      !onboardingSkippedRef.current
    ) {
      setStartupLogoVisible(true);
    }
  }, [onboardingStep, startupLogoReady]);

  const handleStartupLogoComplete = useCallback(() => {
    markStartupLogoDismissed();
  }, [markStartupLogoDismissed]);

  const handleOnboardingLogoComplete = useCallback(() => {
    markStartupLogoDismissed();
    goToOnboardingStep("language", { recordHistory: false });
  }, [goToOnboardingStep, markStartupLogoDismissed]);

  const persistTamagotchiHungerNotificationIds = useCallback((ids = []) => {
    tamagotchiHungerNotificationIdsRef.current = ids;
    AsyncStorage.setItem(
      STORAGE_KEYS.TAMAGOTCHI_HUNGER_NOTIFICATIONS,
      JSON.stringify(ids)
    ).catch(() => {});
  }, []);

  const persistTamagotchiHungerDailyCount = useCallback((dayKey, count) => {
    tamagotchiHungerDailyCountRef.current = { dayKey, count };
    AsyncStorage.setItem(
      STORAGE_KEYS.TAMAGOTCHI_HUNGER_DAILY_COUNT,
      JSON.stringify({ dayKey, count })
    ).catch(() => {});
  }, []);

  const persistTamagotchiHungerLastAt = useCallback((timestamp) => {
    const normalized = Number(timestamp) || 0;
    tamagotchiHungerLastAtRef.current = normalized > 0 ? normalized : 0;
    AsyncStorage.setItem(
      STORAGE_KEYS.TAMAGOTCHI_HUNGER_LAST_AT,
      String(tamagotchiHungerLastAtRef.current)
    ).catch(() => {});
  }, []);

  const getTamagotchiHungerLastAt = useCallback(() => {
    return Number(tamagotchiHungerLastAtRef.current) || 0;
  }, []);

  const getTamagotchiHungerDailyCount = useCallback((timestamp = Date.now()) => {
    const dayKey = getDayKey(timestamp);
    const stored = tamagotchiHungerDailyCountRef.current || {};
    const count =
      stored.dayKey === dayKey ? Math.max(0, Number(stored.count) || 0) : 0;
    return { dayKey, count };
  }, []);

  const bumpTamagotchiHungerDailyCount = useCallback(
    (timestamp = Date.now()) => {
      const { dayKey, count } = getTamagotchiHungerDailyCount(timestamp);
      const nextCount = Math.min(TAMAGOTCHI_HUNGER_NOTIFICATION_DAILY_LIMIT, count + 1);
      persistTamagotchiHungerDailyCount(dayKey, nextCount);
      return nextCount;
    },
    [getTamagotchiHungerDailyCount, persistTamagotchiHungerDailyCount]
  );

  const cancelTamagotchiHungerNotifications = useCallback(async () => {
    const ids = Array.isArray(tamagotchiHungerNotificationIdsRef.current)
      ? tamagotchiHungerNotificationIdsRef.current
      : [];
    if (!ids.length) return;
    await Promise.all(
      ids.map((notificationId) =>
        Notifications.cancelScheduledNotificationAsync(notificationId).catch(() => {})
      )
    );
    persistTamagotchiHungerNotificationIds([]);
  }, [persistTamagotchiHungerNotificationIds]);

  const scheduleTamagotchiHungerNotifications = useCallback(async () => {
    if (notificationPermissionGranted !== true) {
      await cancelTamagotchiHungerNotifications();
      return;
    }
    const currentHunger = Math.min(
      TAMAGOTCHI_MAX_HUNGER,
      Math.max(0, Number(tamagotchiState.hunger) || 0)
    );
    if (currentHunger <= 0) {
      await cancelTamagotchiHungerNotifications();
      return;
    }
    const nowTs = Date.now();
    const lastSentAt = getTamagotchiHungerLastAt();
    const nextAllowedAt =
      lastSentAt > 0 ? lastSentAt + TAMAGOTCHI_HUNGER_NOTIFICATION_WINDOW_MS : nowTs;
    await cancelTamagotchiHungerNotifications();
    const copy = TAMAGOTCHI_NOTIFICATION_COPY[language] || TAMAGOTCHI_NOTIFICATION_COPY.ru;
    const candidates = [];
    if (currentHunger > TAMAGOTCHI_HUNGER_LOW_THRESHOLD) {
      const stepsToLow = Math.ceil(
        (currentHunger - TAMAGOTCHI_HUNGER_LOW_THRESHOLD) / TAMAGOTCHI_DECAY_STEP
      );
      const lowAt = nowTs + stepsToLow * TAMAGOTCHI_DECAY_INTERVAL_MS;
      candidates.push({ at: lowAt, body: copy.low });
    }
    const stepsToStarving = Math.ceil(currentHunger / TAMAGOTCHI_DECAY_STEP);
    const starvingAt = nowTs + stepsToStarving * TAMAGOTCHI_DECAY_INTERVAL_MS;
    candidates.push({ at: starvingAt, body: copy.starving });
    const nextCandidate = candidates
      .filter((entry) => Number.isFinite(entry.at) && entry.at >= nextAllowedAt && entry.body)
      .sort((a, b) => a.at - b.at)[0];
    if (!nextCandidate) {
      persistTamagotchiHungerNotificationIds([]);
      return;
    }
    const safeTimestamp = Math.max(nowTs, nextCandidate.at);
    const scheduledEntry = await scheduleNotificationWithCooldown({
      content: {
        title: t("tamagotchiName"),
        body: nextCandidate.body,
        data: { kind: "tamagotchi_hunger" },
        ...(Platform.OS === "android" ? { channelId: ANDROID_TAMAGOTCHI_CHANNEL_ID } : null),
      },
      trigger: new Date(safeTimestamp),
    });
    const ids = scheduledEntry?.id ? [scheduledEntry.id] : [];
    persistTamagotchiHungerNotificationIds(ids);
  }, [
    cancelTamagotchiHungerNotifications,
    getTamagotchiHungerLastAt,
    language,
    notificationPermissionGranted,
    persistTamagotchiHungerNotificationIds,
    scheduleNotificationWithCooldown,
    t,
    tamagotchiState.hunger,
  ]);

  const sendTamagotchiHungerNotification = useCallback(
    async (kind) => {
      const copy = TAMAGOTCHI_NOTIFICATION_COPY[language] || TAMAGOTCHI_NOTIFICATION_COPY.ru;
      const body = copy[kind];
      if (!body) return;
      const nowTs = Date.now();
      const lastSentAt = getTamagotchiHungerLastAt();
      const nextAllowedAt =
        lastSentAt > 0 ? lastSentAt + TAMAGOTCHI_HUNGER_NOTIFICATION_WINDOW_MS : 0;
      if (nextAllowedAt && nowTs < nextAllowedAt) return;
      const sent = await sendImmediateNotification({
        title: t("tamagotchiName"),
        body,
        data: { kind: "tamagotchi_hunger" },
        ...(Platform.OS === "android" ? { channelId: ANDROID_TAMAGOTCHI_CHANNEL_ID } : null),
      });
      if (sent) {
        persistTamagotchiHungerLastAt(nowTs);
        cancelTamagotchiHungerNotifications();
      }
    },
    [
      cancelTamagotchiHungerNotifications,
      getTamagotchiHungerLastAt,
      language,
      persistTamagotchiHungerLastAt,
      sendImmediateNotification,
      t,
    ]
  );
  const notifyDailySummaryReady = useCallback(
    (summary) => {
      if (!summary) return;
      const todayKey =
        typeof summary.todayKey === "string" && summary.todayKey.trim()
          ? summary.todayKey.trim()
          : getDayKey(Date.now());
      if (!todayKey) return;
      const savedUSD = Math.max(0, Number(summary.savedUSD) || 0);
      const declines = Math.max(0, Number(summary.declines) || 0);
      if (declines < 3) return;
      const spends = Math.max(0, Number(summary.spends) || 0);
      const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
      const savedLabel = formatCurrency(
        convertToCurrency(savedUSD, currencyCode),
        currencyCode
      );
      sendImmediateNotification({
        title: t("dailySummaryNotificationTitle"),
        body: t("dailySummaryNotificationBody", {
          saved: savedLabel,
          declines,
        }),
        data: {
          kind: "daily_summary",
          targetScreen: "daily_summary",
          dedupeKey: `daily_summary_${todayKey}`,
          todayKey,
          savedUSD,
          declines,
          spends,
        },
      });
    },
    [getDayKey, profile.currency, sendImmediateNotification, t]
  );

  useEffect(() => {
    const currentHunger = Math.min(
      TAMAGOTCHI_MAX_HUNGER,
      Math.max(0, Number(tamagotchiState.hunger) || 0)
    );
    if (!tamagotchiHydratedRef.current) {
      tamagotchiHungerPrevRef.current = currentHunger;
      return;
    }
    const previousHunger = Math.min(
      TAMAGOTCHI_MAX_HUNGER,
      Math.max(0, Number(tamagotchiHungerPrevRef.current) || 0)
    );
    if (currentHunger <= 0 && previousHunger > 0) {
      sendTamagotchiHungerNotification("starving");
    } else if (
      currentHunger <= TAMAGOTCHI_HUNGER_LOW_THRESHOLD &&
      previousHunger > TAMAGOTCHI_HUNGER_LOW_THRESHOLD
    ) {
      sendTamagotchiHungerNotification("low");
    }
    tamagotchiHungerPrevRef.current = currentHunger;
  }, [sendTamagotchiHungerNotification, tamagotchiState.hunger]);

  useEffect(() => {
    if (!tamagotchiHydratedRef.current) return;
    scheduleTamagotchiHungerNotifications();
  }, [scheduleTamagotchiHungerNotifications, tamagotchiState.hunger]);

  const tutorialOverlayVisible = tutorialVisible || temptationTutorialVisible;
  const canShowTutorialNow = useCallback(() => {
    if (overlay || overlayActiveRef.current) return false;
    if (overlayQueueRef.current.length) return false;
    if (celebrationQueueRef.current.length) return false;
    if (celebrationGapTimerRef.current) return false;
    if (blockingModalVisible) return false;
    const lastDismissedAt = lastOverlayDismissedAtRef.current || 0;
    if (Date.now() - lastDismissedAt < 600) return false;
    return true;
  }, [blockingModalVisible, overlay]);
  const shouldShowTutorial =
    onboardingStep === "done" &&
    tutorialHydrated &&
    !tutorialSeen &&
    !tutorialVisible &&
    canShowTutorialNow();
  const shouldShowTemptationTutorial =
    onboardingStep === "done" &&
    tutorialSeen &&
    temptationTutorialStatus === "pending" &&
    temptationTutorialQueued &&
    !tutorialOverlayVisible &&
    homeLayoutReady &&
    !startupLogoVisible &&
    !dailySummaryVisible &&
    canShowTutorialNow();

  useEffect(() => {
    if (!shouldShowTutorial) return;
    if (!appTutorialSteps.length) return;
    if (!homeLayoutReady) return;
    if (startupLogoVisible) return;
    if (!canShowTutorialNow()) return;
    setTutorialStepIndex(0);
    setTutorialVisible(true);
  }, [appTutorialSteps.length, canShowTutorialNow, homeLayoutReady, shouldShowTutorial, startupLogoVisible]);

  useEffect(() => {
    if (!shouldShowTutorial) return;
    if (!appTutorialSteps.length) return;
    const fallbackTimer = setTimeout(() => {
      if (!canShowTutorialNow()) return;
      setTutorialStepIndex(0);
      setTutorialVisible(true);
    }, 1600);
    return () => clearTimeout(fallbackTimer);
  }, [appTutorialSteps.length, canShowTutorialNow, shouldShowTutorial]);
  useEffect(() => {
    dailyChallengePendingRef.current = isDailyChallengePromptPending;
    const wasPending = dailyChallengePendingPrevRef.current;
    dailyChallengePendingPrevRef.current = isDailyChallengePromptPending;
    if (!isDailyChallengePromptPending) {
      dailyChallengePromptQueuedRef.current = false;
      dailyChallengeOfferDeferredRef.current = false;
      setDailyChallengePromptGate(false);
      return;
    }
    if (!dailyChallengePromptQueuedRef.current) {
      dailyChallengePromptQueuedRef.current = true;
      setDailyChallengePromptGate(false);
    }
    if (!wasPending) {
      dailyChallengeOfferDeferredRef.current = true;
      setDailyChallengePromptGate(false);
    }
  }, [isDailyChallengePromptPending]);
  useEffect(() => {
    if (!dailyChallengePromptAllowed) return;
    if (!isDailyChallengePromptPending) return;
    if (dailyChallengePromptGate) return;
    if (dailyChallengeOfferDeferredRef.current) return;
    setDailyChallengePromptGate(true);
  }, [
    dailyChallengePromptAllowed,
    dailyChallengePromptGate,
    isDailyChallengePromptPending,
  ]);
  useEffect(() => {
    if (!dailyChallengePromptGate) return;
    if (!isDailyChallengePromptPending) return;
    enqueueQueuedModal(QUEUED_MODAL_TYPES.DAILY_CHALLENGE);
  }, [dailyChallengePromptGate, enqueueQueuedModal, isDailyChallengePromptPending]);
  useEffect(() => {
    if (queuedModalType !== QUEUED_MODAL_TYPES.DAILY_CHALLENGE) return;
    if (isDailyChallengePromptPending) return;
    clearQueuedModal(QUEUED_MODAL_TYPES.DAILY_CHALLENGE);
  }, [clearQueuedModal, isDailyChallengePromptPending, queuedModalType]);
  useEffect(() => {
    if (!shouldShowTemptationTutorial) return;
    if (activeTab !== "feed") {
      goToTab("feed", { recordHistory: false });
    }
    const timer = setTimeout(() => {
      if (!canShowTutorialNow()) return;
      setTemptationTutorialStepIndex(0);
      setTemptationTutorialCompleted(false);
      setTemptationTutorialVisible(true);
      setTemptationTutorialSeen(true);
      setTemptationTutorialQueued(false);
    }, 260);
    return () => clearTimeout(timer);
  }, [activeTab, canShowTutorialNow, goToTab, shouldShowTemptationTutorial]);
  useEffect(() => {
    if (!tutorialOverlayVisible) {
      setTutorialHighlightRect(null);
    }
  }, [tutorialOverlayVisible]);
  useEffect(() => {
    if (!temptationTutorialVisible) return;
    tutorialHighlightAdjustCountRef.current = 0;
    tutorialHighlightAlignAttemptsRef.current = 0;
    tutorialScrollExtraRef.current = 90;
    const attemptScroll = () => {
      const scroller = feedScreenRef.current;
      if (scroller && typeof scroller.scrollToTemptations === "function") {
        const didScroll = scroller.scrollToTemptations({
          animated: true,
          extraOffset: tutorialScrollExtraRef.current,
        });
        if (didScroll) {
          scheduleTutorialHighlightMeasure(360);
        }
        return didScroll;
      }
      return false;
    };
    if (attemptScroll()) return;
    const timer = setTimeout(attemptScroll, 350);
    return () => clearTimeout(timer);
  }, [scheduleTutorialHighlightMeasure, temptationTutorialVisible]);
  // Align tutorial highlight without Android-specific adjustments: mirror iOS behavior.
  useEffect(() => {
    if (Platform.OS !== "android") return;
    if (!temptationTutorialVisible) {
      tutorialHighlightAlignAttemptsRef.current = 0;
    }
  }, [temptationTutorialVisible]);

  useEffect(() => {
    if (dailySummaryOpenToken === dailySummaryOpenProcessedRef.current) return;
    if (!historyHydrated) return;
    dailySummaryOpenProcessedRef.current = dailySummaryOpenToken;
    if (onboardingStep !== "done") return;
    if (!dailySummaryUnlocked) return;
    const hour = new Date().getHours();
    if (hour < 20) return;
    const todayKey = getDayKey(Date.now());
    if (dailySummarySeenKey === todayKey) return;
    if (pendingDailySummaryData?.todayKey === todayKey) return;
    const todayEvents = resolvedHistoryEvents.filter((e) => getDayKey(e.timestamp) === todayKey);
    if (!todayEvents.length) return;
    const saves = todayEvents.filter((e) => e.kind === "refuse_spend");
    const spends = todayEvents.filter((e) => e.kind === "spend");
    const savedUSD = saves.reduce((sum, e) => sum + (Number(e.meta?.amountUSD) || 0), 0);
    const declines = saves.length;
    if (declines < 3) return;
    const spendCount = spends.length;
    const summaryPayload = { savedUSD, declines, spends: spendCount, todayKey };
    setPendingDailySummaryData(summaryPayload);
    notifyDailySummaryReady(summaryPayload);
  }, [
    dailySummaryOpenToken,
    dailySummarySeenKey,
    dailySummaryUnlocked,
    historyHydrated,
    notifyDailySummaryReady,
    onboardingStep,
    pendingDailySummaryData?.todayKey,
    resolvedHistoryEvents,
  ]);

  useEffect(() => {
    if (!dailySummaryUnlocked) return;
    if (!pendingDailySummaryData) return;
    if (!interfaceReady) return;
    enqueueQueuedModal(QUEUED_MODAL_TYPES.DAILY_SUMMARY);
  }, [dailySummaryUnlocked, enqueueQueuedModal, interfaceReady, pendingDailySummaryData]);
  useEffect(() => {
    if (queuedModalType !== QUEUED_MODAL_TYPES.DAILY_SUMMARY) return;
    if (!pendingDailySummaryData) {
      clearQueuedModal(QUEUED_MODAL_TYPES.DAILY_SUMMARY);
      return;
    }
    setDailySummaryData(pendingDailySummaryData);
    setDailySummaryVisible(true);
    const todayKey = pendingDailySummaryData.todayKey || getDayKey(Date.now());
    setDailySummarySeenKey(todayKey);
    AsyncStorage.setItem(STORAGE_KEYS.DAILY_SUMMARY, todayKey).catch(() => {});
    setPendingDailySummaryData(null);
  }, [clearQueuedModal, pendingDailySummaryData, queuedModalType]);
  useEffect(() => {
    if (!spendLoggingReminderHydrated) return;
    if (onboardingStep !== "done") return;
    const now = Date.now();
    const todayKey = getDayKey(now);
    const hasActionToday = resolvedHistoryEvents.some((entry) => {
      if (!entry?.timestamp) return false;
      if (getDayKey(entry.timestamp) !== todayKey) return false;
      return [
        "refuse_spend",
        "spend",
        "pending_added",
        "pending_to_wish",
        "pending_to_decline",
      ].includes(entry.kind);
    });
    if (hasActionToday) return;
    const lastSpendTimestamp = resolvedHistoryEvents.reduce((max, entry) => {
      if (entry?.kind !== "spend") return max;
      const ts = Number(entry.timestamp) || 0;
      return ts > max ? ts : max;
    }, 0);
    const joinedAtTimestamp = profileJoinedAt ? new Date(profileJoinedAt).getTime() : 0;
    const lastTrackedSpendAt = lastSpendTimestamp || joinedAtTimestamp;
    if (!lastTrackedSpendAt) return;
    if (now - lastTrackedSpendAt < SPEND_LOGGING_REMINDER_DELAY_MS) return;
    const lastReminderAt = Number(lastSpendLoggingReminderRef.current) || 0;
    if (lastReminderAt && now - lastReminderAt < SPEND_LOGGING_REMINDER_COOLDOWN_MS) return;
    lastSpendLoggingReminderRef.current = now;
    AsyncStorage.setItem(STORAGE_KEYS.SPEND_LOGGING_REMINDER, String(now)).catch(() => {});
    const dedupeKey = `spend_logging:${todayKey}`;
    sendImmediateNotification(
      {
        title: t("spendLoggingReminderTitle"),
        body: t("spendLoggingReminderBody"),
        data: { kind: "spend_logging", dedupeKey },
      },
      { dedupeKey }
    );
  }, [
    onboardingStep,
    profileJoinedAt,
    resolvedHistoryEvents,
    sendImmediateNotification,
    spendLoggingReminderHydrated,
    t,
  ]);

  useEffect(() => {
    processTamagotchiDecay();
    const interval = setInterval(() => {
      processTamagotchiDecay();
    }, 60 * 1000);
    return () => clearInterval(interval);
  }, [processTamagotchiDecay]);

  useEffect(() => {
    setTamagotchiState((prev) =>
      prev.coins === healthPoints ? prev : { ...prev, coins: healthPoints }
    );
  }, [healthPoints]);

  useEffect(() => {
    if (tamagotchiVisible) {
      Animated.timing(tamagotchiModalAnim, {
        toValue: 1,
        duration: 220,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }).start();
    } else {
      Animated.timing(tamagotchiModalAnim, {
        toValue: 0,
        duration: 160,
        easing: Easing.in(Easing.quad),
        useNativeDriver: true,
      }).start();
    }
  }, [tamagotchiVisible, tamagotchiModalAnim]);

  useEffect(() => {
    if (onboardingStep === "done" && (profile.primaryGoals || []).length) {
      ensurePrimaryGoalWish(profile.primaryGoals, language, activeGoalId || profile.goal);
    }
  }, [ensurePrimaryGoalWish, onboardingStep, profile.primaryGoals, activeGoalId, profile.goal, language]);

  useEffect(() => {
    const targetUSD = heroGoalTargetUSD > 0 ? heroGoalTargetUSD : 0;
    const hasMetGoal = targetUSD > 0 && heroGoalSavedUSD >= targetUSD;
    if (hasMetGoal && !profile.goalCelebrated) {
      const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
      const targetLabel = formatCurrency(convertToCurrency(targetUSD, currencyCode), currencyCode);
      const rewardCoins = GOAL_COMPLETION_REWARD_COINS;
      const rewardAmount = GOAL_COMPLETION_REWARD_VALUE;
      setProfile((prev) => ({
        ...prev,
        goalCelebrated: true,
        goalRenewalPending: true,
      }));
      setProfileDraft((prev) => ({
        ...prev,
        goalCelebrated: true,
        goalRenewalPending: true,
      }));
      setHealthPoints((prev) => prev + rewardAmount);
      setPendingGoalCelebration({
        payload: {
          title: t("goalCelebrationTitle"),
          subtitle: t("goalCelebrationSubtitle"),
          targetLabel: t("goalCelebrationTarget", { amount: targetLabel }),
          summary: goalCelebrationSummary,
          fallbackTotalUSD: heroGoalSavedUSD,
          currency: profile.currency || DEFAULT_PROFILE.currency,
          language,
          rewardCoins,
          rewardAmount,
          rewardAsset: GOAL_COMPLETION_REWARD_TIER?.asset || null,
        },
        config: { duration: 0 },
      });
      if (!hasPendingGoals) {
        goalRenewalPromptPendingRef.current = true;
        goalRenewalPromptAfterGoalRef.current = true;
      }
    }
  }, [
    heroGoalTargetUSD,
    profile.goalCelebrated,
    profile.currency,
    heroGoalSavedUSD,
    hasPendingGoals,
    goalCelebrationSummary,
    language,
    setHealthPoints,
    t,
  ]);

  useEffect(() => {
    const targetUSD = heroGoalTargetUSD > 0 ? heroGoalTargetUSD : 0;
    const hasMetGoal = targetUSD > 0 && heroGoalSavedUSD >= targetUSD;
    if (profile.goalCelebrated && !hasMetGoal) {
      setProfile((prev) => ({ ...prev, goalCelebrated: false, goalRenewalPending: false }));
      setProfileDraft((prev) => ({ ...prev, goalCelebrated: false, goalRenewalPending: false }));
      goalRenewalPromptPendingRef.current = false;
    }
  }, [heroGoalTargetUSD, profile.goalCelebrated, heroGoalSavedUSD, setProfile]);

  useEffect(() => {
    if (!wishesHydrated) return;
    queuePersist(STORAGE_KEYS.WISHES, JSON.stringify(wishes));
  }, [queuePersist, wishes, wishesHydrated]);

  useEffect(() => {
    if (!temptationGoalMapHydrated) return;
    queuePersist(STORAGE_KEYS.TEMPTATION_GOALS, JSON.stringify(temptationGoalMap));
  }, [queuePersist, temptationGoalMap, temptationGoalMapHydrated]);

  useEffect(() => {
    if (!purchasesHydrated) return;
    queuePersist(STORAGE_KEYS.PURCHASES, JSON.stringify(purchases));
  }, [queuePersist, purchases, purchasesHydrated]);

  useEffect(() => {
    if (!profileHydrated) return;
    queuePersist(STORAGE_KEYS.PROFILE, JSON.stringify(profile));
  }, [queuePersist, profile, profileHydrated]);

  useEffect(() => {
    if (!activeGoalHydrated) return;
    const value = activeGoalId || "";
    queuePersist(STORAGE_KEYS.ACTIVE_GOAL, value);
  }, [queuePersist, activeGoalHydrated, activeGoalId]);

  // Ensure we always have an active goal selected once profile is loaded.
  useEffect(() => {
    if (!activeGoalHydrated) return;
    if (activeGoalId) return;
    if (profile.goal) {
      setActiveGoalId(profile.goal);
    } else if (Array.isArray(profile.primaryGoals) && profile.primaryGoals[0]?.id) {
      setActiveGoalId(profile.primaryGoals[0].id);
    }
  }, [activeGoalHydrated, activeGoalId, profile.goal, profile.primaryGoals]);

  useEffect(() => {
    if (!profile.goalRenewalPending) {
      goalRenewalPromptPendingRef.current = false;
      goalRenewalPromptAfterGoalRef.current = false;
      return;
    }
    if (profile.goalCelebrated) {
      goalRenewalPromptPendingRef.current = true;
      goalRenewalPromptAfterGoalRef.current = true;
      return;
    }
    if (hasPendingGoals) return;
    requestGoalRenewalPrompt();
  }, [hasPendingGoals, profile.goalCelebrated, profile.goalRenewalPending, requestGoalRenewalPrompt]);

  useEffect(() => {
    setActiveCurrency(profile.currency || DEFAULT_PROFILE.currency);
  }, [profile.currency]);

  useEffect(() => {
    if (!themeHydrated) return;
    queuePersist(STORAGE_KEYS.THEME, theme);
  }, [queuePersist, theme, themeHydrated]);

  useEffect(() => {
    if (!languageHydrated) return;
    queuePersist(STORAGE_KEYS.LANGUAGE, language);
  }, [queuePersist, language, languageHydrated]);

  useEffect(() => {
    if (!healthHydrated) return;
    queuePersist(STORAGE_KEYS.HEALTH, String(healthPoints));
  }, [queuePersist, healthHydrated, healthPoints]);
  useEffect(() => {
    if (!dailyRewardHydrated) return;
    queuePersist(STORAGE_KEYS.DAILY_REWARD, JSON.stringify(dailyRewardState));
  }, [queuePersist, dailyRewardHydrated, dailyRewardState]);

  useEffect(() => {
    if (!claimedRewardsHydrated) return;
    queuePersist(STORAGE_KEYS.CLAIMED_REWARDS, JSON.stringify(claimedRewards));
  }, [queuePersist, claimedRewards, claimedRewardsHydrated]);
  useEffect(() => {
    if (!rewardTotalHydrated || !Number.isFinite(rewardClaimTotal)) return;
    queuePersist(STORAGE_KEYS.REWARD_TOTAL, String(Math.max(0, rewardClaimTotal)));
  }, [queuePersist, rewardClaimTotal, rewardTotalHydrated]);

  useEffect(() => {
    if (!challengesHydrated) return;
    queuePersist(STORAGE_KEYS.CHALLENGES, JSON.stringify(challengesState));
  }, [queuePersist, challengesState, challengesHydrated]);
  useEffect(() => {
    if (!dailyChallengeHydrated) return;
    queuePersist(STORAGE_KEYS.DAILY_CHALLENGE, JSON.stringify(dailyChallenge));
  }, [queuePersist, dailyChallenge, dailyChallengeHydrated]);

useEffect(() => {
  if (!tamagotchiHydratedRef.current) return;
  queuePersist(STORAGE_KEYS.TAMAGOTCHI, JSON.stringify(tamagotchiState));
}, [queuePersist, tamagotchiState]);

  useEffect(() => {
    if (!tamagotchiSkinHydrated) return;
    queuePersist(STORAGE_KEYS.TAMAGOTCHI_SKIN, tamagotchiSkinId);
  }, [queuePersist, tamagotchiSkinHydrated, tamagotchiSkinId]);
  useEffect(() => {
    if (!tamagotchiSkinsUnlockHydrated) return;
    queuePersist(STORAGE_KEYS.TAMAGOTCHI_SKINS_UNLOCKED, tamagotchiSkinsUnlocked ? "1" : "0");
  }, [queuePersist, tamagotchiSkinsUnlockHydrated, tamagotchiSkinsUnlocked]);

  useEffect(() => {
    if (!catalogHydrated) return;
    queuePersist(STORAGE_KEYS.CATALOG, JSON.stringify(catalogOverrides));
  }, [queuePersist, catalogOverrides, catalogHydrated]);
  useEffect(() => {
    if (!pricePrecisionOverridesHydrated) return;
    queuePersist(
      STORAGE_KEYS.PRICE_PRECISION_OVERRIDES,
      JSON.stringify(pricePrecisionOverrides)
    );
  }, [queuePersist, pricePrecisionOverrides, pricePrecisionOverridesHydrated]);

  useEffect(() => {
    if (!titleOverridesHydrated) return;
    queuePersist(STORAGE_KEYS.TITLE_OVERRIDES, JSON.stringify(titleOverrides));
  }, [queuePersist, titleOverrides, titleOverridesHydrated]);

  useEffect(() => {
    if (!emojiOverridesHydrated) return;
    queuePersist(STORAGE_KEYS.EMOJI_OVERRIDES, JSON.stringify(emojiOverrides));
  }, [queuePersist, emojiOverrides, emojiOverridesHydrated]);
  useEffect(() => {
    if (!categoryOverridesHydrated) return;
    queuePersist(STORAGE_KEYS.CATEGORY_OVERRIDES, JSON.stringify(categoryOverrides));
  }, [queuePersist, categoryOverrides, categoryOverridesHydrated]);

  useEffect(() => {
    if (!customCategoriesHydrated) return;
    queuePersist(STORAGE_KEYS.CUSTOM_CATEGORIES, JSON.stringify(customCategories));
  }, [queuePersist, customCategories, customCategoriesHydrated]);

  useEffect(() => {
    if (!descriptionOverridesHydrated) return;
    queuePersist(STORAGE_KEYS.DESCRIPTION_OVERRIDES, JSON.stringify(descriptionOverrides));
  }, [queuePersist, descriptionOverrides, descriptionOverridesHydrated]);

  useEffect(() => {
    if (!savedTotalHydrated) return;
    queuePersist(STORAGE_KEYS.SAVED_TOTAL, String(savedTotalUSD));
  }, [queuePersist, savedTotalUSD, savedTotalHydrated]);

  useEffect(() => {
    if (!lastCelebratedLevelHydrated) return;
    queuePersist(
      STORAGE_KEYS.LAST_CELEBRATED_LEVEL,
      String(Math.max(1, Number(lastCelebratedLevel) || 1))
    );
  }, [queuePersist, lastCelebratedLevel, lastCelebratedLevelHydrated]);

  useEffect(() => {
    if (!savedTotalHydrated || !lifetimeSavedHydrated) return;
    setLifetimeSavedUSD((prev) => (savedTotalUSD > prev ? savedTotalUSD : prev));
  }, [savedTotalUSD, savedTotalHydrated, lifetimeSavedHydrated]);

  useEffect(() => {
    if (!lifetimeSavedHydrated) return;
    queuePersist(STORAGE_KEYS.SAVED_TOTAL_PEAK, String(lifetimeSavedUSD));
  }, [queuePersist, lifetimeSavedUSD, lifetimeSavedHydrated]);

  useEffect(() => {
    if (!declinesHydrated) return;
    queuePersist(STORAGE_KEYS.DECLINES, String(declineCount));
  }, [queuePersist, declineCount, declinesHydrated]);

  useEffect(() => {
    if (onboardingStep !== "done") return;
    if (!profileHydrated) return;
    if (!historyHydrated || !savedTotalHydrated || !lifetimeSavedHydrated || !declinesHydrated) return;
    if (savedTotalUSD <= 0 && lifetimeSavedUSD <= 0) return;
    const joinedAtTimestamp = profile?.joinedAt ? new Date(profile.joinedAt).getTime() : 0;
    if (!Number.isFinite(joinedAtTimestamp) || joinedAtTimestamp <= 0) return;
    if (Date.now() - joinedAtTimestamp > DAY_MS * 2) return;
    const hasSavingsHistory = resolvedHistoryEvents.some(
      (entry) =>
        entry &&
        (HISTORY_SAVED_GAIN_EVENTS.has(entry.kind) ||
          (spendReducesSavings && HISTORY_SAVED_LOSS_EVENTS.has(entry.kind)))
    );
    if (hasSavingsHistory || declineCount > 0) return;
    const recentSaveAt = lastSaveActionAtRef.current || 0;
    if (recentSaveAt && Date.now() - recentSaveAt < SAVED_TOTAL_RESET_GRACE_MS) return;
    setSavedTotalUSD(0);
    setLifetimeSavedUSD(0);
    setLastCelebratedLevel(1);
    previousPlayerLevelRef.current = 1;
    persistLastCelebratedLevel(1);
    AsyncStorage.multiSet([
      [STORAGE_KEYS.SAVED_TOTAL, "0"],
      [STORAGE_KEYS.SAVED_TOTAL_PEAK, "0"],
      [STORAGE_KEYS.LAST_CELEBRATED_LEVEL, "1"],
    ]).catch(() => {});
  }, [
    declineCount,
    declinesHydrated,
    historyHydrated,
    lifetimeSavedHydrated,
    onboardingStep,
    persistLastCelebratedLevel,
    profile?.joinedAt,
    profileHydrated,
    resolvedHistoryEvents,
    savedTotalHydrated,
    savedTotalUSD,
    lifetimeSavedUSD,
    spendReducesSavings,
  ]);

  useEffect(() => {
    if (!dailyNudgesHydrated) return;
    queuePersist(STORAGE_KEYS.DAILY_NUDGES, JSON.stringify(dailyNudgeNotificationIds));
  }, [queuePersist, dailyNudgeNotificationIds, dailyNudgesHydrated]);

  useEffect(() => {
    if (!smartRemindersHydrated) return;
    queuePersist(STORAGE_KEYS.SMART_REMINDERS, JSON.stringify(smartReminders));
  }, [queuePersist, smartReminders, smartRemindersHydrated]);
  useEffect(() => {
    if (!potentialPushHydrated) return;
    queuePersist(
      STORAGE_KEYS.POTENTIAL_PUSH_PROGRESS,
      JSON.stringify({
        lastStep: Math.max(0, Number(potentialPushProgress.lastStep) || 0),
        lastStatus:
          potentialPushProgress.lastStatus === "ahead" || potentialPushProgress.lastStatus === "behind"
            ? potentialPushProgress.lastStatus
            : null,
        baselineKey: potentialPushProgress.baselineKey || null,
        stepMultiplier: Math.min(
          POTENTIAL_PUSH_MAX_MULTIPLIER,
          Math.max(1, Number(potentialPushProgress.stepMultiplier) || 1)
        ),
        lastNotifiedAt:
          Number.isFinite(Number(potentialPushProgress.lastNotifiedAt)) &&
          Number(potentialPushProgress.lastNotifiedAt) > 0
            ? Number(potentialPushProgress.lastNotifiedAt)
            : 0,
      })
    );
  }, [queuePersist, potentialPushHydrated, potentialPushProgress]);

  useEffect(() => {
    if (!pendingHydrated) return;
    queuePersist(STORAGE_KEYS.PENDING, JSON.stringify(pendingList));
  }, [queuePersist, pendingList, pendingHydrated]);

  useEffect(() => {
    if (!freeDayHydrated) return;
    queuePersist(STORAGE_KEYS.FREE_DAY, JSON.stringify(freeDayStats));
  }, [queuePersist, freeDayStats, freeDayHydrated]);

  useEffect(() => {
    if (!refuseStatsHydrated) return;
    queuePersist(STORAGE_KEYS.REFUSE_STATS, JSON.stringify(refuseStats));
  }, [queuePersist, refuseStats, refuseStatsHydrated]);

  useEffect(() => {
    if (!temptationInteractionsHydrated) return;
    queuePersist(STORAGE_KEYS.TEMPTATION_INTERACTIONS, JSON.stringify(temptationInteractions));
  }, [queuePersist, temptationInteractions, temptationInteractionsHydrated]);
  useEffect(() => {
    if (!temptationInteractionsHydrated) return;
    const now = Date.now();
    const updates = {};
    Object.entries(temptationInteractions || {}).forEach(([templateId, entry]) => {
      if (!entry?.frequency) return;
      const desiredIntervalMs = getFrequencyIntervalMs(entry.frequency);
      const intervalMs = desiredIntervalMs || entry.intervalMs || null;
      const lastInteractionAt = Number(entry.lastInteractionAt) || 0;
      const baseNextCheckAt =
        Number(entry.nextCheckAt) ||
        (intervalMs && lastInteractionAt ? lastInteractionAt + intervalMs : null);
      if (!intervalMs || !baseNextCheckAt) return;
      const shouldUpdateInterval =
        Number.isFinite(desiredIntervalMs) && entry.intervalMs !== desiredIntervalMs;
      if (baseNextCheckAt > now && !shouldUpdateInterval && entry.nextCheckAt) return;
      if (baseNextCheckAt > now) {
        updates[templateId] = {
          nextCheckAt: baseNextCheckAt,
          intervalMs,
          missedCyclesDelta: 0,
          resetStreak: false,
        };
        return;
      }
      const cyclesMissed = Math.max(
        1,
        Math.floor((now - baseNextCheckAt) / intervalMs) + 1
      );
      updates[templateId] = {
        nextCheckAt: baseNextCheckAt + cyclesMissed * intervalMs,
        intervalMs,
        missedCyclesDelta: cyclesMissed,
        resetStreak: (refuseStats?.[templateId]?.currentStreak || 0) > 0,
      };
    });
    const templateIds = Object.keys(updates);
    if (!templateIds.length) return;
    setTemptationInteractions((prev) => {
      const source = prev || {};
      let changed = false;
      const next = { ...source };
      templateIds.forEach((templateId) => {
        const prevEntry = source[templateId];
        if (!prevEntry) return;
        const update = updates[templateId];
        const nextMissedCycles = (prevEntry.missedCycles || 0) + update.missedCyclesDelta;
        if (
          prevEntry.nextCheckAt === update.nextCheckAt &&
          prevEntry.lastTimerResetAt === now &&
          prevEntry.missedCycles === nextMissedCycles
        ) {
          return;
        }
        next[templateId] = {
          ...prevEntry,
          nextCheckAt: update.nextCheckAt,
          intervalMs: update.intervalMs || prevEntry.intervalMs || null,
          lastTimerResetAt: now,
          missedCycles: nextMissedCycles,
          frequencyReminderScheduledAt: null,
          frequencyReminderLocale: null,
        };
        changed = true;
      });
      return changed ? next : prev;
    });
    if (!refuseStatsHydrated) return;
    const resetTargets = templateIds.filter((templateId) => updates[templateId].resetStreak);
    if (!resetTargets.length) return;
    setRefuseStats((prev) => {
      const source = prev || {};
      let changed = false;
      const next = { ...source };
      resetTargets.forEach((templateId) => {
        const current = source[templateId];
        if (!current) return;
        const previousStreak = Math.max(current.currentStreak || 0, 0);
        if (previousStreak === 0 && current.lastAction !== "save") {
          return;
        }
        const lastSavedAmountRaw = Number(current.lastSavedAmountUSD);
        const fallbackRecoverableRaw = Number(current.recoverableAmountUSD);
        const lastSavedAmount = Number.isFinite(lastSavedAmountRaw)
          ? Math.max(lastSavedAmountRaw, 0)
          : Number.isFinite(fallbackRecoverableRaw)
          ? Math.max(fallbackRecoverableRaw, 0)
          : 0;
        const bestStreakValue = Math.max(current.bestStreak || 0, previousStreak);
        next[templateId] = {
          ...current,
          currentStreak: 0,
          bestStreak: bestStreakValue,
          lastAction: "spend",
          streakLostAt: now,
          recoverableStreak: previousStreak,
          recoverableAmountUSD: lastSavedAmount,
        };
        changed = true;
      });
      return changed ? next : prev;
    });
  }, [
    refuseStats,
    refuseStatsHydrated,
    setRefuseStats,
    setTemptationInteractions,
    temptationInteractions,
    temptationInteractionsHydrated,
  ]);
  useEffect(() => {
    if (!temptationInteractionsHydrated) return;
    if (notificationPermissionGranted !== true) return;
    const normalizedLanguage = normalizeLanguage(language);
    let cancelled = false;
    const cancelAndClearReminders = async (templateId, reminderValue) => {
      const ids = Array.isArray(reminderValue)
        ? reminderValue
        : reminderValue
        ? [reminderValue]
        : [];
      if (ids.length) {
        await Promise.all(
          ids.map((reminderId) =>
            Notifications.cancelScheduledNotificationAsync(reminderId).catch((error) =>
              console.warn("frequency reminder cancel", error)
            )
          )
        );
      }
      if (cancelled) return;
      setTemptationInteractions((prev) => {
        const prevEntry = prev?.[templateId];
        if (!prevEntry) return prev;
        if (
          !prevEntry.frequencyReminderId &&
          !(prevEntry.frequencyReminderIds && prevEntry.frequencyReminderIds.length) &&
          !prevEntry.frequencyReminderScheduledAt &&
          !prevEntry.frequencyReminderLocale &&
          !prevEntry.frequencyReminderPlanKey
        ) {
          return prev;
        }
        return {
          ...(prev || {}),
          [templateId]: {
            ...prevEntry,
            frequencyReminderId: null,
            frequencyReminderIds: [],
            frequencyReminderScheduledAt: null,
            frequencyReminderLocale: null,
            frequencyReminderPlanKey: null,
          },
        };
      });
    };
    const ensureReminders = async () => {
      const entries = Object.entries(temptationInteractions || {});
      for (let index = 0; index < entries.length; index += 1) {
        if (cancelled) return;
        const [templateId, entry] = entries[index];
        if (!entry) continue;
        const frequency = entry.frequency;
        const nextCheckAt = entry.nextCheckAt;
        const hasFrequency = !!frequency && Number.isFinite(nextCheckAt);
        const existingReminderIds = Array.isArray(entry.frequencyReminderIds)
          ? entry.frequencyReminderIds
          : entry.frequencyReminderId
          ? [entry.frequencyReminderId]
          : [];
        if (!hasFrequency) {
          if (existingReminderIds.length) {
            await cancelAndClearReminders(templateId, existingReminderIds);
          }
          continue;
        }
        const scheduleTriggers = buildFrequencyReminderSchedule(nextCheckAt);
        if (!scheduleTriggers.length) {
          if (existingReminderIds.length) {
            await cancelAndClearReminders(templateId, existingReminderIds);
          }
          continue;
        }
        const planKey = `${normalizedLanguage}:${scheduleTriggers.join(",")}`;
        if (
          entry.frequencyReminderPlanKey === planKey &&
          existingReminderIds.length === scheduleTriggers.length
        ) {
          continue;
        }
        if (existingReminderIds.length) {
          await cancelAndClearReminders(templateId, existingReminderIds);
          if (cancelled) return;
        }
        const label = entry.templateTitle || t("defaultDealTitle");
          const reminderIds = [];
        for (let idx = 0; idx < scheduleTriggers.length; idx += 1) {
          if (cancelled) break;
          const triggerTime = scheduleTriggers[idx];
          try {
            const dedupeKey = `frequency:${templateId}:${triggerTime}`;
            const scheduledEntry = await scheduleNotificationWithCooldown({
              content: {
                title: t("frequencyReminderTitle", { temptation: label }),
                body: t("frequencyReminderBody", { temptation: label }),
                sound: false,
                data: {
                  kind: "frequency_reminder",
                  templateId,
                  dedupeKey,
                },
              },
              trigger: new Date(triggerTime),
            });
            if (scheduledEntry?.id) {
              reminderIds.push(scheduledEntry.id);
            }
          } catch (error) {
            console.warn("frequency reminder schedule", error);
          }
        }
        if (cancelled) {
          if (reminderIds.length) {
            reminderIds.forEach((reminderId) =>
              Notifications.cancelScheduledNotificationAsync(reminderId).catch(() => {})
            );
          }
          return;
        }
        if (!reminderIds.length) {
          continue;
        }
        setTemptationInteractions((prev) => {
          const prevEntry = prev?.[templateId];
          if (!prevEntry) return prev;
          return {
            ...(prev || {}),
            [templateId]: {
              ...prevEntry,
              frequencyReminderId: null,
              frequencyReminderIds: reminderIds,
              frequencyReminderPlanKey: planKey,
              frequencyReminderScheduledAt: null,
              frequencyReminderLocale: normalizedLanguage,
            },
          };
        });
      }
    };
    ensureReminders();
    return () => {
      cancelled = true;
    };
  }, [
    language,
    notificationPermissionGranted,
    scheduleNotificationWithCooldown,
    setTemptationInteractions,
    t,
    temptationInteractions,
    temptationInteractionsHydrated,
  ]);

  useEffect(() => {
    if (analyticsOptOut === null) return;
    setAnalyticsOptOutFlag(analyticsOptOut);
    queuePersist(STORAGE_KEYS.ANALYTICS_OPT_OUT, analyticsOptOut ? "1" : "0");
  }, [queuePersist, analyticsOptOut]);

  useEffect(() => {
    if (!rewardCelebratedHydrated) return;
    queuePersist(STORAGE_KEYS.REWARDS_CELEBRATED, JSON.stringify(rewardCelebratedMap));
  }, [queuePersist, rewardCelebratedHydrated, rewardCelebratedMap]);
  useEffect(() => {
    if (analyticsOptOut !== false) return;
    if (!profileHydrated) return;
    if (notificationPermissionGranted === null) return;
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const hasGoalProperty =
      (Array.isArray(profile.primaryGoals) && profile.primaryGoals.length > 0) ||
      (wishes || []).some((wish) => wish.kind === PRIMARY_GOAL_KIND);
    const totalDecisions =
      (decisionStats?.resolvedToDeclines || 0) + (decisionStats?.resolvedToWishes || 0);
    let savingStyle = "balanced";
    if (totalDecisions > 0) {
      const declineShare = (decisionStats.resolvedToDeclines || 0) / totalDecisions;
      if (declineShare >= 0.7) {
        savingStyle = "aggressive";
      } else if (declineShare <= 0.4) {
        savingStyle = "relaxed";
      }
    }
    const personaType = profile.persona || DEFAULT_PERSONA_ID;
    const genderValue = profile.gender || "none";
    const notificationsAllowed = notificationPermissionGranted === true;
    setUserProperties({
      has_goal: !!hasGoalProperty,
      preferred_currency: currencyCode,
      saving_style: savingStyle,
      locale: language,
      is_premium: false,
      gender: genderValue,
      persona_type: personaType,
      notifications_allowed: notificationsAllowed,
      analytics_consent: "enabled",
    });
  }, [
    analyticsOptOut,
    decisionStats?.resolvedToDeclines,
    decisionStats?.resolvedToWishes,
    language,
    notificationPermissionGranted,
    profile.currency,
    profile.gender,
    profile.persona,
    profile.primaryGoals,
    profileHydrated,
    wishes,
  ]);
  useEffect(() => {
    if (!profileHydrated) return;
    const nextGender = profile.gender || "none";
    const nextPersona = profile.persona || DEFAULT_PERSONA_ID;
    const previousSelection = profileSelectionRef.current;
    const isFirstSync = previousSelection.gender === null && previousSelection.persona === null;
    if (isFirstSync) {
      profileSelectionRef.current = { gender: nextGender, persona: nextPersona };
      return;
    }
    if (onboardingStep !== "done") {
      profileSelectionRef.current = { gender: nextGender, persona: nextPersona };
      return;
    }
    if (previousSelection.gender !== nextGender) {
      const genderEvent = getGenderSelectedEvent(nextGender);
      if (genderEvent) {
        logEvent(genderEvent);
      }
    }
    if (previousSelection.persona !== nextPersona) {
      const personaEvent = getPersonaSelectedEvent(nextPersona);
      if (personaEvent) {
        logEvent(personaEvent);
      }
    }
    profileSelectionRef.current = { gender: nextGender, persona: nextPersona };
  }, [onboardingStep, profile.gender, profile.persona, profileHydrated, logEvent]);

  useEffect(() => {
    if (!rewardsUnlocked) return;
    if (!rewardsReady || !rewardCelebratedHydrated || !achievements.length) return;
    const newlyUnlocked = achievements.filter(
      (reward) => reward.unlocked && !rewardCelebratedMap[reward.id]
    );
    if (!newlyUnlocked.length) return;
    newlyUnlocked.forEach((reward) => {
      logEvent("reward_unlocked", {
        reward_id: reward.id,
        type: "badge",
        condition: ACHIEVEMENT_CONDITION_MAP[reward.metricType] || reward.metricType || "unknown",
      });
    });
    persistRewardCelebrations((prev) => {
      const next = { ...(prev || {}) };
      newlyUnlocked.forEach((reward) => {
        next[reward.id] = true;
      });
      return next;
    });
    triggerOverlayState("reward", newlyUnlocked[0].title, { force: true });
  }, [
    achievements,
    logEvent,
    persistRewardCelebrations,
    rewardCelebratedHydrated,
    rewardCelebratedMap,
    rewardsReady,
    rewardsUnlocked,
  ]);

  const rebalanceWishesFromSavedTotal = useCallback(
    () => {
      if (!wishesHydrated || !savedTotalHydrated) return;
      const primaryGoalId = mainGoalWish?.goalId || activeGoalId || profile.goal || null;
      const { targetUSD: primaryTargetUSD, savedUSD: primaryCurrentSaved } = (() => {
        if (!primaryGoalId) return { targetUSD: 0, savedUSD: 0 };
        const entry = Array.isArray(profile.primaryGoals)
          ? profile.primaryGoals.find((goal) => goal?.id === primaryGoalId)
          : null;
        const target =
          Number.isFinite(entry?.targetUSD) && entry.targetUSD > 0
            ? entry.targetUSD
            : getGoalDefaultTargetUSD(primaryGoalId);
        const savedFromProfile = Number.isFinite(entry?.savedUSD) ? Math.max(entry.savedUSD, 0) : 0;
        const wishSnapshot = Array.isArray(wishesRef.current)
          ? wishesRef.current.find(
              (wish) =>
                (wish?.kind === PRIMARY_GOAL_KIND &&
                  (wish.goalId === primaryGoalId || wish.id === getPrimaryGoalWishId(primaryGoalId))) ||
                wish?.id === primaryGoalId
            )
          : null;
        const savedFromWish = Number.isFinite(wishSnapshot?.savedUSD)
          ? Math.max(wishSnapshot.savedUSD, 0)
          : 0;
        return { targetUSD: target, savedUSD: Math.max(savedFromProfile, savedFromWish) };
      })();
      const desiredPrimaryStatus =
        primaryGoalId && primaryTargetUSD > 0 && primaryCurrentSaved >= primaryTargetUSD
          ? "done"
          : "active";

      setWishes((prev) => {
        if (!prev.length) return prev;
        let changed = false;
        const next = prev.map((wish) => {
          const isPrimary = wish.kind === PRIMARY_GOAL_KIND && (wish.goalId || wish.id) === primaryGoalId;
          if (isPrimary) {
            if (wish.savedUSD !== primaryCurrentSaved || wish.status !== desiredPrimaryStatus) {
              changed = true;
              return { ...wish, savedUSD: primaryCurrentSaved, status: desiredPrimaryStatus };
            }
            return wish;
          }
          const status = (wish.savedUSD || 0) >= (wish.targetUSD || 0) ? "done" : "active";
          if (wish.status !== status) {
            changed = true;
            return { ...wish, status };
          }
          return wish;
        });
        return changed ? next : prev;
      });

      if (primaryGoalId) {
        syncPrimaryGoalProgress(primaryGoalId, primaryCurrentSaved, desiredPrimaryStatus);
      }
    },
    [
      activeGoalId,
      mainGoalWish?.goalId,
      profile.goal,
      profile.primaryGoals,
      savedTotalHydrated,
      syncPrimaryGoalProgress,
      wishesHydrated,
      setWishes,
    ]
  );

  useEffect(() => {
    rebalanceWishesFromSavedTotal();
  }, [rebalanceWishesFromSavedTotal, savedTotalUSD]);

  useEffect(() => {
    if (!decisionStatsHydrated) return;
    queuePersist(STORAGE_KEYS.DECISION_STATS, JSON.stringify(decisionStats));
  }, [queuePersist, decisionStats, decisionStatsHydrated]);

  useEffect(() => {
    if (!historyHydrated) return;
    queuePersist(STORAGE_KEYS.HISTORY, JSON.stringify(resolvedHistoryEvents));
  }, [queuePersist, historyHydrated, resolvedHistoryEvents]);

  useEffect(() => {
    if (!quickTemptationsHydrated) return;
    queuePersist(STORAGE_KEYS.CUSTOM_TEMPTATIONS, JSON.stringify(quickTemptations));
  }, [queuePersist, quickTemptations, quickTemptationsHydrated]);

  useEffect(() => {
    if (!hiddenTemptationsHydrated) return;
    queuePersist(STORAGE_KEYS.HIDDEN_TEMPTATIONS, JSON.stringify(hiddenTemptations));
  }, [queuePersist, hiddenTemptations, hiddenTemptationsHydrated]);

  useEffect(() => {
    if (!impulseTrackerHydrated) return;
    queuePersist(STORAGE_KEYS.IMPULSE_TRACKER, JSON.stringify(impulseTracker));
  }, [queuePersist, impulseTracker, impulseTrackerHydrated]);

  useEffect(() => {
    const applyOverrides = (card) => {
      if (!card) return null;
      const overrideCategory = categoryOverrides[card.id];
      const normalizedCategory =
        overrideCategory && IMPULSE_CATEGORY_DEFS[overrideCategory] ? overrideCategory : null;
      const precisionOverride = pricePrecisionOverrides[card.id];
      const normalizedPrecision =
        typeof precisionOverride === "number" && Number.isFinite(precisionOverride) && precisionOverride >= 0
          ? precisionOverride
          : card.pricePrecision ?? null;
      return {
        ...card,
        priceUSD: catalogOverrides[card.id] ?? card.priceUSD ?? card.basePriceUSD,
        pricePrecision: normalizedPrecision,
        titleOverride: titleOverrides[card.id] ?? card.titleOverride ?? null,
        emoji: emojiOverrides[card.id] || card.emoji,
        impulseCategoryOverride: normalizedCategory || card.impulseCategoryOverride || null,
        descriptionOverride: descriptionOverrides[card.id] ?? card.descriptionOverride ?? null,
      };
    };
    const nextList = DEFAULT_TEMPTATIONS.map(applyOverrides).sort(
      (a, b) =>
        (a.priceUSD ?? a.basePriceUSD ?? 0) - (b.priceUSD ?? b.basePriceUSD ?? 0)
    );
    const primaryTemplateId = profile.customSpend?.id || "custom_habit";
    const personalized = buildPersonalizedTemptations(profile, nextList).map(applyOverrides);
    const hiddenSet = new Set(hiddenTemptations);
    const personalizedVisible = personalized.filter(
      (card) => card && (card.id === primaryTemplateId || !hiddenSet.has(card.id))
    );
    const personalizedIds = new Set(personalizedVisible.map((c) => c.id));
    const quickAdjusted = quickTemptations
      .map(applyOverrides)
      .filter(
        (card) =>
          card &&
          (card.id === primaryTemplateId || (!hiddenSet.has(card.id) && !personalizedIds.has(card.id)))
      );
    const primaryCard =
      personalizedVisible.find((card) => card.id === primaryTemplateId) ||
      quickAdjusted.find((card) => card.id === primaryTemplateId) ||
      applyOverrides(nextList.find((card) => card?.id === primaryTemplateId));
    // Ð‘Ñ‹ÑÑ‚Ñ€Ð°Ñ ÐºÐ°ÑÑ‚Ð¾Ð¼Ð½Ð°Ñ ÐºÐ°Ñ€Ñ‚Ð° Ð²ÑÐµÐ³Ð´Ð° Ñ€ÐµÐ½Ð´ÐµÑ€Ð¸Ñ‚ÑÑ Ð¿ÐµÑ€Ð²Ð¾Ð¹, Ð·Ð°Ñ‚ÐµÐ¼ Ð¸Ð´Ñ‘Ñ‚ Ð¿ÐµÑ€ÑÐ¾Ð½Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ð¿Ð¾Ñ€ÑÐ´Ð¾Ðº.
    const combined = [...quickAdjusted, ...personalizedVisible];
    if (primaryCard && !combined.some((card) => card?.id === primaryTemplateId)) {
      combined.unshift(primaryCard);
    }

    setTemptations(combined);
  }, [
    catalogOverrides,
    pricePrecisionOverrides,
    profile,
    titleOverrides,
    emojiOverrides,
    categoryOverrides,
    descriptionOverrides,
    quickTemptations,
    hiddenTemptations,
    onboardingStep,
  ]);

  useEffect(() => {
    return () => {
      if (overlayTimer.current) clearTimeout(overlayTimer.current);
      Object.values(cardFeedbackTimers.current).forEach((timer) => clearTimeout(timer));
    };
  }, []);

  useEffect(() => {
    if (!focusTemplateId) return;
    const exists =
      [...quickTemptations, ...temptations].some((card) => card?.id === focusTemplateId) ||
      focusTemplateId === primaryTemptationId;
    if (!exists) {
      setFocusTemplateId(null);
      setFocusSaveCount(0);
    }
  }, [focusTemplateId, primaryTemptationId, quickTemptations, temptations]);

  const handleTabChange = (tabKey) => {
    triggerHaptic();
    if (tabKey !== activeTab && tabKey === "cart") {
      logEvent("menu_progress_opened");
    }
    goToTab(tabKey);
  };

  const handleTabHistoryBack = useCallback(() => {
    const history = tabHistoryRef.current;
    if (!history.length) return false;
    const previousTab = history[history.length - 1];
    const nextHistory = history.slice(0, -1);
    updateTabHistory(nextHistory);
    goToTab(previousTab, { recordHistory: false });
    return true;
  }, [goToTab, updateTabHistory]);

  const handleAppBack = useCallback(() => {
    if (onboardingStep !== "done") {
      if (canGoBackOnboarding) {
        handleOnboardingBack();
        return true;
      }
      return false;
    }
    return handleTabHistoryBack();
  }, [canGoBackOnboarding, handleOnboardingBack, handleTabHistoryBack, onboardingStep]);

  const canUseBackGesture = onboardingStep !== "done" ? canGoBackOnboarding : tabHistory.length > 0;

  const backGestureResponder = useMemo(() => {
    if (!canUseBackGesture) return null;
    let handled = false;
    const tryHandleBack = (gestureState) => {
      if (
        handled ||
        gestureState.dx > -BACK_GESTURE_TRIGGER_DISTANCE ||
        Math.abs(gestureState.dy) >= BACK_GESTURE_VERTICAL_SLOP
      ) {
        return;
      }
      handled = true;
      handleAppBack();
    };
    return PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: (_, gestureState) =>
        Math.abs(gestureState.dx) > Math.abs(gestureState.dy) && gestureState.dx < -10,
      onPanResponderRelease: (_, gestureState) => {
        tryHandleBack(gestureState);
      },
      onPanResponderTerminate: (_, gestureState) => {
        tryHandleBack(gestureState);
      },
      onPanResponderTerminationRequest: () => true,
    });
  }, [canUseBackGesture, handleAppBack]);

  const handleThemeToggle = (mode) => {
    const nextTheme = mode === "dark" ? "dark" : "light";
    triggerHaptic();
    setTheme(nextTheme);
    if (nextTheme !== theme) {
      logEvent("theme_changed", { theme: nextTheme });
    }
  };

  const handleLanguageChange = (lng) => {
    const nextLanguage = normalizeLanguage(lng);
    triggerHaptic();
    setLanguage(nextLanguage);
    const languageEvent = getLanguageSelectedEvent(nextLanguage);
    if (languageEvent) {
      logEvent(languageEvent);
    }
  };

  const handleTermsOpen = () => {
    triggerHaptic();
    setTermsContinuePending(false);
    setTermsModalVisible(true);
  };

  const handleTermsCancel = () => {
    triggerHaptic();
    setTermsContinuePending(false);
    setTermsModalVisible(false);
  };

  const handleTermsLinkOpen = () => {
    const normalizedLanguage = normalizeLanguage(language);
    const url = TERMS_LINKS[normalizedLanguage] || TERMS_LINKS.en;
    if (!url) return;
    triggerHaptic();
    Linking.openURL(url).catch((error) => console.warn("terms link", error));
  };

  const handleTermsAccept = () => {
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    const shouldAdvance = termsContinuePending;
    setTermsAccepted(true);
    setTermsModalVisible(false);
    setTermsContinuePending(false);
    AsyncStorage.setItem(STORAGE_KEYS.TERMS_ACCEPTED, "1").catch(() => {});
    logEvent("onboarding_terms_accepted", { language });
    logEvent("consent_terms_accepted", { language });
    if (shouldAdvance) {
      goToOnboardingStep("analytics_consent");
    }
  };

  const handleProfileCurrencyChange = (code) => {
    if (!CURRENCIES.includes(code) || profile.currency === code) return;
    triggerHaptic();
    setProfile((prev) => ({ ...prev, currency: code }));
    setProfileDraft((prev) => ({ ...prev, currency: code }));
    setRegistrationData((prev) => ({ ...prev, currency: code }));
    setActiveCurrency(code);
    const currencyEvent = getCurrencySelectedEvent(code);
    if (currencyEvent) {
      logEvent(currencyEvent);
    }
  };

  const handleActiveGoalSelect = useCallback(
    (goalId) => {
      if (!goalId) return;
      triggerHaptic();
      const previousGoalId = activeGoalId || profile.goal;
      clearCompletedPrimaryGoal(previousGoalId);
      setActiveGoalId(goalId);
      setProfile((prev) => ({
        ...prev,
        goal: goalId,
        goalCelebrated: false,
        goalRenewalPending: false,
      }));
      setProfileDraft((prev) => ({
        ...prev,
        goal: goalId,
        goalCelebrated: false,
        goalRenewalPending: false,
      }));
      dismissGoalRenewalPrompt();
    },
    [dismissGoalRenewalPrompt, triggerHaptic, activeGoalId, profile.goal, clearCompletedPrimaryGoal]
  );

  const handleLanguageContinue = () => {
    triggerHaptic();
    if (!termsAccepted) {
      setTermsModalVisible(true);
      setTermsContinuePending(true);
      return;
    }
    goToOnboardingStep("analytics_consent");
  };

  const handleGuideContinue = () => {
    triggerHaptic();
    goToOnboardingStep("register");
  };

  const updateRegistrationData = (field, value) => {
    if (field === "currency") {
      setActiveCurrency(value);
      const currencyEvent = getCurrencySelectedEvent(value);
      if (currencyEvent) {
        logEvent(currencyEvent);
      }
    }
    if (field === "gender" && onboardingStep !== "done") {
      const genderValue = value || "none";
      const genderEvent = getGenderSelectedEvent(genderValue);
      if (genderEvent) {
        logEvent(genderEvent);
      }
    }
    if (field === "persona" && onboardingStep !== "done") {
      const personaEvent = getPersonaSelectedEvent(value);
      if (personaEvent) {
        logEvent(personaEvent);
      }
    }
    setRegistrationData((prev) => ({ ...prev, [field]: value }));
  };

  const ensurePrimaryGoalWish = useCallback(
    (goalEntries = [], lng, activeGoal = null) => {
      const entries = Array.isArray(goalEntries) ? goalEntries : [];
      const trimmedEntries = entries.filter((entry) => entry?.id);
      const validEntries = trimmedEntries.filter((entry) => {
        const customTitle = typeof entry?.customTitle === "string" ? entry.customTitle.trim() : "";
        return !!customTitle || !!getGoalPreset(entry.id);
      });
      const activeEntry =
        activeGoal && validEntries.length
          ? validEntries.find((entry) => entry?.id === activeGoal)
          : null;
      const orderedEntries = activeEntry
        ? [activeEntry, ...validEntries.filter((entry) => entry?.id !== activeEntry.id)]
        : validEntries;
      if (!orderedEntries.length) return;
      const languageKey = lng || "en";
      const primaryGoalIds = new Set(orderedEntries.map((entry) => entry.id));
      setWishes((prev) => {
        const existingMap = new Map();
        prev.forEach((wish) => {
          if (
            wish.kind === PRIMARY_GOAL_KIND ||
            wish.id === PRIMARY_GOAL_WISH_ID_LEGACY ||
            (typeof wish.id === "string" && wish.id.startsWith("wish_primary_goal_"))
          ) {
            let key = null;
            if (wish.goalId) {
              key = wish.goalId;
            } else if (typeof wish.id === "string" && wish.id.startsWith("wish_primary_goal_")) {
              key = wish.id.replace("wish_primary_goal_", "");
            } else if (wish.id === PRIMARY_GOAL_WISH_ID_LEGACY && activeGoal) {
              key = activeGoal;
            } else {
              key = "legacy";
            }
            const existing = existingMap.get(key);
            if (!existing) {
              existingMap.set(key, wish);
              return;
            }
            const existingSaved = Number(existing.savedUSD) || 0;
            const candidateSaved = Number(wish.savedUSD) || 0;
            const existingIsNew =
              typeof existing.id === "string" && existing.id.startsWith("wish_primary_goal_");
            const candidateIsNew =
              typeof wish.id === "string" && wish.id.startsWith("wish_primary_goal_");
            const shouldReplace =
              candidateSaved > existingSaved ||
              (candidateSaved === existingSaved && candidateIsNew && !existingIsNew);
            if (shouldReplace) {
              existingMap.set(key, wish);
            }
          }
        });
        const nonPrimary = prev.filter(
          (wish) =>
            wish.kind !== PRIMARY_GOAL_KIND &&
            wish.id !== PRIMARY_GOAL_WISH_ID_LEGACY &&
            !(typeof wish.id === "string" && wish.id.startsWith("wish_primary_goal_")) &&
            !primaryGoalIds.has(wish.id)
        );
        const nextPrimary = orderedEntries.map((entry) => {
          const goalPreset = getGoalPreset(entry.id);
          const customTitle = typeof entry?.customTitle === "string" ? entry.customTitle.trim() : "";
          const hasCustomTitle = !!customTitle;
          const customEmoji = entry?.customEmoji
            ? normalizeEmojiValue(entry.customEmoji, DEFAULT_GOAL_EMOJI)
            : null;
          const resolvedEmoji = hasCustomTitle
            ? customEmoji || DEFAULT_GOAL_EMOJI
            : goalPreset?.emoji || DEFAULT_GOAL_EMOJI;
          const presetLabel = goalPreset?.[languageKey] || goalPreset?.en || entry.id;
          const resolvedLabel = hasCustomTitle ? customTitle : presetLabel || entry.id;
          const title = `${resolvedEmoji} ${resolvedLabel}`.trim();
          const targetUSD =
            Number.isFinite(entry.targetUSD) && entry.targetUSD > 0
              ? entry.targetUSD
              : getGoalDefaultTargetUSD(entry.id);
          const existing = existingMap.get(entry.id);
          const entrySavedUSD = Number.isFinite(entry.savedUSD) ? entry.savedUSD : 0;
          const existingSavedUSD = Number.isFinite(existing?.savedUSD) ? existing.savedUSD : 0;
          const nextSavedUSD = Math.max(entrySavedUSD, existingSavedUSD);
          const inferredStatus =
            targetUSD > 0 && nextSavedUSD >= targetUSD
              ? "done"
              : existing?.status && existing.status !== "done"
              ? existing.status
              : entry?.status && entry.status !== "done"
              ? entry.status
              : "active";
          return {
            id: getPrimaryGoalWishId(entry.id),
            templateId: `goal_${entry.id}`,
            title,
            emoji: resolvedEmoji,
            targetUSD,
            savedUSD: nextSavedUSD,
            status: inferredStatus,
            createdAt: existing?.createdAt || entry?.createdAt || Date.now(),
            autoManaged: true,
            kind: PRIMARY_GOAL_KIND,
            goalId: entry.id,
          };
        });
        return [...nextPrimary, ...nonPrimary];
      });
    },
    [setWishes]
  );

  const openImagePickerSheet = (resolver) => {
    imagePickerResolver.current = resolver;
    setShowImageSourceSheet(true);
  };

  const closeImagePickerSheet = () => {
    setShowImageSourceSheet(false);
    imagePickerResolver.current = null;
  };

  const handleImageSourceChoice = async (source) => {
    const resolver = imagePickerResolver.current;
    closeImagePickerSheet();
    if (!resolver) return;
    if (Platform.OS === "ios") {
      // Avoid presenting the picker while the modal sheet is still dismissing.
      await new Promise((resolve) => setTimeout(resolve, 250));
    }
    await pickImage(source, (uri) => {
      if (!uri) return;
      resolver(uri);
    });
  };

  const handlePickImage = () => {
    openImagePickerSheet((uri) =>
      setProfileDraft((prev) => ({
        ...prev,
        avatar: uri,
      }))
    );
  };

  const handleRegistrationPickImage = () => {
    openImagePickerSheet((uri) =>
      setRegistrationData((prev) => ({
        ...prev,
        avatar: uri,
      }))
    );
  };

  const handleRegistrationSubmit = () => {
    if (!registrationData.currency) {
      Alert.alert("Almost", t("currencyLabel"));
      return;
    }
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    goToOnboardingStep("persona");
  };

  const handleCoinSliderMaxUpdate = useCallback((nextUSD) => {
    if (!Number.isFinite(nextUSD) || nextUSD <= 0) return;
    setCoinSliderMaxUSD(nextUSD);
  }, []);
  const openCoinEntry = useCallback(
    (source = "unknown") => {
      coinEntryContextRef.current = {
        source,
        openedAt: Date.now(),
        submitted: false,
      };
      setCoinEntryVisible(true);
      logEvent("coin_entry_opened", { source });
    },
    [logEvent]
  );
  const handleCoinEntryClose = useCallback(() => {
    const context = coinEntryContextRef.current;
    if (context?.source) {
      logEvent("coin_entry_closed", {
        source: context.source,
        result: context.submitted ? "submitted" : "dismissed",
        duration_ms: Math.max(0, Date.now() - (context.openedAt || 0)),
      });
    }
    coinEntryContextRef.current = { source: null, openedAt: 0, submitted: false };
    setCoinEntryVisible(false);
  }, [logEvent]);

  const handleQuickCustomChange = (field, value) => {
    setQuickSpendDraft((prev) => ({
      ...prev,
      [field]:
        field === "emoji"
          ? limitEmojiInput(value)
          : field === "category"
          ? (IMPULSE_CATEGORY_DEFS[value] ? value : prev.category)
          : value,
    }));
  };

  const resolveTemptationCategory = useCallback(
    (item) => {
      if (!item) return DEFAULT_IMPULSE_CATEGORY;
      const override = categoryOverrides[item.id];
      if (override && IMPULSE_CATEGORY_DEFS[override]) {
        return override;
      }
      if (item.impulseCategoryOverride && IMPULSE_CATEGORY_DEFS[item.impulseCategoryOverride]) {
        return item.impulseCategoryOverride;
      }
      if (Array.isArray(item.categories)) {
        const match = IMPULSE_CATEGORY_ORDER.find((slug) => item.categories.includes(slug));
        if (match) return match;
      }
      const inferred = resolveImpulseCategory(item);
      return IMPULSE_CATEGORY_DEFS[inferred] ? inferred : DEFAULT_IMPULSE_CATEGORY;
    },
    [categoryOverrides]
  );

  const shouldPromptCategory = useCallback(
    (item, action, options = {}) => {
      if (options?.skipCategoryPrompt) return false;
      if (action !== "save" && action !== "spend") return false;
      if (!categoryOverridesHydrated) return false;
      if (!isCustomTemptation(item)) return false;
      const templateId = resolveTemptationTemplateId(item);
      if (!templateId) return false;
      const override = categoryOverrides?.[templateId];
      if (override && IMPULSE_CATEGORY_DEFS[override]) return false;
      if (item?.impulseCategoryOverride && IMPULSE_CATEGORY_DEFS[item.impulseCategoryOverride] && !item?.quickTemptation) {
        return false;
      }
      return true;
    },
    [categoryOverrides, categoryOverridesHydrated, resolveTemptationTemplateId]
  );

  const openCategoryPrompt = useCallback(
    (item, action, options = {}) => {
      if (!item) return;
      const inferred = resolveTemptationCategory(item) || DEFAULT_IMPULSE_CATEGORY;
      setCategoryPromptSelection(inferred);
      setCategoryPrompt({ visible: true, item, action, options });
    },
    [resolveTemptationCategory]
  );

  const closeCategoryPrompt = useCallback(() => {
    setCategoryPrompt({ visible: false, item: null, action: null, options: null });
  }, []);

  const handleQuickCustomSubmit = (customData) => {
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const parsedAmount = parseNumberInputValue(customData.amount || "");
    if (!customData.title?.trim() || !Number.isFinite(parsedAmount) || parsedAmount <= 0) {
      Alert.alert("Almost", t("customSpendTitle"));
      return;
    }
    const amountUSD = convertFromCurrency(parsedAmount, currencyCode);
    const manualPrecision = getManualInputPrecision(customData.amount || "");
    const ownerGender = profile.gender || "none";
    const emojiValue = normalizeEmojiValue(customData.emoji, DEFAULT_TEMPTATION_EMOJI);
    const category =
      customData.category && IMPULSE_CATEGORY_DEFS[customData.category]
        ? customData.category
        : DEFAULT_IMPULSE_CATEGORY;
    const newCustom = {
      title: customData.title.trim(),
      amountUSD,
      pricePrecision: manualPrecision,
      currency: currencyCode,
      emoji: emojiValue,
      id: customData.id || `custom_habit_${Date.now()}`,
      gender: ownerGender,
      impulseCategory: category,
    };
    const card = createCustomHabitTemptation(newCustom, currencyCode, ownerGender);
    if (card) {
      card.gender = ownerGender;
      card.quickTemptation = true;
      setQuickTemptations((prev) => [card, ...prev]);
    }
    setCategoryOverrides((prev) => ({ ...prev, [newCustom.id]: category }));
    logEvent("temptation_created", {
      temptation_id: newCustom.id,
      is_custom: true,
      category,
      price: convertToCurrency(amountUSD, currencyCode),
    });
    setQuickSpendDraft({ title: "", amount: "", emoji: DEFAULT_TEMPTATION_EMOJI, category: DEFAULT_IMPULSE_CATEGORY });
    setShowCustomSpend(false);
    triggerOverlayState("custom_temptation", newCustom.title);
  };

  const handleQuickCustomCancel = () => {
    setQuickSpendDraft({ title: "", amount: "", emoji: DEFAULT_TEMPTATION_EMOJI, category: DEFAULT_IMPULSE_CATEGORY });
    setShowCustomSpend(false);
  };

  const handleCoinEntrySubmit = useCallback(
    async ({ amountUSD, category, direction }) => {
      if (!Number.isFinite(amountUSD) || amountUSD <= 0) return;
      if (!category || !IMPULSE_CATEGORY_DEFS[category]) return;
      const action = direction === "save" ? "save" : "spend";
      const entryId = `coin_entry_${Date.now()}`;
      const categoryDef = IMPULSE_CATEGORY_DEFS[category];
      const title = action === "save" ? t("coinEntrySaveLabel") : t("coinEntrySpendLabel");
      const virtualItem = {
        id: entryId,
        title,
        emoji: categoryDef.emoji || "âœ¨",
        priceUSD: amountUSD,
        basePriceUSD: amountUSD,
        categories: [category],
        impulseCategoryOverride: category,
      };
      const entryContext = coinEntryContextRef.current || {};
      const entrySource = entryContext.source || "unknown";
      logEvent("coin_entry_submit", {
        source: entrySource,
        direction: action,
        amount_usd: amountUSD,
        category,
      });
      coinEntryContextRef.current = {
        source: entrySource,
        openedAt: entryContext.openedAt || Date.now(),
        submitted: true,
      };
      handleCoinEntryClose();
      if (action === "save") {
        const fallbackGoal =
          activeGoalId ||
          profile.goal ||
          mainGoalWish?.id ||
          (Array.isArray(profile.primaryGoals) ? profile.primaryGoals[0]?.id : null) ||
          getFallbackGoalId();
        await handleTemptationAction("save", virtualItem, {
          skipPrompt: true,
          goalId: fallbackGoal,
          shouldAssign: false,
          forcePrimaryGoal: true,
          forceOverlay: true,
        });
      } else {
        await handleTemptationAction("spend", virtualItem, {
          bypassSpendPrompt: true,
        });
      }
    },
    [
      activeGoalId,
      getFallbackGoalId,
      handleCoinEntryClose,
      handleTemptationAction,
      logEvent,
      mainGoalWish?.id,
      profile.goal,
      profile.primaryGoals,
      t,
    ]
  );

  const handleFabNewTemptation = useCallback(() => {
    triggerHaptic();
    closeFabMenu();
    setQuickSpendDraft({ title: "", amount: "", emoji: DEFAULT_TEMPTATION_EMOJI, category: DEFAULT_IMPULSE_CATEGORY });
    setShowCustomSpend(true);
  }, [closeFabMenu, triggerHaptic]);

  const handleFabNewGoal = useCallback(() => {
    triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    closeFabMenu();
    openNewGoalModal(false, "fab_menu");
  }, [closeFabMenu, openNewGoalModal, triggerHaptic]);

  const handleNewGoalChange = useCallback((field, value) => {
    setNewGoalModal((prev) => ({
      ...prev,
      [field]: field === "emoji" ? limitEmojiInput(value) : value,
    }));
  }, []);

  const handleNewGoalCancel = useCallback(() => {
    if (newGoalModal.visible) {
      logEvent("goal_creator_cancelled", {
        source: newGoalModal.source || "unknown",
        make_primary: newGoalModal.makePrimary ? 1 : 0,
      });
    }
    setNewGoalModal({
      visible: false,
      name: "",
      target: "",
      emoji: DEFAULT_GOAL_EMOJI,
      makePrimary: false,
      source: "unknown",
    });
  }, [logEvent, newGoalModal]);


  const handleNewGoalSubmit = useCallback(() => {
    const trimmedName = (newGoalModal.name || "").trim();
    if (!trimmedName) {
      Alert.alert("Almost", t("goalEditNameError"));
      return;
    }
    const parsedLocal = parseNumberInputValue(newGoalModal.target);
    if (!Number.isFinite(parsedLocal) || parsedLocal <= 0) {
      Alert.alert("Almost", t("goalEditTargetError"));
      return;
    }
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const targetUSD = convertFromCurrency(parsedLocal, currencyCode);
    const emoji = normalizeEmojiValue(newGoalModal.emoji, DEFAULT_GOAL_EMOJI);
    if (newGoalModal.makePrimary) {
      const goalId = `custom_goal_${Date.now()}`;
      const goalEntry = {
        id: goalId,
        targetUSD,
        customTitle: trimmedName,
        customEmoji: emoji,
        savedUSD: 0,
        status: "active",
        createdAt: Date.now(),
      };
      const existingGoals = Array.isArray(profile.primaryGoals) ? profile.primaryGoals : [];
      const nextPrimaryGoals = [
        goalEntry,
        ...existingGoals.filter((entry) => entry?.id && entry.id !== goalId),
      ];
      const activeTargetUSD = targetUSD > 0 ? targetUSD : getGoalDefaultTargetUSD(goalId);
      setProfile((prev) => ({
        ...prev,
        primaryGoals: nextPrimaryGoals,
        goal: goalId,
        goalTargetUSD: activeTargetUSD,
        goalCelebrated: false,
        goalRenewalPending: false,
      }));
      setProfileDraft((prev) => ({
        ...prev,
        primaryGoals: nextPrimaryGoals,
        goal: goalId,
        goalTargetUSD: activeTargetUSD,
        goalCelebrated: false,
        goalRenewalPending: false,
      }));
      setActiveGoalId(goalId);
      ensurePrimaryGoalWish(nextPrimaryGoals, language, goalId);
      logHistoryEvent("wish_added", {
        title: trimmedName,
        targetUSD,
        templateId: "manual_primary_goal",
        wishId: getPrimaryGoalWishId(goalId),
      });
      logEvent("goal_manual_created", {
        title: trimmedName,
        target_usd: targetUSD,
        currency: currencyCode,
        is_primary: 1,
      });
      logEvent("goal_created", {
        goal_id: goalId,
        goal_type: resolveGoalTypeFromTarget(targetUSD),
        target_amount: convertToCurrency(targetUSD, currencyCode),
      });
    } else {
      const newWish = {
        id: `wish-manual-${Date.now()}`,
        templateId: null,
        title: trimmedName,
        targetUSD,
        savedUSD: 0,
        status: "active",
        createdAt: Date.now(),
        autoManaged: false,
        emoji,
      };
      setWishes((prev) => insertWishAfterPrimary(prev, newWish));
      ensureActiveGoalForNewWish(newWish);
      logHistoryEvent("wish_added", { title: trimmedName, targetUSD, templateId: "manual_goal", wishId: newWish.id });
      logEvent("goal_manual_created", {
        title: trimmedName,
        target_usd: targetUSD,
        currency: currencyCode,
      });
      logEvent("goal_created", {
        goal_id: newWish.id,
        goal_type: resolveGoalTypeFromTarget(targetUSD),
        target_amount: convertToCurrency(targetUSD, currencyCode),
      });
    }
    triggerOverlayState("purchase", t("wishAdded", { title: trimmedName }));
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    dismissGoalRenewalPrompt();
    setNewGoalModal({
      visible: false,
      name: "",
      target: "",
      emoji: DEFAULT_GOAL_EMOJI,
      makePrimary: false,
      source: "unknown",
    });
  }, [
    dismissGoalRenewalPrompt,
    ensureActiveGoalForNewWish,
    ensurePrimaryGoalWish,
    language,
    logEvent,
    logHistoryEvent,
    newGoalModal,
    profile.primaryGoals,
    profile.currency,
    setProfile,
    setProfileDraft,
    setWishes,
    t,
    triggerHaptic,
    triggerOverlayState,
  ]);

  const openOnboardingGoalModal = useCallback(() => {
    triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    setOnboardingGoalModal({ visible: true, name: "", target: "", emoji: DEFAULT_GOAL_EMOJI });
  }, [triggerHaptic]);

  const handleOnboardingGoalChange = useCallback((field, value) => {
    setOnboardingGoalModal((prev) => ({
      ...prev,
      [field]: field === "emoji" ? limitEmojiInput(value) : value,
    }));
  }, []);

  const handleOnboardingGoalCancel = useCallback(() => {
    setOnboardingGoalModal({ visible: false, name: "", target: "", emoji: DEFAULT_GOAL_EMOJI });
  }, []);

  const handleOnboardingGoalSubmit = useCallback(() => {
    const trimmedName = (onboardingGoalModal.name || "").trim();
    if (!trimmedName) {
      Alert.alert("Almost", t("goalEditNameError"));
      return;
    }
    const parsedLocal = parseNumberInputValue(onboardingGoalModal.target);
    if (!Number.isFinite(parsedLocal) || parsedLocal <= 0) {
      Alert.alert("Almost", t("goalEditTargetError"));
      return;
    }
    const currencyCode = registrationData.currency || DEFAULT_PROFILE.currency;
    const targetUSD = convertFromCurrency(parsedLocal, currencyCode);
    const emoji = normalizeEmojiValue(onboardingGoalModal.emoji, DEFAULT_GOAL_EMOJI);
    const id = `custom_goal_${Date.now()}`;
    const formattedLocal = formatNumberInputValue(parsedLocal);
    goalSelectionTouchedRef.current = true;
    setRegistrationData((prev) => {
      const selections = prev.goalSelections || [];
      const nextSelections = selections.includes(id) ? selections : [...selections, id];
      return {
        ...prev,
        customGoals: [
          ...(prev.customGoals || []),
          { id, title: trimmedName, emoji, targetUSD, targetLocal: formattedLocal },
        ],
        goalSelections: nextSelections,
        goalTargetMap: {
          ...(prev.goalTargetMap || {}),
          [id]: formattedLocal,
        },
      };
    });
    logEvent("onboarding_goal_custom_created", {
      title: trimmedName,
      target_usd: targetUSD,
      currency: currencyCode,
    });
    logEvent("goal_created", {
      goal_id: id,
      goal_type: resolveGoalTypeFromTarget(targetUSD),
      target_amount: convertToCurrency(targetUSD, currencyCode),
    });
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    setOnboardingGoalModal({ visible: false, name: "", target: "", emoji: DEFAULT_GOAL_EMOJI });
  }, [onboardingGoalModal, registrationData.currency, setRegistrationData, t, triggerHaptic]);

  const handlePersonaSubmit = () => {
    if (!registrationData.persona) {
      Alert.alert("Almost", t("personaHabitLabel"));
      return;
    }
    triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    goToOnboardingStep("habit");
  };

  const handleHabitSubmit = (skip = false) => {
    let sanitizedFrequency = null;
    if (!skip) {
      if (!registrationData.customSpendTitle.trim()) {
        Alert.alert("Almost", t("customSpendTitle"));
        return;
      }
      const parsed = parseNumberInputValue(registrationData.customSpendAmount || "");
      if (!Number.isFinite(parsed) || parsed <= 0) {
        Alert.alert("Almost", t("customSpendAmountLabel"));
        return;
      }
      const frequencyValue = parseFloat(
        (registrationData.customSpendFrequency || "").replace(",", ".")
      );
      if (!Number.isFinite(frequencyValue) || frequencyValue <= 0) {
        Alert.alert("Almost", t("customSpendFrequencyLabel"));
        return;
      }
      sanitizedFrequency = Math.max(1, Math.round(frequencyValue));
      setRegistrationData((prev) => ({
        ...prev,
        customSpendFrequency: `${sanitizedFrequency}`,
      }));
    } else {
      setRegistrationData((prev) => ({
        ...prev,
        customSpendTitle: "",
        customSpendAmount: "",
        customSpendFrequency: "",
        customSpendCategory: DEFAULT_IMPULSE_CATEGORY,
      }));
    }
    const customAmountLocal = parseNumberInputValue(registrationData.customSpendAmount || "");
    const hasCustom =
      !skip &&
      registrationData.customSpendTitle.trim() &&
      Number.isFinite(customAmountLocal) &&
      customAmountLocal > 0;
    const customAmountUSD = hasCustom
      ? convertFromCurrency(customAmountLocal, registrationData.currency || DEFAULT_PROFILE.currency)
      : 0;
    const frequencyPerWeek = hasCustom ? sanitizedFrequency || 0 : 0;
    logEvent("onboarding_custom_spend", {
      has_custom: !!hasCustom,
      price_usd: customAmountUSD || 0,
      frequency_per_week: frequencyPerWeek,
    });
    triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    goToOnboardingStep("baseline");
  };

  const handleBaselineSubmit = () => {
    const currencyCode =
      registrationData.currency || profile.currency || DEFAULT_PROFILE.currency;
    const parsedLocal = parseNumberInputValue(registrationData.baselineMonthlyWaste || "");
    if (!Number.isFinite(parsedLocal) || parsedLocal <= 0) {
      Alert.alert("Almost", t("baselineInputError"));
      return;
    }
    triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    const timestamp = new Date().toISOString();
    setRegistrationData((prev) => ({
      ...prev,
      baselineMonthlyWaste: formatNumberInputValue(parsedLocal),
      baselineCapturedAt: timestamp,
    }));
    goToOnboardingStep("goal");
  };

  const handleBaselineSkip = () => {
    triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    setRegistrationData((prev) => ({
      ...prev,
      baselineMonthlyWaste: "",
      baselineCapturedAt: null,
    }));
    goToOnboardingStep("goal");
  };

  const handleBaselineSetupPrompt = () => {
    triggerHaptic();
    if (onboardingStep === "done") {
      openBaselinePrompt();
      return;
    }
    setRegistrationData((prev) => ({
      ...prev,
      currency: profile.currency || prev.currency || DEFAULT_PROFILE.currency,
      baselineMonthlyWaste: "",
      baselineCapturedAt: null,
    }));
    setOnboardingSkipLocked(true);
    goToOnboardingStep("baseline");
  };

  const handleGoalToggle = (goalId) => {
    triggerHaptic();
    goalSelectionTouchedRef.current = true;
    const currentSelections = registrationData.goalSelections || [];
    const wasSelected = currentSelections.includes(goalId);
    const preset = getGoalPreset(goalId);
    const customGoal = customGoalMap[goalId];
    setRegistrationData((prev) => {
      const selections = prev.goalSelections || [];
      const nextSelections = selections.includes(goalId)
        ? selections.filter((id) => id !== goalId)
        : [...selections, goalId];
      const currencyCode = prev.currency || DEFAULT_PROFILE.currency;
      const nextTargetMap = { ...(prev.goalTargetMap || {}) };
      if (selections.includes(goalId)) {
        delete nextTargetMap[goalId];
      } else {
        let defaultLocal = "";
        if (customGoal?.targetLocal) {
          defaultLocal = customGoal.targetLocal;
        } else if (Number.isFinite(customGoal?.targetUSD) && customGoal.targetUSD > 0) {
          defaultLocal = formatNumberInputValue(
            convertToCurrency(customGoal.targetUSD, currencyCode)
          );
        }
        if (!(goalId in nextTargetMap)) {
          nextTargetMap[goalId] = defaultLocal;
        }
      }
      const confirmed = (prev.goalTargetConfirmed || []).filter((id) => id !== goalId);
      return {
        ...prev,
        goalSelections: nextSelections,
        goalTargetMap: nextTargetMap,
        goalTargetConfirmed: confirmed,
      };
    });
    if (!wasSelected && onboardingStep !== "done") {
      logEvent("onboarding_goal_chosen", {
        goal_id: goalId,
        target_usd: customGoal?.targetUSD || 0,
      });
    }
  };

  const handleGoalTargetSubmit = async () => {
    const selections = registrationData.goalSelections || [];
    if (!selections.length) {
      logEvent("onboarding_goal_skipped", { method: "target_step_empty" });
      setRegistrationData((prev) => ({
        ...prev,
        goalTargetConfirmed: [],
      }));
      await handleGoalComplete(null);
      return;
    }
    const currencyCode = registrationData.currency || DEFAULT_PROFILE.currency;
    const targets = [];
    for (const goalId of selections) {
      const draftValue = registrationData.goalTargetMap?.[goalId];
      const parsedLocal = parseNumberInputValue(draftValue || "");
      if (!Number.isFinite(parsedLocal) || parsedLocal <= 0) {
        Alert.alert("Almost", t("goalTargetError"));
        return;
      }
      targets.push({
        id: goalId,
        usd: convertFromCurrency(parsedLocal, currencyCode),
      });
    }
    setRegistrationData((prev) => ({
      ...prev,
      goalTargetConfirmed: selections.slice(),
    }));
    await handleGoalComplete(targets);
  };

  const handleGoalTargetDraftChange = (goalId, value) => {
    setRegistrationData((prev) => ({
      ...prev,
      goalTargetMap: {
        ...(prev.goalTargetMap || {}),
        [goalId]: value,
      },
    }));
  };

  const handleGoalStageContinue = async () => {
    const selections = registrationData.goalSelections || [];
    if (!selections.length) {
      triggerHaptic();
      logEvent("onboarding_goal_skipped", { method: "empty_selection" });
      await handleGoalComplete(null);
      return;
    }
    const currentMap = registrationData.goalTargetMap || {};
    let patchedMap = null;
    let hasInvalidTarget = false;
    let firstInvalidGoalId = null;
    const currencyCode = registrationData.currency || DEFAULT_PROFILE.currency;
    const targets = [];
    for (const goalId of selections) {
      const workingMap = patchedMap || currentMap;
      const draftValue = workingMap[goalId];
      let parsedValue = parseNumberInputValue(draftValue || "");
      if (!Number.isFinite(parsedValue) || parsedValue <= 0) {
        const customGoal = customGoalMap[goalId];
        const fallbackValue = customGoal?.targetLocal || "";
        const fallbackParsed = parseNumberInputValue(fallbackValue || "");
        if (Number.isFinite(fallbackParsed) && fallbackParsed > 0) {
          if (!patchedMap) {
            patchedMap = { ...currentMap };
          }
          patchedMap[goalId] = fallbackValue;
          parsedValue = fallbackParsed;
        }
      }
      if (!Number.isFinite(parsedValue) || parsedValue <= 0) {
        if (!firstInvalidGoalId) {
          firstInvalidGoalId = goalId;
        }
        hasInvalidTarget = true;
        continue;
      }
      targets.push({
        id: goalId,
        usd: convertFromCurrency(parsedValue, currencyCode),
      });
    }
    if (hasInvalidTarget) {
      if (firstInvalidGoalId) {
        goalTargetFocusRef.current?.(firstInvalidGoalId);
      }
      Alert.alert("Almost", t("goalTargetError"));
      return;
    }
    triggerHaptic();
    setRegistrationData((prev) => ({
      ...prev,
      goalTargetMap: patchedMap
        ? {
            ...(prev.goalTargetMap || {}),
            ...patchedMap,
          }
        : prev.goalTargetMap || {},
      goalTargetConfirmed: selections.slice(),
    }));
    await handleGoalComplete(targets);
  };
  const handleGoalStageSkip = async () => {
    triggerHaptic();
    logEvent("onboarding_goal_skipped", { method: "skip_button" });
    goalSelectionTouchedRef.current = false;
    setRegistrationData((prev) => ({
      ...prev,
      goalSelections: [],
      goalTargetMap: {},
      goalTargetConfirmed: [],
    }));
    await handleGoalComplete(null);
  };

  const handleGoalComplete = async (targetsOverride = null) => {
    const selections = registrationData.goalSelections || [];
    const currencyCode = registrationData.currency || DEFAULT_PROFILE.currency;
    const dedupeTargetsById = (list = []) => {
      const map = new Map();
      list.forEach((entry) => {
        if (entry?.id && !map.has(entry.id)) {
          map.set(entry.id, entry);
        }
      });
      return Array.from(map.values());
    };
    let targets = [];
    if (Array.isArray(targetsOverride)) {
      targets = targetsOverride;
    } else if (selections.length) {
      targets = selections.map((goalId) => {
        const draftValue = registrationData.goalTargetMap?.[goalId];
        const parsedLocal = parseNumberInputValue(draftValue || "");
        const usd = Number.isFinite(parsedLocal) && parsedLocal > 0
          ? convertFromCurrency(parsedLocal, currencyCode)
          : getGoalDefaultTargetUSD(goalId);
        return { id: goalId, usd };
      });
    }
    targets = dedupeTargetsById(targets);
    const primaryGoals = targets.map((entry) => {
      const goalId = entry.id;
      const targetUSD = entry.usd > 0 ? entry.usd : getGoalDefaultTargetUSD(goalId);
      const customGoal = customGoalMap[goalId];
      const customTitle = typeof customGoal?.title === "string" ? customGoal.title.trim() : "";
      const base = {
        id: goalId,
        targetUSD,
        savedUSD: 0,
        status: "active",
        createdAt: Date.now(),
      };
      if (customTitle) {
        base.customTitle = customTitle;
      }
      if (customGoal?.emoji) {
        base.customEmoji = normalizeEmojiValue(customGoal.emoji, DEFAULT_GOAL_EMOJI);
      }
      return base;
    });
    const hasPrimaryGoal = primaryGoals.length > 0;
    const activeGoalTargetUSD =
      hasPrimaryGoal && Number.isFinite(primaryGoals[0]?.targetUSD) && primaryGoals[0].targetUSD > 0
        ? primaryGoals[0].targetUSD
        : 0;
    const firstNameValue = (registrationData.firstName || "").trim();
    const lastNameValue = (registrationData.lastName || "").trim();
    const mottoValue = (registrationData.motto || "").trim();
    const displayName = `${firstNameValue} ${lastNameValue}`.trim() || firstNameValue || "";
    const personaId = registrationData.persona || DEFAULT_PERSONA_ID;
    const gender = registrationData.gender || "none";
    logEvent("onboarding_profile_fields", {
      first_name_entered: firstNameValue.length > 0,
      last_name_entered: lastNameValue.length > 0,
      motto_entered: mottoValue.length > 0,
    });
    let customSpend = null;
    const customName = registrationData.customSpendTitle?.trim();
    const customAmount = parseNumberInputValue(registrationData.customSpendAmount || "");
    const customFrequency = parseFloat(
      (registrationData.customSpendFrequency || "").replace(",", ".")
    );
    if (customName && Number.isFinite(customAmount) && customAmount > 0) {
      const amountUSD = convertFromCurrency(customAmount, registrationData.currency);
      const manualPrecision = getManualInputPrecision(registrationData.customSpendAmount || "");
      const categoryValue =
        registrationData.customSpendCategory && IMPULSE_CATEGORY_DEFS[registrationData.customSpendCategory]
          ? registrationData.customSpendCategory
          : DEFAULT_IMPULSE_CATEGORY;
      customSpend = {
        title: customName,
        amountUSD,
        pricePrecision: manualPrecision,
        currency: registrationData.currency,
        frequencyPerWeek:
          Number.isFinite(customFrequency) && customFrequency > 0
            ? Math.round(customFrequency)
            : 0,
        impulseCategory: categoryValue,
      };
      logEvent("temptation_created", {
        temptation_id: profile.customSpend?.id || "custom_habit",
        is_custom: true,
        category: categoryValue,
        price: customAmount,
      });
    }
    if (customSpend) {
      schedulePrimaryTemptationPrompt();
    } else {
      markPrimaryTemptationPromptDone();
    }
    let spendingProfile = profile.spendingProfile || { ...DEFAULT_PROFILE.spendingProfile };
    const baselineLocal = parseNumberInputValue(registrationData.baselineMonthlyWaste || "");
    if (Number.isFinite(baselineLocal) && baselineLocal > 0) {
      spendingProfile = {
        baselineMonthlyWasteUSD: convertFromCurrency(baselineLocal, currencyCode),
        baselineStartAt: registrationData.baselineCapturedAt || new Date().toISOString(),
      };
    }
    const updatedProfile = {
      ...profile,
      name: displayName,
      firstName: registrationData.firstName,
      lastName: registrationData.lastName,
      subtitle: mottoValue || profile.subtitle,
      motto: mottoValue || profile.motto,
      avatar: registrationData.avatar || profile.avatar,
      currency: registrationData.currency,
      goal: hasPrimaryGoal ? primaryGoals[0]?.id : null,
      primaryGoals,
      goalTargetUSD: activeGoalTargetUSD,
      goalCelebrated: false,
      persona: personaId,
      gender,
      customSpend,
      spendingProfile,
      joinedAt: profile.joinedAt || new Date().toISOString(),
      goalRenewalPending: false,
    };
    setProfile(updatedProfile);
    setProfileDraft(updatedProfile);
    setActiveGoalId(updatedProfile.goal);
    await AsyncStorage.setItem(STORAGE_KEYS.PROFILE, JSON.stringify(updatedProfile)).catch(() => {});
    await AsyncStorage.setItem(STORAGE_KEYS.ONBOARDING, "done").catch(() => {});
    setSavedTotalUSD(0);
    setLifetimeSavedUSD(0);
    setLastCelebratedLevel(1);
    previousPlayerLevelRef.current = 1;
    setHistoryEvents([]);
    setDeclineCount(0);
    setDecisionStats({ ...INITIAL_DECISION_STATS });
    setRefuseStats({});
    AsyncStorage.multiSet([
      [STORAGE_KEYS.SAVED_TOTAL, "0"],
      [STORAGE_KEYS.SAVED_TOTAL_PEAK, "0"],
      [STORAGE_KEYS.LAST_CELEBRATED_LEVEL, "1"],
      [STORAGE_KEYS.HISTORY, "[]"],
      [STORAGE_KEYS.DECLINES, "0"],
      [STORAGE_KEYS.DECISION_STATS, JSON.stringify({ ...INITIAL_DECISION_STATS })],
      [STORAGE_KEYS.REFUSE_STATS, "{}"],
    ]).catch(() => {});
    await AsyncStorage.setItem(STORAGE_KEYS.TUTORIAL, "pending").catch(() => {});
    await AsyncStorage.setItem(STORAGE_KEYS.TEMPTATION_TUTORIAL, "pending").catch(() => {});
    setTutorialSeen(false);
    setTemptationTutorialSeen(false);
    setTemptationTutorialStatus("pending");
    setTemptationTutorialVisible(false);
    setTemptationTutorialStepIndex(0);
    setTemptationTutorialQueued(true);
    setTemptationTutorialCompleted(false);
    setFabTutorialVisible(false);
    setFabTutorialStateAndPersist(FAB_TUTORIAL_STATUS.PENDING);
    setFabTutorialEligible(false);
    homeSessionRef.current.sessionCount = 0;
    homeSessionRef.current.pendingIndex = null;
    homeSessionRef.current.dateKey = getDayKey(Date.now());
    setActiveCurrency(updatedProfile.currency);
    ensurePrimaryGoalWish(primaryGoals, language, updatedProfile.goal);
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    const startBalanceLocal = convertToCurrency(
      savedTotalUSD || 0,
      updatedProfile.currency || DEFAULT_PROFILE.currency
    );
    logEvent("onboarding_completed", {
      persona_id: personaId,
      goal_id: primaryGoals[0]?.id || "none",
      has_goal: hasPrimaryGoal,
      start_balance: startBalanceLocal,
      skipped: onboardingSkippedRef.current ? 1 : 0,
    });
    setTimeout(() => {
      if (analyticsOptOut === null) {
        analyticsConsentGateRef.current = true;
        goToOnboardingStep("analytics_consent", { recordHistory: false, resetHistory: true });
      } else {
        goToOnboardingStep("push_optin", { recordHistory: false, resetHistory: true });
      }
      setRegistrationData(INITIAL_REGISTRATION);
      goalSelectionTouchedRef.current = false;
      onboardingSkippedRef.current = false;
    }, 500);
  };

  const requestTrackingTransparencyIfNeeded = useCallback(async () => {
    if (Platform.OS !== "ios") return null;
    if (!TrackingTransparency) return null;
    const getter = TrackingTransparency.getTrackingPermissionsAsync;
    const requester = TrackingTransparency.requestTrackingPermissionsAsync;
    if (typeof getter !== "function" || typeof requester !== "function") return null;
    try {
      const current = await getter();
      const status = current?.status;
      if (status && status !== "undetermined" && status !== "not-determined") {
        return status;
      }
      const result = await requester();
      return result?.status || status || null;
    } catch (error) {
      console.warn("tracking transparency", error);
      return null;
    }
  }, []);

  const handleAnalyticsConsentComplete = async (allowAnalytics) => {
    markStartupLogoDismissed();
    await requestTrackingTransparencyIfNeeded();
    const optOut = !allowAnalytics;
    setAnalyticsOptOutState(optOut);
    setAnalyticsOptOutFlag(optOut);
    AsyncStorage.setItem(
      STORAGE_KEYS.ANALYTICS_OPT_OUT,
      optOut ? "1" : "0"
    ).catch(() => {});
    logEvent("consent_analytics_enabled", { enabled: allowAnalytics, source: "onboarding" });
    if (analyticsConsentGateRef.current) {
      analyticsConsentGateRef.current = false;
      goToOnboardingStep("push_optin", { recordHistory: false, resetHistory: true });
      return;
    }
    goToOnboardingStep("guide");
  };

  const handleOnboardingNotificationsContinue = async () => {
    triggerHaptic();
    await ensureNotificationPermission();
    goToOnboardingStep("done", { recordHistory: false, resetHistory: true });
  };

  const handleOnboardingSkip = useCallback(async () => {
    if (!canShowOnboardingSkip) return;
    onboardingSkippedRef.current = true;
    logEvent("onboarding_skipped", { from_step: onboardingStep });
    await handleGoalComplete(null);
  }, [canShowOnboardingSkip, handleGoalComplete, logEvent, onboardingStep]);

  const ensureMediaPermission = async (type) => {
    if (type === "library" && Platform.OS === "android") {
      return true;
    }
    const getter =
      type === "camera"
        ? ImagePicker.getCameraPermissionsAsync
        : ImagePicker.getMediaLibraryPermissionsAsync;
    const requester =
      type === "camera"
        ? ImagePicker.requestCameraPermissionsAsync
        : ImagePicker.requestMediaLibraryPermissionsAsync;

    const current = await getter();
    if (current?.granted) return true;
    const requestResult = await requester();
    if (requestResult?.granted) return true;

    Alert.alert(
      "Almost",
      requestResult?.canAskAgain ? t("photoPermissionDenied") : t("photoPermissionSettings"),
      [
        {
          text: t("profileCancel"),
          style: "cancel",
        },
        !requestResult?.canAskAgain
          ? {
              text: t("openSettings"),
              onPress: () => Linking.openSettings?.(),
            }
          : null,
      ].filter(Boolean)
    );
    return false;
  };

  const persistAvatarUri = useCallback(async (uri, fileName) => {
    if (!uri || typeof uri !== "string") return uri;
    const documentDir = FileSystem.documentDirectory;
    if (!documentDir) return uri;
    if (uri.startsWith(documentDir)) return uri;
    const isFileUri = uri.startsWith("file://");
    const isContentUri = uri.startsWith("content://");
    if (!isFileUri && !isContentUri) return uri;
    if (isFileUri) {
      const fileInfo = await FileSystem.getInfoAsync(uri).catch(() => null);
      if (!fileInfo?.exists) return uri;
    }
    const targetDir = `${documentDir}profile-avatars/`;
    await FileSystem.makeDirectoryAsync(targetDir, { intermediates: true }).catch(() => {});
    const cleanedUri = uri.split("?")[0];
    const cleanedName = typeof fileName === "string" ? fileName.split("?")[0] : "";
    const fileNameMatch = cleanedName.match(/\.([a-zA-Z0-9]+)$/);
    const extensionMatch = cleanedUri.match(/\.([a-zA-Z0-9]+)$/);
    const extension = (fileNameMatch?.[1] || extensionMatch?.[1] || "jpg").toLowerCase();
    const generatedName = `avatar-${Date.now()}-${Math.random().toString(16).slice(2)}.${extension}`;
    const targetUri = `${targetDir}${generatedName}`;
    try {
      await FileSystem.copyAsync({ from: uri, to: targetUri });
      return targetUri;
    } catch (error) {
      console.warn("avatar persist", error);
      return uri;
    }
  }, []);

  useEffect(() => {
    if (!profileHydrated) return;
    let cancelled = false;
    const migrateAvatar = async () => {
      const currentAvatar = profile?.avatar;
      if (!currentAvatar || typeof currentAvatar !== "string") return;
      if (!currentAvatar.startsWith("file://") && !currentAvatar.startsWith("content://")) return;
      const documentDir = FileSystem.documentDirectory;
      if (!documentDir || currentAvatar.startsWith(documentDir)) return;
      if (currentAvatar.startsWith("file://")) {
        const info = await FileSystem.getInfoAsync(currentAvatar).catch(() => null);
        if (!info?.exists) return;
      }
      const persistedUri = await persistAvatarUri(currentAvatar);
      if (!persistedUri || persistedUri === currentAvatar || cancelled) return;
      setProfile((prev) => (prev?.avatar === currentAvatar ? { ...prev, avatar: persistedUri } : prev));
      setProfileDraft((prev) => (prev?.avatar === currentAvatar ? { ...prev, avatar: persistedUri } : prev));
      setRegistrationData((prev) =>
        prev?.avatar === currentAvatar ? { ...prev, avatar: persistedUri } : prev
      );
    };
    migrateAvatar();
    return () => {
      cancelled = true;
    };
  }, [profileHydrated, profile?.avatar, persistAvatarUri]);

  const pickImage = async (source = "library", onPicked) => {
    try {
      triggerHaptic();
      const type = source === "camera" ? "camera" : "library";
      const permitted = await ensureMediaPermission(type);
      if (!permitted) return;
      const pickerOptions = {
        mediaTypes: ["images"],
        quality: 0.8,
        ...(SHOULD_USE_ANDROID_LEGACY_MEDIA_PICKER ? { legacy: true } : {}),
      };
      const result =
        source === "camera"
          ? await ImagePicker.launchCameraAsync(pickerOptions)
          : await ImagePicker.launchImageLibraryAsync(pickerOptions);
      if (!result.canceled && result.assets?.length) {
        const asset = result.assets[0];
        const persistedUri = await persistAvatarUri(asset.uri, asset.fileName);
        onPicked?.(persistedUri);
      }
    } catch (error) {
      const errorMessage =
        error?.message && error.message.includes("canceled")
          ? null
          : `${t("photoPickerError")}\n${error?.message || ""}`.trim();
      if (errorMessage) {
        Alert.alert("Almost", errorMessage);
      }
      console.warn("image picker", error);
    }
  };

  const registerSmartReminder = useCallback(
    async (entry) => {
      if (!entry) return;
      if (!["refuse_spend", "pending_to_decline", "spend"].includes(entry.kind)) return;
      const timestamp = Number(entry.timestamp) || Date.now();
      const now = Date.now();
      const baseTriggerTime = timestamp + SMART_REMINDER_DELAY_MS;
      if (!Number.isFinite(baseTriggerTime) || baseTriggerTime <= now) return;
      // Space reminders so Android does not deliver multiple notifications at once.
      const futureReminders = (smartRemindersRef.current || []).filter((reminder) => {
        const scheduledAt = Number(reminder?.scheduledAt);
        return Number.isFinite(scheduledAt) && scheduledAt > now;
      });
      const lastScheduledFromState = futureReminders.reduce(
        (latest, reminder) => Math.max(latest, Number(reminder.scheduledAt) || 0),
        0
      );
      const inferredTail =
        smartReminderScheduleTailRef.current > now ? smartReminderScheduleTailRef.current : 0;
      const lastScheduledAt = Math.max(lastScheduledFromState, inferredTail);
      const triggerTime =
        lastScheduledAt > 0
          ? Math.max(baseTriggerTime, lastScheduledAt + SMART_REMINDER_MIN_INTERVAL_MS)
          : baseTriggerTime;
      const permitted = await ensureNotificationPermission({ request: false });
      if (!permitted) return;
      const templateId = entry.meta?.templateId || entry.meta?.id || entry.meta?.template_id;
      const metaTitle =
        (typeof entry.meta?.title === "string" && entry.meta.title.trim()) ||
        resolveTemplateTitle(templateId, "") ||
        "";
      const title = metaTitle || t("defaultDealTitle");
      const isSpendEvent = entry.kind === "spend";
      const dedupeKey = `smart:${entry.id || timestamp}`;
      try {
        const scheduledEntry = await scheduleNotificationWithCooldown({
          content: {
            title: isSpendEvent
              ? t("smartInsightSpendTitle", { temptation: title })
              : t("smartInsightDeclineTitle", { temptation: title }),
            body: isSpendEvent
              ? t("smartInsightSpendBody", { temptation: title })
            : t("smartInsightDeclineBody", { temptation: title }),
            data: {
              kind: "smart_insight",
              templateId: templateId || null,
              dedupeKey,
            },
          },
          trigger: new Date(triggerTime),
        });
        const notificationId = scheduledEntry?.id || null;
        const scheduledFor = Number(scheduledEntry?.scheduledFor) || triggerTime;
        if (notificationId) {
          smartReminderScheduleTailRef.current = scheduledFor;
          const payload = {
            id: `smart-${entry.id}`,
            eventId: entry.id,
            kind: entry.kind,
            title,
            timestamp,
            scheduledAt: scheduledFor,
            notificationId,
            templateId: templateId || null,
          };
          setSmartReminders((prev) => normalizeSmartReminderEntries([payload, ...prev]));
        }
      } catch (error) {
        console.warn("smart reminder schedule", error);
      }
    },
    [
      ensureNotificationPermission,
      resolveTemplateTitle,
      scheduleNotificationWithCooldown,
      setSmartReminders,
      t,
    ]
  );

  const cancelSameDaySmartReminders = useCallback(
    async (templateId, dayKey) => {
      if (!templateId || !dayKey) return;
      const reminders = Array.isArray(smartRemindersRef.current) ? smartRemindersRef.current : [];
      const keep = [];
      const toCancel = [];
      reminders.forEach((reminder) => {
        const reminderDay =
          reminder?.scheduledAt && Number.isFinite(reminder.scheduledAt)
            ? getDayKey(reminder.scheduledAt)
            : null;
        if (reminder?.templateId === templateId && reminderDay === dayKey) {
          if (reminder.notificationId) {
            toCancel.push(reminder.notificationId);
          }
        } else {
          keep.push(reminder);
        }
      });
      if (toCancel.length) {
        await Promise.all(
          toCancel.map((id) => Notifications.cancelScheduledNotificationAsync(id).catch(() => {}))
        );
      }
      if (toCancel.length) {
        setSmartReminders(normalizeSmartReminderEntries(keep));
      }
    },
    [setSmartReminders]
  );

  const logHistoryEvent = useCallback(
    (kind, meta = {}) => {
      const timestamp = Date.now();
      const templateId =
        meta?.templateId || meta?.template_id || meta?.id || meta?.template || meta?.templateId;
      const dayKey = getDayKey(timestamp);
      if (templateId) {
        cancelSameDaySmartReminders(templateId, dayKey);
      }
      const normalizedMeta =
        templateId && !meta.templateId && !meta.template_id ? { ...meta, templateId } : meta;
      const entry = {
        id: `history-${timestamp}-${Math.random().toString(16).slice(2, 6)}`,
        kind,
        meta: normalizedMeta,
        timestamp,
      };
      setHistoryEvents((prev) => {
        const next = [entry, ...prev].filter((item) => {
          if (!item?.timestamp) return false;
          return timestamp - item.timestamp <= HISTORY_RETENTION_MS;
        });
        return next.slice(0, MAX_HISTORY_EVENTS);
      });
      setChallengesState((prev) => applyChallengeEvent(prev, entry));
      registerSmartReminder(entry);
    },
    [cancelSameDaySmartReminders, registerSmartReminder, setChallengesState]
  );

  const recomputeHistoryAggregates = useCallback(
    (list) => {
      let nextDeclines = 0;
      let resolvedToWishes = 0;
      let resolvedToDeclines = 0;
      const nextRefuseStats = {};
      (list || []).forEach((entry) => {
        if (!entry) return;
        if (entry.kind === "refuse_spend") {
          const amount = Math.max(0, Number(entry.meta?.amountUSD) || 0);
          nextDeclines += 1;
          const templateId =
            entry.meta?.templateId || entry.meta?.id || entry.meta?.title || "unknown";
          const current = nextRefuseStats[templateId] || {
            count: 0,
            totalUSD: 0,
            lastSavedAt: 0,
            lastSavedAmountUSD: 0,
          };
          current.count += 1;
          current.totalUSD += amount;
          if (!current.lastSavedAt || (entry.timestamp || 0) > current.lastSavedAt) {
            current.lastSavedAt = entry.timestamp || 0;
            current.lastSavedAmountUSD = amount;
          }
          nextRefuseStats[templateId] = current;
        } else if (entry.kind === "pending_to_wish") {
          resolvedToWishes += 1;
        } else if (entry.kind === "pending_to_decline") {
          resolvedToDeclines += 1;
        }
      });
      const chronologicalEntries = (Array.isArray(list) ? list : [])
        .filter((entry) => entry?.meta?.templateId && Number.isFinite(entry.timestamp))
        .sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
      const streakTracker = {};
      chronologicalEntries.forEach((entry) => {
        const templateId = entry.meta.templateId;
        const prev = streakTracker[templateId] || {
          current: 0,
          best: 0,
          lastAction: null,
          lostAt: null,
          recoverable: 0,
          recoverableAmountUSD: 0,
        };
        if (entry.kind === "refuse_spend") {
          const nextCurrent = prev.lastAction === "save" ? prev.current + 1 : 1;
          streakTracker[templateId] = {
            current: nextCurrent,
            best: Math.max(prev.best, nextCurrent),
            lastAction: "save",
            lostAt: null,
            recoverable: 0,
            recoverableAmountUSD: 0,
          };
        } else if (entry.kind === "spend") {
          const previousRecoverable =
            prev.lastAction === "save" ? prev.current : prev.recoverable || 0;
          const spendAmountUSD = Math.max(0, Number(entry.meta?.amountUSD) || 0);
          streakTracker[templateId] = {
            current: 0,
            best: Math.max(prev.best, prev.current),
            lastAction: "spend",
            lostAt: entry.timestamp || null,
            recoverable: previousRecoverable,
            recoverableAmountUSD: spendAmountUSD || prev.recoverableAmountUSD || 0,
          };
        } else if (entry.kind === "streak_restore") {
          const restoredValue = Math.max(
            0,
            Number(entry.meta?.restoredStreak) ||
              prev.recoverable ||
              prev.current ||
              0
          );
          streakTracker[templateId] = {
            current: restoredValue,
            best: Math.max(prev.best, restoredValue),
            lastAction: "save",
            lostAt: null,
            recoverable: 0,
            recoverableAmountUSD: 0,
          };
        } else {
          streakTracker[templateId] = prev;
        }
      });
      Object.entries(streakTracker).forEach(([templateId, streak]) => {
        const base = nextRefuseStats[templateId] || {
          count: 0,
          totalUSD: 0,
          lastSavedAt: 0,
          lastSavedAmountUSD: 0,
          recoverableStreak: 0,
          recoverableAmountUSD: 0,
        };
        const recoverableStreakValue =
          streak.lastAction === "spend" ? Math.max(streak.recoverable || 0, 0) : 0;
        const recoverableAmountValue =
          streak.lastAction === "spend" ? Math.max(streak.recoverableAmountUSD || 0, 0) : 0;
        nextRefuseStats[templateId] = {
          ...base,
          currentStreak: streak.lastAction === "save" ? streak.current : 0,
          bestStreak: Math.max(base.bestStreak || 0, streak.best),
          lastAction: streak.lastAction,
          streakLostAt: streak.lastAction === "spend" ? streak.lostAt : null,
          recoverableStreak: recoverableStreakValue,
          recoverableAmountUSD: recoverableAmountValue,
        };
      });
      setDeclineCount(nextDeclines);
      setRefuseStats(nextRefuseStats);
      setDecisionStats((prev) => ({
        ...prev,
        resolvedToWishes,
        resolvedToDeclines,
      }));
    },
    [setDeclineCount, setDecisionStats, setRefuseStats, setSavedTotalUSD]
  );

  const computeSavingsTotals = useCallback(
    (list, shouldReduceSpends = spendReducesSavings) => {
      const normalized = Array.isArray(list) ? list.filter(Boolean) : [];
      if (!normalized.length) {
        return { running: 0, peak: 0 };
      }
      const sorted = normalized.slice().sort((a, b) => {
        const aStamp = typeof a?.timestamp === "number" ? a.timestamp : 0;
        const bStamp = typeof b?.timestamp === "number" ? b.timestamp : 0;
        return aStamp - bStamp;
      });
      let running = 0;
      let peak = 0;
      sorted.forEach((entry) => {
        if (!entry?.kind) return;
        const amount = Math.max(0, Number(entry?.meta?.amountUSD) || 0);
        if (!amount) return;
        if (HISTORY_SAVED_GAIN_EVENTS.has(entry.kind)) {
          running += amount;
        } else if (shouldReduceSpends && HISTORY_SAVED_LOSS_EVENTS.has(entry.kind)) {
          running -= amount;
        }
        if (running < 0) running = 0;
        if (running > peak) peak = running;
      });
      return { running, peak };
    },
    [spendReducesSavings]
  );

  const rebuildSavingsFromHistory = useCallback(
    (list, shouldReduceSpends = spendReducesSavings) => {
      const { running, peak } = computeSavingsTotals(list, shouldReduceSpends);
      setSavedTotalUSD(running);
      setLifetimeSavedUSD(peak);
      const currentLevel = getTierProgress(
        Math.max(running, peak),
        profile.currency || DEFAULT_PROFILE.currency
      ).level;
      persistLastCelebratedLevel(currentLevel);
      previousPlayerLevelRef.current = currentLevel;
      return { running, peak };
    },
    [
      computeSavingsTotals,
      persistLastCelebratedLevel,
      profile.currency,
      setLifetimeSavedUSD,
      setSavedTotalUSD,
      spendReducesSavings,
    ]
  );

  const handleSpendImpactToggle = useCallback(
    (enabled) => {
      const nextValue = !!enabled;
      triggerHaptic();
      setProfile((prev) => ({ ...prev, spendReducesSavings: nextValue }));
      setProfileDraft((prev) => ({ ...prev, spendReducesSavings: nextValue }));
      const totals = rebuildSavingsFromHistory(resolvedHistoryEvents, nextValue);
      if (totals && typeof totals.running === "number") {
        rebalanceWishesFromSavedTotal();
      }
      logEvent("spend_impact_toggle", { enabled: nextValue ? 1 : 0 });
    },
    [logEvent, rebuildSavingsFromHistory, rebalanceWishesFromSavedTotal, resolvedHistoryEvents, triggerHaptic]
  );
  const handleSoundToggle = useCallback(
    (enabled) => {
      const nextValue = !!enabled;
      triggerHaptic();
      setSoundEnabled(nextValue);
      if (!nextValue) {
        stopAllSounds();
      }
      AsyncStorage.setItem(STORAGE_KEYS.SOUND_ENABLED, nextValue ? "1" : "0").catch(() => {});
      logEvent("sound_toggle", { enabled: nextValue ? 1 : 0 });
    },
    [logEvent, stopAllSounds, triggerHaptic]
  );

  const normalizeHistoryGoalId = useCallback(
    (goalId) => {
      if (!goalId || typeof goalId !== "string") return null;
      if (goalId.startsWith("wish_primary_goal_")) return goalId;
      const isPrimary =
        (Array.isArray(profile.primaryGoals) &&
          profile.primaryGoals.some((goal) => goal?.id === goalId)) ||
        profile.goal === goalId;
      return isPrimary ? getPrimaryGoalWishId(goalId) : goalId;
    },
    [profile.goal, profile.primaryGoals]
  );

  const applyHistoryGoalDelta = useCallback(
    (rawGoalId, deltaUSD) => {
      if (!rawGoalId || !Number.isFinite(deltaUSD) || deltaUSD === 0) return;
      const normalizedGoalId = normalizeHistoryGoalId(rawGoalId);
      if (!normalizedGoalId) return;
      if (normalizedGoalId.startsWith("wish_primary_goal_")) {
        const goalId = normalizedGoalId.replace("wish_primary_goal_", "");
        const primaryEntry = Array.isArray(profile.primaryGoals)
          ? profile.primaryGoals.find((goal) => goal?.id === goalId)
          : null;
        const primaryWish =
          Array.isArray(wishesRef.current) &&
          wishesRef.current.find(
            (wish) => wish?.id === normalizedGoalId || wish?.goalId === goalId
          );
        const currentSaved = Number.isFinite(primaryEntry?.savedUSD)
          ? primaryEntry.savedUSD
          : Number.isFinite(primaryWish?.savedUSD)
          ? primaryWish.savedUSD
          : 0;
        const targetUSD =
          Number.isFinite(primaryEntry?.targetUSD) && primaryEntry.targetUSD > 0
            ? primaryEntry.targetUSD
            : Number.isFinite(primaryWish?.targetUSD) && primaryWish.targetUSD > 0
            ? primaryWish.targetUSD
            : profile.goal === goalId &&
              Number.isFinite(profile.goalTargetUSD) &&
              profile.goalTargetUSD > 0
            ? profile.goalTargetUSD
            : getGoalDefaultTargetUSD(goalId);
        const nextSaved = Math.max(0, currentSaved + deltaUSD);
        const nextStatus = targetUSD > 0 && nextSaved >= targetUSD ? "done" : "active";
        syncPrimaryGoalProgress(goalId, nextSaved, nextStatus);
        return;
      }
      setWishes((prev) => {
        let changed = false;
        const next = prev.map((wish) => {
          if (!wish) return wish;
          if (wish.id !== normalizedGoalId && wish.goalId !== normalizedGoalId) return wish;
          const targetUSD =
            Number.isFinite(wish.targetUSD) && wish.targetUSD > 0
              ? wish.targetUSD
              : getGoalDefaultTargetUSD(wish.goalId || wish.id);
          const previousSaved = Number.isFinite(wish.savedUSD) ? wish.savedUSD : 0;
          const nextSaved = Math.max(0, previousSaved + deltaUSD);
          const nextStatus = targetUSD > 0 && nextSaved >= targetUSD ? "done" : "active";
          if (nextSaved !== previousSaved || nextStatus !== wish.status) {
            changed = true;
            return { ...wish, savedUSD: nextSaved, status: nextStatus };
          }
          return wish;
        });
        return changed ? next : prev;
      });
    },
    [
      normalizeHistoryGoalId,
      profile.goal,
      profile.goalTargetUSD,
      profile.primaryGoals,
      setWishes,
      syncPrimaryGoalProgress,
    ]
  );

  const handleHistoryDelete = useCallback(
    (entry) => {
      if (!entry) return;
      const entryId = entry.id;
      const amountUSD = Math.max(0, Number(entry.meta?.amountUSD) || 0);
      const resolveHistoryGoalId = () => {
        const meta = entry.meta || {};
        const storedGoalId =
          meta.goalId || meta.goal_id || meta.savingTargetId || meta.saving_target_id || null;
        if (storedGoalId) return storedGoalId;
        const templateId = meta.templateId || meta.id || null;
        return templateId ? resolveTemptationGoalId(templateId) : null;
      };
      if (entry.kind === "refuse_spend") {
        const metaCoinReward = Math.max(0, Number(entry.meta?.coinReward) || 0);
        const resolvedCurrency = entry.meta?.currency || profile.currency || DEFAULT_PROFILE.currency;
        const coinRefund = metaCoinReward > 0
          ? metaCoinReward
          : computeRefuseCoinReward(amountUSD, resolvedCurrency);
        if (coinRefund > 0) {
          setHealthPoints((prev) => Math.max(0, prev - coinRefund));
        }
        const targetGoalId = resolveHistoryGoalId();
        if (targetGoalId) {
          applyHistoryGoalDelta(targetGoalId, -amountUSD);
        }
      }
      if (amountUSD > 0) {
        if (entry.kind === "refuse_spend") {
          setSavedTotalUSD((prev) => Math.max(0, prev - amountUSD));
        } else if (entry.kind === "spend" && spendReducesSavings) {
          setSavedTotalUSD((prev) => Math.max(0, prev + amountUSD));
        }
      }
      setHistoryEvents((prev) => {
        const next = prev.filter((h) => h.id !== entryId);
        AsyncStorage.setItem(STORAGE_KEYS.HISTORY, JSON.stringify(next)).catch(() => {});
        setChallengesState((prevState) => rebuildChallengeProgressFromHistory(next, prevState));
        return next;
      });
      if (entry.kind === "pending_added" && entry.meta?.pendingId) {
        setPendingList((prev) => prev.filter((p) => p.id !== entry.meta.pendingId));
      }
      if (entry.kind === "wish_added" && entry.meta?.wishId) {
        setWishes((prev) => prev.filter((w) => w.id !== entry.meta.wishId));
      }
    },
    [
      applyHistoryGoalDelta,
      profile.currency,
      resolveTemptationGoalId,
      setPendingList,
      setWishes,
      setHealthPoints,
      setSavedTotalUSD,
      setChallengesState,
      spendReducesSavings,
    ]
  );

  useEffect(() => {
    recomputeHistoryAggregates(resolvedHistoryEvents);
  }, [resolvedHistoryEvents, recomputeHistoryAggregates]);
  const maybeTriggerNorthStarMetric = useCallback(() => {
    if (!northStarHydrated || !profileHydrated || northStarLoggedRef.current) return;
    if (!profileJoinedAt) return;
    const joinedAtTimestamp = new Date(profileJoinedAt).getTime();
    if (!Number.isFinite(joinedAtTimestamp)) return;
    const windowEnd = joinedAtTimestamp + NORTH_STAR_WINDOW_MS;
    let savesInWindow = 0;
    resolvedHistoryEvents.forEach((entry) => {
      if (entry?.kind !== "refuse_spend") return;
      const eventTimestamp = typeof entry.timestamp === "number" ? entry.timestamp : 0;
      if (!eventTimestamp) return;
      if (eventTimestamp >= joinedAtTimestamp && eventTimestamp <= windowEnd) {
        savesInWindow += 1;
      }
    });
    if (savesInWindow < NORTH_STAR_SAVE_THRESHOLD) return;
    const hoursSinceJoinRaw = Math.max(0, (Date.now() - joinedAtTimestamp) / (1000 * 60 * 60));
    const hoursSinceJoin = Math.min(24, Math.round(hoursSinceJoinRaw * 10) / 10);
    setNorthStarLogged(true);
    northStarLoggedRef.current = true;
    AsyncStorage.setItem(
      STORAGE_KEYS.NORTH_STAR_METRIC,
      JSON.stringify({
        logged: true,
        loggedAt: new Date().toISOString(),
        savesInWindow,
        northStar2Logged: northStar2LoggedRef.current,
      })
    ).catch(() => {});
    logEvent("north_star_two_saves", {
      saves_in_window: savesInWindow,
      hours_since_join: hoursSinceJoin,
    });
  }, [logEvent, northStarHydrated, profileHydrated, profileJoinedAt, resolvedHistoryEvents]);
  useEffect(() => {
    maybeTriggerNorthStarMetric();
  }, [maybeTriggerNorthStarMetric]);

  const maybeTriggerNorthStar2 = useCallback(() => {
    if (!northStarHydrated || !profileHydrated || northStar2LoggedRef.current) return;
    const decisionKinds = new Set([
      "refuse_spend",
      "spend",
      "pending_added",
      "pending_to_wish",
      "pending_to_decline",
    ]);
    const dayKeys = new Set();
    let decisionsTotal = 0;
    resolvedHistoryEvents.forEach((entry) => {
      if (!entry || !decisionKinds.has(entry.kind)) return;
      const ts = Number(entry.timestamp) || 0;
      if (!ts) return;
      const dayKey = getDayKey(ts);
      if (!dayKey) return;
      dayKeys.add(dayKey);
      decisionsTotal += 1;
    });
    if (dayKeys.size < 2) return;
    setNorthStar2Logged(true);
    northStar2LoggedRef.current = true;
    AsyncStorage.setItem(
      STORAGE_KEYS.NORTH_STAR_METRIC,
      JSON.stringify({
        logged: northStarLoggedRef.current,
        loggedAt: northStarLoggedRef.current ? new Date().toISOString() : null,
        northStar2Logged: true,
        northStar2LoggedAt: new Date().toISOString(),
        decisionsTotal,
        decisionDays: dayKeys.size,
      })
    ).catch(() => {});
    logEvent("north_star2", {
      decision_days: dayKeys.size,
      decisions_total: decisionsTotal,
    });
  }, [logEvent, northStarHydrated, profileHydrated, resolvedHistoryEvents]);
  useEffect(() => {
    maybeTriggerNorthStar2();
  }, [maybeTriggerNorthStar2]);

  const triggerCardFeedback = useCallback((templateId) => {
    if (!templateId) return;
    const burstKey = Date.now();
    setCardFeedback((prev) => ({
      ...prev,
      [templateId]: {
        ...(prev[templateId] || {}),
        message: true,
        burstKey,
      },
    }));
    if (cardFeedbackTimers.current[templateId]) {
      clearTimeout(cardFeedbackTimers.current[templateId]);
    }
    cardFeedbackTimers.current[templateId] = setTimeout(() => {
      setCardFeedback((prev) => {
        const entry = prev[templateId];
        if (!entry) return prev;
        return {
          ...prev,
          [templateId]: {
            ...entry,
            message: false,
          },
        };
      });
      delete cardFeedbackTimers.current[templateId];
    }, 2000);
  }, []);

  const triggerCoinHaptics = useCallback(() => {
    triggerCoinRewardHaptics();
    playSound("coin");
  }, [playSound]);

  const closeSpendPrompt = useCallback(() => {
    spendPromptLockRef.current = false;
    setSpendPrompt({ visible: false, item: null });
  }, []);

  const processMascotQueue = useCallback(() => {
    if (overlay || mascotBusyRef.current) return;
    if (!mascotQueueRef.current.length) return;
    const next = mascotQueueRef.current.shift();
    if (!next) return;
    mascotBusyRef.current = true;
    setMascotOverride({ ...next, key: Date.now() });
  }, [overlay]);

  useEffect(() => {
    if (!overlay) {
      processMascotQueue();
    }
  }, [overlay, processMascotQueue]);

  const requestMascotAnimation = useCallback(
    (type, duration) => {
      const resolvedDuration = duration || TAMAGOTCHI_REACTION_DURATION[type] || 3200;
      mascotQueueRef.current.push({ type, duration: resolvedDuration });
      processMascotQueue();
      playSound("cat");
    },
    [playSound, processMascotQueue]
  );

  const feedTamagotchi = useCallback(
    (foodId = TAMAGOTCHI_DEFAULT_FOOD_ID) => {
      const food = TAMAGOTCHI_FOOD_MAP[foodId] || TAMAGOTCHI_FOOD_MAP[TAMAGOTCHI_DEFAULT_FOOD_ID];
      if (!food) return;
      if (tamagotchiState.hunger >= TAMAGOTCHI_MAX_HUNGER) {
        Alert.alert(t("tamagotchiName"), t("tamagotchiFullMessage"));
        return;
      }
      if (tamagotchiCoins < food.cost) {
        const hint = t("tamagotchiEarnCoinsHint");
        const needText = t("tamagotchiNeedCoinsMessage", { cost: food.cost, emoji: food.emoji });
        Alert.alert(t("tamagotchiName"), `${needText}\n\n${hint}`);
        return;
      }
      let hungerBefore = tamagotchiState.hunger;
      let hungerAfter = tamagotchiState.hunger;
      setTamagotchiState((prev) => {
        const prevHunger = Math.max(0, Number(prev.hunger) || 0);
        const nextHunger = Math.min(TAMAGOTCHI_MAX_HUNGER, prevHunger + food.hungerBoost);
        hungerBefore = prevHunger;
        hungerAfter = nextHunger;
        const nextFoodId = resolveNextTamagotchiFoodId(nextHunger, food.id, true);
        return {
          ...prev,
          hunger: nextHunger,
          lastFedAt: new Date().toISOString(),
          desiredFoodId: nextFoodId,
        };
      });
      const coinsAfter = Math.max(0, tamagotchiCoins - food.cost);
      logEvent("tamagotchi_feed", {
        food_id: food.id,
        food_cost: food.cost,
        hunger_before: hungerBefore,
        hunger_after: hungerAfter,
        coins_before: tamagotchiCoins,
        coins_after: coinsAfter,
      });
      triggerHaptic(Haptics.ImpactFeedbackStyle.Heavy);
      setHealthPoints((coins) => Math.max(0, coins - food.cost));
      requestMascotAnimation("happy", 3600);
      queueHomeSpeech("feed");
    },
    [
      logEvent,
      queueHomeSpeech,
      requestMascotAnimation,
      setHealthPoints,
      t,
      tamagotchiCoins,
      tamagotchiState.hunger,
    ]
  );

  const stopPartyEffects = useCallback(() => {
    if (partyGlowAnimRef.current) {
      partyGlowAnimRef.current.stop();
      partyGlowAnimRef.current = null;
    }
    partyGlow.setValue(0);
    setPartyActive(false);
  }, [partyGlow]);

  const runPartyEffects = useCallback(
    (cyclesLeft = 2) => {
      const executeCycle = (remaining) => {
        if (remaining <= 0) {
          stopPartyEffects();
          return;
        }
        setPartyBurstKey((prev) => prev + 1);
        const glowPulse = Animated.sequence([
          Animated.timing(partyGlow, {
            toValue: 1,
            duration: 400,
            easing: Easing.out(Easing.quad),
            useNativeDriver: true,
          }),
          Animated.timing(partyGlow, {
            toValue: 0,
            duration: 400,
            easing: Easing.in(Easing.quad),
            useNativeDriver: true,
          }),
          Animated.delay(320),
        ]);
        partyGlowAnimRef.current = glowPulse;
        glowPulse.start(() => executeCycle(remaining - 1));
      };
      executeCycle(cyclesLeft);
    },
    [partyGlow, stopPartyEffects]
  );

  useEffect(() => {
    return () => {
      stopPartyEffects();
    };
  }, [stopPartyEffects]);


  const startParty = useCallback(() => {
    if (tamagotchiCoins < TAMAGOTCHI_PARTY_COST) {
      const hint = t("tamagotchiEarnCoinsHint");
      const needText = t("tamagotchiPartyNeedCoinsMessage", {
        amount: TAMAGOTCHI_PARTY_BLUE_COST,
      });
      Alert.alert(t("tamagotchiName"), `${needText}\n\n${hint}`);
      return;
    }
    const coinsAfter = Math.max(0, tamagotchiCoins - TAMAGOTCHI_PARTY_COST);
    logEvent("tamagotchi_party_started", {
      party_cost: TAMAGOTCHI_PARTY_COST,
      coins_before: tamagotchiCoins,
      coins_after: coinsAfter,
    });
    setHealthPoints((coins) => Math.max(0, coins - TAMAGOTCHI_PARTY_COST));
    stopPartyEffects();
    setPartyActive(true);
    runPartyEffects(2);
    requestMascotAnimation("happyHeadshake", 3600);
  }, [
    logEvent,
    requestMascotAnimation,
    runPartyEffects,
    setHealthPoints,
    stopPartyEffects,
    t,
    tamagotchiCoins,
  ]);

  const handleMascotAnimationComplete = useCallback(() => {
    mascotBusyRef.current = false;
    if (!overlay && mascotQueueRef.current.length) {
      const next = mascotQueueRef.current.shift();
      if (next) {
        mascotBusyRef.current = true;
        setMascotOverride({ ...next, key: Date.now() });
        return;
      }
    }
    setMascotOverride(null);
  }, [overlay]);

  const dismissStormEffect = useCallback(() => {
    if (stormTimerRef.current) {
      clearTimeout(stormTimerRef.current);
      stormTimerRef.current = null;
    }
    setStormActive(false);
  }, []);
  const triggerStormEffect = useCallback(() => {
    if (stormTimerRef.current) {
      clearTimeout(stormTimerRef.current);
    }
    setStormActive(true);
    setTimeout(() => playSound("thunder"), 120);
    stormTimerRef.current = setTimeout(() => {
      stormTimerRef.current = null;
      setStormActive(false);
    }, STORM_OVERLAY_DURATION_MS);
  }, [playSound]);
  const recordTemptationInteraction = useCallback(
    (templateId, actionType, item = null) => {
      if (!templateId && !item?.id && !item?.templateId) return;
      if (actionType !== "save" && actionType !== "spend") return;
      dismissPotentialGrowth();
      const resolvedTitle = item
        ? resolveTemptationTitle(item, language)
        : null;
      setTemptationInteractions((prev) => {
        const baseKey = normalizeTemplateKey(templateId);
        const itemIdKey = normalizeTemplateKey(item?.id);
        const itemTemplateKey = normalizeTemplateKey(item?.templateId);
        const candidateKeys = [baseKey, itemIdKey, itemTemplateKey].filter(Boolean);
        if (!candidateKeys.length) return prev;
        const primaryKey = candidateKeys[0];
        const prevEntry = prev?.[primaryKey] || {};
        const now = Date.now();
        const lastInteractionAt = prevEntry.lastInteractionAt || null;
        const priorInteractionAt = prevEntry.previousInteractionAt || null;
        const secondPriorInteractionAt = prevEntry.secondPreviousInteractionAt || null;
        let detectedIntervalMs = prevEntry.detectedIntervalMs || null;
        let frequency = prevEntry.frequency || null;
        let intervalMs = prevEntry.intervalMs || null;
        let nextCheckAt = prevEntry.nextCheckAt || null;
        const latestIntervalMs = lastInteractionAt ? now - lastInteractionAt : null;
        let resolvedFrequency = null;
        if (latestIntervalMs !== null) {
          detectedIntervalMs = latestIntervalMs;
        }
        if (latestIntervalMs !== null) {
          const hasTwoActionsInDay =
            Number.isFinite(lastInteractionAt) &&
            latestIntervalMs <= DAILY_SECOND_ACTION_THRESHOLD_MS;
          if (hasTwoActionsInDay) {
            resolvedFrequency = "daily";
          } else if (
            latestIntervalMs > DAILY_SECOND_ACTION_THRESHOLD_MS &&
            latestIntervalMs <= WEEKLY_FREQUENCY_THRESHOLD_MS
          ) {
            resolvedFrequency = "weekly";
          } else if (
            latestIntervalMs > WEEKLY_FREQUENCY_THRESHOLD_MS &&
            latestIntervalMs <= BIWEEKLY_FREQUENCY_THRESHOLD_MS
          ) {
            resolvedFrequency = "biweekly";
          } else if (latestIntervalMs > BIWEEKLY_FREQUENCY_THRESHOLD_MS) {
            resolvedFrequency = "monthly";
          }
        }
        frequency = resolvedFrequency || frequency || null;
        intervalMs = frequency ? getFrequencyIntervalMs(frequency) : detectedIntervalMs;
        nextCheckAt = frequency && intervalMs ? now + intervalMs : null;
        const nextEntry = {
          ...(prevEntry || {}),
          saveCount: (prevEntry.saveCount || 0) + (actionType === "save" ? 1 : 0),
          spendCount: (prevEntry.spendCount || 0) + (actionType === "spend" ? 1 : 0),
          lastInteractionAt: now,
          previousInteractionAt: lastInteractionAt || priorInteractionAt || null,
          secondPreviousInteractionAt: priorInteractionAt || secondPriorInteractionAt || null,
          detectedIntervalMs,
          frequency: frequency || null,
          intervalMs: intervalMs || null,
          nextCheckAt: frequency ? nextCheckAt : null,
          lastTimerResetAt: null,
          missedCycles: 0,
          templateTitle: resolvedTitle || prevEntry.templateTitle || null,
        };
        if (frequency && nextCheckAt) {
          nextEntry.frequencyReminderScheduledAt = null;
          nextEntry.frequencyReminderLocale = null;
          nextEntry.frequencyReminderId = null;
          nextEntry.frequencyReminderIds = [];
          nextEntry.frequencyReminderPlanKey = null;
        } else if (!frequency) {
          nextEntry.frequencyReminderScheduledAt = null;
          nextEntry.frequencyReminderLocale = null;
          nextEntry.frequencyReminderId = null;
          nextEntry.frequencyReminderIds = [];
          nextEntry.frequencyReminderPlanKey = null;
        } else {
          nextEntry.frequencyReminderScheduledAt = prevEntry.frequencyReminderScheduledAt || null;
          nextEntry.frequencyReminderLocale = prevEntry.frequencyReminderLocale || null;
        }
        const nextMap = { ...(prev || {}) };
        candidateKeys.forEach((key) => {
          nextMap[key] = nextEntry;
        });
        return nextMap;
      });
    },
    [dismissPotentialGrowth, language]
  );
  const normalizeTemplateKey = (value) => {
    if (typeof value !== "string") return null;
    const trimmed = value.trim();
    return trimmed.length ? trimmed : null;
  };
  const resolveTemptationTemplateId = useCallback(
    (item, fallbackId = null) => {
      const fallback = normalizeTemplateKey(fallbackId);
      if (fallback) return fallback;
      const templateProp = normalizeTemplateKey(item?.templateId);
      if (templateProp) return templateProp;
      const itemId = normalizeTemplateKey(item?.id);
      if (itemId) return itemId;
      if (isCustomTemptation(item)) {
        const customId = normalizeTemplateKey(profile.customSpend?.id);
        return customId || "custom_habit";
      }
      return null;
    },
    [profile.customSpend]
  );
  const buildLegacyTemplateKeys = useCallback(
    (templateId, item = null) => {
      const keys = [];
      const pushKey = (value) => {
        if (typeof value !== "string") return;
        const normalized = value.trim();
        if (!normalized || keys.includes(normalized)) return;
        keys.push(normalized);
      };
      const normalizedTemplateId = normalizeTemplateKey(templateId);
      const normalizedItemId = normalizeTemplateKey(item?.id);
      const normalizedItemTemplateId = normalizeTemplateKey(item?.templateId);
      const candidateIds = [normalizedTemplateId, normalizedItemId, normalizedItemTemplateId].filter(Boolean);
      const idLooksCustom = candidateIds.some(
        (value) => typeof value === "string" && value.startsWith("custom_habit_")
      );
      const quickCustom = Boolean(
        item &&
          (item.quickTemptation ||
            item.quickCreate ||
            item.origin === "quick_custom" ||
            item.source === "quick_custom")
      );
      const isQuickCustom = quickCustom || idLooksCustom;
      if (typeof templateId === "string" && templateId.trim()) {
        pushKey(templateId);
      }
      if (item?.templateId) {
        pushKey(item.templateId);
      }
      if (item?.id && item.id !== templateId) {
        pushKey(item.id);
      }
      if (isCustomTemptation(item) && !isQuickCustom) {
        const primaryCustomId = normalizeTemplateKey(profile.customSpend?.id);
        const matchesPrimary =
          primaryCustomId && candidateIds.some((value) => value === primaryCustomId);
        const matchesDefaultLegacy =
          !primaryCustomId &&
          candidateIds.some(
            (value) => value === "custom_habit" || value === "custom" || value === "custom_temptation"
          );
        if (matchesPrimary || matchesDefaultLegacy) {
          if (primaryCustomId) {
            pushKey(primaryCustomId);
          }
          pushKey("custom_habit");
          pushKey("undefined");
        }
      }
      return keys;
    },
    [profile.customSpend]
  );
      const ensureGoalWishExists = useCallback(
        (wishId) => {
          if (!wishId || typeof wishId !== "string") return false;
          if (!wishId.startsWith("wish_primary_goal_")) return false;
          const goalId = wishId.replace("wish_primary_goal_", "");
          const primaryEntries = Array.isArray(profile.primaryGoals) ? profile.primaryGoals : [];
          const primaryEntry = primaryEntries.find((entry) => entry?.id === goalId);
          const canFallbackToProfileGoal = profile.goal === goalId;
          if (!primaryEntry && !canFallbackToProfileGoal) return false;
          const fallbackTargetUSD =
            profile.goal === goalId &&
            Number.isFinite(profile.goalTargetUSD) &&
            profile.goalTargetUSD > 0
              ? profile.goalTargetUSD
              : getGoalDefaultTargetUSD(goalId);
          const ensuredEntry =
            primaryEntry || {
              id: goalId,
              targetUSD: fallbackTargetUSD,
              savedUSD: 0,
              status: "active",
              createdAt: Date.now(),
            };
          setWishes((prev) => {
            if (prev.some((wish) => wish?.id === wishId)) return prev;
            const goalPreset = getGoalPreset(goalId);
            const languageKey = language || "en";
            const customTitle =
          typeof ensuredEntry?.customTitle === "string" ? ensuredEntry.customTitle.trim() : "";
        const hasCustomTitle = !!customTitle;
        const customEmoji = ensuredEntry?.customEmoji
          ? normalizeEmojiValue(ensuredEntry.customEmoji, DEFAULT_GOAL_EMOJI)
          : null;
        const resolvedEmoji =
          hasCustomTitle ? customEmoji || DEFAULT_GOAL_EMOJI : goalPreset?.emoji || DEFAULT_GOAL_EMOJI;
        const presetLabel = goalPreset?.[languageKey] || goalPreset?.en || goalId;
        const resolvedLabel = hasCustomTitle ? customTitle : presetLabel || goalId;
        const title = `${resolvedEmoji} ${resolvedLabel}`.trim();
        const targetUSD =
          Number.isFinite(ensuredEntry?.targetUSD) && ensuredEntry.targetUSD > 0
            ? ensuredEntry.targetUSD
            : getGoalDefaultTargetUSD(goalId);
        const createdAt = ensuredEntry?.createdAt || Date.now();
        const nextWish = {
          id: wishId,
          templateId: `goal_${goalId}`,
          title,
          emoji: resolvedEmoji,
          targetUSD,
          savedUSD: 0,
          status: "active",
          createdAt,
          autoManaged: true,
          kind: PRIMARY_GOAL_KIND,
          goalId,
        };
        return [nextWish, ...prev];
      });
      return true;
    },
    [language, profile.goal, profile.goalTargetUSD, profile.primaryGoals, setWishes]
  );
  const getLegacyRefuseStatsEntry = useCallback(
    (stats, templateId, item = null) => {
      if (!stats || typeof stats !== "object") {
        return { entry: null, key: templateId || null };
      }
      const keysToCheck = buildLegacyTemplateKeys(templateId, item);
      for (let index = 0; index < keysToCheck.length; index += 1) {
        const key = keysToCheck[index];
        if (!key) continue;
        if (Object.prototype.hasOwnProperty.call(stats, key)) {
          return { entry: stats[key], key };
        }
      }
      return { entry: null, key: templateId || null };
    },
    [buildLegacyTemplateKeys]
  );
  const normalizeLegacyRecoveryRefs = useCallback(
    (templateId, item = null) => {
      if (!templateId) return;
      const keysToCheck = buildLegacyTemplateKeys(templateId, item);
      keysToCheck.forEach((key) => {
        if (!key || key === templateId) return;
        if (pendingStreakRecoveryRef.current?.[key]) {
          if (!pendingStreakRecoveryRef.current[templateId]) {
            pendingStreakRecoveryRef.current[templateId] = pendingStreakRecoveryRef.current[key];
          }
          delete pendingStreakRecoveryRef.current[key];
        }
        if (streakRecoveryOverrideRef.current?.[key]) {
          if (!streakRecoveryOverrideRef.current[templateId]) {
            streakRecoveryOverrideRef.current[templateId] = streakRecoveryOverrideRef.current[key];
          }
          delete streakRecoveryOverrideRef.current[key];
        }
      });
    },
    [buildLegacyTemplateKeys]
  );
  const clearStreakRecoveryForTemptation = useCallback((templateId) => {
    if (!templateId) return;
    delete pendingStreakRecoveryRef.current?.[templateId];
    delete streakRecoveryOverrideRef.current?.[templateId];
    setRefuseStats((prev) => {
      const current = prev?.[templateId];
      if (!current) return prev;
      return {
        ...prev,
        [templateId]: {
          ...current,
          recoverableStreak: 0,
          recoverableAmountUSD: 0,
        },
      };
    });
  }, []);
  const queueCoinValueModal = useCallback(() => {
    const currentStatus = coinValueModalStatusRef.current;
    if (
      currentStatus === COIN_VALUE_MODAL_STATUS.SHOWN ||
      currentStatus === COIN_VALUE_MODAL_STATUS.PENDING
    ) {
      return;
    }
    coinValueModalStatusRef.current = COIN_VALUE_MODAL_STATUS.PENDING;
    setCoinValueModalStatus(COIN_VALUE_MODAL_STATUS.PENDING);
    AsyncStorage.setItem(
      STORAGE_KEYS.COIN_VALUE_MODAL,
      COIN_VALUE_MODAL_STATUS.PENDING
    ).catch(() => {});
  }, []);
  const priceEditorTemplateId = priceEditor.item ? resolveTemptationTemplateId(priceEditor.item) : null;
  const priceEditorAssignedGoalId = priceEditorTemplateId
    ? resolveTemptationGoalId(priceEditorTemplateId)
    : null;
  const priceEditorAssignedGoal =
    priceEditorAssignedGoalId &&
    (wishes || []).find((wish) => wish.id === priceEditorAssignedGoalId);
  const priceEditorAssignedGoalTitle = priceEditorAssignedGoal
    ? getWishTitleWithoutEmoji(priceEditorAssignedGoal)
    : "";
  const goalLinkTemplateId = goalLinkPrompt.item ? resolveTemptationTemplateId(goalLinkPrompt.item) : null;
  const goalLinkCurrentGoalId = goalLinkTemplateId ? resolveTemptationGoalId(goalLinkTemplateId) : null;
  const executeSpend = useCallback(
    (item) => {
      if (!item) return;
      const templateId = resolveTemptationTemplateId(item);
      const rawPriceUSD =
        item?.priceUSD ??
        item?.basePriceUSD ??
        item?.amountUSD ??
        item?.amount ??
        item?.amountLocal ??
        0;
      const normalizedPriceUSD = parseAmountValue(rawPriceUSD);
      let priceUSD =
        normalizedPriceUSD > 0
          ? normalizedPriceUSD
          : isCustomTemptation(item)
          ? resolveCustomPriceUSD(item, profile.currency || DEFAULT_PROFILE.currency)
          : 0;
      if (priceUSD <= 0 && isCustomTemptation(item) && profile.customSpend) {
        priceUSD = resolveCustomPriceUSD(
          profile.customSpend,
          profile.currency || DEFAULT_PROFILE.currency
        );
      }
      const title = `${item.emoji || "âœ¨"} ${
        item.title?.[language] || item.title?.en || item.title || "goal"
      }`;
      registerFocusLoss(item);
      handleFocusSpend(item);
      logHistoryEvent("spend", { title, amountUSD: priceUSD, templateId: templateId || item.id });
      triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
      if (spendReducesSavings) {
        setSavedTotalUSD((prev) => Math.max(prev - priceUSD, 0));
      }
      setPurchases((prev) => [
        {
          id: `spend-${item.id}-${Date.now()}`,
          title,
          price: priceUSD,
          paidAmount: priceUSD,
          createdAt: Date.now(),
        },
        ...prev,
      ]);
      setFreeDayStats((prev) => {
        const todayKey = getDayKey(Date.now());
        if (!prev) {
          return { ...INITIAL_FREE_DAY_STATS, blockedDate: todayKey };
        }
        if (prev.blockedDate === todayKey && prev.current === 0) {
          return prev;
        }
        const next = {
          ...prev,
          current: 0,
          blockedDate: todayKey,
        };
        return next;
      });
      setRefuseStats((prev) => {
        if (!templateId) return prev;
        const { entry: current, key: legacyKey } = getLegacyRefuseStatsEntry(prev, templateId, item);
        if (!current) return prev;
        const normalizedBest = Math.max(current.bestStreak || 0, current.currentStreak || 0);
        const recoverableValue = Math.max(current.currentStreak || 0, 0);
        if (recoverableValue > 0) {
          pendingStreakRecoveryRef.current = {
            ...(pendingStreakRecoveryRef.current || {}),
            [templateId]: {
              streak: recoverableValue,
              amountUSD: priceUSD,
            },
          };
        }
        const next = {
          ...prev,
          [templateId]: {
            ...current,
            currentStreak: 0,
            bestStreak: normalizedBest,
            lastAction: "spend",
            streakLostAt: Date.now(),
            recoverableStreak: recoverableValue,
            recoverableAmountUSD: priceUSD,
          },
        };
        if (legacyKey && legacyKey !== templateId) {
          delete next[legacyKey];
        }
        return next;
      });
      logImpulseEvent("spend", item, priceUSD, title);
      requestMascotAnimation(Math.random() > 0.5 ? "sad" : "ohno");
      recordTemptationInteraction(templateId || item.id, "spend", item);
      queueHomeSpeech("spend");
    },
    [
      handleFocusSpend,
      language,
      queueHomeSpeech,
      resolveTemptationTemplateId,
      logHistoryEvent,
      logImpulseEvent,
      recordTemptationInteraction,
      registerFocusLoss,
      requestMascotAnimation,
      setFreeDayStats,
      setRefuseStats,
      getLegacyRefuseStatsEntry,
      setSavedTotalUSD,
      spendReducesSavings,
    ]
  );

  const handleSpendConfirm = useCallback(() => {
    if (!spendPrompt.item || spendExecutionLockRef.current) return;
    const item = spendPrompt.item;
    spendExecutionLockRef.current = true;
    closeSpendPrompt();
    triggerStormEffect();
    try {
      executeSpend(item);
    } finally {
      spendExecutionLockRef.current = false;
    }
  }, [closeSpendPrompt, executeSpend, spendPrompt.item, triggerStormEffect]);

  const buildTemptationPayload = useCallback(
    (item, extra = {}) => {
      const priceUSD = Number(item.priceUSD ?? item.basePriceUSD ?? 0) || 0;
      return {
        item_id: item.id,
        price_usd: priceUSD,
        categories: (item.categories || []).join(","),
        persona: profile.persona || "unknown",
        currency: profile.currency || DEFAULT_PROFILE.currency,
        ...extra,
      };
    },
    [profile.currency, profile.persona]
  );

  const recordRatingPromptAction = useCallback(
    (action) => {
      if (!ratingPromptHydrated) return;
      if (!RATING_PROMPT_ACTION_TYPES.has(action)) return;
      updateRatingPromptState((prev) => {
        if (prev.completed || prev.actionPrompted) return prev;
        const nextCount = Math.max(0, Number(prev.actionCount) || 0) + 1;
        return { ...prev, actionCount: nextCount };
      });
    },
    [ratingPromptHydrated, updateRatingPromptState]
  );

  const logTemptationAction = useCallback(
    (action, item, extra = {}) => {
      if (!item || !action) return;
      recordRatingPromptAction(action);
      maybeLogDayMilestone(action);
      logEvent("temptation_action", buildTemptationPayload(item, { action, ...extra }));
    },
    [buildTemptationPayload, maybeLogDayMilestone, recordRatingPromptAction]
  );

  const scheduleImpulseReminder = useCallback(
    async (event) => {
      if (!event || !event.timestamp) return;
      const triggerAt = getImpulseReminderTimestamp(event.timestamp);
      if (!triggerAt) return;
      if (triggerAt - Date.now() < IMPULSE_REMINDER_MIN_DELAY_MS) return;
      const allowed = await ensureNotificationPermission({ request: false });
      if (!allowed) return;
      const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
      const amountLabel = formatCurrency(
        convertToCurrency(Math.max(event.amountUSD || 0, 0), currencyCode),
        currencyCode
      );
      const templateTitle = event.title || t("defaultDealTitle");
      const dedupeKey = `impulse_reminder:${event.id || event.templateId || Date.now()}`;
      const dayLabel =
        formatRelativeDayLabel(event.timestamp, triggerAt, language) ||
        formatRelativeDayLabel(event.timestamp, Date.now(), language) ||
        (normalizeLanguage(language) === "ru"
          ? "Ð²Ñ‡ÐµÑ€Ð°"
          : normalizeLanguage(language) === "es"
          ? "ayer"
          : normalizeLanguage(language) === "fr"
          ? "hier"
          : "yesterday");
      const content =
        event.action === "save"
          ? {
              title: t("impulseReminderWinTitle", { temptation: templateTitle }),
              body: t("impulseReminderWinBody", { amount: amountLabel, dayLabel }),
            }
          : {
              title: t("impulseReminderLoseTitle", { temptation: templateTitle, dayLabel }),
              body: t("impulseReminderLoseBody", { amount: amountLabel }),
            };
      try {
        await scheduleNotificationWithCooldown({
          content: {
            ...content,
            data: {
              kind: "impulse_reminder",
              templateId: event.templateId || null,
              title: templateTitle,
              emoji: event.emoji || "âœ¨",
              amountUSD: Number(event.amountUSD) || 0,
              dedupeKey,
            },
            categoryIdentifier: ACTIONABLE_NOTIFICATION_CATEGORY_ID,
          },
          trigger: new Date(triggerAt),
        });
      } catch (error) {
        console.warn("impulse reminder schedule", error);
      }
    },
    [ensureNotificationPermission, profile.currency, scheduleNotificationWithCooldown, t]
  );

  const logImpulseEvent = useCallback(
    (action, item, amountUSD = 0, overrideTitle = null) => {
      if (!item || (action !== "save" && action !== "spend")) return;
      const timestamp = Date.now();
      const entryTitle =
        overrideTitle ||
        `${item.emoji || "âœ¨"} ${
          item.title?.[language] || item.title?.en || item.title || t("defaultDealTitle")
        }`;
      const eventTemplateId = resolveTemptationTemplateId(item) || item.id;
      const event = {
        id: `impulse-${timestamp}-${Math.random().toString(16).slice(2, 6)}`,
        templateId: eventTemplateId,
        title: entryTitle,
        emoji: item.emoji || "âœ¨",
        category: resolveImpulseCategory(item),
        action,
        amountUSD: amountUSD || item.priceUSD || item.basePriceUSD || 0,
        timestamp,
        hour: new Date(timestamp).getHours(),
      };
      setImpulseTracker((prev) => {
        const nextEvents = [event, ...(prev?.events || [])].slice(0, MAX_IMPULSE_EVENTS);
        return {
          ...(prev || INITIAL_IMPULSE_TRACKER),
          events: nextEvents,
        };
      });
      scheduleImpulseReminder(event);
    },
    [language, resolveTemptationTemplateId, scheduleImpulseReminder, t]
  );

  const buildPrimaryGoalWishSnapshot = useCallback(
    (wishId) => {
      if (!wishId || typeof wishId !== "string") return null;
      const existing = wishes.find((wish) => wish?.id === wishId);
      if (existing) return existing;
      if (!wishId.startsWith("wish_primary_goal_")) return null;
      const goalId = wishId.replace("wish_primary_goal_", "");
      const primaryEntry = Array.isArray(profile.primaryGoals)
        ? profile.primaryGoals.find((entry) => entry?.id === goalId)
        : null;
      const preset = getGoalPreset(goalId);
      const customTitle =
        typeof primaryEntry?.customTitle === "string" ? primaryEntry.customTitle.trim() : "";
      const customEmoji = primaryEntry?.customEmoji
        ? normalizeEmojiValue(primaryEntry.customEmoji, DEFAULT_GOAL_EMOJI)
        : null;
      const label = customTitle || preset?.[language] || preset?.en || goalId;
      const emoji = customTitle
        ? customEmoji || DEFAULT_GOAL_EMOJI
        : preset?.emoji || DEFAULT_GOAL_EMOJI;
      const targetUSD =
        Number.isFinite(primaryEntry?.targetUSD) && primaryEntry.targetUSD > 0
          ? primaryEntry.targetUSD
          : profile.goal === goalId &&
            Number.isFinite(profile.goalTargetUSD) &&
            profile.goalTargetUSD > 0
          ? profile.goalTargetUSD
          : getGoalDefaultTargetUSD(goalId);
      const savedUSD = Number.isFinite(primaryEntry?.savedUSD) ? primaryEntry.savedUSD : 0;
      return {
        id: wishId,
        title: `${emoji} ${label}`.trim(),
        targetUSD,
        savedUSD,
        status: primaryEntry?.status || "active",
        kind: PRIMARY_GOAL_KIND,
        goalId,
      };
    },
    [language, profile.goal, profile.goalTargetUSD, profile.primaryGoals, wishes]
  );

  const handleTemptationAction = useCallback(
    async (type, item, options = {}) => {
      const {
        skipPrompt = false,
        goalId: forcedGoalId = null,
        shouldAssign = false,
        pinnedBy = null,
        bypassSpendPrompt = false,
        skipStreakRecoveryPrompt = false,
        restoredStreakValue = null,
        forceOverlay = false,
        forcePrimaryGoal = false,
      } = options || {};
      playSound("tap");
      let resolvedForcedGoalId = forcedGoalId;
      if (
        typeof resolvedForcedGoalId === "string" &&
        !resolvedForcedGoalId.startsWith("wish_primary_goal_") &&
        Array.isArray(profile.primaryGoals) &&
        profile.primaryGoals.some((goal) => goal?.id === resolvedForcedGoalId)
      ) {
        resolvedForcedGoalId = getPrimaryGoalWishId(resolvedForcedGoalId);
      }
      const normalizeTargetGoalId = (goalId) => {
        if (
          typeof goalId === "string" &&
          !goalId.startsWith("wish_primary_goal_") &&
          Array.isArray(profile.primaryGoals) &&
          profile.primaryGoals.some((goal) => goal?.id === goalId)
        ) {
          return getPrimaryGoalWishId(goalId);
        }
        if (
          typeof goalId === "string" &&
          !goalId.startsWith("wish_primary_goal_") &&
          profile.goal === goalId
        ) {
          return getPrimaryGoalWishId(goalId);
        }
        return goalId;
      };
      const templateId = resolveTemptationTemplateId(item);
      const rawPriceUSD =
        item?.priceUSD ??
        item?.basePriceUSD ??
        item?.amountUSD ??
        item?.amount ??
        item?.amountLocal ??
        0;
      const normalizedPriceUSD = parseAmountValue(rawPriceUSD);
      let priceUSD = normalizedPriceUSD > 0 ? normalizedPriceUSD : 0;
      if (priceUSD <= 0 && isCustomTemptation(item)) {
        priceUSD = resolveCustomPriceUSD(item, profile.currency || DEFAULT_PROFILE.currency);
        if (priceUSD <= 0 && profile.customSpend) {
          priceUSD = resolveCustomPriceUSD(
            profile.customSpend,
            profile.currency || DEFAULT_PROFILE.currency
          );
        }
      }
      const title = `${item.emoji || "âœ¨"} ${
        item.title?.[language] || item.title?.en || item.title || "goal"
      }`;
      const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
      const priceLocal = convertToCurrency(priceUSD, currencyCode);
      const balanceLocal = convertToCurrency(savedTotalUSD, currencyCode);
      if (type === "maybe" && !thinkingUnlocked) {
        Alert.alert("Almost", t("thinkingLockedMessage"));
        return;
      }
      if (shouldPromptCategory(item, type, options)) {
        openCategoryPrompt(item, type, options);
        return;
      }
      if (type === "spend") {
        if (bypassSpendPrompt) {
          if (spendExecutionLockRef.current) return;
          spendExecutionLockRef.current = true;
        } else if (spendPromptLockRef.current) {
          return;
        } else {
          spendPromptLockRef.current = true;
        }
        dismissStormEffect();
        try {
          logTemptationAction("spend", item);
          logEvent("temptation_spend", buildTemptationPayload(item, { total_saved_usd: savedTotalUSD }));
          logEvent("temptation_decision", {
            temptation_id: templateId || item.id,
            decision: "spend",
            price: priceLocal,
            balance_before: balanceLocal,
          });
          if (bypassSpendPrompt) {
            triggerStormEffect();
            executeSpend(item);
          } else {
            setSpendPrompt({ visible: true, item });
          }
        } catch (error) {
          if (bypassSpendPrompt) {
            spendExecutionLockRef.current = false;
          } else {
            spendPromptLockRef.current = false;
          }
          throw error;
        }
        if (bypassSpendPrompt) {
          spendExecutionLockRef.current = false;
        }
        return;
      }
      if (type === "want") {
        logTemptationAction("wish", item);
        logEvent("temptation_want", buildTemptationPayload(item));
        const wishTemplateId = templateId || item.id || `custom_${Date.now()}`;
        const newWish = {
          id: `wish-${wishTemplateId}-${Date.now()}`,
          templateId: wishTemplateId,
          title,
          targetUSD: priceUSD,
          savedUSD: 0,
          status: "active",
          createdAt: Date.now(),
          autoManaged: false,
          emoji: item.emoji || DEFAULT_GOAL_EMOJI,
          pinnedSource: pinnedBy,
        };
        setWishes((prev) => insertWishAfterPrimary(prev, newWish));
        logHistoryEvent("wish_added", {
          title,
          targetUSD: priceUSD,
          templateId: wishTemplateId,
          wishId: newWish.id,
        });
        triggerOverlayState("purchase", t("wishAdded", { title }));
        triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
        return;
      }
      if (type === "save") {
        if (templateId) {
          normalizeLegacyRecoveryRefs(templateId, item);
        }
        const { entry: resolvedStreakStats } = getLegacyRefuseStatsEntry(refuseStats, templateId, item);
        const streakStatsEntry = resolvedStreakStats || {};
        const overrideEntry = templateId ? streakRecoveryOverrideRef.current?.[templateId] : null;
        const restoredStreakOverride =
          restoredStreakValue !== null && restoredStreakValue !== undefined
            ? restoredStreakValue
            : overrideEntry?.streak ?? null;
        const pendingRecovery = templateId ? pendingStreakRecoveryRef.current?.[templateId] : null;
        const recoverableStreak =
          streakStatsEntry.recoverableStreak ||
          pendingRecovery?.streak ||
          0;
        const recoverableAmountUSD =
          streakStatsEntry.recoverableAmountUSD ||
          pendingRecovery?.amountUSD ||
          0;
        const lastStreakAction =
          streakStatsEntry.lastAction || (pendingRecovery ? "spend" : null);
        if (!skipStreakRecoveryPrompt && restoredStreakOverride == null) {
          const hasRecoverableStreak =
            lastStreakAction === "spend" && recoverableStreak >= 2;
          if (hasRecoverableStreak) {
            const recoveryUSD = recoverableAmountUSD || priceUSD;
            const coinCost = computeStreakRecoveryCost(recoveryUSD);
            const nextOptions = { ...options, skipStreakRecoveryPrompt: true };
            const fallbackTemplateId =
              templateId || (isCustomTemptation(item) ? profile.customSpend?.id || "custom_habit" : null);
            setStreakRecoveryPrompt({
              visible: true,
              item,
              templateId: fallbackTemplateId,
              coinCost,
              options: nextOptions,
              recoverableStreak,
              recoverableAmountUSD: recoveryUSD,
              errorMessage: "",
            });
            return;
          }
        }
        const saveTimestamp = Date.now();
        // Previously we blocked rapid repeated saves; removed to keep progress updating every time.
        const storedGoalId = resolveTemptationGoalId(templateId);
        let primaryGoalWishId = null;
        if (overlay?.type === "primary_temptation" || forcePrimaryGoal) {
          if (typeof activeGoalId === "string" && activeGoalId.startsWith("wish_primary_goal_")) {
            primaryGoalWishId = activeGoalId;
          } else if (
            typeof activeGoalId === "string" &&
            Array.isArray(profile.primaryGoals) &&
            profile.primaryGoals.some((goal) => goal?.id === activeGoalId)
          ) {
            primaryGoalWishId = getPrimaryGoalWishId(activeGoalId);
          } else if (mainGoalWish?.goalId) {
            primaryGoalWishId = getPrimaryGoalWishId(mainGoalWish.goalId);
          } else if (profile.goal) {
            primaryGoalWishId = getPrimaryGoalWishId(profile.goal);
          }
        }
        const normalizedStoredGoalId = normalizeTargetGoalId(storedGoalId);
        const desiredGoalId = normalizeTargetGoalId(
          resolvedForcedGoalId || primaryGoalWishId || normalizedStoredGoalId
        );
        const shouldPrompt =
          !skipPrompt && assignableGoals.length > 1 && !desiredGoalId;
        if (shouldPrompt) {
          setGoalLinkPrompt({
            visible: true,
            item,
            intent: "save",
            streakRecoveryValue: restoredStreakOverride ?? null,
          });
          return;
        }
        const activeFallbackGoalId = activeGoalId || profile.goal || null;
        let targetGoalId =
          desiredGoalId || normalizeTargetGoalId(activeFallbackGoalId) || getFallbackGoalId();
        if (!targetGoalId && assignableGoals.length === 0 && wishes.length > 0) {
          targetGoalId = wishes[0].id;
        }
        if (!targetGoalId) {
          const fallbackGoal = activeGoalId || profile.goal || null;
          if (fallbackGoal) {
            targetGoalId = normalizeTargetGoalId(fallbackGoal);
          }
        }
        // Always normalize to primary-goal wish ids when applicable and ensure target exists.
        let normalizedTargetGoalId = targetGoalId ? normalizeTargetGoalId(targetGoalId) : null;
        const resolveExistingGoalId = () => {
          const primaryActiveId =
            (profile.goal &&
              Array.isArray(profile.primaryGoals) &&
              profile.primaryGoals.some((g) => g?.id === profile.goal) &&
              getPrimaryGoalWishId(profile.goal)) ||
            null;
          const singleAssignableId =
            assignableGoals.length === 1 && assignableGoals[0]?.id ? assignableGoals[0].id : null;
          const candidates = [
            normalizedTargetGoalId,
            primaryActiveId,
            activeGoalId,
            mainGoalWish?.id,
            singleAssignableId,
            (wishes || []).find((wish) => wish.status !== "done")?.id,
            wishes?.[0]?.id,
          ].filter(Boolean);
          for (const candidate of candidates) {
            const matchesWish = wishes.some((wish) => wish?.id === candidate);
            const matchedPrimary =
              Array.isArray(profile.primaryGoals) &&
              profile.primaryGoals.find(
                (goal) =>
                  normalizeTargetGoalId(goal.id) === candidate || getPrimaryGoalWishId(goal.id) === candidate
              );
            if (matchesWish) {
              return candidate;
            }
            if (matchedPrimary) {
              return getPrimaryGoalWishId(matchedPrimary.id);
            }
            if (candidate.startsWith("wish_primary_goal_")) {
              return candidate;
            }
          }
          return null;
        };
        normalizedTargetGoalId = resolveExistingGoalId();
        if (
          normalizedTargetGoalId &&
          normalizedTargetGoalId.startsWith("wish_primary_goal_") &&
          !ensureGoalWishExists(normalizedTargetGoalId)
        ) {
          normalizedTargetGoalId = null;
        }
        if (!normalizedTargetGoalId) {
          const fallbackWishId =
            (wishes || []).find((wish) => wish.status !== "done")?.id || wishes?.[0]?.id || null;
          normalizedTargetGoalId = fallbackWishId ? normalizeTargetGoalId(fallbackWishId) : null;
          if (!normalizedTargetGoalId) {
            const primaryFallbackId =
              profile.goal || (Array.isArray(profile.primaryGoals) ? profile.primaryGoals[0]?.id : null) || null;
            if (primaryFallbackId) {
              const primaryWishId = getPrimaryGoalWishId(primaryFallbackId);
              if (ensureGoalWishExists(primaryWishId)) {
                normalizedTargetGoalId = primaryWishId;
              }
            }
          }
          if (!normalizedTargetGoalId) {
            const mainWishId = mainGoalWish?.id || null;
            if (mainWishId) {
              const normalizedMainWishId = normalizeTargetGoalId(mainWishId);
              if (
                normalizedMainWishId &&
                (!normalizedMainWishId.startsWith("wish_primary_goal_") ||
                  ensureGoalWishExists(normalizedMainWishId))
              ) {
                normalizedTargetGoalId = normalizedMainWishId;
              }
            }
          }
        }
        if (overlay?.type === "primary_temptation") {
          const activePrimaryId =
            profile.goal ||
            (Array.isArray(profile.primaryGoals) && profile.primaryGoals[0]?.id) ||
            null;
          const activePrimaryWishId = activePrimaryId ? getPrimaryGoalWishId(activePrimaryId) : null;
          if (activePrimaryWishId && normalizedTargetGoalId !== activePrimaryWishId) {
            normalizedTargetGoalId = activePrimaryWishId;
            ensureGoalWishExists(normalizedTargetGoalId);
            setActiveGoalId(activePrimaryId);
          }
        }
        if (
          __DEV__ &&
          type === "save" &&
          (overlay?.type === "primary_temptation" || isCustomTemptation(item))
        ) {
          console.warn("primary_temptation_save_debug", {
            priceUSD,
            targetGoalId,
            itemId: item?.id,
            templateId,
            hasWishMatch: wishes.some((wish) => wish?.id === targetGoalId),
            savedTotalUSD,
            heroGoalSavedUSD,
            heroGoalTargetUSD,
            overlayType: overlay?.type || null,
          });
        }
        const autoAssignSingleGoal =
          !storedGoalId && !resolvedForcedGoalId && assignableGoals.length === 1;
        const normalizedActiveFallbackGoalId = activeFallbackGoalId
          ? normalizeTargetGoalId(activeFallbackGoalId)
          : null;
        const shouldStoreGoal =
          normalizedTargetGoalId &&
          (shouldAssign ||
            !!primaryGoalWishId ||
            autoAssignSingleGoal ||
            (!storedGoalId &&
              !resolvedForcedGoalId &&
              normalizedActiveFallbackGoalId &&
              normalizedTargetGoalId === normalizedActiveFallbackGoalId) ||
            (!storedGoalId &&
              !resolvedForcedGoalId &&
              mainGoalWish?.id &&
              normalizedTargetGoalId === mainGoalWish.id));
        if (shouldStoreGoal) {
          assignTemptationGoal(templateId || item.id, normalizedTargetGoalId);
        }
        const targetWish = normalizedTargetGoalId
          ? wishes.find((wish) => wish.id === normalizedTargetGoalId)
          : null;
        const targetWishSnapshot = targetWish || buildPrimaryGoalWishSnapshot(normalizedTargetGoalId);
        logEvent("temptation_decision", {
          temptation_id: templateId || item.id,
          decision: "save",
          price: priceLocal,
          balance_before: balanceLocal,
          saving_target_id: normalizedTargetGoalId || null,
        });
        let appliedAmount = 0;
        if (normalizedTargetGoalId) {
          appliedAmount = applySavingsToWish(normalizedTargetGoalId, priceUSD);
        }
        if (appliedAmount > 0 && normalizedTargetGoalId) {
          setWishes((prev) => {
            let changed = false;
            let found = false;
            const next = prev.map((wish) => {
              if (!wish) return wish;
              if (wish.id !== normalizedTargetGoalId) return wish;
              found = true;
              const targetUSD =
                Number.isFinite(wish.targetUSD) && wish.targetUSD > 0
                  ? wish.targetUSD
                  : getGoalDefaultTargetUSD(wish.goalId || wish.id);
              const previousSaved = Number.isFinite(wish.savedUSD) ? wish.savedUSD : 0;
              const nextSaved = Math.min(previousSaved + appliedAmount, targetUSD || Number.POSITIVE_INFINITY);
              const nextStatus = targetUSD > 0 && nextSaved >= targetUSD ? "done" : "active";
              if (nextSaved !== previousSaved || nextStatus !== wish.status) {
                changed = true;
                return { ...wish, savedUSD: nextSaved, status: nextStatus };
              }
              return wish;
            });
            if (!found) return prev;
            return changed ? next : prev;
          });
        }
        if (
          appliedAmount > 0 &&
          typeof normalizedTargetGoalId === "string" &&
          normalizedTargetGoalId.startsWith("wish_primary_goal_")
        ) {
          const goalId = normalizedTargetGoalId.replace("wish_primary_goal_", "");
          const currentGoalEntry = Array.isArray(profile.primaryGoals)
            ? profile.primaryGoals.find((goal) => goal?.id === goalId)
            : null;
          const currentSaved = Number.isFinite(currentGoalEntry?.savedUSD)
            ? currentGoalEntry.savedUSD
            : 0;
          const targetUSD =
            Number.isFinite(currentGoalEntry?.targetUSD) && currentGoalEntry.targetUSD > 0
              ? currentGoalEntry.targetUSD
              : getGoalDefaultTargetUSD(goalId);
          const nextSaved = Math.max(0, currentSaved + appliedAmount);
          const nextStatus = targetUSD > 0 && nextSaved >= targetUSD ? "done" : "active";
          setActiveGoalId(goalId);
          syncPrimaryGoalProgress(goalId, nextSaved, nextStatus);
          setProfile((prev) => {
            const existingGoals = Array.isArray(prev.primaryGoals) ? prev.primaryGoals : [];
            const updatedGoals = [];
            let found = false;
            existingGoals.forEach((entry) => {
              if (entry?.id !== goalId) {
                updatedGoals.push(entry);
                return;
              }
              found = true;
              updatedGoals.push({
                ...entry,
                targetUSD: targetUSD,
                savedUSD: Math.max(Number(entry.savedUSD) || 0, nextSaved),
                status: nextStatus,
              });
            });
            if (!found) {
              updatedGoals.unshift({
                id: goalId,
                targetUSD,
                savedUSD: nextSaved,
                status: nextStatus,
                createdAt: Date.now(),
              });
            }
            return {
              ...prev,
              goal: goalId,
              goalTargetUSD: targetUSD,
              primaryGoals: updatedGoals,
            };
          });
          setProfileDraft((prev) => {
            const existingGoals = Array.isArray(prev.primaryGoals) ? prev.primaryGoals : [];
            const updatedGoals = [];
            let found = false;
            existingGoals.forEach((entry) => {
              if (entry?.id !== goalId) {
                updatedGoals.push(entry);
                return;
              }
              found = true;
              updatedGoals.push({
                ...entry,
                targetUSD: targetUSD,
                savedUSD: Math.max(Number(entry.savedUSD) || 0, nextSaved),
                status: nextStatus,
              });
            });
            if (!found) {
              updatedGoals.unshift({
                id: goalId,
                targetUSD,
                savedUSD: nextSaved,
                status: nextStatus,
                createdAt: Date.now(),
              });
            }
            return {
              ...prev,
              goal: goalId,
              goalTargetUSD: targetUSD,
              primaryGoals: updatedGoals,
            };
          });
          setWishes((prev) => {
            const existing = prev.find((wish) => wish?.id === normalizedTargetGoalId);
            if (existing) {
              const updated = {
                ...existing,
                kind: PRIMARY_GOAL_KIND,
                goalId: goalId,
                targetUSD: existing.targetUSD || targetUSD,
                savedUSD: Math.max(existing.savedUSD || 0, nextSaved),
                status: nextStatus,
                autoManaged: false,
              };
              return prev.map((wish) => (wish?.id === normalizedTargetGoalId ? updated : wish));
            }
            const preset = getGoalPreset(goalId);
            const label = preset?.[language] || preset?.en || goalId;
            const emoji = preset?.emoji || DEFAULT_GOAL_EMOJI;
            const title = `${emoji} ${label}`.trim();
            const nextWish = {
              id: normalizedTargetGoalId,
              templateId: `goal_${goalId}`,
              title,
              emoji,
              targetUSD,
              savedUSD: nextSaved,
              status: nextStatus,
              createdAt: Date.now(),
              autoManaged: false,
              kind: PRIMARY_GOAL_KIND,
              goalId,
            };
            return [nextWish, ...prev];
          });
        }
        let saveOverlayPayload = { title, moodLine: moodPreset?.saveOverlay || null };
        if (targetWishSnapshot && targetWishSnapshot.targetUSD > 0 && priceUSD > 0) {
          const previousSavedUSD = targetWishSnapshot.savedUSD || 0;
          const targetUSD = targetWishSnapshot.targetUSD || 0;
          const nextSavedUSD = Math.min(previousSavedUSD + appliedAmount, targetUSD);
          const remainingUSD = Math.max(targetUSD - nextSavedUSD, 0);
          const remainingTemptations = Math.max(Math.ceil(remainingUSD / priceUSD), 0);
          const progressStartValue = targetUSD > 0 ? previousSavedUSD / targetUSD : 0;
          const progressEndValue = targetUSD > 0 ? nextSavedUSD / targetUSD : progressStartValue;
          saveOverlayPayload = {
            ...saveOverlayPayload,
            goalTitle: targetWishSnapshot.title || "",
            remainingTemptations,
            goalComplete: remainingUSD <= 0,
            progressStart: progressStartValue,
            progressEnd: progressEndValue,
          };
          const progressPercent =
            targetUSD > 0 ? Math.min((nextSavedUSD / targetUSD) * 100, 100) : 0;
          if (normalizedTargetGoalId && appliedAmount > 0) {
            logEvent("saving_progress_updated", {
              target_id: normalizedTargetGoalId,
              amount_added: convertToCurrency(appliedAmount, currencyCode),
              new_progress: progressPercent,
            });
          }
        }
        if (
          (!Number.isFinite(saveOverlayPayload.progressStart) ||
            !Number.isFinite(saveOverlayPayload.progressEnd)) &&
          heroGoalTargetUSD > 0 &&
          priceUSD > 0
        ) {
          const heroStartValue = Math.min(
            1,
            Math.max(0, heroGoalTargetUSD > 0 ? heroGoalSavedUSD / heroGoalTargetUSD : 0)
          );
          const heroDeltaUSD = appliedAmount > 0 ? appliedAmount : priceUSD;
          const heroEndValue = Math.min(
            1,
            heroGoalTargetUSD > 0
              ? (heroGoalSavedUSD + heroDeltaUSD) / heroGoalTargetUSD
              : heroStartValue
          );
          if (heroEndValue > heroStartValue) {
            saveOverlayPayload = {
              ...saveOverlayPayload,
              progressStart: heroStartValue,
              progressEnd: heroEndValue,
            };
          }
        }
        const timestamp = saveTimestamp;
        const baseLevel = Math.max(
          1,
          Number(lastCelebratedLevel) || 1,
          levelCelebrationQueuedRef.current || 0
        );
        const projectedSavedTotal = savedTotalUSD + priceUSD;
        const projectedLevel = getTierProgress(
          Math.max(projectedSavedTotal, lifetimeSavedUSD || 0),
          profile.currency || DEFAULT_PROFILE.currency
        ).level;
        if (projectedLevel > baseLevel) {
          pendingLevelCelebrationRef.current = {
            level: projectedLevel,
            levelsEarned: projectedLevel - baseLevel,
          };
          levelCelebrationQueuedRef.current = Math.max(
            levelCelebrationQueuedRef.current || 0,
            projectedLevel
          );
        }
        const shouldDebugPrimarySave =
          __DEV__ && (overlay?.type === "primary_temptation" || isCustomTemptation(item));
        lastSaveActionAtRef.current = saveTimestamp;
        setSavedTotalUSD((prev) => {
          const nextValue = prev + priceUSD;
          if (shouldDebugPrimarySave) {
            console.warn("primary_temptation_saved_total_update", {
              prev,
              next: nextValue,
              priceUSD,
              itemId: item?.id,
              templateId,
            });
          }
          return nextValue;
        });
        setDeclineCount((prev) => prev + 1);
        const coinReward = priceUSD
          ? computeRefuseCoinReward(priceUSD, profile.currency || DEFAULT_PROFILE.currency)
          : 0;
        if (coinReward > 0) {
          setHealthPoints((prev) => prev + coinReward);
        }
        setRefuseStats((prev) => {
          if (!templateId) return prev;
          const { entry: currentEntry, key: legacyKey } = getLegacyRefuseStatsEntry(prev, templateId, item);
          const current = currentEntry || {};
          const count = (current.count || 0) + 1;
          const totalUSD = (current.totalUSD || 0) + priceUSD;
          const previousStreak =
            restoredStreakOverride !== null
              ? restoredStreakOverride
              : current.lastAction === "save"
              ? current.currentStreak || 0
              : 0;
          const currentStreak = previousStreak + 1;
          const bestStreak = Math.max(current.bestStreak || 0, currentStreak);
          if (pendingStreakRecoveryRef.current?.[templateId]) {
            delete pendingStreakRecoveryRef.current[templateId];
          }
          const next = {
            ...prev,
            [templateId]: {
              ...current,
              count,
              totalUSD,
              lastSavedAt: timestamp,
              lastSavedAmountUSD: priceUSD,
              currentStreak,
              bestStreak,
              lastAction: "save",
              streakLostAt: null,
              recoverableStreak: 0,
              recoverableAmountUSD: 0,
            },
          };
          if (legacyKey && legacyKey !== templateId) {
            delete next[legacyKey];
          }
          return next;
        });
        if (templateId && streakRecoveryOverrideRef.current?.[templateId]) {
          delete streakRecoveryOverrideRef.current[templateId];
        }
        logHistoryEvent("refuse_spend", {
          title,
          amountUSD: priceUSD,
          templateId: templateId || item.id,
          goalId: normalizedTargetGoalId || null,
          coinReward,
          currency: profile.currency || DEFAULT_PROFILE.currency,
        });
        const refuseStatsEntry = streakStatsEntry || {};
        logEvent(
          "temptation_save",
          buildTemptationPayload(item, {
            total_saved_usd: savedTotalUSD + priceUSD,
            refuse_count_for_item: (refuseStatsEntry.count || 0) + 1,
          })
        );
        logTemptationAction("save", item, { goal_id: normalizedTargetGoalId || null });
        logImpulseEvent("save", item, priceUSD, title);
        triggerCardFeedback(templateId || item.id);
        triggerCoinHaptics();
        handleFocusSaveProgress(item);
      ensureOverlayEnvironmentReady();
    triggerOverlayState(
      "save",
      { ...saveOverlayPayload, coinReward },
      { clearQueueOnDismiss: false, force: !!forceOverlay }
    );
        requestMascotAnimation("happy");
        saveActionLogRef.current = [...recentSaves, { itemId: templateId || item.id, timestamp: saveTimestamp }];
        recordTemptationInteraction(templateId || item.id, "save", item);
        queueHomeSpeech("save");
        return;
      }
      if (type === "maybe") {
        logEvent(
          "temptation_think_later",
          buildTemptationPayload(item, { reminder_days: REMINDER_DAYS })
        );
        logTemptationAction("pending", item);
        const now = Date.now();
        const pendingEntry = {
          id: `pending-${item.id}-${now}`,
          templateId: templateId || item.id,
          title,
          priceUSD,
          pricePrecision: getTemptationPricePrecision(item),
          createdAt: now,
          decisionDue: now + REMINDER_MS,
          notificationId: null,
        };
        logEvent(
          "pending_added",
          buildTemptationPayload(item, {
            remind_at: pendingEntry.decisionDue,
          })
        );
        const reminderId = await schedulePendingReminder(title, pendingEntry.decisionDue, {
          pendingId: pendingEntry.id,
          templateId: pendingEntry.templateId,
          title,
          emoji: item?.emoji || "âœ¨",
          amountUSD: priceUSD,
        });
        if (reminderId) pendingEntry.notificationId = reminderId;
        setPendingList((prev) => [pendingEntry, ...prev]);
        logHistoryEvent("pending_added", { title, amountUSD: priceUSD, pendingId: pendingEntry.id });
        triggerOverlayState("cart", t("pendingAdded"));
        triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
        return;
      }
      Alert.alert("Almost", t("actionSoon"));
    },
    [
      language,
      t,
      thinkingUnlocked,
      schedulePendingReminder,
      logHistoryEvent,
      triggerCardFeedback,
      triggerCoinHaptics,
      buildTemptationPayload,
      buildPrimaryGoalWishSnapshot,
      savedTotalUSD,
      refuseStats,
      logImpulseEvent,
      logTemptationAction,
      resolveTemptationGoalId,
      assignableGoals.length,
      assignTemptationGoal,
      applySavingsToWish,
      syncPrimaryGoalProgress,
      setProfile,
      setProfileDraft,
      setWishes,
      setGoalLinkPrompt,
      getFallbackGoalId,
      wishes,
      moodPreset,
      requestMascotAnimation,
      handleFocusSaveProgress,
      ensureOverlayEnvironmentReady,
      logEvent,
      profile.currency,
      profile.customSpend,
      profile.primaryGoals,
      executeSpend,
      triggerStormEffect,
      recordTemptationInteraction,
      triggerOverlayState,
      clearStreakRecoveryForTemptation,
      getLegacyRefuseStatsEntry,
      normalizeLegacyRecoveryRefs,
      queueHomeSpeech,
      lastCelebratedLevel,
      lifetimeSavedUSD,
      healthPoints,
      setHealthPoints,
      setStreakRecoveryPrompt,
      resolveTemptationTemplateId,
      dismissStormEffect,
      activeGoalId,
      mainGoalWish,
      profile.goal,
      profile.primaryGoals,
      overlay,
      openCategoryPrompt,
      shouldPromptCategory,
    ]
  );

  const handleCategoryPromptConfirm = useCallback(() => {
    const item = categoryPrompt.item;
    if (!item) {
      closeCategoryPrompt();
      return;
    }
    const templateId = resolveTemptationTemplateId(item) || item.id;
    const selected =
      categoryPromptSelection && IMPULSE_CATEGORY_DEFS[categoryPromptSelection]
        ? categoryPromptSelection
        : resolveTemptationCategory(item);
    if (templateId && selected && IMPULSE_CATEGORY_DEFS[selected]) {
      setCategoryOverrides((prev) => ({ ...prev, [templateId]: selected }));
    }
    const nextAction = categoryPrompt.action;
    const nextOptions = categoryPrompt.options || {};
    closeCategoryPrompt();
    if (nextAction) {
      handleTemptationAction(nextAction, item, { ...nextOptions, skipCategoryPrompt: true });
    }
  }, [
    categoryPrompt.action,
    categoryPrompt.item,
    categoryPrompt.options,
    categoryPromptSelection,
    closeCategoryPrompt,
    handleTemptationAction,
    resolveTemptationCategory,
    resolveTemptationTemplateId,
    setCategoryOverrides,
  ]);

  const openAddCategoryModal = useCallback(() => {
    setAddCategoryName("");
    setAddCategoryEmoji("âœ¨");
    setAddCategoryError(false);
    setAddCategoryModalVisible(true);
  }, []);

  const closeAddCategoryModal = useCallback(() => {
    setAddCategoryModalVisible(false);
    setAddCategoryError(false);
  }, []);

  const handleAddCategorySave = useCallback(() => {
    const trimmed = (addCategoryName || "").trim();
    if (!trimmed) {
      setAddCategoryError(true);
      return;
    }
    const emoji = limitEmojiInput(addCategoryEmoji) || "âœ¨";
    const def = registerCustomCategory({
      id: trimmed,
      ru: trimmed,
      en: trimmed,
      es: trimmed,
      fr: trimmed,
      emoji,
    });
    if (def) {
      setCustomCategories((prev) => {
        const next = [...prev, def];
        logEvent("custom_category_created", { count: next.length, category_id: def.id });
        return next;
      });
    }
    closeAddCategoryModal();
  }, [addCategoryEmoji, addCategoryName, closeAddCategoryModal, logEvent]);

  const handleStreakRecoveryDecline = useCallback(() => {
    const { item, options, templateId } = streakRecoveryPrompt;
    if (!item) {
      hideStreakRecoveryPrompt();
      return;
    }
    const resolvedTemplateId = resolveTemptationTemplateId(item, templateId);
    if (resolvedTemplateId) {
      normalizeLegacyRecoveryRefs(resolvedTemplateId, item);
      clearStreakRecoveryForTemptation(resolvedTemplateId);
      setRefuseStats((prev) => {
        const { entry: currentEntry, key: legacyKey } = getLegacyRefuseStatsEntry(prev, resolvedTemplateId, item);
        const current = currentEntry || prev?.[resolvedTemplateId];
        if (!current) return prev;
        const next = {
          ...prev,
          [resolvedTemplateId]: {
            ...current,
            currentStreak: 0,
            lastAction: "spend",
            recoverableStreak: 0,
            recoverableAmountUSD: 0,
            streakLostAt: Date.now(),
          },
        };
        if (legacyKey && legacyKey !== resolvedTemplateId) {
          delete next[legacyKey];
        }
        return next;
      });
    }
    hideStreakRecoveryPrompt();
    handleTemptationAction("save", item, options || {});
  }, [
    clearStreakRecoveryForTemptation,
    getLegacyRefuseStatsEntry,
    handleTemptationAction,
    hideStreakRecoveryPrompt,
    normalizeLegacyRecoveryRefs,
    resolveTemptationTemplateId,
    setRefuseStats,
    streakRecoveryPrompt,
  ]);

  const handleStreakRecoveryConfirm = useCallback(() => {
    const {
      item,
      options,
      coinCost,
      recoverableStreak,
      recoverableAmountUSD,
      templateId,
    } = streakRecoveryPrompt;
    if (!item) {
      hideStreakRecoveryPrompt();
      return;
    }
    const resolvedTemplateId = resolveTemptationTemplateId(item, templateId);
    if (!resolvedTemplateId) {
      hideStreakRecoveryPrompt();
      return;
    }
    if (healthPoints < coinCost) {
      setStreakRecoveryPrompt((prev) => ({
        ...prev,
        errorMessage: t("streakRecoveryInsufficient", { coins: prev.coinCost }),
      }));
      return;
    }
    setHealthPoints((prev) => Math.max(prev - coinCost, 0));
    streakRestoreSoundPendingRef.current = true;
    const restoredValue = Math.max(recoverableStreak || 0, 0);
    const recoveryAmountUSD = Math.max(Number(recoverableAmountUSD) || 0, 0);
    normalizeLegacyRecoveryRefs(resolvedTemplateId, item);
    streakRecoveryOverrideRef.current[resolvedTemplateId] = { streak: restoredValue };
    setRefuseStats((prev) => {
      const { entry: current, key: legacyKey } = getLegacyRefuseStatsEntry(prev, resolvedTemplateId, item);
      if (!current) return prev;
      const restoredCurrent = Math.max(
        recoverableStreak || current.recoverableStreak || 0,
        0
      );
      const next = {
        ...prev,
        [resolvedTemplateId]: {
          ...current,
          currentStreak: restoredCurrent,
          lastAction: "save",
          recoverableStreak: 0,
          recoverableAmountUSD: 0,
        },
      };
      if (legacyKey && legacyKey !== resolvedTemplateId) {
        delete next[legacyKey];
      }
      return next;
    });
    if (pendingStreakRecoveryRef.current?.[resolvedTemplateId]) {
      delete pendingStreakRecoveryRef.current[resolvedTemplateId];
    }
    logHistoryEvent("streak_restore", {
      templateId: resolvedTemplateId,
      restoredStreak: restoredValue,
      amountUSD: recoveryAmountUSD,
      coinCost,
    });
    hideStreakRecoveryPrompt();
    const nextOptions = {
      ...(options || {}),
      skipStreakRecoveryPrompt: true,
      restoredStreakValue: restoredValue,
    };
    handleTemptationAction("save", item, nextOptions);
  }, [
    getLegacyRefuseStatsEntry,
    handleTemptationAction,
    healthPoints,
    hideStreakRecoveryPrompt,
    normalizeLegacyRecoveryRefs,
    pendingStreakRecoveryRef,
    playSound,
    resolveTemptationTemplateId,
    streakRecoveryOverrideRef,
    setHealthPoints,
    setRefuseStats,
    setStreakRecoveryPrompt,
    streakRecoveryPrompt,
    t,
    logHistoryEvent,
  ]);

  const closeGoalLinkPrompt = useCallback(() => {
    setGoalLinkPrompt({ visible: false, item: null, intent: null, streakRecoveryValue: null });
  }, []);

  const handleGoalLinkSelect = useCallback(
    (wishId) => {
      const sourceItem = goalLinkPrompt.item;
      const intent = goalLinkPrompt.intent;
      const streakRecoveryValue = goalLinkPrompt.streakRecoveryValue;
      const templateId = resolveTemptationTemplateId(sourceItem);
      closeGoalLinkPrompt();
      if (!wishId || !sourceItem) return;
      if (intent === "save") {
        handleTemptationAction("save", sourceItem, {
          skipPrompt: true,
          goalId: wishId,
          shouldAssign: true,
          restoredStreakValue: streakRecoveryValue ?? null,
        });
        return;
      }
      assignTemptationGoal(templateId || sourceItem.id, wishId);
    },
    [
      assignTemptationGoal,
      closeGoalLinkPrompt,
      goalLinkPrompt,
      handleTemptationAction,
      resolveTemptationTemplateId,
    ]
  );

  const handleGoalLongPress = useCallback(
    (wish) => {
      if (!wish) return;
      triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
      setGoalTemptationPrompt({ visible: true, wish });
    },
    [triggerHaptic]
  );

  const closeGoalTemptationPrompt = useCallback(() => {
    setGoalTemptationPrompt({ visible: false, wish: null });
  }, []);

  const handleGoalTemptationAssign = useCallback(
    (templateId) => {
      const targetWish = goalTemptationPrompt.wish;
      closeGoalTemptationPrompt();
      if (!templateId || !targetWish) return;
      assignTemptationGoal(templateId, targetWish.id);
    },
    [assignTemptationGoal, closeGoalTemptationPrompt, goalTemptationPrompt]
  );

  const handleNewPendingSubmit = useCallback(async () => {
    const trimmedTitle = (newPendingModal.title || "").trim();
    if (!trimmedTitle) {
      Alert.alert("Almost", t("pendingCustomError"));
      return;
    }
    const parsedLocal = parseNumberInputValue(newPendingModal.amount);
    if (!Number.isFinite(parsedLocal) || parsedLocal <= 0) {
      Alert.alert("Almost", t("pendingCustomError"));
      return;
    }
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const amountUSD = convertFromCurrency(parsedLocal, currencyCode);
    const emoji = normalizeEmojiValue(newPendingModal.emoji, DEFAULT_TEMPTATION_EMOJI);
    const manualPrecision = getManualInputPrecision(newPendingModal.amount || "");
    const manualItem = {
      id: `manual_pending_${Date.now()}`,
      title: trimmedTitle,
      emoji,
      priceUSD: amountUSD,
      basePriceUSD: amountUSD,
      pricePrecision: manualPrecision,
      categories: [],
    };
    await handleTemptationAction("maybe", manualItem);
    setNewPendingModal({ visible: false, title: "", amount: "", emoji: DEFAULT_TEMPTATION_EMOJI });
  }, [handleTemptationAction, newPendingModal, profile.currency, t]);

  const openGoalEditorPrompt = useCallback(
    (wish) => {
      if (!wish) return;
      const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
      const targetLocal = formatNumberInputValue(convertToCurrency(wish.targetUSD || 0, currencyCode));
      setGoalEditorPrompt({
        visible: true,
        wish,
        name: getWishTitleWithoutEmoji(wish) || "",
        target: targetLocal,
        emoji: normalizeEmojiValue(wish.emoji || resolveWishEmoji(wish), DEFAULT_GOAL_EMOJI),
      });
    },
    [profile.currency]
  );

  const closeGoalEditorPrompt = useCallback(() => {
    setGoalEditorPrompt({
      visible: false,
      wish: null,
      name: "",
      target: "",
      emoji: DEFAULT_GOAL_EMOJI,
    });
  }, []);

  const handleGoalEditorNameChange = useCallback((value) => {
    setGoalEditorPrompt((prev) => ({ ...prev, name: value }));
  }, []);

  const handleGoalEditorTargetChange = useCallback((value) => {
    setGoalEditorPrompt((prev) => ({ ...prev, target: value }));
  }, []);

  const handleGoalEditorEmojiChange = useCallback((value) => {
    setGoalEditorPrompt((prev) => ({ ...prev, emoji: limitEmojiInput(value) }));
  }, []);

  const saveGoalEditorPrompt = useCallback(() => {
    if (!goalEditorPrompt.wish) return;
    const trimmedName = goalEditorPrompt.name?.trim();
    if (!trimmedName) {
      Alert.alert("Almost", t("goalEditNameError"));
      return;
    }
    const parsed = parseNumberInputValue(goalEditorPrompt.target);
    if (!Number.isFinite(parsed) || parsed <= 0) {
      Alert.alert("Almost", t("goalEditTargetError"));
      return;
    }
    const fallbackEmoji = resolveWishEmoji(goalEditorPrompt.wish);
    const normalizedEmoji = normalizeEmojiValue(
      goalEditorPrompt.emoji,
      fallbackEmoji || DEFAULT_GOAL_EMOJI
    );
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const nextTargetUSD = convertFromCurrency(parsed, currencyCode);
    let resultingStatus = goalEditorPrompt.wish.status || "active";
    setWishes((prev) => {
      let statusCapture = resultingStatus;
      const next = prev.map((wish) => {
        if (wish.id !== goalEditorPrompt.wish.id) return wish;
        const nextSaved = Math.min(wish.savedUSD || 0, nextTargetUSD);
        const nextStatus = nextSaved >= nextTargetUSD ? "done" : "active";
        statusCapture = nextStatus;
        return {
          ...wish,
          title: trimmedName,
          emoji: normalizedEmoji,
          targetUSD: nextTargetUSD,
          savedUSD: nextSaved,
          status: nextStatus,
        };
      });
      resultingStatus = statusCapture;
      return next;
    });
    const shouldResetCelebration = resultingStatus !== "done";
    if (
      goalEditorPrompt.wish.kind === PRIMARY_GOAL_KIND &&
      goalEditorPrompt.wish.goalId
    ) {
      const goalExtras = {
        customTitle: trimmedName,
        customEmoji: normalizedEmoji,
      };
      setProfile((prev) => {
        const updated = updatePrimaryGoalTargetInProfile(
          prev,
          goalEditorPrompt.wish.goalId,
          nextTargetUSD,
          goalExtras
        );
        return shouldResetCelebration
          ? { ...updated, goalCelebrated: false, goalRenewalPending: false }
          : updated;
      });
      setProfileDraft((prev) => {
        const updated = updatePrimaryGoalTargetInProfile(
          prev,
          goalEditorPrompt.wish.goalId,
          nextTargetUSD,
          goalExtras
        );
        return shouldResetCelebration
          ? { ...updated, goalCelebrated: false, goalRenewalPending: false }
          : updated;
      });
    }
    if (shouldResetCelebration) {
      dismissGoalRenewalPrompt();
    }
    closeGoalEditorPrompt();
  }, [
    closeGoalEditorPrompt,
    dismissGoalRenewalPrompt,
    goalEditorPrompt,
    profile.currency,
    setProfile,
    setProfileDraft,
    t,
  ]);

  const handleGoalRenewalLater = useCallback(() => {
    dismissGoalRenewalPrompt();
    const currentGoalId = mainGoalWish?.goalId || profile.primaryGoals?.[0]?.id || null;
    setProfile((prev) => ({ ...prev, goalRenewalPending: false }));
    setProfileDraft((prev) => ({ ...prev, goalRenewalPending: false }));
    logEvent("goal_renewal_later", { goal_id: currentGoalId });
  }, [dismissGoalRenewalPrompt, mainGoalWish, profile.primaryGoals, setProfile, setProfileDraft]);

  const handleGoalRenewalStart = useCallback(() => {
    dismissGoalRenewalPrompt();
    setProfile((prev) => ({ ...prev, goalRenewalPending: false }));
    setProfileDraft((prev) => ({ ...prev, goalRenewalPending: false }));
    goToTab("cart");
    const targetWish = mainGoalWish || selectMainGoalWish(wishes);
    logEvent("goal_renewal_start", { had_existing_goal: !!targetWish });
    setTimeout(() => {
      openNewGoalModal(true, "goal_renewal");
    }, 280);
  }, [
    dismissGoalRenewalPrompt,
    goToTab,
    mainGoalWish,
    openNewGoalModal,
    wishes,
    setProfile,
    setProfileDraft,
  ]);

  const handleLogFreeDay = useCallback(() => {
    if (!freeDayUnlocked) return;
    const today = new Date();
    const todayKey = getDayKey(today);
    if (freeDayStats.lastDate === todayKey) {
      Alert.alert("Almost", t("freeDayLoggedToday"));
      return;
    }
    Alert.alert("Almost", t("freeDayConfirm"), [
      { text: t("priceEditCancel"), style: "cancel" },
      {
        text: t("freeDayButton"),
        onPress: () => {
          const yesterdayKey = getDayKey(new Date(today.getTime() - DAY_MS));
          const continues = freeDayStats.lastDate === yesterdayKey;
          const current = continues ? freeDayStats.current + 1 : 1;
          const best = Math.max(freeDayStats.best, current);
          const total = freeDayStats.total + 1;
          let achievements = [...freeDayStats.achievements];
          const newMilestones = FREE_DAY_MILESTONES.filter(
            (m) => current >= m && !achievements.includes(m)
          );
          achievements = [...achievements, ...newMilestones];
          setFreeDayStats({
            total,
            current,
            best,
            lastDate: todayKey,
            achievements,
            blockedDate: null,
          });
          logHistoryEvent("free_day", { total, current, best });
          logEvent("free_day_logged", {
            total,
            current_streak: current,
            best_streak: best,
            weekday: today.getDay(),
            persona: profile.persona || "unknown",
            goal: resolveProfileGoalId(profile) || "none",
          });
          newMilestones.forEach((milestone) => {
            logEvent("free_day_milestone", {
              milestone,
              current_streak: current,
            });
          });
          const message =
            newMilestones.length > 0
              ? t("freeDayMilestone", { days: current })
              : t("freeDayCongrats", { days: current });
          triggerOverlayState("purchase", message);
          triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
          const rewardBlueCoins = FREE_DAY_LOGIN_BLUE_COINS * current;
          const rewardHealthPoints = rewardBlueCoins * BLUE_HEALTH_COIN_VALUE;
          setHealthPoints((prev) => prev + rewardHealthPoints);
          const rewardReason =
            current > 1
              ? t("freeDayCoinRewardStreak", { coins: rewardBlueCoins, days: current })
              : t("freeDayCoinReward", { coins: rewardBlueCoins });
          triggerOverlayState("health", {
            amount: rewardHealthPoints,
            displayCoins: rewardBlueCoins,
            coinValue: BLUE_HEALTH_COIN_VALUE,
            reason: rewardReason,
          });
          logEvent("free_day_coin_reward", {
            blue_coins: rewardBlueCoins,
            health_points: rewardHealthPoints,
            current_streak: current,
          });
        },
      },
    ]);
  }, [
    freeDayUnlocked,
    freeDayStats,
    t,
    logEvent,
    logHistoryEvent,
    profile.goal,
    profile.persona,
    profile.primaryGoals,
    resolveProfileGoalId,
    setHealthPoints,
    triggerOverlayState,
  ]);

  const toggleTemptationEditor = useCallback(
    (item) => {
      if (!item) return;
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
      triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
      setPriceEditor((prev) => {
        if (prev.item?.id === item.id) {
          return {
            item: null,
            value: "",
            title: "",
            emoji: "",
            category: DEFAULT_IMPULSE_CATEGORY,
            description: "",
          };
        }
        const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
        const currentValue = convertToCurrency(item.priceUSD || item.basePriceUSD || 0, currencyCode);
        const precisionOverride = getTemptationPricePrecision(item);
        const inputPrecision =
          precisionOverride !== null ? precisionOverride : getCurrencyDisplayPrecision(currencyCode);
        const categorySlug = resolveTemptationCategory(item);
        const descriptionString = typeof item.description === "string" ? item.description : null;
        const descriptionMap =
          item.description && typeof item.description === "object" && !Array.isArray(item.description)
            ? item.description
            : null;
        const isCustom =
          Array.isArray(item?.categories) && item.categories.some((category) => category === "custom");
        const customDescriptionFallback = isCustom
          ? buildCustomTemptationDescription(item?.gender || "none")
          : null;
        const customLanguageFallback = customDescriptionFallback
          ? resolveLanguageMapValue(customDescriptionFallback, language)
          : null;
        const descriptionLanguageValue = descriptionMap ? resolveLanguageMapValue(descriptionMap, language) : null;
        const overrideDescription =
          typeof descriptionOverrides[item.id] === "string"
            ? descriptionOverrides[item.id]
            : "";
        const baseDescription = descriptionLanguageValue || descriptionString || "";
        const computedDescription = isCustom ? baseDescription || customLanguageFallback || "" : baseDescription;
        const resolvedDescription =
          (overrideDescription && overrideDescription.length ? overrideDescription : computedDescription);
        logEvent("temptation_viewed", {
          temptation_id: item.id,
          category: categorySlug,
          price: convertToCurrency(item.priceUSD || item.basePriceUSD || 0, currencyCode),
        });
        return {
          item,
          value: formatNumberInputValue(Number(currentValue) || 0, inputPrecision),
          title: resolveTemptationTitle(item, language, titleOverrides[item.id]),
          emoji: item.emoji || DEFAULT_TEMPTATION_EMOJI,
          category: categorySlug,
          description: resolvedDescription,
        };
      });
    },
    [language, profile.currency, titleOverrides, descriptionOverrides, resolveTemptationCategory]
  );

  const closePriceEditor = useCallback(() => {
    if (!priceEditor.item) return;
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    setPriceEditor({
      item: null,
      value: "",
      title: "",
      emoji: "",
      category: DEFAULT_IMPULSE_CATEGORY,
      description: "",
    });
  }, [priceEditor.item]);

  useEffect(() => {
    if (priceEditor.item) {
      if (!editOverlayVisible) setEditOverlayVisible(true);
      Animated.timing(editOverlayAnim, {
        toValue: 1,
        duration: 220,
        easing: Easing.out(Easing.cubic),
        useNativeDriver: true,
      }).start();
    } else if (editOverlayVisible) {
      Animated.timing(editOverlayAnim, {
        toValue: 0,
        duration: 180,
        easing: Easing.in(Easing.cubic),
        useNativeDriver: true,
      }).start(({ finished }) => {
        if (finished) setEditOverlayVisible(false);
      });
    }
  }, [priceEditor.item, editOverlayAnim, editOverlayVisible]);

  const handlePriceTitleChange = (value) => {
    setPriceEditor((prev) => ({ ...prev, title: value }));
  };

  const handlePriceEmojiChange = (value) => {
    setPriceEditor((prev) => ({ ...prev, emoji: limitEmojiInput(value) }));
  };

  const handlePriceCategoryChange = (value) => {
    if (!IMPULSE_CATEGORY_DEFS[value]) return;
    setPriceEditor((prev) => ({ ...prev, category: value }));
  };

  const handleQuickGoalToggle = useCallback(
    (item) => {
      if (!item) return;
      const existing = (wishes || []).find((wish) => wish.templateId === item.id);
      if (existing) {
        setWishes((prev) => prev.filter((wish) => wish.id !== existing.id));
        assignTemptationGoal(item.id, null);
        logHistoryEvent("wish_removed", { title: existing.title });
        triggerOverlayState("cart", t("goalRemoved"));
        triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
        return;
      }
      handleTemptationAction("want", item, { pinnedBy: "swipe" });
    },
    [
      assignTemptationGoal,
      handleTemptationAction,
      logHistoryEvent,
      t,
      triggerHaptic,
      triggerOverlayState,
      wishes,
    ]
  );

  const handlePriceInputChange = (value) => {
    setPriceEditor((prev) => ({ ...prev, value }));
  };

  const handlePriceDescriptionChange = (value) => {
    setPriceEditor((prev) => ({ ...prev, description: value }));
  };

  const patchTemptationDisplay = useCallback((templateId, patch = {}) => {
    if (!templateId || !patch || typeof patch !== "object") return;
    setTemptations((prev) =>
      prev.map((card) => (card.id === templateId ? { ...card, ...patch } : card))
    );
    setQuickTemptations((prev) => {
      let changed = false;
      const next = prev.map((card) => {
        if (card.id !== templateId) return card;
        changed = true;
        return { ...card, ...patch };
      });
      return changed ? next : prev;
    });
  }, []);

  const removeTemptationTemplate = useCallback(
    (templateId) => {
      if (!templateId) return;
      const existsInQuick = quickTemptations.some((card) => card.id === templateId);
      if (existsInQuick) {
        setQuickTemptations((prev) => prev.filter((card) => card.id !== templateId));
      } else {
        setHiddenTemptations((prev) => (prev.includes(templateId) ? prev : [...prev, templateId]));
      }
      setTemptationGoalMap((prev) => {
        if (!prev[templateId]) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setCatalogOverrides((prev) => {
        if (!(templateId in prev)) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setPricePrecisionOverrides((prev) => {
        if (!(templateId in prev)) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setTitleOverrides((prev) => {
        if (!(templateId in prev)) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setEmojiOverrides((prev) => {
        if (!(templateId in prev)) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setCategoryOverrides((prev) => {
        if (!(templateId in prev)) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setDescriptionOverrides((prev) => {
        if (!(templateId in prev)) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setRefuseStats((prev) => {
        if (!prev[templateId]) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setPendingList((prev) => prev.filter((entry) => entry.templateId !== templateId));
    },
    [
      quickTemptations,
      setQuickTemptations,
      setHiddenTemptations,
      setTemptationGoalMap,
      setCatalogOverrides,
      setPricePrecisionOverrides,
      setTitleOverrides,
      setEmojiOverrides,
      setDescriptionOverrides,
      setRefuseStats,
      setPendingList,
    ]
  );

  const persistPriceOverride = (valueUSD = null, precision = null) => {
    const targetId = priceEditor.item?.id;
    if (!targetId) return;
    setCatalogOverrides((prev) => {
      const next = { ...prev };
      if (valueUSD) {
        next[targetId] = valueUSD;
      } else {
        delete next[targetId];
      }
      return next;
    });
    setPricePrecisionOverrides((prev) => {
      const next = { ...prev };
      const hasPrecision = typeof precision === "number" && Number.isFinite(precision) && precision >= 0;
      if (valueUSD && hasPrecision) {
        next[targetId] = precision;
      } else if (!valueUSD || !hasPrecision) {
        delete next[targetId];
      }
      return next;
    });
  };

  const persistTitleOverride = (value = null) => {
    const targetId = priceEditor.item?.id;
    if (!targetId) return;
    setTitleOverrides((prev) => {
      const next = { ...prev };
      if (value && value.length) {
        next[targetId] = value;
      } else {
        delete next[targetId];
      }
      return next;
    });
  };

  const persistEmojiOverride = (value = null) => {
    const targetId = priceEditor.item?.id;
    if (!targetId) return;
    setEmojiOverrides((prev) => {
      const next = { ...prev };
      if (value && value.length) {
        next[targetId] = value;
      } else {
        delete next[targetId];
      }
      return next;
    });
  };

  const persistDescriptionOverride = (value = null) => {
    const targetId = priceEditor.item?.id;
    if (!targetId) return;
    setDescriptionOverrides((prev) => {
      const next = { ...prev };
      const normalized =
        typeof value === "string" && value.trim().length ? value.trim() : null;
      if (normalized) {
        next[targetId] = normalized;
      } else {
        delete next[targetId];
      }
      return next;
    });
  };

  const persistCategoryOverride = (value = null) => {
    const targetId = priceEditor.item?.id;
    if (!targetId) return;
    setCategoryOverrides((prev) => {
      const next = { ...prev };
      if (value && IMPULSE_CATEGORY_DEFS[value]) {
        next[targetId] = value;
      } else {
        delete next[targetId];
      }
      return next;
    });
  };

  const propagateTemptationEdit = useCallback(
    (templateId, { label, emoji, priceUSD, category, pricePrecision = null }) => {
      if (!templateId) return;
      const fallbackTitle = resolveTranslationValueForLanguage(language, "defaultWishTitle") || "Goal";
      const normalizedLabel = (label && label.trim()) || fallbackTitle;
      const decoratedTitle = buildTemptationDisplayTitle(emoji, normalizedLabel, fallbackTitle);
      const numericPrice = Number(priceUSD);
      const hasPrice = Number.isFinite(numericPrice) && numericPrice > 0;
      const normalizedPrecision =
        typeof pricePrecision === "number" && Number.isFinite(pricePrecision) && pricePrecision >= 0
          ? pricePrecision
          : null;
      setPendingList((prev) => {
        let mutated = false;
        const next = prev.map((entry) => {
          if (entry.templateId !== templateId) return entry;
          const updates = {};
          if (decoratedTitle && entry.title !== decoratedTitle) {
            updates.title = decoratedTitle;
          }
          if (hasPrice && entry.priceUSD !== numericPrice) {
            updates.priceUSD = numericPrice;
          }
          if (normalizedPrecision !== null && entry.pricePrecision !== normalizedPrecision) {
            updates.pricePrecision = normalizedPrecision;
          } else if (normalizedPrecision === null && entry.pricePrecision != null) {
            updates.pricePrecision = null;
          }
          if (!Object.keys(updates).length) return entry;
          mutated = true;
          return { ...entry, ...updates };
        });
        return mutated ? next : prev || [];
      });
      setWishes((prev) => {
        let mutated = false;
        const next = prev.map((wish) => {
          if (wish.templateId !== templateId) return wish;
          const updates = {};
          if (decoratedTitle && wish.title !== decoratedTitle) {
            updates.title = decoratedTitle;
          }
          if (emoji && wish.emoji !== emoji) {
            updates.emoji = emoji;
          }
          if (hasPrice && wish.targetUSD !== numericPrice) {
            updates.targetUSD = numericPrice;
          }
          if (!Object.keys(updates).length) return wish;
          mutated = true;
          return { ...wish, ...updates };
        });
        return mutated ? next : prev;
      });
      setImpulseTracker((prev) => {
        const current = prev || INITIAL_IMPULSE_TRACKER;
        let mutated = false;
        const nextEvents = (current.events || []).map((event) => {
          if (event.templateId !== templateId) return event;
          const updates = {};
          if (decoratedTitle && event.title !== decoratedTitle) {
            updates.title = decoratedTitle;
          }
          if (emoji && event.emoji !== emoji) {
            updates.emoji = emoji;
          }
          if (hasPrice && event.amountUSD !== numericPrice) {
            updates.amountUSD = numericPrice;
          }
          if (category && event.category !== category) {
            updates.category = category;
          }
          if (!Object.keys(updates).length) return event;
          mutated = true;
          return { ...event, ...updates };
        });
        if (!mutated) return current;
        return { ...current, events: nextEvents };
      });
      const historySnapshot = Array.isArray(resolvedHistoryEvents) ? resolvedHistoryEvents : [];
      let historyMutated = false;
      let savedDelta = 0;
      const goalDeltas = {};
      const nextHistory = historySnapshot.map((entry) => {
        if (!entry || !entry.meta) return entry;
        const metaTemplateId =
          entry?.meta?.templateId || entry?.meta?.template_id || entry?.meta?.templateID;
        if (metaTemplateId !== templateId) return entry;
        const nextMeta = { ...(entry.meta || {}) };
        let metaChanged = false;
        if (decoratedTitle && nextMeta.title !== decoratedTitle) {
          nextMeta.title = decoratedTitle;
          metaChanged = true;
        }
        if (emoji && nextMeta.emoji !== emoji) {
          nextMeta.emoji = emoji;
          metaChanged = true;
        }
        if (hasPrice) {
          if (typeof nextMeta.amountUSD === "number" && nextMeta.amountUSD !== numericPrice) {
            const delta = numericPrice - nextMeta.amountUSD;
            if (delta) {
              if (entry.kind === "refuse_spend") {
                savedDelta += delta;
                const goalId =
                  entry.meta?.goalId ||
                  entry.meta?.goal_id ||
                  entry.meta?.savingTargetId ||
                  entry.meta?.saving_target_id ||
                  null;
                if (goalId) {
                  goalDeltas[goalId] = (goalDeltas[goalId] || 0) + delta;
                }
              } else if (entry.kind === "spend" && spendReducesSavings) {
                savedDelta -= delta;
              }
            }
            nextMeta.amountUSD = numericPrice;
            metaChanged = true;
          }
          if (typeof nextMeta.targetUSD === "number" && nextMeta.targetUSD !== numericPrice) {
            nextMeta.targetUSD = numericPrice;
            metaChanged = true;
          }
          if (typeof nextMeta.priceUSD === "number" && nextMeta.priceUSD !== numericPrice) {
            nextMeta.priceUSD = numericPrice;
            metaChanged = true;
          }
        }
        if (!metaChanged) return entry;
        historyMutated = true;
        return { ...entry, meta: nextMeta };
      });
      if (historyMutated) {
        setHistoryEvents(nextHistory);
        if (savedDelta) {
          setSavedTotalUSD((prev) => Math.max(0, prev + savedDelta));
        }
        Object.entries(goalDeltas).forEach(([goalId, delta]) => {
          applyHistoryGoalDelta(goalId, delta);
        });
        if (hasPrice) {
          setChallengesState((prev) => rebuildChallengeProgressFromHistory(nextHistory, prev));
        }
      }
    },
    [
      applyHistoryGoalDelta,
      language,
      rebuildChallengeProgressFromHistory,
      resolvedHistoryEvents,
      setChallengesState,
      setHistoryEvents,
      setImpulseTracker,
      setPendingList,
      setSavedTotalUSD,
      setWishes,
      spendReducesSavings,
    ]
  );

  const savePriceEdit = () => {
    if (!priceEditor.item) return;
    const parsed = parseFloat((priceEditor.value || "").replace(",", "."));
    if (!Number.isFinite(parsed) || parsed <= 0) {
      Alert.alert("Almost", t("priceEditError"));
      return;
    }
    const usdValue = parsed / (CURRENCY_RATES[activeCurrency] || 1);
    const previousPriceUSD = priceEditor.item.priceUSD || priceEditor.item.basePriceUSD || 0;
    const manualPrecision = getManualInputPrecision(priceEditor.value || "");
    persistPriceOverride(usdValue, manualPrecision);
    const titleValue = (priceEditor.title || "").trim();
    persistTitleOverride(titleValue || null);
    const hasCustomEmoji = !!priceEditor.emoji?.trim();
    const resolvedEmoji = hasCustomEmoji
      ? normalizeEmojiValue(priceEditor.emoji, priceEditor.item.emoji || DEFAULT_TEMPTATION_EMOJI)
      : priceEditor.item.emoji || DEFAULT_TEMPTATION_EMOJI;
    persistEmojiOverride(hasCustomEmoji ? resolvedEmoji : null);
    const categoryValue =
      priceEditor.category && IMPULSE_CATEGORY_DEFS[priceEditor.category]
        ? priceEditor.category
        : null;
    const previousCategory = resolveTemptationCategory(priceEditor.item);
    const nextCategory = categoryValue || previousCategory;
    persistCategoryOverride(categoryValue);
    const descriptionValue = (priceEditor.description || "").trim();
    const previousDescriptionOverride =
      typeof descriptionOverrides[priceEditor.item.id] === "string"
        ? descriptionOverrides[priceEditor.item.id]
        : "";
    const changedDescription = descriptionValue !== previousDescriptionOverride;
    persistDescriptionOverride(descriptionValue || null);
    const changedPrice = Math.abs(previousPriceUSD - usdValue) > 0.0001;
    const changedCategory = nextCategory !== previousCategory;
    patchTemptationDisplay(priceEditor.item.id, {
      priceUSD: usdValue,
      pricePrecision: manualPrecision,
      titleOverride: titleValue || null,
      emoji: resolvedEmoji,
      impulseCategoryOverride: categoryValue || null,
      descriptionOverride: descriptionValue || null,
    });
    const fallbackTitle =
      resolveTemptationTitle(
        priceEditor.item,
        language,
        titleOverrides[priceEditor.item.id] || priceEditor.item.titleOverride || null
      ) || resolveTranslationValueForLanguage(language, "defaultWishTitle") || "Goal";
    const normalizedLabel = titleValue || fallbackTitle;
    propagateTemptationEdit(priceEditor.item.id, {
      label: normalizedLabel,
      emoji: resolvedEmoji,
      priceUSD: usdValue,
      category: nextCategory,
      pricePrecision: manualPrecision,
    });
    logEvent("temptation_edited", {
      temptation_id: priceEditor.item.id,
      changed_price: changedPrice,
      changed_category: changedCategory,
      changed_description: changedDescription,
    });
    closePriceEditor();
  };

  const promptTemptationDelete = useCallback(
    (targetItem = null) => {
      const item = targetItem || priceEditor.item;
      if (!item) return;
      Alert.alert(t("priceEditDelete"), t("priceEditDeleteConfirm"), [
        { text: t("priceEditCancel"), style: "cancel" },
        {
          text: t("priceEditDelete"),
          style: "destructive",
          onPress: () => {
            logEvent("temptation_deleted", {
              temptation_id: item.id,
              is_custom: isCustomTemptation(item),
              price: convertToCurrency(
                item.priceUSD || item.basePriceUSD || 0,
                profile.currency || DEFAULT_PROFILE.currency
              ),
            });
            removeTemptationTemplate(item.id);
            if (priceEditor.item?.id === item.id) {
              closePriceEditor();
            }
          },
        },
      ]);
    },
    [closePriceEditor, logEvent, priceEditor.item, profile.currency, removeTemptationTemplate, t]
  );
  const handleTemptationDelete = useCallback(
    (item) => {
      promptTemptationDelete(item);
    },
    [promptTemptationDelete]
  );

  const handleRemoveWish = useCallback(
    (wishId) => {
      const targetWish = wishes.find((wish) => wish.id === wishId);
      if (!targetWish) return;
      const performRemoval = () => {
        setWishes((prev) => prev.filter((wish) => wish.id !== wishId));
        if (
          targetWish.kind === PRIMARY_GOAL_KIND &&
          targetWish.goalId
        ) {
          setProfile((prev) => removePrimaryGoalFromProfile(prev, targetWish.goalId));
          setProfileDraft((prev) => removePrimaryGoalFromProfile(prev, targetWish.goalId));
        }
        logEvent("goal_abandoned", {
          goal_id: targetWish.goalId || targetWish.id,
          reason: "deleted",
        });
      };
      Alert.alert(t("wishlistTitle"), t("wishlistRemoveConfirm"), [
        { text: t("priceEditCancel"), style: "cancel" },
        {
          text: t("wishlistRemove"),
          style: "destructive",
          onPress: performRemoval,
        },
      ]);
    },
    [logEvent, setProfile, setProfileDraft, t, wishes]
  );

  const handlePendingDecision = useCallback(
    async (pendingItem, decision) => {
      if (!pendingItem) return;
      if (pendingItem.notificationId) {
        try {
          await Notifications.cancelScheduledNotificationAsync(pendingItem.notificationId);
        } catch (error) {
          console.warn("cancel reminder", error);
        }
      }
      setPendingList((prev) => prev.filter((entry) => entry.id !== pendingItem.id));
      const template = findTemplateById(pendingItem.templateId);
      const title =
        pendingItem.title || template?.title?.[language] || template?.title?.en || "Goal";
      const priceUSD = pendingItem.priceUSD || template?.basePriceUSD || 0;
      const decisionTimestamp = Date.now();
      const daysWaited = Math.max(
        0,
        Math.round((decisionTimestamp - (pendingItem.createdAt || decisionTimestamp)) / DAY_MS)
      );
      const actionTemplateId = template?.id || pendingItem.templateId || pendingItem.id;
      const actionItem = {
        ...(template || {}),
        id: actionTemplateId,
        templateId: actionTemplateId,
        title: template?.title || pendingItem.title || "Goal",
        emoji: pendingItem.emoji || template?.emoji || DEFAULT_TEMPTATION_EMOJI,
        priceUSD,
        basePriceUSD: template?.basePriceUSD || priceUSD,
        categories: template?.categories || pendingItem.categories || [],
      };
      if (decision === "want") {
        const targetUSD = pendingItem.priceUSD || template?.basePriceUSD || 0;
        const newWish = {
          id: `wish-${pendingItem.templateId}-${Date.now()}`,
          templateId: pendingItem.templateId,
          title,
          targetUSD,
          savedUSD: 0,
          status: "active",
          createdAt: Date.now(),
          autoManaged: false,
          emoji: template?.emoji || DEFAULT_GOAL_EMOJI,
        };
        setWishes((prev) => insertWishAfterPrimary(prev, newWish));
        ensureActiveGoalForNewWish(newWish);
        setDecisionStats((prev) => ({
          ...prev,
          resolvedToWishes: prev.resolvedToWishes + 1,
        }));
        logEvent(
          "pending_decide_want",
          buildTemptationPayload(
            { ...pendingItem, priceUSD },
            {
              days_waited: daysWaited,
            }
          )
        );
        logHistoryEvent("pending_to_wish", { title, targetUSD, wishId: newWish.id, pendingId: pendingItem.id });
        triggerOverlayState("purchase", t("wishAdded", { title }));
        triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
        return;
      }
      if (decision === "spend") {
        await handleTemptationAction("spend", actionItem, {
          skipPrompt: true,
          shouldAssign: false,
        });
        return;
      }
      if (decision === "decline") {
        const price = priceUSD;
        setDecisionStats((prev) => ({
          ...prev,
          resolvedToDeclines: prev.resolvedToDeclines + 1,
        }));
        logEvent(
          "pending_decide_decline",
          buildTemptationPayload(
            { ...pendingItem, priceUSD: price },
            {
              days_waited: daysWaited,
            }
          )
        );
        logHistoryEvent("pending_to_decline", { title, amountUSD: price });
        await handleTemptationAction("save", actionItem, {
          skipPrompt: true,
          shouldAssign: false,
        });
        return;
      }
    },
    [buildTemptationPayload, findTemplateById, handleTemptationAction, language, logHistoryEvent, profile.currency, t]
  );
  useEffect(() => {
    notificationActionHandlerRef.current = async ({ actionIdentifier, notification }) => {
      const action =
        actionIdentifier === NOTIFICATION_ACTION_SAVE
          ? "save"
          : actionIdentifier === NOTIFICATION_ACTION_SPEND
          ? "spend"
          : null;
      if (!action) return;
      const data = notification?.request?.content?.data || {};
      const kind = typeof data.kind === "string" ? data.kind : null;
      const pendingId = typeof data.pendingId === "string" ? data.pendingId : null;
      if (kind === "pending_decision" && pendingId) {
        const pendingItem = (pendingListRef.current || []).find((entry) => entry?.id === pendingId);
        if (pendingItem) {
          await handlePendingDecision(pendingItem, action === "spend" ? "spend" : "decline");
          return;
        }
      }
      const templateId =
        data?.templateId || data?.template_id || data?.templateID || data?.template || null;
      const template = templateId ? findTemplateById(templateId) : null;
      const fallbackTitle =
        typeof data?.title === "string" && data.title.trim() ? data.title.trim() : t("defaultDealTitle");
      const fallbackEmoji = typeof data?.emoji === "string" && data.emoji.trim() ? data.emoji : "âœ¨";
      const fallbackAmount = Math.max(0, Number(data?.amountUSD ?? data?.priceUSD ?? data?.amount) || 0);
      const item = template
        ? { ...template, id: template.id || templateId, emoji: template.emoji || fallbackEmoji }
        : {
            id: templateId || `push_${Date.now()}`,
            title: fallbackTitle,
            emoji: fallbackEmoji,
            priceUSD: fallbackAmount,
            basePriceUSD: fallbackAmount,
            categories: [],
          };
      if (action === "spend") {
        await handleTemptationAction("spend", item, {
          bypassSpendPrompt: true,
          skipPrompt: true,
        });
        return;
      }
      await handleTemptationAction("save", item, {
        skipPrompt: true,
        skipStreakRecoveryPrompt: true,
      });
    };
  }, [handlePendingDecision, handleTemptationAction, t]);
  const handlePendingDelete = useCallback(
    (pendingItem) => {
      if (!pendingItem) return;
      const template = findTemplateById(pendingItem.templateId);
      const title =
        pendingItem.title || template?.title?.[language] || template?.title?.en || "Goal";
      const performDelete = async () => {
        if (pendingItem.notificationId) {
          try {
            await Notifications.cancelScheduledNotificationAsync(pendingItem.notificationId);
          } catch (error) {
            console.warn("cancel reminder", error);
          }
        }
        setPendingList((prev) => prev.filter((entry) => entry.id !== pendingItem.id));
        logHistoryEvent("pending_removed", { title, pendingId: pendingItem.id });
        logEvent("pending_deleted", { pending_id: pendingItem.id });
      };
      Alert.alert(t("pendingTitle"), t("pendingDeleteConfirm"), [
        { text: t("priceEditCancel"), style: "cancel" },
        {
          text: t("goalSwipeDelete"),
          style: "destructive",
          onPress: () => {
            performDelete();
          },
        },
      ]);
    },
    [findTemplateById, language, logEvent, logHistoryEvent, setPendingList, t]
  );

  const handlePendingExtend = useCallback(
    async (pendingItem) => {
      if (!pendingItem) return;
      const template = findTemplateById(pendingItem.templateId);
      const title = pendingItem.title || template?.title?.[language] || template?.title?.en || "Goal";
      const nextDue = Date.now() + PENDING_EXTENSION_MS;
      if (pendingItem.notificationId) {
        Notifications.cancelScheduledNotificationAsync(pendingItem.notificationId).catch(() => {});
      }
      const reminderId = await schedulePendingReminder(title, nextDue, {
        pendingId: pendingItem.id,
        templateId: pendingItem.templateId,
        title,
        emoji: pendingItem.emoji || template?.emoji || DEFAULT_TEMPTATION_EMOJI,
        amountUSD: pendingItem.priceUSD || template?.basePriceUSD || 0,
      });
      setPendingList((prev) =>
        prev.map((entry) =>
          entry.id === pendingItem.id
            ? {
                ...entry,
                decisionDue: nextDue,
                notificationId: reminderId || null,
              }
            : entry
        )
      );
    },
    [findTemplateById, language, schedulePendingReminder, setPendingList]
  );

  useEffect(
    () => () => {
      if (overlayRetryTimerRef.current) {
        clearTimeout(overlayRetryTimerRef.current);
        overlayRetryTimerRef.current = null;
      }
    },
    []
  );
  useEffect(() => {
    if (!pendingFocusId) return;
    if (activeTab !== "pending") return;
    if (!pendingHydrated) return;
    const hasItem = (pendingList || []).some((entry) => entry?.id === pendingFocusId);
    if (!hasItem) {
      setPendingFocusId(null);
      return;
    }
    const tryScroll = () => {
      const y = pendingCardLayoutsRef.current.get(pendingFocusId);
      if (typeof y !== "number") return false;
      pendingScrollRef.current?.scrollTo({ y: Math.max(0, y - 24), animated: true });
      return true;
    };
    if (tryScroll()) {
      setPendingFocusId(null);
      return;
    }
    const timer = setTimeout(() => {
      if (tryScroll()) {
        setPendingFocusId(null);
      }
    }, 300);
    return () => clearTimeout(timer);
  }, [activeTab, pendingFocusId, pendingHydrated, pendingList]);
  useEffect(
    () => () => {
      if (celebrationGapTimerRef.current) {
        clearTimeout(celebrationGapTimerRef.current);
        celebrationGapTimerRef.current = null;
      }
    },
    []
  );

  const processOverlayQueue = useCallback(() => {
    if (overlayActiveRef.current) return;
    const next = overlayQueueRef.current[0];
    if (!next) return;
    if ((!overlayEnvironmentReady || blockingModalVisible) && !next.force) return;
    overlayQueueRef.current.shift();
    overlayActiveRef.current = true;
    if (overlayTimer.current) {
      clearTimeout(overlayTimer.current);
    }
    if (next.type === "purchase") {
      setConfettiKey((prev) => prev + 1);
    }
    setOverlay({ type: next.type, message: next.message, clearQueueOnDismiss: !!next.clearQueueOnDismiss });
    const defaultDuration =
      next.type === "cart"
        ? 1800
        : next.type === "level"
        ? 3200
        : next.type === "reward"
        ? 3200
        : next.type === "daily_reward"
        ? 3200
        : next.type === "save"
        ? null
        : next.type === "impulse_alert"
        ? null
        : next.type === "focus_digest"
        ? null
        : next.type === "primary_temptation"
        ? null
        : 2600;
    const timeout = next.duration ?? defaultDuration;
    if (typeof timeout === "number" && Number.isFinite(timeout) && timeout > 0) {
      overlayTimer.current = setTimeout(() => {
        lastOverlayDismissedAtRef.current = Date.now();
        setOverlay(null);
        overlayActiveRef.current = false;
        processOverlayQueue();
      }, timeout);
    } else {
      overlayTimer.current = null;
    }
  }, [blockingModalVisible, overlayEnvironmentReady]);

  const scheduleOverlayRetry = useCallback(() => {
    if (overlayRetryTimerRef.current) return;
    if (!overlayQueueRef.current.length) return;
    overlayRetryTimerRef.current = setTimeout(() => {
      overlayRetryTimerRef.current = null;
      if ((!overlayEnvironmentReady || blockingModalVisible) && overlayQueueRef.current.length) {
        scheduleOverlayRetry();
        return;
      }
      processOverlayQueue();
    }, 250);
  }, [blockingModalVisible, overlayEnvironmentReady, processOverlayQueue]);

  const triggerOverlayState = useCallback(
    (type, message, config) => {
      let duration = null;
      let clearQueueOnDismiss = false;
      let force = false;
      if (typeof config === "number") {
        duration = config;
      } else if (config && typeof config === "object") {
        duration = typeof config.duration === "number" ? config.duration : null;
        clearQueueOnDismiss = !!config.clearQueueOnDismiss;
        force = !!config.force;
      }
      overlayQueueRef.current.push({ type, message, duration, clearQueueOnDismiss, force });
      processOverlayQueue();
      if (!overlayEnvironmentReady || blockingModalVisible) {
        scheduleOverlayRetry();
      }
    },
    [blockingModalVisible, overlayEnvironmentReady, processOverlayQueue, scheduleOverlayRetry]
  );

  const scheduleCelebrationOverlay = useCallback(() => {
    if (celebrationGapTimerRef.current) return;
    if (!celebrationQueueRef.current.length) return;
    const now = Date.now();
    const lastAt = lastCelebrationAtRef.current || 0;
    const gapRemaining = Math.max(CELEBRATION_OVERLAY_GAP_MS - (now - lastAt), 0);
    celebrationGapTimerRef.current = setTimeout(() => {
      celebrationGapTimerRef.current = null;
      const next = celebrationQueueRef.current.shift();
      if (!next) return;
      lastCelebrationAtRef.current = Date.now();
      triggerOverlayState(next.type, next.message, next.config);
      if (celebrationQueueRef.current.length) {
        scheduleCelebrationOverlay();
      }
    }, gapRemaining);
  }, [triggerOverlayState]);

  const queueCelebrationOverlay = useCallback(
    (type, message, config) => {
      const now = Date.now();
      const lastAt = lastCelebrationAtRef.current || 0;
      if (now - lastAt >= CELEBRATION_OVERLAY_GAP_MS && !celebrationQueueRef.current.length) {
        lastCelebrationAtRef.current = now;
        triggerOverlayState(type, message, config);
        return;
      }
      celebrationQueueRef.current.push({ type, message, config });
      scheduleCelebrationOverlay();
    },
    [scheduleCelebrationOverlay, triggerOverlayState]
  );
  queueCelebrationOverlayRef.current = queueCelebrationOverlay;

  useEffect(() => {
    if (overlayEnvironmentReady && !blockingModalVisible) {
      processOverlayQueue();
    } else if (blockingModalVisible && overlayQueueRef.current.length) {
      scheduleOverlayRetry();
    }
  }, [blockingModalVisible, overlayEnvironmentReady, processOverlayQueue, scheduleOverlayRetry]);

  useEffect(() => {
    if (overlay?.type === "level") {
      pendingLevelCelebrationRef.current = null;
    }
  }, [overlay]);

  const dismissOverlay = useCallback((maybeOptions = {}) => {
    const options =
      maybeOptions && typeof maybeOptions === "object" && "nativeEvent" in maybeOptions ? {} : maybeOptions;
    const shouldPromptGoalRenewal =
      overlay?.type === "goal_complete" && goalRenewalPromptAfterGoalRef.current;
    if (overlay?.type === "focus_digest" && overlay?.message?.prompt) {
      focusPromptActiveRef.current = false;
    }
    if (overlayTimer.current) {
      clearTimeout(overlayTimer.current);
      overlayTimer.current = null;
    }
    if (overlayActiveRef.current) {
      overlayActiveRef.current = false;
    }
    const dismissedAt = Date.now();
    lastOverlayDismissedAtRef.current = dismissedAt;
    if (overlay?.type === "save") {
      lastSaveOverlayDismissedAtRef.current = dismissedAt;
    }
    const hasQueuedCelebrationFollowUp =
      overlay?.type === "save" &&
      overlayQueueRef.current.some((entry) => ["level", "health", "cart"].includes(entry?.type));
    const requestedClearQueue =
      typeof options.clearQueue === "boolean" ? options.clearQueue : null;
    const shouldClearQueue = hasQueuedCelebrationFollowUp
      ? false
      : requestedClearQueue !== null
      ? requestedClearQueue
      : !!overlay?.clearQueueOnDismiss;
    if (shouldClearQueue) {
      overlayQueueRef.current = [];
    }
    setOverlay(null);
    processOverlayQueue();
    if (shouldPromptGoalRenewal) {
      goalRenewalPromptAfterGoalRef.current = false;
      goalRenewalPromptPendingRef.current = false;
      if (!goalRenewalPromptVisible) {
        setGoalRenewalPromptVisible(true);
      }
    }
  }, [goalRenewalPromptVisible, overlay, processOverlayQueue]);

  const resetFocusLossCounter = useCallback((templateId) => {
    if (!templateId) return;
    focusLossCountersRef.current[templateId] = { count: 0 };
  }, []);

  const promptFocusForTemptation = useCallback(
    (template) => {
      if (!focusTargetsUnlocked) return;
      if (!template?.id) return;
      if (focusPromptActiveRef.current) return;
      if (overlay?.type === "focus_digest") return;
      focusPromptActiveRef.current = true;
      const title = resolveTemptationTitle(template, language, titleOverrides[template.id]) || t("defaultDealTitle");
      triggerOverlayState("focus_digest", {
        title: t("focusPromptTitle"),
        body: t("focusPromptBody", { title }),
        strong: null,
        weak: { title, templateId: template.id },
        positive: false,
        targetId: template.id,
        prompt: true,
      }, null);
    },
    [focusTargetsUnlocked, language, overlay, t, titleOverrides, triggerOverlayState]
  );

  const registerFocusLoss = useCallback(
    (template) => {
      if (!focusTargetsUnlocked) return;
      if (!template?.id) return;
      const key = template.id;
      const entry = focusLossCountersRef.current[key] || { count: 0 };
      const nextCount = entry.count + 1;
      focusLossCountersRef.current[key] = { count: nextCount };
      if (nextCount >= FOCUS_LOSS_THRESHOLD) {
        focusLossCountersRef.current[key] = { count: 0 };
        if (focusTemplateId === key) return;
        promptFocusForTemptation(template);
      }
    },
    [focusTargetsUnlocked, focusTemplateId, promptFocusForTemptation]
  );

  const celebrateFocusVictory = useCallback(
    (template) => {
      if (!focusTargetsUnlocked) return;
      if (!template) return;
      const title = resolveTemptationTitle(template, language, titleOverrides[template.id]) || t("defaultDealTitle");
      setFocusTemplateId(null);
      setFocusSaveCount(0);
      resetFocusLossCounter(template.id);
    setHealthPoints((prev) => prev + FOCUS_VICTORY_REWARD);
    if (queueCelebrationOverlayRef.current) {
      queueCelebrationOverlayRef.current("focus_reward", {
        title: t("focusRewardTitle"),
        body: t("focusRewardSubtitle", { title, amount: FOCUS_VICTORY_REWARD }),
        amount: FOCUS_VICTORY_REWARD,
      });
    }
    },
    [focusTargetsUnlocked, language, resetFocusLossCounter, setHealthPoints, t, titleOverrides]
  );

  const handleFocusSaveProgress = useCallback(
    (template) => {
      if (!focusTargetsUnlocked) return;
      if (!template?.id || template.id !== focusTemplateId) return;
      resetFocusLossCounter(template.id);
      setFocusSaveCount((prev) => {
        const next = prev + 1;
        if (next >= FOCUS_VICTORY_THRESHOLD) {
          celebrateFocusVictory(template);
          return 0;
        }
        return next;
      });
    },
    [celebrateFocusVictory, focusTargetsUnlocked, focusTemplateId, resetFocusLossCounter]
  );

  const handleFocusSpend = useCallback(
    (template) => {
      if (!focusTargetsUnlocked) return;
      if (!template?.id || template.id !== focusTemplateId) return;
      setFocusSaveCount(0);
    },
    [focusTargetsUnlocked, focusTemplateId]
  );

  const applyFocusTarget = useCallback(
    (templateId, source = "manual") => {
      if (!focusTargetsUnlocked) return;
      if (!templateId) return;
      setFocusTemplateId(templateId);
      setFocusSaveCount(0);
      resetFocusLossCounter(templateId);
      logEvent("focus_target_set", { template_id: templateId, source });
      logEvent("focus_accepted", { template_id: templateId, source });
      triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
      playSound("focus_accept");
      queueHomeSpeech("focus_set");
    },
    [focusTargetsUnlocked, logEvent, playSound, queueHomeSpeech, resetFocusLossCounter]
  );

  const requestFocusCancel = useCallback(
    (template) => {
      if (!template?.id) return;
      if (template.id !== focusTemplateId) return;
      Alert.alert(t("focusCancelConfirmTitle"), "", [
        { text: t("quickCustomCancel"), style: "cancel" },
        {
          text: t("focusCancelConfirmAction"),
          style: "destructive",
          onPress: () => {
            setFocusTemplateId(null);
            setFocusSaveCount(0);
            resetFocusLossCounter(template.id);
          },
        },
      ]);
    },
    [focusTemplateId, resetFocusLossCounter, setFocusTemplateId, setFocusSaveCount, t]
  );

  const resolveFocusDigest = useCallback(
    (action = "later") => {
      if (!focusModeUnlocked) return;
      if (!pendingFocusDigest) return;
      const targetDateKey = pendingFocusDigest.dateKey;
      setFocusDigestSeenKey(targetDateKey);
      setPendingFocusDigest(null);
      setFocusDigestPromptShown(false);
      clearQueuedModal(QUEUED_MODAL_TYPES.FOCUS_DIGEST);
      AsyncStorage.removeItem(STORAGE_KEYS.FOCUS_DIGEST_PENDING).catch(() => {});
      if (action === "later") {
        logEvent("focus_digest_later", { date_key: targetDateKey });
      } else if (action === "focus") {
        logEvent("focus_digest_focus", { date_key: targetDateKey });
      }
    },
    [clearQueuedModal, focusModeUnlocked, pendingFocusDigest, logEvent]
  );

  const handleFocusOverlayConfirm = useCallback(
    (templateId, source = "digest") => {
      const isPrompt = overlay?.message?.prompt;
      if (templateId) {
        applyFocusTarget(templateId, source);
      }
      resolveFocusDigest("focus");
      dismissOverlay();
      if (isPrompt) {
        focusPromptActiveRef.current = false;
      }
    },
    [applyFocusTarget, dismissOverlay, overlay, resolveFocusDigest]
  );

  const handleFocusOverlayLater = useCallback(() => {
    const isPrompt = overlay?.message?.prompt;
    resolveFocusDigest("later");
    dismissOverlay();
    if (isPrompt) {
      focusPromptActiveRef.current = false;
    }
  }, [dismissOverlay, overlay, resolveFocusDigest]);

  const notifyImpulseRisk = useCallback(
    async (risk) => {
      if (!impulseFeaturesUnlocked) return;
      if (!risk?.templateId) return;
      const now = Date.now();
      const lastShown = impulseAlertCooldownRef.current?.[risk.templateId] || 0;
      if (now - lastShown < IMPULSE_ALERT_COOLDOWN_MS) return;
      const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
      const amountLabel = formatCurrency(
        convertToCurrency(Math.max(risk.amountUSD || 0, 0), currencyCode),
        currencyCode
      );
      const baseOverlayMessage = t("impulseAlertMessage", {
        temptation: risk.title,
        window: risk.windowLabel || "",
        amount: amountLabel,
      });
      const overlayMessage = moodPreset?.impulseOverlay
        ? `${baseOverlayMessage}\n${moodPreset.impulseOverlay}`
        : baseOverlayMessage;
      const pushTitle =
        moodPreset?.pushImpulseTitle && moodPreset.pushImpulseTitle.trim()
          ? renderTemplateString(moodPreset.pushImpulseTitle, { temptation: risk.title })
          : t("impulseNotificationTitle", { temptation: risk.title });
      const pushBody =
        moodPreset?.pushImpulseBody && moodPreset.pushImpulseBody.trim()
          ? renderTemplateString(moodPreset.pushImpulseBody, {
              temptation: risk.title,
              amount: amountLabel,
            })
          : t("impulseNotificationBody", { temptation: risk.title, amount: amountLabel });
      triggerOverlayState("impulse_alert", {
        title: t("impulseAlertTitle"),
        body: overlayMessage,
        moodLine: moodPreset?.impulseOverlay || null,
        window: risk.windowLabel || null,
        amountLabel,
        temptation: risk.title || "",
      });
      await sendImmediateNotification({
        title: pushTitle,
        body: pushBody,
      });
      impulseAlertCooldownRef.current = {
        ...(impulseAlertCooldownRef.current || {}),
        [risk.templateId]: now,
      };
      setImpulseTracker((prev) => ({
        ...(prev || INITIAL_IMPULSE_TRACKER),
        lastAlerts: {
          ...(prev?.lastAlerts || {}),
          [risk.templateId]: now,
        },
        events: prev?.events || [],
      }));
    },
    [impulseFeaturesUnlocked, profile.currency, sendImmediateNotification, t, triggerOverlayState, moodPreset]
  );

  const triggerCelebration = () => {
    const messages = getCelebrationMessages(language, activeGender);
    if (!messages.length) return;
    triggerOverlayState("purchase", messages[Math.floor(Math.random() * messages.length)]);
  };

  const handleLevelCelebrate = useCallback(
    (level, levelsEarned = 1) => {
      ensureOverlayEnvironmentReady();
      const rewardCoins = sumLevelRewardCoins(level, levelsEarned);
      const startLevel = Math.max(2, level - levelsEarned + 1);
      const unlockPayloads = FEATURE_UNLOCK_STEPS.filter(
        ({ level: unlockLevel }) => unlockLevel >= startLevel && unlockLevel <= level
      )
        .map(({ messageKey }) => {
          const body = t(messageKey);
          const variantKey = FEATURE_UNLOCK_VARIANT_MAP[messageKey];
          if (variantKey && FEATURE_UNLOCK_VARIANT_CONFIG[variantKey]) {
            return {
              featureUnlock: true,
              messageKey,
              variant: variantKey,
              body,
            };
          }
          return body;
        })
        .filter(Boolean);
      const queueUnlockAnnouncements = () => {
        unlockPayloads.forEach((payload) => {
          const isFeatureUnlock = payload && typeof payload === "object" && payload.featureUnlock;
          triggerOverlayState("cart", payload, isFeatureUnlock ? { duration: 0 } : { duration: 4800 });
        });
      };
      triggerOverlayState("level", level, { force: true });
      if (rewardCoins > 0) {
        const rewardAmount = rewardCoins * HEALTH_COIN_TIERS[1].value;
        setHealthPoints((prev) => prev + rewardAmount);
        triggerOverlayState(
          "health",
          {
            amount: rewardAmount,
            displayCoins: rewardCoins,
            coinValue: rewardAmount,
            reason: t("healthCelebrateLevel"),
          },
          3200
        );
      }
      queueUnlockAnnouncements();
      triggerSuccessHaptic();
    },
    [ensureOverlayEnvironmentReady, playSound, t, triggerOverlayState]
  );
  const runPendingLevelCelebration = useCallback(() => {
    const pending = pendingLevelCelebrationRef.current;
    if (!pending) return;
    if (!overlayEnvironmentReady) return;
    if (blockingModalVisible) return;
    levelCelebrationQueuedRef.current = Math.max(
      levelCelebrationQueuedRef.current || 0,
      pending.level || 0
    );
    pendingLevelCelebrationRef.current = null;
    handleLevelCelebrate(pending.level, pending.levelsEarned);
  }, [blockingModalVisible, handleLevelCelebrate, overlayEnvironmentReady]);

  useEffect(() => {
    runPendingLevelCelebration();
  }, [blockingModalVisible, overlay, overlayEnvironmentReady, runPendingLevelCelebration]);

  useEffect(() => {
    if (!lastCelebratedLevelHydrated) return;
    if (resetInProgressRef.current) {
      if (playerLevel <= 1 && savedTotalUSD === 0 && lifetimeSavedUSD === 0) {
        resetInProgressRef.current = false;
        previousPlayerLevelRef.current = Math.max(playerLevel, 1);
      }
      return;
    }
    const previousLevel = Math.max(
      previousPlayerLevelRef.current || 1,
      lastCelebratedLevel || 1
    );
    if (playerLevel <= (levelCelebrationQueuedRef.current || 0)) {
      previousPlayerLevelRef.current = Math.max(playerLevel, previousLevel);
      return;
    }
    if (playerLevel > previousLevel) {
      const levelsEarned = playerLevel - previousLevel;
      if (overlay?.type === "save") {
        dismissOverlay({ clearQueue: false });
      }
      logEvent("savings_level_up", {
        level: playerLevel,
        saved_usd_total: savedTotalUSD,
      });
      logEvent("hero_level_unlocked", {
        level: playerLevel,
        saved_usd_total: savedTotalUSD,
      });
      for (let level = previousLevel + 1; level <= playerLevel; level += 1) {
        logEvent("level_reached", { level });
      }
      queueHomeSpeech("level_up");
      pendingLevelCelebrationRef.current = { level: playerLevel, levelsEarned };
      runPendingLevelCelebration();
      persistLastCelebratedLevel(playerLevel);
    }
    previousPlayerLevelRef.current = Math.max(playerLevel, previousLevel);
  }, [
    handleLevelCelebrate,
    lastCelebratedLevel,
    lastCelebratedLevelHydrated,
    lifetimeSavedUSD,
    persistLastCelebratedLevel,
    playerLevel,
    queueHomeSpeech,
    runPendingLevelCelebration,
    savedTotalUSD,
  ]);

  useEffect(() => {
    if (!pendingGoalCelebration) return;
    if (blockingModalVisible) return;
    if (overlay || overlayActiveRef.current) return;
    if (overlayQueueRef.current.length) return;
    if (celebrationQueueRef.current.length) return;
    if (pendingLevelCelebrationRef.current) return;
    triggerOverlayState(
      "goal_complete",
      pendingGoalCelebration.payload,
      pendingGoalCelebration.config
    );
    setPendingGoalCelebration(null);
  }, [blockingModalVisible, overlay, pendingGoalCelebration, triggerOverlayState]);

  const handleRewardClaim = useCallback(
    (reward) => {
      if (!reward?.id || !reward.unlocked || reward.claimed) return;
      const rewardAmount = reward.rewardHealth || HEALTH_PER_REWARD;
      const claimedAt = Date.now();
      setClaimedRewards((prev) => ({ ...prev, [reward.id]: { claimedAt } }));
      setRewardClaimTotal((prev) => Math.max(0, prev) + 1);
      setHealthPoints((prev) => prev + rewardAmount);
      triggerOverlayState(
        "health",
        {
          amount: rewardAmount,
          reason: t("healthCelebrateReward"),
        },
        3200
      );
      playSound("reward");
      triggerSuccessHaptic();
      logEvent("reward_claimed", { reward_id: reward.id });
      logHistoryEvent("reward_claimed", { rewardId: reward.id, title: reward.title });
    },
    [t, triggerOverlayState, logHistoryEvent, playSound]
  );

  const handleChallengeAccept = useCallback(
    async (challengeId) => {
      const def = CHALLENGE_DEF_MAP[challengeId];
      if (!def) return;
      if (getActiveChallengesCount(challengesState) >= MAX_ACTIVE_CHALLENGES) {
        Alert.alert(
          t("challengeLimitReachedTitle", { limit: MAX_ACTIVE_CHALLENGES }),
          t("challengeLimitReachedMessage", { limit: MAX_ACTIVE_CHALLENGES })
        );
        return;
      }
      triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
      let activated = false;
      let startedAt = Date.now();
      let expiresAt = startedAt + def.durationDays * DAY_MS;
      let limitReached = false;
      setChallengesState((prev) => {
        const entry = prev[challengeId] || createChallengeEntry(challengeId);
        const canStart =
          entry.status === CHALLENGE_STATUS.IDLE ||
          entry.status === CHALLENGE_STATUS.EXPIRED ||
          (entry.status === CHALLENGE_STATUS.CLAIMED &&
            getChallengeCooldownRemaining(entry, Date.now()) <= 0);
        if (!canStart) {
          return prev;
        }
        const activeCount = getActiveChallengesCount(prev);
        if (activeCount >= MAX_ACTIVE_CHALLENGES) {
          limitReached = true;
          return prev;
        }
        activated = true;
        startedAt = Date.now();
        expiresAt = startedAt + def.durationDays * DAY_MS;
        return {
          ...prev,
          [challengeId]: {
            ...createChallengeEntry(challengeId),
            status: CHALLENGE_STATUS.ACTIVE,
            startedAt,
            expiresAt,
          },
        };
      });
      if (limitReached) {
        Alert.alert(
          t("challengeLimitReachedTitle", { limit: MAX_ACTIVE_CHALLENGES }),
          t("challengeLimitReachedMessage", { limit: MAX_ACTIVE_CHALLENGES })
        );
        return;
      }
      if (!activated) return;
      playSound("challenge_accept");
      const copy = getChallengeCopy(def, language);
      const title = copy.title || challengeId;
      triggerOverlayState("cart", t("challengeStartedOverlay", { title }));
      logEvent("challenge_started", { challenge_id: challengeId });
      logEvent("challenge_joined", {
        challenge_id: challengeId,
        type: CHALLENGE_TYPE_LABELS[def.metricType] || def.metricType,
      });
      const reminderIds = await scheduleChallengeReminders(challengeId, def, startedAt, expiresAt);
      if (reminderIds.length) {
        setChallengesState((prev) => {
          const entry = prev[challengeId];
          if (!entry || entry.startedAt !== startedAt) return prev;
          return {
            ...prev,
            [challengeId]: {
              ...entry,
              reminderNotificationIds: reminderIds,
            },
          };
        });
      }
    },
    [challengesState, language, playSound, scheduleChallengeReminders, t, triggerOverlayState]
  );

  const handleChallengeClaim = useCallback(
    (challengeId) => {
      const def = CHALLENGE_DEF_MAP[challengeId];
      if (!def) return;
      const currentEntry = challengesState[challengeId];
      if (!currentEntry || currentEntry.status !== CHALLENGE_STATUS.COMPLETED) return;
      (currentEntry.reminderNotificationIds || []).forEach((id) => {
        Notifications.cancelScheduledNotificationAsync(id).catch(() => {});
      });
      triggerSuccessHaptic();
      setChallengesState((prev) => {
        const entry = prev[challengeId];
        if (!entry || entry.status !== CHALLENGE_STATUS.COMPLETED) return prev;
        return {
          ...prev,
          [challengeId]: {
            ...entry,
            status: CHALLENGE_STATUS.CLAIMED,
            claimedAt: Date.now(),
            reminderNotificationIds: [],
          },
        };
      });
      const rewardAmount = getScaledChallengeReward(def.rewardHealth);
      const rewardLabel = formatHealthRewardText(rewardAmount);
      setHealthPoints((prev) => prev + rewardAmount);
      const copy = getChallengeCopy(def, language);
      const title = copy.title || challengeId;
      triggerOverlayState(
        "health",
        {
          amount: rewardAmount,
          reason: t("challengeClaimedOverlay", { title, amount: rewardLabel }),
        },
        3200
      );
      playSound("reward");
      logEvent("challenge_claimed", { challenge_id: challengeId });
    },
    [challengesState, formatHealthRewardText, language, t, triggerOverlayState, playSound]
  );

  const handleChallengeCancel = useCallback(
    (challengeId) => {
      setChallengesState((prev) => {
        const entry = prev[challengeId];
        if (!entry || entry.status !== CHALLENGE_STATUS.ACTIVE) return prev;
        (entry.reminderNotificationIds || []).forEach((id) => {
          Notifications.cancelScheduledNotificationAsync(id).catch(() => {});
        });
        logEvent("challenge_cancelled", { challenge_id: challengeId });
        return {
          ...prev,
          [challengeId]: createChallengeEntry(challengeId),
        };
      });
    },
    [logEvent]
  );

  const handleFreeDayRescue = useCallback(() => {
    if (!freeDayUnlocked) return;
    const now = new Date();
    if (!freeDayStats.lastDate || healthPoints < FREE_DAY_RESCUE_COST) return;
    const yesterdayKey = getDayKey(new Date(now.getTime() - DAY_MS));
    const dayBeforeYesterdayKey = getDayKey(new Date(now.getTime() - DAY_MS * 2));
    if (freeDayStats.lastDate !== dayBeforeYesterdayKey) return;
    setHealthPoints((prev) => Math.max(prev - FREE_DAY_RESCUE_COST, 0));
    setFreeDayStats((prev) => ({ ...prev, lastDate: yesterdayKey }));
    triggerOverlayState("reward", t("freeDayRescueOverlay"));
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    logEvent("free_day_rescue", {
      current_streak: freeDayStats.current,
      health_remaining: Math.max(healthPoints - FREE_DAY_RESCUE_COST, 0),
    });
  }, [freeDayUnlocked, freeDayStats.lastDate, freeDayStats.current, healthPoints, triggerOverlayState, t]);

  const handleResetData = () => {
    Alert.alert(
      t("developerReset"),
      t("developerResetConfirm"),
      [
        { text: t("developerResetCancel"), style: "cancel" },
        {
          text: t("developerResetApply"),
          style: "destructive",
          onPress: async () => {
            resetCounterRef.current += 1;
            resetInProgressRef.current = true;
            triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
            try {
              await AsyncStorage.multiRemove(Object.values(STORAGE_KEYS));
              await AsyncStorage.clear();
            } catch (error) {
              console.warn("reset", error);
            }
            AsyncStorage.setItem(STORAGE_KEYS.TEMPTATION_TUTORIAL, "pending").catch(() => {});
            Notifications.cancelAllScheduledNotificationsAsync?.().catch(() => {});
            try {
              await Promise.all(
                pendingList
                  .filter((entry) => entry.notificationId)
                  .map((entry) =>
                    Notifications.cancelScheduledNotificationAsync(entry.notificationId).catch(() => {})
                  )
              );
            } catch {}
            try {
              const challengeReminderIds = Object.values(challengesState || {}).flatMap(
                (entry) => entry?.reminderNotificationIds || []
              );
              await Promise.all(
                challengeReminderIds.map((id) =>
                  Notifications.cancelScheduledNotificationAsync(id).catch(() => {})
                )
              );
            } catch {}
            try {
              const hungerIds = Array.isArray(tamagotchiHungerNotificationIdsRef.current)
                ? tamagotchiHungerNotificationIdsRef.current
                : [];
              if (hungerIds.length) {
                await Promise.all(
                  hungerIds.map((id) =>
                    Notifications.cancelScheduledNotificationAsync(id).catch(() => {})
                  )
                );
              }
              tamagotchiHungerNotificationIdsRef.current = [];
            } catch {}
            setWishes([]);
            setPendingList([]);
            setPurchases([]);
            setSavedTotalUSD(0);
            setLifetimeSavedUSD(0);
            setDeclineCount(0);
            setCatalogOverrides({});
            setTitleOverrides({});
            setEmojiOverrides({});
            setQuickTemptations([]);
            setFreeDayStats({ ...INITIAL_FREE_DAY_STATS });
            setDecisionStats({ ...INITIAL_DECISION_STATS });
            setHistoryEvents([]);
            setRefuseStats({});
            setTemptationInteractions({});
            setSmartReminders([]);
            setSmartRemindersHydrated(true);
            setPotentialPushProgress({ ...DEFAULT_POTENTIAL_PUSH_STATE });
            setPotentialPushHydrated(true);
            const resetProfile = {
              ...DEFAULT_PROFILE,
              joinedAt: new Date().toISOString(),
              goal: null,
              goalTargetUSD: 0,
              primaryGoals: [],
              goalCelebrated: false,
              goalRenewalPending: false,
            };
            setProfile(resetProfile);
            setProfileDraft(resetProfile);
            setActiveGoalId(null);
            setRegistrationData(INITIAL_REGISTRATION);
            setDailyRewardState({ ...DEFAULT_DAILY_REWARD_STATE });
            setDailyRewardHydrated(true);
            setDailyChallenge(createInitialDailyChallengeState());
            setDailyChallengeHydrated(true);
            setDailySummaryData(null);
            setDailySummaryVisible(false);
            setPendingDailySummaryData(null);
            setDailySummarySeenKey(null);
            setDailyNudgeNotificationIds({});
            dailyNudgeIdsRef.current = {};
            setDailyNudgesHydrated(true);
            pushOptInLoggedRef.current = false;
            pushDayThreePromptShownRef.current = false;
            lastSpendLoggingReminderRef.current = 0;
            goalSelectionTouchedRef.current = false;
            goToOnboardingStep("logo", { recordHistory: false, resetHistory: true });
            setActiveCategory("all");
            setActiveTabState("feed");
            updateTabHistory([]);
            goToTab("feed", { recordHistory: false, resetHistory: true });
            setOverlay(null);
            setTheme(DEFAULT_THEME);
            setLanguage(DEFAULT_LANGUAGE);
            setSoundEnabled(true);
            setSoundEnabledHydrated(true);
            setActiveCurrency(DEFAULT_PROFILE.currency);
            setHealthPoints(0);
            const resetTamagotchiState = {
              ...TAMAGOTCHI_START_STATE,
              coins: 0,
              lastFedAt: null,
              lastDecayAt: Date.now(),
              coinTick: 0,
            };
            setTamagotchiState(resetTamagotchiState);
            tamagotchiHungerPrevRef.current = TAMAGOTCHI_START_STATE.hunger;
            tamagotchiHydratedRef.current = true;
            setTamagotchiSkinId(DEFAULT_TAMAGOTCHI_SKIN);
            setSkinPickerVisible(false);
            setClaimedRewards({});
            setRewardClaimTotal(0);
            setRewardCelebratedMap({});
            const resetChallenges = createInitialChallengesState();
            challengesPrevRef.current = resetChallenges;
            setChallengesState(resetChallenges);
            setImpulseTracker({ ...INITIAL_IMPULSE_TRACKER });
            setMoodState(createMoodStateForToday());
            impulseAlertCooldownRef.current = {};
            setTutorialSeen(false);
            setTutorialVisible(false);
            setTutorialStepIndex(0);
            setTemptationTutorialSeen(false);
            setTemptationTutorialStatus("pending");
            setTemptationTutorialVisible(false);
            setTemptationTutorialStepIndex(0);
            setTemptationTutorialQueued(false);
            setTemptationTutorialCompleted(false);
            setLastCelebratedLevel(1);
            setLastCelebratedLevelHydrated(true);
            setCoinValueModalVisible(false);
            setCoinValueModalStatus("none");
            coinValueModalStatusRef.current = "none";
            coinBalancePrevRef.current = 0;
            setCoinSliderMaxUSD(DEFAULT_COIN_SLIDER_MAX_USD);
            previousPlayerLevelRef.current = 1;
            levelCelebrationQueuedRef.current = 0;
            pendingLevelCelebrationRef.current = null;
            overlayQueueRef.current = [];
            overlayActiveRef.current = false;
            if (overlayRetryTimerRef.current) {
              clearTimeout(overlayRetryTimerRef.current);
              overlayRetryTimerRef.current = null;
            }
            if (overlayTimer.current) {
              clearTimeout(overlayTimer.current);
              overlayTimer.current = null;
            }
            if (customReminderId) {
              Notifications.cancelScheduledNotificationAsync(customReminderId).catch(() => {});
            }
            persistCustomReminderId(null);
            try {
              await AsyncStorage.multiSet([
                [STORAGE_KEYS.HEALTH, "0"],
                [STORAGE_KEYS.TAMAGOTCHI, JSON.stringify(resetTamagotchiState)],
                [STORAGE_KEYS.COIN_SLIDER_MAX, String(DEFAULT_COIN_SLIDER_MAX_USD)],
              ]);
            } catch (error) {
              console.warn("reset storage", error);
            }
          },
        },
      ]
    );
  };

  const startProfileEdit = () => {
    triggerHaptic();
    setProfileDraft(profile);
    setIsEditingProfile(true);
  };

  const cancelProfileEdit = () => {
    triggerHaptic();
    setProfileDraft(profile);
    setIsEditingProfile(false);
  };

  const saveProfileEdit = () => {
    triggerHaptic();
    const normalizedGoals = Array.isArray(profileDraft.primaryGoals) && profileDraft.primaryGoals.length
      ? profileDraft.primaryGoals
          .map((entry) => {
            const goalId = entry?.id || profileDraft.goal || profile.goal || null;
            if (!goalId) return null;
            const targetUSD =
              Number.isFinite(entry?.targetUSD) && entry.targetUSD > 0
                ? entry.targetUSD
                : getGoalDefaultTargetUSD(goalId);
            const normalized = {
              id: goalId,
              targetUSD,
            };
            if (Number.isFinite(entry?.savedUSD)) {
              normalized.savedUSD = entry.savedUSD;
            }
            if (entry?.status) {
              normalized.status = entry.status;
            }
            if (entry?.createdAt) {
              normalized.createdAt = entry.createdAt;
            }
            if (entry?.customTitle) {
              normalized.customTitle = entry.customTitle;
            }
            if (entry?.customEmoji) {
              normalized.customEmoji = entry.customEmoji;
            }
            return normalized;
          })
          .filter(Boolean)
      : [];
    const fallbackGoalId = profileDraft.goal || profile.goal || null;
    const primaryGoalEntries =
      normalizedGoals.length > 0
        ? normalizedGoals
        : fallbackGoalId
        ? [
            {
              id: fallbackGoalId,
              targetUSD: getGoalDefaultTargetUSD(fallbackGoalId),
              savedUSD: 0,
              status: "active",
              createdAt: Date.now(),
            },
          ]
        : [];
    const activeEntry = primaryGoalEntries[0];
    const activeTarget =
      Number.isFinite(activeEntry?.targetUSD) && activeEntry.targetUSD > 0
        ? activeEntry.targetUSD
        : activeEntry?.id
        ? getGoalDefaultTargetUSD(activeEntry.id)
        : 0;
    const activeSaved = Number.isFinite(activeEntry?.savedUSD) ? Math.max(activeEntry.savedUSD, 0) : 0;
    const hasMetTarget = activeTarget > 0 && activeSaved >= activeTarget;
    const prevCustomId = profile.customSpend?.id || "custom_habit";
    const prevCustomTitle = (profile.customSpend?.title || "").trim();
    const nextCustomId = profileDraft.customSpend?.id || prevCustomId;
    const nextCustomTitle = (profileDraft.customSpend?.title || "").trim();
    const nextProfile = {
      ...profileDraft,
      primaryGoals: primaryGoalEntries,
      goal: primaryGoalEntries[0]?.id || null,
      goalTargetUSD: activeTarget,
      goalCelebrated: hasMetTarget ? profileDraft.goalCelebrated : false,
    };
    if (nextCustomId && prevCustomTitle !== nextCustomTitle) {
      setTitleOverrides((prev) => {
        const next = { ...prev };
        if (nextCustomTitle) {
          next[nextCustomId] = nextCustomTitle;
        } else {
          delete next[nextCustomId];
        }
        return next;
      });
    }
    const prevBaselineUSD = profile.spendingProfile?.baselineMonthlyWasteUSD || 0;
    const nextBaselineUSD = nextProfile.spendingProfile?.baselineMonthlyWasteUSD || 0;
    if (prevBaselineUSD !== nextBaselineUSD) {
      logEvent("profile_baseline_updated", {
        previous_usd: prevBaselineUSD,
        baseline_usd: nextBaselineUSD,
        currency: nextProfile.currency || DEFAULT_PROFILE.currency,
      });
    }
    const prevCustomSpend = profile.customSpend || null;
    const nextCustomSpend = nextProfile.customSpend || null;
    const prevCustomAmountUSD = resolveCustomPriceUSD(
      prevCustomSpend,
      profile.currency || DEFAULT_PROFILE.currency
    );
    const nextCustomAmountUSD = resolveCustomPriceUSD(
      nextCustomSpend,
      nextProfile.currency || DEFAULT_PROFILE.currency
    );
    const prevCustomFrequency = prevCustomSpend?.frequencyPerWeek || 0;
    const nextCustomFrequency = nextCustomSpend?.frequencyPerWeek || 0;
    const customSpendChanged =
      prevCustomTitle !== nextCustomTitle ||
      prevCustomAmountUSD !== nextCustomAmountUSD ||
      prevCustomFrequency !== nextCustomFrequency;
    if (customSpendChanged) {
      logEvent("profile_custom_spend_updated", {
        title: nextCustomTitle || null,
        amount_usd: nextCustomAmountUSD || 0,
        frequency_per_week: nextCustomFrequency || 0,
        removed: nextCustomSpend ? 0 : 1,
      });
    }
    setProfile(nextProfile);
    setIsEditingProfile(false);
    Keyboard.dismiss();
  };

  const renderActiveScreen = () => {
    if (activeTab === "purchases" && !deferredHydrationReady) {
      return (
        <View style={[styles.screenLoading, { backgroundColor: colors.background }]}>
          <ActivityIndicator color={colors.text} />
        </View>
      );
    }
    switch (activeTab) {
      case "cart":
        return (
          <ProgressScreen
            wishes={wishes}
            currency={profile.currency || DEFAULT_PROFILE.currency}
            onRemoveWish={handleRemoveWish}
            t={t}
            colors={colors}
            primaryGoals={profile.primaryGoals}
            onGoalLongPress={handleGoalLongPress}
            onGoalEdit={openGoalEditorPrompt}
            activeGoalId={activeGoalId || profile.goal}
            onSetActiveGoal={handleActiveGoalSelect}
            language={language}
            catCuriousSource={tamagotchiAnimations.curious}
            healthPoints={healthPoints}
            freeDayStats={freeDayStats}
            onFreeDayLog={handleLogFreeDay}
            onFreeDayRescue={handleFreeDayRescue}
            freeDayRescueCost={FREE_DAY_RESCUE_COST}
            historyEvents={resolvedHistoryEvents}
            impulseInsights={impulseInsights}
            showImpulseMap={impulseFeaturesUnlocked}
            showFreeDayCard={freeDayUnlocked}
            challenges={challengeList}
            dailyChallenge={resolvedDailyChallenge}
            onChallengeAccept={handleChallengeAccept}
            onChallengeClaim={handleChallengeClaim}
            onChallengeCancel={handleChallengeCancel}
            onCreateGoal={() => openNewGoalModal(false, "progress_goal_add")}
            onFocusCancel={requestFocusCancel}
            focusChallengeId={progressFocusChallengeId}
            onFocusHandled={() => setProgressFocusChallengeId(null)}
            challengeBadges={challengeBadgeEmojis}
            challengeBadgeCount={challengeBadgeCount}
            playerLevel={playerLevel}
            resolveTemplateCard={resolveTemplateCard}
            resolveTemptationCategory={resolveTemptationCategory}
            customCategories={customCategories}
            onWeeklySpendPress={openSpendBreakdown}
          />
        );
      case "pending":
        return (
          <PendingScreen
            items={pendingList}
            currency={profile.currency || DEFAULT_PROFILE.currency}
            t={t}
            colors={colors}
            onResolve={handlePendingDecision}
            onDelete={handlePendingDelete}
            onExtend={handlePendingExtend}
            language={language}
            catCuriousSource={tamagotchiAnimations.curious}
            locked={!thinkingUnlocked}
            onItemLayout={registerPendingCardLayout}
            scrollRef={pendingScrollRef}
          />
        );
      case "purchases":
        return (
          <RewardsScreen
            achievements={achievements}
            challenges={challengeList}
            activePane={rewardsPane}
            onPaneChange={setRewardsPane}
            onChallengeAccept={handleChallengeAccept}
            onChallengeClaim={handleChallengeClaim}
            onChallengeCancel={handleChallengeCancel}
            t={t}
            colors={colors}
            savedTotalUSD={savedTotalUSD}
            currency={profile.currency || DEFAULT_PROFILE.currency}
            onRewardClaim={handleRewardClaim}
            healthRewardAmount={HEALTH_PER_REWARD}
            language={language}
            dailyChallenge={resolvedDailyChallenge}
            showChallenges={false}
            showDailyChallengeWidget={false}
            rewardsLocked={!rewardsUnlocked}
            challengesLocked={!challengesUnlocked}
            dailyChallengeLocked={playerLevel < 2}
          />
        );
      case "profile":
        return (
          <ProfileScreen
            profile={isEditingProfile ? profileDraft : profile}
            stats={profileStats}
            isEditing={isEditingProfile}
            onFieldChange={(field, value) => setProfileDraft((prev) => ({ ...prev, [field]: value }))}
            onEditPress={startProfileEdit}
            onCancelEdit={cancelProfileEdit}
            onSaveEdit={saveProfileEdit}
            onThemeToggle={handleThemeToggle}
            onLanguageChange={handleLanguageChange}
            onCurrencyChange={handleProfileCurrencyChange}
            onResetData={handleResetData}
            onPickImage={handlePickImage}
            theme={theme}
            language={language}
            currencyValue={profile.currency || DEFAULT_PROFILE.currency}
            soundEnabled={soundEnabled}
            onSoundToggle={handleSoundToggle}
            spendReducesSavings={spendReducesSavings}
            onSpendReductionToggle={handleSpendImpactToggle}
            history={resolvedHistoryEvents}
            onHistoryDelete={handleHistoryDelete}
            freeDayStats={freeDayStats}
            rewardBadgeCount={rewardClaimTotal}
            challengeBadges={challengeBadgeEmojis}
            challengeBadgeCount={challengeBadgeCount}
            t={t}
            colors={colors}
            moodPreset={moodPreset}
            mascotImageSource={tamagotchiAvatarSource}
            openAddCategoryModal={openAddCategoryModal}
          />
      );
      default:
        return (
          <FeedScreen
            ref={feedScreenRef}
            products={products}
            savedTotalUSD={savedTotalUSD}
            wishes={wishes}
            onTemptationAction={handleTemptationAction}
            onTemptationEditToggle={toggleTemptationEditor}
            onTemptationQuickGoalToggle={handleQuickGoalToggle}
            onNewTemptation={handleFabNewTemptation}
            t={t}
            tVariant={tVariant}
            language={language}
            colors={colors}
            currency={profile.currency || DEFAULT_PROFILE.currency}
            freeDayStats={freeDayStats}
            onFreeDayLog={handleLogFreeDay}
            goalAssignments={temptationGoalMap}
            analyticsStats={analyticsStats}
            refuseStats={refuseStats}
            cardFeedback={cardFeedback}
            historyEvents={resolvedHistoryEvents}
            onHistoryDelete={handleHistoryDelete}
            profile={profile}
            titleOverrides={titleOverrides}
            descriptionOverrides={descriptionOverrides}
            onBaselineSetup={handleBaselineSetupPrompt}
            healthPoints={healthPoints}
            onFreeDayRescue={handleFreeDayRescue}
            freeDayRescueCost={FREE_DAY_RESCUE_COST}
            impulseInsights={impulseInsights}
            moodPreset={moodPreset}
            onMoodDetailsOpen={openMoodDetails}
            onPotentialDetailsOpen={openPotentialDetails}
            heroGoalTargetUSD={heroGoalTargetUSD}
            heroGoalSavedUSD={heroGoalSavedUSD}
            potentialGrowthUSD={potentialGrowthUSD}
            showPotentialGrowth={potentialGrowthVisible}
            dailyRewardUnlocked={dailyRewardUnlocked}
            dailyRewardReady={dailyRewardReady}
            dailyRewardAmount={dailyRewardDisplayAmount}
            dailyRewardBaseAmount={baseDailyRewardAmount}
            dailyRewardDay={dailyRewardDay}
            onDailyRewardClaim={handleDailyRewardClaim}
            onDailyRewardModalVisibilityChange={setDailyRewardModalVisible}
            mascotOverride={mascotOverride}
            onMascotAnimationComplete={handleMascotAnimationComplete}
            hideMascot={tamagotchiVisible}
            onMascotPress={openTamagotchiOverlay}
            editingTemptationId={priceEditor.item?.id || null}
            editingTitleValue={priceEditor.title}
            editingPriceValue={priceEditor.value}
            editingGoalLabel={priceEditorAssignedGoalTitle}
            editingEmojiValue={priceEditor.emoji}
            editingDescriptionValue={priceEditor.description || ""}
            editingCategoryValue={priceEditor.category || DEFAULT_IMPULSE_CATEGORY}
            onTemptationEditTitleChange={handlePriceTitleChange}
            onTemptationEditPriceChange={handlePriceInputChange}
            onTemptationEditEmojiChange={handlePriceEmojiChange}
            onTemptationEditDescriptionChange={handlePriceDescriptionChange}
            onTemptationEditCategoryChange={handlePriceCategoryChange}
            onTemptationEditSave={savePriceEdit}
            onTemptationEditCancel={closePriceEditor}
            onTemptationEditDelete={handleTemptationDelete}
            onTemptationGoalSelect={openGoalLinkPrompt}
            onTemptationSwipeDelete={handleTemptationDelete}
            onSavingsBreakdownPress={openSavingsBreakdown}
            resolveTemplateTitle={resolveTemplateTitle}
            tamagotchiMood={tamagotchiMood}
            tamagotchiDesiredFood={tamagotchiDesiredFood}
            primaryTemptationId={primaryTemptationId}
            primaryTemptationDescription={primaryTemptationDescription}
            focusTemplateId={focusTemplateId}
            onFocusCancel={requestFocusCancel}
            tamagotchiAnimations={tamagotchiAnimations}
            lifetimeSavedUSD={lifetimeSavedUSD}
            interactionStats={temptationInteractions}
            resolveCardRefuseStats={resolveCardRefuseStats}
            tutorialTemptationStepId={tutorialTemptationStepId}
            tutorialHighlightMeasureTick={tutorialHighlightMeasureTick}
            onTutorialHighlightLayoutChange={handleTutorialHighlightLayoutChange}
            allowThinkAction={thinkingUnlocked}
            activeChallenge={activeChallenge}
            onActiveChallengePress={handleProgressChallengeOpen}
            homeSpeechTick={homeSpeechTrigger.tick}
            homeSpeechReason={homeSpeechTrigger.reason}
            speechAllowed={speechAllowed}
            lastVisitAt={moodState.lastVisitAt}
            lastVisitAtSnapshot={lastVisitAtSnapshotRef.current}
          />
        );
    }
  };

  useEffect(() => {
    const tabScreens = {
      feed: "feed",
      cart: "wishlist",
      pending: "pending",
      purchases: "rewards",
      profile: "profile",
    };
    const screenName = tabScreens[activeTab] || "feed";
    logScreenView(screenName);
  }, [activeTab]);
  useEffect(() => {
    if (!termsAccepted) return;
    const onboardingScreens = {
      logo: "onboarding_logo",
      language: "onboarding_language",
      guide: "onboarding_guide",
      register: "onboarding_register",
      persona: "onboarding_persona",
      habit: "onboarding_custom_spend",
      baseline: "onboarding_baseline",
      goal: "onboarding_goal",
      goal_target: "onboarding_goal_target",
      analytics_consent: "onboarding_analytics_consent",
      push_optin: "onboarding_push_optin",
    };
    const screen = onboardingScreens[onboardingStep];
    if (screen) {
      logScreenView(screen);
    }
  }, [onboardingStep, termsAccepted]);
  useEffect(() => {
    if (onboardingStep === "done") return;
    const screenNumber = resolveOnboardingScreenNumber(onboardingStep);
    if (!screenNumber) return;
    const stepEvent = getOnboardingStepReachedEvent(screenNumber);
    if (stepEvent) {
      logEvent(stepEvent);
    }
  }, [logEvent, onboardingStep]);

  if (onboardingStep !== "done") {
    const onboardingBackHandler = canGoBackOnboarding ? handleOnboardingBack : undefined;
    const onboardingSkipHandler = canShowOnboardingSkip ? handleOnboardingSkip : null;
    let onboardContent = null;
    if (onboardingStep === "logo") {
      onboardContent = startupLogoReady ? <LogoSplash onDone={handleOnboardingLogoComplete} /> : null;
    } else if (onboardingStep === "language") {
      onboardContent = (
        <LanguageScreen
          colors={colors}
          t={t}
          selectedLanguage={language}
          selectedCurrency={registrationData.currency || DEFAULT_PROFILE.currency}
          onLanguageChange={handleLanguageChange}
          onCurrencyChange={(code) => updateRegistrationData("currency", code)}
          onContinue={handleLanguageContinue}
          onBack={onboardingBackHandler}
          onShowTerms={handleTermsOpen}
          termsAccepted={termsAccepted}
          mascotWaveSource={tamagotchiAnimations.waving}
        />
      );
    } else if (onboardingStep === "guide") {
      onboardContent = (
        <HowItWorksScreen
          colors={colors}
          t={t}
          onContinue={handleGuideContinue}
          onBack={onboardingBackHandler}
          onSkip={onboardingSkipHandler}
        />
      );
    } else if (onboardingStep === "register") {
      onboardContent = (
        <RegistrationScreen
          data={registrationData}
          onChange={updateRegistrationData}
          onSubmit={handleRegistrationSubmit}
          onPickImage={handleRegistrationPickImage}
          colors={colors}
          t={t}
          onBack={onboardingBackHandler}
          mascotImageSource={tamagotchiAvatarSource}
          onSkip={onboardingSkipHandler}
        />
      );
    } else if (onboardingStep === "persona") {
      onboardContent = (
        <PersonaScreen
          data={registrationData}
          onChange={updateRegistrationData}
          onSubmit={handlePersonaSubmit}
          colors={colors}
          t={t}
          language={language}
          onBack={onboardingBackHandler}
          onSkip={onboardingSkipHandler}
        />
      );
    } else if (onboardingStep === "habit") {
      onboardContent = (
        <CustomHabitScreen
          data={registrationData}
          onChange={updateRegistrationData}
          onSubmit={handleHabitSubmit}
          colors={colors}
          t={t}
          currency={registrationData.currency || profile.currency || DEFAULT_PROFILE.currency}
          onBack={onboardingBackHandler}
          language={language}
          onSkip={onboardingSkipHandler}
        />
      );
    } else if (onboardingStep === "baseline") {
      onboardContent = (
        <SpendingBaselineScreen
          value={registrationData.baselineMonthlyWaste || ""}
          currency={registrationData.currency || profile.currency || DEFAULT_PROFILE.currency}
          onChange={(text) => updateRegistrationData("baselineMonthlyWaste", text)}
          onSubmit={handleBaselineSubmit}
          colors={colors}
          t={t}
          onBack={onboardingBackHandler}
          onSkip={onboardingSkipHandler}
          onSkipStep={handleBaselineSkip}
        />
      );
    } else if (onboardingStep === "goal") {
      onboardContent = (
        <GoalScreen
          selectedGoals={registrationData.goalSelections || []}
          onToggle={handleGoalToggle}
          onSubmit={handleGoalStageContinue}
          goalTargets={registrationData.goalTargetMap || {}}
          onGoalTargetChange={handleGoalTargetDraftChange}
          currency={registrationData.currency || profile.currency || DEFAULT_PROFILE.currency}
          onRegisterGoalTargetFocus={(handler) => {
            goalTargetFocusRef.current = handler;
          }}
          colors={colors}
          t={t}
          language={language}
          onBack={onboardingBackHandler}
          customGoals={registrationData.customGoals || []}
          onCustomGoalCreate={openOnboardingGoalModal}
          onSkip={onboardingSkipHandler}
          onSkipStep={handleGoalStageSkip}
        />
      );
    } else if (onboardingStep === "goal_target") {
      onboardContent = (
        <GoalTargetScreen
          selections={registrationData.goalSelections || []}
          values={registrationData.goalTargetMap || {}}
          currency={registrationData.currency || profile.currency || DEFAULT_PROFILE.currency}
          onChange={handleGoalTargetDraftChange}
          onSubmit={handleGoalTargetSubmit}
          onBack={onboardingBackHandler}
          colors={colors}
          t={t}
          language={language}
          customGoals={registrationData.customGoals || []}
          onSkip={onboardingSkipHandler}
        />
      );
    } else if (onboardingStep === "analytics_consent") {
      onboardContent = (
        <AnalyticsConsentScreen
          colors={colors}
          t={t}
          onSubmit={(allow) => handleAnalyticsConsentComplete(allow)}
          onBack={onboardingBackHandler}
        />
      );
    } else if (onboardingStep === "push_optin") {
      onboardContent = (
        <OnboardingNotificationsScreen
          colors={colors}
          t={t}
          onContinue={handleOnboardingNotificationsContinue}
          mascotHappySource={tamagotchiAnimations.happy}
        />
      );
    }
    const onboardingBackground = onboardingStep === "logo" ? "#fff" : colors.background;
    return (
      <>
        <TouchableWithoutFeedback
          onPress={Keyboard.dismiss}
          accessible={false}
          disabled={!keyboardVisible}
          touchSoundDisabled
        >
          <View style={[styles.appBackground, { backgroundColor: onboardingBackground }]}>
            <SafeAreaView
              style={[
                styles.appShell,
                {
                  backgroundColor: onboardingBackground,
                  paddingTop: topSafeInset,
                },
              ]}
            >
              {shouldRenderStatusGlass && (
                <StatusGlass
                  height={topSafeInset}
                  colors={{ ...colors, background: onboardingBackground }}
                  theme={theme}
                  blurAvailable={statusBlurAvailable}
                  solid={Platform.OS === "android"}
                />
              )}
              <StatusBar
                style={theme === "dark" ? "light" : "dark"}
                backgroundColor={canSetSystemBarColors ? onboardingBackground : undefined}
              />
              {onboardContent || (startupLogoReady ? <LogoSplash onDone={handleOnboardingLogoComplete} /> : null)}
              {backGestureResponder && (
                <View pointerEvents="box-none" style={styles.backGestureWrapper}>
                  <View style={styles.backGestureEdge} {...backGestureResponder.panHandlers} />
                </View>
              )}
            </SafeAreaView>
          </View>
        </TouchableWithoutFeedback>
        <ImageSourceSheet
          visible={showImageSourceSheet}
          colors={colors}
          t={t}
          onClose={closeImagePickerSheet}
          onSelect={handleImageSourceChoice}
        />
        <OnboardingGoalModal
          visible={onboardingGoalModal.visible}
          colors={colors}
          t={t}
          currency={registrationData.currency || profile.currency || DEFAULT_PROFILE.currency}
          data={onboardingGoalModal}
          onChange={handleOnboardingGoalChange}
          onSubmit={handleOnboardingGoalSubmit}
          onCancel={handleOnboardingGoalCancel}
          keyboardOffset={keyboardModalOffset}
        />
        <TermsModal
          visible={termsModalVisible}
          colors={colors}
          t={t}
          language={language}
          onAccept={handleTermsAccept}
          onCancel={handleTermsCancel}
          onOpenLink={handleTermsLinkOpen}
        />
      </>
    );
  }

  return (
    <SavingsProvider value={{ savedTotalUSD }}>
      <TouchableWithoutFeedback
        onPress={Keyboard.dismiss}
        accessible={false}
        disabled={!keyboardVisible}
        touchSoundDisabled
      >
        <View style={[styles.appBackground, { backgroundColor: colors.background }]}>
          <SafeAreaView
            style={[
              styles.appShell,
              {
                backgroundColor: colors.background,
                paddingTop: topSafeInset,
              },
            ]}
            onLayout={handleHomeLayout}
          >
            {shouldRenderStatusGlass && (
              <StatusGlass
                height={topSafeInset}
                colors={colors}
                theme={theme}
                blurAvailable={statusBlurAvailable}
                solid={Platform.OS === "android"}
              />
            )}
            {startupLogoVisible && (
              <View style={[styles.logoSplashOverlay, { backgroundColor: colors.background }]}>
                <LogoSplash onDone={handleStartupLogoComplete} />
              </View>
            )}
            <StatusBar
              style={theme === "dark" ? "light" : "dark"}
              backgroundColor={
                canSetSystemBarColors ? (systemOverlayActive ? overlaySystemColor : colors.background) : undefined
              }
            />
            {backGestureResponder && (
              <View pointerEvents="box-none" style={styles.backGestureWrapper}>
                <View style={styles.backGestureEdge} {...backGestureResponder.panHandlers} />
              </View>
            )}
            <View style={[styles.screenWrapper, screenKeyboardAdjustmentStyle]}>{renderActiveScreen()}</View>
        {savingsBreakdownVisible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={closeSavingsBreakdown}>
              <View style={styles.breakdownOverlay}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.breakdownCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <View style={styles.breakdownHeader}>
                      <Text style={[styles.breakdownTitle, { color: colors.text }]}>
                        {t("savingsBreakdownTitle")}
                      </Text>
                      <TouchableOpacity onPress={closeSavingsBreakdown}>
                        <Text style={[styles.breakdownClose, { color: colors.muted }]}>âœ•</Text>
                      </TouchableOpacity>
                    </View>
                  <View style={styles.breakdownBars}>
                    {(() => {
                        const maxTotal = Math.max(...savingsBreakdown.days.map((d) => d.total || 0), 1);
                        return savingsBreakdown.days.map((day) => (
                          <View key={day.label} style={styles.breakdownBarItem}>
                            <View style={[styles.breakdownBarTrack, { backgroundColor: colors.border }]}>
                              {day.stacks.map((stack) => {
                                const share = day.total ? (stack.value / (day.total || 1)) * 100 : 0;
                                const height = Math.max(6, Math.min(90, share));
                                return (
                                  <View
                                    key={stack.title}
                                    style={[
                                      styles.breakdownBarStack,
                                      {
                                        height: `${height}%`,
                                        backgroundColor: stack.color,
                                      },
                                    ]}
                                  />
                                );
                              })}
                            </View>
                            <Text style={[styles.breakdownBarLabel, { color: colors.muted }]}>{day.label}</Text>
                            <View style={styles.breakdownAmountWrapper}>
                              <Text
                                style={[styles.breakdownBarAmount, { color: colors.text }]}
                                numberOfLines={1}
                                adjustsFontSizeToFit
                                minimumFontScale={0.6}
                              >
                                {savingsBreakdown.formatLocal(day.total)}
                              </Text>
                            </View>
                          </View>
                        ));
                      })()}
                    </View>
                    <View style={styles.breakdownLegend}>
                      {savingsBreakdown.legend.map((entry) => (
                        <View
                          key={entry.id}
                          style={[styles.breakdownLegendItem, { borderColor: colors.border }]}
                        >
                          <View
                            style={[styles.breakdownLegendDot, { backgroundColor: entry.color }]}
                          />
                          <Text style={[styles.breakdownLegendText, { color: colors.text }]}>
                            {entry.label} Â· {entry.percent}%
                          </Text>
                        </View>
                      ))}
                    </View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {spendBreakdownVisible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={closeSpendBreakdown}>
              <View style={styles.breakdownOverlay}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.spendStatsCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <View style={styles.spendStatsHeader}>
                      <View style={[styles.spendStatsTabs, { backgroundColor: colors.background }]}>
                        {[
                          { id: "day", label: t("spendStatsTabDay") },
                          { id: "week", label: t("spendStatsTabWeek") },
                          { id: "month", label: t("spendStatsTabMonth") },
                        ].map((tab) => {
                          const active = spendBreakdownRange === tab.id;
                          return (
                            <TouchableOpacity
                              key={tab.id}
                              style={[
                                styles.spendStatsTab,
                                active && styles.spendStatsTabActive,
                                active && { backgroundColor: colors.card },
                              ]}
                              activeOpacity={0.85}
                              onPress={() => setSpendBreakdownRangeMode(tab.id)}
                            >
                              <Text
                                style={[
                                  styles.spendStatsTabText,
                                  { color: active ? colors.text : colors.muted },
                                ]}
                              >
                                {tab.label}
                              </Text>
                            </TouchableOpacity>
                          );
                        })}
                      </View>
                      <TouchableOpacity
                        onPress={closeSpendBreakdown}
                        style={[styles.spendStatsCloseButton, { backgroundColor: colors.background }]}
                      >
                        <Text style={[styles.spendStatsCloseText, { color: colors.muted }]}>âœ•</Text>
                      </TouchableOpacity>
                    </View>
                    <View style={styles.spendStatsTitleRow}>
                      <TouchableOpacity
                        onPress={handleSpendBreakdownPrev}
                        style={[styles.spendStatsNavButton, { backgroundColor: colors.background }]}
                      >
                        <Text style={[styles.spendStatsNavText, { color: colors.muted }]}>â€¹</Text>
                      </TouchableOpacity>
                      <View style={styles.spendStatsTitleBlock}>
                        {!!spendBreakdown.averageLabel && (
                          <Text style={[styles.spendStatsSubtitle, { color: colors.muted }]}>
                            {spendBreakdown.averageLabel}
                          </Text>
                        )}
                        <Text style={[styles.spendStatsTitle, { color: colors.text }]}>
                          {spendBreakdown.rangeTitle}
                        </Text>
                      </View>
                      <TouchableOpacity
                        onPress={handleSpendBreakdownNext}
                        disabled={spendBreakdownOffset === 0}
                        style={[
                          styles.spendStatsNavButton,
                          { backgroundColor: colors.background },
                          spendBreakdownOffset === 0 && styles.spendStatsNavButtonDisabled,
                        ]}
                      >
                        <Text
                          style={[
                            styles.spendStatsNavText,
                            { color: spendBreakdownOffset === 0 ? colors.border : colors.muted },
                          ]}
                        >
                          â€º
                        </Text>
                      </TouchableOpacity>
                    </View>
                    <View style={styles.spendStatsChart}>
                      {(() => {
                        const maxTotal = Math.max(
                          ...spendBreakdown.buckets.map((bucket) => bucket.total || 0),
                          1
                        );
                        return spendBreakdown.buckets.map((bucket) => (
                          <View key={bucket.label} style={styles.spendStatsBarItem}>
                            <Text style={[styles.spendStatsValue, { color: colors.text }]}>
                              {bucket.total > 0 ? spendBreakdown.formatLocal(bucket.total) : ""}
                            </Text>
                            <View
                              style={[
                                styles.spendStatsBarTrack,
                                { backgroundColor: colors.background },
                              ]}
                            >
                              {bucket.stacks.slice().reverse().map((stack) => {
                                const share = maxTotal ? (stack.value / maxTotal) * 100 : 0;
                                const height = Math.max(6, Math.min(92, share));
                                return (
                                  <View
                                    key={stack.title}
                                    style={[
                                      styles.spendStatsBarStack,
                                      {
                                        height: `${height}%`,
                                        backgroundColor: stack.color,
                                      },
                                    ]}
                                  />
                                );
                              })}
                            </View>
                            <Text style={[styles.spendStatsBarLabel, { color: colors.muted }]}>
                              {bucket.label}
                            </Text>
                          </View>
                        ));
                      })()}
                    </View>
                    <View style={[styles.spendStatsDivider, { backgroundColor: colors.border }]} />
                    <View style={styles.spendStatsLegend}>
                      {spendBreakdown.legend.map((entry) => (
                        <View
                          key={entry.id}
                          style={[
                            styles.spendStatsLegendPill,
                            { backgroundColor: colorWithAlpha(entry.color, 0.18) },
                          ]}
                        >
                          <Text style={[styles.spendStatsLegendPercent, { color: entry.color }]}>
                            {entry.percent}%
                          </Text>
                          <Text style={[styles.spendStatsLegendLabel, { color: colors.text }]}>
                            {entry.label}
                          </Text>
                        </View>
                      ))}
                    </View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {dailyChallengePromptVisible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={handleDailyChallengeLater}>
              <View style={styles.dailySummaryBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.dailyChallengeCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <View
                      style={[
                        styles.dailyChallengeGlow,
                        { backgroundColor: isDarkTheme ? "rgba(255,200,87,0.4)" : "rgba(255,160,60,0.25)" },
                      ]}
                    />
                    <View style={styles.dailyChallengeContent}>
                      <View style={styles.dailyChallengeHeroRow}>
                        <View style={{ flex: 1, gap: 6 }}>
                          <View
                            style={[
                              styles.dailyChallengeBadge,
                              { borderColor: colors.border, backgroundColor: colors.background },
                            ]}
                          >
                            <Text style={[styles.dailyChallengeBadgeText, { color: colors.muted }]}>
                              {t("dailyChallengeOfferBadge")}
                            </Text>
                          </View>
                          <Text style={[styles.dailyChallengeTitle, { color: colors.text }]}>
                            {t("dailyChallengeOfferTitle")}
                          </Text>
                          <Text style={[styles.dailyChallengeSubtitle, { color: colors.muted }]}>
                            {t("dailyChallengeOfferSubtitle", { temptation: dailyChallengeDisplayTitle })}
                          </Text>
                        </View>
                        <View style={styles.dailyChallengeRewardStack}>
                          <HealthRewardTokens amount={dailyChallengeRewardBonus} color={colors.text} iconSize={18} />
                          <Text style={[styles.dailyChallengeRewardHint, { color: colors.text }]}>
                            {t("dailyChallengeOfferReward", { amount: dailyChallengeRewardLabel })}
                          </Text>
                        </View>
                      </View>
                        <View style={styles.dailyChallengeTemptationRow}>
                          <View style={styles.dailyChallengeEmojiCard}>
                          <Text style={styles.dailyChallengeEmojiCardText}>
                            {dailyChallengeTemplate?.emoji || dailyChallenge.emoji || "âœ¨"}
                          </Text>
                        </View>
                        <View style={{ flex: 1, gap: 4 }}>
                          <Text style={[styles.dailyChallengeTemptationTitle, { color: colors.text }]}>
                            {dailyChallengeDisplayTitle}
                          </Text>
                          <Text style={[styles.dailyChallengeTemptationHint, { color: colors.muted }]}>
                            {t("dailyChallengeOfferHint")}
                          </Text>
                        </View>
                      </View>
                      <View style={styles.dailyChallengeActions}>
                        <TouchableOpacity
                          style={[styles.dailyChallengePrimaryButton, { backgroundColor: colors.text }]}
                          activeOpacity={0.92}
                          onPress={handleDailyChallengeAccept}
                        >
                          <Text style={[styles.dailyChallengePrimaryText, { color: colors.background }]}>
                            {t("dailyChallengeOfferAccept")}
                          </Text>
                        </TouchableOpacity>
                        <TouchableOpacity
                          style={[styles.dailyChallengeGhostButton, { borderColor: colors.border }]}
                          activeOpacity={0.85}
                          onPress={handleDailyChallengeLater}
                        >
                          <Text style={[styles.dailyChallengeGhostText, { color: colors.muted }]}>
                            {t("dailyChallengeOfferLater")}
                          </Text>
                        </TouchableOpacity>
                      </View>
                    </View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {coinValueModalVisible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <View style={styles.quickModalBackdrop}>
              <View style={[styles.quickModalCard, { backgroundColor: colors.card }]}>
                <View style={styles.coinValueHero}>
                  <View style={styles.coinValueHeroGlow} />
                  <Image source={LEVEL_SHARE_CAT} style={styles.coinValueHeroCat} />
                  <View style={styles.coinValueHeroFooter}>
                    <Image source={LEVEL_SHARE_LOGO} style={styles.coinValueHeroLogo} />
                    <Text style={styles.coinValueHeroBrand}>Almost</Text>
                  </View>
                </View>
                <Text style={[styles.quickModalTitle, { color: colors.text }]}>
                  {t("coinValueTitle")}
                </Text>
                <Text style={[styles.quickModalSubtitle, { color: colors.muted }]}>
                  {t("coinValueBody")}
                </Text>
                <View style={styles.quickModalActions}>
                  <TouchableOpacity
                    style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
                    onPress={dismissCoinValueModal}
                    activeOpacity={0.9}
                  >
                    <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>
                      {t("coinValueCta")}
                    </Text>
                  </TouchableOpacity>
                </View>
              </View>
            </View>
          </Modal>
        )}
        {dailySummaryVisible && dailySummaryData && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={handleDailySummaryContinue}>
              <View style={styles.dailySummaryBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.dailySummaryCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <View
                      style={[
                        styles.dailySummaryGlow,
                        { backgroundColor: isDarkTheme ? "#FFC857" : "#111111" },
                      ]}
                    />
                    <View style={styles.dailySummaryCardContent}>
                      <View style={styles.dailySummaryHeroRow}>
                        <View
                          style={[
                            styles.dailySummaryIconWrap,
                            {
                              backgroundColor: isDarkTheme
                                ? "rgba(255,255,255,0.08)"
                                : "rgba(17,17,17,0.05)",
                              borderColor: colors.border,
                            },
                          ]}
                        >
                          <Text style={styles.dailySummaryIconText}>ðŸŒ™</Text>
                        </View>
                        <View style={styles.dailySummaryHeroText}>
                          <View
                            style={[
                              styles.dailySummaryBadge,
                              { backgroundColor: colors.background, borderColor: colors.border },
                            ]}
                          >
                            <Text style={[styles.dailySummaryBadgeText, { color: colors.muted }]}>
                              {t("dailySummaryBadgeLabel")}
                            </Text>
                          </View>
                          <Text style={[styles.dailySummaryTitle, { color: colors.text }]}>
                            {t("dailySummaryTitle")}
                          </Text>
                          <Text style={[styles.dailySummarySubtitle, { color: colors.muted }]}>
                            {t("dailySummarySubtitle")}
                          </Text>
                        </View>
                      </View>
                      <View
                        style={[
                          styles.dailySummaryHighlight,
                          {
                            backgroundColor: isDarkTheme
                              ? "rgba(255,255,255,0.06)"
                              : "rgba(17,17,17,0.03)",
                            borderColor: isDarkTheme ? "rgba(255,255,255,0.12)" : "rgba(0,0,0,0.06)",
                          },
                        ]}
                      >
                        <Text style={[styles.dailySummaryHighlightLabel, { color: colors.muted }]}>
                          {t("dailySummarySavedLabel")}
                        </Text>
                        <Text style={[styles.dailySummaryHighlightValue, { color: colors.text }]}>
                          {formatCurrency(
                            convertToCurrency(
                              dailySummaryData.savedUSD || 0,
                              profile.currency || DEFAULT_PROFILE.currency
                            ),
                            profile.currency || DEFAULT_PROFILE.currency
                          )}
                        </Text>
                        <Text style={[styles.dailySummaryHighlightSub, { color: colors.muted }]}>
                          {t("dailySummarySavedSub")}
                        </Text>
                      </View>
                      <View style={styles.dailySummaryStatsRow}>
                        <View
                          style={[
                            styles.dailySummaryStatCard,
                            {
                              backgroundColor: isDarkTheme
                                ? "rgba(255,255,255,0.08)"
                                : "rgba(255,255,255,0.94)",
                              borderColor: isDarkTheme ? "rgba(255,255,255,0.12)" : "rgba(0,0,0,0.05)",
                            },
                          ]}
                        >
                          <Text style={[styles.dailySummaryStatValue, { color: colors.text }]}>
                            {dailySummaryData.declines || 0}
                          </Text>
                          <Text style={[styles.dailySummaryStatLabel, { color: colors.muted }]}>
                            {t("statsDeclines")}
                          </Text>
                        </View>
                        <View
                          style={[
                            styles.dailySummaryStatCard,
                            {
                              backgroundColor: isDarkTheme
                                ? "rgba(255,255,255,0.08)"
                                : "rgba(255,255,255,0.94)",
                              borderColor: isDarkTheme ? "rgba(255,255,255,0.12)" : "rgba(0,0,0,0.05)",
                            },
                          ]}
                        >
                        <Text style={[styles.dailySummaryStatValue, { color: colors.text }]}>
                            {dailySummaryData.spends || 0}
                          </Text>
                          <Text style={[styles.dailySummaryStatLabel, { color: colors.muted }]}>
                            {t("dailySummarySpendsLabel")}
                          </Text>
                        </View>
                      </View>
                      <TouchableOpacity
                        style={[styles.dailySummaryButton, { backgroundColor: colors.text }]}
                        onPress={handleDailySummaryContinue}
                        activeOpacity={0.9}
                      >
                        <Text style={[styles.dailySummaryButtonText, { color: colors.background }]}>
                          {t("dailySummaryContinue")}
                        </Text>
                        <Text style={[styles.dailySummaryButtonIcon, { color: colors.background }]}>
                          â†’
                        </Text>
                      </TouchableOpacity>
                      <Text style={[styles.dailySummaryHint, { color: colors.muted }]}>
                        {t("dailySummaryHint")}
                      </Text>
                    </View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {pushDayThreePromptVisible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <View style={styles.quickModalBackdrop}>
              <View style={[styles.quickModalCard, { backgroundColor: colors.card }]}>
                <Text style={[styles.quickModalTitle, { color: colors.text }]}>
                  {t("pushOptInPromptTitle")}
                </Text>
                <Text style={[styles.quickModalSubtitle, { color: colors.muted }]}>
                  {t("pushOptInPromptBody")}
                </Text>
                <View style={styles.quickModalActions}>
                  <TouchableOpacity
                    style={[styles.quickModalSecondary, { borderColor: colors.border }]}
                    activeOpacity={0.85}
                    onPress={handlePushDayThreePromptLater}
                  >
                    <Text style={[styles.quickModalSecondaryText, { color: colors.muted }]}>
                      {t("pushOptInPromptSecondary")}
                    </Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
                    activeOpacity={0.92}
                    onPress={handlePushDayThreePromptEnable}
                  >
                    <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>
                      {t("pushOptInPromptPrimary")}
                    </Text>
                  </TouchableOpacity>
                </View>
              </View>
            </View>
          </Modal>
        )}
        {ratingPromptVisible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={handleRatingPromptLater}>
              <View style={styles.ratingPromptBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.ratingPromptCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <Animated.View
                      style={[styles.ratingPromptCatWrap, { transform: [{ translateY: ratingPromptCatBob }] }]}
                    >
                      <Image
                        source={tamagotchiAnimations?.cry || CLASSIC_TAMAGOTCHI_ANIMATIONS.cry}
                        style={styles.ratingPromptCat}
                        resizeMode="contain"
                      />
                    </Animated.View>
                    <Text style={[styles.ratingPromptTitle, { color: colors.text }]}>
                      {t("ratingPromptTitle")}
                    </Text>
                    <Text style={[styles.ratingPromptBody, { color: colors.muted }]}>
                      {t("ratingPromptBody")}
                    </Text>
                    <View style={styles.ratingPromptActions}>
                      <TouchableOpacity
                        style={[styles.ratingPromptSecondary, { borderColor: colors.border }]}
                        activeOpacity={0.85}
                        onPress={handleRatingPromptLater}
                      >
                        <Text style={[styles.ratingPromptSecondaryText, { color: colors.muted }]}>
                          {t("ratingPromptLater")}
                        </Text>
                      </TouchableOpacity>
                      <TouchableOpacity
                        style={[styles.ratingPromptPrimary, { backgroundColor: colors.text }]}
                        activeOpacity={0.92}
                        onPress={handleRatingPromptConfirm}
                      >
                        <Text style={[styles.ratingPromptPrimaryText, { color: colors.background }]}>
                          {t("ratingPromptAction")}
                        </Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {levelShareModal.visible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={closeLevelShareModal}>
              <View style={styles.dailySummaryBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.levelShareModalCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <Text style={[styles.levelShareModalTitle, { color: colors.text }]}>
                      {t("levelShareModalTitle")}
                    </Text>
                    <Text style={[styles.levelShareModalCaption, { color: colors.muted }]}>
                      {t("levelShareModalCaption")}
                    </Text>
                    <ViewShot
                      ref={levelShareCardRef}
                      options={{ format: "png", quality: 0.96, result: "tmpfile" }}
                      style={styles.levelShareShot}
                    >
                      <View style={styles.levelShareCanvas}>
                        <View style={styles.levelShareBadge}>
                          <Text style={styles.levelShareBadgeText}>{t("levelShareCardBadge")}</Text>
                        </View>
                        <Text style={styles.levelShareCanvasTitle}>
                          {t("levelShareCardTitle", { level: levelShareModal.level })}
                        </Text>
                        <Text style={styles.levelShareCanvasSubtitle}>{t("levelShareCardSubtitle")}</Text>
                        <Image source={LEVEL_SHARE_CAT} style={styles.levelShareCat} />
                        <Text style={styles.levelShareJoin}>{t("levelShareJoin")}</Text>
                        <Text style={styles.levelShareInstagram}>@almostsavings</Text>
                        <View style={styles.levelShareFooter}>
                          <Image source={LEVEL_SHARE_LOGO} style={styles.levelShareLogo} />
                          <View>
                            <Text style={styles.levelShareFooterBrand}>{t("levelShareFooterBrand")}</Text>
                            <Text style={styles.levelShareFooterHint}>{t("levelShareFooterHint")}</Text>
                          </View>
                        </View>
                      </View>
                    </ViewShot>
                    <View style={styles.levelShareActions}>
                      <TouchableOpacity
                        style={[
                          styles.levelSharePrimary,
                          { backgroundColor: colors.text, opacity: levelShareSharing ? 0.6 : 1 },
                        ]}
                        activeOpacity={0.92}
                        disabled={levelShareSharing}
                        onPress={handleLevelShareConfirm}
                      >
                        <Text style={[styles.levelSharePrimaryText, { color: colors.background }]}>
                          {levelShareSharing ? "..." : t("levelShareModalShare")}
                        </Text>
                      </TouchableOpacity>
                      <TouchableOpacity
                        style={[styles.levelShareGhost, { borderColor: colors.border }]}
                        activeOpacity={0.85}
                        onPress={closeLevelShareModal}
                      >
                        <Text style={[styles.levelShareGhostText, { color: colors.muted }]}>
                          {t("levelShareModalClose")}
                        </Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        <View
          style={[
            styles.tabBar,
            tutorialIsTemptation && styles.tabBarDimmed,
            {
              backgroundColor: colors.card,
              borderTopColor: colors.border,
              paddingBottom: tabBarBottomInset + (Platform.OS === "android" ? 12 : 0),
              marginBottom: Platform.OS === "ios" ? -(safeAreaInsets.bottom || 0) : 0,
              paddingTop: 18,
            },
          ]}
          onLayout={handleTabBarLayout}
        >
          {availableTabs.map((tab) => {
            const isHighlighted =
              !tutorialIsTemptation && !!tutorialHighlightTabs?.has(tab);
            const isActiveTab = activeTab === tab;
            const isTabLocked =
              (tab === "pending" && !thinkingUnlocked) ||
              (tab === "purchases" && !rewardsUnlocked);
            const highlightBackground = theme === "dark" ? "rgba(255,255,255,0.2)" : "#FFFFFF";
            const highlightTextColor = theme === "dark" ? "#05070D" : colors.text;
            const defaultTextColor = isActiveTab ? colors.text : colors.muted;
            const textColor = isHighlighted ? highlightTextColor : defaultTextColor;
            const highlightBorderColor =
              theme === "dark" ? "rgba(255,255,255,0.4)" : "rgba(0,0,0,0.08)";
            return (
              <TouchableOpacity
                key={tab}
                style={[
                  styles.tabButton,
                  isHighlighted && styles.tabButtonHighlight,
                  isHighlighted && {
                    borderColor: highlightBorderColor,
                    backgroundColor: highlightBackground,
                  },
                ]}
                onPress={() => handleTabChange(tab)}
              >
                <Text
                  style={[
                    styles.tabButtonText,
                    {
                      color: textColor,
                      fontWeight: isActiveTab || isHighlighted ? "700" : "500",
                      fontSize: tabLabelFontSize,
                    },
                  ]}
                >
                  {tab === "feed"
                    ? t("feedTab")
                    : tab === "cart"
                    ? t("wishlistTab")
                    : tab === "pending"
                    ? t("pendingTab")
                    : tab === "purchases"
                    ? t("purchasesTitle")
                    : t("profileTab")}
                </Text>
                {isTabLocked && (
                  <Text style={[styles.tabLockIconOverlay, { color: textColor }]}>ðŸ”’</Text>
                )}
                {tab === "cart" && challengeRewardsBadgeCount > 0 && challengesUnlocked && (
                  <View
                    style={[
                      styles.tabBadge,
                      styles.tabBadgeFloating,
                      {
                        backgroundColor: theme === "dark" ? "#FEE5A8" : colors.text,
                      },
                    ]}
                  >
                    <Text
                      style={[
                        styles.tabBadgeText,
                        { color: theme === "dark" ? "#05070D" : colors.background },
                      ]}
                    >
                      {challengeRewardsBadgeCount > 99 ? "99+" : `${challengeRewardsBadgeCount}`}
                    </Text>
                  </View>
                )}
                {tab === "purchases" && rewardsBadgeCount > 0 && rewardsUnlocked && (
                  <View
                    style={[
                      styles.tabBadge,
                      styles.tabBadgeFloating,
                      {
                        backgroundColor: theme === "dark" ? "#FEE5A8" : colors.text,
                      },
                    ]}
                  >
                    <Text
                      style={[
                        styles.tabBadgeText,
                        { color: theme === "dark" ? "#05070D" : colors.background },
                      ]}
                    >
                      {rewardsBadgeCount > 99 ? "99+" : `${rewardsBadgeCount}`}
                    </Text>
                  </View>
                )}
              </TouchableOpacity>
            );
          })}
        </View>

        {activeTab !== "profile" && activeTab !== "purchases" && !(activeTab === "pending" && !thinkingUnlocked) && (
          <View
            pointerEvents="box-none"
            style={[
              styles.fabCenterContainer,
              Platform.OS === "android"
                ? { bottom: FAB_CONTAINER_BOTTOM + tabBarBottomInset }
                : null,
            ]}
          >
            <View
              ref={fabButtonWrapperRef}
              style={styles.fabButtonWrapper}
              pointerEvents="box-none"
              onLayout={handleFabWrapperLayout}
            >
              {fabTutorialVisible && (
                <View
                  pointerEvents="none"
                  style={[
                    styles.fabTutorialHalo,
                    {
                      backgroundColor: theme === "dark" ? "rgba(255,214,140,0.22)" : "rgba(245,200,105,0.22)",
                      borderColor: theme === "dark" ? "#FFE08A" : "#F5C869",
                      shadowColor: theme === "dark" ? "#FFE08A" : "#F5C869",
                    },
                  ]}
                />
              )}
              <AnimatedTouchableOpacity
                style={[
                  styles.cartBadge,
                  {
                    backgroundColor: colors.text,
                    borderColor: colors.border,
                    transform: [{ scale: cartBadgeScale }],
                  },
                  fabTutorialVisible && styles.cartBadgeHighlight,
                ]}
                onPress={handleFabPress}
                onLongPress={handleFabLongPress}
                delayLongPress={420}
              >
                <Text
                  style={[styles.cartBadgeIcon, { color: colors.background }]}
                  numberOfLines={1}
                >
                  {fabMainIcon}
                </Text>
              </AnimatedTouchableOpacity>
            </View>
          </View>
        )}

        <CoinEntryModal
          visible={coinEntryVisible}
          colors={colors}
          t={t}
          currency={profile.currency || DEFAULT_PROFILE.currency}
          language={language}
          maxAmountUSD={coinSliderMaxUSD}
          onUpdateMaxUSD={handleCoinSliderMaxUpdate}
          onSubmit={handleCoinEntrySubmit}
          onCancel={handleCoinEntryClose}
          playSound={playSound}
        />

        <QuickCustomModal
          visible={showCustomSpend}
          colors={colors}
          t={t}
          currency={profile.currency || DEFAULT_PROFILE.currency}
          data={quickSpendDraft}
          onChange={handleQuickCustomChange}
          onSubmit={handleQuickCustomSubmit}
          onCancel={handleQuickCustomCancel}
          language={language}
          keyboardOffset={keyboardModalOffset}
        />
        <NewPendingModal
          visible={newPendingModal.visible}
          colors={colors}
          t={t}
          currency={profile.currency || DEFAULT_PROFILE.currency}
          data={newPendingModal}
          onChange={handleNewPendingChange}
          onSubmit={handleNewPendingSubmit}
          onCancel={handleNewPendingCancel}
          keyboardOffset={keyboardModalOffset}
        />

        <NewGoalModal
          visible={newGoalModal.visible}
          colors={colors}
          t={t}
          currency={profile.currency || DEFAULT_PROFILE.currency}
          data={newGoalModal}
          onChange={handleNewGoalChange}
          onSubmit={handleNewGoalSubmit}
          onCancel={handleNewGoalCancel}
          keyboardOffset={keyboardModalOffset}
        />

        {activeTab !== "profile" && fabTutorialVisible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={() => handleFabTutorialDismiss("backdrop")}>
              <View style={styles.fabTutorialBackdrop}>
                <Svg
                  pointerEvents="none"
                  width={SCREEN_WIDTH}
                  height={SCREEN_HEIGHT}
                  style={styles.fabTutorialOverlaySvg}
                >
                  <Defs>
                    <Mask id="fabTutorialMask">
                      <SvgRect width={SCREEN_WIDTH} height={SCREEN_HEIGHT} fill="white" />
                      <SvgCircle
                        cx={fabTutorialCutout.centerX}
                        cy={fabTutorialCutout.centerY}
                        r={FAB_TUTORIAL_HALO_SIZE / 2}
                        fill="black"
                      />
                    </Mask>
                  </Defs>
                  <SvgRect
                    width={SCREEN_WIDTH}
                    height={SCREEN_HEIGHT}
                    fill={fabOverlayColor}
                    mask="url(#fabTutorialMask)"
                  />
                </Svg>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View style={styles.fabTutorialContent} pointerEvents="box-none">
                    <View
                      style={[
                        styles.fabTutorialCard,
                        {
                          backgroundColor: colors.card,
                          borderColor: colors.border,
                          marginBottom: tabBarBottomInset + FAB_CONTAINER_BOTTOM + FAB_TUTORIAL_CARD_SPACING,
                        },
                      ]}
                    >
                      <Text style={[styles.fabTutorialTitle, { color: colors.text }]}>
                        {t("fabTutorialTitle")}
                      </Text>
                      <Text style={[styles.fabTutorialDescription, { color: colors.muted }]}>
                        {t("fabTutorialDesc")}
                      </Text>
                      <TouchableOpacity
                        style={[styles.fabTutorialButton, { backgroundColor: colors.text }]}
                        onPress={() => handleFabTutorialDismiss("cta")}
                      >
                        <Text style={[styles.fabTutorialButtonText, { color: colors.background }]}>
                          {t("fabTutorialAction")}
                        </Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}

        {tutorialContext && activeTutorialStep && (
          <Modal
            visible
            transparent
            animationType="fade"
            statusBarTranslucent
            onRequestClose={tutorialSkipHandler}
          >
            <View
              style={[
                styles.tutorialBackdrop,
                tutorialBackdropPlacementStyle,
                { paddingBottom: tutorialBackdropPaddingBottom },
              ]}
              pointerEvents="box-none"
            >
              {tutorialIsTemptation ? (
                <>
                  <View pointerEvents="none" style={StyleSheet.absoluteFillObject}>
                    <Svg
                      width="100%"
                      height="100%"
                      viewBox={`0 0 ${SCREEN_WIDTH} ${SCREEN_HEIGHT}`}
                      pointerEvents="none"
                    >
                      <Defs>
                        <Mask id="tutorialHighlightMask">
                          <SvgRect x="0" y="0" width="100%" height="100%" fill="#fff" />
                          {tutorialHighlightMaskRect && (
                            <SvgRect
                              x={tutorialHighlightMaskRect.x}
                              y={tutorialHighlightMaskRect.y}
                              width={tutorialHighlightMaskRect.width}
                              height={tutorialHighlightMaskRect.height}
                              rx={tutorialHighlightMaskRect.radius}
                              ry={tutorialHighlightMaskRect.radius}
                              fill="#000"
                            />
                          )}
                        </Mask>
                      </Defs>
                      <SvgRect
                        x="0"
                        y="0"
                        width="100%"
                        height="100%"
                        fill="rgba(0,0,0,0.6)"
                        mask="url(#tutorialHighlightMask)"
                      />
                    </Svg>
                  </View>
                  {tutorialHighlightMaskRect && (
                    <View
                      pointerEvents="none"
                      style={[
                        styles.tutorialHighlightFocus,
                        {
                          top: tutorialHighlightMaskRect.y,
                          left: tutorialHighlightMaskRect.x,
                          width: tutorialHighlightMaskRect.width,
                          height: tutorialHighlightMaskRect.height,
                          borderRadius: tutorialHighlightMaskRect.radius,
                        },
                      ]}
                    />
                  )}
                </>
              ) : (
                <View
                  pointerEvents="none"
                  style={[
                    StyleSheet.absoluteFillObject,
                    styles.tutorialBackdropDim,
                    { bottom: tutorialBackdropBottomInset },
                  ]}
                />
              )}
              <View
                style={[
                  styles.tutorialCard,
                  tutorialCardPositionStyle,
                  { backgroundColor: colors.card, borderColor: colors.border },
                ]}
              >
                <Text style={styles.tutorialIcon}>{activeTutorialStep.icon}</Text>
                <Text style={[styles.tutorialTitle, { color: colors.text }]}>
                  {t(activeTutorialStep.titleKey)}
                </Text>
                <Text style={[styles.tutorialDescription, { color: colors.muted }]}>
                  {t(activeTutorialStep.descriptionKey)}
                </Text>
                <View style={styles.tutorialProgressRow}>
                  <View style={styles.tutorialDots}>
                    {tutorialContext.steps.map((step, index) => (
                      <View
                        key={step.id}
                        style={[
                          styles.tutorialDot,
                          {
                            backgroundColor:
                              index <= tutorialCurrentIndex ? colors.text : colors.border,
                          },
                        ]}
                      />
                    ))}
                  </View>
                  <Text style={[styles.tutorialProgressText, { color: colors.muted }]}>
                    {t("tutorialProgress", {
                      current: `${Math.min(tutorialCurrentIndex + 1, tutorialStepCount)}`,
                      total: `${tutorialStepCount}`,
                    })}
                  </Text>
                </View>
                <View style={styles.tutorialActions}>
                  <TouchableOpacity style={styles.tutorialSkipButton} onPress={tutorialSkipHandler}>
                    <Text style={[styles.tutorialSkipText, { color: colors.muted }]}>
                      {t("tutorialSkip")}
                    </Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.tutorialPrimaryButton, { backgroundColor: colors.text }]}
                    onPress={tutorialAdvanceHandler}
                  >
                    <Text style={[styles.tutorialPrimaryText, { color: colors.background }]}>
                      {tutorialStepCount && tutorialCurrentIndex === tutorialStepCount - 1
                        ? t("tutorialDone")
                        : t("tutorialNext")}
                    </Text>
                  </TouchableOpacity>
                </View>
              </View>
            </View>
          </Modal>
        )}
        <Modal
          visible={tamagotchiVisible}
          transparent
          animationType="fade"
          onRequestClose={closeTamagotchiOverlay}
          statusBarTranslucent
        >
          <TouchableWithoutFeedback onPress={closeTamagotchiOverlay}>
            <View style={styles.tamagotchiBackdrop}>
              {partyActive && <PartyFireworksLayer isDarkMode={isDarkTheme} />}
              <TouchableWithoutFeedback onPress={() => {}}>
                <Animated.View
                  style={[
                    styles.tamagotchiCard,
                    { backgroundColor: colors.card, borderColor: colors.border },
                    {
                      transform: [
                        {
                          translateY: tamagotchiModalAnim.interpolate({
                            inputRange: [0, 1],
                            outputRange: [20, 0],
                          }),
                        },
                        {
                          scale: tamagotchiModalAnim.interpolate({
                            inputRange: [0, 1],
                            outputRange: [0.95, 1],
                          }),
                        },
                      ],
                      opacity: tamagotchiModalAnim,
                    },
                  ]}
                >
                  <View style={styles.tamagotchiHeader}>
                    <Text style={[styles.tamagotchiTitle, { color: colors.text }]}>
                      {t("tamagotchiName")}
                    </Text>
                    <Text style={[styles.tamagotchiMood, { color: colors.muted }]}>
                      {tamagotchiMood.label}
                    </Text>
                  </View>
                  <View style={styles.tamagotchiPreview}>
                  <AlmiTamagotchi
                    override={mascotOverride}
                    onOverrideComplete={handleMascotAnimationComplete}
                    isStarving={tamagotchiMood.tone === "urgent"}
                    animations={tamagotchiAnimations}
                  />
                    <View style={styles.skinPickerControl}>
                      <TouchableOpacity
                        style={[
                          styles.skinPickerButton,
                          { borderColor: colors.border, backgroundColor: colors.card },
                          !catCustomizationUnlocked && styles.skinPickerButtonLocked,
                        ]}
                        onPress={catCustomizationUnlocked ? openSkinPicker : undefined}
                        disabled={!catCustomizationUnlocked}
                        activeOpacity={catCustomizationUnlocked ? 0.85 : 1}
                      >
                        <Text style={styles.skinPickerIcon}>ðŸ§¥</Text>
                        {!catCustomizationUnlocked && (
                          <View
                            style={[
                              styles.skinPickerLockBadge,
                              { backgroundColor: colors.card, borderColor: colors.border },
                            ]}
                          >
                            <Text style={styles.skinPickerLockText}>ðŸ”’</Text>
                          </View>
                        )}
                      </TouchableOpacity>
                      {!catCustomizationUnlocked && (
                        <Text style={[styles.skinPickerLockedLabel, { color: colors.muted }]}>
                          {t("tamagotchiCustomizationLocked", { level: 6 })}
                        </Text>
                      )}
                    </View>
                  </View>
                  <View style={styles.tamagotchiStatRow}>
                    <Text style={[styles.tamagotchiStatLabel, { color: colors.muted }]}>
                      {t("tamagotchiFullnessLabel")}
                    </Text>
                    <Text style={[styles.tamagotchiStatValue, { color: colors.text }]}>
                      {Math.round(tamagotchiHungerPercent)}%
                    </Text>
                  </View>
                  <View style={[styles.tamagotchiProgress, { backgroundColor: colors.border }]}>
                    <View
                      style={[
                        styles.tamagotchiProgressFill,
                        {
                          backgroundColor: colors.text,
                          width: `${Math.max(8, Math.min(100, tamagotchiHungerPercent))}%`,
                        },
                      ]}
                    />
                  </View>
                  <View style={styles.tamagotchiStatRow}>
                    <Text style={[styles.tamagotchiStatLabel, { color: colors.muted }]}>
                      {t("tamagotchiCoinsLabel")}
                    </Text>
                    <Text style={[styles.tamagotchiStatValue, { color: colors.text }]}>
                      {tamagotchiCoins}
                    </Text>
                  </View>
                  {tamagotchiState.lastFedAt ? (
                    <Text style={[styles.tamagotchiSub, { color: colors.muted }]}>
                      {t("tamagotchiFedAtLabel")}:{" "}
                      {new Date(tamagotchiState.lastFedAt).toLocaleString()}
                    </Text>
                  ) : (
                    <Text style={[styles.tamagotchiSub, { color: colors.muted }]}>
                      {t("tamagotchiAwaitingFirstCoin")}
                    </Text>
                  )}
                  <Text style={[styles.tamagotchiFoodTitle, { color: colors.text }]}>
                    {t("tamagotchiFoodMenuTitle")}
                  </Text>
                  <View style={styles.tamagotchiFoodList}>
                    {TAMAGOTCHI_FOOD_OPTIONS.map((food, index) => {
                      const label = food.label[language] || food.label.en;
                      const coinTier = getHealthCoinTierForAmount(food.cost);
                      const affordable = tamagotchiCoins >= food.cost;
                      const isDesired = tamagotchiDesiredFood?.id === food.id;
                      const isLast = index === TAMAGOTCHI_FOOD_OPTIONS.length - 1;
                      return (
                        <TouchableOpacity
                          key={food.id}
                          style={[
                            styles.tamagotchiFoodButton,
                            { borderColor: colors.border, backgroundColor: colors.card },
                            isDesired && { borderColor: colors.text },
                            tamagotchiIsFull && styles.tamagotchiFoodButtonDisabled,
                            isLast && styles.tamagotchiFoodButtonLast,
                          ]}
                          activeOpacity={0.9}
                          onPress={() => feedTamagotchi(food.id)}
                          disabled={tamagotchiIsFull}
                        >
                          <Text style={styles.tamagotchiFoodEmoji}>{food.emoji}</Text>
                          <View style={styles.tamagotchiFoodInfo}>
                            <Text style={[styles.tamagotchiFoodLabel, { color: colors.text }]}>{label}</Text>
                            <Text style={[styles.tamagotchiFoodBoost, { color: colors.muted }]}>
                              {t("tamagotchiFoodBoostLabel", { percent: food.hungerBoost })}
                            </Text>
                          </View>
                          <View style={styles.tamagotchiFoodCost}>
                            <Image source={coinTier.asset} style={styles.tamagotchiFoodCostIcon} />
                            <Text
                              style={[
                                styles.tamagotchiFoodCostText,
                                { color: colors.text, opacity: affordable ? 1 : 0.5 },
                              ]}
                            >
                              Ã—{food.cost}
                            </Text>
                          </View>
                          {isDesired && (
                            <View style={[styles.tamagotchiFoodBadge, { backgroundColor: colors.text }]}>
                              <Text style={[styles.tamagotchiFoodBadgeText, { color: colors.background }]}>
                                {t("tamagotchiFoodWantLabel")}
                              </Text>
                            </View>
                          )}
                        </TouchableOpacity>
                      );
                    })}
                  </View>
                  <View style={styles.tamagotchiActions}>
                    <TouchableOpacity
                      style={[
                        styles.tamagotchiButton,
                        { backgroundColor: colors.card, borderColor: colors.border },
                      ]}
                      onPress={startParty}
                    >
                      <View style={styles.tamagotchiButtonContent}>
                        <Image source={HEALTH_COIN_TIERS[1].asset} style={styles.tamagotchiButtonIcon} />
                        <Text style={[styles.tamagotchiButtonText, { color: colors.text }]}>
                          {t("tamagotchiPartyButtonLabel", { cost: TAMAGOTCHI_PARTY_BLUE_COST })}
                        </Text>
                      </View>
                    </TouchableOpacity>
                  </View>
                  {tamagotchiIsFull && (
                    <Text style={[styles.tamagotchiHint, { color: colors.muted }]}>
                      {t("tamagotchiFullHint")}
                    </Text>
                  )}
                  <TouchableOpacity onPress={closeTamagotchiOverlay} style={styles.tamagotchiClose}>
                    <Text style={[styles.tamagotchiCloseText, { color: colors.muted }]}>
                      {t("levelShareModalClose")}
                    </Text>
                  </TouchableOpacity>
                  {partyActive && (
                    <>
                      <ConfettiCannon
                        key={`party_confetti_${partyBurstKey}`}
                        count={120}
                        origin={{ x: SCREEN_WIDTH / 2, y: 0 }}
                        fadeOut
                        explosionSpeed={420}
                        fallSpeed={3200}
                      />
                      <Animated.View
                        pointerEvents="none"
                        style={[
                          styles.partyGlowOverlay,
                          {
                            opacity: partyGlow.interpolate({
                              inputRange: [0, 1],
                              outputRange: [0.1, 0.4],
                            }),
                            backgroundColor: isDarkTheme ? "rgba(110,155,255,0.6)" : "rgba(255,210,120,0.7)",
                          },
                        ]}
                      />
                    </>
                  )}
                </Animated.View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>
        <Modal
          visible={skinPickerVisible}
          transparent
          animationType="fade"
          statusBarTranslucent
          onRequestClose={closeSkinPicker}
        >
          <TouchableWithoutFeedback onPress={closeSkinPicker}>
            <View style={styles.skinPickerBackdrop}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View
                  style={[
                    styles.skinPickerCard,
                    { backgroundColor: colors.card, borderColor: colors.border },
                  ]}
                >
                  <Text style={[styles.skinPickerTitle, { color: colors.text, textAlign: "center" }]}>
                    {t("tamagotchiSkinTitle")}
                  </Text>
                  <ScrollView
                    contentContainerStyle={styles.skinPickerList}
                    showsVerticalScrollIndicator={false}
                  >
                    {tamagotchiSkinsLocked && (
                      <View
                        style={[
                          styles.skinUnlockCard,
                          {
                            backgroundColor: lightenColor(
                              colors.card,
                              isDarkTheme ? 0.08 : 0.15
                            ),
                            borderColor: colors.border,
                          },
                        ]}
                      >
                        <Text style={[styles.skinUnlockTitle, { color: colors.text }]}>
                          {t("tamagotchiSkinUnlockTitle")}
                        </Text>
                        <Text style={[styles.skinUnlockSubtitle, { color: colors.muted }]}>
                          {t("tamagotchiSkinUnlockDescription", { email: SUPPORT_EMAIL })}
                        </Text>
                        <TouchableOpacity
                          style={[
                            styles.skinUnlockButton,
                            { backgroundColor: colors.text },
                          ]}
                          onPress={handleUnlockSkinsPress}
                          activeOpacity={0.85}
                        >
                          <Text
                            style={[
                              styles.skinUnlockButtonText,
                              { color: colors.background },
                              isRomanceLocale ? { fontSize: scaleFontSize(12) } : null,
                            ]}
                          >
                            {t("tamagotchiSkinUnlockButton")}
                          </Text>
                        </TouchableOpacity>
                      </View>
                    )}
                    {TAMAGOTCHI_SKIN_OPTIONS.map((skin) => {
                      const active = skin.id === tamagotchiSkinId;
                      const locked = tamagotchiSkinsLocked && skin.id !== DEFAULT_TAMAGOTCHI_SKIN;
                      const label = skin.label?.[language] || skin.label?.en || skin.id;
                      const description =
                        skin.description?.[language] || skin.description?.en || "";
                      return (
                        <TouchableOpacity
                          key={skin.id}
                          style={[
                            styles.skinPickerItem,
                            {
                              borderColor: active ? colors.text : colors.border,
                              backgroundColor: active
                                ? lightenColor(colors.card, isDarkTheme ? 0.1 : 0.2)
                                : "transparent",
                              opacity: locked ? 0.55 : 1,
                            },
                          ]}
                          onPress={() => handleSkinSelect(skin.id)}
                          disabled={locked}
                        >
                          <Image source={skin.preview} style={styles.skinPickerAvatar} />
                          <View style={{ flex: 1 }}>
                            <Text style={[styles.skinPickerItemTitle, { color: colors.text }]}>
                              {label}
                            </Text>
                            {!!description && (
                              <Text style={[styles.skinPickerItemSubtitle, { color: colors.muted }]}>
                                {description}
                              </Text>
                            )}
                          </View>
                          {active ? (
                            <View
                              style={[
                                styles.skinPickerBadge,
                                { borderColor: colors.border, backgroundColor: colors.background },
                              ]}
                            >
                              <Text style={[styles.skinPickerBadgeText, { color: colors.text }]}>
                                {t("tamagotchiSkinCurrent")}
                              </Text>
                            </View>
                          ) : locked ? (
                            <View
                              style={[
                                styles.skinPickerBadge,
                                styles.skinPickerLockedBadge,
                                { borderColor: colors.border, backgroundColor: colors.background },
                              ]}
                            >
                              <Text
                                style={[
                                  styles.skinPickerBadgeText,
                                  styles.skinPickerLockedBadgeText,
                                  { color: colors.muted },
                                ]}
                              >
                                {t("tamagotchiSkinLockedBadge")}
                              </Text>
                            </View>
                          ) : null}
                        </TouchableOpacity>
                      );
                    })}
                  </ScrollView>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>

        {editOverlayVisible && (
          <TouchableWithoutFeedback onPress={closePriceEditor}>
            <View
              style={[styles.temptationEditOverlay, modalKeyboardPaddingStyle]}
              pointerEvents="box-none"
            >
              <Animated.View
                style={[
                  styles.temptationEditBackdrop,
                  {
                    opacity: editOverlayAnim.interpolate({
                      inputRange: [0, 1],
                      outputRange: [0, 0.6],
                    }),
                  },
                ]}
              />
              {priceEditor.item && (
                <TouchableWithoutFeedback onPress={() => {}}>
                  <Animated.View
                    style={[
                      styles.temptationEditCardContainer,
                      {
                        opacity: editOverlayAnim,
                        transform: [
                          {
                            scale: editOverlayAnim.interpolate({
                              inputRange: [0, 1],
                              outputRange: [0.92, 1],
                            }),
                          },
                          {
                            translateY: editOverlayAnim.interpolate({
                              inputRange: [0, 1],
                              outputRange: [40, 0],
                            }),
                          },
                        ],
                      },
                    ]}
                  >
                    <TemptationCard
                      item={priceEditor.item}
                      language={language}
                      colors={colors}
                      t={t}
                      allowThinkAction={thinkingUnlocked}
                      isFocusTarget={priceEditor.item?.id === focusTemplateId}
                      descriptionOverride={
                        descriptionOverrides[priceEditor.item.id] ||
                        (priceEditor.item.id === primaryTemptationId
                          ? primaryTemptationDescription
                          : null)
                      }
                      currency={profile.currency || DEFAULT_PROFILE.currency}
                      stats={resolveCardRefuseStats(priceEditor.item)}
                      feedback={cardFeedback[priceEditor.item.id]}
                      titleOverride={titleOverrides[priceEditor.item.id]}
                      goalLabel={priceEditorAssignedGoalTitle || null}
                      isEditing
                      showEditorInline
                      cardStyle={styles.temptationOverlayCard}
                      editTitleValue={priceEditor.title}
                      editPriceValue={priceEditor.value}
                      editGoalLabel={priceEditorAssignedGoalTitle || ""}
                      editEmojiValue={priceEditor.emoji}
                      editDescriptionValue={priceEditor.description || ""}
                      editCategoryValue={priceEditor.category}
                      onEditTitleChange={handlePriceTitleChange}
                      onEditPriceChange={handlePriceInputChange}
                      onEditEmojiChange={handlePriceEmojiChange}
                      onEditDescriptionChange={handlePriceDescriptionChange}
                      onEditCategoryChange={handlePriceCategoryChange}
                      onEditSave={savePriceEdit}
                      onEditCancel={closePriceEditor}
                      onEditDelete={() => promptTemptationDelete(priceEditor.item)}
                      onEditGoalSelect={() => {
                        setGoalLinkPrompt({
                          visible: true,
                          item: priceEditor.item,
                          intent: "edit",
                          streakRecoveryValue: null,
                        });
                      }}
                      onQuickGoalToggle={handleQuickGoalToggle}
                      onSwipeDelete={() => promptTemptationDelete(priceEditor.item)}
                      onAction={async (type) => {
                        await handleTemptationAction(type, priceEditor.item);
                      }}
                      onFocusBadgePress={requestFocusCancel}
                    />
                  </Animated.View>
                </TouchableWithoutFeedback>
              )}
            </View>
          </TouchableWithoutFeedback>
        )}

        {moodDetailsVisible && moodPreset && (
          <Modal
            visible
            transparent
            animationType="fade"
            onRequestClose={closeMoodDetails}
            statusBarTranslucent
          >
            <TouchableWithoutFeedback onPress={closeMoodDetails}>
              <View style={styles.moodDetailsBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <MoodGradientBlock colors={moodGradient} style={styles.moodDetailsCard}>
                    <Text style={[styles.moodDetailsLabel, { color: colors.text }]}>
                      {moodPreset.label}
                    </Text>
                    {moodDescription ? (
                      <Text style={[styles.moodDetailsDescription, { color: colors.text }]}>
                        {moodDescription}
                      </Text>
                    ) : null}
                    <TouchableOpacity
                      style={[styles.moodDetailsButton, { borderColor: colors.text }]}
                      onPress={closeMoodDetails}
                    >
                      <Text style={[styles.moodDetailsButtonText, { color: colors.text }]}>
                        {t("profileOk") || "ÐžÐº"}
                      </Text>
                    </TouchableOpacity>
                  </MoodGradientBlock>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}

        {baselinePrompt.visible && (
          <Modal
            visible
            transparent
            animationType="fade"
            onRequestClose={closeBaselinePrompt}
            statusBarTranslucent
          >
            <TouchableWithoutFeedback onPress={closeBaselinePrompt}>
              <View style={styles.baselinePromptBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.baselinePromptCard,
                      {
                        backgroundColor: colors.card,
                        borderColor: colors.border,
                      },
                    ]}
                  >
                    <Text style={[styles.baselinePromptTitle, { color: colors.text }]}>
                      {t("baselineTitle")}
                    </Text>
                    <Text style={[styles.baselinePromptSubtitle, { color: colors.muted }]}>
                      {t("baselineSubtitle")}
                    </Text>
                    <View style={styles.baselineInputGroup}>
                      <TextInput
                        style={[
                          styles.primaryInput,
                          {
                            borderColor: colors.border,
                            backgroundColor: colors.background,
                            color: colors.text,
                          },
                        ]}
                        value={baselinePrompt.value}
                        onChangeText={handleBaselinePromptChange}
                        placeholder={t("baselinePlaceholder", {
                          amount: formatSampleAmount(
                            BASELINE_SAMPLE_USD,
                            baselinePrompt.currency ||
                              profile.currency ||
                              DEFAULT_PROFILE.currency
                          ),
                        })}
                        placeholderTextColor={colorWithAlpha(colors.muted, 0.6)}
                        keyboardType={Platform.OS === "ios" ? "numbers-and-punctuation" : "decimal-pad"}
                        returnKeyType="done"
                        onSubmitEditing={handleBaselinePromptSubmit}
                      />
                    </View>
                    <Text style={[styles.baselineHint, { color: colors.muted }]}>
                      {t("baselineHint")}
                    </Text>
                    <TouchableOpacity
                      style={[styles.primaryButton, { backgroundColor: colors.text }]}
                      onPress={handleBaselinePromptSubmit}
                    >
                      <Text style={[styles.primaryButtonText, { color: colors.background }]}>
                        {t("baselineCTA")}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity style={styles.baselinePromptDismiss} onPress={closeBaselinePrompt}>
                      <Text style={[styles.baselinePromptDismissText, { color: colors.muted }]}>
                        {t("profileCancel")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}

        {potentialDetailsVisible && (
          <Modal
            visible
            transparent
            animationType="fade"
            onRequestClose={closePotentialDetails}
            statusBarTranslucent
          >
            <TouchableWithoutFeedback onPress={closePotentialDetails}>
              <View style={styles.moodDetailsBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.moodDetailsCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <Text style={[styles.moodDetailsLabel, { color: colors.text }]}>
                      {t("potentialBlockTitle")}
                    </Text>
                    <Text style={[styles.moodDetailsDescription, { color: colors.muted }]}>
                      {potentialDetailsText}
                    </Text>
                    <TouchableOpacity
                      style={[styles.moodDetailsButton, { borderColor: colors.text }]}
                      onPress={closePotentialDetails}
                    >
                      <Text style={[styles.moodDetailsButtonText, { color: colors.text }]}>
                        {t("profileOk") || "ÐžÐº"}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}

        {activeTab !== "profile" && fabMenuVisible && (
          <View pointerEvents="box-none" style={styles.fabMenuOverlay}>
            <TouchableWithoutFeedback onPress={closeFabMenu}>
              <View style={styles.fabMenuBackdrop} />
            </TouchableWithoutFeedback>
            <Animated.View
              style={[
                styles.fabOption,
                styles.fabOptionRow,
                {
                  opacity: fabMenuAnim,
                  transform: [
                    {
                      translateY: fabMenuAnim.interpolate({
                        inputRange: [0, 1],
                        outputRange: [20, 0],
                      }),
                    },
                    { scale: fabMenuAnim },
                  ],
                },
              ]}
            >
              <View style={styles.fabOptionRowContent}>
                <TouchableOpacity
                  style={[styles.fabCircle, { backgroundColor: colors.card, borderColor: colors.border }]}
                  onPress={handleFabNewGoal}
                >
                  <Text style={[styles.fabOptionText, { color: colors.text }]} numberOfLines={2}>
                    {t("fabNewGoal")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.fabCircle, { backgroundColor: colors.card, borderColor: colors.border }]}
                  onPress={handleFabNewTemptation}
                >
                  <Text style={[styles.fabOptionText, { color: colors.text }]} numberOfLines={2}>
                    {t("fabNewTemptation")}
                  </Text>
                </TouchableOpacity>
              </View>
            </Animated.View>
          </View>
        )}

        {overlay &&
          overlay.type !== "level" &&
          overlay.type !== "save" &&
          overlay.type !== "custom_temptation" &&
          overlay.type !== "primary_temptation" &&
          overlay.type !== "reward" &&
          overlay.type !== "daily_reward" &&
          overlay.type !== "health" &&
          overlay.type !== "focus_reward" &&
          overlay.type !== "goal_complete" &&
          overlay.type !== "impulse_alert" &&
          overlay.type !== "focus_digest" &&
          !isFeatureUnlockOverlay && (
            <Modal visible transparent animationType="fade" statusBarTranslucent>
              <TouchableWithoutFeedback onPress={dismissOverlay}>
                <View style={styles.confettiLayer}>
                  <View
                    style={[
                      styles.overlayDim,
                      { backgroundColor: overlayDimColor },
                    ]}
                  />
                  {overlay.type === "cancel" && <RainOverlay colors={colors} />}
                  {overlay.type === "purchase" && (
                    <ConfettiCannon
                      key={confettiKey}
                      count={90}
                      origin={{ x: SCREEN_WIDTH / 2, y: 0 }}
                      fadeOut
                      explosionSpeed={350}
                      fallSpeed={2600}
                    />
                  )}
                  <View
                    style={[
                      styles.celebrationBanner,
                      {
                        backgroundColor: overlayCardBackground,
                        borderColor: overlayBorderColor,
                        borderWidth: overlay.type === "cart" ? 0 : 1,
                      },
                    ]}
                  >
                    {(overlay.type === "cancel" ||
                      overlay.type === "purchase" ||
                      overlay.type === "completion") && (
                      <Image
                        source={
                          overlay.type === "cancel"
                            ? tamagotchiAnimations.sad
                            : tamagotchiAnimations.happy
                        }
                        style={[
                          styles.celebrationCat,
                          overlay.type === "purchase" || overlay.type === "completion"
                            ? styles.catHappy
                            : styles.catSad,
                        ]}
                      />
                    )}
                    <Text style={[styles.celebrationText, { color: colors.text }]}>
                      {overlay.message}
                    </Text>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </Modal>
        )}
        {overlay?.type === "focus_digest" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <View style={styles.overlayFullScreen}>
              <View
                style={[
                  styles.overlayDim,
                  { backgroundColor: overlayDimColor },
                ]}
              />
              <TouchableWithoutFeedback onPress={() => {}}>
                <View
                  style={[
                    styles.focusDigestCard,
                    { backgroundColor: colors.card, borderColor: colors.border },
                  ]}
                >
                  <Text style={[styles.focusDigestTitle, { color: colors.text }]}>
                    {overlay.message?.title || ""}
                  </Text>
                  <Text style={[styles.focusDigestBody, { color: colors.muted }]}>
                    {overlay.message?.body || ""}
                  </Text>
                  <View style={styles.focusDigestStats}>
                    <View
                      style={[
                        styles.focusDigestStat,
                        {
                          borderColor: colors.border,
                          backgroundColor: lightenColor(colors.card, isDarkTheme ? 0.08 : 0.2),
                        },
                      ]}
                    >
                      <Text style={[styles.focusDigestLabel, { color: colors.muted }]}>
                        {t("focusDigestStrongLabel")}
                      </Text>
                      <Text style={[styles.focusDigestValue, { color: colors.text }]}>
                        {overlay.message?.strong?.title || t("focusDigestMissing")}
                      </Text>
                      {overlay.message?.strong?.window && (
                        <Text style={[styles.focusDigestHint, { color: colors.muted }]}>
                          {overlay.message.strong.window}
                        </Text>
                      )}
                    </View>
                    <View
                      style={[
                        styles.focusDigestStat,
                        {
                          borderColor: colors.border,
                          backgroundColor: lightenColor(colors.card, isDarkTheme ? 0.04 : 0.12),
                        },
                      ]}
                    >
                      <Text style={[styles.focusDigestLabel, { color: colors.muted }]}>
                        {t("focusDigestWeakLabel")}
                      </Text>
                      <Text style={[styles.focusDigestValue, { color: colors.text }]}>
                        {overlay.message?.weak?.title || t("focusDigestMissing")}
                      </Text>
                      {overlay.message?.weak?.window && (
                        <Text style={[styles.focusDigestHint, { color: colors.muted }]}>
                          {overlay.message.weak.window}
                        </Text>
                      )}
                    </View>
                  </View>
                  <View style={styles.focusDigestButtons}>
                    <TouchableOpacity
                      style={[styles.focusDigestSecondary, { borderColor: colors.border }]}
                      onPress={handleFocusOverlayLater}
                    >
                      <Text style={[styles.focusDigestSecondaryText, { color: colors.muted }]}>
                        {t("focusDigestDismiss")}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[
                        styles.focusDigestPrimary,
                        {
                          backgroundColor: overlay.message?.targetId ? colors.text : colors.border,
                        },
                      ]}
                      disabled={!overlay.message?.targetId}
                      onPress={() =>
                        handleFocusOverlayConfirm(
                          overlay.message?.targetId,
                          overlay.message?.positive ? "digest_positive" : "digest_negative"
                        )
                      }
                    >
                      <Text
                        style={[
                          styles.focusDigestPrimaryText,
                          { color: overlay.message?.targetId ? colors.background : colors.muted },
                        ]}
                      >
                        {t("focusDigestButton")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </Modal>
        )}
        {isFeatureUnlockOverlay && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <View
                  style={[
                    styles.overlayDim,
                    { backgroundColor: overlayDimColor },
                  ]}
                />
                <View style={styles.featureUnlockWrapper}>
                  <FeatureUnlockCelebration
                    colors={colors}
                    payload={overlay.message}
                    t={t}
                    tamagotchiAnimations={tamagotchiAnimations}
                    onDismiss={dismissOverlay}
                  />
                </View>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "level" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <View style={styles.overlayFullScreen}>
              <TouchableWithoutFeedback onPress={dismissOverlay}>
                <View style={styles.overlayTouchable} />
              </TouchableWithoutFeedback>
              <LevelUpCelebration
                colors={colors}
                message={overlay.message}
                level={overlay.message}
                t={t}
                onSharePress={handleLevelSharePress}
              />
            </View>
          </Modal>
        )}
        {overlay?.type === "save" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={handleSaveOverlayPress}>
              <View style={styles.saveOverlay}>
                <View
                  style={[
                    styles.overlayDim,
                    { backgroundColor: overlayDimColor },
                  ]}
                />
                <CoinRainOverlay dropCount={16} />
                  <SaveCelebration
                    ref={saveCelebrationRef}
                    colors={colors}
                    t={t}
                    language={language}
                    payload={saveOverlayPayload}
                    goalCopy={saveOverlayGoalText}
                    goalPrefix={saveOverlayGoalPrefix}
                    coinReward={saveOverlayPayload?.coinReward}
                    playSound={playSound}
                    mascotHappySource={tamagotchiAnimations.happy}
                    progressStart={
                    Number.isFinite(saveOverlayPayload?.progressStart)
                      ? saveOverlayPayload.progressStart
                      : heroGoalProgressRatio
                  }
                  progressEnd={
                    Number.isFinite(saveOverlayPayload?.progressEnd)
                      ? saveOverlayPayload.progressEnd
                      : heroGoalProgressRatio
                  }
                  remainingActions={
                    Number.isFinite(saveOverlayPayload?.remainingTemptations)
                      ? saveOverlayPayload.remainingTemptations
                      : remainingGoalActions
                  }
                />
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "custom_temptation" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.saveOverlay}>
                <View
                  style={[
                    styles.overlayDim,
                    { backgroundColor: overlayDimColor },
                  ]}
                />
                <View
                  style={[
                    styles.customTemptationCard,
                    { backgroundColor: overlayCardBackground, borderColor: overlayBorderColor },
                  ]}
                >
                  <Image source={tamagotchiAnimations.follow} style={styles.customTemptationGif} />
                  <Text style={[styles.customTemptationText, { color: colors.text }]}>
                    {t("customTemptationAdded", { title: overlay.message || "" })}
                  </Text>
                </View>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "primary_temptation" && primaryTemptationOverlayItem && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <View
                  style={[
                    styles.overlayDim,
                    { backgroundColor: overlayDimColor },
                  ]}
                />
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.primaryTemptationOverlayCardContainer,
                      { backgroundColor: colors.background, borderColor: overlayBorderColor },
                    ]}
                  >
                    <Text style={[styles.primaryTemptationOverlayTitle, { color: colors.text }]}>
                      {t("customSpendTitle")}
                    </Text>
                    <TemptationCard
                      item={primaryTemptationOverlayItem}
                      language={language}
                      colors={colors}
                      t={t}
                      allowThinkAction={thinkingUnlocked}
                      currency={profile.currency || DEFAULT_PROFILE.currency}
                      stats={primaryTemptationOverlayStats}
                      feedback={primaryTemptationOverlayItem ? cardFeedback[primaryTemptationOverlayItem.id] : null}
                      titleOverride={primaryTemptationOverlayTitle}
                      descriptionOverride={primaryTemptationOverlayDescription}
                      goalLabel={primaryTemptationOverlayGoalLabel}
                      isPrimaryTemptation={primaryTemptationOverlayItem.id === primaryTemptationId}
                      onAction={(type, item) => handlePrimaryTemptationOverlayAction(type, item)}
                      onToggleEdit={null}
                      cardStyle={styles.primaryTemptationCard}
                    />
                    <TouchableOpacity
                      style={[styles.primaryTemptationDismiss, { borderColor: colors.border }]}
                      onPress={dismissOverlay}
                    >
                      <Text style={[styles.primaryTemptationDismissText, { color: colors.muted }]}>
                        {t("profileCancel")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "reward" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <RewardCelebration
                  colors={colors}
                  message={overlay.message}
                  t={t}
                  mascotHappySource={tamagotchiAnimations.happy}
                />
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "daily_reward" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <DailyRewardCelebration
                  colors={colors}
                  payload={overlay.message}
                  t={t}
                />
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "focus_reward" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.focusRewardCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <View style={styles.focusRewardIconRow}>
                      <Image source={HEALTH_COIN_TIERS[0].asset} style={styles.focusRewardCoin} />
                      <Text style={[styles.focusRewardAmount, { color: colors.text }]}>
                        +{overlay.message?.amount || FOCUS_VICTORY_REWARD}
                      </Text>
                    </View>
                    <Text style={[styles.focusRewardTitle, { color: colors.text }]}>
                      {overlay.message?.title || t("focusRewardTitle")}
                    </Text>
                    <Text style={[styles.focusRewardBody, { color: colors.muted }]}>
                      {overlay.message?.body || ""}
                    </Text>
                    <TouchableOpacity
                      style={[styles.focusRewardButton, { borderColor: colors.text }]}
                      onPress={dismissOverlay}
                    >
                      <Text style={[styles.focusRewardButtonText, { color: colors.text }]}>
                        {t("profileOk") || "ÐžÐº"}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "health" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <HealthCelebration colors={colors} payload={overlay.message} t={t} language={language} />
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "goal_complete" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <View style={styles.overlayFullScreen}>
              <Pressable style={StyleSheet.absoluteFillObject} onPress={dismissOverlay} />
              <View style={styles.overlayFullScreen} pointerEvents="box-none">
                <GoalCelebration
                  colors={colors}
                  payload={overlay.message}
                  t={t}
                  mascotHappySource={tamagotchiAnimations.happy}
                  onClose={dismissOverlay}
                />
              </View>
            </View>
          </Modal>
        )}
        {overlay?.type === "impulse_alert" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <View
                  style={[
                    styles.overlayDim,
                    { backgroundColor: overlayDimColor },
                  ]}
                />
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.impulseAlertCard,
                      { backgroundColor: overlayCardBackground, borderColor: overlayBorderColor },
                    ]}
                  >
                    <View
                      style={[
                        styles.impulseAlertGlow,
                        { backgroundColor: isDarkTheme ? "#FFC857" : "#FF8F5A" },
                      ]}
                    />
                    <View style={styles.impulseAlertContent}>
                      <View style={styles.impulseAlertHeader}>
                        <View
                          style={[
                            styles.impulseAlertBadge,
                            { backgroundColor: colors.background, borderColor: colors.border },
                          ]}
                        >
                          <Text style={[styles.impulseAlertBadgeText, { color: colors.muted }]}>
                            {t("impulseAlertBadgeLabel")}
                          </Text>
                        </View>
                        <Text style={styles.impulseAlertEmoji}>âš¡ï¸</Text>
                      </View>
                      <Text style={[styles.impulseAlertTitle, { color: colors.text }]}>
                        {impulseAlertPayload?.title || t("impulseAlertTitle")}
                      </Text>
                      <Text style={[styles.impulseAlertBody, { color: colors.muted }]}>
                        {impulseAlertPayload?.body || ""}
                      </Text>
                      {(impulseAlertPayload?.window || impulseAlertPayload?.amountLabel) && (
                        <View style={styles.impulseAlertStats}>
                          {impulseAlertPayload?.window ? (
                            <View style={styles.impulseAlertStat}>
                              <Text style={[styles.impulseAlertStatLabel, { color: colors.muted }]}>
                                {t("impulseAlertWindowLabel")}
                              </Text>
                              <Text style={[styles.impulseAlertStatValue, { color: colors.text }]}>
                                {impulseAlertPayload.window}
                              </Text>
                            </View>
                          ) : null}
                          {impulseAlertPayload?.amountLabel ? (
                            <View style={styles.impulseAlertStat}>
                              <Text style={[styles.impulseAlertStatLabel, { color: colors.muted }]}>
                                {t("impulseAlertAmountLabel")}
                              </Text>
                              <Text style={[styles.impulseAlertStatValue, { color: colors.text }]}>
                                {impulseAlertPayload.amountLabel}
                              </Text>
                            </View>
                          ) : null}
                        </View>
                      )}
                      {impulseAlertPayload?.moodLine ? (
                        <View
                          style={[
                            styles.impulseAlertMoodCard,
                            {
                              backgroundColor: isDarkTheme
                                ? "rgba(255,255,255,0.08)"
                                : "rgba(17,17,17,0.04)",
                              borderColor: isDarkTheme ? "rgba(255,255,255,0.12)" : "rgba(0,0,0,0.05)",
                            },
                          ]}
                        >
                          <Text style={[styles.impulseAlertMood, { color: colors.text }]}>
                            {impulseAlertPayload.moodLine}
                          </Text>
                        </View>
                      ) : null}
                      <TouchableOpacity
                        style={[styles.impulseAlertButton, { backgroundColor: colors.text }]}
                        onPress={dismissOverlay}
                        activeOpacity={0.9}
                      >
                        <Text style={[styles.impulseAlertButtonText, { color: colors.background }]}>
                          {t("impulseAlertButtonLabel")}
                        </Text>
                        <Text style={[styles.impulseAlertButtonIcon, { color: colors.background }]}>
                          â†’
                        </Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}

        <Modal
          visible={goalLinkPrompt.visible}
          transparent
          animationType="fade"
          statusBarTranslucent
        >
          <TouchableWithoutFeedback onPress={closeGoalLinkPrompt}>
            <View style={[styles.priceModalBackdrop, modalKeyboardPaddingStyle]}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View style={[styles.goalModalCard, { backgroundColor: colors.card }] }>
                  <Text style={[styles.goalModalTitle, { color: colors.text }]}>
                    {t("goalAssignPromptTitle")}
                  </Text>
                  {goalLinkPrompt.item && (
                    <Text style={[styles.goalModalSubtitle, { color: colors.muted }]}>
                      {t("goalAssignPromptSubtitle", {
                        title: resolveTemptationTitle(
                          goalLinkPrompt.item,
                          language,
                          titleOverrides[goalLinkPrompt.item.id]
                        ),
                      })}
                    </Text>
                  )}
                  <ScrollView style={{ maxHeight: 360 }}>
                    {goalSelectionList.map((goal) => {
                      const active = goalLinkCurrentGoalId === goal.id;
                      const currentLocal = formatCurrency(
                        convertToCurrency(goal.savedUSD || 0, profile.currency || DEFAULT_PROFILE.currency),
                        profile.currency || DEFAULT_PROFILE.currency
                      );
                      const targetLocal = formatCurrency(
                        convertToCurrency(goal.targetUSD || 0, profile.currency || DEFAULT_PROFILE.currency),
                        profile.currency || DEFAULT_PROFILE.currency
                      );
                      return (
                        <TouchableOpacity
                          key={goal.id}
                          style={[
                            styles.goalOptionButton,
                            {
                              borderColor: colors.border,
                              backgroundColor: active ? colors.text : "transparent",
                            },
                          ]}
                          onPress={() => handleGoalLinkSelect(goal.id)}
                        >
                          <Text
                            style={[
                              styles.goalOptionTitle,
                              { color: active ? colors.background : colors.text },
                            ]}
                          >
                            {goal.title}
                          </Text>
                          <Text
                            style={[
                              styles.goalOptionSubtitle,
                              { color: active ? colors.background : colors.muted },
                            ]}
                          >
                            {t("wishlistProgress", { current: currentLocal, target: targetLocal })}
                          </Text>
                        </TouchableOpacity>
                      );
                    })}
                  </ScrollView>
                  {goalLinkPrompt.intent !== "save" && goalLinkPrompt.item && (
                    <TouchableOpacity
                      style={styles.goalPickerReset}
                      onPress={() => {
                        const templateId = resolveTemptationTemplateId(goalLinkPrompt.item);
                        assignTemptationGoal(templateId || goalLinkPrompt.item.id, null);
                        closeGoalLinkPrompt();
                      }}
                    >
                      <Text style={[styles.goalPickerResetText, { color: colors.muted }]}>
                        {t("goalAssignClear")}
                      </Text>
                    </TouchableOpacity>
                  )}
                  <TouchableOpacity onPress={closeGoalLinkPrompt}>
                    <Text style={[styles.priceModalCancel, { color: colors.muted }]}>
                      {t("priceEditCancel")}
                    </Text>
                  </TouchableOpacity>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>

        <Modal
          visible={goalTemptationPrompt.visible}
          transparent
          animationType="fade"
          statusBarTranslucent
        >
          <TouchableWithoutFeedback onPress={closeGoalTemptationPrompt}>
            <View style={[styles.priceModalBackdrop, modalKeyboardPaddingStyle]}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View style={[styles.goalModalCard, { backgroundColor: colors.card }] }>
                  <Text style={[styles.goalModalTitle, { color: colors.text }]}>
                    {t("goalAssignTemptationTitle")}
                  </Text>
                  <Text style={[styles.goalModalSubtitle, { color: colors.muted }]}>
                    {t("goalAssignTemptationSubtitle", {
                      goal: goalTemptationPrompt.wish?.title || "",
                    })}
                  </Text>
                  <ScrollView style={{ maxHeight: 360 }}>
                    {temptations.map((template) => {
                      const templateTitle = resolveTemptationTitle(
                        template,
                        language,
                        titleOverrides[template.id]
                      );
                      const assignedGoalId = temptationGoalMap[template.id];
                      const isActive =
                        assignedGoalId && goalTemptationPrompt.wish
                          ? assignedGoalId === goalTemptationPrompt.wish.id
                          : false;
                      const assignedLabel = assignedGoalId
                        ? getWishTitleById(assignedGoalId)
                        : t("goalAssignNone");
                      return (
                        <TouchableOpacity
                          key={template.id}
                          style={[
                            styles.goalOptionButton,
                            {
                              borderColor: colors.border,
                              backgroundColor: isActive ? colors.text : "transparent",
                            },
                          ]}
                          onPress={() => handleGoalTemptationAssign(template.id)}
                        >
                          <Text
                            style={[
                              styles.goalOptionTitle,
                              { color: isActive ? colors.background : colors.text },
                            ]}
                          >
                            {templateTitle}
                          </Text>
                          <Text
                            style={[
                              styles.goalOptionSubtitle,
                              { color: isActive ? colors.background : colors.muted },
                            ]}
                          >
                            {assignedLabel}
                          </Text>
                        </TouchableOpacity>
                      );
                    })}
                  </ScrollView>
                  <TouchableOpacity onPress={closeGoalTemptationPrompt}>
                    <Text style={[styles.priceModalCancel, { color: colors.muted }]}>
                      {t("priceEditCancel")}
                    </Text>
                  </TouchableOpacity>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>

        <Modal
          visible={streakRecoveryPrompt.visible}
          transparent
          animationType="fade"
          statusBarTranslucent
        >
          <TouchableWithoutFeedback onPress={handleStreakRecoveryDecline}>
            <View style={[styles.priceModalBackdrop, modalKeyboardPaddingStyle]}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View style={[styles.streakRecoveryCard, { backgroundColor: colors.card }]}>
                  <Text style={[styles.streakRecoveryTitle, { color: colors.text }]}>
                    {t("streakRecoveryTitle")}
                  </Text>
                  <Text style={[styles.streakRecoveryBody, { color: colors.muted }]}>
                    {t("streakRecoveryBody", { coins: streakRecoveryPrompt.coinCost })}
                  </Text>
                  {Boolean(streakRecoveryPrompt.coinCost) && (
                    <View style={styles.streakRecoveryCoinRow}>
                      {BLUE_HEALTH_COIN_ASSET ? (
                        <>
                          {Array.from({
                            length: Math.min(streakRecoveryPrompt.coinCost || 0, 6),
                          }).map((_, index) => (
                            <Image
                              key={`recovery-coin-${index}`}
                              source={BLUE_HEALTH_COIN_ASSET}
                              style={styles.streakRecoveryCoinIcon}
                            />
                          ))}
                          {streakRecoveryPrompt.coinCost > 6 ? (
                            <Text style={[styles.streakRecoveryCoinOverflow, { color: colors.muted }]}>
                              +{streakRecoveryPrompt.coinCost - 6}
                            </Text>
                          ) : null}
                        </>
                      ) : (
                        <Text style={[styles.streakRecoveryCoinOverflow, { color: colors.text }]}>
                          Ã—{streakRecoveryPrompt.coinCost}
                        </Text>
                      )}
                    </View>
                  )}
                  {Boolean(streakRecoveryPrompt.errorMessage) && (
                    <Text style={styles.streakRecoveryErrorText}>
                      {streakRecoveryPrompt.errorMessage}
                    </Text>
                  )}
                  <View style={styles.streakRecoveryActions}>
                    <TouchableOpacity
                      style={[
                        styles.streakRecoveryButton,
                        styles.streakRecoveryButtonSecondary,
                        { borderColor: colors.border },
                      ]}
                      onPress={handleStreakRecoveryDecline}
                    >
                      <Text style={[styles.streakRecoveryButtonText, { color: colors.text }]}>
                        {t("streakRecoveryDecline")}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[
                        styles.streakRecoveryButton,
                        styles.streakRecoveryButtonPrimary,
                        { backgroundColor: colors.text },
                      ]}
                      onPress={handleStreakRecoveryConfirm}
                    >
                      <Text style={[styles.streakRecoveryButtonText, { color: colors.background }]}>
                        {t("streakRecoveryConfirm", { coins: streakRecoveryPrompt.coinCost })}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>

        <Modal
          visible={goalEditorPrompt.visible}
          transparent
          animationType="fade"
          statusBarTranslucent
        >
          <TouchableWithoutFeedback onPress={closeGoalEditorPrompt}>
            <View style={[styles.priceModalBackdrop, modalKeyboardPaddingStyle]}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View style={[styles.priceModalCard, { backgroundColor: colors.card }] }>
                  <Text style={[styles.priceModalTitle, { color: colors.text }]}>
                    {t("goalEditModalTitle")}
                  </Text>
                  <Text style={[styles.priceModalLabel, { color: colors.muted, marginTop: 0 }]}>
                    {t("goalEditNameLabel")}
                  </Text>
                  <TextInput
                    style={[
                      styles.priceModalInput,
                      {
                        borderColor: colors.border,
                        color: colors.text,
                        backgroundColor: colors.card,
                      },
                    ]}
                    value={goalEditorPrompt.name}
                    onChangeText={handleGoalEditorNameChange}
                    placeholder={t("goalEditNameLabel")}
                    placeholderTextColor={colors.muted}
                  />
                  <Text style={[styles.priceModalLabel, { color: colors.muted }]}>
                    {t("goalEditTargetLabel")}
                  </Text>
                  <TextInput
                    style={[
                      styles.priceModalInput,
                      {
                        borderColor: colors.border,
                        color: colors.text,
                        backgroundColor: colors.card,
                      },
                    ]}
                    value={goalEditorPrompt.target}
                    onChangeText={handleGoalEditorTargetChange}
                    placeholder={t("goalEditTargetLabel")}
                    placeholderTextColor={colors.muted}
                    keyboardType="numeric"
                  />
                  <Text style={[styles.priceModalLabel, { color: colors.muted }]}>
                    {t("goalEditEmojiLabel")}
                  </Text>
                  <TextInput
                    style={[
                      styles.priceModalInput,
                      {
                        borderColor: colors.border,
                        color: colors.text,
                        backgroundColor: colors.card,
                      },
                    ]}
                    value={goalEditorPrompt.emoji}
                    onChangeText={handleGoalEditorEmojiChange}
                  placeholder={t("goalEditEmojiLabel")}
                  placeholderTextColor={colors.muted}
                  selectTextOnFocus
                  maxLength={2}
                />
                  <View style={styles.priceModalButtons}>
                    <TouchableOpacity
                      style={[styles.priceModalPrimary, { backgroundColor: colors.text }]}
                      onPress={saveGoalEditorPrompt}
                    >
                      <Text style={[styles.priceModalPrimaryText, { color: colors.background }]}>
                        {t("goalEditSave")}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[styles.priceModalSecondary, { borderColor: colors.border }]}
                      onPress={closeGoalEditorPrompt}
                    >
                      <Text style={[styles.priceModalSecondaryText, { color: colors.muted }]}>
                        {t("goalEditCancel")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>

        <Modal
          visible={goalRenewalPromptVisible}
          transparent
          animationType="fade"
          statusBarTranslucent
        >
          <TouchableWithoutFeedback onPress={handleGoalRenewalLater}>
            <View style={styles.goalRenewalBackdrop}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View
                  style={[
                    styles.goalRenewalCard,
                    { backgroundColor: colors.card, borderColor: colors.border },
                  ]}
                >
                  <Text style={[styles.goalRenewalTitle, { color: colors.text }]}>
                    {t("goalRenewalTitle")}
                  </Text>
                  <Text style={[styles.goalRenewalSubtitle, { color: colors.muted }]}>
                    {t("goalRenewalSubtitle")}
                  </Text>
                  <View style={styles.goalRenewalActions}>
                    <TouchableOpacity
                      style={[styles.goalRenewalSecondary, { borderColor: colors.border }]}
                      onPress={handleGoalRenewalLater}
                    >
                      <Text style={[styles.goalRenewalSecondaryText, { color: colors.muted }]}>
                        {t("goalRenewalLater")}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[styles.goalRenewalPrimary, { backgroundColor: colors.text }]}
                      onPress={handleGoalRenewalStart}
                    >
                      <Text style={[styles.goalRenewalPrimaryText, { color: colors.background }]}>
                        {t("goalRenewalCreate")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>

        <ImageSourceSheet
          visible={showImageSourceSheet}
          colors={colors}
          t={t}
          onClose={closeImagePickerSheet}
          onSelect={handleImageSourceChoice}
        />
        <Modal
          visible={categoryPrompt.visible}
          transparent
          animationType="fade"
          statusBarTranslucent
        >
          <TouchableWithoutFeedback onPress={closeCategoryPrompt}>
            <View style={[styles.priceModalBackdrop, modalKeyboardPaddingStyle]}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View style={[styles.priceModalCard, { backgroundColor: colors.card }]}>
                  <Text style={[styles.priceModalTitle, { color: colors.text }]}>
                    {t("categoryPromptTitle")}
                  </Text>
                  <Text style={[styles.priceModalLabel, { color: colors.muted, marginTop: 0 }]}>
                    {t("categoryPromptSubtitle")}
                  </Text>
                  <ImpulseCategorySelector
                    value={categoryPromptSelection || DEFAULT_IMPULSE_CATEGORY}
                    onChange={setCategoryPromptSelection}
                    colors={colors}
                    language={language}
                    horizontal
                    visibleCount={5}
                  />
                  <View style={styles.priceModalButtons}>
                    <TouchableOpacity
                      style={[styles.priceModalPrimary, { backgroundColor: colors.text }]}
                      onPress={handleCategoryPromptConfirm}
                    >
                      <Text style={[styles.priceModalPrimaryText, { color: colors.background }]}>
                        {t("categoryPromptConfirm")}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[styles.priceModalSecondary, { borderColor: colors.border }]}
                      onPress={closeCategoryPrompt}
                    >
                      <Text style={[styles.priceModalSecondaryText, { color: colors.muted }]}>
                        {t("categoryPromptCancel")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>
        <Modal
          visible={addCategoryModalVisible}
          transparent
          animationType="fade"
          statusBarTranslucent
        >
          <TouchableWithoutFeedback onPress={closeAddCategoryModal}>
            <View style={[styles.priceModalBackdrop, modalKeyboardPaddingStyle]}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View style={[styles.priceModalCard, { backgroundColor: colors.card }]}>
                  <Text style={[styles.priceModalTitle, { color: colors.text }]}>
                    {t("addCategoryModalTitle")}
                  </Text>
                  <Text style={[styles.priceModalLabel, { color: colors.muted, marginTop: 0 }]}>
                    {t("addCategoryNameLabel")}
                  </Text>
                  <TextInput
                    style={[
                      styles.priceModalInput,
                      {
                        borderColor: colors.border,
                        color: colors.text,
                        backgroundColor: colors.card,
                      },
                    ]}
                    value={addCategoryName}
                    onChangeText={(text) => {
                      setAddCategoryName(text);
                      setAddCategoryError(false);
                    }}
                    placeholder={t("addCategoryNameLabel")}
                    placeholderTextColor={colors.muted}
                  />
                  <Text style={[styles.priceModalLabel, { color: colors.muted }]}>
                    {t("addCategoryEmojiLabel")}
                  </Text>
                  <TextInput
                    style={[
                      styles.priceModalInput,
                      {
                        borderColor: colors.border,
                        color: colors.text,
                        backgroundColor: colors.card,
                      },
                    ]}
                    value={addCategoryEmoji}
                    onChangeText={(text) => setAddCategoryEmoji(limitEmojiInput(text))}
                    placeholder={t("addCategoryEmojiLabel")}
                    placeholderTextColor={colors.muted}
                    selectTextOnFocus
                    maxLength={2}
                  />
                  {addCategoryError && (
                    <Text style={[styles.priceModalDeleteText, { color: "#E15555" }]}>
                      {t("addCategoryError")}
                    </Text>
                  )}
                  <View style={styles.priceModalButtons}>
                    <TouchableOpacity
                      style={[styles.priceModalPrimary, { backgroundColor: colors.text }]}
                      onPress={handleAddCategorySave}
                    >
                      <Text style={[styles.priceModalPrimaryText, { color: colors.background }]}>
                        {t("addCategorySave")}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[styles.priceModalSecondary, { borderColor: colors.border }]}
                      onPress={closeAddCategoryModal}
                    >
                      <Text style={[styles.priceModalSecondaryText, { color: colors.muted }]}>
                        {t("addCategoryCancel")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>
        <SpendConfirmSheet
          visible={spendPrompt.visible}
          item={spendPrompt.item}
          currency={profile.currency || DEFAULT_PROFILE.currency}
          language={language}
          onCancel={closeSpendPrompt}
          onConfirm={handleSpendConfirm}
          colors={colors}
          t={t}
          theme={theme}
        />
        <StormOverlay
          visible={stormActive}
          t={t}
          catCrySource={tamagotchiAnimations.cry}
          colors={colors}
          onDismiss={dismissStormEffect}
        />
      </SafeAreaView>
        </View>
      </TouchableWithoutFeedback>
    </SavingsProvider>
  );
}

function App() {
  return (
    <SafeAreaProvider>
      <AppContent />
    </SafeAreaProvider>
  );
}

export default Sentry.wrap(App);

const StatusGlass = React.memo(({ height, colors, theme, blurAvailable = false, solid = false }) => {
  const gradientId = useMemo(() => `status-glass-${Math.random().toString(36).slice(2, 10)}`, []);
  const baseColor = colors?.background || "#fff";
  const isDarkTheme = theme === "dark";
  const tintedBase = isDarkTheme
    ? blendColors(baseColor, "#000000", 0.35)
    : blendColors(baseColor, "#ffffff", 0.45);
  const highlightBase = isDarkTheme ? "#000000" : "#ffffff";
  const highlight = colorWithAlpha(highlightBase, isDarkTheme ? 0.3 : 0.32);
  const softCore = colorWithAlpha(tintedBase, isDarkTheme ? 0.45 : 0.38);
  const fadeOut = colorWithAlpha(baseColor, 0);
  const borderColor = colorWithAlpha(colors?.border || tintedBase, isDarkTheme ? 0.35 : 0.18);
  const borderOffset = solid ? StyleSheet.hairlineWidth : 26;
  const borderPosition = Math.max(0, height - borderOffset);
  if (solid) {
    return (
      <View
        pointerEvents="none"
        style={[styles.statusGlass, { height, backgroundColor: baseColor }]}
      >
        <View style={[styles.statusGlassBorder, { borderColor, top: borderPosition }]} />
      </View>
    );
  }
  const overlay = (
    <Svg style={StyleSheet.absoluteFill} pointerEvents="none">
      <Defs>
        <SvgLinearGradient id={gradientId} x1="0" y1="0" x2="0" y2="1">
          <SvgStop offset="0%" stopColor={highlight} />
          <SvgStop offset="55%" stopColor={softCore} />
          <SvgStop offset="100%" stopColor={fadeOut} />
        </SvgLinearGradient>
      </Defs>
      <SvgRect x="0" y="0" width="100%" height="100%" fill={`url(#${gradientId})`} />
    </Svg>
  );
  const border = <View style={[styles.statusGlassBorder, { borderColor, top: borderPosition }]} />;
  if (blurAvailable) {
    return (
      <View pointerEvents="none" style={[styles.statusGlass, { height }]}>
        {Platform.OS === "android" && AndroidBlurView ? (
          <AndroidBlurView
            blurType={theme === "dark" ? "dark" : "light"}
            blurAmount={4}
            reducedTransparencyFallbackColor={isDarkTheme ? "#0B0B0B" : "#F2F2F2"}
            style={StyleSheet.absoluteFill}
          />
        ) : (
          <ExpoBlurView
            tint={theme === "dark" ? "dark" : "extraLight"}
            intensity={18}
            experimentalBlurMethod={Platform.OS === "android" ? "dimezisBlurView" : undefined}
            style={StyleSheet.absoluteFill}
          />
        )}
        {overlay}
        {border}
      </View>
    );
  }
  return (
    <View pointerEvents="none" style={[styles.statusGlass, { height }]}>
      {overlay}
      {border}
    </View>
  );
});

const TYPOGRAPHY = {
  logo: {
    fontFamily: INTER_FONTS.extraBold,
    fontSize: scaleFontSize(44),
    letterSpacing: scaleLetterSpacing(-0.5),
  },
  display: {
    fontFamily: INTER_FONTS.bold,
    fontSize: scaleFontSize(34),
    letterSpacing: scaleLetterSpacing(-0.2),
  },
  blockTitle: {
    fontFamily: INTER_FONTS.bold,
    fontSize: scaleFontSize(24),
    letterSpacing: scaleLetterSpacing(-0.2),
  },
  body: {
    fontFamily: INTER_FONTS.regular,
    fontSize: scaleFontSize(15),
    lineHeight: scaleFontSize(20),
  },
  secondary: {
    fontFamily: INTER_FONTS.light,
    fontSize: scaleFontSize(12),
    lineHeight: scaleFontSize(16),
  },
  cta: {
    fontFamily: INTER_FONTS.semiBold,
    fontSize: scaleFontSize(14),
    letterSpacing: scaleLetterSpacing(CTA_LETTER_SPACING),
  },
};

const createBodyText = (overrides = {}) => ({ ...TYPOGRAPHY.body, ...scaleTypographyOverrides(overrides) });
const createSecondaryText = (overrides = {}) => ({
  ...TYPOGRAPHY.secondary,
  ...scaleTypographyOverrides(overrides),
});
const createCtaText = (overrides = {}) => ({ ...TYPOGRAPHY.cta, ...scaleTypographyOverrides(overrides) });

const styles = StyleSheet.create({
  appBackground: {
    flex: 1,
  },
  appShell: {
    flex: 1,
  },
  screenWrapper: {
    flex: 1,
  },
  backGestureWrapper: {
    ...StyleSheet.absoluteFillObject,
    alignItems: "flex-end",
  },
  backGestureEdge: {
    width: BACK_GESTURE_EDGE_WIDTH,
    height: "100%",
  },
  statusGlass: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    overflow: "hidden",
    zIndex: 10,
  },
  statusGlassBorder: {
    position: "absolute",
    left: 0,
    right: 0,
    borderBottomWidth: StyleSheet.hairlineWidth,
  },
  container: {
    flex: 1,
    paddingHorizontal: BASE_HORIZONTAL_PADDING,
    paddingTop: 24,
    position: "relative",
  },
  screenLoading: {
    flex: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  feedList: {
    marginHorizontal: -BASE_HORIZONTAL_PADDING,
    overflow: "visible",
  },
  feedListContent: {
    paddingTop: 4,
    paddingBottom: 160,
    paddingHorizontal: BASE_HORIZONTAL_PADDING,
  },
  frequencySectionHeader: {
    marginTop: 16,
    marginBottom: 8,
    paddingVertical: 10,
    paddingHorizontal: 14,
    borderRadius: 16,
    borderWidth: 1,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  frequencySectionHeaderText: {
    flexDirection: "row",
    alignItems: "center",
  },
  frequencySectionTitle: {
    fontSize: 15,
    fontWeight: "600",
  },
  frequencySectionCount: {
    fontSize: 13,
    fontWeight: "500",
    marginLeft: 8,
  },
  frequencySectionToggle: {
    flexDirection: "row",
    alignItems: "center",
  },
  frequencySectionToggleLabel: {
    fontSize: 13,
    fontWeight: "600",
  },
  frequencySectionToggleArrow: {
    fontSize: 14,
    fontWeight: "700",
    marginLeft: 6,
  },
  feedHero: {
    paddingBottom: 12,
  },
  feedTemptationHeader: {
    marginTop: 12,
    marginBottom: 6,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  feedTemptationTitle: {
    fontSize: 18,
    fontWeight: "700",
  },
  feedTemptationAddButton: {
    width: 30,
    height: 30,
    borderRadius: 15,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  feedTemptationAddIcon: {
    fontSize: 18,
    fontWeight: "700",
    lineHeight: 20,
  },
  feedHeroTop: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-start",
  },
  moodGradientBlock: {
    position: "relative",
    overflow: "hidden",
  },
  moodGradientOverlay: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.55,
    transform: [{ rotate: "-10deg" }],
  },
  heroMoodGradient: {
    flex: 1,
    width: "100%",
    borderRadius: 28,
    padding: 18,
    paddingBottom: 20,
    position: "relative",
    overflow: "hidden",
  },
  moodBadge: {
    alignSelf: "flex-start",
    paddingHorizontal: 14,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "rgba(255,255,255,0.85)",
    marginTop: 16,
  },
  moodBadgeText: {
    ...createCtaText({ fontSize: 13, textTransform: "uppercase" }),
  },
  moodDetailsBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.5)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  moodDetailsCard: {
    width: "100%",
    borderRadius: 32,
    padding: 24,
    alignItems: "center",
    gap: 12,
  },
  moodDetailsLabel: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 20,
    textAlign: "center",
  },
  moodDetailsDescription: {
    ...createBodyText({ fontSize: 16, textAlign: "center", lineHeight: 22 }),
  },
  moodDetailsButton: {
    marginTop: 12,
    paddingHorizontal: 24,
    paddingVertical: 10,
    borderRadius: 999,
    borderWidth: 1,
  },
  moodDetailsButtonText: {
    ...createCtaText({ textTransform: "uppercase" }),
  },
  baselinePromptBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.45)",
    padding: 24,
    justifyContent: "center",
  },
  baselinePromptCard: {
    borderRadius: 28,
    borderWidth: 1,
    padding: 20,
    gap: 12,
  },
  baselinePromptTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 22,
  },
  baselinePromptSubtitle: {
    ...createBodyText({ fontSize: 15, lineHeight: 22 }),
  },
  baselinePromptDismiss: {
    alignItems: "center",
    marginTop: 4,
  },
  baselinePromptDismissText: {
    ...createCtaText({ fontSize: 13 }),
  },
  heroMascotRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  heroMascotContainer: {
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    marginTop: 52,
    width: HERO_MASCOT_SIZE,
    height: HERO_MASCOT_SIZE,
  },
  heroTextWrap: {
    flex: 1,
    paddingRight: 6,
  },
  appName: {
    ...TYPOGRAPHY.logo,
  },
  heroTagline: {
    ...TYPOGRAPHY.body,
    marginTop: 4,
  },
  almiMascotWrap: {
    width: HERO_MASCOT_SIZE,
    height: HERO_MASCOT_SIZE,
    borderRadius: 28,
    backgroundColor: "rgba(255,255,255,0.75)",
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden",
    borderWidth: 1,
    borderColor: "rgba(255,255,255,0.5)",
  },
  almiMascotImage: {
    width: "120%",
    height: "120%",
  },
  mascotBubbleWrap: {
    position: "absolute",
    bottom: HERO_MASCOT_SIZE + 8,
    left: 0,
    right: 0,
    alignItems: "center",
    marginBottom: -2,
  },
  mascotBubble: {
    minHeight: 34,
    paddingHorizontal: 10,
    paddingVertical: 7,
    borderRadius: 16,
    borderWidth: 1,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.25,
    shadowRadius: 10,
    elevation: 4,
    justifyContent: "center",
  },
  mascotBubbleText: {
    ...createBodyText({ fontSize: 10, textAlign: "center", lineHeight: 13 }),
    fontWeight: "600",
    paddingTop: 2,
    paddingBottom: 1,
  },
  mascotBubbleTail: {
    position: "absolute",
    bottom: -6,
    left: "50%",
    width: 12,
    height: 12,
    transform: [{ translateX: -6 }, { rotate: "45deg" }],
    borderRadius: 3,
  },
  skinPickerControl: {
    position: "absolute",
    top: 8,
    right: 8,
    alignItems: "flex-end",
    gap: 6,
  },
  skinPickerButton: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 14,
    borderWidth: 1,
    shadowColor: "rgba(0,0,0,0.25)",
    shadowOpacity: 0.25,
    shadowOffset: { width: 0, height: 2 },
    shadowRadius: 4,
    elevation: 3,
  },
  skinPickerButtonLocked: {
    opacity: 0.7,
  },
  skinPickerIcon: {
    fontSize: 16,
  },
  skinPickerLockBadge: {
    position: "absolute",
    top: -6,
    right: -6,
    borderRadius: 999,
    paddingHorizontal: 4,
    paddingVertical: 2,
    borderWidth: 1,
  },
  skinPickerLockText: {
    fontSize: 10,
  },
  skinPickerLockedLabel: {
    ...createBodyText({ fontSize: 11 }),
    fontWeight: "600",
  },
  skinPickerBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.55)",
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 20,
    paddingVertical: 20,
  },
  skinPickerCard: {
    width: "100%",
    maxWidth: 380,
    borderRadius: 28,
    paddingVertical: 16,
    paddingHorizontal: 18,
    borderWidth: 1,
    gap: 8,
  },
  skinPickerTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 20,
  },
  skinPickerSubtitle: {
    ...createBodyText({ fontSize: 15 }),
  },
  skinPickerList: {
    paddingVertical: 6,
    paddingHorizontal: 4,
  },
  skinUnlockCard: {
    borderWidth: 1,
    borderRadius: 20,
    padding: 16,
    marginBottom: 16,
    gap: 10,
  },
  skinUnlockTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 17,
  },
  skinUnlockSubtitle: {
    ...createBodyText({ fontSize: 14 }),
  },
  skinUnlockButton: {
    borderRadius: 999,
    paddingVertical: 12,
    paddingHorizontal: 16,
    alignItems: "center",
  },
  skinUnlockButtonText: {
    ...createCtaText({ fontSize: 14, textTransform: "none" }),
  },
  featureUnlockWrapper: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    padding: 24,
    justifyContent: "center",
    alignItems: "center",
  },
  featureUnlockCard: {
    width: "100%",
    maxWidth: 420,
    borderRadius: 32,
    padding: 24,
    borderWidth: 1,
  },
  featureUnlockHeader: {
    flexDirection: "row",
    alignItems: "center",
  },
  featureUnlockCat: {
    width: 72,
    height: 72,
    marginRight: 16,
    resizeMode: "contain",
  },
  featureUnlockMessage: {
    flex: 1,
    fontSize: 18,
    fontWeight: "600",
    lineHeight: 24,
  },
  featureUnlockSection: {
    marginTop: 20,
    borderWidth: 1,
    borderRadius: 22,
    padding: 16,
  },
  featureUnlockSectionLabel: {
    fontSize: 12,
    textTransform: "uppercase",
    letterSpacing: 0.8,
  },
  featureUnlockSectionTitle: {
    fontSize: 16,
    fontWeight: "600",
    marginTop: 6,
  },
  featureUnlockSectionDescription: {
    fontSize: 14,
    lineHeight: 20,
    marginTop: 6,
  },
  featureUnlockIllustration: {
    marginTop: 12,
    borderRadius: 20,
    borderWidth: 1,
    padding: 16,
  },
  featureUnlockTabs: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginTop: 14,
  },
  featureUnlockTab: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 10,
    marginHorizontal: 4,
    alignItems: "center",
  },
  featureUnlockTabIcon: {
    fontSize: 16,
  },
  featureUnlockPreviewCard: {
    borderWidth: 1,
    borderRadius: 20,
    padding: 16,
    marginBottom: 12,
  },
  featureUnlockPreviewBadge: {
    alignSelf: "flex-start",
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 999,
  },
  featureUnlockPreviewBadgeText: {
    fontSize: 12,
    fontWeight: "700",
    color: "#1F1300",
  },
  featureUnlockPreviewCat: {
    position: "absolute",
    top: 10,
    right: 10,
    width: 46,
    height: 46,
    resizeMode: "contain",
  },
  featureUnlockPreviewLines: {
    marginTop: 10,
  },
  featureUnlockPreviewLine: {
    height: 8,
    borderRadius: 4,
    marginTop: 6,
  },
  featureUnlockModalPreview: {
    borderRadius: 24,
    borderWidth: 1,
    padding: 18,
    alignItems: "stretch",
  },
  featureUnlockModalBadge: {
    alignSelf: "flex-start",
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 999,
    marginBottom: 12,
  },
  featureUnlockModalBadgeText: {
    fontSize: 13,
    fontWeight: "600",
    color: "#1F1300",
  },
  featureUnlockModalButton: {
    marginTop: 18,
    borderRadius: 18,
    paddingVertical: 10,
    alignItems: "center",
  },
  featureUnlockModalButtonText: {
    fontSize: 16,
    fontWeight: "700",
    color: "#1F1300",
  },
  featureUnlockRewardRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 10,
  },
  featureUnlockRewardCoin: {
    width: 24,
    height: 24,
    resizeMode: "contain",
    marginRight: 8,
  },
  featureUnlockRewardAmount: {
    fontSize: 16,
    fontWeight: "700",
  },
  featureUnlockHero: {
    borderWidth: 1,
    borderRadius: 18,
    padding: 14,
    marginBottom: 12,
  },
  featureUnlockHeroAccent: {
    borderWidth: 2,
    borderRadius: 14,
    paddingHorizontal: 12,
    paddingVertical: 4,
    alignSelf: "flex-start",
    marginBottom: 8,
  },
  featureUnlockHeroLabel: {
    fontSize: 14,
    fontWeight: "600",
  },
  featureUnlockMap: {
    paddingVertical: 6,
  },
  featureUnlockMapRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginBottom: 6,
  },
  featureUnlockMapDot: {
    width: 18,
    height: 18,
    borderRadius: 9,
  },
  featureUnlockList: {
    paddingVertical: 4,
  },
  featureUnlockListItem: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 10,
  },
  featureUnlockListBullet: {
    width: 10,
    height: 10,
    borderRadius: 5,
    marginRight: 8,
  },
  featureUnlockListLine: {
    height: 8,
    borderRadius: 4,
  },
  featureUnlockButton: {
    marginTop: 24,
    borderRadius: 20,
    paddingVertical: 14,
    alignItems: "center",
  },
  featureUnlockButtonText: {
    fontSize: 16,
    fontWeight: "600",
  },
  lockedFeatureWrap: {
    position: "relative",
    overflow: "hidden",
  },
  lockedFeatureOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "flex-start",
    alignItems: "flex-start",
    paddingTop: 18,
    paddingBottom: 24,
    paddingHorizontal: 18,
  },
  lockedFeatureOverlayCentered: {
    justifyContent: "center",
    alignItems: "center",
  },
  lockedFeatureOverlayCompact: {
    paddingTop: 12,
    paddingBottom: 12,
    paddingHorizontal: 12,
  },
  lockedFeatureBlur: {
    zIndex: 0,
  },
  lockedFeatureScrim: {
    ...StyleSheet.absoluteFillObject,
  },
  lockedFeatureOverlayContent: {
    gap: 8,
    maxWidth: "100%",
    flexShrink: 1,
    zIndex: 1,
  },
  lockedFeatureOverlayContentCentered: {
    alignItems: "center",
    width: "100%",
  },
  lockedFeatureOverlayContentCompact: {
    gap: 6,
  },
  lockedFeatureLockRow: {
    flexDirection: "row",
    alignItems: "center",
  },
  lockedFeatureLockRowCentered: {
    justifyContent: "center",
    width: "100%",
  },
  lockedFeatureLockIcon: {
    fontSize: 16,
  },
  lockedFeatureLockIconCentered: {
    alignSelf: "center",
    textAlign: "center",
    textAlignVertical: "center",
  },
  lockedFeatureLockIconCompact: {
    fontSize: 12,
  },
  lockedFeatureTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 18,
    flexShrink: 1,
  },
  lockedFeatureTitleCentered: {
    textAlign: "center",
  },
  lockedFeatureTitleCompact: {
    fontSize: 14,
  },
  lockedFeatureDescription: {
    ...createBodyText({ fontSize: 14 }),
    lineHeight: 20,
    flexShrink: 1,
  },
  lockedFeatureDescriptionCentered: {
    textAlign: "center",
  },
  lockedFeatureDescriptionCompact: {
    fontSize: 11,
    lineHeight: 14,
  },
  lockedFeatureLevelBadge: {
    alignSelf: "flex-start",
    marginTop: 4,
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    maxWidth: "100%",
  },
  lockedFeatureLevelBadgeCentered: {
    alignSelf: "center",
  },
  lockedFeatureLevelBadgeCompact: {
    marginTop: 2,
    paddingHorizontal: 8,
    paddingVertical: 4,
  },
  lockedFeatureLevelText: {
    fontSize: 12,
    fontWeight: "700",
  },
  lockedFeatureLevelTextCompact: {
    fontSize: 10,
  },
  lockedFeaturePlaceholder: {
    borderRadius: 20,
    borderWidth: 1,
    padding: 18,
    gap: 10,
    minHeight: 140,
  },
  lockedFeaturePlaceholderCompact: {
    borderRadius: 20,
    borderWidth: 1,
    padding: 16,
    gap: 8,
    minHeight: 110,
  },
  lockedFeaturePlaceholderSquare: {
    aspectRatio: 1,
    width: "100%",
    minHeight: 0,
  },
  lockedFeaturePlaceholderLine: {
    height: 10,
    borderRadius: 6,
  },
  lockedFeatureCard: {
    borderRadius: 20,
    marginTop: 12,
  },
  lockedFeatureRow: {
    flexDirection: "row",
    gap: 12,
    marginTop: 12,
  },
  lockedFeatureMiniCard: {
    flex: 1,
    borderRadius: 18,
  },
  lockedFeatureInlineCard: {
    borderRadius: 20,
  },
  lockedFeaturePane: {
    borderRadius: 24,
    minHeight: 220,
  },
  lockedFeaturePaneContent: {
    padding: 6,
  },
  lockedFeatureScreen: {
    flex: 1,
  },
  lockedFeatureScreenContent: {
    flex: 1,
  },
  skinPickerItem: {
    flexDirection: "row",
    alignItems: "center",
    borderWidth: 1,
    borderRadius: 18,
    padding: 12,
    gap: 12,
    marginBottom: 12,
  },
  skinPickerAvatar: {
    width: 56,
    height: 56,
    borderRadius: 18,
  },
  skinPickerItemTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 16,
  },
  skinPickerItemSubtitle: {
    ...createBodyText({ fontSize: 13 }),
  },
  skinPickerBadge: {
    borderWidth: 1,
    borderRadius: 999,
    paddingHorizontal: 10,
    paddingVertical: 4,
  },
  skinPickerBadgeText: {
    ...createCtaText({ fontSize: 10, textTransform: "uppercase" }),
  },
  skinPickerLockedBadge: {
    opacity: 0.85,
  },
  skinPickerLockedBadgeText: {
    letterSpacing: 0.5,
  },
  tamagotchiBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.55)",
    justifyContent: "center",
    alignItems: "center",
    padding: 20,
  },
  partyGlowOverlay: {
    ...StyleSheet.absoluteFillObject,
  },
  partyFireworksOverlay: {
    ...StyleSheet.absoluteFillObject,
  },
  partyFireworkRing: {
    position: "absolute",
    borderWidth: 2,
    opacity: 0,
  },
  tamagotchiCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 24,
    padding: 20,
    borderWidth: 1,
    gap: 10,
  },
  tamagotchiHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  tamagotchiTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 18,
  },
  tamagotchiMood: {
    ...createBodyText({ fontSize: 14 }),
  },
  tamagotchiStatRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  tamagotchiStatLabel: {
    ...createBodyText({ fontSize: 14 }),
  },
  tamagotchiStatValue: {
    ...createBodyText({ fontSize: 16, fontWeight: "700" }),
  },
  tamagotchiProgress: {
    height: 12,
    borderRadius: 999,
    overflow: "hidden",
  },
  tamagotchiProgressFill: {
    height: "100%",
    borderRadius: 999,
  },
  tamagotchiActions: {
    flexDirection: "row",
    gap: 10,
    marginTop: 6,
  },
  tamagotchiButton: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: 14,
    borderWidth: 1,
    alignItems: "center",
  },
  tamagotchiButtonContent: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  tamagotchiButtonIcon: {
    width: 20,
    height: 20,
  },
  tamagotchiPreview: {
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 6,
  },
  tamagotchiButtonText: {
    ...createCtaText({ fontSize: 14 }),
  },
  tamagotchiFoodTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 16,
    marginTop: 12,
  },
  tamagotchiFoodList: {
    marginTop: 6,
  },
  tamagotchiFoodButton: {
    flexDirection: "row",
    alignItems: "center",
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 12,
    paddingHorizontal: 14,
    gap: 12,
    position: "relative",
    marginBottom: 10,
  },
  tamagotchiFoodButtonLast: {
    marginBottom: 0,
  },
  tamagotchiFoodButtonDisabled: {
    opacity: 0.5,
  },
  tamagotchiFoodEmoji: {
    fontSize: 28,
  },
  tamagotchiFoodInfo: {
    flex: 1,
    gap: 2,
  },
  tamagotchiFoodLabel: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 15,
  },
  tamagotchiFoodBoost: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  tamagotchiFoodCost: {
    flexDirection: "row",
    alignItems: "center",
    gap: 4,
  },
  tamagotchiFoodCostIcon: {
    width: 18,
    height: 18,
  },
  tamagotchiFoodCostText: {
    ...createCtaText({ fontSize: 13 }),
  },
  tamagotchiFoodBadge: {
    position: "absolute",
    top: -10,
    right: 12,
    borderRadius: 999,
    paddingHorizontal: 8,
    paddingVertical: 3,
  },
  tamagotchiFoodBadgeText: {
    ...createCtaText({ fontSize: 10, textTransform: "uppercase" }),
    letterSpacing: 0.6,
  },
  tamagotchiSub: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  tamagotchiHint: {
    ...createSecondaryText({ fontSize: 12, textAlign: "center" }),
    marginTop: 4,
  },
  tamagotchiClose: {
    alignSelf: "center",
    marginTop: 6,
    paddingVertical: 6,
    paddingHorizontal: 12,
  },
  tamagotchiCloseText: {
    ...createCtaText({ fontSize: 14 }),
  },
  heroStatCard: {
    padding: 16,
    borderRadius: 24,
    marginTop: 18,
  },
  heroStatRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  heroStatLabel: {
    textTransform: "uppercase",
    fontSize: 12,
  },
  heroStatValue: {
    fontSize: 24,
    fontWeight: "700",
  },
  heroSpendLine: {
    fontSize: Platform.OS === "ios" ? 16 : 18,
    lineHeight: Platform.OS === "ios" ? 20 : 22,
    fontWeight: "600",
    marginTop: Platform.OS === "ios" ? 6 : 10,
  },
  progressHeroCard: {
    marginTop: 8,
    borderRadius: 24,
    padding: 18,
    borderWidth: 1,
  },
  savedHeroCard: {
    marginTop: 12,
    padding: 18,
    borderRadius: 26,
    shadowOpacity: 0.18,
    shadowRadius: 20,
    shadowOffset: { width: 0, height: 8 },
    elevation: 8,
    overflow: "hidden",
    position: "relative",
  },
  savedHeroGlowWrap: {
    ...StyleSheet.absoluteFillObject,
    zIndex: 0,
  },
  savedHeroGlow: {
    position: "absolute",
    width: 140,
    height: 140,
    borderRadius: 70,
    top: -40,
    right: -30,
    opacity: 0.6,
    zIndex: -1,
  },
  savedHeroGlowBottom: {
    width: 120,
    height: 120,
    bottom: -30,
    left: -10,
    zIndex: -1,
  },
  savedHeroContent: {
    position: "relative",
    zIndex: 1,
  },
  savedHeroHeader: {
    marginBottom: 2,
    flexDirection: "row",
    alignItems: "flex-start",
    justifyContent: "space-between",
    position: "relative",
    paddingRight: 96,
  },
  savedHeroTitleWrap: {
    flex: 1,
  },
  savedHeroSubtitle: {
    ...createBodyText({
      fontSize: Platform.OS === "ios" ? 13 : 15,
      marginTop: Platform.OS === "ios" ? 4 : 6,
      marginBottom: 8,
      lineHeight: Platform.OS === "ios" ? 18 : 20,
      width: "100%",
    }),
  },
  savedHeroRecentList: {
    width: "100%",
    alignSelf: "stretch",
    marginTop: 0,
    gap: Platform.OS === "ios" ? 4 : 6,
    marginBottom: 14,
  },
  savedHeroRecentTitle: {
    ...createCtaText({ fontSize: 11 }),
  },
  savedHeroRecentItem: {
    ...createBodyText({
      fontSize: Platform.OS === "ios" ? 11 : 12,
      lineHeight: Platform.OS === "ios" ? 15 : 17,
    }),
    width: "100%",
    flexShrink: 1,
  },
  savedHeroLevelButton: {
    paddingHorizontal: 6,
    paddingVertical: 6,
    position: "absolute",
    top: -18,
    right: -8,
  },
  savedHeroLevelBadge: {
    borderRadius: 999,
    paddingHorizontal: 14,
    paddingVertical: 6,
    borderWidth: 1,
  },
  savedHeroLevelText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  dailyRewardButton: {
    borderRadius: 16,
    borderWidth: 1,
    paddingVertical: 3,
    paddingHorizontal: 10,
    alignItems: "center",
    justifyContent: "center",
    gap: 4,
  },
  dailyRewardCoin: {
    width: 22,
    height: 22,
    resizeMode: "contain",
  },
  dailyRewardAmount: {
    fontSize: 12,
    fontWeight: "800",
    lineHeight: 14,
  },
  dailyRewardCaption: {
    fontSize: 7,
    fontWeight: "600",
    textTransform: "none",
    textAlign: "center",
    includeFontPadding: false,
    lineHeight: 9,
  },
  dailyRewardLockedIcon: {
    fontSize: 12,
    lineHeight: 14,
  },
  dailyRewardLockedLabel: {
    fontSize: 9,
    fontWeight: "700",
    textTransform: "uppercase",
    textAlign: "center",
    includeFontPadding: false,
    lineHeight: 12,
  },
  dailyRewardFloating: {
    position: "absolute",
    right: 0,
    zIndex: 2,
    elevation: 2,
  },
  dailyRewardModalBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.35)",
  },
  dailyRewardModalWrap: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    padding: 20,
    justifyContent: "center",
    alignItems: "center",
  },
  dailyRewardModalCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 16,
    borderWidth: 1,
    padding: 18,
    shadowColor: "#000",
    shadowOpacity: 0.12,
    shadowOffset: { width: 0, height: 6 },
    shadowRadius: 12,
    elevation: 4,
  },
  dailyRewardModalTitle: {
    fontSize: 16,
    fontWeight: "800",
    marginBottom: 4,
  },
  dailyRewardModalSubtitle: {
    fontSize: 13,
    fontWeight: "600",
    marginBottom: 12,
    textAlign: "center",
  },
  dailyRewardCalendar: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    flexWrap: "wrap",
    marginBottom: 8,
    gap: 6,
  },
  dailyRewardCalendarDay: {
    minWidth: 44,
    maxWidth: 52,
    width: 46,
    paddingVertical: 6,
    paddingHorizontal: 6,
    borderRadius: 12,
    borderWidth: 1,
    alignItems: "center",
    gap: 3,
  },
  dailyRewardCalendarDayLabel: {
    fontSize: 9,
    fontWeight: "600",
  },
  dailyRewardCalendarAmount: {
    fontSize: 12,
    fontWeight: "800",
  },
  dailyRewardCalendarSuperLabel: {
    fontSize: 8,
    fontWeight: "700",
    textTransform: "uppercase",
    letterSpacing: 0.6,
  },
  dailyRewardModalNote: {
    fontSize: 12,
    fontWeight: "600",
    textAlign: "center",
    marginTop: 4,
  },
  dailyRewardModalActions: {
    flexDirection: "row",
    gap: 8,
    marginTop: 14,
  },
  dailyRewardModalSecondary: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 12,
    borderWidth: 1,
    alignItems: "center",
  },
  dailyRewardModalSecondaryText: {
    fontSize: 14,
    fontWeight: "700",
  },
  dailyRewardModalPrimary: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: 12,
    alignItems: "center",
  },
  dailyRewardModalPrimaryText: {
    fontSize: 14,
    fontWeight: "800",
  },
  savedHeroAmountWrap: {
    marginTop: 0,
    marginBottom: 4,
  },
  heroLevelDetails: {
    borderRadius: 16,
    borderWidth: 1,
    padding: 12,
    marginBottom: 10,
  },
  heroLevelTitle: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  heroLevelSubtitle: {
    ...createBodyText({ fontSize: 12, marginTop: 6 }),
  },
  heroLevelMeta: {
    ...createSecondaryText({ marginTop: 8 }),
  },
  heroPotentialCard: {
    marginTop: 10,
    marginBottom: 12,
    borderRadius: 18,
    padding: 14,
    gap: 8,
  },
  heroPotentialBody: {
    ...createBodyText({ fontSize: 14 }),
  },
  heroPotentialHeader: {
    gap: 6,
  },
  heroPotentialRow: {
    flexDirection: "row",
    alignItems: "baseline",
    justifyContent: "space-between",
    width: "100%",
    gap: 12,
  },
  heroPotentialLabel: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
    lineHeight: 16,
    flex: 1,
  },
  heroPotentialValue: {
    ...createBodyText({ fontSize: 16, fontWeight: "700" }),
    lineHeight: 20,
    textAlign: "right",
  },
  heroPotentialHint: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  heroPotentialStatus: {
    ...createSecondaryText({ fontSize: 12 }),
    lineHeight: 16,
    flex: 1,
  },
  heroPotentialDelta: {
    ...createCtaText({ fontSize: 13 }),
    marginTop: 0,
    textAlign: "right",
  },
  heroPotentialButton: {
    borderWidth: 1,
    borderRadius: 999,
    paddingVertical: 8,
    alignItems: "center",
  },
  heroPotentialButtonText: {
    ...createCtaText(),
  },
  savedHeroProgressRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    marginBottom: 10,
  },
  savedHeroBar: {
    flex: 1,
    marginBottom: 0,
  },
  savedHeroPercentTag: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
  },
  savedHeroPercentText: {
    ...createCtaText({ fontSize: 12 }),
  },
  savedHeroGoalRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
  },
  goalLabel: {
    ...createCtaText({ fontSize: 12 }),
  },
  savedHeroGoalMetaRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
    marginTop: 2,
  },
  savedHeroGoalLabel: {
    ...createBodyText({ fontSize: 13, flex: 1 }),
  },
  goalCompleteBadge: {
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 12,
    paddingVertical: 4,
  },
  goalCompleteBadgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  heroChallengeBlock: {
    marginTop: 10,
    borderRadius: 16,
    borderWidth: 1,
    padding: 10,
    gap: 6,
    opacity: 0.9,
  },
  heroChallengeRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 8,
  },
  heroChallengeTitleRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
    flex: 1,
  },
  heroChallengeEmoji: {
    fontSize: 16,
  },
  heroChallengeMeta: {
    ...createSecondaryText({ fontSize: 11 }),
  },
  heroChallengeName: {
    ...createBodyText({ fontSize: 13, fontWeight: "700" }),
    flex: 1,
  },
  heroChallengeProgressRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  heroChallengeBar: {
    flex: 1,
    height: 6,
    borderRadius: 999,
    overflow: "hidden",
  },
  heroChallengeFill: {
    height: "100%",
    borderRadius: 999,
  },
  heroChallengeLabel: {
    ...createSecondaryText({ fontSize: 11 }),
  },
  goalSelectButton: {
    marginTop: 10,
    paddingVertical: 10,
    paddingHorizontal: 14,
    borderRadius: 14,
    borderWidth: 1,
    alignItems: "center",
  },
  goalSelectText: {
    ...createCtaText({ fontSize: 13 }),
  },
  breakdownOverlay: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.45)",
    justifyContent: "center",
    alignItems: "center",
    padding: 16,
  },
  dailySummaryBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.6)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  dailySummaryCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 28,
    padding: 24,
    borderWidth: 1,
    overflow: "hidden",
  },
  dailySummaryGlow: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.12,
  },
  dailySummaryCardContent: {
    gap: 18,
  },
  dailySummaryHeroRow: {
    flexDirection: "row",
    gap: 12,
  },
  dailySummaryHeroText: {
    flex: 1,
  },
  dailySummaryIconWrap: {
    width: 56,
    height: 56,
    borderRadius: 18,
    alignItems: "center",
    justifyContent: "center",
    borderWidth: 1,
  },
  dailySummaryIconText: {
    fontSize: 28,
  },
  dailySummaryBadge: {
    alignSelf: "flex-start",
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 999,
    borderWidth: 1,
    marginBottom: 6,
  },
  dailySummaryBadgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  dailySummaryTitle: {
    ...TYPOGRAPHY.blockTitle,
  },
  dailySummarySubtitle: {
    ...createBodyText({ fontSize: 16, marginTop: 4 }),
  },
  dailySummaryHighlight: {
    borderRadius: 22,
    padding: 18,
    borderWidth: 1,
  },
  dailySummaryHighlightLabel: {
    ...createCtaText({ fontSize: 13, textTransform: "uppercase" }),
  },
  dailySummaryHighlightValue: {
    fontSize: 32,
    fontWeight: "800",
    marginTop: 8,
  },
  dailySummaryHighlightSub: {
    ...createBodyText({ fontSize: 14, marginTop: 6 }),
  },
  dailySummaryStatsRow: {
    flexDirection: "row",
    gap: 12,
  },
  dailySummaryStatCard: {
    flex: 1,
    borderRadius: 20,
    paddingVertical: 16,
    borderWidth: 1,
    alignItems: "center",
  },
  dailySummaryStatValue: {
    fontSize: 26,
    fontWeight: "800",
  },
  dailySummaryStatLabel: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase", marginTop: 8 }),
  },
  dailySummaryButton: {
    borderRadius: 18,
    paddingVertical: 14,
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "row",
    gap: 8,
  },
  dailySummaryButtonText: {
    ...createCtaText({ fontSize: 15 }),
  },
  dailySummaryButtonIcon: {
    ...createCtaText({ fontSize: 16 }),
  },
  dailySummaryHint: {
    ...createSecondaryText({ textAlign: "center" }),
  },
  ratingPromptBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.5)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  ratingPromptCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 26,
    padding: 24,
    gap: 16,
    borderWidth: 1,
  },
  ratingPromptCatWrap: {
    alignItems: "center",
  },
  ratingPromptCat: {
    width: 130,
    height: 130,
  },
  ratingPromptTitle: {
    ...TYPOGRAPHY.blockTitle,
    textAlign: "center",
  },
  ratingPromptBody: {
    ...createBodyText({ fontSize: 15, textAlign: "center" }),
  },
  ratingPromptActions: {
    flexDirection: "row",
    gap: 12,
  },
  ratingPromptSecondary: {
    flex: 1,
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
    borderWidth: 1,
  },
  ratingPromptSecondaryText: {
    ...createCtaText({ fontSize: 15 }),
  },
  ratingPromptPrimary: {
    flex: 1,
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
  },
  ratingPromptPrimaryText: {
    ...createCtaText({ fontSize: 15 }),
  },
  levelShareModalCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 28,
    padding: 22,
    borderWidth: 1,
    gap: 12,
  },
  levelShareModalTitle: {
    ...TYPOGRAPHY.blockTitle,
    textAlign: "center",
  },
  levelShareModalCaption: {
    ...createSecondaryText({ textAlign: "center" }),
  },
  levelShareShot: {
    width: "100%",
    borderRadius: 28,
    overflow: "hidden",
  },
  levelShareCanvas: {
    backgroundColor: LEVEL_SHARE_BG,
    borderRadius: 24,
    paddingVertical: 26,
    paddingHorizontal: 20,
    alignItems: "center",
    gap: 12,
  },
  levelShareBadge: {
    borderRadius: 999,
    paddingHorizontal: 18,
    paddingVertical: 6,
    backgroundColor: LEVEL_SHARE_ACCENT,
  },
  levelShareBadgeText: {
    color: "#1E0F00",
    fontWeight: "800",
    fontSize: 12,
    letterSpacing: 1,
  },
  levelShareCanvasTitle: {
    color: "#FFFFFF",
    fontSize: 32,
    fontWeight: "900",
    textTransform: "uppercase",
  },
  levelShareCanvasSubtitle: {
    color: LEVEL_SHARE_MUTED,
    fontSize: 15,
    textAlign: "center",
  },
  levelShareCat: {
    width: 180,
    height: 180,
    resizeMode: "contain",
  },
  levelShareJoin: {
    color: "#FFFFFF",
    fontSize: 16,
    fontWeight: "700",
    textAlign: "center",
  },
  levelShareInstagram: {
    color: LEVEL_SHARE_MUTED,
    fontSize: 13,
    fontWeight: "700",
    textAlign: "center",
  },
  levelShareFooter: {
    marginTop: 12,
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  levelShareLogo: {
    width: 48,
    height: 48,
    borderRadius: 16,
  },
  levelShareFooterBrand: {
    color: "#FFFFFF",
    fontSize: 18,
    fontWeight: "800",
  },
  levelShareFooterHint: {
    color: LEVEL_SHARE_MUTED,
    fontSize: 12,
    textTransform: "uppercase",
  },
  levelShareActions: {
    gap: 10,
  },
  levelSharePrimary: {
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
  },
  levelSharePrimaryText: {
    ...createCtaText({ fontSize: 15 }),
  },
  levelShareGhost: {
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
    borderWidth: 1,
  },
  levelShareGhostText: {
    ...createCtaText({ fontSize: 15 }),
  },
  dailyChallengeCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 30,
    padding: 24,
    borderWidth: 1,
    overflow: "hidden",
  },
  dailyChallengeGlow: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.25,
  },
  dailyChallengeContent: {
    gap: 20,
  },
  dailyChallengeHeroRow: {
    flexDirection: "row",
    gap: 16,
  },
  dailyChallengeBadge: {
    alignSelf: "flex-start",
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 999,
    borderWidth: 1,
  },
  dailyChallengeBadgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  dailyChallengeTitle: {
    ...TYPOGRAPHY.blockTitle,
  },
  dailyChallengeSubtitle: {
    ...createBodyText({ fontSize: 15, marginTop: 4 }),
  },
  dailyChallengeRewardStack: {
    alignItems: "flex-end",
    gap: 6,
  },
  dailyChallengeRewardHint: {
    ...createBodyText({ fontSize: 13 }),
    fontWeight: "700",
  },
  dailyChallengeTemptationRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    borderWidth: 1,
    borderRadius: 24,
    padding: 14,
    backgroundColor: "rgba(17,17,17,0.03)",
  },
  dailyChallengeEmojiCard: {
    width: 58,
    height: 58,
    borderRadius: 18,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "rgba(17,17,17,0.05)",
  },
  dailyChallengeEmojiCardText: {
    fontSize: 32,
  },
  dailyChallengeTemptationTitle: {
    fontSize: 16,
    fontWeight: "700",
  },
  dailyChallengeTemptationHint: {
    ...createBodyText({ fontSize: 14 }),
  },
  dailyChallengeActions: {
    flexDirection: "row",
    gap: 12,
  },
  dailyChallengePrimaryButton: {
    flex: 1,
    borderRadius: 18,
    paddingVertical: 14,
    alignItems: "center",
  },
  dailyChallengePrimaryText: {
    ...createCtaText({ fontSize: 15 }),
  },
  dailyChallengeGhostButton: {
    flex: 1,
    borderRadius: 18,
    paddingVertical: 14,
    alignItems: "center",
    borderWidth: 1,
  },
  dailyChallengeGhostText: {
    ...createCtaText({ fontSize: 15 }),
  },
  breakdownCard: {
    width: "100%",
    maxWidth: 420,
    borderRadius: 20,
    padding: 16,
    borderWidth: 1,
  },
  breakdownHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 12,
  },
  breakdownTitle: {
    fontSize: 18,
    fontWeight: "800",
  },
  breakdownClose: {
    fontSize: 18,
    fontWeight: "700",
  },
  breakdownBars: {
    flexDirection: "row",
    justifyContent: "space-between",
    gap: 10,
    marginBottom: 16,
  },
  breakdownBarItem: {
    flex: 1,
    alignItems: "center",
    gap: 6,
  },
  breakdownBarTrack: {
    width: "100%",
    height: 140,
    borderRadius: 10,
    overflow: "hidden",
    justifyContent: "flex-end",
  },
  breakdownBarStack: {
    width: "100%",
  },
  breakdownBarLabel: {
    fontSize: 12,
    fontWeight: "700",
  },
  breakdownBarAmount: {
    fontSize: 11,
    fontWeight: "600",
    textAlign: "center",
  },
  breakdownAmountWrapper: {
    width: "100%",
    paddingHorizontal: 4,
  },
  breakdownLegend: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  breakdownLegendItem: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 12,
    borderWidth: 1,
  },
  breakdownLegendDot: {
    width: 10,
    height: 10,
    borderRadius: 5,
  },
  breakdownLegendText: {
    fontSize: 12,
    fontWeight: "700",
  },
  spendStatsCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 24,
    borderWidth: 1,
    padding: 18,
    gap: 12,
  },
  spendStatsHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  spendStatsTabs: {
    flex: 1,
    flexDirection: "row",
    padding: 4,
    borderRadius: 999,
    gap: 4,
  },
  spendStatsTab: {
    flex: 1,
    paddingVertical: 8,
    borderRadius: 999,
    alignItems: "center",
    justifyContent: "center",
  },
  spendStatsTabActive: {
    shadowColor: "#000",
    shadowOpacity: 0.06,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 2 },
    elevation: 2,
  },
  spendStatsTabText: {
    fontSize: 15,
    fontWeight: "700",
  },
  spendStatsCloseButton: {
    width: 36,
    height: 36,
    borderRadius: 18,
    alignItems: "center",
    justifyContent: "center",
  },
  spendStatsCloseText: {
    fontSize: 16,
    fontWeight: "700",
  },
  spendStatsTitleRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
  },
  spendStatsNavButton: {
    width: 38,
    height: 38,
    borderRadius: 19,
    alignItems: "center",
    justifyContent: "center",
  },
  spendStatsNavButtonDisabled: {
    opacity: 0.4,
  },
  spendStatsNavText: {
    fontSize: 20,
    fontWeight: "700",
  },
  spendStatsTitleBlock: {
    flex: 1,
    alignItems: "center",
    gap: 4,
  },
  spendStatsSubtitle: {
    fontSize: 13,
    fontWeight: "600",
  },
  spendStatsTitle: {
    fontSize: 22,
    fontWeight: "800",
  },
  spendStatsChart: {
    flexDirection: "row",
    alignItems: "flex-end",
    justifyContent: "space-between",
    gap: 10,
    minHeight: 190,
  },
  spendStatsBarItem: {
    flex: 1,
    alignItems: "center",
    gap: 6,
  },
  spendStatsValue: {
    fontSize: 13,
    fontWeight: "700",
  },
  spendStatsBarTrack: {
    width: "100%",
    height: 140,
    borderRadius: 16,
    padding: 6,
    justifyContent: "flex-end",
  },
  spendStatsBarStack: {
    width: "100%",
    borderRadius: 10,
    marginTop: 4,
  },
  spendStatsBarLabel: {
    fontSize: 12,
    fontWeight: "700",
  },
  spendStatsDivider: {
    height: 1,
  },
  spendStatsLegend: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 10,
    justifyContent: "center",
  },
  spendStatsLegendPill: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
  },
  spendStatsLegendPercent: {
    fontSize: 13,
    fontWeight: "800",
  },
  spendStatsLegendLabel: {
    fontSize: 14,
    fontWeight: "700",
  },
  savedHeroToggleRow: {
    marginTop: 10,
    alignItems: "flex-end",
  },
  savedHeroToggleButton: {
    paddingVertical: 4,
    paddingHorizontal: 8,
  },
  savedHeroToggleText: {
    fontSize: 12,
    fontWeight: "600",
    textAlign: "right",
  },
  savedHeroDaily: {
    marginTop: 12,
    gap: 12,
  },
  savedHeroExpanded: {
    marginTop: 12,
    gap: 16,
  },
  savedHeroCoinsCard: {
    flexDirection: "row",
    alignItems: "center",
    gap: 14,
    borderRadius: 18,
    borderWidth: 1,
    padding: 14,
  },
  savedHeroCoinsText: {
    flex: 1,
    gap: 4,
  },
  savedHeroCoinsLabel: {
    fontSize: 14,
    fontWeight: "800",
  },
  savedHeroCoinsSubtitle: {
    fontSize: 12,
    fontWeight: "600",
  },
  savedHeroCoinsValue: {
    fontSize: 24,
    fontWeight: "900",
  },
  savedHeroDailyTitle: {
    fontSize: 14,
    fontWeight: "700",
  },
  savedHeroBars: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-end",
    gap: 8,
  },
  savedHeroBarItem: {
    flex: 1,
    alignItems: "center",
    gap: 4,
  },
  savedHeroBarAmountWrap: {
    minHeight: 28,
    justifyContent: "flex-end",
    alignItems: "center",
    gap: 2,
    paddingHorizontal: 2,
  },
  savedHeroBarAmountBlock: {
    alignItems: "center",
    maxWidth: 60,
    width: "100%",
  },
  savedHeroBarAmount: {
    fontSize: 9,
    textAlign: "center",
    lineHeight: 11,
    fontWeight: "600",
  },
  savedHeroBarSpend: {
    fontSize: 8,
    textAlign: "center",
    lineHeight: 10,
    fontWeight: "600",
  },
  savedHeroBarCurrency: {
    fontSize: 8,
    fontWeight: "600",
  },
  savedHeroBarTrack: {
    width: 20,
    height: 70,
    borderRadius: 10,
    backgroundColor: "rgba(255,255,255,0.4)",
    justifyContent: "flex-end",
    overflow: "hidden",
    position: "relative",
  },
  savedHeroBarColumn: {
    width: "100%",
    borderRadius: 10,
  },
  savedHeroBarColumnSpend: {
    position: "absolute",
    left: 0,
    bottom: 0,
    width: "100%",
    borderRadius: 10,
  },
  savedHeroBarLabel: {
    fontSize: 11,
    fontWeight: "600",
  },
  savedHeroDailyEmpty: {
    fontSize: 12,
  },
  weeklyTrendRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 12,
    marginTop: 6,
    marginBottom: 2,
  },
  weeklyTrendItem: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  weeklyTrendLabel: {
    ...createSecondaryText({ fontSize: 11 }),
  },
  weeklyTrendValue: {
    ...createSecondaryText({ fontSize: 11 }),
    fontWeight: "700",
  },
  progressHeroHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 12,
  },
  progressHeroTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: Platform.OS === "ios" ? 22 : 24,
    lineHeight: Platform.OS === "ios" ? 26 : undefined,
    fontFamily: INTER_FONTS.extraBold,
    marginRight: Platform.OS === "ios" ? 8 : 0,
  },
  progressHeroAmount: {
    fontSize: 26,
    fontWeight: "900",
    fontFamily: INTER_FONTS.extraBold,
    marginBottom: 6,
  },
  progressHeroLevel: {
    fontSize: 14,
    fontWeight: "600",
  },
  progressHeroBar: {
    height: 10,
    borderRadius: 999,
    overflow: "hidden",
    marginBottom: 8,
  },
  progressHeroFill: {
    height: "100%",
    borderRadius: 999,
  },
  progressHeroNext: {
    fontSize: 13,
    fontWeight: "500",
  },
  savedHeroStatsRow: {
    flexDirection: "row",
    gap: 10,
    marginTop: 14,
  },
  savedHeroStatsItem: {
    flex: 1,
    borderRadius: 18,
    borderWidth: 1,
    paddingVertical: 12,
    paddingHorizontal: 12,
  },
  savedHeroStatsValue: {
    fontSize: 18,
    fontWeight: "800",
  },
  savedHeroStatsLabel: {
    fontSize: 12,
    marginTop: 4,
  },
  payBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.5)",
    justifyContent: "flex-end",
  },
  payBackdropHit: {
    flex: 1,
  },
  paySheet: {
    borderTopLeftRadius: 28,
    borderTopRightRadius: 28,
    padding: 24,
    gap: 16,
  },
  paySheetHandle: {
    width: 60,
    height: 4,
    borderRadius: 2,
    backgroundColor: "rgba(255,255,255,0.3)",
    alignSelf: "center",
    marginBottom: 4,
  },
  payBrand: {
    fontSize: 18,
    fontWeight: "700",
    textAlign: "center",
  },
  payCard: {
    flexDirection: "row",
    alignItems: "center",
    borderRadius: 18,
    padding: 16,
    gap: 12,
  },
  payCardIcon: {
    width: 48,
    height: 48,
    borderRadius: 14,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "rgba(0,0,0,0.05)",
  },
  payCardEmoji: {
    fontSize: 26,
  },
  payCardTexts: {
    flex: 1,
    marginLeft: 10,
  },
  payCardTitle: {
    fontSize: 14,
    fontWeight: "600",
  },
  payCardAmount: {
    fontSize: 16,
    fontWeight: "700",
  },
  paySheetReminder: {
    width: "100%",
    alignItems: "center",
    paddingVertical: 8,
  },
  paySheetSubtitle: {
    fontSize: 11,
    lineHeight: 14,
    textAlign: "center",
    maxWidth: "90%",
    alignSelf: "center",
  },
  payConfirm: {
    borderRadius: 999,
    paddingVertical: 12,
    alignItems: "center",
  },
  payConfirmText: {
    fontSize: 15,
    fontWeight: "700",
  },
  payCancel: {
    paddingVertical: 8,
    alignItems: "center",
  },
  payCancelText: {
    fontSize: 14,
    fontWeight: "600",
  },
  freeDayCard: {
    marginTop: 12,
    padding: 18,
    borderRadius: 24,
    borderWidth: 1,
    gap: 12,
    position: "relative",
  },
  freeDayHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    flexWrap: "wrap",
    gap: 12,
  },
  freeDayTitleBlock: {
    flex: 1,
  },
  freeDayLabel: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 18,
    letterSpacing: -0.3,
  },
  freeDayStatsRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 6,
  },
  freeDayStat: {
    flex: 1,
    alignItems: "center",
  },
  freeDayStatLabel: {
    ...createSecondaryText({ marginBottom: 2, textAlign: "center" }),
  },
  freeDayStatValue: {
    ...createBodyText({ fontSize: 16, fontWeight: "700", textAlign: "center" }),
  },
  freeDaySummaryRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginTop: 4,
    flexWrap: "wrap",
    gap: 8,
  },
  freeDayChip: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "rgba(0,0,0,0.05)",
    alignItems: "center",
    flexDirection: "row",
    flexShrink: 1,
  },
  freeDayChipText: {
    ...createCtaText({ fontSize: 12, textAlign: "center" }),
  },
  freeDayToggle: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    alignItems: "center",
  },
  freeDayToggleText: {
    ...createCtaText({ fontSize: 12, textAlign: "center" }),
  },
  freeDayStatusPill: {
    borderRadius: 999,
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderWidth: 1,
    alignSelf: "flex-start",
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "row",
  },
  freeDayStatusText: {
    ...createCtaText({ fontSize: 12, textAlign: "center" }),
  },
  freeDayStatusPillDisabled: {
    opacity: 0.5,
  },
  freeDayStatusCoin: {
    width: 18,
    height: 18,
    marginLeft: 6,
    resizeMode: "contain",
  },
  freeDayHealthBadge: {
    display: "none",
  },
  freeDayRescueBanner: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    borderRadius: 16,
    borderWidth: 1,
    paddingHorizontal: 14,
    paddingVertical: 10,
    gap: 12,
  },
  freeDayRescueTitle: {
    ...createBodyText({ fontSize: 15, marginBottom: 2 }),
  },
  freeDayRescueSubtitle: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  freeDayRescueButton: {
    borderRadius: 999,
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  freeDayRescueButtonText: {
    ...createCtaText({ fontSize: 13, color: "#fff", textAlign: "center" }),
  },
  freeDayRescueButtonDisabled: {
    backgroundColor: "rgba(0,0,0,0.05)",
    borderWidth: 1,
    borderColor: "rgba(0,0,0,0.08)",
  },
  impulseCard: {
    marginTop: 12,
    padding: 18,
    borderRadius: 24,
    borderWidth: 1,
    gap: 12,
    position: "relative",
    overflow: "hidden",
  },
  impulseCardGlow: {
    position: "absolute",
    width: 220,
    height: 220,
    borderRadius: 110,
    top: -90,
    right: -80,
    opacity: 0.2,
  },
  impulseHeaderRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-start",
    gap: 8,
  },
  impulseHeader: {
    gap: 4,
    flex: 1,
  },
  impulseCardTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 21,
  },
  impulseCardSubtitle: {
    ...createBodyText({ fontSize: 13, lineHeight: 18 }),
  },
  impulseToggle: {
    borderWidth: 1,
    borderRadius: 999,
    paddingHorizontal: 14,
    paddingVertical: 7,
  },
  impulseToggleText: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase", letterSpacing: 0.4 }),
  },
  impulseSummaryGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 10,
  },
  impulseBadge: {
    flex: 1,
    minWidth: "47%",
    borderRadius: 18,
    padding: 12,
    borderWidth: 1,
    gap: 6,
  },
  impulseSummaryLabel: {
    ...createCtaText({ fontSize: 10, textTransform: "uppercase", letterSpacing: 0.5 }),
  },
  impulseSummaryValue: {
    ...createBodyText({ fontSize: 13, lineHeight: 17, fontWeight: "600" }),
  },
  impulseTrendRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    paddingVertical: 6,
    paddingHorizontal: 10,
    borderRadius: 999,
    borderWidth: 1,
    alignSelf: "flex-start",
  },
  impulseTrendText: {
    ...createBodyText({ fontSize: 11, fontWeight: "700", letterSpacing: 0.2 }),
  },
  impulseCategoryList: {
    marginTop: 8,
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  impulseCategoryRow: {
    flexBasis: "48%",
    flexGrow: 1,
    flexDirection: "column",
    alignItems: "flex-start",
    borderWidth: 1,
    borderRadius: 16,
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
  },
  impulseCategoryLabel: {
    ...createBodyText({ fontSize: 12, fontWeight: "700" }),
  },
  impulseCategoryStats: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "flex-start",
    gap: 8,
  },
  impulseCategoryStat: {
    ...createBodyText({ fontSize: 11, fontWeight: "700" }),
  },
  impulseCategoryStatSecondary: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  impulseSequenceSection: {
    marginTop: 12,
    borderRadius: 18,
    borderWidth: 1,
    padding: 12,
    gap: 6,
  },
  impulseSequenceTitle: {
    ...createBodyText({ fontSize: 11, fontWeight: "700", textTransform: "uppercase", letterSpacing: 0.4 }),
    marginBottom: 2,
  },
  impulseSequenceEntry: {
    ...createSecondaryText({ fontSize: 11, lineHeight: 16 }),
  },
  freeDayHealthRow: {
    flexDirection: "row",
    alignItems: "center",
    borderWidth: 1,
    borderRadius: 16,
    padding: 12,
    marginBottom: 10,
    gap: 12,
  },
  freeDayHealthIcon: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "rgba(16,91,49,0.08)",
  },
  healthCoinIcon: {
    width: 26,
    height: 26,
    resizeMode: "contain",
  },
  freeDayHealthLabel: {
    fontSize: 14,
    fontWeight: "700",
  },
  freeDayHealthSubtitle: {
    fontSize: 12,
  },
  freeDayCoinRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginTop: 6,
  },
  freeDayCoinBadge: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 999,
    borderWidth: 1,
    gap: 6,
  },
  freeDayCoinImage: {
    width: 20,
    height: 20,
    resizeMode: "contain",
  },
  freeDayCoinCount: {
    fontSize: 12,
    fontWeight: "600",
  },
  freeDayHealthValue: {
    fontSize: 20,
    fontWeight: "800",
    minWidth: 40,
    textAlign: "right",
  },
  freeDayCalendar: {
    marginTop: 4,
    borderRadius: 16,
    padding: 12,
    backgroundColor: "rgba(255,255,255,0.35)",
  },
  freeDayCalendarHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 6,
  },
  freeDayCalendarTitle: {
    fontSize: 12,
    fontWeight: "600",
  },
  freeDayCalendarDays: {
    flexDirection: "row",
    justifyContent: "space-between",
  },
  freeDayCalendarDay: {
    alignItems: "center",
    gap: 4,
    flex: 1,
  },
  freeDayCalendarLabel: {
    fontSize: 11,
    textTransform: "uppercase",
  },
  freeDayCalendarDot: {
    width: 16,
    height: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: "rgba(0,0,0,0.08)",
  },
  freeDayCalendarDotActive: {
    backgroundColor: "#1EB25F",
    borderColor: "#1EB25F",
  },
  freeDayCalendarDotToday: {
    borderColor: "#1EB25F",
    borderWidth: 2,
  },
  progressHeroGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 12,
  },
  progressWeeklyCard: {
    borderRadius: 18,
    borderWidth: 1,
    padding: 14,
    gap: 10,
  },
  progressWeeklyTitle: {
    fontSize: 14,
    fontWeight: "700",
  },
  progressGoalCard: {
    flex: 1,
    borderRadius: 22,
    padding: 16,
    borderWidth: 1,
    gap: 8,
  },
  progressGoalHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  progressGoalTitle: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase" }),
  },
  progressGoalEmoji: {
    fontSize: 20,
  },
  progressGoalName: {
    ...createBodyText({ fontSize: 16, fontWeight: "700" }),
  },
  progressGoalMeta: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  progressGoalRingRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    marginTop: 4,
  },
  progressGoalRingText: {
    gap: 2,
    flex: 1,
    minWidth: 0,
  },
  progressGoalPercent: {
    fontSize: 18,
    fontWeight: "800",
  },
  progressGoalTarget: {
    ...createSecondaryText({ fontSize: 11 }),
  },
  progressCoinCard: {
    flex: 1,
    borderRadius: 22,
    padding: 16,
    borderWidth: 1,
    gap: 8,
  },
  progressCoinHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  progressCoinTitle: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase" }),
  },
  progressCoinEmoji: {
    fontSize: 20,
  },
  progressCoinValue: {
    fontSize: 26,
    fontWeight: "800",
  },
  progressCoinSubtitle: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  progressCoinRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  progressCoinBadge: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
    borderRadius: 12,
    borderWidth: 1,
    paddingHorizontal: 8,
    paddingVertical: 4,
  },
  progressCoinImage: {
    width: 14,
    height: 14,
    resizeMode: "contain",
  },
  progressCoinCount: {
    fontSize: 12,
    fontWeight: "600",
  },
  progressActiveChallenge: {
    borderRadius: 22,
    padding: 16,
    borderWidth: 1,
    gap: 10,
  },
  progressActiveChallengeHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  progressActiveChallengeTitle: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase" }),
  },
  progressActiveChallengeMeta: {
    ...createSecondaryText({ fontSize: 11 }),
  },
  progressActiveChallengeRow: {
    flexDirection: "row",
    alignItems: "flex-start",
    gap: 12,
  },
  progressActiveChallengeName: {
    ...createBodyText({ fontSize: 16, fontWeight: "700" }),
  },
  progressActiveChallengeDesc: {
    ...createBodyText({ fontSize: 13 }),
  },
  progressActiveChallengeButton: {
    borderRadius: 14,
    paddingVertical: 10,
    alignItems: "center",
    marginTop: 4,
  },
  progressActiveChallengeButtonText: {
    ...createCtaText({ fontSize: 13 }),
  },
  progressActiveChallengeEmpty: {
    ...createSecondaryText({ fontSize: 13 }),
  },
  progressAnalyticsCard: {
    borderRadius: 22,
    padding: 16,
    borderWidth: 1,
    gap: 10,
  },
  progressAnalyticsHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    gap: 8,
  },
  progressAnalyticsTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 16,
  },
  progressAnalyticsLegend: {
    flexDirection: "column",
    alignItems: "flex-end",
    gap: 4,
    flexWrap: "nowrap",
  },
  progressAnalyticsLegendItem: {
    flexDirection: "row",
    alignItems: "center",
    gap: 4,
  },
  progressAnalyticsDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
  },
  progressAnalyticsLegendText: {
    ...createSecondaryText({ fontSize: 10 }),
    flexShrink: 1,
  },
  progressAnalyticsSubtitle: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  progressAnalyticsScroll: {
    width: "100%",
  },
  progressAnalyticsList: {
    gap: 10,
    marginTop: 4,
  },
  progressBadgeRow: {
    marginTop: 6,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 8,
  },
  progressBadgeLabel: {
    ...createSecondaryText({ fontSize: 11 }),
  },
  progressBadgeList: {
    flexDirection: "row",
    alignItems: "center",
    gap: 4,
  },
  progressBadgeEmoji: {
    fontSize: 14,
  },
  progressBadgeCount: {
    ...createSecondaryText({ fontSize: 11 }),
  },
  progressAnalyticsRow: {
    gap: 6,
  },
  progressAnalyticsRowHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  progressAnalyticsLabel: {
    ...createBodyText({ fontSize: 13, fontWeight: "600" }),
  },
  progressAnalyticsValue: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  progressAnalyticsTrack: {
    height: 10,
    borderRadius: 999,
    overflow: "hidden",
  },
  progressAnalyticsFill: {
    height: "100%",
    flexDirection: "row",
    borderRadius: 999,
    overflow: "hidden",
  },
  progressAnalyticsSave: {
    height: "100%",
  },
  progressAnalyticsSpend: {
    height: "100%",
  },
  progressCategoryModalRoot: {
    flex: 1,
    justifyContent: "center",
  },
  progressCategoryBackdrop: {
    ...StyleSheet.absoluteFillObject,
  },
  progressCategoryModalWrap: {
    flex: 1,
    justifyContent: "center",
    paddingHorizontal: 18,
  },
  progressCategoryModalCard: {
    borderRadius: 18,
    borderWidth: 1,
    padding: 16,
    maxHeight: "70%",
  },
  progressCategoryModalHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
    marginBottom: 8,
  },
  progressCategoryModalTitle: {
    fontSize: 16,
    fontWeight: "800",
    flex: 1,
  },
  progressCategoryModalClose: {
    padding: 4,
  },
  progressCategoryModalCloseText: {
    fontSize: 18,
    fontWeight: "700",
  },
  progressCategoryModalList: {
    borderWidth: 1,
    borderRadius: 12,
    maxHeight: 380,
  },
  progressSectionHeader: {
    gap: 2,
  },
  progressSectionTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 18,
  },
  progressSectionSubtitle: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  progressGoalScroll: {
    paddingVertical: 4,
    paddingHorizontal: 2,
    paddingRight: 12,
    gap: 12,
  },
  progressGoalMiniCard: {
    width: 150,
    borderRadius: 18,
    borderWidth: 1,
    padding: 14,
    gap: 6,
    justifyContent: "center",
  },
  progressGoalMiniPlaceholder: {
    borderStyle: "dashed",
    alignItems: "center",
  },
  progressGoalMiniEmoji: {
    fontSize: 20,
  },
  progressGoalMiniTitle: {
    fontSize: 14,
    fontWeight: "700",
  },
  progressGoalMiniMeta: {
    ...createSecondaryText({ fontSize: 11 }),
  },
  progressGoalMiniPlus: {
    fontSize: 22,
    fontWeight: "700",
  },
  profileBadgeRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  profileChallengeBadge: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
    borderRadius: 12,
    borderWidth: 1,
    paddingHorizontal: 8,
    paddingVertical: 4,
  },
  profileChallengeBadgeList: {
    flexDirection: "row",
    alignItems: "center",
    gap: 2,
  },
  profileChallengeBadgeEmoji: {
    fontSize: 12,
  },
  profileChallengeBadgeCount: {
    ...createSecondaryText({ fontSize: 11 }),
  },
  stormOverlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(4,6,15,0.92)",
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 24,
    zIndex: 99,
  },
  stormFlash: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(255,255,255,0.55)",
  },
  stormMessageWrap: {
    width: "85%",
    maxWidth: 360,
    paddingHorizontal: 26,
    paddingVertical: 24,
    borderRadius: 32,
    borderWidth: 1,
    alignItems: "center",
    gap: 8,
  },
  stormMessage: {
    fontSize: 18,
    fontWeight: "700",
    textAlign: "center",
    lineHeight: 24,
  },
  stormComfortText: {
    fontSize: 14,
    textAlign: "center",
    fontWeight: "500",
  },
  stormCatWrap: {
    marginBottom: 8,
  },
  stormCatImage: {
    width: 170,
    height: 170,
  },
  stormLightningBolt: {
    position: "absolute",
    width: 80,
    height: 200,
  },
  productCard: {
    width: "48%",
    borderRadius: 28,
    padding: 16,
    minHeight: 210,
  },
  productTagline: {
    fontSize: 12,
    color: "#4A3D5E",
  },
  productImage: {
    width: 100,
    height: 100,
    alignSelf: "center",
    marginVertical: 12,
    borderRadius: 16,
  },
  productTitle: {
    fontSize: 18,
    fontWeight: "700",
    color: "#1C1A2A",
  },
  productPrice: {
    marginTop: 4,
    color: "#1C1A2A",
  },
  temptationCard: {
    borderRadius: TEMPTATION_CARD_RADIUS,
    padding: 20,
    gap: 12,
    position: "relative",
    overflow: "visible",
  },
  temptationTextureContainer: {
    ...StyleSheet.absoluteFillObject,
    borderRadius: TEMPTATION_CARD_RADIUS,
    overflow: "hidden",
  },
  temptationTextureOverlay: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.18,
  },
  temptationTextureAccent: {
    transform: [{ rotate: "-8deg" }],
    opacity: 0.12,
    top: -80,
    bottom: -80,
  },
  temptationTextureHighlight: {
    opacity: 0.16,
    transform: [{ rotate: "14deg" }],
    left: "-20%",
    right: "-20%",
    top: "-60%",
    bottom: "-60%",
  },
  temptationSwipeWrapper: {
    marginBottom: 16,
    position: "relative",
  },
  temptationSwipeBackground: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    paddingHorizontal: 16,
  },
  temptationTutorialSwipeHint: {
    borderRadius: TEMPTATION_CARD_RADIUS,
    ...Platform.select({
      android: {
        borderWidth: 0,
        borderColor: "transparent",
        backgroundColor: "transparent",
      },
      default: {
        borderColor: "#F6C16B",
        backgroundColor: "rgba(246,193,107,0.12)",
        borderWidth: 2,
      },
    }),
  },
  swipeHint: {
    borderWidth: 1,
    borderRadius: 24,
    paddingHorizontal: 12,
    paddingVertical: 6,
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  swipeHintLeft: {
    justifyContent: "flex-start",
  },
  swipeHintRight: {
    justifyContent: "flex-end",
  },
  swipeHintIcon: {
    fontSize: 14,
  },
  swipeHintText: {
    fontSize: 12,
    fontWeight: "600",
  },
  temptationHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  temptationEmoji: {
    fontSize: 28,
  },
  emojiDisplayWrapper: {
    width: 40,
    alignItems: "center",
  },
  temptationBadgeStack: {
    position: "absolute",
    top: 0,
    right: 0,
    alignItems: "flex-end",
    gap: 4,
  },
  temptationPinnedBadge: {
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 10,
    paddingVertical: 4,
  },
  temptationPinnedBadgeText: {
    fontSize: 11,
    fontWeight: "700",
  },
  temptationTitle: {
    fontSize: 18,
    fontWeight: "700",
    flex: 1,
    flexWrap: "wrap",
  },
  titleEditWrapper: {
    flex: 1,
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  titleEditInputContainer: {
    flex: 1,
    position: "relative",
  },
  titleEditInput: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 14,
    paddingVertical: 6,
    fontSize: 18,
    fontWeight: "700",
  },
  emojiEditWrapper: {
    width: 60,
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 12,
    paddingVertical: 6,
    justifyContent: "center",
    position: "relative",
  },
  emojiEditInput: {
    textAlign: "center",
    fontSize: 18,
    fontWeight: "700",
    paddingRight: 14,
  },
  temptationDesc: {
    lineHeight: 20,
    marginTop: 4,
    marginBottom: 8,
  },
  temptationPriceRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginTop: 6,
    marginBottom: 6,
  },
  temptationPricePill: {
    paddingVertical: 6,
    paddingHorizontal: 14,
    borderRadius: 16,
    borderWidth: 1,
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  pricePillInput: {
    minWidth: 60,
    fontSize: 20,
    fontWeight: "700",
    borderWidth: 0,
    backgroundColor: "transparent",
  },
  temptationPrice: {
    fontSize: 20,
    fontWeight: "700",
  },
  temptationGoalBadge: {
    alignSelf: "flex-start",
    paddingHorizontal: 8,
    paddingVertical: 3,
    borderRadius: 999,
    borderWidth: 1,
    marginBottom: 6,
  },
  temptationGoalBadgeFloating: {
    alignSelf: "flex-end",
    marginBottom: 0,
  },
  temptationGoalBadgeEditable: {
    flexDirection: "row",
    alignItems: "center",
  },
  temptationGoalBadgeText: {
    fontSize: 10,
    fontWeight: "700",
  },
  temptationGoalBadgeInline: {
    marginLeft: 12,
    marginTop: 2,
  },
  categoryEditSection: {
    marginTop: 10,
    gap: 6,
  },
  categoryEditLabel: {
    ...createSecondaryText({ fontSize: 11, textTransform: "uppercase" }),
  },
  temptationFocusBadge: {
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 999,
    borderWidth: 1,
    marginBottom: 6,
  },
  temptationFocusBadgeText: {
    ...createCtaText({ fontSize: 11 }),
  },
  temptationStreakBadge: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 8,
    paddingVertical: 3,
    borderRadius: 999,
    borderWidth: 1,
    gap: 4,
    minHeight: 22,
  },
  temptationStreakEmoji: {
    fontSize: 12,
  },
  temptationStreakText: {
    ...createCtaText({ fontSize: 10 }),
  },
  temptationStreakBadgeFloating: {
    position: "absolute",
    top: -26,
    right: -2,
    zIndex: 2,
  },
  editPriceText: {
    fontSize: 13,
    fontWeight: "600",
  },
  temptationRefuseMeta: {
    fontSize: 12,
    marginBottom: 6,
  },
  temptationTimerBlock: {
    marginTop: 8,
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 12,
    borderWidth: 1,
  },
  temptationTimerTitle: {
    fontSize: 13,
    fontWeight: "600",
  },
  temptationTimerCountdown: {
    fontSize: 12,
    marginTop: 2,
    fontWeight: "500",
  },
  temptationFeedbackOverlay: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    borderRadius: 28,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 24,
  },
  temptationFeedbackText: {
    fontSize: 18,
    fontWeight: "700",
    textAlign: "center",
  },
  coinBurst: {
    position: "absolute",
    bottom: 32,
    left: "50%",
    marginLeft: -8,
    width: 16,
    height: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: "#E9A600",
    backgroundColor: "#FFD766",
    shadowColor: "#E9A600",
    shadowOpacity: 0.4,
    shadowRadius: 4,
    shadowOffset: { width: 0, height: 2 },
    elevation: 4,
    justifyContent: "center",
    alignItems: "center",
  },
  coinBurstInner: {
    width: 8,
    height: 8,
    borderRadius: 4,
    backgroundColor: "#FFF4B3",
  },
  temptationEditor: {
    marginTop: 8,
    borderTopWidth: StyleSheet.hairlineWidth,
    paddingTop: 12,
    gap: 14,
  },
  temptationEditorField: {
    gap: 6,
  },
  editorLabelRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  temptationEditorActions: {
    gap: 8,
  },
  temptationBadge: {
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 999,
    borderWidth: 1,
  },
  temptationBadgeText: {
    fontSize: 12,
    fontWeight: "600",
    textTransform: "uppercase",
  },
  temptationActions: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginTop: 8,
  },
  temptationTutorialAccent: {
    borderWidth: 2,
    borderColor: "#F6C16B",
    borderRadius: 28,
    padding: 12,
    backgroundColor: "rgba(246,193,107,0.08)",
    zIndex: 2,
  },
  temptationButtonPrimary: {
    flexGrow: 1,
    borderRadius: 16,
    paddingVertical: 12,
    alignItems: "center",
  },
  temptationButtonPrimaryText: {
    fontWeight: "700",
    fontSize: 14,
  },
  temptationButtonGhost: {
    flexGrow: 1,
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 10,
    alignItems: "center",
  },
  temptationButtonGhostText: {
    fontWeight: "600",
  },
  temptationButtonOutline: {
    flexGrow: 1,
    borderRadius: 16,
    paddingVertical: 10,
    borderWidth: 1,
    alignItems: "center",
  },
  temptationButtonOutlineText: {
    fontWeight: "600",
  },
  temptationTutorialAccentButton: {
    borderWidth: 2,
    borderColor: "#F6C16B",
    backgroundColor: "rgba(246,193,107,0.16)",
    shadowColor: "rgba(246,193,107,0.45)",
    shadowOpacity: Platform.OS === "ios" ? 0.7 : 0.5,
    shadowRadius: 20,
    shadowOffset: { width: 0, height: 12 },
  },
  detailBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.4)",
    justifyContent: "center",
    padding: 24,
  },
  detailCard: {
    borderRadius: 30,
    padding: 20,
  },
  detailHero: {
    borderRadius: 24,
    padding: 24,
    alignItems: "center",
    marginBottom: 16,
  },
  detailImage: {
    width: 160,
    height: 160,
  },
  detailTitle: {
    fontSize: 26,
    fontWeight: "700",
  },
  detailTagline: {
    marginTop: 6,
    fontWeight: "600",
  },
  detailPrice: {
    fontSize: 20,
    fontWeight: "700",
    marginTop: 8,
  },
  detailRating: {
    marginTop: 4,
    fontSize: 14,
  },
  detailDesc: {
    marginTop: 12,
    lineHeight: 20,
  },
  tutorialBackdrop: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  tutorialBackdropDim: {
    backgroundColor: "rgba(0,0,0,0.55)",
  },
  tutorialCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 28,
    padding: 24,
    borderWidth: 1,
    gap: 12,
  },
  tutorialHighlightFocus: {
    position: "absolute",
    ...Platform.select({
      android: {
        borderWidth: 0,
        borderColor: "transparent",
        elevation: 0,
      },
      default: {
        borderWidth: 2,
        borderColor: "#F6C16B",
        shadowColor: "rgba(246,193,107,0.65)",
        shadowOpacity: 0.95,
        shadowRadius: 32,
        shadowOffset: { width: 0, height: 18 },
      },
    }),
  },
  tutorialIcon: {
    fontSize: 32,
    textAlign: "center",
  },
  tutorialTitle: {
    fontSize: 22,
    fontWeight: "800",
    textAlign: "center",
  },
  tutorialDescription: {
    fontSize: 15,
    lineHeight: 20,
    textAlign: "center",
  },
  tutorialProgressRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginTop: 8,
  },
  tutorialDots: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  tutorialDot: {
    width: 10,
    height: 10,
    borderRadius: 5,
  },
  tutorialProgressText: {
    fontSize: 12,
    fontWeight: "600",
  },
  tutorialActions: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    marginTop: 4,
  },
  tutorialSkipButton: {
    flex: 1,
    paddingVertical: 12,
  },
  tutorialSkipText: {
    textAlign: "center",
    fontSize: 14,
    fontWeight: "600",
  },
  tutorialPrimaryButton: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: 16,
    alignItems: "center",
  },
  tutorialPrimaryText: {
    fontSize: 15,
    fontWeight: "700",
  },
  variantRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    marginTop: 18,
    gap: 10,
  },
  variantPill: {
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 10,
    paddingHorizontal: 14,
  },
  variantText: {
    fontWeight: "600",
  },
  variantPrice: {
    fontSize: 12,
    marginTop: 4,
  },
  primaryButton: {
    borderRadius: 24,
    paddingVertical: 16,
    alignItems: "center",
    marginTop: 22,
  },
  primaryButtonText: {
    ...createCtaText({ fontSize: 16 }),
  },
  secondaryButtonClear: {
    alignItems: "center",
    paddingVertical: 12,
  },
  secondaryButtonClearText: {
    ...createCtaText({ fontSize: 14 }),
  },
  secondaryButton: {
    borderRadius: 24,
    paddingVertical: 14,
    alignItems: "center",
    marginTop: 12,
    borderWidth: 1,
  },
  secondaryButtonText: {
    ...createCtaText(),
  },
  closeButton: {
    alignSelf: "flex-end",
  },
  closeButtonText: {
    fontSize: 28,
  },
  header: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 30,
    marginBottom: 16,
  },
  subheader: {
    ...TYPOGRAPHY.blockTitle,
    marginTop: 24,
    marginBottom: 12,
  },
  emptyState: {
    alignItems: "center",
    paddingVertical: 60,
  },
  emptyStateTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 20,
  },
  emptyStateText: {
    ...createBodyText({ textAlign: "center", marginTop: 6 }),
  },
  cartEmptyState: {
    alignItems: "center",
    paddingVertical: 60,
    gap: 12,
  },
  catImage: {
    width: 160,
    height: 160,
    opacity: 0.4,
    borderRadius: 32,
  },
  catImageLarge: {
    width: 220,
    height: 220,
    opacity: 0.9,
  },
  cartEmptyTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 22,
  },
  cartEmptySubtitle: {
    ...createBodyText({ fontSize: 16, textAlign: "center" }),
  },
  cartCard: {
    flexDirection: "row",
    alignItems: "center",
    borderRadius: 28,
    padding: 16,
    marginBottom: 14,
  },
  cartImageWrap: {
    width: 70,
    height: 70,
    borderRadius: 22,
    backgroundColor: "#F1F2F6",
    alignItems: "center",
    justifyContent: "center",
    marginRight: 14,
  },
  cartTitleText: {
    fontSize: 16,
    fontWeight: "700",
  },
  cartVariant: {
    marginTop: 4,
  },
  cartRight: {
    alignItems: "flex-end",
  },
  cartPrice: {
    fontWeight: "700",
  },
  cartBuyButton: {
    marginTop: 6,
    borderRadius: 16,
    paddingHorizontal: 14,
    paddingVertical: 6,
  },
  cartBuyText: {
    fontSize: 12,
    fontWeight: "600",
  },
  cartRemove: {
    marginTop: 4,
    fontSize: 12,
  },
  wishCard: {
    borderRadius: 28,
    padding: 18,
    marginBottom: 16,
    gap: 10,
    position: "relative",
  },
  goalSwipeRow: {
    marginBottom: 20,
    overflow: "hidden",
    position: "relative",
  },
  goalSwipeActions: {
    position: "absolute",
    left: 0,
    top: 0,
    bottom: 0,
    width: 160,
    justifyContent: "center",
    alignItems: "flex-start",
    paddingVertical: 12,
    paddingHorizontal: 12,
    gap: 10,
    zIndex: 0,
  },
  goalSwipeButton: {
    paddingVertical: 8,
    paddingHorizontal: 10,
    borderRadius: 12,
    borderWidth: 1,
  },
  goalSwipeButtonDisabled: {
    opacity: 0.4,
  },
  goalSwipeButtonText: {
    ...createCtaText({ fontSize: 14 }),
  },
  goalSwipeContent: {
    width: "100%",
    zIndex: 1,
  },
  wishHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-start",
  },
  wishTitleWrap: {
    flexDirection: "row",
    alignItems: "center",
    flex: 1,
    marginRight: 12,
    gap: 8,
  },
  wishEmoji: {
    fontSize: 22,
  },
  wishTitle: {
    fontSize: 18,
    fontWeight: "700",
    flex: 1,
    paddingRight: 0,
  },
  wishSavedHint: {
    fontSize: 12,
    marginTop: 2,
  },
  wishBadge: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "transparent",
    backgroundColor: "rgba(0,0,0,0.04)",
  },
  wishBadgeText: {
    fontSize: 12,
    fontWeight: "700",
  },
  wishMeta: {
    fontSize: 13,
    marginBottom: 4,
  },
  wishProgressRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    marginTop: 6,
  },
  wishProgressTrack: {
    flex: 1,
    height: 10,
    borderRadius: 999,
    overflow: "hidden",
  },
  wishProgressBar: {
    height: 10,
    borderRadius: 999,
    overflow: "hidden",
    marginTop: 8,
    marginBottom: 12,
  },
  wishProgressFill: {
    height: "100%",
    borderRadius: 999,
  },
  wishProgressLabel: {
    ...createSecondaryText({ fontSize: 13 }),
  },
  wishButtonGhost: {
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 12,
    paddingHorizontal: 16,
    justifyContent: "center",
    alignItems: "center",
  },
  goalDragWrapper: {
    flexDirection: "row",
    alignItems: "stretch",
    gap: 10,
    paddingVertical: 4,
  },
  goalDragWrapperActive: {
    opacity: 0.94,
  },
  goalDragHandle: {
    width: 32,
    alignItems: "center",
    justifyContent: "center",
    borderRadius: 16,
    paddingVertical: 18,
    marginRight: 4,
  },
  goalDragHandleDots: {
    fontSize: 18,
    fontWeight: "700",
  },
  goalDragCardActive: {
    transform: [{ scale: 0.995 }],
  },
  primaryGoalCard: {
    borderRadius: 36,
    padding: 28,
    overflow: "hidden",
  },
  primaryGoalAura: {
    position: "absolute",
    width: 220,
    height: 220,
    borderRadius: 110,
    top: -60,
    right: -40,
  },
  primaryGoalTop: {
    flexDirection: "row",
    alignItems: "flex-start",
    gap: 16,
  },
  primaryGoalBadge: {
    borderRadius: 999,
    paddingHorizontal: 14,
    paddingVertical: 6,
    borderWidth: 1,
    alignSelf: "flex-start",
  },
  primaryGoalBadgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  primaryGoalTitle: {
    ...TYPOGRAPHY.blockTitle,
  },
  primaryGoalSubtitle: {
    ...createBodyText({ fontSize: 15, marginTop: 6 }),
  },
  primaryGoalEmblem: {
    width: 64,
    height: 64,
    borderRadius: 32,
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 1,
  },
  primaryGoalProgressRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    marginTop: 18,
  },
  primaryGoalProgressTrack: {
    flex: 1,
    height: 14,
    borderRadius: 999,
    overflow: "hidden",
  },
  primaryGoalProgressFill: {
    height: "100%",
    borderRadius: 999,
  },
  primaryGoalPercent: {
    ...createBodyText({ fontSize: 16, fontWeight: "800" }),
  },
  pendingCard: {
    borderRadius: 24,
    padding: 18,
    gap: 12,
  },
  pendingSwipeWrapper: {
    position: "relative",
  },
  pendingSwipeBackground: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    justifyContent: "flex-end",
    alignItems: "center",
    paddingHorizontal: 16,
    flexDirection: "row",
  },
  pendingHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    gap: 12,
  },
  pendingTitle: {
    ...createBodyText({ fontSize: 18, fontWeight: "700", flex: 1 }),
  },
  pendingDue: {
    ...createCtaText({ fontSize: 13, textTransform: "uppercase" }),
  },
  pendingPrice: {
    fontSize: 16,
    fontWeight: "600",
  },
  pendingButtons: {
    flexDirection: "row",
    gap: 10,
  },
  pendingCountdown: {
    fontSize: 20,
    fontWeight: "800",
    marginTop: 6,
  },
  pendingButtonPrimary: {
    flex: 1,
    borderRadius: 16,
    paddingVertical: 12,
    alignItems: "center",
  },
  pendingButtonPrimaryText: {
    ...createCtaText(),
  },
  pendingButtonSecondary: {
    borderWidth: 1,
    borderRadius: 16,
    paddingHorizontal: 16,
    paddingVertical: 12,
    alignItems: "center",
  },
  cartTotalRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginTop: 12,
  },
  cartTotalText: {
    ...createBodyText({ fontSize: 18, fontWeight: "600" }),
  },
  cartTotalAmount: {
    ...createBodyText({ fontSize: 18, fontWeight: "700" }),
  },
  buyAllButton: {
    marginTop: 18,
    borderRadius: 24,
    paddingVertical: 16,
    alignItems: "center",
  },
  buyAllButtonText: {
    ...createCtaText(),
  },
  purchasesSubtitle: {
    marginBottom: 16,
  },
  progressCard: {
    borderRadius: 26,
    padding: 18,
    marginBottom: 20,
  },
  progressTextRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginBottom: 12,
  },
  progressLabel: {
    textTransform: "uppercase",
    fontSize: 12,
  },
  progressValue: {
    fontSize: 32,
    fontWeight: "800",
  },
  progressGoal: {
    fontWeight: "700",
  },
  progressBar: {
    height: 12,
    borderRadius: 12,
    overflow: "hidden",
  },
  progressFill: {
    height: "100%",
    borderRadius: 12,
  },
  progressHint: {
    marginTop: 10,
  },
  purchaseCard: {
    borderRadius: 24,
    padding: 16,
    marginBottom: 14,
  },
  purchaseInfo: {
    marginBottom: 8,
  },
  purchaseTitle: {
    fontWeight: "700",
  },
  purchaseDesc: {
    marginTop: 4,
  },
  purchasePrice: {
    fontWeight: "700",
  },
  levelWidget: {
    borderRadius: 28,
    padding: 20,
    borderWidth: 1,
    gap: 12,
  },
  levelWidgetHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  levelWidgetTitle: {
    fontSize: 18,
    fontWeight: "800",
  },
  levelWidgetBadge: {
    borderRadius: 999,
    paddingHorizontal: 14,
    paddingVertical: 6,
  },
  levelWidgetBadgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  levelWidgetSubtitle: {
    ...createBodyText({ fontSize: 14, fontWeight: "600" }),
  },
  levelWidgetBar: {
    height: 8,
    borderRadius: 16,
    overflow: "hidden",
    marginTop: 8,
  },
  levelWidgetFill: {
    height: "100%",
    borderRadius: 16,
  },
  levelWidgetMeta: {
    ...createSecondaryText({ fontSize: 13 }),
  },
  goalCard: {
    borderRadius: 24,
    padding: 20,
    marginBottom: 12,
    gap: 12,
    position: "relative",
  },
  goalTitle: {
    ...createBodyText({ fontWeight: "700", fontSize: 16 }),
  },
  goalDesc: {
    ...createBodyText({ marginTop: 4 }),
  },
  rewardHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
  },
  rewardBadge: {
    borderRadius: 999,
    paddingHorizontal: 12,
    paddingVertical: 5,
    alignSelf: "flex-start",
  },
  rewardBadgeFloating: {
    position: "absolute",
    top: 0,
    right: -6,
  },
  rewardBadgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  rewardBadgeContainer: {
    position: "absolute",
    top: -8,
    right: -10,
    padding: 0,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "flex-end",
    width: "100%",
    pointerEvents: "none",
  },
  healthRewardTokenRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  healthRewardTokenRowCompact: {
    gap: 6,
  },
  healthRewardToken: {
    flexDirection: "row",
    alignItems: "center",
    gap: 4,
  },
  healthRewardTokenIcon: {
    width: 18,
    height: 18,
    resizeMode: "contain",
  },
  healthRewardTokenCount: {
    ...createCtaText({ fontSize: 12 }),
  },
  rewardClaimButton: {
    borderRadius: 16,
    paddingVertical: 10,
    paddingHorizontal: 20,
    marginTop: 6,
  },
  rewardClaimButtonText: {
    ...createCtaText({ fontSize: 14, textAlign: "center", width: "100%" }),
  },
  rewardsTabs: {
    flexDirection: "row",
    gap: 10,
    marginTop: 4,
    marginBottom: 4,
  },
  rewardsTabButton: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 10,
    alignItems: "center",
  },
  rewardsTabText: {
    ...createCtaText({ fontSize: 14 }),
  },
  challengeCard: {
    borderRadius: 22,
    padding: 18,
    gap: 12,
    borderWidth: 1,
    position: "relative",
  },
  challengeHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  challengeEmoji: {
    fontSize: 28,
  },
  challengeTitle: {
    ...createBodyText({ fontSize: CHALLENGE_TITLE_FONT_SIZE, fontWeight: "700" }),
  },
  challengeDesc: {
    ...createBodyText({ fontSize: CHALLENGE_DESC_FONT_SIZE, lineHeight: CHALLENGE_LINE_HEIGHT }),
  },
  challengeMetaRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  challengeStatus: {
    ...createCtaText({ fontSize: CHALLENGE_META_FONT_SIZE, textTransform: "uppercase" }),
  },
  challengeTimer: {
    ...createSecondaryText({ fontSize: CHALLENGE_META_FONT_SIZE }),
    textAlign: "right",
  },
  challengeProgressBar: {
    height: 8,
    borderRadius: 999,
    overflow: "hidden",
  },
  challengeProgressFill: {
    height: "100%",
    borderRadius: 999,
  },
  challengeProgressLabel: {
    ...createSecondaryText({ fontSize: CHALLENGE_META_FONT_SIZE }),
  },
  challengeDotRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  challengeDot: {
    width: 18,
    height: 18,
    borderRadius: 9,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  challengeDotCheck: {
    fontSize: 11,
    fontWeight: "700",
  },
  challengePotential: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  challengeLockRow: {
    borderRadius: 14,
    borderWidth: 1,
    borderColor: "transparent",
    paddingVertical: 10,
    alignItems: "center",
  },
  challengeLockText: {
    ...createSecondaryText({ fontSize: 12 }),
    textTransform: "uppercase",
    letterSpacing: 0.6,
  },
  challengeCardLocked: {
    opacity: 1,
  },
  challengeActionButton: {
    borderRadius: 16,
    paddingVertical: 12,
    alignItems: "center",
  },
  challengeActionText: {
    ...createCtaText(),
  },
  dailyChallengeWidget: {
    borderRadius: 24,
    padding: 18,
    borderWidth: 1,
    gap: 16,
  },
  dailyChallengeWidgetHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  dailyChallengeWidgetRewardRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  dailyChallengeMultiplierPill: {
    borderRadius: 999,
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderWidth: 1,
  },
  dailyChallengeMultiplierText: {
    fontSize: scaleFontSize(12),
    fontWeight: "800",
    letterSpacing: 0.4,
  },
  dailyChallengeWidgetBody: {
    flexDirection: "row",
    alignItems: "center",
    gap: 14,
  },
  dailyChallengeEmojiPill: {
    width: 54,
    height: 54,
    borderRadius: 18,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "rgba(0,0,0,0.06)",
  },
  dailyChallengeEmojiText: {
    fontSize: scaleFontSize(30),
  },
  dailyChallengeWidgetTitle: {
    fontSize: scaleFontSize(18),
    fontWeight: "800",
  },
  dailyChallengeWidgetDesc: {
    ...createBodyText({ fontSize: 14 }),
  },
  dailyChallengeProgressBar: {
    height: 8,
    borderRadius: 8,
    overflow: "hidden",
  },
  dailyChallengeProgressFill: {
    height: "100%",
    borderRadius: 8,
  },
  dailyChallengeWidgetFooter: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  dailyChallengeProgressLabel: {
    ...createSecondaryText({ fontSize: 13 }),
  },
  dailyChallengeRewardLabel: {
    fontSize: scaleFontSize(14),
    fontWeight: "800",
  },
  challengeRewardChip: {
    borderRadius: 999,
    paddingHorizontal: 10,
    paddingVertical: 4,
  },
  challengeRewardChipFloating: {
    position: "absolute",
    right: 10,
    top: -6,
  },
  challengeSwipeWrapper: {
    position: "relative",
    borderRadius: 22,
    backgroundColor: "transparent",
  },
  challengeSwipeActions: {
    position: "absolute",
    right: 0,
    top: 0,
    bottom: 0,
    width: CHALLENGE_SWIPE_ACTION_WIDTH,
    justifyContent: "center",
    alignItems: "center",
    borderRadius: 22,
    overflow: "hidden",
  },
  challengeSwipeButton: {
    borderRadius: 16,
    paddingVertical: 12,
    paddingHorizontal: 10,
    width: "80%",
    alignItems: "center",
  },
  challengeSwipeButtonText: {
    ...createCtaText({ fontSize: 13, textAlign: "center" }),
  },
  goalProgressBar: {
    height: 8,
    borderRadius: 999,
    overflow: "hidden",
    marginTop: 16,
    marginBottom: 8,
  },
  goalProgressFill: {
    height: "100%",
    borderRadius: 999,
  },
  profileCard: {
    borderRadius: 30,
    padding: 24,
    alignItems: "center",
    marginBottom: 20,
  },
  profileMoodAura: {
    alignItems: "center",
    width: "100%",
    marginBottom: 12,
  },
  profileMoodGradient: {
    width: 170,
    height: 170,
    borderRadius: 85,
    justifyContent: "center",
    alignItems: "center",
    padding: 8,
  },
  profileMoodStatus: {
    ...createCtaText({ fontSize: 13, textTransform: "uppercase", marginTop: 10 }),
  },
  profileScrollContent: {
    paddingTop: 4,
    paddingBottom: 40,
    flexGrow: 1,
  },
  profileAvatarWrap: {
    alignItems: "center",
    marginBottom: 0,
    position: "relative",
  },
  profileAvatar: {
    width: 120,
    height: 120,
    borderRadius: 60,
  },
  profileNameRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  rewardBadgeSmall: {
    borderRadius: 999,
    paddingHorizontal: 10,
    paddingVertical: 4,
  },
  rewardBadgeSmallText: {
    ...createCtaText({ fontSize: 12 }),
  },
  profileAvatarHint: {
    ...createSecondaryText({ fontSize: 12, marginTop: 12, textAlign: "center" }),
  },
  profileAvatarEditBadge: {
    position: "absolute",
    top: 6,
    right: 6,
    width: 32,
    height: 32,
    borderRadius: 16,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  profileAvatarEditIcon: {
    fontSize: 15,
    fontWeight: "700",
  },
  profileName: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: scaleFontSize(28),
  },
  profileSubtitle: {
    ...createBodyText({ marginTop: 4 }),
    fontSize: PROFILE_SUBTITLE_FONT_SIZE,
    lineHeight: PROFILE_SUBTITLE_LINE_HEIGHT,
    textAlign: "center",
  },
  profileBio: {
    ...createBodyText({ marginTop: 10, textAlign: "center", lineHeight: 20 }),
  },
  profileStatsRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    width: "100%",
    marginTop: 20,
  },
  profileStat: {
    alignItems: "center",
    flex: 1,
    paddingHorizontal: 2,
  },
  profileStatValueRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 4,
  },
  profileStatValue: {
    ...createBodyText({ fontWeight: "700" }),
  },
  profileStatValueSuffix: {
    ...createBodyText({ fontWeight: "700" }),
  },
  profileStatLabel: {
    ...createCtaText({
      fontSize: PROFILE_STAT_LABEL_FONT_SIZE,
      textTransform: "uppercase",
      marginTop: 4,
      letterSpacing: PROFILE_STAT_LETTER_SPACING,
    }),
    textAlign: "center",
    flexShrink: 1,
  },
  profileActions: {
    width: "100%",
    marginTop: 20,
    gap: 12,
  },
  profileActionPrimary: {
    paddingVertical: 14,
    borderRadius: 24,
    alignItems: "center",
  },
  profileActionPrimaryText: {
    ...createCtaText(),
  },
  profileActionSecondary: {
    paddingVertical: 14,
    borderRadius: 24,
    alignItems: "center",
    borderWidth: 1,
  },
  profileActionSecondaryText: {
    ...createCtaText(),
  },
  profileInput: {
    width: "100%",
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 16,
    paddingVertical: 10,
    marginBottom: 10,
  },
  profileInputPlaceholder: {
    fontSize: IS_COMPACT_DEVICE ? 13 : 14,
  },
  goalTargetInputWrap: {
    flexDirection: "row",
    alignItems: "center",
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 16,
    paddingVertical: 10,
    gap: 10,
  },
  goalTargetInput: {
    flex: 1,
    fontSize: 16,
    fontWeight: "600",
  },
  goalTargetCurrency: {
    fontWeight: "700",
  },
  goalTargetRow: {
    width: "100%",
    marginBottom: 12,
    gap: 6,
  },
  goalTargetLabel: {
    fontSize: 13,
    fontWeight: "600",
  },
  profileInputHalf: {
    flex: 1,
    width: "auto",
  },
  profileHintText: {
    fontSize: 12,
    lineHeight: 18,
  },
  profileSettingValue: {
    fontSize: 16,
    fontWeight: "600",
  },
  profileBioInput: {
    height: 90,
    textAlignVertical: "top",
  },
  inputRow: {
    flexDirection: "row",
    gap: 10,
    width: "100%",
  },
  settingsCard: {
    borderRadius: 26,
    padding: 20,
    marginBottom: 40,
  },
  profileSection: {
    marginBottom: 16,
    gap: 12,
  },
  settingsDivider: {
    height: 1,
    width: "100%",
    backgroundColor: "rgba(0,0,0,0.05)",
    marginVertical: 8,
  },
  settingsTitle: {
    fontSize: 20,
    fontWeight: "700",
    marginBottom: 16,
  },
  settingRow: {
    marginBottom: 18,
  },
  settingRowContent: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  settingLabel: {
    marginBottom: 8,
  },
  settingValue: {
    fontSize: 16,
    fontWeight: "600",
  },
  settingChoices: {
    flexDirection: "row",
    gap: 12,
    flexWrap: "wrap",
  },
  settingCurrencyScrollWrapper: {
    position: "relative",
    marginTop: 4,
    marginRight: -32,
    paddingRight: 32,
  },
  settingCurrencyScroll: {
    marginTop: 0,
  },
  settingCurrencyScrollContent: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    paddingRight: 16,
  },
  profileGoalGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 10,
  },
  profileGoalOption: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    borderWidth: 1,
    borderRadius: 20,
    paddingVertical: 8,
    paddingHorizontal: 12,
  },
  profileGoalEmoji: {
    fontSize: 18,
  },
  profileGoalText: {
    fontWeight: "600",
  },
  goalTargetBlock: {
    width: "100%",
    borderWidth: 1,
    borderRadius: 18,
    padding: 14,
    gap: 8,
  },
  goalTargetHeader: {
    gap: 4,
    marginBottom: 4,
  },
  goalTargetTitle: {
    fontSize: 15,
    fontWeight: "700",
  },
  goalTargetHint: {
    fontSize: 12,
  },
  guideCards: {
    width: "100%",
    gap: 12,
  },
  guideCard: {
    borderRadius: 22,
    padding: 18,
    borderWidth: 1,
    gap: 8,
  },
  guideEmoji: {
    fontSize: 28,
  },
  guideTitle: {
    fontSize: 16,
    fontWeight: "700",
  },
  guideDesc: {
    fontSize: 13,
    lineHeight: 18,
  },
  settingToggle: {
    width: 48,
    height: 28,
    borderRadius: 16,
    borderWidth: 1,
    padding: 2,
    justifyContent: "center",
  },
  settingToggleHandle: {
    width: 22,
    height: 22,
    borderRadius: 12,
  },
  settingChip: {
    paddingHorizontal: 14,
    paddingVertical: 8,
    borderRadius: 18,
    borderWidth: 1,
  },
  resetButton: {
    marginTop: Platform.OS === "ios" ? 16 : 8,
    paddingVertical: 12,
    borderWidth: 1,
    borderRadius: 18,
    alignItems: "center",
  },
  analyticsCard: {
    borderRadius: 26,
    padding: 20,
    marginBottom: 24,
  },
  analyticsTitle: {
    fontSize: 18,
    fontWeight: "700",
    marginBottom: 12,
  },
  analyticsRow: {
    flexDirection: "row",
    gap: 12,
  },
  analyticsItem: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 14,
    paddingHorizontal: 12,
    alignItems: "center",
  },
  analyticsValue: {
    fontSize: 22,
    fontWeight: "800",
  },
  analyticsLabel: {
    marginTop: 6,
    fontSize: 12,
    textAlign: "center",
  },
  historyCard: {
    borderRadius: 26,
    padding: 20,
    marginBottom: 80,
  },
  historyTitle: {
    fontSize: 20,
    fontWeight: "700",
    marginBottom: 12,
  },
  historyEmpty: {
    fontSize: 14,
  },
  historyList: {
    borderWidth: StyleSheet.hairlineWidth,
    borderRadius: 20,
  },
  historyListContent: {
    paddingHorizontal: 12,
  },
  historyItem: {
    paddingVertical: 12,
  },
  historyRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  historyDeleteBtn: {
    width: 32,
    height: 32,
    borderWidth: 1,
    borderRadius: 16,
    alignItems: "center",
    justifyContent: "center",
  },
  historyDeleteText: {
    fontSize: 16,
    fontWeight: "700",
  },
  historyItemTitle: {
    ...createBodyText({ fontWeight: "600" }),
  },
  historyItemMeta: {
    ...createSecondaryText({ marginTop: 4 }),
  },
  profileLinkButton: {
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 10,
    paddingHorizontal: 14,
    marginBottom: 16,
    gap: 2,
  },
  profileLinkText: {
    ...createCtaText({ fontSize: 14 }),
  },
  profileLinkHint: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  resetButtonText: {
    ...createCtaText(),
  },
  tabBar: {
    flexDirection: "row",
    borderTopWidth: 1,
    paddingHorizontal: 12,
    overflow: "visible",
  },
  tabBarDimmed: {
    opacity: 0.35,
  },
  tabButton: {
    flex: 1,
    paddingVertical: 14,
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
  },
  tabButtonHighlight: {
    borderWidth: 1,
    borderRadius: 18,
    marginHorizontal: 4,
    paddingHorizontal: 10,
    shadowColor: "#000",
    shadowOpacity: 0.08,
    shadowRadius: 8,
    shadowOffset: { width: 0, height: 4 },
    elevation: 4,
  },
  tabButtonText: {
    ...createCtaText({ fontSize: 13, textTransform: "uppercase" }),
    marginTop: 6,
  },
  tabLockIconOverlay: {
    fontSize: 12,
    lineHeight: 14,
    position: "absolute",
    top: 4,
    left: "50%",
    marginLeft: -7,
    textAlign: "center",
    textAlignVertical: "center",
  },
  tabBadge: {
    minWidth: 20,
    height: 20,
    borderRadius: 10,
    paddingHorizontal: 6,
    alignItems: "center",
    justifyContent: "center",
  },
  tabBadgeFloating: {
    position: "absolute",
    top: -6,
    right: -2,
  },
  tabBadgeText: {
    ...createCtaText({ fontSize: 11, textTransform: "none" }),
  },
  analyticsConsentScreen: {
    flex: 1,
    justifyContent: "flex-start",
    padding: 24,
    paddingTop: 48,
    gap: 20,
  },
  analyticsConsentCard: {
    borderRadius: 32,
    borderWidth: 1,
    padding: 28,
    gap: 20,
  },
  analyticsConsentTitle: {
    ...TYPOGRAPHY.blockTitle,
  },
  analyticsConsentBody: {
    ...createBodyText({ lineHeight: 22 }),
  },
  analyticsConsentPrimary: {
    borderRadius: 20,
    paddingVertical: 14,
    alignItems: "center",
  },
  analyticsConsentPrimaryText: {
    ...createCtaText({ fontSize: 15 }),
  },
  analyticsConsentSecondary: {
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
  },
  analyticsConsentSecondaryText: {
    ...createCtaText({ fontSize: 14 }),
  },
  modalContainer: {
    flex: 1,
    justifyContent: "flex-end",
    backgroundColor: "rgba(0,0,0,0.4)",
  },
  paySheet: {
    borderTopLeftRadius: 30,
    borderTopRightRadius: 30,
    padding: 24,
  },
  modalTitle: {
    fontSize: 28,
    fontWeight: "700",
    marginBottom: 16,
  },
  payCard: {
    borderRadius: 22,
    padding: 18,
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 14,
  },
  payLabel: {
    fontSize: 12,
    textTransform: "uppercase",
  },
  payDigits: {
    marginTop: 6,
    fontSize: 16,
  },
  payAmount: {
    fontWeight: "700",
    fontSize: 20,
  },
  payOptions: {
    flexDirection: "row",
    gap: 12,
    marginBottom: 10,
  },
  payOptionChip: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 10,
    alignItems: "center",
  },
  partialInputWrap: {
    marginTop: 6,
  },
  partialLabel: {
    marginBottom: 6,
  },
  partialInput: {
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 16,
    paddingVertical: 10,
  },
  partialInfo: {
    ...createBodyText({ marginVertical: 12, textAlign: "center" }),
  },
  appleButton: {
    paddingVertical: 16,
    borderRadius: 26,
    alignItems: "center",
    marginTop: 12,
  },
  appleButtonText: {
    ...createCtaText({ fontSize: 16 }),
  },
  payCancel: {
    ...createSecondaryText({ textAlign: "center", marginTop: 12 }),
  },
  fabCenterContainer: {
    position: "absolute",
    bottom: FAB_CONTAINER_BOTTOM,
    left: 0,
    right: 0,
    alignItems: "center",
    justifyContent: "center",
  },
  fabButtonWrapper: {
    width: FAB_BUTTON_SIZE,
    height: FAB_BUTTON_SIZE,
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
  },
  cartBadge: {
    width: FAB_BUTTON_SIZE,
    height: FAB_BUTTON_SIZE,
    borderRadius: FAB_BUTTON_SIZE / 2,
    justifyContent: "center",
    alignItems: "center",
    shadowColor: "#000",
    shadowOpacity: 0.2,
    shadowOffset: { width: 0, height: 2 },
    shadowRadius: 4,
    elevation: 4,
    borderWidth: 1,
  },
  cartBadgeHighlight: {
    borderColor: "#F5C869",
    shadowColor: "#F5C869",
    shadowOpacity: 0.85,
    shadowRadius: 16,
    elevation: 8,
    borderWidth: 2,
    borderRadius: FAB_BUTTON_SIZE / 2,
  },
  cartBadgeIcon: {
    fontSize: 20,
    lineHeight: 20,
    fontWeight: "700",
    letterSpacing: 0.5,
    textAlign: "center",
    textAlignVertical: "center",
    includeFontPadding: false,
  },
  fabMenuOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "flex-end",
    alignItems: "center",
    paddingBottom: 180,
    paddingHorizontal: 24,
  },
  fabMenuBackdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(0,0,0,0.15)",
  },
  fabOption: {
    alignItems: "center",
    justifyContent: "center",
  },
  fabOptionRow: {
    alignSelf: "center",
  },
  fabOptionRowContent: {
    flexDirection: "row",
    gap: 12,
  },
  fabCircle: {
    width: 88,
    height: 88,
    borderRadius: 44,
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 1,
    paddingHorizontal: 8,
  },
  fabOptionText: {
    fontSize: 13,
    fontWeight: "700",
    textAlign: "center",
    lineHeight: 16,
  },
  fabTutorialBackdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "transparent",
    justifyContent: "flex-end",
    alignItems: "center",
  },
  fabTutorialOverlaySvg: {
    ...StyleSheet.absoluteFillObject,
  },
  fabTutorialContent: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "flex-end",
    alignItems: "center",
    paddingHorizontal: 24,
  },
  fabTutorialHalo: {
    position: "absolute",
    width: FAB_TUTORIAL_HALO_SIZE,
    height: FAB_TUTORIAL_HALO_SIZE,
    borderRadius: FAB_TUTORIAL_HALO_SIZE / 2,
    borderWidth: 2,
    top: -FAB_TUTORIAL_HALO_INSET,
    left: -FAB_TUTORIAL_HALO_INSET,
    shadowOpacity: 0.65,
    shadowRadius: 28,
    shadowOffset: { width: 0, height: 6 },
    elevation: 6,
    zIndex: -1,
  },
  fabTutorialCard: {
    width: "90%",
    maxWidth: 360,
    borderRadius: 24,
    paddingHorizontal: 20,
    paddingVertical: 20,
    borderWidth: 1,
  },
  fabTutorialTitle: {
    fontSize: 18,
    fontWeight: "700",
    textAlign: "center",
    marginBottom: 8,
  },
  fabTutorialDescription: {
    fontSize: 15,
    lineHeight: 21,
    textAlign: "center",
    marginBottom: 16,
  },
  fabTutorialButton: {
    borderRadius: 16,
    paddingVertical: 12,
    paddingHorizontal: 16,
  },
  fabTutorialButtonText: {
    fontSize: 15,
    fontWeight: "700",
    textAlign: "center",
  },
  quickModalBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.4)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  quickModalCard: {
    width: "100%",
    borderRadius: 28,
    padding: 20,
    gap: 14,
  },
  coinValueHero: {
    height: 140,
    borderRadius: 22,
    backgroundColor: LEVEL_SHARE_BG,
    borderWidth: 1,
    borderColor: "rgba(255,180,71,0.6)",
    justifyContent: "center",
    alignItems: "center",
    overflow: "hidden",
  },
  coinValueHeroGlow: {
    position: "absolute",
    top: -40,
    right: -20,
    width: 140,
    height: 140,
    borderRadius: 70,
    backgroundColor: "rgba(255,180,71,0.25)",
  },
  coinValueHeroCat: {
    width: 92,
    height: 92,
    resizeMode: "contain",
  },
  coinValueHeroFooter: {
    position: "absolute",
    bottom: 12,
    right: 14,
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  coinValueHeroLogo: {
    width: 18,
    height: 18,
    resizeMode: "contain",
  },
  coinValueHeroBrand: {
    color: LEVEL_SHARE_MUTED,
    fontSize: 12,
    fontWeight: "600",
  },
  quickModalTitle: {
    fontSize: 20,
    fontWeight: "700",
  },
  quickModalSubtitle: {
    fontSize: 14,
    lineHeight: 20,
  },
  quickModalActions: {
    flexDirection: "row",
    gap: 12,
    width: "100%",
  },
  quickModalSecondary: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 16,
    justifyContent: "center",
    alignItems: "center",
    paddingVertical: 12,
  },
  quickModalSecondaryText: {
    fontWeight: "600",
  },
  quickModalPrimary: {
    flex: 1,
    borderRadius: 16,
    justifyContent: "center",
    alignItems: "center",
    paddingVertical: 12,
  },
  quickModalPrimaryText: {
    ...createCtaText(),
  },
  coinEntryBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.55)",
    padding: 24,
    justifyContent: "center",
    alignItems: "center",
  },
  coinEntryCard: {
    width: "100%",
    maxWidth: 420,
    borderRadius: 32,
    padding: 22,
    borderWidth: 1,
    gap: 16,
  },
  coinEntryHeader: {
    flexDirection: "row",
    alignItems: "flex-start",
    gap: 12,
  },
  coinEntryTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 24,
  },
  coinEntrySubtitle: {
    ...createBodyText({ fontSize: 15, lineHeight: 20 }),
  },
  coinEntryClose: {
    padding: 4,
  },
  coinEntryCloseText: {
    fontSize: 20,
    fontWeight: "700",
  },
  coinEntryAmountRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  coinEntryAmount: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 28,
  },
  coinEntryManualTapHint: {
    ...createBodyText({ fontSize: 12, lineHeight: 16 }),
    textAlign: "center",
    marginTop: 6,
  },
  coinSliderWrapper: {
    marginTop: 20,
    alignItems: "center",
    justifyContent: "center",
    minHeight: COIN_SLIDER_SIZE + 40,
    width: "100%",
  },
  coinSliderBackdrop: {
    position: "absolute",
    width: "100%",
    height: "100%",
    borderRadius: 24,
  },
  coinCircle: {
    width: COIN_SLIDER_SIZE,
    height: COIN_SLIDER_SIZE,
    borderRadius: COIN_SLIDER_SIZE / 2,
    borderWidth: 3,
    backgroundColor: "#F6F8FC",
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden",
    shadowOpacity: 0.25,
    shadowRadius: 18,
    shadowOffset: { width: 0, height: 12 },
    elevation: 12,
  },
  coinInnerSurface: {
    width: COIN_SLIDER_SIZE - 24,
    height: COIN_SLIDER_SIZE - 24,
    borderRadius: (COIN_SLIDER_SIZE - 24) / 2,
    backgroundColor: "#ECEFF5",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.8)",
    justifyContent: "center",
    alignItems: "center",
    overflow: "hidden",
  },
  coinFillTrack: {
    position: "absolute",
    bottom: 0,
    width: "100%",
    alignItems: "center",
  },
  coinFill: {
    width: "100%",
    borderTopLeftRadius: (COIN_SLIDER_SIZE - 24) / 2,
    borderTopRightRadius: (COIN_SLIDER_SIZE - 24) / 2,
  },
  coinShine: {
    position: "absolute",
    top: 18,
    left: 26,
    width: 86,
    height: 14,
    borderRadius: 14,
    opacity: 0.6,
  },
  coinCurrencySymbol: {
    fontSize: 48,
    fontWeight: "800",
    opacity: 0.2,
  },
  coinDirectionLabels: {
    flexDirection: "row",
    justifyContent: "space-between",
    width: "100%",
    paddingHorizontal: 16,
    marginTop: 12,
  },
  coinDirectionLabel: {
    fontSize: 13,
    fontWeight: "700",
    textTransform: "uppercase",
  },
  coinEntryActions: {
    flexDirection: "row",
    gap: 12,
    marginTop: 16,
  },
  coinEntryActionButton: {
    flex: 1,
    borderRadius: 20,
    paddingVertical: 14,
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "#000",
    shadowOpacity: 0.08,
    shadowRadius: 8,
    shadowOffset: { width: 0, height: 4 },
    elevation: 4,
  },
  coinEntryActionButtonSpend: {
    backgroundColor: COIN_ENTRY_SPEND_BACKGROUND,
  },
  coinEntryActionButtonSave: {
    backgroundColor: COIN_ENTRY_SAVE_BACKGROUND,
  },
  coinEntryActionButtonText: {
    fontSize: 16,
    fontWeight: "700",
  },
  coinEntryActionButtonTextSpend: {
    color: SPEND_ACTION_COLOR,
  },
  coinEntryActionButtonTextSave: {
    color: SAVE_ACTION_COLOR,
  },
  coinEntryHint: {
    ...createBodyText({ fontSize: 13 }),
  },
  coinEntryCategoryLabel: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 18,
  },
  coinEntryError: {
    fontSize: 12,
    fontWeight: "600",
  },
  coinEntryCategoryScroll: {
    width: "100%",
  },
  coinEntryCategoryRow: {
    flexDirection: "row",
    gap: 10,
    paddingHorizontal: 4,
  },
  coinEntryCategoryButton: {
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 14,
    paddingHorizontal: 8,
    alignItems: "center",
    gap: 6,
  },
  coinEntryCategoryEmoji: {
    fontSize: 28,
  },
  coinEntryCategoryText: {
    fontSize: 10,
    fontWeight: "700",
    textAlign: "center",
  },
  coinEntryMaxLabel: {
    fontSize: 14,
    fontWeight: "600",
  },
  coinEntryManualBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.6)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  coinEntryManualCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 28,
    padding: 20,
    borderWidth: 1,
    gap: 12,
  },
  coinEntryManualTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 20,
  },
  coinEntryManualInput: {
    borderWidth: 1,
    borderRadius: 16,
    paddingHorizontal: 14,
    paddingVertical: 10,
    fontSize: 18,
    fontWeight: "600",
  },
  coinEntryManualError: {
    fontSize: 12,
    fontWeight: "600",
  },
  coinEntryManualActions: {
    flexDirection: "row",
    gap: 12,
  },
  coinEntryManualButtonGhost: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 12,
    alignItems: "center",
  },
  coinEntryManualButtonGhostText: {
    fontWeight: "600",
  },
  coinEntryManualButtonPrimary: {
    flex: 1,
    borderRadius: 16,
    paddingVertical: 12,
    alignItems: "center",
  },
  coinEntryManualButtonPrimaryText: {
    ...createCtaText(),
  },
  termsCard: {
    width: "100%",
    borderRadius: 28,
    padding: 22,
    gap: 12,
  },
  termsTitle: {
    ...TYPOGRAPHY.blockTitle,
    textAlign: "center",
  },
  termsSubtitle: {
    ...createBodyText({ fontSize: 15, lineHeight: 22, textAlign: "center" }),
  },
  termsScroll: {
    maxHeight: 260,
    marginVertical: 4,
  },
  termsScrollContent: {
    paddingBottom: 4,
    gap: 12,
  },
  termsPoint: {
    flexDirection: "row",
    gap: 8,
  },
  termsPointIndex: {
    ...createCtaText({ fontSize: 13 }),
  },
  termsPointText: {
    ...createBodyText({ flex: 1, fontSize: 15, lineHeight: 22 }),
  },
  termsLinkButton: {
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 10,
    alignItems: "center",
  },
  termsLinkText: {
    ...createCtaText({ fontSize: 14 }),
  },
  termsHint: {
    ...createSecondaryText({ fontSize: 12, textAlign: "center" }),
  },
  languageMascot: {
    width: 220,
    height: 220,
    alignSelf: "center",
    marginBottom: 4,
  },
  confettiLayer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  overlayFullScreen: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
  },
  overlayTouchable: {
    ...StyleSheet.absoluteFillObject,
  },
  overlayDim: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(5, 6, 15, 0.2)",
  },
  celebrationBanner: {
    position: "absolute",
    top: "35%",
    paddingHorizontal: 28,
    paddingVertical: 20,
    borderRadius: 30,
    alignItems: "center",
    gap: 12,
  },
  celebrationText: {
    fontWeight: "700",
    fontSize: 18,
    textAlign: "center",
  },
  celebrationSubtext: {
    fontWeight: "600",
    fontSize: 14,
    textAlign: "center",
  },
  focusDigestCard: {
    width: "86%",
    borderRadius: 30,
    borderWidth: 1,
    padding: 24,
    gap: 14,
  },
  focusDigestTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 22,
    textAlign: "center",
  },
  focusDigestBody: {
    ...createBodyText({ fontSize: 15, lineHeight: 22 }),
    textAlign: "center",
  },
  focusDigestStats: {
    flexDirection: "row",
    gap: 12,
  },
  focusDigestStat: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 18,
    padding: 12,
    gap: 4,
  },
  focusDigestLabel: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase" }),
  },
  focusDigestValue: {
    ...createBodyText({ fontSize: 15, fontWeight: "700" }),
  },
  focusDigestHint: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  focusDigestButtons: {
    flexDirection: "row",
    gap: 12,
    marginTop: 6,
  },
  focusDigestPrimary: {
    flex: 1,
    borderRadius: 16,
    paddingVertical: 12,
    paddingHorizontal: 12,
    alignItems: "center",
  },
  focusDigestPrimaryText: {
    ...createCtaText({ fontSize: 12 }),
  },
  focusDigestSecondary: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 12,
    paddingHorizontal: 12,
    alignItems: "center",
  },
  focusDigestSecondaryText: {
    ...createCtaText({ fontSize: 12 }),
  },
  focusRewardCard: {
    width: "82%",
    borderRadius: 30,
    borderWidth: 1,
    padding: 24,
    gap: 14,
    alignItems: "center",
  },
  focusRewardIconRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  focusRewardCoin: {
    width: 48,
    height: 48,
  },
  focusRewardAmount: {
    ...createCtaText({ fontSize: 24 }),
  },
  focusRewardTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 24,
    textAlign: "center",
  },
  focusRewardBody: {
    ...createBodyText({ fontSize: 15, lineHeight: 22 }),
    textAlign: "center",
  },
  focusRewardButton: {
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 24,
    paddingVertical: 10,
  },
  focusRewardButtonText: {
    ...createCtaText({ fontSize: 14 }),
  },
  impulseCategoryPicker: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  impulseCategoryPickerScroll: {
    width: "100%",
  },
  impulseCategoryPickerScrollContent: {
    paddingVertical: 2,
    paddingHorizontal: 4,
  },
  impulseCategoryPickerCompact: {
    marginTop: 2,
  },
  impulseCategoryChip: {
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 6,
    paddingHorizontal: 14,
  },
  impulseCategoryChipCompact: {
    paddingVertical: 4,
    paddingHorizontal: 12,
  },
  impulseCategoryChipText: {
    ...createCtaText({ fontSize: 9 }),
  },
  impulseCategoryChipTextCompact: {
    fontSize: 8,
  },
  impulseAlertCard: {
    marginHorizontal: 24,
    borderRadius: 28,
    borderWidth: 1,
    overflow: "hidden",
    position: "relative",
  },
  impulseAlertGlow: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.18,
  },
  impulseAlertContent: {
    padding: 24,
    gap: 16,
    position: "relative",
  },
  impulseAlertHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  impulseAlertBadge: {
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 999,
    borderWidth: 1,
  },
  impulseAlertBadgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  impulseAlertEmoji: {
    fontSize: 28,
  },
  impulseAlertTitle: {
    ...TYPOGRAPHY.blockTitle,
  },
  impulseAlertBody: {
    ...createBodyText({ fontSize: 15, lineHeight: 22 }),
  },
  impulseAlertStats: {
    flexDirection: "row",
    gap: 12,
  },
  impulseAlertStat: {
    flex: 1,
    borderRadius: 18,
    padding: 14,
    borderWidth: 1,
  },
  impulseAlertStatLabel: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase" }),
  },
  impulseAlertStatValue: {
    ...createBodyText({ fontSize: 18, fontWeight: "800", marginTop: 6 }),
  },
  impulseAlertMoodCard: {
    borderRadius: 18,
    borderWidth: 1,
    padding: 12,
  },
  impulseAlertMood: {
    ...createBodyText({ fontSize: 14, lineHeight: 20 }),
  },
  impulseAlertButton: {
    borderRadius: 16,
    paddingVertical: 13,
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "row",
    gap: 8,
  },
  impulseAlertButtonText: {
    ...createCtaText({ fontSize: 15 }),
  },
  impulseAlertButtonIcon: {
    ...createCtaText({ fontSize: 16 }),
  },
  celebrationCat: {
    width: 90,
    height: 90,
    borderRadius: 18,
    opacity: 0.9,
  },
  catHappy: {
    transform: [{ scale: 1.05 }],
  },
  catSad: {
    opacity: 0.7,
  },
  levelOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
  },
  levelBackdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(255,247,214,0.95)",
  },
  levelContent: {
    padding: 28,
    borderRadius: 32,
    backgroundColor: "rgba(255,255,255,0.95)",
    borderWidth: 2,
    borderColor: "rgba(255,186,0,0.4)",
    alignItems: "center",
    gap: 12,
  },
  levelTitle: {
    ...TYPOGRAPHY.display,
    fontSize: 32,
  },
  levelSubtitle: {
    ...createBodyText({ fontSize: 16, fontWeight: "700", textAlign: "center" }),
  },
  levelShareButton: {
    borderRadius: 999,
    paddingVertical: 10,
    paddingHorizontal: 26,
    marginTop: 8,
  },
  levelShareButtonText: {
    ...createCtaText({ fontSize: 14 }),
  },
  rewardOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
  },
  rewardBackdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(255,241,225,0.92)",
  },
  rewardCard: {
    paddingVertical: 30,
    paddingHorizontal: 24,
    borderRadius: 36,
    alignItems: "center",
    width: OVERLAY_CARD_MAX_WIDTH,
    maxWidth: OVERLAY_CARD_MAX_WIDTH,
    borderWidth: 2,
    borderColor: "rgba(255,181,115,0.7)",
    gap: 12,
  },
  rewardCat: {
    width: 140,
    height: 140,
    marginBottom: 8,
  },
  rewardTitle: {
    fontSize: 22,
    fontWeight: "800",
    textAlign: "center",
  },
  rewardSubtitle: {
    fontSize: 16,
    fontWeight: "600",
    textAlign: "center",
  },
  healthOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
  },
  healthBackdrop: {
    ...StyleSheet.absoluteFillObject,
  },
  healthHeartWrap: {
    width: 220,
    height: 220,
    borderRadius: 110,
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 20,
  },
  healthCoinImage: {
    width: 140,
    height: 140,
    resizeMode: "contain",
  },
  healthCard: {
    paddingHorizontal: 24,
    paddingVertical: 24,
    borderRadius: 30,
    borderWidth: 1,
    alignItems: "center",
    width: OVERLAY_CARD_MAX_WIDTH,
    maxWidth: OVERLAY_CARD_MAX_WIDTH,
  },
  healthTitle: {
    fontSize: 24,
    fontWeight: "800",
    textAlign: "center",
  },
  healthSubtitle: {
    fontSize: 16,
    marginTop: 8,
    textAlign: "center",
  },
  goalCelebrateOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
  },
  goalCelebrateBackdrop: {
    ...StyleSheet.absoluteFillObject,
  },
  goalCelebrateCard: {
    paddingVertical: 26,
    paddingHorizontal: 22,
    borderRadius: 34,
    borderWidth: 2,
    alignItems: "stretch",
    width: OVERLAY_CARD_MAX_WIDTH,
    maxWidth: OVERLAY_CARD_MAX_WIDTH,
    maxHeight: SCREEN_HEIGHT * 0.78,
    gap: 16,
  },
  goalCelebrateContent: {
    gap: 16,
    paddingBottom: 4,
  },
  goalCelebrateHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 16,
  },
  goalCelebrateCat: {
    width: 96,
    height: 96,
  },
  goalCelebrateHeaderText: {
    flex: 1,
    gap: 6,
  },
  goalCelebrateTitle: {
    fontSize: 24,
    fontWeight: "900",
  },
  goalCelebrateSubtitle: {
    fontSize: 16,
    fontWeight: "600",
  },
  goalCelebrateTarget: {
    fontSize: 15,
    fontWeight: "700",
  },
  goalCelebrateBadge: {
    alignSelf: "flex-start",
    borderRadius: 999,
    borderWidth: 1,
    paddingVertical: 6,
    paddingHorizontal: 14,
  },
  goalCelebrateBadgeText: {
    ...createCtaText({ fontSize: 12 }),
  },
  goalCelebrateTotal: {
    borderRadius: 20,
    borderWidth: 1,
    paddingVertical: 14,
    paddingHorizontal: 16,
    gap: 6,
  },
  goalCelebrateTotalLabel: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase" }),
  },
  goalCelebrateTotalValue: {
    ...TYPOGRAPHY.display,
    fontSize: 28,
  },
  goalCelebrateTotalSub: {
    ...createBodyText({ fontSize: 13, lineHeight: 18 }),
  },
  goalCelebratePraise: {
    ...createBodyText({ fontSize: 13, lineHeight: 18, fontWeight: "700" }),
  },
  goalCelebrateRewardRow: {
    marginTop: 6,
    borderRadius: 12,
    paddingVertical: 8,
    paddingHorizontal: 10,
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  goalCelebrateRewardCoin: {
    width: 20,
    height: 20,
    resizeMode: "contain",
  },
  goalCelebrateRewardText: {
    ...createBodyText({ fontSize: 12, fontWeight: "700" }),
  },
  goalCelebrateStatsRow: {
    flexDirection: "row",
    gap: 12,
  },
  goalCelebrateStatCard: {
    flex: 1,
    borderRadius: 16,
    borderWidth: 1,
    paddingVertical: 12,
    paddingHorizontal: 12,
    gap: 4,
  },
  goalCelebrateStatLabel: {
    ...createCtaText({ fontSize: 10, textTransform: "uppercase" }),
  },
  goalCelebrateStatValue: {
    ...createBodyText({ fontSize: 18, fontWeight: "800" }),
  },
  goalCelebrateWeek: {
    gap: 8,
  },
  goalCelebrateSectionLabel: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase" }),
  },
  goalCelebrateWeekBars: {
    flexDirection: "row",
    alignItems: "flex-end",
    gap: 6,
  },
  goalCelebrateWeekBarWrap: {
    flex: 1,
    alignItems: "center",
  },
  goalCelebrateWeekBar: {
    width: 10,
    borderRadius: 6,
  },
  goalCelebrateInsights: {
    gap: 12,
  },
  goalCelebrateCta: {
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  goalCelebrateCtaText: {
    ...createCtaText({ fontSize: 14 }),
  },
  goalCelebrateInsightCard: {
    borderRadius: 18,
    borderWidth: 1,
    paddingVertical: 12,
    paddingHorizontal: 14,
    gap: 8,
  },
  goalCelebrateInsightHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  goalCelebrateInsightIcon: {
    fontSize: 18,
  },
  goalCelebrateInsightTitle: {
    ...createBodyText({ fontSize: 15, fontWeight: "800" }),
  },
  goalCelebrateInsightBody: {
    ...createBodyText({ fontSize: 13, lineHeight: 19 }),
  },
  goalCelebrateBreakdown: {
    gap: 10,
  },
  goalCelebrateBreakdownList: {
    gap: 10,
  },
  goalCelebrateBreakdownRow: {
    borderRadius: 14,
    paddingVertical: 10,
    paddingHorizontal: 12,
    backgroundColor: "rgba(0,0,0,0.04)",
  },
  goalCelebrateBreakdownTitle: {
    ...createBodyText({ fontSize: 14, fontWeight: "700" }),
  },
  goalCelebrateBreakdownMeta: {
    ...createBodyText({ fontSize: 12, lineHeight: 18 }),
  },
  heartRain: {
    ...StyleSheet.absoluteFillObject,
  },
  heartRainDrop: {
    position: "absolute",
    top: -40,
    textShadowColor: "rgba(0,0,0,0.25)",
    textShadowOffset: { width: 0, height: 2 },
    textShadowRadius: 6,
  },
  rewardHeart: {
    position: "absolute",
    bottom: 40,
    fontSize: 22,
    textShadowColor: "rgba(0,0,0,0.35)",
    textShadowRadius: 6,
  },
  dailyRewardOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
  },
  dailyRewardBackdrop: {
    ...StyleSheet.absoluteFillObject,
  },
  dailyRewardCard: {
    width: "86%",
    borderRadius: 28,
    borderWidth: 1,
    padding: 22,
    alignItems: "center",
  },
  dailyRewardBadge: {
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 14,
    paddingVertical: 6,
    alignSelf: "flex-start",
  },
  dailyRewardBadgeText: {
    fontSize: 13,
    fontWeight: "700",
    letterSpacing: 0.6,
    textTransform: "uppercase",
  },
  dailyRewardHero: {
    alignItems: "center",
    marginTop: 18,
    marginBottom: 12,
  },
  dailyRewardCoinWrap: {
    width: 96,
    height: 96,
    borderRadius: 48,
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 14,
    shadowColor: "#000",
    shadowOpacity: 0.12,
    shadowOffset: { width: 0, height: 8 },
    shadowRadius: 16,
    elevation: 6,
  },
  dailyRewardCoinLarge: {
    width: 54,
    height: 54,
    resizeMode: "contain",
  },
  dailyRewardAmountLarge: {
    fontSize: 36,
    fontWeight: "800",
    marginBottom: 6,
  },
  dailyRewardTitle: {
    fontSize: 18,
    fontWeight: "700",
    textAlign: "center",
  },
  dailyRewardReason: {
    fontSize: 14,
    lineHeight: 20,
    textAlign: "center",
    marginTop: 6,
    marginBottom: 14,
  },
  dailyRewardFooter: {
    borderTopWidth: 1,
    paddingTop: 12,
    width: "100%",
    alignItems: "center",
  },
  dailyRewardHint: {
    fontSize: 13,
    fontWeight: "600",
    textTransform: "uppercase",
    letterSpacing: 0.5,
  },
  levelCoin: {
    position: "absolute",
    borderRadius: 999,
    backgroundColor: "#FFD93D",
  },
  saveOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
  },
  primaryTemptationOverlayCardContainer: {
    width: OVERLAY_CARD_MAX_WIDTH,
    maxWidth: OVERLAY_CARD_MAX_WIDTH,
    borderRadius: 34,
    padding: 20,
    borderWidth: 1,
    gap: 16,
  },
  primaryTemptationOverlayTitle: {
    fontSize: 20,
    fontWeight: "800",
    textAlign: "center",
  },
  primaryTemptationCard: {
    width: "100%",
  },
  primaryTemptationDismiss: {
    alignSelf: "center",
    paddingHorizontal: 18,
    paddingVertical: 8,
    borderRadius: 24,
    borderWidth: 1,
  },
  primaryTemptationDismissText: {
    fontSize: 14,
    fontWeight: "600",
  },
  saveCelebrationOverlay: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: "center",
    alignItems: "center",
  },
  saveCelebrationCard: {
    paddingVertical: 26,
    paddingHorizontal: 26,
    borderRadius: 34,
    alignItems: "center",
    width: OVERLAY_CARD_MAX_WIDTH,
    maxWidth: OVERLAY_CARD_MAX_WIDTH,
    borderWidth: 2,
    gap: 16,
  },
  saveCelebrationPrimary: {
    gap: 18,
  },
  saveCelebrationCat: {
    width: 150,
    height: 150,
    resizeMode: "contain",
    marginBottom: 4,
  },
  saveCelebrationTitle: {
    fontSize: 22,
    fontWeight: "900",
    textAlign: "center",
  },
  saveCelebrationSubtitle: {
    fontSize: 18,
    fontWeight: "700",
    textAlign: "center",
  },
  saveRewardRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderRadius: 16,
  },
  saveRewardIcon: {
    width: 26,
    height: 26,
    resizeMode: "contain",
  },
  saveRewardText: {
    fontSize: 15,
    fontWeight: "700",
  },
  saveQuote: {
    fontSize: 16,
    fontWeight: "600",
    textAlign: "center",
    opacity: 0.9,
  },
  saveProgressSection: {
    width: "100%",
    alignItems: "center",
    gap: 8,
  },
  saveProgressTrack: {
    width: SAVE_PROGRESS_BAR_WIDTH,
    height: 12,
    borderRadius: 999,
    overflow: "hidden",
  },
  saveProgressFill: {
    height: "100%",
    borderRadius: 999,
  },
  saveProgressLabelRow: {
    width: SAVE_PROGRESS_BAR_WIDTH,
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  saveProgressValue: {
    fontSize: 22,
    fontWeight: "900",
  },
  saveProgressHint: {
    fontSize: 14,
    fontWeight: "600",
  },
  saveCountdownCard: {
    position: "absolute",
    gap: 16,
    overflow: "hidden",
  },
  saveCountdownGlow: {
    position: "absolute",
    top: -40,
    left: -60,
    right: -60,
    bottom: -40,
    borderRadius: 999,
  },
  saveCountdownTitle: {
    fontSize: 18,
    fontWeight: "800",
    textAlign: "center",
  },
  saveCountdownGoal: {
    fontSize: 18,
    fontWeight: "800",
    textAlign: "center",
  },
  saveCountdownGoalPrefix: {
    fontSize: 16,
    fontWeight: "600",
    textAlign: "center",
    marginTop: 4,
  },
  saveCounterRow: {
    flexDirection: "row",
    gap: 8,
    alignItems: "center",
    justifyContent: "center",
  },
  saveCounterSeparator: {
    paddingHorizontal: 2,
    paddingVertical: 6,
  },
  saveCounterSeparatorText: {
    fontSize: 28,
    fontWeight: "800",
  },
  saveCounterSpace: {
    width: 12,
  },
  saveCounterDigit: {
    width: 58,
    height: SAVE_COUNTER_DIGIT_HEIGHT,
    borderRadius: 18,
    padding: 2,
    shadowColor: "#000",
    shadowOpacity: 0.15,
    shadowRadius: 14,
    shadowOffset: { width: 0, height: 6 },
    elevation: 4,
  },
  saveCounterDigitSurface: {
    flex: 1,
    borderRadius: 16,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: "rgba(0,0,0,0.08)",
    alignItems: "center",
    justifyContent: "center",
  },
  saveCounterDigitColumn: {
    position: "absolute",
    top: -4,
    left: 0,
    right: 0,
    width: "100%",
    alignItems: "center",
    paddingVertical: 4,
  },
  saveCounterDigitText: {
    fontSize: 36,
    fontWeight: "800",
    fontVariant: ["tabular-nums"],
    textAlign: "center",
    height: SAVE_COUNTER_DIGIT_HEIGHT,
    lineHeight: SAVE_COUNTER_DIGIT_HEIGHT,
  },
  saveCounterDigitEdgeTop: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    height: SAVE_COUNTER_DIGIT_HEIGHT / 2,
    backgroundColor: "rgba(255,255,255,0.18)",
  },
  saveCounterDigitEdgeBottom: {
    position: "absolute",
    bottom: 0,
    left: 0,
    right: 0,
    height: SAVE_COUNTER_DIGIT_HEIGHT / 2,
    backgroundColor: "rgba(0,0,0,0.08)",
  },
  saveCounterDigitHighlight: {
    position: "absolute",
    top: 6,
    left: 6,
    right: 6,
    height: 16,
    borderRadius: 999,
    backgroundColor: "rgba(255,255,255,0.85)",
  },
  saveCounterDigitDivider: {
    position: "absolute",
    top: SAVE_COUNTER_DIGIT_HEIGHT / 2 - 1,
    left: 8,
    right: 8,
    height: 2,
    borderRadius: 999,
    backgroundColor: "rgba(0,0,0,0.18)",
  },
  saveRemainingCopy: {
    fontSize: 16,
    fontWeight: "600",
    textAlign: "center",
    opacity: 0.85,
  },
  customTemptationCard: {
    backgroundColor: "rgba(255,255,255,0.95)",
    borderRadius: 24,
    paddingVertical: 28,
    paddingHorizontal: 24,
    alignItems: "center",
    gap: 16,
    borderWidth: 1,
    borderColor: "rgba(18,15,40,0.08)",
    marginHorizontal: 24,
  },
  customTemptationGif: {
    width: 160,
    height: 160,
    borderRadius: 32,
    resizeMode: "contain",
  },
  customTemptationText: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 18,
    textAlign: "center",
  },
  rainLayer: {
    ...StyleSheet.absoluteFillObject,
  },
  rainDrop: {
    width: 2,
    borderRadius: 1,
    position: "absolute",
    top: 0,
  },
  sheetBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.35)",
    justifyContent: "flex-end",
  },
  sheetCard: {
    borderTopLeftRadius: 28,
    borderTopRightRadius: 28,
    paddingHorizontal: 24,
    paddingTop: 16,
    paddingBottom: 36,
    gap: 14,
  },
  sheetHandle: {
    width: 60,
    height: 4,
    borderRadius: 2,
    alignSelf: "center",
    marginBottom: 6,
  },
  sheetTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 20,
    textAlign: "center",
  },
  sheetSubtitle: {
    ...createBodyText({ fontSize: 15, textAlign: "center" }),
  },
  sheetButton: {
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
  },
  sheetCancel: {
    ...createCtaText({ textAlign: "center", marginTop: 4 }),
  },
  priceModalBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.35)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  priceModalCard: {
    width: "100%",
    borderRadius: 28,
    padding: 20,
    gap: 16,
  },
  priceModalTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 20,
    textAlign: "center",
  },
  priceModalLabel: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase", marginTop: 12, marginBottom: 4 }),
  },
  priceModalInput: {
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 16,
    paddingVertical: 10,
    fontSize: 18,
    textAlign: "center",
  },
  priceModalInputCompact: {
    borderWidth: 1,
    borderRadius: 14,
    paddingHorizontal: 12,
    paddingVertical: 8,
    fontSize: 16,
    textAlign: "left",
  },
  goalPickerButton: {
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 12,
    paddingHorizontal: 16,
  },
  goalPickerButtonText: {
    ...createCtaText({ fontSize: 15 }),
  },
  goalPickerReset: {
    marginTop: 6,
  },
  goalPickerResetText: {
    ...createSecondaryText({ fontSize: 13 }),
  },
  temptationEditOverlay: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    zIndex: 400,
    justifyContent: "center",
    alignItems: "center",
  },
  temptationEditBackdrop: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    backgroundColor: "#05060F",
  },
  temptationEditCardContainer: {
    width: "86%",
    maxWidth: 360,
    paddingHorizontal: 0,
    paddingTop: 0,
  },
  temptationOverlayCard: {
    width: "100%",
    alignSelf: "center",
    paddingHorizontal: 16,
    paddingVertical: 16,
    borderRadius: 24,
  },
  priceModalButtons: {
    gap: 10,
  },
  priceModalPrimary: {
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
  },
  priceModalPrimaryText: {
    fontWeight: "700",
  },
  priceModalSecondary: {
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
    borderWidth: 1,
  },
  priceModalSecondaryText: {
    fontWeight: "600",
  },
  priceModalCancel: {
    textAlign: "center",
    fontWeight: "600",
    marginTop: 4,
  },
  priceModalDeleteText: {
    textAlign: "center",
    fontWeight: "700",
    marginTop: 10,
  },
  goalModalCard: {
    width: "100%",
    borderRadius: 28,
    padding: 20,
    gap: 10,
  },
  goalModalTitle: {
    fontSize: 20,
    fontWeight: "700",
    textAlign: "center",
  },
  goalModalSubtitle: {
    fontSize: 14,
    lineHeight: 20,
    textAlign: "center",
  },
  streakRecoveryCard: {
    width: "88%",
    maxWidth: 360,
    borderRadius: 28,
    padding: 24,
    gap: 14,
    alignSelf: "center",
  },
  streakRecoveryTitle: {
    fontSize: 20,
    fontWeight: "700",
    textAlign: "center",
  },
  streakRecoveryBody: {
    fontSize: 15,
    lineHeight: 22,
    textAlign: "center",
  },
  streakRecoveryCoinRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    justifyContent: "center",
    alignItems: "center",
    gap: 6,
  },
  streakRecoveryCoinIcon: {
    width: 32,
    height: 32,
    resizeMode: "contain",
  },
  streakRecoveryCoinOverflow: {
    fontSize: 15,
    fontWeight: "600",
  },
  streakRecoveryErrorText: {
    textAlign: "center",
    fontSize: 14,
    fontWeight: "600",
    color: "#D9381E",
  },
  streakRecoveryActions: {
    flexDirection: "row",
    gap: 12,
  },
  streakRecoveryButton: {
    flex: 1,
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  streakRecoveryButtonSecondary: {
    borderWidth: 1,
  },
  streakRecoveryButtonPrimary: {},
  streakRecoveryButtonText: {
    fontWeight: "700",
  },
  goalOptionButton: {
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 12,
    paddingHorizontal: 16,
    marginTop: 10,
  },
  goalOptionTitle: {
    fontSize: 16,
    fontWeight: "600",
  },
  goalOptionSubtitle: {
    fontSize: 13,
    marginTop: 2,
  },
  goalRenewalBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.45)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  goalRenewalCard: {
    width: "100%",
    borderRadius: 32,
    borderWidth: 1,
    padding: 24,
    gap: 12,
  },
  goalRenewalTitle: {
    ...TYPOGRAPHY.blockTitle,
    textAlign: "center",
  },
  goalRenewalSubtitle: {
    ...createBodyText({ fontSize: 16, textAlign: "center", lineHeight: 22 }),
  },
  goalRenewalActions: {
    flexDirection: "row",
    gap: 12,
    marginTop: 8,
  },
  goalRenewalSecondary: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
  },
  goalRenewalSecondaryText: {
    ...createCtaText({ fontSize: 15 }),
  },
  goalRenewalPrimary: {
    flex: 1,
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
  },
  goalRenewalPrimaryText: {
    ...createCtaText({ fontSize: 15 }),
  },
  onboardContainer: {
    flex: 1,
    paddingHorizontal: BASE_HORIZONTAL_PADDING,
    paddingTop: 40,
    gap: 20,
  },
  onboardContent: {
    gap: 16,
    paddingBottom: 60,
  },
  onboardCenteredContent: {
    alignItems: "center",
  },
  onboardWideButton: {
    alignSelf: "stretch",
    width: "100%",
  },
  onboardContentWithFooter: {
    paddingBottom: 140,
  },
  onboardContentCompact: {
    gap: 12,
    paddingBottom: 40,
  },
  onboardHeaderRow: {
    flexDirection: "row",
    alignItems: "center",
    width: "100%",
  },
  onboardTitle: {
    ...TYPOGRAPHY.display,
  },
  onboardTitleCompact: {
    ...TYPOGRAPHY.display,
    fontSize: Math.max(TYPOGRAPHY.display.fontSize - 4, 26),
    lineHeight: Math.max(TYPOGRAPHY.display.fontSize - 2, 28),
  },
  personaTitleCompact: {
    ...TYPOGRAPHY.display,
    fontSize: Math.max(TYPOGRAPHY.display.fontSize - 8, 22),
    lineHeight: Math.max(TYPOGRAPHY.display.fontSize - 6, 24),
  },
  onboardSubtitle: {
    ...createBodyText({ fontSize: 16, lineHeight: 22 }),
  },
  onboardGuideContent: {
    gap: 12,
    paddingBottom: 24,
  },
  onboardFloatingActions: {
    position: "absolute",
    left: BASE_HORIZONTAL_PADDING,
    right: BASE_HORIZONTAL_PADDING,
    bottom: 24,
    paddingTop: 12,
  },
  onboardFloatingPrimary: {
    shadowColor: "#000",
    shadowOpacity: 0.15,
    shadowRadius: 12,
    shadowOffset: { width: 0, height: 4 },
    elevation: 6,
  },
  avatarPreview: {
    borderWidth: 1,
    borderRadius: 24,
    padding: 16,
    alignItems: "center",
  },
  primaryInput: {
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 16,
    paddingVertical: 12,
    fontSize: 16,
  },
  baselineInputGroup: {
    marginTop: 8,
    gap: 4,
  },
  baselineHint: {
    ...createSecondaryText({ fontSize: 14, lineHeight: 20 }),
  },
  avatarImage: {
    width: 120,
    height: 120,
    borderRadius: 60,
    marginBottom: 8,
  },
  avatarPlaceholder: {
    width: 120,
    height: 120,
    borderRadius: 60,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 8,
  },
  currencyLabel: {
    fontSize: 14,
    textTransform: "none",
    marginTop: 4,
  },
  currencyScrollWrapper: {
    marginTop: 12,
    position: "relative",
    marginRight: -32,
    paddingRight: 32,
  },
    currencyScroll: {
    marginTop: 0,
  },
  currencyScrollContent: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    paddingRight: 12,
  },
  currencyScrollFadeWrapper: {
    position: "absolute",
    right: 0,
    top: 0,
    bottom: 0,
    width: 40,
  },
  currencyScrollFade: {
    height: "100%",
  },
  currencyChipLarge: {
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 8,
    paddingHorizontal: 12,
  },
  goalGrid: {
    flex: 1,
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 12,
  },
  goalCustomSectionTitle: {
    ...createCtaText({ fontSize: 14, textTransform: "uppercase", marginTop: 16 }),
  },
  goalCustomButton: {
    borderWidth: 1,
    borderRadius: 22,
    paddingVertical: 14,
    alignItems: "center",
    marginTop: 16,
  },
  goalCustomButtonText: {
    ...createCtaText({ fontSize: 14 }),
  },
  goalOptionWrap: {
    width: "48%",
    gap: 8,
  },
  goalOption: {
    borderWidth: 1,
    borderRadius: 22,
    padding: 16,
    alignItems: "center",
    gap: 8,
  },
  goalTargetInline: {
    width: "100%",
  },
  personaGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 12,
  },
  personaCard: {
    width: "48%",
    borderWidth: 1,
    borderRadius: 22,
    padding: 16,
    gap: 6,
  },
  personaEmoji: {
    fontSize: 24,
  },
  personaTitle: {
    ...createBodyText({ fontWeight: "700", fontSize: 15 }),
  },
  personaSubtitleCard: {
    ...createBodyText({ fontSize: 14, lineHeight: 20 }),
  },
  goalEmoji: {
    fontSize: 28,
  },
  goalText: {
    ...createBodyText({ fontWeight: "600", textAlign: "center" }),
  },
  languageButtons: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 10,
  },
  languageTermsBlock: {
    width: "100%",
    marginTop: 12,
    gap: 6,
  },
  languageTermsNote: {
    ...createSecondaryText({ fontSize: 12, lineHeight: 16 }),
  },
  languageTermsButton: {
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 10,
    alignItems: "center",
  },
  languageTermsButtonText: {
    ...createCtaText({ fontSize: 13 }),
  },
  genderGrid: {
    flexDirection: "row",
    justifyContent: "space-between",
    gap: 12,
  },
  genderChip: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 20,
    paddingVertical: 12,
    alignItems: "center",
    gap: 6,
  },
  genderEmoji: {
    fontSize: 20,
  },
  genderLabel: {
    ...createBodyText({ fontWeight: "600" }),
  },
  languageButton: {
    flexGrow: 1,
    width: "48%",
    borderWidth: 1,
    borderRadius: 20,
    paddingVertical: 18,
    paddingHorizontal: 12,
    alignItems: "center",
  },
  onboardBackButton: {
    flexDirection: "row",
    alignItems: "center",
    alignSelf: "flex-start",
    borderWidth: 1,
    borderRadius: 999,
    paddingHorizontal: 14,
    paddingVertical: 6,
    gap: 6,
    marginBottom: 12,
  },
  onboardBackIcon: {
    fontSize: 14,
  },
  onboardBackLabel: {
    ...createCtaText({ fontSize: 13 }),
  },
  onboardSkipButton: {
    marginLeft: "auto",
    borderRadius: 999,
    paddingHorizontal: 16,
    paddingVertical: 8,
    backgroundColor: "#000000",
    marginBottom: 12,
  },
  onboardSkipLabel: {
    ...createCtaText({ fontSize: 13 }),
    color: "#FFFFFF",
  },
  languageHint: {
    ...createSecondaryText({ marginTop: 6, fontSize: 12 }),
  },
  goalTargetHint: {
    ...createSecondaryText({ fontSize: 13, marginTop: 8, marginBottom: 22 }),
  },
  logoSplashOverlay: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    zIndex: 1000,
  },
  logoSplash: {
    flex: 1,
    backgroundColor: "#fff",
    justifyContent: "center",
    alignItems: "center",
  },
  logoSplashImage: {
    width: 140,
    height: 140,
    marginBottom: 8,
  },
  logoSplashText: {
    ...TYPOGRAPHY.logo,
    fontSize: 48,
    letterSpacing: -0.5,
    color: "#111",
  },
});
function ImageSourceSheet({ visible, colors, t, onClose, onSelect }) {
  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onClose}
      statusBarTranslucent
    >
      <TouchableWithoutFeedback onPress={onClose}>
        <View style={styles.sheetBackdrop}>
          <TouchableWithoutFeedback onPress={() => {}}>
            <View style={[styles.sheetCard, { backgroundColor: colors.card }] }>
              <View style={[styles.sheetHandle, { backgroundColor: colors.border }]} />
              <Text style={[styles.sheetTitle, { color: colors.text }]}>{t("photoPromptTitle")}</Text>
              <Text style={[styles.sheetSubtitle, { color: colors.muted }]}>{t("photoPromptSubtitle")}</Text>
              <TouchableOpacity
                style={[styles.sheetButton, { borderColor: colors.border }]}
                onPress={() => onSelect("library")}
              >
                <Text style={{ color: colors.text }}>{t("photoLibrary")}</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.sheetButton, { borderColor: colors.border }]}
                onPress={() => onSelect("camera")}
              >
                <Text style={{ color: colors.text }}>{t("photoCamera")}</Text>
              </TouchableOpacity>
              <TouchableOpacity onPress={onClose}>
                <Text style={[styles.sheetCancel, { color: colors.muted }]}>{t("profileCancel")}</Text>
              </TouchableOpacity>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
}

function RegistrationScreen({
  data,
  onChange,
  onSubmit,
  onPickImage,
  colors,
  t,
  onBack,
  mascotImageSource,
  onSkip,
}) {
  const fallbackAvatar = mascotImageSource || CLASSIC_TAMAGOTCHI_ANIMATIONS.idle;
  const fade = useFadeIn();

  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView
        contentContainerStyle={styles.onboardContent}
        showsVerticalScrollIndicator={false}
        keyboardShouldPersistTaps="handled"
      >
        <OnboardingHeader onBack={onBack} colors={colors} t={t} />
        <Text style={[styles.onboardTitle, { color: colors.text }]}>{t("registrationTitle")}</Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("registrationSubtitle")}</Text>

        <TouchableOpacity
          style={[styles.avatarPreview, { borderColor: colors.border }]}
          onPress={() => onPickImage?.()}
        >
          {data.avatar ? (
            <Image source={{ uri: data.avatar }} style={styles.avatarImage} />
          ) : (
            <Image source={fallbackAvatar} style={styles.avatarImage} />
          )}
          <Text style={{ color: colors.muted }}>{t("photoTapHint")}</Text>
        </TouchableOpacity>

      <View style={styles.inputRow}>
        <TextInput
          style={[
            styles.profileInput,
            styles.profileInputHalf,
            { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
          ]}
          placeholder={t("inputFirstName")}
          placeholderTextColor={colors.muted}
          value={data.firstName}
          onChangeText={(text) => onChange("firstName", text)}
          returnKeyType="done"
          blurOnSubmit
          onSubmitEditing={Keyboard.dismiss}
        />
        <TextInput
          style={[
            styles.profileInput,
            styles.profileInputHalf,
            { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
          ]}
          placeholder={t("inputLastName")}
          placeholderTextColor={colors.muted}
          value={data.lastName}
          onChangeText={(text) => onChange("lastName", text)}
          returnKeyType="done"
          blurOnSubmit
          onSubmitEditing={Keyboard.dismiss}
        />
      </View>

        <TextInput
          style={[
            styles.profileInput,
            { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
          ]}
          placeholder={t("inputMotto")}
          placeholderTextColor={colors.muted}
          value={data.motto}
          onChangeText={(text) => onChange("motto", text)}
          returnKeyType="done"
          blurOnSubmit
          onSubmitEditing={Keyboard.dismiss}
        />

        <TouchableOpacity style={[styles.primaryButton, { backgroundColor: colors.text }]} onPress={onSubmit}>
          <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("nextButton")}</Text>
        </TouchableOpacity>
      </ScrollView>
    </Animated.View>
  );
}

function GoalScreen({
  selectedGoals = [],
  onToggle,
  onSubmit,
  goalTargets = {},
  onGoalTargetChange,
  currency,
  onRegisterGoalTargetFocus,
  colors,
  t,
  language,
  onBack,
  customGoals = [],
  onCustomGoalCreate,
  onSkip,
  onSkipStep,
}) {
  const fade = useFadeIn();
  const selection = Array.isArray(selectedGoals) ? selectedGoals : [];
  const targets = goalTargets && typeof goalTargets === "object" ? goalTargets : {};
  const resolvedCurrency = currency || DEFAULT_PROFILE.currency;
  const scrollRef = useRef(null);
  const inputRefs = useRef({});
  const layoutRefs = useRef({});
  const focusGoalTarget = useCallback((goalId) => {
    if (!goalId) return;
    const layout = layoutRefs.current[goalId];
    if (layout && scrollRef.current?.scrollTo) {
      scrollRef.current.scrollTo({ y: Math.max(0, layout.y - 32), animated: true });
    }
    setTimeout(() => {
      inputRefs.current?.[goalId]?.focus?.();
    }, 120);
  }, []);
  const handleGoalPress = useCallback(
    (goalId) => {
      const wasActive = selection.includes(goalId);
      onToggle?.(goalId);
      if (!wasActive) {
        setTimeout(() => {
          focusGoalTarget(goalId);
        }, 160);
      }
    },
    [focusGoalTarget, onToggle, selection]
  );
  const handleSubmit = useCallback(() => {
    onSubmit?.();
  }, [onSubmit]);
  useEffect(() => {
    onRegisterGoalTargetFocus?.(focusGoalTarget);
    return () => {
      onRegisterGoalTargetFocus?.(null);
    };
  }, [focusGoalTarget, onRegisterGoalTargetFocus]);
  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView
        contentContainerStyle={styles.onboardContent}
        showsVerticalScrollIndicator={false}
        keyboardShouldPersistTaps="handled"
        ref={scrollRef}
      >
        <OnboardingHeader onBack={onBack} onSkip={onSkip} colors={colors} t={t} />
        <Text style={[styles.onboardTitle, { color: colors.text }]}>{t("goalTitle")}</Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("goalSubtitle")}</Text>

        <View style={styles.goalGrid}>
          {GOAL_PRESETS.map((goal) => {
            const active = selection.includes(goal.id);
            return (
              <View key={goal.id} style={styles.goalOptionWrap}>
                <TouchableOpacity
                  style={[
                    styles.goalOption,
                    {
                      borderColor: colors.border,
                      backgroundColor: active ? colors.card : "transparent",
                    },
                  ]}
                  onPress={() => handleGoalPress(goal.id)}
                >
                  <Text style={styles.goalEmoji}>{goal.emoji}</Text>
                  <Text style={[styles.goalText, { color: colors.text }]}>
                    {goal[language] || goal.en}
                  </Text>
                </TouchableOpacity>
                {active && (
                  <View
                    style={[
                      styles.goalTargetInputWrap,
                      styles.goalTargetInline,
                      { borderColor: colors.border, backgroundColor: colors.card },
                    ]}
                    onLayout={(event) => {
                      layoutRefs.current[goal.id] = event.nativeEvent.layout;
                    }}
                  >
                    <TextInput
                      ref={(node) => {
                        if (node) {
                          inputRefs.current[goal.id] = node;
                        }
                      }}
                      style={[styles.goalTargetInput, { color: colors.text }]}
                      placeholder={t("goalTargetPlaceholder")}
                      placeholderTextColor={colors.muted}
                      keyboardType="decimal-pad"
                      value={targets[goal.id] || ""}
                      onChangeText={(text) => onGoalTargetChange?.(goal.id, text)}
                      returnKeyType="done"
                      blurOnSubmit
                      onSubmitEditing={Keyboard.dismiss}
                    />
                    <Text style={[styles.goalTargetCurrency, { color: colors.muted }]}>
                      {resolvedCurrency}
                    </Text>
                  </View>
                )}
              </View>
            );
          })}
        </View>

        {customGoals.length > 0 && (
          <>
            <Text style={[styles.goalCustomSectionTitle, { color: colors.muted }]}>
              {t("goalCustomSectionTitle")}
            </Text>
            <View style={styles.goalGrid}>
              {customGoals.map((goal) => {
                const active = selection.includes(goal.id);
                return (
                  <View key={goal.id} style={styles.goalOptionWrap}>
                    <TouchableOpacity
                      style={[
                        styles.goalOption,
                        {
                          borderColor: colors.border,
                          backgroundColor: active ? colors.card : "transparent",
                        },
                      ]}
                      onPress={() => handleGoalPress(goal.id)}
                    >
                      <Text style={styles.goalEmoji}>{goal.emoji || "ðŸŽ¯"}</Text>
                      <Text style={[styles.goalText, { color: colors.text }]}>{goal.title}</Text>
                    </TouchableOpacity>
                    {active && (
                      <View
                        style={[
                          styles.goalTargetInputWrap,
                          styles.goalTargetInline,
                          { borderColor: colors.border, backgroundColor: colors.card },
                        ]}
                        onLayout={(event) => {
                          layoutRefs.current[goal.id] = event.nativeEvent.layout;
                        }}
                      >
                    <TextInput
                      ref={(node) => {
                        if (node) {
                          inputRefs.current[goal.id] = node;
                        }
                      }}
                      style={[styles.goalTargetInput, { color: colors.text }]}
                      placeholder={t("goalTargetPlaceholder")}
                      placeholderTextColor={colors.muted}
                      keyboardType="decimal-pad"
                      value={targets[goal.id] || ""}
                      onChangeText={(text) => onGoalTargetChange?.(goal.id, text)}
                      returnKeyType="done"
                      blurOnSubmit
                      onSubmitEditing={Keyboard.dismiss}
                    />
                        <Text style={[styles.goalTargetCurrency, { color: colors.muted }]}>
                          {resolvedCurrency}
                        </Text>
                      </View>
                    )}
                  </View>
                );
              })}
            </View>
          </>
        )}

        {onCustomGoalCreate && (
          <TouchableOpacity
            style={[styles.goalCustomButton, { borderColor: colors.border }]}
            onPress={onCustomGoalCreate}
          >
            <Text style={[styles.goalCustomButtonText, { color: colors.text }]}>
              {t("goalCustomCreate")}
            </Text>
          </TouchableOpacity>
        )}

        <TouchableOpacity style={[styles.primaryButton, { backgroundColor: colors.text }]} onPress={handleSubmit}>
          <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("goalButton")}</Text>
        </TouchableOpacity>
        {typeof onSkipStep === "function" && (
          <TouchableOpacity style={styles.secondaryButtonClear} onPress={onSkipStep}>
            <Text style={[styles.secondaryButtonClearText, { color: colors.muted }]}>{t("goalSkip")}</Text>
          </TouchableOpacity>
        )}
      </ScrollView>
    </Animated.View>
  );
}

function GoalTargetScreen({
  selections = [],
  values = {},
  currency,
  onChange,
  onSubmit,
  onBack,
  colors,
  t,
  language,
  customGoals = [],
  onSkip,
}) {
  const fade = useFadeIn();
  const selectionList = Array.isArray(selections) ? selections : [];
  const customGoalMap = useMemo(() => {
    const entries = Array.isArray(customGoals) ? customGoals : [];
    return entries.reduce((acc, goal) => {
      acc[goal.id] = goal;
      return acc;
    }, {});
  }, [customGoals]);
  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView contentContainerStyle={styles.onboardContent} showsVerticalScrollIndicator={false} keyboardShouldPersistTaps="handled">
        <OnboardingHeader onBack={onBack} onSkip={onSkip} colors={colors} t={t} />
        <Text style={[styles.onboardTitle, { color: colors.text }]}>{t("goalTargetTitle")}</Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("goalTargetSubtitle")}</Text>
        {selectionList.map((goalId) => {
          const preset = getGoalPreset(goalId);
          const customGoal = customGoalMap[goalId];
          const goalLabel =
            customGoal?.title || preset?.[language] || preset?.en || goalId;
          return (
            <View key={goalId} style={styles.goalTargetRow}>
              <Text style={[styles.goalTargetLabel, { color: colors.muted }]}>{goalLabel}</Text>
              <View
                style={[
                  styles.goalTargetInputWrap,
                  { borderColor: colors.border, backgroundColor: colors.card },
                ]}
              >
                <TextInput
                  style={[styles.goalTargetInput, { color: colors.text }]}
                  placeholder={t("goalTargetPlaceholder")}
                  placeholderTextColor={colors.muted}
                  keyboardType="decimal-pad"
                  value={values[goalId] || ""}
                  onChangeText={(text) => onChange?.(goalId, text)}
                  returnKeyType="done"
                  blurOnSubmit
                  onSubmitEditing={Keyboard.dismiss}
                />
                <Text style={[styles.goalTargetCurrency, { color: colors.muted }]}>{currency}</Text>
              </View>
            </View>
          );
        })}
        <Text style={[styles.goalTargetHint, { color: colors.muted }]}>{t("goalTargetHint")}</Text>
        <TouchableOpacity style={[styles.primaryButton, { backgroundColor: colors.text }]} onPress={onSubmit}>
          <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("goalTargetCTA")}</Text>
        </TouchableOpacity>
      </ScrollView>
    </Animated.View>
  );
}

function AnalyticsConsentScreen({ colors, t, onSubmit, onBack }) {
  const isTrackingPrePrompt = Platform.OS === "ios";
  const titleKey = isTrackingPrePrompt ? "trackingConsentTitle" : "analyticsConsentTitle";
  const bodyKey = isTrackingPrePrompt ? "trackingConsentBody" : "analyticsConsentBody";
  const primaryKey = isTrackingPrePrompt ? "trackingConsentContinue" : "analyticsConsentAgree";

  return (
    <View style={[styles.analyticsConsentScreen, { backgroundColor: colors.background }]}>
      <OnboardingBackButton onPress={onBack} colors={colors} t={t} />
      <View
        style={[
          styles.analyticsConsentCard,
          { backgroundColor: colors.card, borderColor: colors.border },
        ]}
      >
        <Text style={[styles.analyticsConsentTitle, { color: colors.text }]}>
          {t(titleKey)}
        </Text>
        <Text style={[styles.analyticsConsentBody, { color: colors.muted }]}>
          {t(bodyKey)}
        </Text>
        <TouchableOpacity
          style={[styles.analyticsConsentPrimary, { backgroundColor: colors.text }]}
          onPress={() => onSubmit(true)}
        >
          <Text style={[styles.analyticsConsentPrimaryText, { color: colors.background }]}>
            {t(primaryKey)}
          </Text>
        </TouchableOpacity>
        {!isTrackingPrePrompt && (
          <TouchableOpacity
            style={[styles.analyticsConsentSecondary, { borderColor: colors.border }]}
            onPress={() => onSubmit(false)}
          >
            <Text style={[styles.analyticsConsentSecondaryText, { color: colors.muted }]}>
              {t("analyticsConsentSkip")}
            </Text>
          </TouchableOpacity>
        )}
      </View>
    </View>
  );
}

function OnboardingNotificationsScreen({ colors, t, onContinue, mascotHappySource }) {
  const fade = useFadeIn();
  const happySource = mascotHappySource || CLASSIC_TAMAGOTCHI_ANIMATIONS.happy;

  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView
        contentContainerStyle={[styles.onboardContent, styles.onboardCenteredContent]}
        showsVerticalScrollIndicator={false}
      >
        <Image source={happySource} style={styles.languageMascot} />
        <Text style={[styles.onboardTitleCompact, { color: colors.text, textAlign: "center" }]}>
          {t("onboardingNotificationsTitle")}
        </Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted, textAlign: "center" }]}>
          {t("onboardingNotificationsBody")}
        </Text>
        <TouchableOpacity
          style={[styles.primaryButton, styles.onboardWideButton, { backgroundColor: colors.text }]}
          onPress={onContinue}
        >
          <Text style={[styles.primaryButtonText, { color: colors.background }]}>
            {t("onboardingNotificationsCTA")}
          </Text>
        </TouchableOpacity>
      </ScrollView>
    </Animated.View>
  );
}

function SpendingBaselineScreen({
  value,
  currency,
  onChange,
  onSubmit,
  colors,
  t,
  onBack,
  onSkip,
  onSkipStep,
}) {
  const fade = useFadeIn();
  const baselineSampleLabel = formatSampleAmount(BASELINE_SAMPLE_USD, currency || DEFAULT_PROFILE.currency);
  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView contentContainerStyle={styles.onboardContent} showsVerticalScrollIndicator={false} keyboardShouldPersistTaps="handled">
        <OnboardingHeader onBack={onBack} onSkip={onSkip} colors={colors} t={t} />
        <Text style={[styles.onboardTitle, { color: colors.text }]}>{t("baselineTitle")}</Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("baselineSubtitle")}</Text>
        <View style={styles.baselineInputGroup}>
          <TextInput
            style={[
              styles.primaryInput,
              { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
            ]}
            placeholder={t("baselinePlaceholder", { amount: baselineSampleLabel })}
            placeholderTextColor={colors.muted}
            keyboardType="decimal-pad"
            value={value}
            onChangeText={onChange}
            returnKeyType="done"
            blurOnSubmit
            onSubmitEditing={Keyboard.dismiss}
          />
        </View>
        <Text style={[styles.baselineHint, { color: colors.muted }]}>{t("baselineHint")}</Text>
        <TouchableOpacity style={[styles.primaryButton, { backgroundColor: colors.text }]} onPress={onSubmit}>
          <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("baselineCTA")}</Text>
        </TouchableOpacity>
        {typeof onSkipStep === "function" && (
          <TouchableOpacity style={styles.secondaryButtonClear} onPress={onSkipStep}>
            <Text style={[styles.secondaryButtonClearText, { color: colors.muted }]}>{t("baselineSkip")}</Text>
          </TouchableOpacity>
        )}
      </ScrollView>
    </Animated.View>
  );
}

function PersonaScreen({ data, onChange, onSubmit, colors, t, language, onBack, onSkip }) {
  const fade = useFadeIn();
  const personaList = Object.values(PERSONA_PRESETS);
  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView
        contentContainerStyle={[styles.onboardContent, styles.onboardContentWithFooter]}
        showsVerticalScrollIndicator={false}
      >
        <OnboardingHeader onBack={onBack} onSkip={onSkip} colors={colors} t={t} />
        <Text style={[styles.personaTitleCompact, { color: colors.text }]}>
          {t("personaTitle")}
        </Text>
        <View style={styles.genderGrid}>
          {GENDER_OPTIONS.map((option) => {
            const active = option.id === data.gender;
            return (
              <TouchableOpacity
                key={option.id}
                style={[
                  styles.genderChip,
                  {
                    borderColor: colors.border,
                    backgroundColor: active ? colors.card : "transparent",
                  },
                ]}
                onPress={() => onChange("gender", option.id)}
              >
                <Text style={styles.genderEmoji}>{option.emoji}</Text>
                <Text style={[styles.genderLabel, { color: colors.text }]}>
                  {option.label[language] || option.label.en}
                </Text>
              </TouchableOpacity>
            );
          })}
        </View>

        <View style={styles.personaGrid}>
          {personaList.map((persona) => {
            const active = data.persona === persona.id;
            return (
              <TouchableOpacity
                key={persona.id}
                style={[
                  styles.personaCard,
                  {
                    borderColor: colors.border,
                    backgroundColor: active ? colors.card : "transparent",
                  },
                ]}
                onPress={() => onChange("persona", persona.id)}
              >
                <Text style={styles.personaEmoji}>{persona.emoji}</Text>
                <Text style={[styles.personaTitle, { color: colors.text }]}>
                  {persona.title[language] || persona.title.en}
                </Text>
                <Text style={[styles.personaSubtitleCard, { color: colors.muted }]}>
                  {persona.description[language] || persona.description.en}
                </Text>
              </TouchableOpacity>
            );
          })}
        </View>

      </ScrollView>
      <View style={[styles.onboardFloatingActions, { backgroundColor: colors.background }]}>
        <TouchableOpacity
          style={[styles.primaryButton, styles.onboardFloatingPrimary, { backgroundColor: colors.text }]}
          onPress={onSubmit}
        >
          <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("personaConfirm")}</Text>
        </TouchableOpacity>
      </View>
    </Animated.View>
  );
}

function CustomHabitScreen({ data, onChange, onSubmit, colors, t, currency, onBack, language, onSkip }) {
  const fade = useFadeIn();
  const customSpendSampleLabel = formatSampleAmount(CUSTOM_SPEND_SAMPLE_USD, currency || DEFAULT_PROFILE.currency);
  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView contentContainerStyle={styles.onboardContentCompact} showsVerticalScrollIndicator={false}>
        <OnboardingHeader onBack={onBack} onSkip={onSkip} colors={colors} t={t} />
        <Text style={[styles.onboardTitleCompact, { color: colors.text }]}>{t("customSpendTitle")}</Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("customSpendSubtitle")}</Text>

        <TextInput
          style={[
            styles.primaryInput,
            { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
          ]}
          placeholder={t("customSpendNamePlaceholder")}
          placeholderTextColor={colors.muted}
          value={data.customSpendTitle}
          onChangeText={(text) => onChange("customSpendTitle", text)}
          returnKeyType="done"
          blurOnSubmit
          onSubmitEditing={Keyboard.dismiss}
        />
        <View style={{ gap: 6 }}>
          <Text style={[styles.currencyLabel, { color: colors.muted }]}>{t("customSpendAmountLabel")}</Text>
          <TextInput
            style={[
              styles.primaryInput,
              { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
            ]}
            placeholder={t("customSpendAmountPlaceholder", { amount: customSpendSampleLabel })}
            placeholderTextColor={colors.muted}
            keyboardType="decimal-pad"
            value={data.customSpendAmount}
            onChangeText={(text) => onChange("customSpendAmount", text)}
            returnKeyType="done"
            blurOnSubmit
            onSubmitEditing={Keyboard.dismiss}
          />
        </View>
        <View style={{ gap: 6 }}>
          <Text style={[styles.currencyLabel, { color: colors.muted }]}>{t("customSpendFrequencyLabel")}</Text>
          <TextInput
            style={[
              styles.primaryInput,
              { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
            ]}
            placeholder={t("customSpendFrequencyPlaceholder")}
            placeholderTextColor={colors.muted}
            keyboardType="number-pad"
            value={data.customSpendFrequency}
            onChangeText={(text) => onChange("customSpendFrequency", text)}
            returnKeyType="done"
            blurOnSubmit
            onSubmitEditing={Keyboard.dismiss}
          />
        </View>
        <View style={{ gap: 6 }}>
          <Text style={[styles.currencyLabel, { color: colors.muted }]}>{t("impulseCategoryLabel")}</Text>
          <ImpulseCategorySelector
            value={data.customSpendCategory || DEFAULT_IMPULSE_CATEGORY}
            onChange={(cat) => onChange("customSpendCategory", cat)}
            colors={colors}
            language={language}
          />
        </View>
        <Text style={{ color: colors.muted }}>{t("customSpendHint")}</Text>

        <TouchableOpacity style={[styles.primaryButton, { backgroundColor: colors.text }]} onPress={() => onSubmit(false)}>
          <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("personaConfirm")}</Text>
        </TouchableOpacity>
        <TouchableOpacity style={styles.secondaryButtonClear} onPress={() => onSubmit(true)}>
          <Text style={[styles.secondaryButtonClearText, { color: colors.muted }]}>{t("customSpendSkip")}</Text>
        </TouchableOpacity>
      </ScrollView>
    </Animated.View>
  );
}

function ImpulseCategorySelector({
  value,
  onChange,
  colors,
  language,
  compact = false,
  horizontal = false,
  visibleCount = 5,
}) {
  const selected = value && IMPULSE_CATEGORY_DEFS[value] ? value : DEFAULT_IMPULSE_CATEGORY;
  const gap = 8;
  const horizontalPadding = 24;
  const chipWidth = horizontal
    ? Math.max(
        64,
        Math.floor(
          (SCREEN_WIDTH - horizontalPadding * 2 - gap * Math.max(visibleCount - 1, 0)) /
            Math.max(visibleCount, 1)
        )
      )
    : null;
  const chips = IMPULSE_CATEGORY_ORDER.map((categoryId) => {
    const active = selected === categoryId;
    return (
      <TouchableOpacity
        key={categoryId}
        style={[
          styles.impulseCategoryChip,
          compact && styles.impulseCategoryChipCompact,
          horizontal && chipWidth ? { width: chipWidth } : null,
          {
            borderColor: active ? colors.text : colors.border,
            backgroundColor: active ? colors.text : "transparent",
          },
        ]}
        onPress={() => onChange?.(categoryId)}
        activeOpacity={0.85}
      >
        <Text
          style={[
            styles.impulseCategoryChipText,
            compact && styles.impulseCategoryChipTextCompact,
            { color: active ? colors.background : colors.text },
          ]}
          numberOfLines={2}
        >
          {getImpulseCategoryLabel(categoryId, language)}
        </Text>
      </TouchableOpacity>
    );
  });
  if (horizontal) {
    return (
      <ScrollView
        horizontal
        showsHorizontalScrollIndicator={false}
        style={styles.impulseCategoryPickerScroll}
        contentContainerStyle={[styles.impulseCategoryPickerScrollContent, { gap }]}
      >
        {chips}
      </ScrollView>
    );
  }
  return (
    <View
      style={[
        styles.impulseCategoryPicker,
        compact && styles.impulseCategoryPickerCompact,
      ]}
    >
      {chips}
    </View>
  );
}

function CoinEntryModal({
  visible,
  colors,
  t,
  currency,
  language,
  maxAmountUSD = DEFAULT_COIN_SLIDER_MAX_USD,
  onUpdateMaxUSD,
  onSubmit,
  onCancel,
  playSound,
}) {
  const [sliderValue, setSliderValue] = useState(0.25);
  const [trackHeight, setTrackHeight] = useState(260);
  const [selectedCategory, setSelectedCategory] = useState(null);
  const [categoryError, setCategoryError] = useState(false);
  const [manualMode, setManualMode] = useState(null);
  const [manualValue, setManualValue] = useState("");
  const [manualError, setManualError] = useState("");
  const [manualExactLocal, setManualExactLocal] = useState(null);
  const directionAnim = useRef(new Animated.Value(0)).current;
  const sliderValueRef = useRef(0.25);
  const sliderValueCommitRef = useRef(0.25);
  const pendingSliderValueRef = useRef(null);
  const sliderRafRef = useRef(null);
  const hapticStepRef = useRef(0);
  const sliderHapticCooldownRef = useRef(0);
  const sliderTickStepRef = useRef(null);
  const sliderTickCooldownRef = useRef(0);
  const tossingRef = useRef(false);
  const touchStartValueRef = useRef(0.25);
  const touchStartPageYRef = useRef(0);
  const sliderGestureRef = useRef({
    axis: "pending",
  });
  const touchStartRef = useRef(0);
  const manualVisible = manualMode !== null;
  const manualIsAmountMode = manualMode === "amount";
  useEffect(() => {
    return () => {
      if (sliderRafRef.current) {
        cancelAnimationFrame(sliderRafRef.current);
        sliderRafRef.current = null;
      }
    };
  }, []);
  useEffect(() => {
    if (!visible) return;
    updateSliderValue(0.25, { force: true });
    hapticStepRef.current = Math.round(0.25 * 20);
    sliderHapticCooldownRef.current = 0;
    sliderGestureRef.current = {
      axis: "pending",
    };
    setSelectedCategory(null);
    setCategoryError(false);
    setManualMode(null);
    setManualValue("");
    setManualError("");
    setManualExactLocal(null);
    directionAnim.setValue(0);
    sliderTickStepRef.current = null;
    sliderTickCooldownRef.current = 0;
    tossingRef.current = false;
    touchStartRef.current = 0;
    touchStartValueRef.current = 0.25;
    touchStartPageYRef.current = 0;
  }, [directionAnim, updateSliderValue, visible]);
  const currencySymbol =
    CURRENCY_SIGNS[currency] ||
    CURRENCY_SIGNS[DEFAULT_PROFILE.currency] ||
    DEFAULT_PROFILE.currency ||
    "$";
  const displayPrecision = useMemo(() => getCurrencyDisplayPrecision(currency), [currency]);
  const tickStepLocal = useMemo(
    () => (displayPrecision > 0 ? Math.pow(10, -displayPrecision) : 1),
    [displayPrecision]
  );
  const computeAmountUSDForValue = useCallback(
    (value) => {
      if (!Number.isFinite(value) || maxAmountUSD <= 0) return 0;
      const localAmount = roundCurrencyValue(
        convertToCurrency(maxAmountUSD * value, currency),
        currency
      );
      const usd = convertFromCurrency(localAmount, currency);
      return Math.max(0, Math.min(maxAmountUSD, usd));
    },
    [currency, maxAmountUSD]
  );
  const sliderAmountUSD = computeAmountUSDForValue(sliderValue);
  const sliderLocalValue = snapCurrencyValue(convertToCurrency(sliderAmountUSD, currency), currency);
  const sliderAmountLocal = manualExactLocal
    ? formatCurrencyWhole(manualExactLocal.value, currency, manualExactLocal.precision)
    : formatCurrencyWhole(sliderLocalValue, currency);
  const sliderMaxLocalValue = useMemo(
    () => snapCurrencyValue(convertToCurrency(maxAmountUSD, currency), currency),
    [currency, maxAmountUSD]
  );
  const sliderMaxLocal = formatCurrencyWhole(sliderMaxLocalValue, currency);
  const sliderFillHeight = Math.max(COIN_FILL_MIN_HEIGHT, Math.min(trackHeight, trackHeight * sliderValue));
  const coinHasValue = sliderValue > 0.02;
  const coinFillColor = coinHasValue ? "#F7C45D" : "#DADDE3";
  const coinShineColor = coinHasValue ? "rgba(255,255,255,0.5)" : "rgba(255,255,255,0.25)";
  const isDarkTheme = colors.background === THEMES.dark.background;
  const coinSurfaceOuter = isDarkTheme ? "#111525" : "#F6F8FC";
  const coinSurfaceInner = isDarkTheme ? "#181D31" : "#ECEFF5";
  const coinSurfaceBorder = isDarkTheme ? "rgba(255,255,255,0.14)" : "rgba(255,255,255,0.8)";
  const coinSymbolColor = isDarkTheme ? "rgba(245,248,255,0.78)" : "rgba(5,7,13,0.25)";
  const coinSymbolOpacity = isDarkTheme ? 0.85 : 0.2;
  const sliderBackground = directionAnim.interpolate({
    inputRange: [-1, 0, 1],
    outputRange: ["rgba(217,72,98,0.18)", "rgba(0,0,0,0)", "rgba(46,184,115,0.18)"],
    extrapolate: "clamp",
  });
  const coinTranslateX = directionAnim.interpolate({
    inputRange: [-3, -1, 0, 1, 3],
    outputRange: [-SCREEN_WIDTH, -48, 0, 48, SCREEN_WIDTH],
    extrapolate: "clamp",
  });
  const currencyFineStep = useMemo(() => getCurrencyFineStep(currency), [currency]);
  const computeTickIndex = useCallback(
    (value) => {
      if (!Number.isFinite(value)) return 0;
      const amountUSD = computeAmountUSDForValue(value);
      const localAmount = snapCurrencyValue(convertToCurrency(amountUSD, currency), currency);
      const roundedLocal = roundCurrencyValue(localAmount, currency, displayPrecision);
      const stepLocal = tickStepLocal || 1;
      if (!Number.isFinite(stepLocal) || stepLocal <= 0) {
        return Math.round(roundedLocal * 100);
      }
      return Math.round(roundedLocal / stepLocal);
    },
    [computeAmountUSDForValue, currency, displayPrecision, tickStepLocal]
  );
  const triggerSliderTick = useCallback(
    (stepIndex) => {
      if (stepIndex === null || stepIndex === undefined) return;
      if (sliderTickStepRef.current === stepIndex) return;
      sliderTickStepRef.current = stepIndex;
      const now = Date.now();
      if (now - sliderTickCooldownRef.current < 30) return;
      sliderTickCooldownRef.current = now;
      playSound?.("counter", { skipCooldown: true });
    },
    [playSound]
  );
  const computeSteppedValue = useCallback(
    (rawValue) => {
      const clamped = Math.max(0, Math.min(1, rawValue));
      if (!Number.isFinite(clamped) || maxAmountUSD <= 0 || sliderMaxLocalValue <= 0) {
        return clamped;
      }
      const targetLocal = clamped * sliderMaxLocalValue;
      const stepLocal = currencyFineStep;
      let roundedLocal;
      if (stepLocal > 0) {
        roundedLocal = Math.round(targetLocal / stepLocal) * stepLocal;
      } else {
        roundedLocal = targetLocal;
      }
      roundedLocal = roundCurrencyValue(roundedLocal, currency);
      const limitedLocal = Math.max(0, Math.min(sliderMaxLocalValue, roundedLocal));
      const roundedUSD = convertFromCurrency(limitedLocal, currency);
      if (!Number.isFinite(roundedUSD) || roundedUSD < 0) {
        return clamped;
      }
      return Math.max(0, Math.min(1, roundedUSD / maxAmountUSD));
    },
    [currency, currencyFineStep, sliderMaxLocalValue, maxAmountUSD]
  );
  const computeValueFromTouch = useCallback(
    (locationY) => {
      if (!Number.isFinite(locationY) || trackHeight <= 0) {
        return sliderValueRef.current;
      }
      const clamped = Math.max(0, Math.min(trackHeight, locationY));
      const normalized = 1 - clamped / trackHeight;
      return Math.max(0, Math.min(1, normalized));
    },
    [sliderValueRef, trackHeight]
  );
  const updateSliderValue = useCallback(
    (value, { force = false, fromUser = false, manualOverride = false } = {}) => {
      if (!manualOverride) {
        setManualExactLocal(null);
      }
      const clamped = Math.max(0, Math.min(1, Number.isFinite(value) ? value : 0));
      sliderValueRef.current = clamped;
      if (force) {
        if (sliderRafRef.current) {
          cancelAnimationFrame(sliderRafRef.current);
          sliderRafRef.current = null;
        }
        pendingSliderValueRef.current = null;
        sliderValueCommitRef.current = clamped;
        setSliderValue(clamped);
        return clamped;
      }
      pendingSliderValueRef.current = clamped;
      if (sliderRafRef.current) {
        return clamped;
      }
      sliderRafRef.current = requestAnimationFrame(() => {
        sliderRafRef.current = null;
        const pending = pendingSliderValueRef.current;
        if (pending === null || pending === undefined) return;
        pendingSliderValueRef.current = null;
        sliderValueCommitRef.current = pending;
        setSliderValue(pending);
      });
      return clamped;
    },
    [setManualExactLocal]
  );
  const openManual = useCallback(
    (mode) => {
      setManualMode(mode);
      setManualError("");
      if (mode === "amount") {
        const formatted = sliderLocalValue > 0 ? formatNumberInputValue(sliderLocalValue) : "";
        setManualValue(formatted);
      } else {
        setManualValue("");
      }
    },
    [sliderLocalValue]
  );
  const closeManual = useCallback(() => {
    setManualMode(null);
    setManualError("");
  }, []);
  const finalizeSliderValue = useCallback(() => {
    const snapped = computeSteppedValue(sliderValueRef.current);
    sliderValueRef.current = snapped;
    updateSliderValue(snapped, { force: true });
  }, [computeSteppedValue, updateSliderValue]);
  const panResponder = useMemo(
    () =>
      PanResponder.create({
        onStartShouldSetPanResponder: () => true,
        onPanResponderGrant: (evt, gesture) => {
          sliderGestureRef.current = {
            axis: "vertical",
          };
          const touchY = evt.nativeEvent?.locationY;
          if (Number.isFinite(touchY)) {
            const nextValue = computeValueFromTouch(touchY);
            const applied = updateSliderValue(nextValue, { force: true, fromUser: true });
            const snapped = computeSteppedValue(applied);
            touchStartValueRef.current = applied;
            hapticStepRef.current = Math.round(snapped * 20);
            triggerSliderTick(computeTickIndex(snapped));
          } else {
            touchStartValueRef.current = sliderValueRef.current;
          }
          touchStartPageYRef.current = Number.isFinite(gesture?.y0) ? gesture.y0 : evt.nativeEvent?.pageY || 0;
          touchStartRef.current = Date.now();
          directionAnim.stopAnimation();
          directionAnim.setValue(0);
        },
        onPanResponderMove: (evt, gesture) => {
          if (tossingRef.current) return;
          if (trackHeight <= 0) return;
          const startY = touchStartPageYRef.current;
          const moveY = Number.isFinite(gesture?.moveY) ? gesture.moveY : evt.nativeEvent?.pageY;
          let nextValue;
          if (Number.isFinite(startY) && Number.isFinite(moveY)) {
            const dy = moveY - startY;
            nextValue = Math.max(0, Math.min(1, touchStartValueRef.current - dy / trackHeight));
          } else {
            const touchY = evt.nativeEvent?.locationY;
            nextValue = computeValueFromTouch(touchY);
          }
          const applied = updateSliderValue(nextValue, { fromUser: true });
          const snapped = computeSteppedValue(applied);
          const nextStep = Math.round(snapped * 20);
          if (nextStep !== hapticStepRef.current) {
            const now = Date.now();
            if (now - sliderHapticCooldownRef.current >= COIN_SLIDER_HAPTIC_COOLDOWN_MS) {
              triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
              sliderHapticCooldownRef.current = now;
            }
            hapticStepRef.current = nextStep;
            triggerSliderTick(computeTickIndex(snapped));
          }
        },
        onPanResponderRelease: (_, gesture) => {
          const elapsed = Date.now() - (touchStartRef.current || 0);
          const isTap =
            Math.abs(gesture.dx) < 6 && Math.abs(gesture.dy) < 6 && elapsed < 200 && !tossingRef.current;
          sliderGestureRef.current = {
            axis: "pending",
          };
          finalizeSliderValue();
          if (isTap) {
            openManual("amount");
          }
        },
        onPanResponderTerminate: () => {
          sliderGestureRef.current = {
            axis: "pending",
          };
          finalizeSliderValue();
        },
      }),
    [
      computeSteppedValue,
      computeValueFromTouch,
      directionAnim,
      finalizeSliderValue,
      openManual,
      trackHeight,
    ]
  );
  const handleManualSave = () => {
    const parsed = parseNumberInputValue(manualValue);
    if (!Number.isFinite(parsed) || parsed <= 0) {
      setManualError(t("coinEntryManualError"));
      return;
    }
    const normalizedLocal = manualIsAmountMode ? parsed : snapCurrencyValue(parsed, currency);
    if (manualIsAmountMode) {
      if (!Number.isFinite(maxAmountUSD) || maxAmountUSD <= 0) {
        setManualError(t("coinEntryManualError"));
        return;
      }
      const limitedLocal = Math.max(0, Math.min(sliderMaxLocalValue, normalizedLocal));
      const parsedUSD = convertFromCurrency(limitedLocal, currency);
      if (!Number.isFinite(parsedUSD)) {
        setManualError(t("coinEntryManualError"));
        return;
      }
      const normalized = Math.max(0, Math.min(1, parsedUSD / maxAmountUSD));
      updateSliderValue(normalized, { force: true, fromUser: true, manualOverride: true });
      hapticStepRef.current = Math.round(normalized * 20);
      const manualPrecision = getManualInputPrecision(manualValue);
      setManualExactLocal({
        value: limitedLocal,
        precision: manualPrecision,
      });
      sliderGestureRef.current = {
        axis: "pending",
      };
      closeManual();
      return;
    }
    const parsedUSD = convertFromCurrency(normalizedLocal, currency);
    if (!Number.isFinite(parsedUSD) || parsedUSD <= 0) {
      setManualError(t("coinEntryManualError"));
      return;
    }
    onUpdateMaxUSD?.(parsedUSD);
    closeManual();
  };
  const categoryLabelKey = getShortLanguageKey(language);
  const categoryChipWidth = useMemo(() => {
    const visibleCount = 3;
    const gap = 10;
    const horizontalPadding = 32;
    const available = SCREEN_WIDTH - horizontalPadding * 2 - gap * (visibleCount - 1);
    return Math.max(96, Math.floor(available / visibleCount));
  }, []);
  const manualTitle = manualIsAmountMode ? t("coinEntryManualAmountTitle") : t("coinEntryManualTitle");
  const manualPlaceholder = manualIsAmountMode
    ? t("coinEntryManualAmountPlaceholder", { amount: sliderAmountLocal })
    : t("coinEntryManualPlaceholder", { amount: sliderMaxLocal });
  const handleAction = useCallback(
    (direction) => {
      if (tossingRef.current) return;
      const value = sliderValueRef.current;
      const hasAmount = value >= 0.02;
      if (!hasAmount) {
        triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
        return;
      }
      if (!selectedCategory) {
        setCategoryError(true);
        triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
        return;
      }
      playSound?.("coin");
      const computedAmountUSD = computeAmountUSDForValue(value);
      tossingRef.current = true;
      Animated.timing(directionAnim, {
        toValue: direction === "save" ? 3.2 : -3.2,
        duration: 180,
        easing: Easing.out(Easing.circle),
        useNativeDriver: false,
      }).start(() => {
        tossingRef.current = false;
        directionAnim.setValue(0);
        onSubmit?.({
          amountUSD: computedAmountUSD,
          category: selectedCategory,
          direction,
        });
      });
    },
    [computeAmountUSDForValue, directionAnim, onSubmit, playSound, selectedCategory]
  );
  const showActionButtons = true;
  return (
    <Modal visible={visible} transparent animationType="fade" onRequestClose={onCancel} statusBarTranslucent>
      <TouchableWithoutFeedback onPress={onCancel}>
        <View style={styles.coinEntryBackdrop}>
          <TouchableWithoutFeedback onPress={() => {}}>
            <View
              style={[
                styles.coinEntryCard,
                { backgroundColor: colors.card, borderColor: colors.border },
              ]}
            >
              <View style={styles.coinEntryHeader}>
                <View style={{ flex: 1 }}>
                  <Text style={[styles.coinEntryTitle, { color: colors.text }]}>{t("coinEntryTitle")}</Text>
                  <Text style={[styles.coinEntrySubtitle, { color: colors.muted }]}>
                    {t("coinEntrySubtitle")}
                  </Text>
                </View>
                <TouchableOpacity onPress={onCancel} style={styles.coinEntryClose}>
                  <Text style={[styles.coinEntryCloseText, { color: colors.muted }]}>âœ•</Text>
                </TouchableOpacity>
              </View>
              <View style={styles.coinEntryAmountRow}>
                <Text style={[styles.coinEntryAmount, { color: colors.text }]}>{sliderAmountLocal}</Text>
                <TouchableOpacity
                  onPress={() => openManual("max")}
                  hitSlop={{ top: 8, bottom: 8, left: 8, right: 8 }}
                >
                  <Text style={[styles.coinEntryMaxLabel, { color: colors.muted }]}>
                    {sliderMaxLocal}
                  </Text>
                </TouchableOpacity>
              </View>
              <Text style={[styles.coinEntryManualTapHint, { color: colors.muted }]}>
                {t("coinEntryManualTapHint")}
              </Text>
              <View style={styles.coinSliderWrapper}>
                <Animated.View style={[styles.coinSliderBackdrop, { backgroundColor: sliderBackground }]} />
                <Animated.View
                  style={[
                    styles.coinCircle,
                    {
                      borderColor: coinHasValue ? "rgba(247,196,93,0.5)" : colors.border,
                      backgroundColor: coinSurfaceOuter,
                      shadowColor: coinHasValue ? "#F7C45D" : "#A0A5B6",
                      transform: [{ translateX: coinTranslateX }],
                    },
                  ]}
                  onLayout={(event) => {
                    const { height } = event.nativeEvent.layout;
                    if (height) setTrackHeight(height);
                  }}
                  {...panResponder.panHandlers}
                >
                  <View
                    style={[
                      styles.coinInnerSurface,
                      { backgroundColor: coinSurfaceInner, borderColor: coinSurfaceBorder },
                    ]}
                  >
                    <View style={styles.coinFillTrack}>
                      <View
                        style={[
                          styles.coinFill,
                          {
                            height: sliderFillHeight,
                            backgroundColor: coinFillColor,
                          },
                        ]}
                      />
                    </View>
                    <View style={[styles.coinShine, { backgroundColor: coinShineColor }]} />
                    <Text
                      style={[
                        styles.coinCurrencySymbol,
                        { color: coinSymbolColor, opacity: coinSymbolOpacity },
                      ]}
                    >
                      {currencySymbol}
                    </Text>
                  </View>
                </Animated.View>
              </View>
              {showActionButtons && (
                <View style={styles.coinEntryActions}>
                  <TouchableOpacity
                    style={[styles.coinEntryActionButton, styles.coinEntryActionButtonSpend]}
                    onPress={() => handleAction("spend")}
                    activeOpacity={0.85}
                  >
                    <Text style={[styles.coinEntryActionButtonText, styles.coinEntryActionButtonTextSpend]}>
                      {t("spendAction")}
                    </Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.coinEntryActionButton, styles.coinEntryActionButtonSave]}
                    onPress={() => handleAction("save")}
                    activeOpacity={0.85}
                  >
                    <Text style={[styles.coinEntryActionButtonText, styles.coinEntryActionButtonTextSave]}>
                      {t("saveAction")}
                    </Text>
                  </TouchableOpacity>
                </View>
              )}
              <Text style={[styles.coinEntryHint, { color: colors.muted }]}>{t("coinEntryHint")}</Text>
              <Text style={[styles.coinEntryCategoryLabel, { color: colors.text }]}>
                {t("coinEntryCategoryLabel")}
              </Text>
              {categoryError && (
                <Text style={[styles.coinEntryError, { color: SPEND_ACTION_COLOR }]}>
                  {t("coinEntryCategoryError")}
                </Text>
              )}
              <ScrollView
                horizontal
                showsHorizontalScrollIndicator={false}
                style={styles.coinEntryCategoryScroll}
                contentContainerStyle={styles.coinEntryCategoryRow}
              >
                {IMPULSE_CATEGORY_ORDER.map((categoryId) => {
                  const def = IMPULSE_CATEGORY_DEFS[categoryId];
                  const active = selectedCategory === categoryId;
                  return (
                    <TouchableOpacity
                      key={categoryId}
                      style={[
                        styles.coinEntryCategoryButton,
                        {
                          width: categoryChipWidth,
                          borderColor: active ? colors.text : colors.border,
                          backgroundColor: active ? colors.text : "transparent",
                        },
                      ]}
                      onPress={() => {
                        setSelectedCategory(categoryId);
                        setCategoryError(false);
                      }}
                    >
                      <Text style={styles.coinEntryCategoryEmoji}>{def.emoji}</Text>
                      <Text
                        style={[
                          styles.coinEntryCategoryText,
                          { color: active ? colors.background : colors.text },
                        ]}
                        numberOfLines={2}
                      >
                        {def[categoryLabelKey]}
                      </Text>
                    </TouchableOpacity>
                  );
                })}
              </ScrollView>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
      {manualVisible && (
        <Modal visible transparent animationType="fade" onRequestClose={closeManual}>
          <TouchableWithoutFeedback onPress={closeManual}>
            <View style={styles.coinEntryManualBackdrop}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View
                  style={[
                    styles.coinEntryManualCard,
                    { backgroundColor: colors.card, borderColor: colors.border },
                  ]}
                >
                  <Text style={[styles.coinEntryManualTitle, { color: colors.text }]}>
                    {manualTitle}
                  </Text>
                  <TextInput
                    style={[styles.coinEntryManualInput, { color: colors.text, borderColor: colors.border }]}
                    placeholder={manualPlaceholder}
                    placeholderTextColor={colors.muted}
                    keyboardType="numeric"
                    value={manualValue}
                    onChangeText={setManualValue}
                  />
                  {!!manualError && (
                    <Text style={[styles.coinEntryManualError, { color: SPEND_ACTION_COLOR }]}>{manualError}</Text>
                  )}
                  <View style={styles.coinEntryManualActions}>
                    <TouchableOpacity
                      style={[styles.coinEntryManualButtonGhost, { borderColor: colors.border }]}
                      onPress={closeManual}
                    >
                      <Text style={[styles.coinEntryManualButtonGhostText, { color: colors.muted }]}>
                        {t("coinEntryManualCancel")}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[styles.coinEntryManualButtonPrimary, { backgroundColor: colors.text }]}
                      onPress={handleManualSave}
                    >
                      <Text style={[styles.coinEntryManualButtonPrimaryText, { color: colors.background }]}>
                        {t("coinEntryManualSave")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>
      )}
    </Modal>
  );
}

function QuickCustomModal({
  visible,
  colors,
  t,
  currency,
  data,
  onChange,
  onSubmit,
  onCancel,
  language,
  keyboardOffset = 0,
}) {
  const keyboardPaddingStyle = keyboardOffset ? { paddingBottom: keyboardOffset } : null;
  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onCancel}
      statusBarTranslucent
    >
      <TouchableWithoutFeedback onPress={onCancel}>
        <View style={[styles.quickModalBackdrop, keyboardPaddingStyle]}>
          <TouchableWithoutFeedback onPress={() => {}}>
            <View style={[styles.quickModalCard, { backgroundColor: colors.card }] }>
              <Text style={[styles.quickModalTitle, { color: colors.text }]}>{t("quickCustomTitle")}</Text>
              <Text style={[styles.quickModalSubtitle, { color: colors.muted }]}>{t("quickCustomSubtitle")}</Text>
              <View style={{ gap: 8, width: "100%" }}>
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("quickCustomNameLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.title}
                  onChangeText={(text) => onChange("title", text)}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("quickCustomAmountLabel", { currency })}
                  placeholderTextColor={colors.muted}
                  keyboardType="decimal-pad"
                  value={data.amount}
                  onChangeText={(text) => onChange("amount", text)}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("quickCustomEmojiLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.emoji || ""}
                  onChangeText={(text) => onChange("emoji", text)}
                  selectTextOnFocus
                  maxLength={2}
                />
                <View style={{ gap: 6 }}>
                  <Text style={[styles.currencyLabel, { color: colors.muted }]}>
                    {t("impulseCategoryLabel")}
                  </Text>
                  <ImpulseCategorySelector
                    value={data.category || DEFAULT_IMPULSE_CATEGORY}
                    onChange={(cat) => onChange("category", cat)}
                    colors={colors}
                    language={language}
                    horizontal
                    visibleCount={3}
                  />
                </View>
              </View>
              <View style={styles.quickModalActions}>
                <TouchableOpacity
                  style={[styles.quickModalSecondary, { borderColor: colors.border }]}
                  onPress={onCancel}
                >
                  <Text style={[styles.quickModalSecondaryText, { color: colors.muted }]}>
                    {t("quickCustomCancel")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
                  onPress={() => onSubmit(data)}
                >
                  <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>
                    {t("quickCustomConfirm")}
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
}

function NewGoalModal({
  visible,
  colors,
  t,
  currency,
  data,
  onChange,
  onSubmit,
  onCancel,
  keyboardOffset = 0,
}) {
  const keyboardPaddingStyle = keyboardOffset ? { paddingBottom: keyboardOffset } : null;
  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onCancel}
      statusBarTranslucent
    >
      <TouchableWithoutFeedback onPress={onCancel}>
        <View style={[styles.quickModalBackdrop, keyboardPaddingStyle]}>
          <TouchableWithoutFeedback onPress={() => {}}>
            <View style={[styles.quickModalCard, { backgroundColor: colors.card }] }>
              <Text style={[styles.quickModalTitle, { color: colors.text }]}>{t("newGoalTitle")}</Text>
              <Text style={[styles.quickModalSubtitle, { color: colors.muted }]}>{t("newGoalSubtitle")}</Text>
              <View style={{ gap: 8, width: "100%" }}>
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newGoalNameLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.name}
                  onChangeText={(text) => onChange("name", text)}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newGoalTargetLabel", { currency })}
                  placeholderTextColor={colors.muted}
                  keyboardType="decimal-pad"
                  value={data.target}
                  onChangeText={(text) => onChange("target", text)}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newGoalEmojiLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.emoji || ""}
                  onChangeText={(text) => onChange("emoji", text)}
                  selectTextOnFocus
                  maxLength={2}
                />
              </View>
              <View style={styles.quickModalActions}>
                <TouchableOpacity
                  style={[styles.quickModalSecondary, { borderColor: colors.border }]}
                  onPress={onCancel}
                >
                  <Text style={[styles.quickModalSecondaryText, { color: colors.muted }]}>
                    {t("newGoalCancel")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
                  onPress={onSubmit}
                >
                  <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>
                    {t("newGoalCreate")}
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
}

function NewPendingModal({
  visible,
  colors,
  t,
  currency,
  data,
  onChange,
  onSubmit,
  onCancel,
  keyboardOffset = 0,
}) {
  const keyboardPaddingStyle = keyboardOffset ? { paddingBottom: keyboardOffset } : null;
  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onCancel}
      statusBarTranslucent
    >
      <TouchableWithoutFeedback onPress={onCancel}>
        <View style={[styles.quickModalBackdrop, keyboardPaddingStyle]}>
          <TouchableWithoutFeedback onPress={() => {}}>
            <View style={[styles.quickModalCard, { backgroundColor: colors.card }] }>
              <Text style={[styles.quickModalTitle, { color: colors.text }]}>{t("newPendingTitle")}</Text>
              <Text style={[styles.quickModalSubtitle, { color: colors.muted }]}>{t("newPendingSubtitle")}</Text>
              <View style={{ gap: 8, width: "100%" }}>
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newPendingNameLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.title}
                  onChangeText={(text) => onChange("title", text)}
                  returnKeyType="done"
                  blurOnSubmit
                  onSubmitEditing={Keyboard.dismiss}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newPendingAmountLabel", { currency })}
                  placeholderTextColor={colors.muted}
                  keyboardType="decimal-pad"
                  value={data.amount}
                  onChangeText={(text) => onChange("amount", text)}
                  returnKeyType="done"
                  blurOnSubmit
                  onSubmitEditing={Keyboard.dismiss}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newPendingEmojiLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.emoji || ""}
                  onChangeText={(text) => onChange("emoji", text)}
                  selectTextOnFocus
                  maxLength={2}
                  returnKeyType="done"
                  blurOnSubmit
                  onSubmitEditing={Keyboard.dismiss}
                />
              </View>
              <View style={styles.quickModalActions}>
                <TouchableOpacity
                  style={[styles.quickModalSecondary, { borderColor: colors.border }]}
                  onPress={onCancel}
                >
                  <Text style={[styles.quickModalSecondaryText, { color: colors.muted }]}>
                    {t("newPendingCancel")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
                  onPress={onSubmit}
                >
                  <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>
                    {t("newPendingCreate")}
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
}

function OnboardingGoalModal({
  visible,
  colors,
  t,
  currency,
  data,
  onChange,
  onSubmit,
  onCancel,
  keyboardOffset = 0,
}) {
  const keyboardPaddingStyle = keyboardOffset ? { paddingBottom: keyboardOffset } : null;
  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onCancel}
      statusBarTranslucent
    >
      <TouchableWithoutFeedback onPress={onCancel}>
        <View style={[styles.quickModalBackdrop, keyboardPaddingStyle]}>
          <TouchableWithoutFeedback onPress={() => {}}>
            <View style={[styles.quickModalCard, { backgroundColor: colors.card }] }>
              <Text style={[styles.quickModalTitle, { color: colors.text }]}>{t("newGoalTitle")}</Text>
              <Text style={[styles.quickModalSubtitle, { color: colors.muted }]}>{t("newGoalSubtitle")}</Text>
              <View style={{ gap: 8, width: "100%" }}>
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newGoalNameLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.name}
                  onChangeText={(text) => onChange("name", text)}
                  returnKeyType="done"
                  blurOnSubmit
                  onSubmitEditing={Keyboard.dismiss}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newGoalTargetLabel", { currency })}
                  placeholderTextColor={colors.muted}
                  keyboardType="decimal-pad"
                  value={data.target}
                  onChangeText={(text) => onChange("target", text)}
                  returnKeyType="done"
                  blurOnSubmit
                  onSubmitEditing={Keyboard.dismiss}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newGoalEmojiLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.emoji || ""}
                  onChangeText={(text) => onChange("emoji", text)}
                  selectTextOnFocus
                  maxLength={2}
                  returnKeyType="done"
                  blurOnSubmit
                  onSubmitEditing={Keyboard.dismiss}
                />
              </View>
              <View style={styles.quickModalActions}>
                <TouchableOpacity
                  style={[styles.quickModalSecondary, { borderColor: colors.border }]}
                  onPress={onCancel}
                >
                  <Text style={[styles.quickModalSecondaryText, { color: colors.muted }]}>
                    {t("newGoalCancel")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
                  onPress={onSubmit}
                >
                  <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>
                    {t("goalCustomCreate")}
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
}

function TermsModal({ visible, colors, t, language, onAccept, onCancel, onOpenLink }) {
  const normalizedLanguage = normalizeLanguage(language);
  const points = TERMS_POINTS[normalizedLanguage] || TERMS_POINTS.en;
  return (
    <Modal visible={visible} transparent animationType="fade" statusBarTranslucent onRequestClose={onCancel}>
      <View style={styles.quickModalBackdrop}>
        <View style={[styles.termsCard, { backgroundColor: colors.card }]}>
          <Text style={[styles.termsTitle, { color: colors.text }]}>{t("termsTitle")}</Text>
          <Text style={[styles.termsSubtitle, { color: colors.muted }]}>{t("termsSubtitle")}</Text>
          <ScrollView
            style={styles.termsScroll}
            contentContainerStyle={styles.termsScrollContent}
            showsVerticalScrollIndicator={false}
          >
            {points.map((point, index) => (
              <View key={`${index}-${language}`} style={styles.termsPoint}>
                <Text style={[styles.termsPointIndex, { color: colors.muted }]}>{index + 1}.</Text>
                <Text style={[styles.termsPointText, { color: colors.text }]}>{point}</Text>
              </View>
            ))}
          </ScrollView>
          <TouchableOpacity
            style={[styles.termsLinkButton, { borderColor: colors.border }]}
            onPress={onOpenLink}
          >
            <Text style={[styles.termsLinkText, { color: colors.text }]}>{t("termsViewFull")}</Text>
          </TouchableOpacity>
          <Text style={[styles.termsHint, { color: colors.muted }]}>{t("termsLinkHint")}</Text>
          <View style={styles.quickModalActions}>
            <TouchableOpacity
              style={[styles.quickModalSecondary, { borderColor: colors.border }]}
              onPress={onCancel}
            >
              <Text style={[styles.quickModalSecondaryText, { color: colors.muted }]}>{t("termsDecline")}</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
              onPress={onAccept}
            >
              <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>{t("termsAccept")}</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
}

function OnboardingBackButton({ onPress, colors, t }) {
  if (!onPress) return null;
  return (
    <TouchableOpacity
      style={[styles.onboardBackButton, { borderColor: colors.border }]}
      onPress={onPress}
      hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
    >
      <Text style={[styles.onboardBackIcon, { color: colors.text }]}>â†</Text>
      <Text style={[styles.onboardBackLabel, { color: colors.text }]}>{t("onboardingBack")}</Text>
    </TouchableOpacity>
  );
}

function OnboardingSkipButton({ onPress, t }) {
  if (!onPress) return null;
  return (
    <TouchableOpacity
      style={styles.onboardSkipButton}
      onPress={onPress}
      hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
    >
      <Text style={styles.onboardSkipLabel}>{t("onboardingSkip")}</Text>
    </TouchableOpacity>
  );
}

function OnboardingHeader({ onBack, onSkip, colors, t }) {
  if (!onBack && !onSkip) return null;
  return (
    <View style={styles.onboardHeaderRow}>
      <OnboardingBackButton onPress={onBack} colors={colors} t={t} />
      <OnboardingSkipButton onPress={onSkip} t={t} />
    </View>
  );
}

function HowItWorksScreen({ colors, t, onContinue, onBack, onSkip }) {
  const fade = useFadeIn();
  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView
        contentContainerStyle={[styles.onboardContent, styles.onboardGuideContent]}
        showsVerticalScrollIndicator={false}
      >
        <OnboardingHeader onBack={onBack} onSkip={onSkip} colors={colors} t={t} />
        <Text style={[styles.onboardTitleCompact, { color: colors.text }]}>{t("onboardingGuideTitle")}</Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("onboardingGuideSubtitle")}</Text>
        <View style={styles.guideCards}>
          {HOW_IT_WORKS_STEPS.map((step) => (
            <View
              key={step.id}
              style={[
                styles.guideCard,
                {
                  backgroundColor: colors.card,
                  borderColor: colors.border,
                },
              ]}
            >
              <Text style={styles.guideEmoji}>{step.emoji}</Text>
              <Text style={[styles.guideTitle, { color: colors.text }]}>{t(step.titleKey)}</Text>
              <Text style={[styles.guideDesc, { color: colors.muted }]}>{t(step.descKey)}</Text>
            </View>
          ))}
        </View>
        <TouchableOpacity
          style={[styles.primaryButton, { backgroundColor: colors.text }]}
          onPress={onContinue}
        >
          <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("onboardingGuideButton")}</Text>
        </TouchableOpacity>
      </ScrollView>
    </Animated.View>
  );
}
function LanguageScreen({
  colors,
  t,
  selectedLanguage,
  selectedCurrency,
  onLanguageChange,
  onCurrencyChange,
  onContinue,
  onBack,
  onShowTerms,
  termsAccepted,
  mascotWaveSource,
}) {
  const fade = useFadeIn();
  const wavingSource = mascotWaveSource || CLASSIC_TAMAGOTCHI_ANIMATIONS.waving;
  const [currencyIndicatorVisible, setCurrencyIndicatorVisible] = useState(true);
  const currencyScrollRef = useRef(null);
  const currencyNudgeRan = useRef(false);
  const [shouldAnimateCurrencyNudge, setShouldAnimateCurrencyNudge] = useState(false);
  const handleCurrencyScroll = useCallback(
    (event) => {
      const { contentOffset, contentSize, layoutMeasurement } = event.nativeEvent;
      const scrollable = contentSize.width > layoutMeasurement.width + 4;
      if (!scrollable) {
        setCurrencyIndicatorVisible(false);
        return;
      }
      const atEnd = contentOffset.x + layoutMeasurement.width >= contentSize.width - 8;
      setCurrencyIndicatorVisible(!atEnd);
    },
    [setCurrencyIndicatorVisible]
  );
  useEffect(() => {
    let cancelled = false;
    AsyncStorage.getItem(STORAGE_KEYS.LANGUAGE_CURRENCY_NUDGE)
      .then((value) => {
        if (!cancelled && !value) setShouldAnimateCurrencyNudge(true);
      })
      .catch(() => {});
    return () => {
      cancelled = true;
    };
  }, []);
  useEffect(() => {
    if (!shouldAnimateCurrencyNudge || currencyNudgeRan.current) return undefined;
    currencyNudgeRan.current = true;
    let backTimeout;
    const forwardTimeout = setTimeout(() => {
      currencyScrollRef.current?.scrollTo({ x: 48, animated: true });
      backTimeout = setTimeout(() => {
        currencyScrollRef.current?.scrollTo({ x: 0, animated: true });
      }, 650);
    }, 900);
    AsyncStorage.setItem(STORAGE_KEYS.LANGUAGE_CURRENCY_NUDGE, "1").catch(() => {});
    return () => {
      clearTimeout(forwardTimeout);
      if (backTimeout) clearTimeout(backTimeout);
    };
  }, [shouldAnimateCurrencyNudge]);
  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <View style={styles.onboardContent}>
        <OnboardingBackButton onPress={onBack} colors={colors} t={t} />
        <Image source={wavingSource} style={styles.languageMascot} />
        <Text style={[styles.onboardTitleCompact, { color: colors.text }]}>{t("languageTitle")}</Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("languageSubtitle")}</Text>
        <View style={styles.languageButtons}>
          {SUPPORTED_LANGUAGES.map((langKey) => {
            const label = LANGUAGE_NATIVE_LABELS[langKey] || langKey.toUpperCase();
            const active = selectedLanguage === langKey;
            return (
              <TouchableOpacity
                key={langKey}
                style={[
                  styles.languageButton,
                  {
                    borderColor: colors.border,
                    backgroundColor: active ? colors.card : "transparent",
                  },
                ]}
                onPress={() => onLanguageChange?.(langKey)}
              >
                <Text style={{ color: colors.text, fontWeight: "700" }}>{label}</Text>
              </TouchableOpacity>
            );
          })}
        </View>
        <View style={{ width: "100%", marginTop: 20 }}>
          <Text style={[styles.currencyLabel, { color: colors.muted }]}>
            {t("currencyLabel")} <Text style={{ fontSize: 16 }}>â†’</Text>
          </Text>
          <View style={styles.currencyScrollWrapper}>
            <ScrollView
              ref={currencyScrollRef}
              horizontal
              showsHorizontalScrollIndicator={false}
              style={styles.currencyScroll}
              contentContainerStyle={styles.currencyScrollContent}
              onScroll={handleCurrencyScroll}
              scrollEventThrottle={16}
            >
              {CURRENCIES.map((currency) => {
                const active = currency === selectedCurrency;
                return (
                  <TouchableOpacity
                    key={currency}
                    style={[
                      styles.currencyChipLarge,
                      {
                        backgroundColor: active ? colors.text : "transparent",
                        borderColor: colors.border,
                      },
                    ]}
                    onPress={() => onCurrencyChange?.(currency)}
                  >
                    <Text
                      style={{
                        color: active ? colors.background : colors.text,
                        fontWeight: "600",
                      }}
                    >
                      {currency}
                    </Text>
                  </TouchableOpacity>
                );
              })}
            </ScrollView>
            {currencyIndicatorVisible && (
              <View pointerEvents="none" style={styles.currencyScrollFadeWrapper}>
                <Svg style={styles.currencyScrollFade} width="100%" height="100%">
                  <Defs>
                    <SvgLinearGradient id="currencyFade" x1="0" y1="0" x2="1" y2="0">
                      <SvgStop offset="0%" stopColor={colors.background} stopOpacity="0" />
                      <SvgStop offset="100%" stopColor={colors.background} stopOpacity="1" />
                    </SvgLinearGradient>
                  </Defs>
                  <SvgRect x="0" y="0" width="100%" height="100%" fill="url(#currencyFade)" />
                </Svg>
              </View>
            )}
          </View>
          <Text style={[styles.languageHint, { color: colors.muted }]}>{t("languageCurrencyHint")}</Text>
        </View>
        <TouchableOpacity
          style={[styles.primaryButton, { backgroundColor: colors.text, marginTop: 20 }]}
          onPress={onContinue}
        >
          <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("nextButton")}</Text>
        </TouchableOpacity>
        <View style={styles.languageTermsBlock}>
          <Text style={[styles.languageTermsNote, { color: colors.muted }]}>
            {termsAccepted ? t("languageTermsAccepted") : t("languageTermsHint")}
          </Text>
          <TouchableOpacity
            style={[styles.languageTermsButton, { borderColor: colors.border }]}
            onPress={() => onShowTerms?.()}
          >
            <Text style={[styles.languageTermsButtonText, { color: colors.text }]}>{t("languageTermsLink")}</Text>
          </TouchableOpacity>
        </View>
      </View>
    </Animated.View>
  );
}

function LogoSplash({ onDone }) {
  const [text, setText] = useState("");
  const onDoneRef = useRef(onDone);
  const animationIdRef = useRef(0);
  const completedRef = useRef(false);
  useEffect(() => {
    onDoneRef.current = onDone;
  }, [onDone]);
  const handleLayout = useCallback(() => {
    SplashScreen.hideAsync().catch(() => {});
  }, []);
  useEffect(() => {
    const word = "Almost";
    const animationId = animationIdRef.current + 1;
    animationIdRef.current = animationId;
    completedRef.current = false;
    setText("");
    let index = 0;
    let stepTimer = null;
    let doneTimer = null;
    const step = () => {
      if (animationIdRef.current !== animationId || completedRef.current) return;
      index += 1;
      setText(word.slice(0, index));
      if (index >= word.length) {
        completedRef.current = true;
        doneTimer = setTimeout(() => {
          if (animationIdRef.current !== animationId) return;
          onDoneRef.current?.();
        }, 600);
        return;
      }
      stepTimer = setTimeout(step, 140);
    };
    stepTimer = setTimeout(step, 140);
    return () => {
      if (stepTimer) clearTimeout(stepTimer);
      if (doneTimer) clearTimeout(doneTimer);
    };
  }, []);

  return (
    <View style={styles.logoSplash} onLayout={handleLayout}>
      <Text style={styles.logoSplashText}>{text}</Text>
    </View>
  );
}
const LevelUpCelebration = ({ colors, message, t, onSharePress }) => {
  const isDarkMode = colors.background === THEMES.dark.background;
  const backdropColor = isDarkMode ? "rgba(6,10,18,0.92)" : "rgba(255,247,214,0.95)";
  const cardBackground = isDarkMode ? "rgba(18,24,38,0.95)" : "rgba(255,255,255,0.95)";
  const cardBorder = isDarkMode ? "rgba(255,214,130,0.35)" : "rgba(255,186,0,0.4)";
  const textColor = isDarkMode ? "#F7E7C2" : colors.text;
  const shareButtonBg = isDarkMode ? "#F6C16B" : colors.text;
  const shareButtonText = isDarkMode ? "#1A1205" : colors.background;
  const coins = useMemo(
    () =>
      Array.from({ length: 28 }).map((_, index) => ({
        id: `level_coin_${index}`,
        delay: Math.random() * 400,
        left: Math.random() * SCREEN_WIDTH,
        size: 14 + Math.random() * 20,
        duration: 1500 + Math.random() * 600,
      })),
    []
  );
  const levelNumber = Number(message) || 1;
  return (
    <View style={styles.levelOverlay} pointerEvents="box-none">
      <View style={[styles.levelBackdrop, { backgroundColor: backdropColor }]} />
      <View style={[styles.levelContent, { backgroundColor: cardBackground, borderColor: cardBorder }]}>
        <Text style={[styles.levelTitle, { color: textColor }]}>{t("progressHeroLevel", { level: levelNumber })}</Text>
        <Text style={[styles.levelSubtitle, { color: textColor }]}>
          {t("levelCelebrate", { level: levelNumber })}
        </Text>
        {onSharePress && (
          <TouchableOpacity
            style={[styles.levelShareButton, { backgroundColor: shareButtonBg }]}
            activeOpacity={0.92}
            onPress={() => onSharePress(levelNumber)}
          >
            <Text style={[styles.levelShareButtonText, { color: shareButtonText }]}>
              {t("levelShareButton")}
            </Text>
          </TouchableOpacity>
        )}
      </View>
      {coins.map((coin) => (
        <FallingCoin key={coin.id} {...coin} />
      ))}
    </View>
  );
};

const FallingCoin = ({ left, size, delay, duration }) => {
  const progress = useRef(new Animated.Value(0)).current;
  useEffect(() => {
    const animation = Animated.sequence([
      Animated.delay(delay),
      Animated.timing(progress, {
        toValue: 1,
        duration,
        easing: Easing.in(Easing.quad),
        useNativeDriver: true,
      }),
    ]);
    animation.start();
    return () => animation.stop();
  }, [delay, duration, progress]);

  const translateY = progress.interpolate({
    inputRange: [0, 1],
    outputRange: [-80, Dimensions.get("window").height],
  });
  const rotate = progress.interpolate({
    inputRange: [0, 1],
    outputRange: ["-40deg", "40deg"],
  });
  const opacity = progress.interpolate({
    inputRange: [0, 0.1, 0.9, 1],
    outputRange: [0, 1, 1, 0],
  });

  return (
    <Animated.View
      pointerEvents="none"
      style={[
        styles.levelCoin,
        {
          width: size,
          height: size,
          left,
          opacity,
          transform: [{ translateY }, { rotate }],
        },
      ]}
    />
  );
};

const getRandomFinancialQuote = (language) => {
  const normalized = normalizeLanguage(language);
  const pool = FINANCIAL_QUOTES.map((entry) => entry[normalized] || entry.en).filter(Boolean);
  if (!pool.length) return "";
  return pool[Math.floor(Math.random() * pool.length)];
};

const getSaveProgressCopy = (language) => {
  const normalized = normalizeLanguage(language);
  const map = {
    ru: "Ð”Ð¾ Ñ†ÐµÐ»Ð¸",
    en: "Closer to goal",
    es: "MÃ¡s cerca de la meta",
    fr: "Plus prÃ¨s de l'objectif",
  };
  return map[normalized] || map.en;
};

const getSaveCountdownTitle = (language) => {
  const normalized = normalizeLanguage(language);
  const map = {
    ru: "Ð¡ÐºÐ¾Ð»ÑŒÐºÐ¾ Ð¾ÑÑ‚Ð°Ð»Ð¾ÑÑŒ Ð´Ð¾ Ñ†ÐµÐ»Ð¸",
    en: "Steps left to reach it",
    es: "Lo que falta para llegar",
    fr: "Combien reste-t-il",
  };
  return map[normalized] || map.en;
};

const getSaveCountdownCopy = (language, count) => {
  const normalized = normalizeLanguage(language);
  const safeCount = Math.max(0, Number(count) || 0);
  if (safeCount <= 0) {
    const doneMap = {
      ru: "Ð¦ÐµÐ»ÑŒ Ð¿Ð¾Ñ‡Ñ‚Ð¸ Ð´Ð¾ÑÑ‚Ð¸Ð³Ð½ÑƒÑ‚Ð°!",
      en: "Goal is within reach!",
      es: "La meta estÃ¡ al alcance.",
      fr: "L'objectif est tout proche !",
    };
    return doneMap[normalized] || doneMap.en;
  }
  if (normalized === "ru") {
    const suffix =
      safeCount % 10 === 1 && safeCount % 100 !== 11
        ? "Ð¿Ð¾ÑÑ‚ÑƒÐ¿Ð¾Ðº"
        : safeCount % 10 >= 2 && safeCount % 10 <= 4 && (safeCount % 100 < 10 || safeCount % 100 >= 20)
        ? "Ð¿Ð¾ÑÑ‚ÑƒÐ¿ÐºÐ°"
        : "Ð¿Ð¾ÑÑ‚ÑƒÐ¿ÐºÐ¾Ð²";
    return `Ð•Ñ‰Ñ‘ ${safeCount} ${suffix} Ð´Ð¾ Ñ†ÐµÐ»Ð¸`;
  }
  const map = {
    en: `${safeCount} more actions like this to reach your goal`,
    es: `Quedan ${safeCount} pasos como este hasta la meta`,
    fr: `Encore ${safeCount} actions comme celle-ci pour la cible`,
  };
  return map[normalized] || map.en;
};

const buildSaveCountdownSlots = (count, language) => {
  const safeCount = Math.max(0, Number(count) || 0);
  const formattedLocale = getFormatLocale(language);
  let formattedValue =
    safeCount >= 1000 ? safeCount.toLocaleString(formattedLocale) : safeCount.toString().padStart(3, "0");
  formattedValue = formattedValue.replace(/\u202F/g, " ").replace(/\u00A0/g, " ");
  return formattedValue.split("").map((char, index) => {
    if (/[0-9]/.test(char)) {
      return { type: "digit", value: Number(char), key: `digit_${index}_${char}` };
    }
    if (char === " ") {
      return { type: "space", value: char, key: `space_${index}` };
    }
    return { type: "separator", value: char, key: `separator_${index}_${char}` };
  });
};

const getGoalQuoteMarks = (language) => {
  const normalized = normalizeLanguage(language);
  switch (normalized) {
    case "ru":
    case "fr":
    case "es":
      return ["Â«", "Â»"];
    default:
      return ["â€œ", "â€"];
  }
};

const clampProgress = (value) => {
  if (!Number.isFinite(value)) return 0;
  if (value < 0) return 0;
  if (value > 1) return 1;
  return value;
};
const MIN_PROGRESS_PULSE = 0.012;
const MAX_PROGRESS_PULSE = 0.05;

const SaveCelebration = forwardRef(
  (
    {
      colors,
      payload,
      t,
      language,
      goalCopy,
      goalPrefix = null,
      coinReward = 0,
      playSound,
      mascotHappySource,
      progressStart: progressStartProp = 0,
      progressEnd: progressEndProp = 0,
      remainingActions = 0,
    },
    ref
  ) => {
    const happySource = mascotHappySource || CLASSIC_TAMAGOTCHI_ANIMATIONS.happy;
    const countdownEnabled = !!goalCopy;
    const progressEnabled = !!goalCopy;
    const rawProgressStart = clampProgress(progressStartProp);
    const rawProgressEnd = clampProgress(
      progressEndProp < rawProgressStart ? rawProgressStart : progressEndProp
    );
    const progressStart = rawProgressStart;
    const progressEnd =
      progressEnabled && rawProgressEnd === 0 ? MIN_PROGRESS_PULSE : rawProgressEnd;
    const displayActions = Math.max(0, Number(remainingActions) || 0);
    const countdownSlots = useMemo(
      () => buildSaveCountdownSlots(displayActions, language),
      [displayActions, language]
    );
    const hearts = useMemo(
      () =>
        Array.from({ length: 18 }).map((_, index) => ({
          id: `reward_heart_${index}`,
          left: Math.random() * SCREEN_WIDTH,
          delay: Math.random() * 1200,
          duration: 1800 + Math.random() * 800,
        })),
      []
    );
    const celebrationQuote = useMemo(() => getRandomFinancialQuote(language), [language]);
    const isDarkTheme = colors.background === THEMES.dark.background;
    const primaryCardBg = isDarkTheme ? lightenColor(colors.card, 0.12) : colors.card;
    const primaryCardBorder = isDarkTheme ? lightenColor(colors.border, 0.25) : "rgba(255,181,115,0.7)";
    const countdownCardBg = isDarkTheme ? lightenColor(colors.card, 0.1) : lightenColor(colors.card, 0.04);
    const countdownCardBorder = isDarkTheme ? lightenColor(colors.border, 0.3) : "rgba(255,180,126,0.65)";
    const progressAccent = isDarkTheme ? "#FFD06A" : "#FF8C3B";
    const progressTrack = isDarkTheme ? "rgba(255,255,255,0.08)" : "rgba(17,7,0,0.08)";
    const counterDigitBackground = isDarkTheme ? "rgba(255,255,255,0.08)" : "rgba(255,255,255,0.92)";
    const glowColor = isDarkTheme ? "rgba(255,214,165,0.35)" : "rgba(255,178,120,0.35)";
    const progressValue = useRef(new Animated.Value(progressStart)).current;
    const progressPulse = useRef(new Animated.Value(1)).current;
    const progressHapticTimersRef = useRef([]);
    const progressSoundTimersRef = useRef([]);
    const counterSoundTimersRef = useRef([]);
    const countdownSoundTimerRef = useRef(null);
    const counterSoundStartedRef = useRef(false);
    const fanfarePlayedRef = useRef(false);
    const introOpacity = useRef(new Animated.Value(1)).current;
    const introScale = useRef(new Animated.Value(0.94)).current;
    const countdownOpacity = useRef(new Animated.Value(0)).current;
    const countdownScale = useRef(new Animated.Value(0.9)).current;
    const countdownZoom = useRef(new Animated.Value(1)).current;
    const glowPulse = useRef(new Animated.Value(0)).current;
    const [countdownActive, setCountdownActive] = useState(false);
    const [countdownReady, setCountdownReady] = useState(false);
    const introTimerRef = useRef(null);
    const countdownActiveRef = useRef(false);
    const digitsCompletedRef = useRef(0);
    const digitCount = useMemo(
      () => countdownSlots.filter((slot) => slot.type === "digit").length,
      [countdownSlots]
    );
    const handleDigitSpinComplete = useCallback(() => {
      if (digitCount <= 0) {
        setCountdownReady(true);
        triggerSuccessHaptic();
        return;
      }
      digitsCompletedRef.current += 1;
      triggerSelectionHaptic();
      playCounterBurst();
      if (digitsCompletedRef.current >= digitCount) {
        setCountdownReady(true);
        triggerSuccessHaptic();
      }
    }, [digitCount, playCounterBurst]);
    const progressWidth = progressValue.interpolate({
      inputRange: [0, 1],
      outputRange: [0, SAVE_PROGRESS_BAR_WIDTH],
    });
    useEffect(() => {
      introScale.setValue(0.94);
      const introEntrance = Animated.spring(introScale, {
        toValue: 1,
        useNativeDriver: true,
        friction: 8,
      });
      introEntrance.start();
      return () => introEntrance.stop();
    }, [introScale]);
    useEffect(() => {
      progressValue.setValue(progressStart);
      progressPulse.setValue(1);
      const diff = Math.max(0, progressEnd - progressStart);
      const impactDelta = Math.max(diff, MIN_PROGRESS_PULSE);
      const paddedTarget = clampProgress(progressStart + impactDelta);
      const overshootDelta = Math.min(
        Math.max(impactDelta * 0.65, MIN_PROGRESS_PULSE * 0.75),
        MAX_PROGRESS_PULSE
      );
      const pumpTarget =
        diff < MIN_PROGRESS_PULSE
          ? paddedTarget
          : clampProgress(Math.max(progressStart, progressEnd - overshootDelta * 0.75));
      const overshootTarget = clampProgress(pumpTarget + overshootDelta);
      const fillSequence = Animated.sequence([
        Animated.spring(progressValue, {
          toValue: pumpTarget,
          friction: 7,
          tension: 120,
          velocity: 1.1,
          useNativeDriver: false,
        }),
        Animated.spring(progressValue, {
          toValue: overshootTarget,
          friction: 5,
          tension: 70,
          velocity: 0.8,
          useNativeDriver: false,
        }),
        Animated.spring(progressValue, {
          toValue: progressEnd,
          friction: 11,
          tension: 90,
          velocity: 0.65,
          useNativeDriver: false,
        }),
      ]);
      const anim = Animated.sequence([
        Animated.delay(SAVE_PROGRESS_DELAY_MS),
        Animated.spring(progressPulse, {
          toValue: SAVE_PROGRESS_PULSE_SCALE,
          friction: 6,
          tension: 140,
          useNativeDriver: true,
        }),
        Animated.delay(90),
        fillSequence,
        Animated.delay(60),
        Animated.spring(progressPulse, {
          toValue: 1,
          friction: 9,
          tension: 80,
          useNativeDriver: true,
        }),
      ]);
      anim.start();
      return () => anim.stop();
    }, [progressEnd, progressPulse, progressStart, progressValue]);
    const clearProgressHapticTimers = useCallback(() => {
      if (progressHapticTimersRef.current.length) {
        progressHapticTimersRef.current.forEach((timerId) => clearTimeout(timerId));
        progressHapticTimersRef.current = [];
      }
    }, []);
    const clearProgressSoundTimers = useCallback(() => {
      if (progressSoundTimersRef.current.length) {
        progressSoundTimersRef.current.forEach((timerId) => clearTimeout(timerId));
        progressSoundTimersRef.current = [];
      }
    }, []);
    const clearCounterSoundTimers = useCallback(() => {
      if (counterSoundTimersRef.current.length) {
        counterSoundTimersRef.current.forEach((timerId) => clearTimeout(timerId));
        counterSoundTimersRef.current = [];
      }
    }, []);
    const playCounterBurst = useCallback(() => {
      if (!playSound) return;
      clearCounterSoundTimers();
      const spacing = 70;
      [0, 1, 2].forEach((index) => {
        const timerId = setTimeout(() => {
          playSound("counter", { skipCooldown: index > 0 });
        }, index * spacing);
        counterSoundTimersRef.current.push(timerId);
      });
    }, [clearCounterSoundTimers, playSound]);
    useEffect(() => () => clearCounterSoundTimers(), [clearCounterSoundTimers]);
    const handleCounterSpinStart = useCallback(() => {
      if (!playSound) return;
      if (counterSoundStartedRef.current) return;
      counterSoundStartedRef.current = true;
      playCounterBurst();
    }, [playCounterBurst, playSound]);
    useEffect(() => {
      clearProgressHapticTimers();
      const diff = Math.max(0, progressEnd - progressStart);
      if (diff <= 0) return undefined;
      const schedule = (timeout, fn) => {
        const timerId = setTimeout(fn, Math.max(0, timeout));
        progressHapticTimersRef.current.push(timerId);
      };
      const baseDelay = SAVE_PROGRESS_DELAY_MS + 100;
      const diffScale = Math.min(Math.max(diff, MIN_PROGRESS_PULSE), 0.85);
      const fillDuration = 640 + diffScale * 1600;
      schedule(baseDelay, () => triggerHaptic(Haptics.ImpactFeedbackStyle.Light));
      schedule(baseDelay + fillDuration * 0.45, () => triggerSelectionHaptic());
      schedule(baseDelay + fillDuration * 0.92, () => triggerHaptic(Haptics.ImpactFeedbackStyle.Medium));
      return () => {
        clearProgressHapticTimers();
      };
    }, [clearProgressHapticTimers, progressEnd, progressStart]);
    useEffect(() => {
      clearProgressSoundTimers();
      if (!playSound) return undefined;
      if (countdownEnabled) return undefined;
      const diff = Math.max(0, progressEnd - progressStart);
      if (diff <= 0) return undefined;
      const baseDelay = SAVE_PROGRESS_DELAY_MS + 120;
      const diffScale = Math.min(Math.max(diff, MIN_PROGRESS_PULSE), 0.85);
      const fillDuration = 640 + diffScale * 1600;
      const scheduleSound = (timeout, key) => {
        const timerId = setTimeout(() => playSound(key), Math.max(0, timeout));
        progressSoundTimersRef.current.push(timerId);
      };
      scheduleSound(baseDelay, "counter");
      scheduleSound(baseDelay + fillDuration * 0.55, "counter");
      scheduleSound(baseDelay + fillDuration * 0.94, "coin");
      return () => {
        clearProgressSoundTimers();
      };
    }, [clearProgressSoundTimers, countdownEnabled, playSound, progressEnd, progressStart]);
    const clearIntroTimer = useCallback(() => {
      if (introTimerRef.current) {
        clearTimeout(introTimerRef.current);
        introTimerRef.current = null;
      }
    }, []);
    const startCountdownPhase = useCallback(() => {
      if (!countdownEnabled) return false;
      if (countdownActiveRef.current) return false;
      clearIntroTimer();
      digitsCompletedRef.current = 0;
      counterSoundStartedRef.current = false;
      fanfarePlayedRef.current = false;
      setCountdownReady(digitCount <= 0);
      countdownActiveRef.current = true;
      setCountdownActive(true);
      triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
      Animated.parallel([
        Animated.timing(introOpacity, {
          toValue: 0,
          duration: 320,
          easing: Easing.out(Easing.cubic),
          useNativeDriver: true,
        }),
        Animated.timing(countdownOpacity, {
          toValue: 1,
          duration: 360,
          easing: Easing.out(Easing.cubic),
          useNativeDriver: true,
        }),
        Animated.spring(countdownScale, {
          toValue: 1,
          useNativeDriver: true,
          friction: 8,
        }),
      ]).start();
      return true;
    }, [clearIntroTimer, countdownOpacity, countdownScale, digitCount, introOpacity, playCounterBurst]);
    useEffect(() => {
      if (!countdownEnabled) return undefined;
      introTimerRef.current = setTimeout(() => {
        startCountdownPhase();
      }, SAVE_INTRO_STAGE_DURATION);
      return () => {
        clearIntroTimer();
      };
    }, [clearIntroTimer, countdownEnabled, startCountdownPhase]);
    useEffect(() => {
      if (!countdownEnabled) return;
      countdownActiveRef.current = countdownActive;
    }, [countdownActive]);
    useEffect(() => {
      if (!countdownEnabled || !countdownActive || !countdownReady) return;
      if (countdownSoundTimerRef.current) {
        clearTimeout(countdownSoundTimerRef.current);
        countdownSoundTimerRef.current = null;
      }
      if (playSound && !fanfarePlayedRef.current) {
        fanfarePlayedRef.current = true;
        countdownSoundTimerRef.current = setTimeout(() => {
          playSound("reward");
        }, 160);
      }
      glowPulse.setValue(0);
      countdownZoom.setValue(1);
      const pulse = Animated.sequence([
        Animated.delay(SAVE_COUNTDOWN_ZOOM_DELAY_AFTER_SPIN),
        Animated.parallel([
          Animated.sequence([
            Animated.timing(glowPulse, {
              toValue: 1,
              duration: 260,
              useNativeDriver: true,
            }),
            Animated.timing(glowPulse, {
              toValue: 0,
              duration: 420,
              useNativeDriver: true,
            }),
          ]),
          Animated.sequence([
            Animated.timing(countdownZoom, {
              toValue: 1.04,
              duration: 240,
              easing: Easing.out(Easing.quad),
              useNativeDriver: true,
            }),
            Animated.timing(countdownZoom, {
              toValue: 1,
              duration: 320,
              easing: Easing.out(Easing.quad),
              useNativeDriver: true,
            }),
          ]),
        ]),
        Animated.delay(SAVE_COUNTDOWN_FINAL_HOLD_DELAY),
      ]);
      pulse.start();
      return () => {
        pulse.stop();
        if (countdownSoundTimerRef.current) {
          clearTimeout(countdownSoundTimerRef.current);
          countdownSoundTimerRef.current = null;
        }
      };
    }, [countdownActive, countdownEnabled, countdownReady, countdownZoom, glowPulse, playSound]);
    const percentLabel =
      progressEnd > 0
        ? Math.min(100, Math.max(1, Math.round(progressEnd * 100)))
        : 0;
    const progressCopy = getSaveProgressCopy(language);
    const countdownTitle = getSaveCountdownTitle(language);
    const rewardLabel = Math.max(0, Number(coinReward) || 0);
    const [goalQuoteStart, goalQuoteEnd] = useMemo(() => getGoalQuoteMarks(language), [language]);
    const goalDisplay = goalPrefix && goalCopy ? `${goalQuoteStart}${goalCopy}${goalQuoteEnd}` : goalCopy;
    const rewardRowBg = isDarkTheme ? "rgba(255,255,255,0.08)" : "rgba(33,150,243,0.08)";
    useImperativeHandle(
      ref,
      () => ({
        skipToCountdown: () => (countdownEnabled ? startCountdownPhase() : false),
        isCountdownActive: () => (countdownEnabled ? countdownActiveRef.current : false),
      }),
      [countdownEnabled, startCountdownPhase]
    );
    return (
      <View style={styles.saveCelebrationOverlay} pointerEvents="none">
        {hearts.map((heart) => (
          <RewardHeart key={heart.id} {...heart} />
        ))}
        <Animated.View
          style={[
            styles.saveCelebrationCard,
            styles.saveCelebrationPrimary,
            {
              backgroundColor: primaryCardBg,
              borderColor: primaryCardBorder,
              opacity: introOpacity,
              transform: [{ scale: introScale }],
            },
          ]}
        >
          <Image source={happySource} style={styles.saveCelebrationCat} />
          <Text style={[styles.saveCelebrationTitle, { color: colors.text }]}>
            {t("saveCelebrateTitlePrefix")}
          </Text>
          <Text style={[styles.saveCelebrationSubtitle, { color: colors.text }]}>
            {payload?.title || ""}
          </Text>
          {rewardLabel > 0 && (
            <View style={[styles.saveRewardRow, { backgroundColor: rewardRowBg }]}>
              <Image source={HEALTH_COIN_TIERS[0].asset} style={styles.saveRewardIcon} />
              <Text style={[styles.saveRewardText, { color: colors.text }]}>
                {t("saveOverlayCoinReward", { amount: rewardLabel })}
              </Text>
            </View>
          )}
          {celebrationQuote ? (
            <Text style={[styles.saveQuote, { color: colors.text }]}>{celebrationQuote}</Text>
          ) : null}
          {progressEnabled && (
            <Animated.View style={[styles.saveProgressSection, { transform: [{ scaleY: progressPulse }] }]}>
              <View style={[styles.saveProgressTrack, { backgroundColor: progressTrack }]}>
                <Animated.View
                  style={[
                    styles.saveProgressFill,
                    {
                      width: progressWidth,
                      backgroundColor: progressAccent,
                    },
                  ]}
                />
              </View>
              <View style={styles.saveProgressLabelRow}>
                <Text style={[styles.saveProgressValue, { color: colors.text }]}>{percentLabel}%</Text>
                <Text style={[styles.saveProgressHint, { color: colors.muted }]}>{progressCopy}</Text>
              </View>
            </Animated.View>
          )}
        </Animated.View>
        {countdownEnabled && (
          <Animated.View
            style={[
              styles.saveCelebrationCard,
              styles.saveCountdownCard,
              {
                backgroundColor: countdownCardBg,
                borderColor: countdownCardBorder,
                opacity: countdownOpacity,
                transform: [{ scale: countdownScale }, { scale: countdownZoom }],
              },
            ]}
          >
            <Animated.View
              pointerEvents="none"
              style={[
                styles.saveCountdownGlow,
                {
                  backgroundColor: glowColor,
                  opacity: glowPulse,
                },
              ]}
            />
            <Text style={[styles.saveCountdownTitle, { color: colors.text }]}>{countdownTitle}</Text>
            <View style={styles.saveCounterRow}>
              {countdownSlots.map((slot, index) => {
                if (slot.type === "digit") {
                  return (
                    <SaveCounterDigit
                      key={`${slot.key}-${countdownActive}`}
                      index={index}
                      digit={slot.value}
                      delay={index * 110}
                      active={countdownActive}
                      color={colors.text}
                      backgroundColor={counterDigitBackground}
                      onSpinStart={index === 0 ? handleCounterSpinStart : undefined}
                      onSpinComplete={handleDigitSpinComplete}
                    />
                  );
                }
                if (slot.type === "separator") {
                  return (
                    <View key={`${slot.key}-sep`} style={styles.saveCounterSeparator}>
                      <Text style={[styles.saveCounterSeparatorText, { color: colors.muted }]}>{slot.value}</Text>
                    </View>
                  );
                }
                return <View key={`${slot.key}-space`} style={styles.saveCounterSpace} />;
              })}
            </View>
            {goalPrefix && goalDisplay ? (
              <>
                <Text style={[styles.saveCountdownGoalPrefix, { color: colors.muted }]}>{goalPrefix}</Text>
                <Text style={[styles.saveCountdownGoal, { color: colors.text }]}>{goalDisplay}</Text>
              </>
            ) : goalDisplay ? (
              <Text style={[styles.saveCountdownGoal, { color: colors.text }]}>{goalDisplay}</Text>
            ) : null}
          </Animated.View>
        )}
      </View>
    );
  }
);

const SaveCounterDigit = ({
  digit = 0,
  delay = 0,
  active = false,
  color = "#000",
  backgroundColor = "rgba(0,0,0,0.05)",
  index = 0,
  onSpinStart,
  onSpinComplete,
}) => {
  const spinProgress = useRef(new Animated.Value(0)).current;
  const digitScale = useRef(new Animated.Value(0.96)).current;
  const tiltProgress = useRef(new Animated.Value(0)).current;
  const shineProgress = useRef(new Animated.Value(0)).current;
  const loops = Math.max(1, SAVE_COUNTER_SPIN_LOOPS + index);
  const spinHapticTimeoutsRef = useRef([]);
  const spinHapticIntervalRef = useRef(null);
  const clearSpinHaptics = useCallback(() => {
    if (spinHapticTimeoutsRef.current.length) {
      spinHapticTimeoutsRef.current.forEach((timerId) => clearTimeout(timerId));
      spinHapticTimeoutsRef.current = [];
    }
    if (spinHapticIntervalRef.current) {
      clearInterval(spinHapticIntervalRef.current);
      spinHapticIntervalRef.current = null;
    }
  }, []);
  const digitsSequence = useMemo(() => {
    const safeDigit = Math.max(0, Number(digit) || 0);
    const values = [];
    for (let counter = 0; counter < loops * 10; counter += 1) {
      values.push(counter % 10);
    }
    values.push(safeDigit);
    return values;
  }, [digit, loops]);
  const spinSteps = Math.max(1, digitsSequence.length - 1);
  const translateY = spinProgress.interpolate({
    inputRange: [0, spinSteps],
    outputRange: [0, -SAVE_COUNTER_DIGIT_HEIGHT * spinSteps],
  });
  const rotateX = tiltProgress.interpolate({
    inputRange: [0, 1],
    outputRange: ["0deg", "-7deg"],
  });
  const highlightOpacity = shineProgress.interpolate({
    inputRange: [0, 1],
    outputRange: [0.1, 0.7],
  });
  useEffect(() => {
    spinProgress.setValue(0);
    digitScale.setValue(0.96);
    tiltProgress.setValue(0);
    shineProgress.setValue(0);
    if (!active) return;
    const spinStartTimer = setTimeout(() => {
      onSpinStart?.();
    }, Math.max(0, delay));
    const animation = Animated.sequence([
      Animated.delay(delay),
      Animated.timing(spinProgress, {
        toValue: spinSteps - 0.35,
        duration: 900 + spinSteps * 12,
        easing: Easing.out(Easing.cubic),
        useNativeDriver: true,
      }),
      Animated.timing(spinProgress, {
        toValue: spinSteps,
        duration: 160,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }),
      Animated.parallel([
        Animated.spring(digitScale, {
          toValue: 1.08,
          friction: 5,
          tension: 140,
          useNativeDriver: true,
        }),
        Animated.spring(tiltProgress, {
          toValue: 1,
          friction: 6,
          tension: 110,
          useNativeDriver: true,
        }),
        Animated.sequence([
          Animated.timing(shineProgress, {
            toValue: 1,
            duration: 160,
            useNativeDriver: true,
          }),
          Animated.spring(shineProgress, {
            toValue: 0.35,
            friction: 6,
            useNativeDriver: true,
          }),
        ]),
      ]),
      Animated.spring(digitScale, {
        toValue: 1,
        friction: 7,
        tension: 90,
        useNativeDriver: true,
      }),
      Animated.spring(tiltProgress, {
        toValue: 0,
        friction: 7,
        tension: 70,
        useNativeDriver: true,
      }),
    ]);
    animation.start(({ finished }) => {
      if (finished) {
        onSpinComplete?.();
      }
    });
    return () => {
      clearTimeout(spinStartTimer);
      animation.stop();
    };
  }, [
    active,
    delay,
    digitScale,
    onSpinComplete,
    onSpinStart,
    shineProgress,
    spinProgress,
    spinSteps,
    tiltProgress,
  ]);
  useEffect(() => {
    clearSpinHaptics();
    if (!active) return undefined;
    const startDelay = Math.max(0, delay + 60);
    const spinDuration = 900 + spinSteps * 12 + 160;
    const tickInterval = Math.max(70, Math.min(170, spinDuration / Math.max(2, loops * 1.2)));
    const startTimer = setTimeout(() => {
      triggerSelectionHaptic();
      spinHapticIntervalRef.current = setInterval(() => {
        triggerSelectionHaptic();
      }, tickInterval);
    }, startDelay);
    const stopTimer = setTimeout(() => {
      clearSpinHaptics();
    }, startDelay + spinDuration);
    spinHapticTimeoutsRef.current = [startTimer, stopTimer];
    return () => {
      clearSpinHaptics();
    };
  }, [active, clearSpinHaptics, delay, loops, spinSteps]);
  return (
    <Animated.View style={[styles.saveCounterDigit, { transform: [{ scale: digitScale }] }]}>
      <Animated.View
        style={[
          styles.saveCounterDigitSurface,
          {
            backgroundColor,
            transform: [{ perspective: 400 }, { rotateX }],
          },
        ]}
      >
        <View pointerEvents="none" style={styles.saveCounterDigitEdgeTop} />
        <View pointerEvents="none" style={styles.saveCounterDigitEdgeBottom} />
        <Animated.View
          style={[
            styles.saveCounterDigitColumn,
            {
              transform: [{ translateY }],
            },
          ]}
        >
          {digitsSequence.map((value, valueIndex) => (
            <Text key={`${value}-${valueIndex}`} style={[styles.saveCounterDigitText, { color }]}>
              {value}
            </Text>
          ))}
        </Animated.View>
        <Animated.View
          pointerEvents="none"
          style={[styles.saveCounterDigitHighlight, { opacity: highlightOpacity }]}
        />
        <View pointerEvents="none" style={styles.saveCounterDigitDivider} />
      </Animated.View>
    </Animated.View>
  );
};

const RewardCelebration = ({ colors, message, t, mascotHappySource }) => {
  const happySource = mascotHappySource || CLASSIC_TAMAGOTCHI_ANIMATIONS.happy;
  const hearts = useMemo(
    () =>
      Array.from({ length: 18 }).map((_, index) => ({
        id: `reward_heart_${index}`,
        left: Math.random() * SCREEN_WIDTH,
        delay: Math.random() * 1200,
        duration: 1800 + Math.random() * 800,
      })),
    []
  );
  const isDarkTheme = colors.background === THEMES.dark.background;
  const rewardBackdropColor = isDarkTheme ? "rgba(0,0,0,0.85)" : "rgba(255,241,225,0.92)";
  const rewardCardBg = isDarkTheme ? lightenColor(colors.card, 0.12) : colors.card;
  const rewardCardBorder = isDarkTheme ? lightenColor(colors.border, 0.25) : "rgba(255,181,115,0.7)";
  return (
    <View style={styles.rewardOverlay}>
      <View style={[styles.rewardBackdrop, { backgroundColor: rewardBackdropColor }]} />
      {hearts.map((heart) => (
        <RewardHeart key={heart.id} {...heart} />
      ))}
      <View
        style={[
          styles.rewardCard,
          { backgroundColor: rewardCardBg, borderColor: rewardCardBorder },
        ]}
      >
        <Image source={happySource} style={styles.rewardCat} />
        <Text style={[styles.rewardTitle, { color: colors.text }]}>
          {t("rewardCelebrateTitle", { title: message })}
        </Text>
        <Text style={[styles.rewardSubtitle, { color: colors.muted }]}>
          {t("rewardCelebrateSubtitle")}
        </Text>
      </View>
    </View>
  );
};

const HealthCelebration = ({ colors, payload, t, language }) => {
  const scale = useRef(new Animated.Value(1)).current;
  useEffect(() => {
    const pulse = Animated.loop(
      Animated.sequence([
        Animated.timing(scale, {
          toValue: 1.2,
          duration: 460,
          useNativeDriver: true,
        }),
        Animated.timing(scale, {
          toValue: 1,
          duration: 460,
          useNativeDriver: true,
        }),
      ])
    );
    pulse.start();
    return () => pulse.stop();
  }, [scale]);
  const data = payload && typeof payload === "object" ? payload : { reason: payload };
  const amount =
    typeof data.amount === "number" && Number.isFinite(data.amount) ? data.amount : HEALTH_PER_REWARD;
  const coinValue =
    typeof data.coinValue === "number" && Number.isFinite(data.coinValue) ? data.coinValue : amount;
  const baseSubtitle = t("healthCelebrateSubtitle");
  const reason = data.reason || baseSubtitle;
  const isDarkTheme = colors.background === THEMES.dark.background;
  const backdropColor = isDarkTheme ? "rgba(0,0,0,0.85)" : "rgba(6,9,19,0.35)";
  const cardBg = isDarkTheme ? lightenColor(colors.card, 0.15) : colors.card;
  const cardBorder = isDarkTheme ? lightenColor(colors.border, 0.25) : "rgba(0,0,0,0.1)";
  const heartBackground = isDarkTheme ? "rgba(255,255,255,0.05)" : "rgba(255,255,255,0.8)";
  const rewardCoinTier = getHealthCoinTierForAmount(coinValue);
  const titleAmount = formatHealthRewardLabel(coinValue, language);
  return (
    <View style={styles.healthOverlay}>
      <View style={[styles.healthBackdrop, { backgroundColor: backdropColor }]} />
      <Animated.View
        style={[
          styles.healthHeartWrap,
          { transform: [{ scale }], backgroundColor: heartBackground },
        ]}
      >
        <Image source={rewardCoinTier.asset} style={styles.healthCoinImage} />
      </Animated.View>
      <View style={[styles.healthCard, { backgroundColor: cardBg, borderColor: cardBorder }]}>
        <Text style={[styles.healthTitle, { color: colors.text }]}>
          {t("healthCelebrateTitle", { amount: titleAmount })}
        </Text>
        <Text style={[styles.healthSubtitle, { color: colors.muted }]}>{reason}</Text>
        {reason !== baseSubtitle && (
          <Text style={[styles.healthSubtitle, { color: colors.muted }]}>{baseSubtitle}</Text>
        )}
      </View>
    </View>
  );
};

const HeartRain = ({ count = 26 }) => {
  const hearts = useMemo(
    () =>
      Array.from({ length: count }).map((_, index) => ({
        id: `rain_heart_${index}`,
        left: Math.random() * (SCREEN_WIDTH - 20),
        delay: Math.random() * 1400,
        duration: 2200 + Math.random() * 1600,
        size: 14 + Math.random() * 14,
        sway: 12 + Math.random() * 16,
        rotate: Math.random() * 40 - 20,
      })),
    [count]
  );
  return (
    <View style={styles.heartRain} pointerEvents="none">
      {hearts.map((heart) => (
        <FallingHeart key={heart.id} {...heart} />
      ))}
    </View>
  );
};

const FallingHeart = ({ left, delay, duration, size, sway, rotate }) => {
  const translateY = useRef(new Animated.Value(-40)).current;
  const translateX = useRef(new Animated.Value(0)).current;
  const opacity = useRef(new Animated.Value(0)).current;
  useEffect(() => {
    const drop = Animated.parallel([
      Animated.timing(translateY, {
        toValue: SCREEN_HEIGHT + 120,
        duration,
        easing: Easing.in(Easing.quad),
        useNativeDriver: true,
      }),
      Animated.sequence([
        Animated.timing(opacity, {
          toValue: 1,
          duration: Math.min(320, duration * 0.2),
          useNativeDriver: true,
        }),
        Animated.timing(opacity, {
          toValue: 0,
          duration: Math.min(420, duration * 0.3),
          delay: Math.max(duration * 0.4, 0),
          useNativeDriver: true,
        }),
      ]),
      Animated.sequence([
        Animated.timing(translateX, {
          toValue: sway,
          duration: duration * 0.5,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(translateX, {
          toValue: -sway,
          duration: duration * 0.5,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ]),
    ]);
    const anim = Animated.loop(Animated.sequence([Animated.delay(delay), drop]), {
      resetBeforeIteration: true,
    });
    anim.start();
    return () => anim.stop();
  }, [delay, duration, opacity, sway, translateX, translateY]);

  return (
    <Animated.Text
      style={[
        styles.heartRainDrop,
        {
          left,
          fontSize: size,
          opacity,
          transform: [{ translateY }, { translateX }, { rotate: `${rotate}deg` }],
        },
      ]}
    >
      â¤ï¸
    </Animated.Text>
  );
};

const GoalCelebration = ({ colors, payload, t, mascotHappySource, onClose }) => {
  const happySource = mascotHappySource || CLASSIC_TAMAGOTCHI_ANIMATIONS.happy;
  const data =
    payload && typeof payload === "object"
      ? payload
      : { title: payload || t("goalCelebrationTitle"), subtitle: t("goalCelebrationSubtitle") };
  const summary = data.summary || null;
  const currency = data.currency || DEFAULT_PROFILE.currency;
  const language = data.language || DEFAULT_LANGUAGE;
  const rewardCoins = Math.max(0, Number(data.rewardCoins) || 0);
  const rewardAsset = data.rewardAsset || GOAL_COMPLETION_REWARD_TIER?.asset || null;
  const totalSavedUSD =
    Number.isFinite(summary?.totalSavedUSD) && summary.totalSavedUSD > 0
      ? summary.totalSavedUSD
      : Number.isFinite(data.fallbackTotalUSD)
      ? data.fallbackTotalUSD
      : 0;
  const totalSavedLabel = formatCurrency(convertToCurrency(totalSavedUSD, currency), currency);
  const totalWins = summary?.totalCount || 0;
  const totalDays = summary?.daysCount || 0;
  const strongDay = summary?.strongDay || null;
  const weakDay = summary?.weakDay || null;
  const breakdown = summary?.breakdown || [];
  const resolveDayLabel = (dayKey) => {
    if (!dayKey) return "";
    const ts = parseDayKey(dayKey)?.getTime();
    return formatRelativeDayLabel(ts, Date.now(), language) || dayKey;
  };
  const formatAmount = (amountUSD) =>
    formatCurrency(convertToCurrency(Math.max(0, amountUSD || 0), currency), currency);
  const strongLabel = strongDay ? resolveDayLabel(strongDay.dayKey) : "";
  const strongAmount = strongDay ? formatAmount(strongDay.savedUSD) : "";
  const strongBody = strongDay
    ? strongDay.topTitle
      ? t("goalCelebrationStrongBody", {
          dayLabel: strongLabel,
          amount: strongAmount,
          count: strongDay.count || 0,
          title: strongDay.topTitle,
        })
      : t("goalCelebrationStrongBodyNoTitle", {
          dayLabel: strongLabel,
          amount: strongAmount,
          count: strongDay.count || 0,
        })
    : t("goalCelebrationStrongFallback");
  const weakLabel = weakDay ? resolveDayLabel(weakDay.dayKey) : "";
  const weakAmount = weakDay ? formatAmount(weakDay.savedUSD) : "";
  const weakBody = weakDay
    ? summary?.weakMode === "spend" && (weakDay.spendCount || 0) > 0
      ? t("goalCelebrationWeakBody", {
          dayLabel: weakLabel,
          spends: weakDay.spendCount || 0,
          amount: weakAmount,
          count: weakDay.count || 0,
        })
      : t("goalCelebrationWeakBodyNoSpends", {
          dayLabel: weakLabel,
          amount: weakAmount,
          count: weakDay.count || 0,
        })
    : t("goalCelebrationWeakFallback");
  const weekBars = summary?.lastSevenDays || [];
  const maxWeekSaved = summary?.maxWeekSavedUSD || 0;
  const isDarkTheme = colors.background === THEMES.dark.background;
  const backdropColor = isDarkTheme ? "rgba(0,0,0,0.85)" : "rgba(7,44,23,0.85)";
  const cardBg = isDarkTheme ? lightenColor(colors.card, 0.15) : "#E7FFE9";
  const cardBorder = isDarkTheme ? lightenColor(colors.border, 0.25) : "#8FD7AE";
  const accent = isDarkTheme ? "#7CFFB0" : "#18B86A";
  return (
    <View style={styles.goalCelebrateOverlay}>
      <View style={[styles.goalCelebrateBackdrop, { backgroundColor: backdropColor }]} />
      <HeartRain />
      <View style={[styles.goalCelebrateCard, { backgroundColor: cardBg, borderColor: cardBorder }]}>
        <ScrollView contentContainerStyle={styles.goalCelebrateContent} showsVerticalScrollIndicator={false}>
          <View style={styles.goalCelebrateHeader}>
            <Image source={happySource} style={styles.goalCelebrateCat} />
            <View style={styles.goalCelebrateHeaderText}>
              <Text style={[styles.goalCelebrateTitle, { color: colors.text }]}>
                {data.title || t("goalCelebrationTitle")}
              </Text>
              <Text style={[styles.goalCelebrateSubtitle, { color: colors.muted }]}>
                {data.subtitle || t("goalCelebrationSubtitle")}
              </Text>
            </View>
          </View>
          {data.targetLabel ? (
            <View style={[styles.goalCelebrateBadge, { borderColor: cardBorder }]}>
              <Text style={[styles.goalCelebrateBadgeText, { color: colors.text }]}>
                {data.targetLabel}
              </Text>
            </View>
          ) : null}
          <View style={[styles.goalCelebrateTotal, { borderColor: cardBorder }]}>
            <Text style={[styles.goalCelebrateTotalLabel, { color: colors.muted }]}>
              {t("goalCelebrationTotalLabel")}
            </Text>
            <Text style={[styles.goalCelebrateTotalValue, { color: colors.text }]}>
              {totalSavedLabel}
            </Text>
            <Text style={[styles.goalCelebrateTotalSub, { color: colors.muted }]}>
              {t("goalCelebrationTotalSub", { wins: totalWins, days: totalDays })}
            </Text>
            <Text style={[styles.goalCelebratePraise, { color: colors.text }]}>
              {t("goalCelebrationPraise")}
            </Text>
            {rewardCoins > 0 && rewardAsset ? (
              <View style={[styles.goalCelebrateRewardRow, { backgroundColor: "rgba(0,0,0,0.06)" }]}>
                <Image source={rewardAsset} style={styles.goalCelebrateRewardCoin} />
                <Text style={[styles.goalCelebrateRewardText, { color: colors.text }]}>
                  {t("saveOverlayCoinReward", { amount: rewardCoins })}
                </Text>
              </View>
            ) : null}
          </View>
          <View style={styles.goalCelebrateStatsRow}>
            <View style={[styles.goalCelebrateStatCard, { borderColor: cardBorder }]}>
              <Text style={[styles.goalCelebrateStatLabel, { color: colors.muted }]}>
                {t("goalCelebrationTotalWinsLabel")}
              </Text>
              <Text style={[styles.goalCelebrateStatValue, { color: colors.text }]}>
                {totalWins}
              </Text>
            </View>
            <View style={[styles.goalCelebrateStatCard, { borderColor: cardBorder }]}>
              <Text style={[styles.goalCelebrateStatLabel, { color: colors.muted }]}>
                {t("goalCelebrationTotalDaysLabel")}
              </Text>
              <Text style={[styles.goalCelebrateStatValue, { color: colors.text }]}>
                {totalDays}
              </Text>
            </View>
          </View>
          {weekBars.length ? (
            <View style={styles.goalCelebrateWeek}>
              <Text style={[styles.goalCelebrateSectionLabel, { color: colors.muted }]}>
                {t("goalCelebrationWeekLabel")}
              </Text>
              <View style={styles.goalCelebrateWeekBars}>
                {weekBars.map((entry) => {
                  const ratio = maxWeekSaved > 0 ? entry.savedUSD / maxWeekSaved : 0;
                  const height = 8 + 32 * ratio;
                  return (
                    <View key={entry.dayKey} style={styles.goalCelebrateWeekBarWrap}>
                      <View
                        style={[
                          styles.goalCelebrateWeekBar,
                          {
                            height,
                            backgroundColor: entry.savedUSD > 0 ? accent : "rgba(0,0,0,0.08)",
                          },
                        ]}
                      />
                    </View>
                  );
                })}
              </View>
            </View>
          ) : null}
          <View style={styles.goalCelebrateInsights}>
            <View style={[styles.goalCelebrateInsightCard, { borderColor: cardBorder }]}>
              <View style={styles.goalCelebrateInsightHeader}>
                <Text style={styles.goalCelebrateInsightIcon}>ðŸ”¥</Text>
                <Text style={[styles.goalCelebrateInsightTitle, { color: colors.text }]}>
                  {t("goalCelebrationStrongTitle")}
                </Text>
              </View>
              <Text style={[styles.goalCelebrateInsightBody, { color: colors.muted }]}>
                {strongBody}
              </Text>
            </View>
            <View style={[styles.goalCelebrateInsightCard, { borderColor: cardBorder }]}>
              <View style={styles.goalCelebrateInsightHeader}>
                <Text style={styles.goalCelebrateInsightIcon}>ðŸŒ§ï¸</Text>
                <Text style={[styles.goalCelebrateInsightTitle, { color: colors.text }]}>
                  {t("goalCelebrationWeakTitle")}
                </Text>
              </View>
              <Text style={[styles.goalCelebrateInsightBody, { color: colors.muted }]}>
                {weakBody}
              </Text>
            </View>
          </View>
          {breakdown.length ? (
            <View style={styles.goalCelebrateBreakdown}>
              <Text style={[styles.goalCelebrateSectionLabel, { color: colors.muted }]}>
                {t("goalCelebrationBreakdownLabel")}
              </Text>
              <View style={styles.goalCelebrateBreakdownList}>
                {breakdown.map((entry) => (
                  <View key={entry.title} style={styles.goalCelebrateBreakdownRow}>
                    <Text style={[styles.goalCelebrateBreakdownTitle, { color: colors.text }]}>
                      {entry.title}
                    </Text>
                    <Text style={[styles.goalCelebrateBreakdownMeta, { color: colors.muted }]}>
                      {t("goalCelebrationBreakdownItem", {
                        count: entry.count || 0,
                        amount: formatAmount(entry.savedUSD || 0),
                      })}
                    </Text>
                  </View>
                ))}
              </View>
            </View>
          ) : null}
          <TouchableOpacity style={[styles.goalCelebrateCta, { backgroundColor: colors.text }]} onPress={onClose}>
            <Text style={[styles.goalCelebrateCtaText, { color: colors.background }]}>
              {t("goalCelebrationCta")}
            </Text>
          </TouchableOpacity>
        </ScrollView>
      </View>
    </View>
  );
};

const DailyRewardCelebration = ({ colors, payload, t }) => {
  const rewardLabel = payload?.amount || "";
  const amountValue =
    typeof payload === "object" && Number.isFinite(payload?.amountValue)
      ? payload.amountValue
      : 0;
  const coinTier = getHealthCoinTierForAmount(amountValue) || HEALTH_COIN_TIERS[0];
  const reason = payload?.reason || "";
  const isDarkTheme = colors.background === THEMES.dark.background;
  const cardBg = isDarkTheme ? lightenColor(colors.card, 0.12) : "#FFF7EC";
  const cardBorder = isDarkTheme ? lightenColor(colors.border, 0.3) : "#FFD0A6";
  const badgeBg = isDarkTheme ? "rgba(255,210,140,0.2)" : "rgba(255,170,90,0.2)";
  const accent = isDarkTheme ? "#FFD06A" : "#FF9B4A";
  return (
    <View style={styles.dailyRewardOverlay} pointerEvents="none">
      <View style={[styles.dailyRewardBackdrop, { backgroundColor: isDarkTheme ? "rgba(0,0,0,0.82)" : "rgba(255,241,225,0.92)" }]} />
      <View style={[styles.dailyRewardCard, { backgroundColor: cardBg, borderColor: cardBorder }]}>
        <View style={[styles.dailyRewardBadge, { backgroundColor: badgeBg, borderColor: cardBorder }]}>
          <Text style={[styles.dailyRewardBadgeText, { color: colors.text }]}>
            {t("dailyRewardButtonLabel")}
          </Text>
        </View>
        <View style={styles.dailyRewardHero}>
          <View style={[styles.dailyRewardCoinWrap, { backgroundColor: accent }]}>
            <Image source={coinTier.asset} style={styles.dailyRewardCoinLarge} />
          </View>
          <Text style={[styles.dailyRewardAmountLarge, { color: colors.text }]}>
            {rewardLabel ? `+${rewardLabel}` : t("dailyRewardCelebrateMessage", { amount: "" })}
          </Text>
          <Text style={[styles.dailyRewardTitle, { color: colors.text }]}>
            {t("dailyRewardButtonLabel")}
          </Text>
        </View>
        {reason ? (
          <Text style={[styles.dailyRewardReason, { color: colors.muted }]}>{reason}</Text>
        ) : null}
        <View style={[styles.dailyRewardFooter, { borderColor: cardBorder }]}>
          <Text style={[styles.dailyRewardHint, { color: colors.muted }]}>
            {t("dailyRewardCollectedLabel")}
          </Text>
        </View>
      </View>
    </View>
  );
};

const FeatureUnlockCelebration = ({ colors, payload, t, tamagotchiAnimations, onDismiss }) => {
  const happySource = tamagotchiAnimations?.happy || CLASSIC_TAMAGOTCHI_ANIMATIONS.happy;
  const messageText = typeof payload === "object" ? payload?.body || "" : payload || "";
  const variantKey = typeof payload === "object" ? payload?.variant || null : null;
  const variant = variantKey ? FEATURE_UNLOCK_VARIANT_CONFIG[variantKey] : null;
  const whereLabel = t("featureUnlockWhereLabel");
  const previewSectionLabel = t("featureUnlockPreviewLabel");
  const sectionTitle = variant ? t(variant.titleKey) : "";
  const sectionDescription = variant ? t(variant.descriptionKey) : "";
  const previewBadgeLabel = variant ? t(variant.previewLabelKey) : "";
  const previewActionLabel =
    variantKey === "rewardsDaily" ? t("dailyRewardClaimHint") : null;
  const isDarkTheme = colors.background === THEMES.dark.background;
  const cardBg = isDarkTheme ? lightenColor(colors.card, 0.12) : lightenColor(colors.card, 0.22);
  const cardBorder = isDarkTheme ? lightenColor(colors.border, 0.3) : "rgba(0,0,0,0.08)";
  const sectionBg = isDarkTheme ? "rgba(255,255,255,0.03)" : "rgba(0,0,0,0.02)";
  return (
    <View style={[styles.featureUnlockCard, { backgroundColor: cardBg, borderColor: cardBorder }]}>
      <View style={styles.featureUnlockHeader}>
        <Image source={happySource} style={styles.featureUnlockCat} />
        <Text style={[styles.featureUnlockMessage, { color: colors.text }]}>{messageText}</Text>
      </View>
      {variant ? (
        <View style={[styles.featureUnlockSection, { backgroundColor: sectionBg, borderColor: colors.border }]}>
          <Text style={[styles.featureUnlockSectionLabel, { color: colors.muted }]}>{whereLabel}</Text>
          <Text style={[styles.featureUnlockSectionTitle, { color: colors.text }]}>{sectionTitle}</Text>
          <Text style={[styles.featureUnlockSectionDescription, { color: colors.muted }]}>{sectionDescription}</Text>
          <Text style={[styles.featureUnlockSectionLabel, { color: colors.muted, marginTop: 16 }]}>
            {previewSectionLabel}
          </Text>
          <FeatureUnlockIllustration
            variantKey={variantKey}
            colors={colors}
            label={previewBadgeLabel}
            actionLabel={previewActionLabel}
          />
        </View>
      ) : null}
      <TouchableOpacity style={[styles.featureUnlockButton, { backgroundColor: colors.text }]} onPress={onDismiss}>
        <Text style={[styles.featureUnlockButtonText, { color: colors.background }]}>
          {t("profileOk") || "ÐžÐº"}
        </Text>
      </TouchableOpacity>
    </View>
  );
};

const FeatureUnlockIllustration = ({ variantKey, colors, label, actionLabel }) => {
  if (!variantKey || !FEATURE_UNLOCK_VARIANT_CONFIG[variantKey]) return null;
  const isDarkTheme = colors.background === THEMES.dark.background;
  const screenBg = isDarkTheme ? "rgba(255,255,255,0.02)" : "rgba(0,0,0,0.02)";
  const accent = isDarkTheme ? "#FFC857" : "#F5A524";
  const baseLineColor = isDarkTheme ? "rgba(255,255,255,0.2)" : "rgba(0,0,0,0.12)";
  const borderColor = isDarkTheme ? "rgba(255,255,255,0.05)" : "rgba(0,0,0,0.05)";
  const tabIcons = ["ðŸ§ ", "ðŸŽ¯", "ðŸ’­", "ðŸ†", "ðŸ‘¤"];
  const renderTabBar = (activeIndex) => (
    <View style={styles.featureUnlockTabs}>
      {tabIcons.map((icon, idx) => {
        const active = idx === activeIndex;
        return (
          <View
            key={`${icon}_${idx}`}
            style={[
              styles.featureUnlockTab,
              {
                borderColor: isDarkTheme ? "rgba(255,255,255,0.1)" : "rgba(0,0,0,0.08)",
                backgroundColor: active ? accent : "transparent",
              },
            ]}
          >
            <Text style={[styles.featureUnlockTabIcon, { color: active ? "#1F1300" : colors.muted }]}>{icon}</Text>
          </View>
        );
      })}
    </View>
  );
  const renderPreviewCard = () => (
    <View
      style={[
        styles.featureUnlockPreviewCard,
        {
          backgroundColor: isDarkTheme ? "rgba(255,255,255,0.04)" : "rgba(255,255,255,0.92)",
          borderColor: isDarkTheme ? "rgba(255,255,255,0.05)" : "rgba(0,0,0,0.05)",
        },
      ]}
    >
      <View style={[styles.featureUnlockPreviewBadge, { backgroundColor: accent }]}>
        <Text style={styles.featureUnlockPreviewBadgeText}>{label}</Text>
      </View>
      <View style={styles.featureUnlockPreviewLines}>
        <View style={[styles.featureUnlockPreviewLine, { width: "70%", backgroundColor: baseLineColor }]} />
        <View style={[styles.featureUnlockPreviewLine, { width: "50%", backgroundColor: baseLineColor }]} />
      </View>
    </View>
  );
  switch (variantKey) {
    case "rewardsDaily":
      return (
        <View style={[styles.featureUnlockIllustration, { backgroundColor: screenBg, borderColor }]}>
          <View
            style={[
              styles.featureUnlockModalPreview,
              {
                backgroundColor: isDarkTheme ? "rgba(12,12,16,0.9)" : "#FFFFFF",
                borderColor,
              },
            ]}
          >
            <View style={[styles.featureUnlockModalBadge, { backgroundColor: accent }]}>
              <Text style={styles.featureUnlockModalBadgeText}>{label}</Text>
            </View>
            <View style={styles.featureUnlockRewardRow}>
              <Image source={HEALTH_COIN_TIERS[0].asset} style={styles.featureUnlockRewardCoin} />
              <Text style={[styles.featureUnlockRewardAmount, { color: colors.text }]}>+1</Text>
            </View>
            <View style={styles.featureUnlockPreviewLines}>
              <View style={[styles.featureUnlockPreviewLine, { width: "80%", backgroundColor: baseLineColor }]} />
              <View style={[styles.featureUnlockPreviewLine, { width: "60%", backgroundColor: baseLineColor }]} />
            </View>
            <View style={[styles.featureUnlockModalButton, { backgroundColor: accent }]}>
              <Text style={styles.featureUnlockModalButtonText}>{actionLabel || "âœ“"}</Text>
            </View>
          </View>
        </View>
      );
    case "feedFocus":
      return (
        <View style={[styles.featureUnlockIllustration, { backgroundColor: screenBg, borderColor }]}>
          <View style={styles.featureUnlockHero}>
            <View style={[styles.featureUnlockHeroAccent, { borderColor: accent }]}>
              <Text style={[styles.featureUnlockHeroLabel, { color: colors.text }]}>{label}</Text>
            </View>
            <View style={styles.featureUnlockPreviewLines}>
              <View style={[styles.featureUnlockPreviewLine, { width: "60%", backgroundColor: baseLineColor }]} />
              <View style={[styles.featureUnlockPreviewLine, { width: "45%", backgroundColor: baseLineColor }]} />
            </View>
          </View>
          {renderTabBar(0)}
        </View>
      );
    case "impulseMap":
      return (
        <View style={[styles.featureUnlockIllustration, { backgroundColor: screenBg, borderColor }]}>
          <View style={styles.featureUnlockMap}>
            {Array.from({ length: 6 }).map((_, row) => (
              <View key={`map_row_${row}`} style={styles.featureUnlockMapRow}>
                {Array.from({ length: 4 }).map((_, col) => {
                  const isHotSpot = (row === 1 && col === 2) || (row === 3 && col === 1);
                  return (
                    <View
                      key={`map_dot_${row}_${col}`}
                      style={[
                        styles.featureUnlockMapDot,
                        {
                          backgroundColor: isHotSpot ? accent : baseLineColor,
                          opacity: isHotSpot ? 1 : 0.7,
                        },
                      ]}
                    />
                  );
                })}
              </View>
            ))}
          </View>
          {renderTabBar(1)}
        </View>
      );
    case "thinkingList":
      return (
        <View style={[styles.featureUnlockIllustration, { backgroundColor: screenBg, borderColor }]}>
          <View style={styles.featureUnlockList}>
            {Array.from({ length: 4 }).map((_, index) => (
              <View key={`thinking_${index}`} style={styles.featureUnlockListItem}>
                <View
                  style={[
                    styles.featureUnlockListBullet,
                    { backgroundColor: index === 0 ? accent : baseLineColor },
                  ]}
                />
                <View
                  style={[
                    styles.featureUnlockListLine,
                    { width: `${80 - index * 10}%`, backgroundColor: baseLineColor },
                  ]}
                />
              </View>
            ))}
          </View>
          {renderTabBar(2)}
        </View>
      );
    case "freeDay":
      return (
        <View style={[styles.featureUnlockIllustration, { backgroundColor: screenBg, borderColor }]}>
          {renderPreviewCard()}
          {renderTabBar(1)}
        </View>
      );
    case "catCustomization":
      return (
        <View style={[styles.featureUnlockIllustration, { backgroundColor: screenBg, borderColor }]}>
          <View
            style={[
              styles.featureUnlockPreviewCard,
              {
                backgroundColor: isDarkTheme ? "rgba(255,255,255,0.04)" : "rgba(255,255,255,0.92)",
                borderColor: isDarkTheme ? "rgba(255,255,255,0.05)" : "rgba(0,0,0,0.05)",
              },
            ]}
          >
            <View style={[styles.featureUnlockPreviewBadge, { backgroundColor: accent }]}>
              <Text style={styles.featureUnlockPreviewBadgeText}>{label}</Text>
            </View>
            <Image source={LEVEL_SHARE_CAT} style={styles.featureUnlockPreviewCat} />
            <View style={styles.featureUnlockPreviewLines}>
              <View style={[styles.featureUnlockPreviewLine, { width: "70%", backgroundColor: baseLineColor }]} />
              <View style={[styles.featureUnlockPreviewLine, { width: "50%", backgroundColor: baseLineColor }]} />
            </View>
          </View>
          {renderTabBar(0)}
        </View>
      );
    default:
      return (
        <View style={[styles.featureUnlockIllustration, { backgroundColor: screenBg, borderColor }]}>
          {renderPreviewCard()}
          {renderTabBar(3)}
        </View>
      );
  }
};

const RewardHeart = ({ left, delay, duration }) => {
  const translateY = useRef(new Animated.Value(60)).current;
  const opacity = useRef(new Animated.Value(0)).current;
  useEffect(() => {
    const anim = Animated.sequence([
      Animated.delay(delay),
      Animated.parallel([
        Animated.timing(translateY, {
          toValue: -160,
          duration,
          useNativeDriver: true,
        }),
        Animated.sequence([
          Animated.timing(opacity, {
            toValue: 1,
            duration: duration * 0.4,
            useNativeDriver: true,
          }),
          Animated.timing(opacity, {
            toValue: 0,
            duration: duration * 0.6,
            useNativeDriver: true,
          }),
        ]),
      ]),
    ]);
    anim.start();
    return () => anim.stop();
  }, [delay, duration, opacity, translateY]);

  return (
    <Animated.Text
      style={[
        styles.rewardHeart,
        {
          left,
          opacity,
          transform: [{ translateY }],
        },
      ]}
    >
      â¤ï¸
    </Animated.Text>
  );
};
