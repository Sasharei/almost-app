import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  View,
  Text,
  FlatList,
  Image,
  TouchableOpacity,
  Modal,
  StyleSheet,
  SafeAreaView,
  ScrollView,
  TextInput,
  Alert,
  Keyboard,
  TouchableWithoutFeedback,
  Platform,
  Dimensions,
  Animated,
  Easing,
  Linking,
  PanResponder,
  Switch,
  LayoutAnimation,
  UIManager,
  StatusBar as RNStatusBar,
  AppState,
  Share,
  ActionSheetIOS,
  PixelRatio,
  InteractionManager,
} from "react-native";
import Svg, {
  Circle as SvgCircle,
  Defs,
  Mask,
  Rect as SvgRect,
  LinearGradient as SvgLinearGradient,
  Stop as SvgStop,
} from "react-native-svg";
import AsyncStorage from "@react-native-async-storage/async-storage";
import ConfettiCannon from "react-native-confetti-cannon";
import * as Haptics from "expo-haptics";
import * as ImagePicker from "expo-image-picker";
import * as Notifications from "expo-notifications";
import * as NavigationBar from "expo-navigation-bar";
import * as FileSystem from "expo-file-system";
import { StatusBar } from "expo-status-bar";
import { BlurView } from "expo-blur";
import * as SplashScreen from "expo-splash-screen";
import {
  useFonts,
  Inter_300Light,
  Inter_400Regular,
  Inter_500Medium,
  Inter_600SemiBold,
  Inter_700Bold,
  Inter_800ExtraBold,
  Inter_900Black,
} from "@expo-google-fonts/inter";
import Sentry, { initSentry } from "./sentry";
import { SafeAreaProvider, useSafeAreaInsets } from "react-native-safe-area-context";
import ViewShot, { captureRef as captureViewShotRef } from "react-native-view-shot";
import { Settings as FacebookSettings } from "react-native-fbsdk-next";
import {
  initAnalytics,
  initPerformanceMonitoring,
  logEvent,
  logScreenView,
  setAnalyticsOptOut as setAnalyticsOptOutFlag,
  setUserProperties,
} from "./analytics";
import { SavingsProvider, useRealSavedAmount } from "./src/hooks/useRealSavedAmount";
import { useSavingsSimulation } from "./src/hooks/useSavingsSimulation";

let StoreReview = null;
try {
  // Optional native module ‚Äì older builds might not include it.
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  StoreReview = require("expo-store-review");
} catch (error) {
  console.warn("StoreReview unavailable", error);
}
let Sharing = null;
try {
  // Optional: module might be missing on some builds (e.g. Expo Go).
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  Sharing = require("expo-sharing");
} catch (error) {
  console.warn("Sharing unavailable", error);
}

Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowAlert: true,
    shouldPlaySound: false,
    shouldSetBadge: false,
  }),
});

initSentry();
initAnalytics();
initPerformanceMonitoring();
// Keep native splash visible until our custom LogoSplash is ready.
SplashScreen.preventAutoHideAsync().catch(() => {});

const STORAGE_KEYS = {
  PURCHASES: "@almost_purchases",
  PROFILE: "@almost_profile",
  THEME: "@almost_theme",
  LANGUAGE: "@almost_language",
  ONBOARDING: "@almost_onboarded",
  TERMS_ACCEPTED: "@almost_terms_accepted",
  CATALOG: "@almost_catalog_overrides",
  PRICE_PRECISION_OVERRIDES: "@almost_price_precision_overrides",
  TITLE_OVERRIDES: "@almost_title_overrides",
  EMOJI_OVERRIDES: "@almost_emoji_overrides",
  WISHES: "@almost_wishes",
  SAVED_TOTAL: "@almost_saved_total",
  DECLINES: "@almost_declines",
  PENDING: "@almost_pending",
  FREE_DAY: "@almost_free_day_stats",
  DECISION_STATS: "@almost_decision_stats",
  HISTORY: "@almost_history",
  REFUSE_STATS: "@almost_refuse_stats",
  REWARDS_CELEBRATED: "@almost_rewards_celebrated",
  HEALTH: "@almost_health_points",
  CLAIMED_REWARDS: "@almost_claimed_rewards",
  REWARD_TOTAL: "@almost_reward_total",
  ANALYTICS_OPT_OUT: "@almost_analytics_opt_out",
  TEMPTATION_GOALS: "@almost_temptation_goals",
  TEMPTATION_INTERACTIONS: "@almost_temptation_interactions",
  CUSTOM_TEMPTATIONS: "@almost_custom_temptations",
  HIDDEN_TEMPTATIONS: "@almost_hidden_temptations",
  IMPULSE_TRACKER: "@almost_impulse_tracker",
  MOOD_STATE: "@almost_mood_state",
  CHALLENGES: "@almost_challenges",
  CUSTOM_REMINDER: "@almost_custom_reminder",
  SMART_REMINDERS: "@almost_smart_reminders",
  DAILY_NUDGES: "@almost_daily_nudges",
  LANGUAGE_CURRENCY_NUDGE: "@almost_language_currency_nudge",
  TAMAGOTCHI: "@almost_tamagotchi_state",
  DAILY_SUMMARY: "@almost_daily_summary",
  POTENTIAL_PUSH_PROGRESS: "@almost_potential_push_progress",
  TUTORIAL: "@almost_tutorial_state",
  DAILY_CHALLENGE: "@almost_daily_challenge_state",
  TAB_HINTS: "@almost_tab_hints",
  FOCUS_TARGET: "@almost_focus_target",
  FOCUS_DIGEST: "@almost_focus_digest",
  CATEGORY_OVERRIDES: "@almost_category_overrides",
  DESCRIPTION_OVERRIDES: "@almost_description_overrides",
  FOCUS_DIGEST_PENDING: "@almost_focus_digest_pending",
  TAMAGOTCHI_SKIN: "@almost_tamagotchi_skin",
  TAMAGOTCHI_SKINS_UNLOCKED: "@almost_tamagotchi_skins_unlocked",
  SAVED_TOTAL_PEAK: "@almost_saved_total_peak",
  ACTIVE_GOAL: "@almost_active_goal",
  COIN_SLIDER_MAX: "@almost_coin_slider_max",
  FAB_TUTORIAL: "@almost_fab_tutorial",
  RATING_PROMPT: "@almost_rating_prompt",
  NORTH_STAR_METRIC: "@almost_north_star_metric",
};

const DEFAULT_LANGUAGE = "en";
const FALLBACK_LANGUAGE = "en";
const SUPPORTED_LANGUAGES = ["en", "es", "fr", "ru"];
const LANGUAGE_LABEL_KEYS = {
  ru: "languageRussian",
  en: "languageEnglish",
  es: "languageSpanish",
  fr: "languageFrench",
};
const LANGUAGE_NATIVE_LABELS = {
  ru: "–†—É—Å—Å–∫–∏–π",
  en: "English",
  es: "Espa√±ol",
  fr: "Fran√ßais",
};
const normalizeLanguage = (value) =>
  SUPPORTED_LANGUAGES.includes(value) ? value : DEFAULT_LANGUAGE;
const getLanguageLabelKey = (language) =>
  LANGUAGE_LABEL_KEYS[language] || LANGUAGE_LABEL_KEYS[FALLBACK_LANGUAGE];
const FORMAT_LOCALES = {
  ru: "ru-RU",
  en: "en-US",
  es: "es-ES",
  fr: "fr-FR",
};
const SHORT_LANGUAGE_MAP = {
  ru: "ru",
  en: "en",
  es: "es",
  fr: "fr",
};
const getFormatLocale = (language) =>
  FORMAT_LOCALES[language] || FORMAT_LOCALES[FALLBACK_LANGUAGE];
const getShortLanguageKey = (language) =>
  SHORT_LANGUAGE_MAP[language] || SHORT_LANGUAGE_MAP[FALLBACK_LANGUAGE];

const PURCHASE_GOAL = 20000;
const MAX_ACTIVE_CHALLENGES = 3;
const ANDROID_API_LEVEL =
  Platform.OS === "android"
    ? typeof Platform.Version === "string"
      ? parseInt(Platform.Version, 10) || 0
      : Number(Platform.Version) || 0
    : 0;
const SHOULD_USE_ANDROID_LEGACY_MEDIA_PICKER =
  Platform.OS === "android" && ANDROID_API_LEVEL > 0 && ANDROID_API_LEVEL < 33;
const CLASSIC_TAMAGOTCHI_ANIMATIONS = {
  idle: require("./assets/Cat_idle.gif"),
  curious: require("./assets/Cat_curious.gif"),
  follow: require("./assets/Cat_follows.gif"),
  speak: require("./assets/Cat_speaks.gif"),
  happy: require("./assets/Cat_happy.gif"),
  happyHeadshake: require("./assets/Cat_happy_headshake.gif"),
  sad: require("./assets/Cat_sad.gif"),
  ohno: require("./assets/Cat_oh_oh.gif"),
  cry: require("./assets/Cat_cry.gif"),
  waving: require("./assets/Cat_waving.gif"),
};
const GREEN_TAMAGOTCHI_ANIMATIONS = {
  idle: require("./assets/tamagotchi_skins/green/Cat_idle.gif"),
  curious: require("./assets/tamagotchi_skins/green/Cat_curious.gif"),
  follow: require("./assets/tamagotchi_skins/green/Cat_follows.gif"),
  speak: require("./assets/tamagotchi_skins/green/Cat_speaks.gif"),
  happy: require("./assets/tamagotchi_skins/green/Cat_happy.gif"),
  happyHeadshake: require("./assets/tamagotchi_skins/green/Cat_happy_headshake.gif"),
  sad: require("./assets/tamagotchi_skins/green/Cat_sad.gif"),
  ohno: require("./assets/tamagotchi_skins/green/Cat_oh_oh.gif"),
  cry: require("./assets/tamagotchi_skins/green/Cat_cry.gif"),
  waving: require("./assets/tamagotchi_skins/green/Cat_waving.gif"),
};
const TEAL_TAMAGOTCHI_ANIMATIONS = {
  idle: require("./assets/tamagotchi_skins/teal/Cat_idle.gif"),
  curious: require("./assets/tamagotchi_skins/teal/Cat_curious.gif"),
  follow: require("./assets/tamagotchi_skins/teal/Cat_follows.gif"),
  speak: require("./assets/tamagotchi_skins/teal/Cat_speaks.gif"),
  happy: require("./assets/tamagotchi_skins/teal/Cat_happy.gif"),
  happyHeadshake: require("./assets/tamagotchi_skins/teal/Cat_happy_headshake.gif"),
  sad: require("./assets/tamagotchi_skins/teal/Cat_sad.gif"),
  ohno: require("./assets/tamagotchi_skins/teal/Cat_oh_oh.gif"),
  cry: require("./assets/tamagotchi_skins/teal/Cat_cry.gif"),
  waving: require("./assets/tamagotchi_skins/teal/Cat_waving.gif"),
};
const PENDING_COUNTDOWN_FAST_MS = 1000;

const stripEmojis = (text = "") =>
  text
    .replace(
      /(?:\uD83C[\uDF00-\uDFFF]|\uD83D[\uDC00-\uDE4F]|\uD83D[\uDE80-\uDEFF]|[\u2600-\u27BF])/g,
      ""
    )
    .replace(/\s{2,}/g, " ")
    .trim();
const YELLOW_TAMAGOTCHI_ANIMATIONS = {
  idle: require("./assets/tamagotchi_skins/yellow/Cat_idle.gif"),
  curious: require("./assets/tamagotchi_skins/yellow/Cat_curious.gif"),
  follow: require("./assets/tamagotchi_skins/yellow/Cat_follows.gif"),
  speak: require("./assets/tamagotchi_skins/yellow/Cat_speaks.gif"),
  happy: require("./assets/tamagotchi_skins/yellow/Cat_happy.gif"),
  happyHeadshake: require("./assets/tamagotchi_skins/yellow/Cat_happy_headshake.gif"),
  sad: require("./assets/tamagotchi_skins/yellow/Cat_sad.gif"),
  ohno: require("./assets/tamagotchi_skins/yellow/Cat_oh_oh.gif"),
  cry: require("./assets/tamagotchi_skins/yellow/Cat_cry.gif"),
  waving: require("./assets/tamagotchi_skins/yellow/Cat_waving.gif"),
};
const PURPLE_TAMAGOTCHI_ANIMATIONS = {
  idle: require("./assets/tamagotchi_skins/purple/Cat_idle.gif"),
  curious: require("./assets/tamagotchi_skins/purple/Cat_curious.gif"),
  follow: require("./assets/tamagotchi_skins/purple/Cat_follows.gif"),
  speak: require("./assets/tamagotchi_skins/purple/Cat_speaks.gif"),
  happy: require("./assets/tamagotchi_skins/purple/Cat_happy.gif"),
  happyHeadshake: require("./assets/tamagotchi_skins/purple/Cat_happy_headshake.gif"),
  sad: require("./assets/tamagotchi_skins/purple/Cat_sad.gif"),
  ohno: require("./assets/tamagotchi_skins/purple/Cat_oh_oh.gif"),
  cry: require("./assets/tamagotchi_skins/purple/Cat_cry.gif"),
  waving: require("./assets/tamagotchi_skins/purple/Cat_waving.gif"),
};
const TAMAGOTCHI_SKIN_OPTIONS = [
  {
    id: "classic",
    label: { ru: "–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π", en: "Classic", es: "Cl√°sico", fr: "Classique" },
    description: {
      ru: "–ó–Ω–∞–∫–æ–º—ã–π –æ–±—Ä–∞–∑ –ê–ª–º–∏",
      en: "The original Almi look",
      es: "El estilo original de Almi",
      fr: "Le look original d'Almi",
    },
    preview: require("./assets/Cat_mascot.png"),
    avatar: require("./assets/Cat_mascot.png"),
    animations: CLASSIC_TAMAGOTCHI_ANIMATIONS,
  },
  {
    id: "green",
    label: { ru: "–õ–µ—Å–Ω–æ–π", en: "Forest", es: "Verde bosque", fr: "For√™t" },
    description: {
      ru: "–ú—è—Ç–Ω—ã–π –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å",
      en: "Mint explorer",
      es: "Explorador mentolado",
      fr: "Exploratrice menthol√©e",
    },
    preview: require("./assets/tamagotchi_skins/green/Cat_idle.gif"),
    avatar: require("./assets/tamagotchi_skins/green/Cat_idle.gif"),
    animations: GREEN_TAMAGOTCHI_ANIMATIONS,
  },
  {
    id: "teal",
    label: { ru: "–õ–∞–∑—É—Ä–Ω—ã–π", en: "Teal breeze", es: "Brisa turquesa", fr: "Brise turquoise" },
    description: {
      ru: "–°–≤–µ–∂–∏–π –º–æ—Ä—Å–∫–æ–π –æ—Ç—Ç–µ–Ω–æ–∫",
      en: "Ocean breeze palette",
      es: "Paleta brisa marina",
      fr: "Palette brise oc√©ane",
    },
    preview: require("./assets/tamagotchi_skins/teal/Cat_idle.gif"),
    avatar: require("./assets/tamagotchi_skins/teal/Cat_idle.gif"),
    animations: TEAL_TAMAGOTCHI_ANIMATIONS,
  },
  {
    id: "yellow",
    label: { ru: "–°–æ–ª–Ω–µ—á–Ω—ã–π", en: "Sunny", es: "Amarillo brillante", fr: "Ensoleill√©" },
    description: {
      ru: "–¢—ë–ø–ª—ã–π –∏ —ç–Ω–µ—Ä–≥–∏—á–Ω—ã–π",
      en: "Bright and energising",
      es: "C√°lido y lleno de energ√≠a",
      fr: "Chaud et plein d'√©nergie",
    },
    preview: require("./assets/tamagotchi_skins/yellow/Cat_idle.gif"),
    avatar: require("./assets/tamagotchi_skins/yellow/Cat_idle.gif"),
    animations: YELLOW_TAMAGOTCHI_ANIMATIONS,
  },
  {
    id: "purple",
    label: { ru: "–°–∏—Ä–µ–Ω–µ–≤—ã–π", en: "Lavender", es: "Lavanda", fr: "Lavande" },
    description: {
      ru: "–ù–µ–º–Ω–æ–≥–æ –∑–∞–≥–∞–¥–æ—á–Ω—ã–π",
      en: "A dreamy violet vibe",
      es: "Un toque violeta so√±ador",
      fr: "Une touche violette r√™veuse",
    },
    preview: require("./assets/tamagotchi_skins/purple/Cat_idle.gif"),
    avatar: require("./assets/tamagotchi_skins/purple/Cat_idle.gif"),
    animations: PURPLE_TAMAGOTCHI_ANIMATIONS,
  },
];
const TAMAGOTCHI_SKINS = TAMAGOTCHI_SKIN_OPTIONS.reduce((acc, skin) => {
  acc[skin.id] = skin;
  return acc;
}, {});
const DEFAULT_TAMAGOTCHI_SKIN = "classic";
const SUPPORT_EMAIL = "almostappsup@gmail.com";
const FACEBOOK_APP_ID = "1653035139013896";
const HEALTH_COIN_TIERS = [
  { id: "green", value: 1, asset: require("./assets/coins/Coin_green.png") },
  { id: "blue", value: 10, asset: require("./assets/coins/Coin_blue.png") },
  { id: "orange", value: 100, asset: require("./assets/coins/Coin_orange.png") },
  { id: "red", value: 1000, asset: require("./assets/coins/Coin_red.png") },
  { id: "pink", value: 10000, asset: require("./assets/coins/Coin_pink.png") },
];
const BLUE_HEALTH_COIN_TIER =
  HEALTH_COIN_TIERS.find((tier) => tier.id === "blue") || HEALTH_COIN_TIERS[1];
const BLUE_HEALTH_COIN_ASSET = BLUE_HEALTH_COIN_TIER?.asset || null;
const BLUE_HEALTH_COIN_VALUE = BLUE_HEALTH_COIN_TIER?.value || 10;
const SCREEN_WIDTH = Dimensions.get("window").width;
const SCREEN_HEIGHT = Dimensions.get("window").height;
const CTA_LETTER_SPACING = 0.4;
const FONT_SCALE = typeof PixelRatio.getFontScale === "function" ? PixelRatio.getFontScale() : 1;
const IS_EXTRA_COMPACT_DEVICE = SCREEN_WIDTH <= 375 || (SCREEN_WIDTH <= 390 && FONT_SCALE > 1.1);
const TYPOGRAPHY_SCALE = IS_EXTRA_COMPACT_DEVICE ? 0.92 : 1;
const scaleFontSize = (value) =>
  typeof value === "number" ? Number((value * TYPOGRAPHY_SCALE).toFixed(2)) : value;
const scaleLetterSpacing = (value) =>
  typeof value === "number" ? Number((value * TYPOGRAPHY_SCALE).toFixed(3)) : value;
const scaleTypographyOverrides = (overrides = {}) => {
  if (!overrides || typeof overrides !== "object") return overrides;
  let next = overrides;
  const applyScaled = (key, scaleFn) => {
    if (typeof overrides[key] === "number") {
      if (next === overrides) next = { ...overrides };
      next[key] = scaleFn(overrides[key]);
    }
  };
  applyScaled("fontSize", scaleFontSize);
  applyScaled("lineHeight", scaleFontSize);
  applyScaled("letterSpacing", scaleLetterSpacing);
  return next;
};
// Limit how far dialog-style cards can move when the keyboard is visible.
const MAX_MODAL_KEYBOARD_OFFSET = Math.min(SCREEN_HEIGHT * 0.45, 360);
const OVERLAY_CARD_MAX_WIDTH = Math.min(SCREEN_WIDTH - 40, 440);
const IS_COMPACT_DEVICE = SCREEN_WIDTH <= 380;
const PROFILE_SUBTITLE_FONT_SIZE = scaleFontSize(IS_COMPACT_DEVICE ? 12 : 13);
const PROFILE_SUBTITLE_LINE_HEIGHT = scaleFontSize(IS_COMPACT_DEVICE ? 16 : 18);
const PROFILE_STAT_LABEL_FONT_SIZE = scaleFontSize(IS_COMPACT_DEVICE ? 8.5 : 10);
const PROFILE_STAT_LETTER_SPACING = scaleLetterSpacing(
  IS_COMPACT_DEVICE ? CTA_LETTER_SPACING * 0.6 : CTA_LETTER_SPACING * 0.8
);
const CHALLENGE_TITLE_FONT_SIZE = scaleFontSize(IS_COMPACT_DEVICE ? 15 : 16);
const CHALLENGE_DESC_FONT_SIZE = scaleFontSize(IS_COMPACT_DEVICE ? 13 : 14);
const CHALLENGE_LINE_HEIGHT = scaleFontSize(IS_COMPACT_DEVICE ? 18 : 20);
const CHALLENGE_META_FONT_SIZE = scaleFontSize(IS_COMPACT_DEVICE ? 11.5 : 12);

const THEMES = {
  light: {
    background: "#F6F7FB",
    card: "#FFFFFF",
    text: "#1C1A2A",
    muted: "#7A7F92",
    border: "#E5E6ED",
    primary: "#111",
  },
  dark: {
    background: "#05070D",
    card: "#161B2A",
    text: "#F7F9FF",
    muted: "#A5B1CC",
    border: "#2E374F",
    primary: "#FFC857",
  },
};

const INTER_FONTS = {
  light: "Inter_300Light",
  regular: "Inter_400Regular",
  medium: "Inter_500Medium",
  semiBold: "Inter_600SemiBold",
  bold: "Inter_700Bold",
  extraBold: "Inter_800ExtraBold",
  black: "Inter_900Black",
};

const SMART_REMINDER_DELAY_MS = 23 * 60 * 60 * 1000;
const SMART_REMINDER_MIN_INTERVAL_MS = 60 * 60 * 1000;
const SMART_REMINDER_RETENTION_MS = 14 * 24 * 60 * 60 * 1000;
const SMART_REMINDER_LIMIT = 40;
const DAILY_NUDGE_REMINDERS = [
  { id: "morning", hour: 9, minute: 0, titleKey: "dailyNudgeMorningTitle", bodyKey: "dailyNudgeMorningBody" },
  { id: "daytime", hour: 12, minute: 30, titleKey: "dailyNudgeDayTitle", bodyKey: "dailyNudgeDayBody" },
  {
    id: "afternoon",
    hour: 15,
    minute: 30,
    titleKey: "dailyNudgeAfternoonTitle",
    bodyKey: "dailyNudgeAfternoonBody",
  },
  { id: "evening", hour: 19, minute: 0, titleKey: "dailyNudgeEveningTitle", bodyKey: "dailyNudgeEveningBody" },
];
const DAILY_NUDGE_TITLE_KEYS = [
  "dailyNudgeMorningTitle",
  "dailyNudgeDayTitle",
  "dailyNudgeAfternoonTitle",
  "dailyNudgeEveningTitle",
];
const DAILY_NUDGE_BODY_KEYS = [
  "dailyNudgeMorningBody",
  "dailyNudgeDayBody",
  "dailyNudgeAfternoonBody",
  "dailyNudgeEveningBody",
];
const DAILY_NUDGE_LANGUAGES = SUPPORTED_LANGUAGES;
const DAILY_NUDGE_NOTIFICATION_TAG = "daily_nudge";
const ANDROID_DAILY_NUDGE_CHANNEL_ID = "daily-nudges";
const DAILY_CHALLENGE_MIN_SPEND_EVENTS = 2;
const DAILY_CHALLENGE_REWARD_MULTIPLIER = 2;

const DAILY_CHALLENGE_STATUS = {
  IDLE: "idle",
  OFFER: "offer",
  ACTIVE: "active",
  COMPLETED: "completed",
  FAILED: "failed",
};
const FOCUS_VICTORY_THRESHOLD = 3;
const FOCUS_VICTORY_REWARD = 3;
const FOCUS_LOSS_THRESHOLD = 3;
const CHALLENGE_REWARD_SCALE = 0.5;
const getScaledChallengeReward = (value = 0) =>
  Math.max(1, Math.round(Math.max(0, value) * CHALLENGE_REWARD_SCALE));
const PUSH_NOTIFICATION_COOLDOWN_MS = 30 * 60 * 1000;

const buildTemptationPressureMap = (events = []) => {
  const map = {};
  (Array.isArray(events) ? events : []).forEach((event) => {
    if (!event?.templateId) return;
    const entry = map[event.templateId] || {
      spend: 0,
      save: 0,
      lastTimestamp: 0,
    };
    if (event.action === "spend") {
      entry.spend += 1;
      if (event.timestamp && event.timestamp > entry.lastTimestamp) {
        entry.lastTimestamp = event.timestamp;
      }
    } else if (event.action === "save") {
      entry.save += 1;
    }
    map[event.templateId] = entry;
  });
  return map;
};

const resolveDailyChallengeTemplateId = (
  pressureMap = {},
  minSpendEvents = DAILY_CHALLENGE_MIN_SPEND_EVENTS
) => {
  const ranked = Object.entries(pressureMap || {})
    .map(([templateId, stats]) => ({
      templateId,
      spend: stats?.spend || 0,
      save: stats?.save || 0,
      lastTimestamp: stats?.lastTimestamp || 0,
      score: (stats?.spend || 0) * 2 - (stats?.save || 0),
    }))
    .filter((entry) => entry.spend >= minSpendEvents && entry.spend > entry.save)
    .sort((a, b) => {
      if (b.score !== a.score) return b.score - a.score;
      if (b.spend !== a.spend) return b.spend - a.spend;
      return b.lastTimestamp - a.lastTimestamp;
    });
  if (ranked.length > 0) {
    return ranked[0].templateId;
  }
  const desc = (typeof descriptionOverride === "string" && descriptionOverride.trim().length
    ? descriptionOverride
    : null) || desc || "";
  return null;
};

const createInitialDailyChallengeState = () => ({
  id: null,
  dateKey: null,
  templateId: null,
  templateTitle: "",
  emoji: "‚ú®",
  priceUSD: 0,
  rewardBonus: 0,
  baseReward: 0,
  templateLabel: "",
  target: 1,
  progress: 0,
  status: DAILY_CHALLENGE_STATUS.IDLE,
  acceptedAt: null,
  completedAt: null,
  failedAt: null,
  offerDismissed: false,
  rewardGranted: false,
});
const buildDailyNudgeTrigger = (hour, minute) => {
  if (Platform.OS === "android") {
    const now = new Date();
    const next = new Date(now);
    next.setHours(hour, minute, 0, 0);
    if (next.getTime() <= now.getTime()) {
      next.setDate(next.getDate() + 1);
    }
    return next;
  }
  return { hour, minute, second: 0, repeats: true };
};


const normalizeSmartReminderEntries = (list) => {
  const now = Date.now();
  const seen = new Set();
  const normalized = [];
  (Array.isArray(list) ? list : []).forEach((entry) => {
    if (!entry) return;
    const timestamp = Number(entry.timestamp);
    if (!Number.isFinite(timestamp)) return;
    if (now - timestamp > SMART_REMINDER_RETENTION_MS) return;
    const eventId = entry.eventId || entry.id;
    if (!eventId || seen.has(eventId)) return;
    seen.add(eventId);
    normalized.push({
      id: entry.id || `smart-${eventId}`,
      eventId,
      kind: typeof entry.kind === "string" ? entry.kind : "refuse_spend",
      title: typeof entry.title === "string" ? entry.title : "",
      timestamp,
      scheduledAt: Number(entry.scheduledAt) || timestamp + SMART_REMINDER_DELAY_MS,
      notificationId: entry.notificationId || null,
    });
  });
  normalized.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
  return normalized.slice(0, SMART_REMINDER_LIMIT);
};

const resolveInterFontFamily = (fontWeight) => {
  if (typeof fontWeight === "string") {
    if (fontWeight.toLowerCase() === "bold") return INTER_FONTS.bold;
    if (fontWeight.toLowerCase() === "normal") return INTER_FONTS.regular;
  }
  const numericWeight = Number(fontWeight) || 0;
  if (numericWeight >= 900) return INTER_FONTS.black;
  if (numericWeight >= 800) return INTER_FONTS.extraBold;
  if (numericWeight >= 700) return INTER_FONTS.bold;
  if (numericWeight >= 600) return INTER_FONTS.semiBold;
  if (numericWeight >= 500) return INTER_FONTS.medium;
  if (numericWeight >= 300) return INTER_FONTS.light;
  return INTER_FONTS.regular;
};

const withInterTypography = (Component) => {
  if (!Component?.render) return;
  const defaultRender = Component.render;
  Component.render = function render(props = {}, ref) {
    const styleProp = props.style;
    const baseStyles = Array.isArray(styleProp)
      ? styleProp.filter(Boolean)
      : styleProp
        ? [styleProp]
        : [];
    const flattened = StyleSheet.flatten(baseStyles) || {};
    if (flattened.fontFamily) {
      return defaultRender.apply(this, [props, ref]);
    }
    const resolvedFontFamily = resolveInterFontFamily(flattened.fontWeight);
    const fontStyle = { fontFamily: resolvedFontFamily };
    const nextStyle = baseStyles.length ? [...baseStyles, fontStyle] : fontStyle;
    return defaultRender.apply(this, [{ ...props, style: nextStyle }, ref]);
  };
};

const ensureGlobalInterTypography = (() => {
  let applied = false;
  return () => {
    if (applied) return;
    [Text, TextInput, Animated.Text].forEach(withInterTypography);
    applied = true;
  };
})();

const APP_TUTORIAL_STEPS = [
  {
    id: "feed",
    icon: "üß†",
    titleKey: "tutorialFeedTitle",
    descriptionKey: "tutorialFeedDesc",
    tabs: ["feed"],
  },
  {
    id: "goals",
    icon: "üéØ",
    titleKey: "tutorialGoalsTitle",
    descriptionKey: "tutorialGoalsDesc",
    tabs: ["cart"],
  },
  {
    id: "thinking",
    icon: "üßä",
    titleKey: "tutorialThinkingTitle",
    descriptionKey: "tutorialThinkingDesc",
    tabs: ["pending"],
  },
  {
    id: "rewards",
    icon: "üèÜ",
    titleKey: "tutorialRewardsTitle",
    descriptionKey: "tutorialRewardsDesc",
    tabs: ["purchases"],
  },
  {
    id: "profile",
    icon: "‚öôÔ∏è",
    titleKey: "tutorialProfileTitle",
    descriptionKey: "tutorialProfileDesc",
    tabs: ["profile"],
  },
];
const FAB_TUTORIAL_STATUS = {
  DONE: "done",
  PENDING: "pending",
  SHOWING: "showing",
};
const DEFAULT_TAB_HINTS_STATE = {
  feed: false,
  cart: false,
  pending: false,
  purchases: false,
  profile: false,
};
const CARD_TEXTURE_ACCENTS = ["#8AB9FF", "#FFA4C0", "#8CE7CF", "#FFD48A", "#BBA4FF", "#7FD8FF"];
const TAB_HINT_CONFIG = {
  feed: { titleKey: "tabHintFeedTitle", bodyKey: "tabHintFeedBody" },
  cart: { titleKey: "tabHintCartTitle", bodyKey: "tabHintCartBody" },
  pending: { titleKey: "tabHintPendingTitle", bodyKey: "tabHintPendingBody" },
  purchases: { titleKey: "tabHintPurchasesTitle", bodyKey: "tabHintPurchasesBody" },
  profile: { titleKey: "tabHintProfileTitle", bodyKey: "tabHintProfileBody" },
};
const TAB_BAR_BASE_HEIGHT = 64;
const FAB_BUTTON_SIZE = 64;
const FAB_CONTAINER_BOTTOM = 96;
const FAB_TUTORIAL_MIN_SESSIONS = 3;
const FAB_TUTORIAL_HALO_SIZE = 128;
const FAB_TUTORIAL_CARD_SPACING = 140;
const FAB_TUTORIAL_HALO_INSET = (FAB_TUTORIAL_HALO_SIZE - FAB_BUTTON_SIZE) / 2;

const CELEBRATION_BASE_RU = [
  "–•–æ–ø! –ï—â—ë –æ–¥–Ω–∞ –æ—Å–æ–∑–Ω–∞–Ω–Ω–∞—è —ç–∫–æ–Ω–æ–º–∏—è",
  "–ú–µ–Ω—å—à–µ –ª–∏—à–Ω–∏—Ö –ø–æ–∫—É–ø–æ–∫, –±–æ–ª—å—à–µ –ø–ª–∞–Ω–∞",
  "–ö–æ—à–µ–ª—ë–∫ –≤–∑–¥–æ—Ö–Ω—É–ª —Å–ø–æ–∫–æ–π–Ω–æ",
];

const CELEBRATION_MESSAGES = {
  ru: {
    female: [...CELEBRATION_BASE_RU, "–¢—ã —Å–Ω–æ–≤–∞ –≤—ã–±—Ä–∞–ª–∞ —É–º–Ω—ã–π —Å–≤–æ–ø –≤–º–µ—Å—Ç–æ —Ä–∞—Å—Ç—Ä–∞—Ç"],
    male: [...CELEBRATION_BASE_RU, "–¢—ã —Å–Ω–æ–≤–∞ –≤—ã–±—Ä–∞–ª —É–º–Ω—ã–π —Å–≤–æ–ø –≤–º–µ—Å—Ç–æ —Ä–∞—Å—Ç—Ä–∞—Ç"],
    none: [...CELEBRATION_BASE_RU, "–°–Ω–æ–≤–∞ –≤—ã–±—Ä–∞–Ω —É–º–Ω—ã–π —Å–≤–æ–ø –≤–º–µ—Å—Ç–æ —Ä–∞—Å—Ç—Ä–∞—Ç"],
    level: "–£—Ä–æ–≤–µ–Ω—å {{level}}! –≠–∫–æ–Ω–æ–º–∏—è —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –ø—Ä–∏–≤—ã—á–∫–æ–π üíé",
  },
  en: {
    default: [
      "Boom! Another mindful deal",
      "Less impulse, more plan",
      "Wallet just sighed with relief",
      "Smart deal locked ‚Äì savings are safe",
    ],
    level: "Level {{level}}! Savings armor upgraded ‚ú®",
  },
  fr: {
    default: [
      "Boom ! Encore un choix conscient",
      "Moins d'impulsions, plus de plan",
      "Le portefeuille respire enfin",
      "Accord malin verrouill√© ‚Äì l'√©pargne est en s√©curit√©",
    ],
    level: "Niveau {{level}} ! Armure d'√©pargne am√©lior√©e ‚ú®",
  },
  es: {
    default: [
      "¬°Boom! Otro ahorro consciente",
      "Menos impulso, m√°s plan",
      "La cartera respira aliviada",
      "Intercambio inteligente: el ahorro est√° a salvo",
    ],
    female: [
      "¬°Boom! Otro ahorro consciente",
      "Menos impulso, m√°s plan",
      "La cartera respira aliviada",
      "Intercambio inteligente: el ahorro est√° a salvo",
    ],
    male: [
      "¬°Boom! Otro ahorro consciente",
      "Menos impulso, m√°s plan",
      "La cartera respira aliviada",
      "Intercambio inteligente: el ahorro est√° a salvo",
    ],
    none: [
      "¬°Boom! Otro ahorro consciente",
      "Menos impulso, m√°s plan",
      "La cartera respira aliviada",
      "Intercambio inteligente: el ahorro est√° a salvo",
    ],
    level: "¬°Nivel {{level}}! Tu armadura de ahorro sube de rango ‚ú®",
  },
};

const getCelebrationMessages = (language, gender = "none") => {
  const normalized = normalizeLanguage(language);
  const entry = CELEBRATION_MESSAGES[normalized] || CELEBRATION_MESSAGES[FALLBACK_LANGUAGE];
  if (!entry) return [];
  if (Array.isArray(entry)) return entry;
  if (Array.isArray(entry.default)) return entry.default;
  const variant =
    (gender && entry[gender]) ||
    entry.none ||
    entry.default ||
    Object.values(entry)[0];
  return Array.isArray(variant) ? variant : [];
};

const RAIN_DROPS = 20;
const LTR_MARK = "\u200E"; // keeps currency labels left-to-right even with RTL symbols
const RTL_CURRENCIES = new Set(["SAR"]);
const CURRENCY_RATES = {
  AED: 3.67,
  AUD: 1.5,
  BYN: 3.3,
  CAD: 1.35,
  EUR: 0.92,
  GBP: 0.79,
  JPY: 150,
  KZT: 450,
  KRW: 1350,
  MXN: 17,
  PLN: 4,
  RUB: 92,
  SAR: 3.75,
  USD: 1,
};
const CURRENCY_REWARD_STEPS = {
  AED: 20,
  AUD: 5,
  BYN: 5,
  CAD: 5,
  EUR: 5,
  GBP: 5,
  JPY: 750,
  KZT: 2000,
  KRW: 7000,
  MXN: 100,
  PLN: 20,
  RUB: 500,
  SAR: 20,
  USD: 5,
};
const DEFAULT_COIN_SLIDER_MAX_USD = 50;
const COIN_SLIDER_SIZE = 220;
const COIN_SLIDER_VALUE_DEADBAND = 0.01;
const COIN_SLIDER_STATE_MIN_INTERVAL = 16;
const COIN_SLIDER_HAPTIC_COOLDOWN_MS = 80;
const COIN_SLIDER_STEP_STICKINESS = 0.95;
const COIN_SLIDER_GESTURE_DEADBAND = 0.03;
const COIN_FILL_MIN_HEIGHT = 12;
const CURRENCY_SIGNS = {
  AED: "AED ",
  AUD: "A$",
  BYN: "Br",
  CAD: "C$",
  EUR: "‚Ç¨",
  GBP: "¬£",
  JPY: "¬•",
  KZT: "‚Ç∏",
  KRW: "‚Ç©",
  MXN: "MX$",
  PLN: "z≈Ç",
  RUB: "‚ÇΩ",
  SAR: "Ô∑º",
  USD: "$",
};
const CURRENCY_FINE_STEPS = {
  AED: 0.5,
  AUD: 0.5,
  BYN: 0.5,
  CAD: 0.5,
  EUR: 0.5,
  GBP: 0.5,
  JPY: 10,
  KZT: 10,
  KRW: 100,
  MXN: 0.5,
  PLN: 0.5,
  RUB: 5,
  SAR: 0.5,
  USD: 0.5,
};
const CURRENCY_DISPLAY_PRECISION = {
  AED: 0,
  AUD: 0,
  BYN: 0,
  CAD: 0,
  EUR: 0,
  GBP: 0,
  MXN: 0,
  PLN: 0,
  SAR: 0,
  USD: 0,
};
const ECONOMY_RULES = {
  saveRewardStepUSD: 5,
  minSaveReward: 1,
  maxSaveReward: 24,
  baseAchievementReward: 60,
  freeDayRescueCost: 60,
  tamagotchiFeedCost: 1,
  tamagotchiFeedBoost: 24,
  tamagotchiPartyCost: 20,
};
const DEFAULT_REMOTE_IMAGE =
  "https://images.unsplash.com/photo-1498050108023-c5249f4df085?auto=format&fit=crop&w=600&q=80";
const REMINDER_DAYS = 14;
const DAY_MS = 1000 * 60 * 60 * 24;
const REWARD_RESET_INTERVAL_MS = DAY_MS * 14;
const REMINDER_MS = REMINDER_DAYS * DAY_MS;
const SAVE_SPAM_WINDOW_MS = 1000 * 60 * 5;
const SAVE_SPAM_ITEM_LIMIT = 3;
const SAVE_SPAM_GLOBAL_LIMIT = 5;
const NORTH_STAR_SAVE_THRESHOLD = 2;
const NORTH_STAR_WINDOW_MS = DAY_MS;
const SAVE_ACTION_COLOR = "#2EB873";
const SPEND_ACTION_COLOR = "#D94862";
// Android darkens translucent backgrounds when elevation is applied, so use opaque fallbacks there.
const COIN_ENTRY_SAVE_BACKGROUND =
  Platform.OS === "android" ? "#E6F6EE" : "rgba(46,184,115,0.12)";
const COIN_ENTRY_SPEND_BACKGROUND =
  Platform.OS === "android" ? "#FAE9EC" : "rgba(217,72,98,0.12)";
const GOAL_HIGHLIGHT_COLOR = "#F6C16B";
const GOAL_SWIPE_THRESHOLD = 80;
const DELETE_SWIPE_THRESHOLD = 130;
const CHALLENGE_SWIPE_ACTION_WIDTH = 120;
const BASELINE_SAMPLE_USD = 120;
const CUSTOM_SPEND_SAMPLE_USD = 7.5;
const RATING_PROMPT_DELAY_DAYS = 2; // show on the third calendar day (after two full days)
const ANDROID_REVIEW_URL = "market://details?id=com.sasarei.almostclean";
const ANDROID_REVIEW_WEB_URL = "https://play.google.com/store/apps/details?id=com.sasarei.almostclean";
const LEVEL_SHARE_CAT = require("./assets/Cat_mascot.png");
const LEVEL_SHARE_LOGO = require("./assets/Almost_icon.png");
const LEVEL_SHARE_ACCENT = "#FFB347";
const LEVEL_SHARE_BG = "#050C1A";
const LEVEL_SHARE_MUTED = "rgba(255,255,255,0.65)";
const createInitialRatingPromptState = () => ({
  firstOpenAt: new Date().toISOString(),
  completed: false,
  lastShownAt: null,
  lastAction: null,
  respondedAt: null,
});

const getDayKey = (date) => {
  const d = new Date(date);
  if (Number.isNaN(d.getTime())) return "";
  d.setHours(0, 0, 0, 0);
  const year = d.getFullYear();
  const month = String(d.getMonth() + 1).padStart(2, "0");
  const day = String(d.getDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
};

const isSameDay = (tsA, tsB = Date.now()) => {
  if (!tsA) return false;
  return getDayKey(tsA) === getDayKey(tsB);
};
const DEFAULT_TEMPTATION_EMOJI = "‚ú®";
const DEFAULT_GOAL_EMOJI = "üéØ";
const MAX_HISTORY_EVENTS = 200;
const HISTORY_RETENTION_MS = DAY_MS * 31;
const HISTORY_VIEWPORT_ROWS = 5;
const HISTORY_ITEM_HEIGHT = 60;
const HISTORY_VIEWPORT_HEIGHT = HISTORY_VIEWPORT_ROWS * HISTORY_ITEM_HEIGHT;
const HISTORY_SAVED_GAIN_EVENTS = new Set(["refuse_spend", "pending_to_decline"]);
const HISTORY_SAVED_LOSS_EVENTS = new Set(["spend"]);
const normalizeClaimedRewardEntry = (value, now = Date.now()) => {
  if (!value) return null;
  if (typeof value === "object" && Number.isFinite(value.claimedAt)) {
    return { claimedAt: value.claimedAt };
  }
  if (typeof value === "number" && Number.isFinite(value)) {
    return { claimedAt: value };
  }
  if (value === true) {
    return { claimedAt: now };
  }
  return null;
};
const normalizeClaimedRewardsMap = (map, now = Date.now()) => {
  if (!map || typeof map !== "object") return {};
  const normalized = {};
  Object.entries(map).forEach(([key, entry]) => {
    const normalizedEntry = normalizeClaimedRewardEntry(entry, now);
    if (!normalizedEntry) return;
    if (now - normalizedEntry.claimedAt < REWARD_RESET_INTERVAL_MS) {
      normalized[key] = normalizedEntry;
    }
  });
  return normalized;
};
const claimedRewardsEqual = (a = {}, b = {}) => {
  const aKeys = Object.keys(a || {});
  const bKeys = Object.keys(b || {});
  if (aKeys.length !== bKeys.length) return false;
  return aKeys.every((key) => {
    const aEntry = a[key];
    const bEntry = b[key];
    if (!bEntry || !aEntry) return false;
    return Number(aEntry.claimedAt) === Number(bEntry.claimedAt);
  });
};
const getHealthCoinTierForAmount = (amount = 0) => {
  const normalized = Math.max(0, Math.floor(amount));
  for (let i = HEALTH_COIN_TIERS.length - 1; i >= 0; i -= 1) {
    const tier = HEALTH_COIN_TIERS[i];
    if (normalized >= tier.value) {
      return tier;
    }
  }
  return HEALTH_COIN_TIERS[0];
};
const getHealthCoinBreakdown = (amount = 0) => {
  let remaining = Math.max(0, Math.floor(amount));
  const breakdown = {};
  for (let i = HEALTH_COIN_TIERS.length - 1; i >= 0; i -= 1) {
    const tier = HEALTH_COIN_TIERS[i];
    const count = Math.floor(remaining / tier.value);
    breakdown[tier.id] = count;
    remaining -= count * tier.value;
  }
  HEALTH_COIN_TIERS.forEach((tier) => {
    if (!breakdown[tier.id]) breakdown[tier.id] = 0;
  });
  return breakdown;
};
const buildHealthCoinEntries = (amount = 0) => {
  const breakdown = getHealthCoinBreakdown(amount);
  return HEALTH_COIN_TIERS.slice().reverse().map((tier) => ({
    ...tier,
    count: breakdown[tier.id] || 0,
  }));
};
const getLocalRewardStep = (currencyCode = activeCurrency) => {
  const code = typeof currencyCode === "string" && currencyCode.trim() ? currencyCode : activeCurrency;
  if (code && CURRENCY_REWARD_STEPS[code]) {
    return CURRENCY_REWARD_STEPS[code];
  }
  const rate = code ? CURRENCY_RATES[code] : null;
  if (rate && ECONOMY_RULES.saveRewardStepUSD > 0) {
    return ECONOMY_RULES.saveRewardStepUSD * rate;
  }
  return ECONOMY_RULES.saveRewardStepUSD;
};
const computeRefuseCoinReward = (amountUSD = 0, currencyCode = activeCurrency) => {
  if (!amountUSD || amountUSD <= 0) return 0;
  const localAmount = convertToCurrency(amountUSD, currencyCode);
  const localStep = getLocalRewardStep(currencyCode);
  if (!localStep || localStep <= 0) return 0;
  const normalized = Math.ceil(localAmount / localStep);
  if (normalized <= 0) return 0;
  const adjusted = Math.max(ECONOMY_RULES.minSaveReward, normalized);
  return Math.min(ECONOMY_RULES.maxSaveReward, adjusted);
};

const computeDailyChallengeBonus = (amountUSD = 0, currencyCode = activeCurrency) => {
  const baseReward = computeRefuseCoinReward(amountUSD, currencyCode);
  const multiplied = Math.round(baseReward * DAILY_CHALLENGE_REWARD_MULTIPLIER);
  if (multiplied > 0) {
    return Math.max(multiplied - baseReward, baseReward || 1);
  }
  return Math.max(1, baseReward || ECONOMY_RULES.minSaveReward);
};

const computeLevelRewardCoins = (level) => {
  if (level <= 1) return 0;
  if (level <= 9) return Math.max(1, level - 1);
  return level;
};

const sumLevelRewardCoins = (level, levelsEarned = 1) => {
  if (level <= 1 || levelsEarned <= 0) return 0;
  const start = Math.max(2, level - levelsEarned + 1);
  let total = 0;
  for (let current = start; current <= level; current += 1) {
    total += computeLevelRewardCoins(current);
  }
  return total;
};
const HEALTH_COIN_LABELS = {
  ru: {
    pink: "—Ä–æ–∑–æ–≤—ã—Ö –º–æ–Ω–µ—Ç",
    red: "–∫—Ä–∞—Å–Ω—ã—Ö –º–æ–Ω–µ—Ç",
    orange: "–æ—Ä–∞–Ω–∂–µ–≤—ã—Ö –º–æ–Ω–µ—Ç",
    blue: "—Å–∏–Ω–∏—Ö –º–æ–Ω–µ—Ç",
    green: "–∑–µ–ª—ë–Ω—ã—Ö –º–æ–Ω–µ—Ç",
  },
  en: {
    pink: "pink coins",
    red: "red coins",
    orange: "orange coins",
    blue: "blue coins",
    green: "green coins",
  },
  es: {
    pink: "monedas rosas",
    red: "monedas rojas",
    orange: "monedas naranjas",
    blue: "monedas azules",
    green: "monedas verdes",
  },
  fr: {
    pink: "pi√®ces roses",
    red: "pi√®ces rouges",
    orange: "pi√®ces orange",
    blue: "pi√®ces bleues",
    green: "pi√®ces vertes",
  },
};
const ZERO_HEALTH_REWARD_LABELS = {
  ru: "0 –º–æ–Ω–µ—Ç",
  en: "0 coins",
  es: "0 monedas",
  fr: "0 pi√®ce",
};
const formatHealthRewardLabel = (amount = 0, language = DEFAULT_LANGUAGE) => {
  const entries = buildHealthCoinEntries(amount);
  const labels = HEALTH_COIN_LABELS[language] || HEALTH_COIN_LABELS.en;
  const parts = entries
    .filter((entry) => entry.count > 0)
    .map((entry) => `${entry.count} ${labels[entry.id] || entry.id}`);
  if (!parts.length) {
    return ZERO_HEALTH_REWARD_LABELS[language] || ZERO_HEALTH_REWARD_LABELS.en;
  }
  return parts.join(" ¬∑ ");
};

const HealthRewardTokens = ({
  amount = 0,
  color = "#fff",
  iconSize = 18,
  maxItems = 3,
  zeroLabel = "0",
  textSize = 12,
  rowStyle = null,
  countStyle = null,
}) => {
  const entries = useMemo(
    () => buildHealthCoinEntries(amount).filter((entry) => entry.count > 0),
    [amount]
  );
  const visible = entries.slice(0, maxItems);
  const rowStyles = rowStyle ? [styles.healthRewardTokenRow, rowStyle] : [styles.healthRewardTokenRow];
  const countStyles = [
    styles.healthRewardTokenCount,
    { color, fontSize: textSize },
    ...(countStyle ? [countStyle] : []),
  ];
  if (!visible.length) {
    return (
      <View style={rowStyles}>
        <Text style={countStyles}>{zeroLabel}</Text>
      </View>
    );
  }
  return (
    <View style={rowStyles}>
      {visible.map((entry) => (
        <View key={`${entry.id}-${entry.count}`} style={styles.healthRewardToken}>
          <Image
            source={entry.asset}
            style={[styles.healthRewardTokenIcon, { width: iconSize, height: iconSize }]}
          />
          <Text style={countStyles}>{`√ó${entry.count}`}</Text>
        </View>
      ))}
    </View>
  );
};
const INITIAL_DECISION_STATS = {
  resolvedToWishes: 0,
  resolvedToDeclines: 0,
};

const MOOD_IDS = {
  NEUTRAL: "neutral",
  FOCUSED: "focused",
  IMPULSIVE: "impulsive",
  DOUBTER: "doubter",
  TIRED: "tired",
  DREAMER: "dreamer",
};
const MOOD_MAX_EVENTS = 24;
const MOOD_ACTION_WINDOW_MS = 1000 * 60 * 60 * 48;
const MOOD_EVENT_THRESHOLD = 3;
const MOOD_PENDING_THRESHOLD = 4;
const MOOD_DREAM_WISH_THRESHOLD = 3;
const MOOD_INACTIVITY_THRESHOLD_MS = 1000 * 60 * 60 * 72;
const createMoodStateForToday = (overrides = {}) => ({
  current: MOOD_IDS.NEUTRAL,
  events: [],
  lastInteractionAt: null,
  lastVisitAt: null,
  pendingSnapshot: 0,
  dayKey: getDayKey(Date.now()),
  ...overrides,
});

const INITIAL_MOOD_STATE = createMoodStateForToday();

const MOOD_PRESETS = {
  [MOOD_IDS.NEUTRAL]: {
    label: { ru: "–†–µ–∂–∏–º –±–∞–ª–∞–Ω—Å–∞", en: "Balanced mode", es: "Modo balance", fr: "Mode √©quilibre" },
    hero: {
      ru: "–ë–∞–ª–∞–Ω—Å –¥–µ—Ä–∂–∏—Ç—Å—è, –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–¥–æ–ª–∂–∞–π –æ—Ç–º–µ—á–∞—Ç—å –ø–æ–±–µ–¥—ã.",
      en: "Balance holds steady-keep logging the wins.",
      es: "El balance se mantiene: sigue registrando victorias.",
      fr: "L'√©quilibre tient bon : continue de noter tes victoires.",
    },
    heroComplete: {
      ru: "–†–µ–∂–∏–º —Å–ø–æ–∫–æ–π—Å—Ç–≤–∏—è —Ñ–∏–∫—Å–∏—Ä—É–µ—Ç –∫–∞–∂–¥–æ–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ.",
      en: "Calm mode celebrates each milestone.",
      es: "El modo calma celebra cada logro.",
      fr: "Le mode calme c√©l√®bre chaque √©tape.",
    },
    motivation: {
      ru: "–ù–µ–±–æ–ª—å—à–æ–π —à–∞–≥ —Å–µ–≥–æ–¥–Ω—è —Å–ø–∞—Å–∞–µ—Ç –∑–∞–≤—Ç—Ä–∞—à–Ω–∏–π –ø–ª–∞–Ω.",
      en: "A tiny step today protects tomorrow‚Äôs plan.",
      es: "Un paso peque√±o hoy protege el plan de ma√±ana.",
      fr: "Un petit pas aujourd'hui prot√®ge le plan de demain.",
    },
    saveOverlay: {
      ru: "–ë–∞–ª–∞–Ω—Å —É—Å–∏–ª–µ–Ω –µ—â—ë –æ–¥–Ω–∏–º –æ—Ç–∫–∞–∑–æ–º.",
      en: "Balance reinforced with another skip.",
      es: "El balance se refuerza con otro rechazo.",
      fr: "L'√©quilibre est renforc√© par un refus de plus.",
    },
    impulseOverlay: {
      ru: "–°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–ø–æ–∫–æ–π—Å—Ç–≤–∏–µ –¥–∞–∂–µ –ø—Ä–∏ —à—Ç–æ—Ä–º–∞—Ö.",
      en: "Staying calm even when urges spike.",
      es: "Mantenemos la calma incluso cuando suben los impulsos.",
      fr: "On reste calme m√™me quand les envies montent.",
    },
    pushPendingTitle: {
      ru: "–ë–∞–ª–∞–Ω—Å –ø—Ä–æ–≤–µ—Ä—è–µ—Ç —Ö–æ—Ç–µ–ª–∫—É",
      en: "Balance check-in",
      es: "Recordatorio de balance",
      fr: "Contr√¥le √©quilibre",
    },
    pushPendingBody: {
      ru: "¬´{{title}}¬ª –∂–¥–µ—Ç —Ä–µ—à–µ–Ω–∏—è. –ü–æ–¥—É–º–∞–π, —Å—Ç–æ–∏—Ç –ª–∏ –¥–µ—Ä–∂–∞—Ç—å –∫—É—Ä—Å.",
      en: "‚Äú{{title}}‚Äù is waiting. Decide if it fits the plan.",
      es: "‚Äú{{title}}‚Äù sigue esperando. Decide si se queda en el plan.",
      fr: "¬´ {{title}} ¬ª attend. D√©cide si √ßa reste dans le plan.",
    },
    pushImpulseTitle: {
      ru: "–ë–∞–ª–∞–Ω—Å –≤ –¥–µ–ª–µ",
      en: "Balance alert",
      es: "Aviso de balance",
      fr: "Alerte √©quilibre",
    },
    pushImpulseBody: {
      ru: "–í —ç—Ç–æ –≤—Ä–µ–º—è —Ö–æ—á–µ—Ç—Å—è {{temptation}}, –Ω–æ –±–∞–ª–∞–Ω—Å –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç —Å–ø–∞—Å—Ç–∏ {{amount}}.",
      en: "This hour usually tempts {{temptation}}, but balance can bank {{amount}}.",
      es: "A esta hora suele ganar {{temptation}}, pero el balance puede guardar {{amount}}.",
      fr: "√Ä cette heure {{temptation}} appelle, mais l'√©quilibre peut mettre {{amount}} de c√¥t√©.",
    },
  },
  [MOOD_IDS.FOCUSED]: {
    label: { ru: "–í–æ–ª–µ–≤–æ–π —Ä–µ–∂–∏–º", en: "Focused mode", es: "Modo enfoque", fr: "Mode focus" },
    hero: {
      ru: "–í–æ–ª–µ–≤–æ–π —Ä–µ–∂–∏–º –∞–∫—Ç–∏–≤–µ–Ω - –∏—Å–∫—É—à–µ–Ω–∏—è —Å–∞–º–∏ –ø—É–≥–∞—é—Ç—Å—è.",
      en: "Focused mode is on-temptations get nervous.",
      es: "El modo enfoque est√° activo: las tentaciones se ponen nerviosas.",
      fr: "Le mode focus est activ√© : les tentations se crispent.",
    },
    heroComplete: {
      ru: "–í–æ–ª–µ–≤–æ–π —Ä–µ–∂–∏–º –∏ —Ü–µ–ª—å —Å–¥–µ–ª–∞–Ω—ã! –ú–æ–∂–Ω–æ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –±–æ–ª—å—à–µ.",
      en: "Focused mode + goal complete! Time to plan even bigger.",
      es: "Modo enfoque + meta completa. Hora de un objetivo m√°s grande.",
      fr: "Mode focus + objectif atteint ! Place √† un r√™ve plus grand.",
    },
    motivation: {
      ru: "–†–µ–∂–∏–º —Å–∏–ª—ã: —Å–æ–±–µ—Ä–∏ –µ—â—ë –æ–¥–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –¥–∏—Å—Ü–∏–ø–ª–∏–Ω—ã.",
      en: "Power mode: lock in one more proof of discipline.",
      es: "Modo potencia: suma otra prueba de disciplina.",
      fr: "Mode puissance : ajoute une preuve de discipline de plus.",
    },
    saveOverlay: {
      ru: "–í–æ–ª–µ–≤–æ–µ —Ä–µ—à–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ. –¢–∞–∫ –¥–µ—Ä–∂–∞—Ç—å!",
      en: "Willpower locked in. Keep it going!",
      es: "La fuerza de voluntad qued√≥ registrada. ¬°Sigue as√≠!",
      fr: "Force de volont√© verrouill√©e. Continue comme √ßa !",
    },
    impulseOverlay: {
      ru: "–í–æ–ª–µ–≤–æ–π —Ä–µ–∂–∏–º —É–º–µ–µ—Ç —Ç–æ—Ä–º–æ–∑–∏—Ç—å –∏–º–ø—É–ª—å—Å—ã.",
      en: "Focused mode crushes impulse spikes.",
      es: "El modo enfoque aplasta los impulsos.",
      fr: "Le mode focus √©crase les pics d'impulsion.",
    },
    pushPendingTitle: {
      ru: "–í–æ–ª–µ–≤–æ–π –ø–∏–Ω–≥",
      en: "Focused ping",
      es: "Ping de enfoque",
      fr: "Ping focus",
    },
    pushPendingBody: {
      ru: "–¢—ã –≤ –≤–æ–ª–µ–≤–æ–º —Ä–µ–∂–∏–º–µ - —Ä–µ—à–∏, –∏–¥–µ–º –ª–∏ –¥–∞–ª—å—à–µ —Å ¬´{{title}}¬ª.",
      en: "Focused mode speaking-decide what to do with ‚Äú{{title}}‚Äù.",
      es: "Modo enfoque al habla: decide qu√© hacer con ¬´{{title}}¬ª.",
      fr: "Le mode focus te parle : d√©cide quoi faire de ¬´ {{title}} ¬ª.",
    },
    pushImpulseTitle: {
      ru: "–í–æ–ª–µ–≤–æ–π —Å–∏–≥–Ω–∞–ª",
      en: "Focused alert",
      es: "Alerta de enfoque",
      fr: "Alerte focus",
    },
    pushImpulseBody: {
      ru: "–°–µ–π—á–∞—Å —á–∞—â–µ —Ö–æ—á–µ—Ç—Å—è {{temptation}}, –Ω–æ –≤–æ–ª–µ–≤–æ–π —Ä–µ–∂–∏–º –º–æ–∂–µ—Ç –æ—Ç–ø—Ä–∞–≤–∏—Ç—å {{amount}} –≤ –∫–æ–ø–∏–ª–∫—É.",
      en: "This hour begs for {{temptation}}, but focused mode can stash {{amount}}.",
      es: "A esta hora pide {{temptation}}, pero el modo enfoque puede guardar {{amount}}.",
      fr: "√Ä cette heure {{temptation}} insiste, mais le mode focus peut mettre {{amount}} de c√¥t√©.",
    },
  },
  [MOOD_IDS.IMPULSIVE]: {
    label: { ru: "–ò–º–ø—É–ª—å—Å–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º", en: "Impulse mode", es: "Modo impulso", fr: "Mode impulsif" },
    hero: {
      ru: "–ò–º–ø—É–ª—å—Å–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º –≤–∫–ª—é—á—ë–Ω - —Å—Ç–æ–∏—Ç –ø–æ–π–º–∞—Ç—å –ø–∞—Ä—É –ø–æ–±–µ–¥.",
      en: "Impulse mode detected-time to capture a few wins.",
      es: "Modo impulso activado: toca atrapar un par de victorias.",
      fr: "Mode impulsif d√©tect√© : il est temps de d√©crocher quelques victoires.",
    },
    heroComplete: {
      ru: "–ò–º–ø—É–ª—å—Å—ã –±—ã–ª–∏ —Å–∏–ª—å–Ω—ã–º–∏, –Ω–æ —Ü–µ–ª—å –≤—Å—ë —Ä–∞–≤–Ω–æ –∑–∞–∫—Ä—ã—Ç–∞.",
      en: "Impulses were strong, yet you still hit the target.",
      es: "El impulso fue fuerte, pero aun as√≠ lograste la meta.",
      fr: "Les envies √©taient fortes, mais tu as quand m√™me atteint la cible.",
    },
    motivation: {
      ru: "–ú–∞–ª–µ–Ω—å–∫–∏–π –æ—Ç–∫–∞–∑ –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å –≤–µ—Ä–Ω—ë—Ç –∫–æ–Ω—Ç—Ä–æ–ª—å.",
      en: "One tiny skip right now resets control.",
      es: "Un peque√±o ‚Äúno‚Äù ahora recupera el control.",
      fr: "Un petit ¬´ non ¬ª maintenant rend le contr√¥le.",
    },
    saveOverlay: {
      ru: "–ò–º–ø—É–ª—å—Å—ã –º–µ–¥–ª—è—Ç - —Ç—ã –ø–µ—Ä–µ—Ö–≤–∞—Ç–∏–ª —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ.",
      en: "Impulse paused-you took the controls back.",
      es: "El impulso se detuvo: retomaste el mando.",
      fr: "Impulsion stopp√©e : tu reprends les commandes.",
    },
    impulseOverlay: {
      ru: "–ü–æ–π–º–∞–π –µ—â—ë –æ–¥–∏–Ω –º–æ–º–µ–Ω—Ç –∏ –ø–µ—Ä–µ–≤–µ–¥–∏ –µ–≥–æ –≤ –∫–æ–ø–∏–ª–∫—É.",
      en: "Catch the next urge and reroute it into savings.",
      es: "Atrapa el siguiente impulso y convi√©rtelo en ahorro.",
      fr: "Attrape la prochaine envie et transforme-la en √©pargne.",
    },
    pushPendingTitle: {
      ru: "–ò–º–ø—É–ª—å—Å –ø—Ä–æ–≤–µ—Ä—è–µ—Ç ¬´{{title}}¬ª",
      en: "Impulse check-in",
      es: "Aviso del impulso",
      fr: "Contr√¥le impulsif",
    },
    pushPendingBody: {
      ru: "–ò–º–ø—É–ª—å—Å–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º –ø—Ä–æ—Å–∏—Ç —è—Å–Ω–æ—Å—Ç–∏: –æ—Å—Ç–∞–≤–ª—è–µ–º ¬´{{title}}¬ª –∏–ª–∏ –∫–æ–ø–∏–º?",
      en: "Impulse mode needs clarity: keep ‚Äú{{title}}‚Äù or bank it?",
      es: "El modo impulso pide claridad: ¬ødejamos ¬´{{title}}¬ª o lo convertimos en ahorro?",
      fr: "Le mode impulsif demande une d√©cision : on garde ¬´ {{title}} ¬ª ou on le convertit en √©pargne ?",
    },
    pushImpulseTitle: {
      ru: "–ò–º–ø—É–ª—å—Å –Ω–∞ –ø–æ–¥—Ö–æ–¥–µ",
      en: "Impulse incoming",
      es: "Impulso en camino",
      fr: "Impulsion en approche",
    },
    pushImpulseBody: {
      ru: "–ß–∞—â–µ –≤—Å–µ–≥–æ —Å–µ–π—á–∞—Å –±–µ—Ä–µ—à—å {{temptation}}. –ü–æ–ø—Ä–æ–±—É–π –æ—Ç–ø—Ä–∞–≤–∏—Ç—å {{amount}} –≤ –∫–æ–ø–∏–ª–∫—É.",
      en: "{{temptation}} usually wins now. Try sending {{amount}} to savings instead.",
      es: "Ahora suele ganar {{temptation}}. Intenta enviar {{amount}} al ahorro.",
      fr: "{{temptation}} gagne souvent maintenant. Essaie d'envoyer {{amount}} vers l'√©pargne.",
    },
  },
  [MOOD_IDS.DOUBTER]: {
    label: { ru: "–†–µ–∂–∏–º —Å–æ–º–Ω–µ–Ω–∏–π", en: "Doubter mode", es: "Modo dudas", fr: "Mode doutes" },
    hero: {
      ru: "–†–µ–∂–∏–º —Å–æ–º–Ω–µ–Ω–∏–π –∞–∫—Ç–∏–≤–µ–Ω - –≤—ã–±–µ—Ä–∏ —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ —É–≤–µ—Ä–µ–Ω–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ.",
      en: "Doubter mode is on-choose one confident move.",
      es: "Modo dudas activo: elige al menos un movimiento seguro.",
      fr: "Le mode doutes est activ√© : choisis au moins un geste s√ªr.",
    },
    heroComplete: {
      ru: "–°–æ–º–Ω–µ–≤–∞–µ—à—å—Å—è, –Ω–æ —Ü–µ–ª–∏ –¥–æ—Å—Ç–∏–≥–∞—é—Ç—Å—è. –ó–Ω–∞—á–∏—Ç, –∫—É—Ä—Å –≤–µ—Ä–Ω—ã–π.",
      en: "Doubts aside, goals still get reached. The course works.",
      es: "Aun con dudas, las metas se cumplen. Vas en buen camino.",
      fr: "M√™me avec des doutes, les objectifs avancent. Le cap est bon.",
    },
    motivation: {
      ru: "–í—ã–±–µ—Ä–∏ –æ–¥–Ω—É –º—ã—Å–ª—å ¬´–∫–æ–ø–∏—Ç—å¬ª –∏ –∑–∞–∫—Ä–µ–ø–∏ —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å.",
      en: "Pick one ‚Äúsave it‚Äù thought and lock it in.",
      es: "Elige un ‚Äúah√≥rralo‚Äù y afianza la confianza.",
      fr: "Choisis un ¬´ j'√©conomise ¬ª et consolide ta confiance.",
    },
    saveOverlay: {
      ru: "–≠—Ç–æ —Ä–µ—à–µ–Ω–∏–µ —Å–Ω–∏–º–∞–µ—Ç —Å–æ–º–Ω–µ–Ω–∏—è.",
      en: "That choice dissolves doubts.",
      es: "Esa decisi√≥n disuelve las dudas.",
      fr: "Ce choix dissout les doutes.",
    },
    impulseOverlay: {
      ru: "–°–æ–º–Ω–µ–Ω–∏—è –ª—É—á—à–µ –ø–µ—Ä–µ–≤–æ–¥–∏—Ç—å –≤ —Ü–∏—Ñ—Ä—ã, –∞ –Ω–µ –ø–æ–∫—É–ø–∫–∏.",
      en: "Turn doubts into numbers, not purchases.",
      es: "Convierte las dudas en n√∫meros, no en compras.",
      fr: "Transforme les doutes en chiffres, pas en achats.",
    },
    pushPendingTitle: {
      ru: "–°–æ–º–Ω–µ–Ω–∏—è –ø—Ä–æ—Å—è—Ç –æ—Ç–≤–µ—Ç–∞",
      en: "Doubter check",
      es: "Chequeo de dudas",
      fr: "Contr√¥le des doutes",
    },
    pushPendingBody: {
      ru: "¬´{{title}}¬ª –≤–∏—Å–∏—Ç –≤ —Å–æ–º–Ω–µ–Ω–∏—è—Ö. –†–µ—à–∏, –∫—É–¥–∞ –µ–≥–æ –Ω–∞–ø—Ä–∞–≤–∏—Ç—å.",
      en: "‚Äú{{title}}‚Äù is stuck in limbo. Decide where it belongs.",
      es: "‚Äú{{title}}‚Äù sigue en duda. Decide ad√≥nde va.",
      fr: "¬´ {{title}} ¬ª plane encore. D√©cide o√π l'envoyer.",
    },
    pushImpulseTitle: {
      ru: "–°–æ–º–Ω–µ–≤–∞–µ—à—å—Å—è?",
      en: "Feeling unsure?",
      es: "¬øCon dudas?",
      fr: "Un doute ?",
    },
    pushImpulseBody: {
      ru: "–ö–æ–≥–¥–∞ —Ç—è–Ω–µ—Ç –∫ {{temptation}}, –ø–æ–ø—Ä–æ–±—É–π –Ω–∞–ø—Ä–∞–≤–∏—Ç—å {{amount}} –≤ –∫–æ–ø–∏–ª–∫—É - —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –≤–µ—Ä–Ω—ë—Ç—Å—è.",
      en: "When {{temptation}} calls, redirect {{amount}} to savings to regain certainty.",
      es: "Cuando llame {{temptation}}, dirige {{amount}} al ahorro para recuperar seguridad.",
      fr: "Quand {{temptation}} appelle, envoie {{amount}} vers l'√©pargne pour retrouver confiance.",
    },
  },
  [MOOD_IDS.TIRED]: {
    label: { ru: "–†–µ–∂–∏–º –æ—Ç–¥—ã—Ö–∞", en: "Recharge mode", es: "Modo descanso", fr: "Mode recharge" },
    hero: {
      ru: "–î–∞–≤–Ω–æ –Ω–µ –≤–∏–¥–µ–ª–∏—Å—å - —Ä–µ–∂–∏–º –æ—Ç–¥—ã—Ö–∞ –Ω–∞–ø–æ–º–∏–Ω–∞–µ—Ç –æ –º—è–≥–∫–æ–º —Å—Ç–∞—Ä—Ç–µ.",
      en: "Long time no see-recharge mode suggests a gentle restart.",
      es: "Tiempo sin verte: el modo descanso propone un reinicio suave.",
      fr: "√áa faisait longtemps : le mode recharge propose un red√©marrage tout doux.",
    },
    heroComplete: {
      ru: "–ü–∞—É–∑—ã —Ç–æ–∂–µ —á–∞—Å—Ç—å –ø—É—Ç–∏. –í–æ–∑–≤—Ä–∞—â–∞–π—Å—è, –∫–æ–≥–¥–∞ –≥–æ—Ç–æ–≤.",
      en: "Breaks are part of the path. Return when ready.",
      es: "Los descansos son parte del camino. Vuelve cuando est√©s listo.",
      fr: "Les pauses font partie du chemin. Reviens quand tu es pr√™t¬∑e.",
    },
    motivation: {
      ru: "–ù–∞—á–Ω–∏ —Å –æ–¥–Ω–æ–≥–æ –æ—Ç–∫–∞–∑–∞ —Å–µ–≥–æ–¥–Ω—è –∏ –ø–æ—Å–º–æ—Ç—Ä–∏, —á—Ç–æ –∏–∑–º–µ–Ω–∏—Ç—Å—è.",
      en: "Start with one skip today and see the shift.",
      es: "Empieza con un rechazo hoy y nota el cambio.",
      fr: "Commence par un refus aujourd'hui et observe le d√©clic.",
    },
    saveOverlay: {
      ru: "–í–æ—Ç –∏ –º—è–≥–∫–∏–π —Ä–µ—Å—Ç–∞—Ä—Ç. –¢–∞–∫ –¥–µ—Ä–∂–∞—Ç—å.",
      en: "There‚Äôs the gentle restart. Nice.",
      es: "As√≠ se ve un reinicio suave. Bien hecho.",
      fr: "Voil√† un red√©marrage tout doux. Bravo.",
    },
    impulseOverlay: {
      ru: "–û—Ç–¥–æ—Ö–Ω—É–≤—à–∞—è –≤–µ—Ä—Å–∏—è —Ç–µ–±—è —É–º–µ–µ—Ç –≥–æ–≤–æ—Ä–∏—Ç—å ¬´–ø–æ—Ç–æ–º¬ª.",
      en: "Rested-you can say ‚Äúlater‚Äù with ease.",
      es: "En modo descanso es m√°s f√°cil decir ‚Äúluego‚Äù.",
      fr: "Repos√©¬∑e, tu peux dire \"plus tard\" sans effort.",
    },
    pushPendingTitle: {
      ru: "–í–µ—Ä–Ω–∏—Å—å –∫ ¬´{{title}}¬ª",
      en: "Come back to ‚Äú{{title}}‚Äù",
      es: "Vuelve a ¬´{{title}}¬ª",
      fr: "Reviens √† ¬´ {{title}} ¬ª",
    },
    pushPendingBody: {
      ru: "–†–µ–∂–∏–º –æ—Ç–¥—ã—Ö–∞ –Ω–µ –≤–µ—á–Ω—ã–π. –†–µ—à–∏, —á—Ç–æ –¥–µ–ª–∞—Ç—å —Å ¬´{{title}}¬ª.",
      en: "Recharge mode isn‚Äôt forever. Decide what to do with ‚Äú{{title}}‚Äù.",
      es: "El modo descanso no es eterno. Decide qu√© hacer con ¬´{{title}}¬ª.",
      fr: "Le mode recharge n'est pas √©ternel. D√©cide quoi faire de ¬´ {{title}} ¬ª.",
    },
    pushImpulseTitle: {
      ru: "–ú—è–≥–∫–∏–π —Å–∏–≥–Ω–∞–ª",
      en: "Gentle alert",
      es: "Alerta suave",
      fr: "Alerte douce",
    },
    pushImpulseBody: {
      ru: "–ü–∞—É–∑—ã –±—ã–ª–∏ –¥–ª–∏–Ω–Ω—ã–º–∏, –Ω–æ –¥–∞–∂–µ —Å–µ–π—á–∞—Å –º–æ–∂–Ω–æ —Å–±–µ—Ä–µ—á—å {{amount}} –æ—Ç {{temptation}}.",
      en: "Breaks ran long, yet this minute can still save {{amount}} from {{temptation}}.",
      es: "El descanso fue largo, pero a√∫n puedes salvar {{amount}} de {{temptation}}.",
      fr: "La pause a dur√©, mais tu peux encore sauver {{amount}} de {{temptation}}.",
    },
  },
  [MOOD_IDS.DREAMER]: {
    label: { ru: "–ú–µ—á—Ç–∞—Ç–µ–ª—å–Ω—ã–π —Ä–µ–∂–∏–º", en: "Dreamer mode", es: "Modo so√±ador", fr: "Mode r√™veur" },
    hero: {
      ru: "–ú–µ—á—Ç–∞—Ç–µ–ª—å–Ω—ã–π —Ä–µ–∂–∏–º –∞–∫—Ç–∏–≤–µ–Ω - –≤ ¬´–¥—É–º–∞–µ–º¬ª —É–∂–µ —Ü–µ–ª–∞—è –≥–∞–ª–µ—Ä–µ—è.",
      en: "Dreamer mode is on-your Thinking shelf is a gallery.",
      es: "Modo so√±ador activo: tu estante En pausa parece una galer√≠a.",
      fr: "Le mode r√™veur est activ√© : ton onglet En pause ressemble √† une galerie.",
    },
    heroComplete: {
      ru: "–î–∞–∂–µ –º–µ—á—Ç–∞—Ç–µ–ª–∏ –¥–æ–≤–æ–¥—è—Ç –ø–ª–∞–Ω—ã –¥–æ –∫–æ–Ω—Ü–∞.",
      en: "Even dreamers finish their plans.",
      es: "Incluso los so√±adores concluyen sus planes.",
      fr: "M√™me les r√™veurs bouclent leurs plans.",
    },
    motivation: {
      ru: "–í—ã–±–µ—Ä–∏ –æ–¥–Ω—É –º–µ—á—Ç—É –∏ –Ω–∞–∂–º–∏ ¬´–∫–æ–ø–∏—Ç—å¬ª —Å–µ–≥–æ–¥–Ω—è.",
      en: "Pick one dream and tap ‚Äúsave it‚Äù today.",
      es: "Elige un sue√±o y pulsa ‚Äúah√≥rralo‚Äù hoy.",
      fr: "Choisis un r√™ve et appuie sur ¬´ j'√©conomise ¬ª aujourd'hui.",
    },
    saveOverlay: {
      ru: "–ú–µ—á—Ç–∞ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–º –¥–µ–π—Å—Ç–≤–∏–µ–º.",
      en: "Dream locked in with a real action.",
      es: "Sue√±o asegurado con una acci√≥n real.",
      fr: "R√™ve s√©curis√© par une vraie action.",
    },
    impulseOverlay: {
      ru: "–ü—É—Å—Ç—å –º–µ—á—Ç—ã –∫–æ–ø—è—Ç—Å—è –≤ —Ü–∏—Ñ—Ä–∞—Ö, –∞ –Ω–µ —Ä–∞—Å—Ö–æ–¥–∞—Ö.",
      en: "Let dreams live in numbers, not expenses.",
      es: "Que los sue√±os vivan en cifras y no en gastos.",
      fr: "Que les r√™ves vivent en chiffres, pas en d√©penses.",
    },
    pushPendingTitle: {
      ru: "–ú–µ—á—Ç—ã –∂–¥—É—Ç —Å—Ç–∞—Ä—Ç–∞",
      en: "Dreams are waiting",
      es: "Los sue√±os esperan",
      fr: "Les r√™ves attendent",
    },
    pushPendingBody: {
      ru: "–í ¬´–¥—É–º–∞–µ–º¬ª —É–∂–µ –æ—á–µ—Ä–µ–¥—å. –†–µ—à–∏, —á—Ç–æ –¥–µ–ª–∞—Ç—å —Å ¬´{{title}}¬ª.",
      en: "Thinking is crowded. Decide what to do with ‚Äú{{title}}‚Äù.",
      es: "Hay fila en En pausa. Decide qu√© hacer con ¬´{{title}}¬ª.",
      fr: "L'onglet En pause est plein. D√©cide quoi faire de ¬´ {{title}} ¬ª.",
    },
    pushImpulseTitle: {
      ru: "–ú–µ—á—Ç–∞—Ç–µ–ª—å–Ω—ã–π —Å–∏–≥–Ω–∞–ª",
      en: "Dreamer alert",
      es: "Alerta so√±adora",
      fr: "Alerte r√™veuse",
    },
    pushImpulseBody: {
      ru: "–õ—É—á—à–µ –¥–æ–±–∞–≤–∏—Ç—å {{amount}} –≤ –º–µ—á—Ç—É, —á–µ–º —Å–Ω–æ–≤–∞ –±—Ä–∞—Ç—å {{temptation}}.",
      en: "Add {{amount}} to the dream instead of grabbing {{temptation}} again.",
      es: "Mejor suma {{amount}} al sue√±o antes que volver a tomar {{temptation}}.",
      fr: "Ajoute {{amount}} au r√™ve plut√¥t que de reprendre {{temptation}}.",
    },
  },
};

const lightenColor = (hex, amount = 0.25) => {
  if (typeof hex !== "string" || !hex.startsWith("#") || (hex.length !== 7 && hex.length !== 4)) {
    return hex;
  }
  const full = hex.length === 4 ? `#${hex[1]}${hex[1]}${hex[2]}${hex[2]}${hex[3]}${hex[3]}` : hex;
  const num = parseInt(full.slice(1), 16);
  if (Number.isNaN(num)) return hex;
  const adjust = (channel) => {
    const delta = 255 * amount;
    const next = channel + delta;
    return Math.max(0, Math.min(255, Math.round(next)));
  };
  const r = adjust((num >> 16) & 255);
  const g = adjust((num >> 8) & 255);
  const b = adjust(num & 255);
  return `rgb(${r}, ${g}, ${b})`;
};

const MOOD_GRADIENTS = {
  [MOOD_IDS.NEUTRAL]: {
    start: "#CDE6FF",
    end: "#F3F7FF",
    accent: "#A2C9FF",
  },
  [MOOD_IDS.FOCUSED]: {
    start: "#FFE8C7",
    end: "#FFD6E7",
    accent: "#FFB973",
  },
  [MOOD_IDS.IMPULSIVE]: {
    start: "#FFD1CC",
    end: "#FFF0DA",
    accent: "#FF8A7F",
  },
  [MOOD_IDS.DOUBTER]: {
    start: "#E3D8FF",
    end: "#F7E9FF",
    accent: "#C7B1FF",
  },
  [MOOD_IDS.TIRED]: {
    start: "#D5E0FF",
    end: "#ECEFF5",
    accent: "#9AB0FF",
  },
  [MOOD_IDS.DREAMER]: {
    start: "#CFF7F1",
    end: "#E9E2FF",
    accent: "#94D8C7",
  },
};

const getMoodGradient = (moodId = MOOD_IDS.NEUTRAL) =>
  MOOD_GRADIENTS[moodId] || MOOD_GRADIENTS[MOOD_IDS.NEUTRAL];

const applyThemeToMoodGradient = (palette, themeKey = "light") => {
  if (!palette) return getMoodGradient();
  if (themeKey !== "dark") return palette;
  return {
    start: lightenColor(palette.start, -0.55),
    end: lightenColor(palette.end, -0.65),
    accent: lightenColor(palette.accent, 0.35),
  };
};

const MoodGradientBlock = ({ colors: palette, style, children }) => {
  const gradientColors = palette || MOOD_GRADIENTS[MOOD_IDS.NEUTRAL];
  return (
    <View
      style={[
        styles.moodGradientBlock,
        { backgroundColor: gradientColors.start },
        style,
      ]}
    >
      <View
        pointerEvents="none"
        style={[
          styles.moodGradientOverlay,
          { backgroundColor: gradientColors.end },
        ]}
      />
      {children}
    </View>
  );
};

const CoinRainOverlay = React.memo(({ dropCount = 14 }) => {
  const drops = useRef(
    Array.from({ length: dropCount }).map((_, idx) => {
      const anim = new Animated.Value(Math.random());
      return {
        key: `coin_rain_${idx}`,
        anim,
        left: Math.random() * (SCREEN_WIDTH - 40),
        size: 20 + Math.random() * 14,
        duration: 4200 + Math.random() * 1800,
        delay: Math.random() * 1400,
      };
    })
  ).current;

  useEffect(() => {
    const loops = drops.map(({ anim, duration, delay }) => {
      const animation = Animated.loop(
        Animated.sequence([
          Animated.delay(delay),
          Animated.timing(anim, {
            toValue: 1,
            duration,
            easing: Easing.out(Easing.cubic),
            useNativeDriver: true,
          }),
          Animated.timing(anim, {
            toValue: 0,
            duration: 0,
            useNativeDriver: true,
          }),
        ])
      );
      animation.start();
      return animation;
    });
    return () => {
      loops.forEach((animation) => animation?.stop?.());
    };
  }, [drops]);

  return (
    <View pointerEvents="none" style={StyleSheet.absoluteFillObject}>
      {drops.map(({ key, anim, left, size }) => {
        const translateY = anim.interpolate({
          inputRange: [0, 1],
          outputRange: [-160, Dimensions.get("window").height + 120],
        });
        const translateX = anim.interpolate({
          inputRange: [0, 0.2, 0.5, 0.8, 1],
          outputRange: [left - 16, left + 12, left - 8, left + 6, left - 2],
        });
        const opacity = anim.interpolate({
          inputRange: [0, 0.15, 0.85, 1],
          outputRange: [0, 0.9, 0.8, 0],
        });
        const rotate = anim.interpolate({
          inputRange: [0, 1],
          outputRange: ["180deg", "540deg"],
        });
        return (
          <Animated.Image
            key={key}
            source={HEALTH_COIN_TIERS[0].asset}
            style={{
              position: "absolute",
              left: 0,
              width: size,
              height: size,
              opacity,
              transform: [
                { translateX },
                { translateY },
                { rotate },
              ],
            }}
            resizeMode="contain"
          />
        );
      })}
    </View>
  );
});

const PartyFirework = ({ color, size = 160, delay = 0, style }) => {
  const scale = useRef(new Animated.Value(0.2)).current;
  const opacity = useRef(new Animated.Value(0)).current;
  useEffect(() => {
    scale.setValue(0.2);
    opacity.setValue(0);
    const animation = Animated.loop(
      Animated.sequence([
        Animated.delay(delay),
        Animated.parallel([
          Animated.timing(scale, {
            toValue: 1,
            duration: 1100,
            easing: Easing.out(Easing.cubic),
            useNativeDriver: true,
          }),
          Animated.sequence([
            Animated.timing(opacity, {
              toValue: 0.85,
              duration: 220,
              useNativeDriver: true,
            }),
            Animated.timing(opacity, {
              toValue: 0,
              duration: 880,
              useNativeDriver: true,
            }),
          ]),
        ]),
        Animated.timing(scale, {
          toValue: 0.2,
          duration: 0,
          useNativeDriver: true,
        }),
      ])
    );
    animation.start();
    return () => animation.stop();
  }, [delay, opacity, scale]);
  return (
    <Animated.View
      pointerEvents="none"
      style={[
        styles.partyFireworkRing,
        style,
        {
          borderColor: color,
          width: size,
          height: size,
          borderRadius: size / 2,
          transform: [{ scale }],
          opacity,
        },
      ]}
    />
  );
};

const PartyFireworksLayer = ({ isDarkMode = false }) => {
  const palette = useMemo(
    () => (isDarkMode ? PARTY_FIREWORK_COLORS.dark : PARTY_FIREWORK_COLORS.light),
    [isDarkMode]
  );
  return (
    <View pointerEvents="none" style={styles.partyFireworksOverlay}>
      {PARTY_FIREWORK_CONFIGS.map((config, index) => (
        <PartyFirework
          key={`firework_${index}`}
          color={palette[index % palette.length]}
          size={config.size}
          delay={config.delay}
          style={{
            top: config.top,
            bottom: config.bottom,
            left: config.left,
            right: config.right,
          }}
        />
      ))}
    </View>
  );
};

const TAMAGOTCHI_IDLE_VARIANTS = ["idle", "idle", "curious", "follow", "speak"];
const TAMAGOTCHI_STARVING_VARIANTS = ["cry", "cry", "sad", "ohno", "idle"];
const TAMAGOTCHI_REACTION_DURATION = {
  happy: 3600,
  happyHeadshake: 3600,
  sad: 4200,
  ohno: 4000,
};
const TAMAGOTCHI_DECAY_INTERVAL_MS = 1000 * 60 * 5;
const TAMAGOTCHI_DECAY_STEP = 2;
const TAMAGOTCHI_COIN_DECAY_TICKS = 6;
const TAMAGOTCHI_FEED_AMOUNT = ECONOMY_RULES.tamagotchiFeedBoost;
const TAMAGOTCHI_MAX_HUNGER = 100;
const TAMAGOTCHI_FEED_COST = ECONOMY_RULES.tamagotchiFeedCost;
const TAMAGOTCHI_PARTY_COST = ECONOMY_RULES.tamagotchiPartyCost;
const PARTY_FIREWORK_CONFIGS = [
  { top: "12%", left: "18%", size: 150, delay: 0 },
  { top: "18%", right: "16%", size: 120, delay: 180 },
  { bottom: "26%", left: "20%", size: 170, delay: 360 },
  { bottom: "22%", right: "18%", size: 140, delay: 520 },
  { top: "30%", left: "40%", size: 110, delay: 420 },
];
const PARTY_FIREWORK_COLORS = {
  light: ["#FFB457", "#FF6FD8", "#7CDAFF", "#FFD36E"],
  dark: ["#FFD685", "#FF8FF3", "#7DC6FF", "#9BFFDA"],
};
const TAMAGOTCHI_PARTY_BLUE_COST = Math.max(
  1,
  Math.round(TAMAGOTCHI_PARTY_COST / HEALTH_COIN_TIERS[1].value)
);
const TAMAGOTCHI_FOOD_OPTIONS = [
  {
    id: "berries",
    tier: "snack",
    emoji: "üçì",
    hungerBoost: Math.round(TAMAGOTCHI_FEED_AMOUNT * 0.55),
    cost: Math.max(1, Math.round(TAMAGOTCHI_FEED_COST)),
    label: { ru: "–Ø–≥–æ–¥–∫–∏", en: "Berries", es: "Frutos rojos", fr: "Baies" },
  },
  {
    id: "fish",
    tier: "treat",
    emoji: "üêü",
    hungerBoost: TAMAGOTCHI_FEED_AMOUNT,
    cost: Math.max(2, Math.round(TAMAGOTCHI_FEED_COST * 2)),
    label: { ru: "–†—ã–±–∫–∞", en: "Fish", es: "Pescado", fr: "Poisson" },
  },
  {
    id: "sushi",
    tier: "deluxe",
    emoji: "üç£",
    hungerBoost: TAMAGOTCHI_FEED_AMOUNT + 12,
    cost: Math.max(4, Math.round(TAMAGOTCHI_FEED_COST * 4)),
    label: { ru: "–°—É—à–∏", en: "Sushi", es: "Sushi", fr: "Sushi" },
  },
  {
    id: "cake",
    tier: "deluxe",
    emoji: "üç∞",
    hungerBoost: TAMAGOTCHI_FEED_AMOUNT + 18,
    cost: Math.max(5, Math.round(TAMAGOTCHI_FEED_COST * 5)),
    label: { ru: "–î–µ—Å–µ—Ä—Ç", en: "Dessert", es: "Postre", fr: "Dessert" },
  },
];
const TAMAGOTCHI_FOOD_MAP = TAMAGOTCHI_FOOD_OPTIONS.reduce((acc, option) => {
  acc[option.id] = option;
  return acc;
}, {});
const TAMAGOTCHI_DEFAULT_FOOD_ID =
  TAMAGOTCHI_FOOD_OPTIONS[0]?.id || (TAMAGOTCHI_FOOD_OPTIONS[1]?.id ?? "berries");
const resolveTamagotchiFoodTier = (hunger = TAMAGOTCHI_MAX_HUNGER) => {
  const normalized = Math.max(0, Math.min(TAMAGOTCHI_MAX_HUNGER, hunger));
  if (normalized < 30) return "deluxe";
  if (normalized < 60) return "treat";
  return "snack";
};
const pickTamagotchiFoodByTier = (tier = "snack", excludeId = null) => {
  const pool = TAMAGOTCHI_FOOD_OPTIONS.filter((food) => food.tier === tier);
  const fallback = pool.length ? pool : TAMAGOTCHI_FOOD_OPTIONS;
  if (!fallback.length) return null;
  const candidates =
    excludeId && fallback.length > 1 ? fallback.filter((food) => food.id !== excludeId) : fallback;
  const list = candidates.length ? candidates : fallback;
  const randomIndex = Math.floor(Math.random() * list.length);
  return list[randomIndex]?.id || fallback[0].id;
};
const resolveNextTamagotchiFoodId = (
  hunger = TAMAGOTCHI_MAX_HUNGER,
  prevId = TAMAGOTCHI_DEFAULT_FOOD_ID,
  forceChange = false
) => {
  const nextTier = resolveTamagotchiFoodTier(hunger);
  const prevFood = TAMAGOTCHI_FOOD_MAP[prevId];
  const prevTier = prevFood?.tier || resolveTamagotchiFoodTier(TAMAGOTCHI_MAX_HUNGER);
  if (!forceChange && prevTier === nextTier && prevFood) {
    return prevId;
  }
  return pickTamagotchiFoodByTier(nextTier, forceChange ? prevId : null) || prevId;
};
const TAMAGOTCHI_HUNGER_LOW_THRESHOLD = Math.round(TAMAGOTCHI_MAX_HUNGER * 0.25);
const TAMAGOTCHI_START_STATE = {
  hunger: 80,
  coins: 5,
  lastFedAt: null,
  lastDecayAt: null,
  coinTick: 0,
  desiredFoodId: TAMAGOTCHI_DEFAULT_FOOD_ID,
};
const TAMAGOTCHI_NOTIFICATION_COPY = {
  ru: {
    low: "–ê–ª–º–∏ –∏–∑ Almost –ø—Ä–æ–≥–æ–ª–æ–¥–∞–ª—Å—è - –∑–∞–≥–ª—è–Ω–∏ –∏ –ø–æ–∫–æ—Ä–º–∏ –µ–≥–æ.",
    starving: "–ê–ª–º–∏ —Å–æ–≤—Å–µ–º –æ—Å–ª–∞–±. –û—Ç–∫—Ä–æ–π Almost –∏ –Ω–∞–∫–æ—Ä–º–∏ –µ–≥–æ —Å–∫–æ—Ä–µ–µ.",
  },
  en: {
    low: "Almi from Almost is hungry - drop in and feed him.",
    starving: "Almi is starving. Open Almost and give him a snack.",
  },
};

const computeTamagotchiDecay = (state = TAMAGOTCHI_START_STATE, timestamp = Date.now()) => {
  const source = state || {};
  const now = Number.isFinite(timestamp) ? timestamp : Date.now();
  const lastStored = source.lastDecayAt;
  const last =
    typeof lastStored === "number" && Number.isFinite(lastStored)
      ? lastStored
      : Number(lastStored) || now;
  const hunger = Math.min(TAMAGOTCHI_MAX_HUNGER, Math.max(0, Number(source.hunger) || 0));
  const coins = Math.max(0, Math.floor(Number(source.coins) || 0));
  const coinTick = Math.max(0, Number(source.coinTick) || 0);
  const elapsed = Math.max(0, now - last);
  const ticks = Math.floor(elapsed / TAMAGOTCHI_DECAY_INTERVAL_MS);
  if (ticks <= 0) {
    return {
      state: {
        ...source,
        hunger,
        coins,
        coinTick,
        lastDecayAt: now,
      },
      burnedCoins: 0,
    };
  }
  const hungerDrop = ticks * TAMAGOTCHI_DECAY_STEP;
  const nextHunger = Math.max(0, hunger - hungerDrop);
  const totalTicks = coinTick + ticks;
  const nextCoinTick = totalTicks % TAMAGOTCHI_COIN_DECAY_TICKS;
  const decayDuration = ticks * TAMAGOTCHI_DECAY_INTERVAL_MS;
  const hungerDelta = hunger - nextHunger;
  const tierChanged = resolveTamagotchiFoodTier(nextHunger) !== resolveTamagotchiFoodTier(hunger);
  const shouldRefreshCraving =
    !source?.desiredFoodId || tierChanged || hungerDelta >= TAMAGOTCHI_DECAY_STEP * 3;
  const desiredFoodId = shouldRefreshCraving
    ? resolveNextTamagotchiFoodId(nextHunger, source?.desiredFoodId, hungerDelta > 0)
    : source.desiredFoodId;
  return {
    state: {
      ...source,
      hunger: nextHunger,
      coins,
      lastDecayAt: last + decayDuration,
      coinTick: nextCoinTick,
      desiredFoodId: desiredFoodId || TAMAGOTCHI_DEFAULT_FOOD_ID,
    },
    burnedCoins: 0,
  };
};

const getTamagotchiMood = (hunger = 0, language = DEFAULT_LANGUAGE) => {
  const texts = {
    ru: {
      happy: "–ê–ª–º–∏ —Å—ã—Ç—ã–π –∏ –¥–æ–≤–æ–ª—å–Ω—ã–π",
      calm: "–ê–ª–º–∏ —á—É—Ç—å –ø—Ä–æ–≥–æ–ª–æ–¥–∞–ª—Å—è",
      sad: "–ê–ª–º–∏ –≥—Ä—É—Å—Ç–∏—Ç, —Ö–æ—á–µ—Ç –º–æ–Ω–µ—Ç–∫—É",
      urgent: "–ê–ª–º–∏ –æ—á–µ–Ω—å –≥–æ–ª–æ–¥–Ω—ã–π!",
    },
    en: {
      happy: "Almi is well-fed and happy",
      calm: "Almi is getting hungry",
      sad: "Almi is sad, needs a coin",
      urgent: "Almi is very hungry!",
    },
    es: {
      happy: "Almi est√° lleno y feliz",
      calm: "Almi empieza a tener hambre",
      sad: "Almi est√° triste, quiere una moneda",
      urgent: "¬°Almi tiene mucha hambre!",
    },
    fr: {
      happy: "Almi est rassasi√© et heureux",
      calm: "Almi commence √† avoir faim",
      sad: "Almi est triste, il veut une pi√®ce",
      urgent: "Almi a tr√®s faim !",
    },
  };
  const dict = texts[language] || texts.ru;
  if (hunger >= 75) return { label: dict.happy, tone: "happy" };
  if (hunger >= 45) return { label: dict.calm, tone: "calm" };
  if (hunger >= 20) return { label: dict.sad, tone: "sad" };
  return { label: dict.urgent, tone: "urgent" };
};

function AlmiTamagotchi({
  override,
  onOverrideComplete,
  style,
  isStarving = false,
  animations = CLASSIC_TAMAGOTCHI_ANIMATIONS,
}) {
  const [currentKey, setCurrentKey] = useState("idle");
  const idleTimerRef = useRef(null);
  const overrideTimerRef = useRef(null);
  const idleVariants = useMemo(
    () => (isStarving ? TAMAGOTCHI_STARVING_VARIANTS : TAMAGOTCHI_IDLE_VARIANTS),
    [isStarving]
  );
  const resolveNextIdleKey = useCallback(() => {
    const pool = idleVariants.length ? idleVariants : TAMAGOTCHI_IDLE_VARIANTS;
    const index = Math.floor(Math.random() * pool.length);
    return pool[index] || "idle";
  }, [idleVariants]);

  const scheduleIdleCycle = useCallback(
    (delay = 4500) => {
      if (idleTimerRef.current) clearTimeout(idleTimerRef.current);
      idleTimerRef.current = setTimeout(() => {
        const next = resolveNextIdleKey();
        setCurrentKey(next);
        scheduleIdleCycle(5000 + Math.random() * 3000);
      }, delay);
    },
    [resolveNextIdleKey]
  );

  useEffect(() => {
    scheduleIdleCycle(2200);
    return () => {
      if (idleTimerRef.current) clearTimeout(idleTimerRef.current);
      if (overrideTimerRef.current) clearTimeout(overrideTimerRef.current);
    };
  }, [scheduleIdleCycle]);

  useEffect(() => {
    if (!override) return;
    if (idleTimerRef.current) clearTimeout(idleTimerRef.current);
    if (overrideTimerRef.current) clearTimeout(overrideTimerRef.current);
    const key = animations[override.type] ? override.type : "happy";
    setCurrentKey(key);
    overrideTimerRef.current = setTimeout(() => {
      onOverrideComplete?.();
      scheduleIdleCycle(2500);
    }, override.duration || 3200);
  }, [animations, override?.key, override?.type, override?.duration, onOverrideComplete, scheduleIdleCycle]);

  const source = animations[currentKey] || animations.idle;
  return (
    <View style={[styles.almiMascotWrap, style]}>
      <Image
        source={source}
        defaultSource={animations.idle}
        style={styles.almiMascotImage}
        resizeMode="contain"
        fadeDuration={0}
      />
    </View>
  );
}
const MAX_IMPULSE_EVENTS = 180;
const MIN_IMPULSE_EVENTS_FOR_MAP = 4;
const IMPULSE_ALERT_COOLDOWN_MS = 1000 * 60 * 45;
const IMPULSE_CATEGORY_DEFS = {
  food: { id: "food", ru: "–ï–¥–∞", en: "Food", es: "Comida", fr: "Nourriture", emoji: "üçú" },
  things: { id: "things", ru: "–í–µ—â–∏", en: "Things", es: "Cosas", fr: "Objets", emoji: "üéÅ" },
  fun: {
    id: "fun",
    ru: "–†–∞–∑–≤–ª–µ—á–µ–Ω–∏—è",
    en: "Entertainment",
    es: "Diversi√≥n",
    fr: "Divertissement",
    emoji: "üéâ",
  },
  vices: {
    id: "vices",
    ru: "–í—Ä–µ–¥–Ω—ã–µ –º–µ–ª–æ—á–∏",
    en: "Small vices",
    es: "Peque√±os vicios",
    fr: "Petits vices",
    emoji: "‚ö°Ô∏è",
  },
};
const IMPULSE_CATEGORY_ORDER = ["food", "things", "fun", "vices"];
const DEFAULT_IMPULSE_CATEGORY = "vices";
const INITIAL_IMPULSE_TRACKER = {
  events: [],
  lastAlerts: {},
};

const padHour = (value) => value.toString().padStart(2, "0");
const formatImpulseWindowLabel = (hour, span = 2) => {
  if (!Number.isInteger(hour)) return null;
  const start = padHour(hour);
  const end = padHour((hour + span) % 24);
  return `${start}:00‚Äì${end}:00`;
};

const resolveImpulseCategory = (item = {}) => {
  const override = typeof item?.impulseCategoryOverride === "string" ? item.impulseCategoryOverride : null;
  if (override && IMPULSE_CATEGORY_DEFS[override]) {
    return override;
  }
  const categories = Array.isArray(item.categories)
    ? item.categories.map((entry) => (entry || "").toLowerCase())
    : [];
  const price = Number(item.priceUSD ?? item.basePriceUSD ?? 0) || 0;
  const matches = (...keys) => categories.some((cat) => keys.includes(cat));
  if (matches("food", "groceries", "meal", "dining")) return "food";
  if (matches("coffee", "tea", "habit") && price <= 30) return "vices";
  if (matches("travel", "wow", "game", "gaming", "fun", "experience", "movie", "concert")) return "fun";
  if (matches("style", "tech", "phone", "wearable", "fashion", "beauty", "home", "sport", "flagship")) return "things";
  if (matches("lifestyle", "custom", "gift") && price <= 60) return "vices";
  if (price <= 18) return "vices";
  if (price <= 90) return "food";
  return "things";
};

const resolveGoalTypeFromTarget = (targetUSD = 0) => {
  if (!Number.isFinite(targetUSD)) return "short_term";
  return targetUSD >= 1000 ? "long_term" : "short_term";
};

const isCustomTemptation = (item = null) => {
  if (!item) return false;
  const categories = Array.isArray(item.categories) ? item.categories : [];
  if (categories.includes("custom")) return true;
  if (typeof item.id === "string") {
    return item.id.startsWith("custom_") || item.id.startsWith("custom");
  }
  return false;
};

const buildImpulseInsights = (events = []) => {
  if (!Array.isArray(events) || !events.length) {
    const categories = IMPULSE_CATEGORY_ORDER.reduce((acc, id) => {
      acc[id] = { save: 0, spend: 0 };
      return acc;
    }, {});
    return { categories, hotLose: null, hotWin: null, activeRisk: null, hottestCategory: null, eventCount: 0 };
  }
  const categories = IMPULSE_CATEGORY_ORDER.reduce((acc, id) => {
    acc[id] = { save: 0, spend: 0 };
    return acc;
  }, {});
  const templateStats = new Map();
  let processedEvents = 0;
  let totalSaves = 0;
  let totalSpends = 0;
  events.forEach((event) => {
    if (!event || !event.templateId) return;
    processedEvents += 1;
    const category = event.category || "things";
    if (!categories[category]) {
      categories[category] = { save: 0, spend: 0 };
    }
    if (event.action === "save") {
      categories[category].save += 1;
      totalSaves += 1;
    } else if (event.action === "spend") {
      categories[category].spend += 1;
      totalSpends += 1;
    }
    const stat =
      templateStats.get(event.templateId) || {
        templateId: event.templateId,
        title: event.title,
        emoji: event.emoji,
        category,
        saveCount: 0,
        spendCount: 0,
        saveHours: Array(24).fill(0),
        spendHours: Array(24).fill(0),
        lastAmountUSD: event.amountUSD || 0,
      };
    if (event.action === "save") {
      stat.saveCount += 1;
      if (Number.isInteger(event.hour)) {
        stat.saveHours[event.hour] = (stat.saveHours[event.hour] || 0) + 1;
      }
    } else if (event.action === "spend") {
      stat.spendCount += 1;
      if (Number.isInteger(event.hour)) {
        stat.spendHours[event.hour] = (stat.spendHours[event.hour] || 0) + 1;
      }
      stat.lastAmountUSD = event.amountUSD || stat.lastAmountUSD;
    }
    templateStats.set(event.templateId, stat);
  });
  const selectHotHour = (hours = []) => {
    let chosen = null;
    let best = 0;
    hours.forEach((value, hour) => {
      if (value > best) {
        best = value;
        chosen = hour;
      }
    });
    return {
      hour: Number.isInteger(chosen) ? chosen : null,
      count: best,
      label: Number.isInteger(chosen) ? formatImpulseWindowLabel(chosen) : null,
    };
  };
  let hotLose = null;
  let hotWin = null;
  templateStats.forEach((stat) => {
    const total = stat.saveCount + stat.spendCount;
    if (!total) return;
    const loseRate = stat.spendCount / total;
    if (stat.spendCount >= 1 && loseRate >= 0.5) {
      if (!hotLose || stat.spendCount > hotLose.spendCount || loseRate > hotLose.lossRate) {
        hotLose = {
          ...stat,
          lossRate: loseRate,
          hotspot: selectHotHour(stat.spendHours),
        };
      }
    }
    const winRate = stat.saveCount / total;
    if (stat.saveCount >= 1 && winRate >= 0.5) {
      if (!hotWin || stat.saveCount > hotWin.saveCount || winRate > hotWin.winRate) {
        hotWin = {
          ...stat,
          winRate,
          hotspot: selectHotHour(stat.saveHours),
        };
      }
    }
  });
  const nowHour = new Date().getHours();
  let activeRisk = null;
  templateStats.forEach((stat) => {
    const spendHits = stat.spendHours[nowHour] || 0;
    if (spendHits < 2) return;
    const saveHits = stat.saveHours[nowHour] || 0;
    if (saveHits >= spendHits) return;
    const total = stat.saveCount + stat.spendCount;
    if (!total) return;
    const lossRate = stat.spendCount / total;
    if (lossRate < 0.6) return;
    if (!activeRisk || spendHits > activeRisk.spendHits) {
      activeRisk = {
        templateId: stat.templateId,
        title: stat.title,
        emoji: stat.emoji,
        category: stat.category,
        spendHits,
        hour: nowHour,
        windowLabel: formatImpulseWindowLabel(nowHour),
        amountUSD: stat.lastAmountUSD,
      };
    }
  });
  const hottestCategory = IMPULSE_CATEGORY_ORDER.reduce(
    (best, id) => {
      const entry = categories[id];
      const delta = (entry?.spend || 0) - (entry?.save || 0);
      if (!best || delta > best.delta) {
        return { id, delta };
      }
      return best;
    },
    null
  );
  return {
    categories,
    hotLose: hotLose
      ? {
          templateId: hotLose.templateId,
          title: hotLose.title,
          emoji: hotLose.emoji,
          category: hotLose.category,
          count: hotLose.spendCount,
          rate: hotLose.lossRate,
          windowLabel: hotLose.hotspot?.label || null,
        }
      : null,
    hotWin: hotWin
      ? {
          templateId: hotWin.templateId,
          title: hotWin.title,
          emoji: hotWin.emoji,
          category: hotWin.category,
          count: hotWin.saveCount,
          rate: hotWin.winRate,
          windowLabel: hotWin.hotspot?.label || null,
        }
      : null,
    activeRisk,
    hottestCategory,
    eventCount: processedEvents,
    totalSaveCount: totalSaves,
    totalSpendCount: totalSpends,
  };
};

const renderTemplateString = (template, params = {}) => {
  if (!template || typeof template !== "string") return "";
  return template.replace(/\{\{(\w+)\}\}/g, (_, key) =>
    params[key] !== undefined && params[key] !== null ? String(params[key]) : ""
  );
};

const SwipeableChallengeCard = ({
  children,
  colors,
  cancelLabel,
  onCancel,
  onSwipeOpen,
  onSwipeClose,
}) => {
  const translateX = useRef(new Animated.Value(0)).current;
  const gestureStartOffset = useRef(0);
  const closerRef = useRef(null);

  const closeRow = useCallback(
    (notify = true) => {
      Animated.timing(translateX, {
        toValue: 0,
        duration: 150,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }).start(() => {
        if (notify) {
          onSwipeClose?.(closerRef.current);
          closerRef.current = null;
        }
      });
    },
    [onSwipeClose, translateX]
  );

  const notifyOpen = useCallback(() => {
    const closer = () => closeRow();
    closerRef.current = closer;
    onSwipeOpen?.(closer);
  }, [closeRow, onSwipeOpen]);

  const panResponder = useMemo(
    () =>
      PanResponder.create({
        onMoveShouldSetPanResponder: (_, gestureState) =>
          Math.abs(gestureState.dx) > Math.abs(gestureState.dy) && gestureState.dx < -6,
        onPanResponderGrant: () => {
          translateX.stopAnimation((value) => {
            gestureStartOffset.current = value;
          });
        },
        onPanResponderMove: (_, gestureState) => {
          const base = gestureStartOffset.current || 0;
          const next = Math.max(-CHALLENGE_SWIPE_ACTION_WIDTH, Math.min(base + gestureState.dx, 0));
          translateX.setValue(next);
        },
        onPanResponderRelease: () => {
          translateX.stopAnimation((value) => {
            const shouldOpen = value < -CHALLENGE_SWIPE_ACTION_WIDTH * 0.35;
            Animated.timing(translateX, {
              toValue: shouldOpen ? -CHALLENGE_SWIPE_ACTION_WIDTH : 0,
              duration: 180,
              easing: Easing.out(Easing.quad),
              useNativeDriver: true,
            }).start(() => {
              if (shouldOpen) {
                notifyOpen();
              } else {
                closeRow();
              }
            });
          });
        },
        onPanResponderTerminate: () => {
          closeRow();
        },
      }),
    [closeRow, notifyOpen, translateX]
  );

  return (
    <View style={styles.challengeSwipeWrapper}>
      <View style={[styles.challengeSwipeActions, { backgroundColor: SPEND_ACTION_COLOR }]}>
        <TouchableOpacity
          style={[styles.challengeSwipeButton, { backgroundColor: SPEND_ACTION_COLOR }]}
          onPress={() => {
            closeRow();
            onCancel?.();
          }}
          activeOpacity={0.85}
        >
          <Text style={[styles.challengeSwipeButtonText, { color: colors.background }]}>{cancelLabel}</Text>
        </TouchableOpacity>
      </View>
      <Animated.View style={{ transform: [{ translateX }] }} {...panResponder.panHandlers}>
        {children}
      </Animated.View>
    </View>
  );
};

const getMoodPreset = (moodId = MOOD_IDS.NEUTRAL, language = DEFAULT_LANGUAGE) => {
  const preset = MOOD_PRESETS[moodId] || MOOD_PRESETS[MOOD_IDS.NEUTRAL];
  const localize = (value) => {
    if (!value) return "";
    if (typeof value === "string") return value;
    return value[language] || value.en || "";
  };
  return {
    id: preset.id || moodId,
    label: localize(preset.label),
    hero: localize(preset.hero),
    heroComplete: localize(preset.heroComplete),
    motivation: localize(preset.motivation),
    saveOverlay: localize(preset.saveOverlay),
    impulseOverlay: localize(preset.impulseOverlay),
    pushPendingTitle: localize(preset.pushPendingTitle),
    pushPendingBody: localize(preset.pushPendingBody),
    pushImpulseTitle: localize(preset.pushImpulseTitle),
    pushImpulseBody: localize(preset.pushImpulseBody),
  };
};

const getLatestEventTimestamp = (events = [], type) => {
  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];
    if (event?.type === type && event.timestamp) {
      return event.timestamp;
    }
  }
  return null;
};

const evaluateMoodState = (state = createMoodStateForToday(), context = {}) => {
  const now = context.now || Date.now();
  const pendingCount =
    context.pendingCount !== undefined ? context.pendingCount : state.pendingSnapshot || 0;
  const filteredEvents = (state.events || []).filter(
    (event) => now - (event.timestamp || 0) <= MOOD_ACTION_WINDOW_MS
  );
  const counts = filteredEvents.reduce(
    (acc, event) => {
      if (event?.type && acc[event.type] !== undefined) {
        acc[event.type] += 1;
      }
      return acc;
    },
    { save: 0, spend: 0, maybe: 0, dream: 0 }
  );
  let nextMood = state.current || MOOD_IDS.NEUTRAL;
  const lastInteraction = state.lastInteractionAt || state.lastVisitAt || 0;
  if (lastInteraction && now - lastInteraction >= MOOD_INACTIVITY_THRESHOLD_MS) {
    nextMood = MOOD_IDS.TIRED;
  } else {
    const candidates = [];
    if (counts.spend >= MOOD_EVENT_THRESHOLD) {
      const timestamp = getLatestEventTimestamp(filteredEvents, "spend");
      if (timestamp) candidates.push({ mood: MOOD_IDS.IMPULSIVE, timestamp });
    }
    if (counts.save >= MOOD_EVENT_THRESHOLD) {
      const timestamp = getLatestEventTimestamp(filteredEvents, "save");
      if (timestamp) candidates.push({ mood: MOOD_IDS.FOCUSED, timestamp });
    }
    if (counts.maybe >= MOOD_EVENT_THRESHOLD) {
      const timestamp = getLatestEventTimestamp(filteredEvents, "maybe");
      if (timestamp) candidates.push({ mood: MOOD_IDS.DOUBTER, timestamp });
    }
    if (counts.dream >= MOOD_DREAM_WISH_THRESHOLD) {
      const timestamp = getLatestEventTimestamp(filteredEvents, "dream");
      if (timestamp) candidates.push({ mood: MOOD_IDS.DREAMER, timestamp });
    }
    if (pendingCount >= MOOD_PENDING_THRESHOLD) {
      candidates.push({ mood: MOOD_IDS.DREAMER, timestamp: now });
    }
    if (candidates.length) {
      candidates.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
      nextMood = candidates[0].mood;
    } else {
      nextMood = MOOD_IDS.NEUTRAL;
    }
  }
  return {
    ...state,
    current: nextMood,
    events: filteredEvents,
    pendingSnapshot: pendingCount,
  };
};

const mapHistoryEventsToMoodEvents = (history = [], now = Date.now()) =>
  history
    .filter((entry) => entry?.timestamp && now - entry.timestamp <= MOOD_ACTION_WINDOW_MS)
    .map((entry) => {
      if (entry.kind === "refuse_spend") return { type: "save", timestamp: entry.timestamp };
      if (entry.kind === "spend") return { type: "spend", timestamp: entry.timestamp };
      if (entry.kind === "pending_added") return { type: "maybe", timestamp: entry.timestamp };
      if (entry.kind === "wish_added") return { type: "dream", timestamp: entry.timestamp };
      return null;
    })
    .filter(Boolean)
    .slice(0, MOOD_MAX_EVENTS);

const WEEKDAY_LABELS = {
  ru: ["–í—Å", "–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±"],
  en: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  es: ["Dom", "Lun", "Mar", "Mi√©", "Jue", "Vie", "S√°b"],
  fr: ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"],
};
const WEEKDAY_LABELS_MONDAY_FIRST = {
  ru: ["–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±", "–í—Å"],
  en: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
  es: ["Lun", "Mar", "Mi√©", "Jue", "Vie", "S√°b", "Dom"],
  fr: ["Lun", "Mar", "Mer", "Jeu", "Ven", "Sam", "Dim"],
};
const PENDING_DAY_SUFFIX = { ru: "–¥", en: "d", es: "d", fr: "j" };

const buildSavingsBreakdown = (
  history = [],
  currency = DEFAULT_PROFILE.currency,
  resolveTemplateTitle,
  language = DEFAULT_LANGUAGE
) => {
  const now = Date.now();
  const defaultDeclineTitle = resolveTranslationValueForLanguage(language, "defaultDeclineLabel") || "Skip";
  const otherLabel = resolveTranslationValueForLanguage(language, "savingsBreakdownOtherLabel") || "Other";
  const dayLabels = WEEKDAY_LABELS[language] || WEEKDAY_LABELS.en;
  const palette = ["#3E8EED", "#F6A23D", "#8F7CF6", "#2EB873", "#E15555", "#FFC857"];
  const totalsByTitle = {};
  const daysRaw = Array.from({ length: 7 }).map((_, idx) => {
    const dayStart = new Date(now - (6 - idx) * DAY_MS);
    dayStart.setHours(0, 0, 0, 0);
    const dayEnd = dayStart.getTime() + DAY_MS;
    const label = dayLabels[dayStart.getDay()];
    const stacks = {};
    history.forEach((entry) => {
      if (entry?.kind !== "refuse_spend") return;
      if (!entry?.timestamp || entry.timestamp < dayStart.getTime() || entry.timestamp >= dayEnd) return;
      const resolvedTitle =
        (resolveTemplateTitle &&
          resolveTemplateTitle(entry.meta?.templateId, entry.meta?.title || entry.title)) ||
        null;
      const baseTitle =
        (resolvedTitle ||
          entry.meta?.title ||
          entry.title ||
          entry.meta?.templateId ||
          entry.emoji ||
          entry.id ||
          defaultDeclineTitle)
          .toString()
          .slice(0, 42);
      const stripped = stripEmojis(baseTitle);
      const title = (stripped || baseTitle || defaultDeclineTitle).trim();
      const amount = Math.max(0, Number(entry.meta?.amountUSD) || 0);
      stacks[title] = (stacks[title] || 0) + amount;
      totalsByTitle[title] = (totalsByTitle[title] || 0) + amount;
    });
    const total = Object.values(stacks).reduce((sum, v) => sum + v, 0);
    return { label, stacks, total };
  });
  const sortedTitles = Object.entries(totalsByTitle)
    .sort((a, b) => b[1] - a[1])
    .map(([title]) => title);
  const topTitles = sortedTitles.slice(0, 5);
  const colorMap = {};
  topTitles.forEach((title, idx) => {
    colorMap[title] = palette[idx % palette.length];
  });
  const otherColor = "#F6C16B";
  const days = daysRaw.map((day) => {
    const stacksArray = [];
    const otherSum = Object.entries(day.stacks).reduce((acc, [title, value]) => {
      if (colorMap[title]) {
        stacksArray.push({ title, value, color: colorMap[title] });
        return acc;
      }
      return acc + value;
    }, 0);
    if (otherSum > 0) {
      stacksArray.push({ title: otherLabel, value: otherSum, color: otherColor });
    }
    return { label: day.label, total: day.total, stacks: stacksArray };
  });
  const grandTotal = Object.values(totalsByTitle).reduce((sum, v) => sum + v, 0) || 1;
  const legend = topTitles.map((title, idx) => ({
    id: title,
    label: title,
    value: totalsByTitle[title],
    percent: Math.round((totalsByTitle[title] / grandTotal) * 100),
    color: palette[idx % palette.length],
  }));
  const otherTotal = grandTotal - legend.reduce((sum, item) => sum + item.value, 0);
  if (otherTotal > 0) {
    legend.push({
      id: "other",
      label: otherLabel,
      value: otherTotal,
      percent: Math.max(1, Math.round((otherTotal / grandTotal) * 100)),
      color: otherColor,
    });
  }
  const formatLocal = (usd) => formatCurrency(convertToCurrency(usd || 0, currency), currency);
  return { days, legend, formatLocal };
};

const computeRefuseStreak = (history = []) => {
  if (!Array.isArray(history)) return 0;
  const sorted = [...history]
    .filter((entry) => entry?.timestamp)
    .sort((a, b) => b.timestamp - a.timestamp);
  let streak = 0;
  for (const entry of sorted) {
    if (entry.kind === "refuse_spend") {
      streak += 1;
    } else {
      break;
    }
  }
  return streak;
};

const deriveMoodFromState = (state = createMoodStateForToday(), pendingCount = 0, now = Date.now()) => {
  const events = Array.isArray(state.events) ? state.events : [];
  const filtered = events.filter(
    (event) => event?.timestamp && now - event.timestamp <= MOOD_ACTION_WINDOW_MS
  );
  const counts = filtered.reduce(
    (acc, event) => {
      if (event?.type && acc[event.type] !== undefined) {
        acc[event.type] += 1;
      }
      return acc;
    },
    { save: 0, spend: 0, maybe: 0, dream: 0 }
  );
  const lastInteraction = state.lastInteractionAt || state.lastVisitAt || filtered[0]?.timestamp || 0;
  if (lastInteraction && now - lastInteraction >= MOOD_INACTIVITY_THRESHOLD_MS) {
    return MOOD_IDS.TIRED;
  }
  const candidates = [];
  if (counts.spend >= MOOD_EVENT_THRESHOLD) {
    const timestamp = getLatestEventTimestamp(filtered, "spend");
    if (timestamp) candidates.push({ mood: MOOD_IDS.IMPULSIVE, timestamp });
  }
  if (counts.save >= MOOD_EVENT_THRESHOLD) {
    const timestamp = getLatestEventTimestamp(filtered, "save");
    if (timestamp) candidates.push({ mood: MOOD_IDS.FOCUSED, timestamp });
  }
  if (counts.maybe >= MOOD_EVENT_THRESHOLD) {
    const timestamp = getLatestEventTimestamp(filtered, "maybe");
    if (timestamp) candidates.push({ mood: MOOD_IDS.DOUBTER, timestamp });
  }
  if (counts.dream >= MOOD_DREAM_WISH_THRESHOLD) {
    const timestamp = getLatestEventTimestamp(filtered, "dream");
    if (timestamp) candidates.push({ mood: MOOD_IDS.DREAMER, timestamp });
  }
  if (pendingCount >= MOOD_PENDING_THRESHOLD) {
    candidates.push({ mood: MOOD_IDS.DREAMER, timestamp: now });
  }
  if (candidates.length) {
    candidates.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
    return candidates[0].mood;
  }
  return MOOD_IDS.NEUTRAL;
};

const getImpulseCategoryLabel = (id, language = "en") => {
  const entry = IMPULSE_CATEGORY_DEFS[id];
  if (!entry) return id;
  const localeKey = getShortLanguageKey(language);
  return `${entry.emoji} ${entry[localeKey]}`;
};

const RainOverlay = ({ colors }) => {
  const drops = useMemo(
    () =>
      Array.from({ length: RAIN_DROPS }, (_, index) => ({
        id: index,
        left: Math.random() * SCREEN_WIDTH,
        delay: Math.random() * 800,
        height: 80 + Math.random() * 60,
      })),
    []
  );

  return (
    <View style={styles.rainLayer} pointerEvents="none">
      {drops.map((drop) => (
        <RainDrop key={drop.id} {...drop} colors={colors} />
      ))}
    </View>
  );
};

const RainDrop = ({ left, delay, height, colors }) => {
  const translateY = useRef(new Animated.Value(-120)).current;

  useEffect(() => {
    const loop = Animated.loop(
      Animated.sequence([
        Animated.delay(delay),
        Animated.timing(translateY, {
          toValue: 500,
          duration: 1400,
          useNativeDriver: true,
        }),
        Animated.timing(translateY, {
          toValue: -120,
          duration: 0,
          useNativeDriver: true,
        }),
      ])
    );
    loop.start();
    return () => loop.stop();
  }, [delay, translateY]);

  return (
    <Animated.View
      style={[
        styles.rainDrop,
        {
          left,
          height,
          backgroundColor: colors.muted,
          transform: [{ translateY }],
        },
      ]}
    />
  );
};

const AnimatedTouchableOpacity = Animated.createAnimatedComponent(TouchableOpacity);
const BASE_HORIZONTAL_PADDING = Platform.OS === "android" ? 20 : 30;

if (Platform.OS === "android" && UIManager.setLayoutAnimationEnabledExperimental) {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

const triggerHaptic = (style = Haptics.ImpactFeedbackStyle.Light) => {
  Haptics.impactAsync(style).catch(() => {});
};

const triggerSuccessHaptic = () => {
  Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success).catch(() => {});
};

const convertToCurrency = (valueUSD = 0, currency = activeCurrency) => {
  if (!valueUSD) return 0;
  const rate = CURRENCY_RATES[currency] || 1;
  return valueUSD * rate;
};

const convertFromCurrency = (valueLocal = 0, currency = activeCurrency) => {
  if (!valueLocal) return 0;
  const rate = CURRENCY_RATES[currency] || 1;
  if (!rate) return valueLocal;
  return valueLocal / rate;
};

const POTENTIAL_PUSH_STEP_EUR = 10;
const POTENTIAL_PUSH_STEP_USD = convertFromCurrency(POTENTIAL_PUSH_STEP_EUR, "EUR");
const POTENTIAL_PUSH_STEP_LOCAL_MAP = {
  AED: 10,
  AUD: 10,
  BYN: 10,
  CAD: 10,
  EUR: 10,
  GBP: 10,
  JPY: 1000,
  KZT: 3000,
  KRW: 15000,
  MXN: 100,
  PLN: 10,
  RUB: 1000,
  SAR: 10,
  USD: 10,
  DEFAULT: 10,
};
const POTENTIAL_PUSH_STEP_LOCAL_FALLBACK =
  POTENTIAL_PUSH_STEP_LOCAL_MAP.DEFAULT || POTENTIAL_PUSH_STEP_EUR;
const POTENTIAL_PUSH_MAX_MULTIPLIER = 5;
const POTENTIAL_PUSH_FAST_GAIN_WINDOW_MS = 2 * 60 * 60 * 1000;
const POTENTIAL_PUSH_COOLDOWN_WINDOW_MS = 36 * 60 * 60 * 1000;
const DEFAULT_POTENTIAL_PUSH_STATE = {
  lastStep: 0,
  lastStatus: null,
  baselineKey: null,
  stepMultiplier: 1,
  lastNotifiedAt: 0,
};

const getCurrencyPrecision = (currency = activeCurrency) => {
  if (
    currency === "AED" ||
    currency === "AUD" ||
    currency === "BYN" ||
    currency === "CAD" ||
    currency === "EUR" ||
    currency === "GBP" ||
    currency === "MXN" ||
    currency === "PLN" ||
    currency === "SAR" ||
    currency === "USD"
  )
    return 2;
  return 0;
};

const getCurrencyDisplayPrecision = (currency = activeCurrency) => {
  if (Object.prototype.hasOwnProperty.call(CURRENCY_DISPLAY_PRECISION, currency)) {
    return CURRENCY_DISPLAY_PRECISION[currency];
  }
  return getCurrencyPrecision(currency);
};

const getCurrencyFineStep = (currency = activeCurrency) => {
  if (CURRENCY_FINE_STEPS[currency]) return CURRENCY_FINE_STEPS[currency];
  const precision = getCurrencyPrecision(currency);
  return precision > 0 ? Math.pow(10, -precision) : 1;
};

const roundCurrencyValue = (value = 0, currency = activeCurrency, precisionOverride = null) => {
  const precision =
    typeof precisionOverride === "number" && Number.isFinite(precisionOverride)
      ? precisionOverride
      : getCurrencyPrecision(currency);
  const factor = Math.pow(10, precision);
  if (!Number.isFinite(factor) || factor <= 0) return Number(value) || 0;
  return Math.round(((Number(value) || 0) + Number.EPSILON) * factor) / factor;
};

const snapCurrencyValue = (value = 0, currency = activeCurrency) => {
  const step = CURRENCY_FINE_STEPS[currency];
  if (!step || step <= 0) {
    return roundCurrencyValue(value, currency);
  }
  const snapped = Math.round((Number(value) || 0) / step) * step;
  return roundCurrencyValue(snapped, currency);
};

const getFriendlyDisplayStep = (amount = 0) => {
  const value = Math.abs(amount);
  if (value === 0) return 1;
  if (value < 1) return 0.1;
  if (value < 5) return 0.25;
  if (value < 20) return 1;
  if (value < 50) return 2;
  if (value < 100) return 5;
  if (value < 250) return 10;
  if (value < 1000) return 25;
  if (value < 5000) return 50;
  if (value < 20000) return 100;
  if (value < 100000) return 250;
  return 500;
};

const applyFriendlyDisplayRounding = (value = 0, currency = activeCurrency) => {
  if (!Number.isFinite(value) || value === 0) return value || 0;
  const baseStep = getFriendlyDisplayStep(value);
  const fineStep = getCurrencyFineStep(currency) || 0;
  const step = Math.max(baseStep, fineStep || 0);
  if (!Number.isFinite(step) || step === 0) return value;
  return Math.round(value / step) * step;
};

const formatSampleAmount = (valueUSD, currencyCode) =>
  formatCurrency(convertToCurrency(valueUSD, currencyCode), currencyCode);

const formatNumberInputValue = (value) => {
  if (!Number.isFinite(value)) return "";
  const formatted = value.toFixed(2).replace(/\.?0+$/, "");
  return formatted;
};

const parseNumberInputValue = (value = "") => {
  if (typeof value !== "string") return NaN;
  const normalized = value.replace(/[^\d,.\s]/g, "").replace(",", ".");
  const parsed = parseFloat(normalized);
  return Number.isFinite(parsed) ? parsed : NaN;
};

const getManualInputPrecision = (value = "") => {
  if (typeof value !== "string") return 0;
  const normalized = value.replace(/[^\d,.\s]/g, "").replace(",", ".").trim();
  const [, fraction = ""] = normalized.split(".");
  if (!fraction) return 0;
  const digits = fraction.replace(/\D/g, "");
  return Math.max(0, Math.min(6, digits.length));
};

const formatLatestSavingTimestamp = (timestamp, language = DEFAULT_LANGUAGE) => {
  if (!timestamp) return null;
  try {
    const locale = getFormatLocale(language);
    const date = new Date(timestamp);
    const dateLabel = date.toLocaleDateString(locale, { day: "numeric", month: "short" });
    const timeLabel = date.toLocaleTimeString(locale, {
      hour: "2-digit",
      minute: "2-digit",
      hour12: false,
    });
    return `${dateLabel}, ${timeLabel}`;
  } catch {
    return null;
  }
};

const normalizeEmojiValue = (value, fallback) => {
  const trimmed = (value || "").trim();
  if (!trimmed) return fallback;
  const firstGrapheme = Array.from(trimmed)[0];
  return firstGrapheme || fallback;
};

const limitEmojiInput = (value) => {
  if (!value) return "";
  const trimmed = value.trim();
  const firstGrapheme = Array.from(trimmed)[0];
  return firstGrapheme || "";
};

const getPersonaPreset = (personaId) => PERSONA_PRESETS[personaId] || PERSONA_PRESETS[DEFAULT_PERSONA_ID];

const createPersonaTemptation = (preset) => {
  if (!preset?.habit) return null;
  const habit = preset.habit;
  return {
    id: `persona_${preset.id}`,
    emoji: habit.emoji || preset.emoji || "‚ú®",
    image: habit.image,
    color: habit.color || "#FFF5E6",
    categories: habit.categories || ["habit"],
    basePriceUSD: habit.basePriceUSD || 5,
    priceUSD: habit.basePriceUSD || 5,
    title: habit.title,
    description: habit.description,
    audience: preset.audience || habit.audience || null,
  };
};

const parseAmountValue = (value) => {
  if (value === null || value === undefined) return 0;
  if (typeof value === "number") return Number.isFinite(value) ? value : 0;
  if (typeof value === "string") {
    const parsed = Number(value.replace(",", "."));
    return Number.isFinite(parsed) ? parsed : 0;
  }
  return 0;
};

const resolveCustomPriceUSD = (customSpend, fallbackCurrency = DEFAULT_PROFILE.currency) => {
  const direct = parseAmountValue(customSpend?.amountUSD);
  if (direct > 0) return direct;
  const local = parseAmountValue(customSpend?.amount ?? customSpend?.amountLocal ?? customSpend?.price);
  if (local > 0) {
    const currencyCode = customSpend?.currency || fallbackCurrency || DEFAULT_PROFILE.currency;
    return convertFromCurrency(local, currencyCode);
  }
  return 0;
};

const buildCustomTemptationDescription = (gender = "none") => {
  const isFemale = gender === "female";
  const isMale = gender === "male";
  let ru = "–≠—Ç–æ –∏—Å–∫—É—à–µ–Ω–∏–µ —Ç—ã –¥–æ–±–∞–≤–∏–ª(–∞) —Å–∞–º(–∞). –û—Ç—Å–ª–µ–∂–∏–≤–∞–π –µ–≥–æ –∏ –ø–æ–±–µ–∂–¥–∞–π —á–∞—â–µ.";
  if (isMale) {
    ru = "–≠—Ç–æ –∏—Å–∫—É—à–µ–Ω–∏–µ —Ç—ã –¥–æ–±–∞–≤–∏–ª —Å–∞–º. –û—Ç—Å–ª–µ–∂–∏–≤–∞–π –µ–≥–æ –∏ –ø–æ–±–µ–∂–¥–∞–π —á–∞—â–µ.";
  } else if (isFemale) {
    ru = "–≠—Ç–æ –∏—Å–∫—É—à–µ–Ω–∏–µ —Ç—ã –¥–æ–±–∞–≤–∏–ª–∞ —Å–∞–º–∞. –û—Ç—Å–ª–µ–∂–∏–≤–∞–π –µ–≥–æ –∏ –ø–æ–±–µ–∂–¥–∞–π —á–∞—â–µ.";
  }
  const en = "You added this temptation yourself. Track it and beat it more often.";
  const esBase = "A√±adiste esta tentaci√≥n t√∫ misma. Reg√≠strala y sup√©rala m√°s seguido.";
  const es = isMale
    ? "A√±adiste esta tentaci√≥n t√∫ mismo. Reg√≠strala y sup√©rala m√°s seguido."
    : esBase;
  const fr = "Tu as ajout√© cette tentation toi-m√™me. Suis-la et bats-la plus souvent.";
  return {
    ru,
    en,
    es,
    fr,
  };
};

const createCustomHabitTemptation = (customSpend, fallbackCurrency, gender = "none") => {
  if (!customSpend?.title) return null;
  const price = resolveCustomPriceUSD(customSpend, fallbackCurrency);
  if (!price) return null;
  const title = customSpend.title;
  const description = buildCustomTemptationDescription(gender);
  const impulseCategory =
    customSpend.impulseCategory && IMPULSE_CATEGORY_DEFS[customSpend.impulseCategory]
      ? customSpend.impulseCategory
      : null;
  const categories = ["habit", "custom"];
  if (impulseCategory) {
    categories.push(impulseCategory);
  }
  return {
    id: customSpend.id || "custom_habit",
    emoji: customSpend.emoji || "üí°",
    color: "#FFF5E6",
    categories,
    basePriceUSD: price,
    priceUSD: price,
    title: {
      ru: title,
      en: title,
      es: title,
      fr: title,
    },
    description,
    impulseCategoryOverride: impulseCategory,
  };
};

const hasValidCustomPrice = (entry) => {
  if (!entry || typeof entry !== "object") return false;
  const price = Number(entry.priceUSD);
  if (Number.isFinite(price) && price > 0) return true;
  const basePrice = Number(entry.basePriceUSD);
  return Number.isFinite(basePrice) && basePrice > 0;
};

const normalizeCustomTemptationEntry = (
  entry,
  fallbackCurrency = DEFAULT_PROFILE.currency
) => {
  if (!entry || typeof entry !== "object") return null;
  const genderValue = entry?.gender || "none";
  if (hasValidCustomPrice(entry)) {
    const entryCategory =
      entry.impulseCategoryOverride || entry.impulseCategory || null;
    const normalizedCategory =
      entryCategory && IMPULSE_CATEGORY_DEFS[entryCategory] ? entryCategory : null;
    return {
      ...entry,
      description: buildCustomTemptationDescription(genderValue),
      impulseCategoryOverride: normalizedCategory,
    };
  }
  const rebuilt = createCustomHabitTemptation(entry, fallbackCurrency, genderValue);
  if (!rebuilt) return null;
  const merged = { ...rebuilt, ...entry };
  merged.priceUSD = rebuilt.priceUSD;
  merged.basePriceUSD = rebuilt.basePriceUSD;
  merged.description = rebuilt.description;
  const entryCategory =
    entry.impulseCategoryOverride || entry.impulseCategory || rebuilt.impulseCategoryOverride;
  merged.impulseCategoryOverride =
    entryCategory && IMPULSE_CATEGORY_DEFS[entryCategory] ? entryCategory : rebuilt.impulseCategoryOverride || null;
  return merged;
};

const matchesGenderAudience = (card, gender = "none") => {
  if (!card || !card.audience || !gender || gender === "none") return true;
  const list = Array.isArray(card.audience) ? card.audience : [card.audience];
  return list.includes(gender);
};

const buildPersonalizedTemptations = (profile, baseList = DEFAULT_TEMPTATIONS) => {
  const preset = getPersonaPreset(profile?.persona);
  const customFirst = createCustomHabitTemptation(
    profile?.customSpend,
    profile?.currency,
    profile?.gender
  );
  const personaCard = createPersonaTemptation(preset);
  const gender = profile?.gender || "none";
  const seen = new Set();
  const result = [];
  const pushIfVisible = (card) => {
    if (!card || seen.has(card.id)) return;
    if (!matchesGenderAudience(card, gender)) return;
    seen.add(card.id);
    result.push(card);
  };

  // 1) –ö–∞—Å—Ç–æ–º–Ω–∞—è –∫–∞—Ä—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤—Å–µ–≥–¥–∞ –ø–µ—Ä–≤–∞—è, –µ—Å–ª–∏ –µ—Å—Ç—å.
  pushIfVisible(customFirst);
  // 2) –ö–∞—Ä—Ç–∞ –ø–µ—Ä—Å–æ–Ω—ã - —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –∫–∞—Å—Ç–æ–º–Ω–æ–π –∏–ª–∏ –ø–µ—Ä–≤–æ–π, –µ—Å–ª–∏ –∫–∞—Å—Ç–æ–º–Ω–æ–π –Ω–µ—Ç.
  pushIfVisible(personaCard);

  // –û—Å—Ç–∞–ª—å–Ω—ã–µ, –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ —Ü–µ–Ω–µ.
  const pool = [...baseList].filter((item) => item && !seen.has(item.id));
  const sortedPool = pool
    .filter((item) => matchesGenderAudience(item, gender))
    .sort((a, b) => {
      const priceA = a.priceUSD ?? a.basePriceUSD ?? Number.POSITIVE_INFINITY;
      const priceB = b.priceUSD ?? b.basePriceUSD ?? Number.POSITIVE_INFINITY;
      return priceA - priceB;
    });
  return [...result, ...sortedPool];
};

const mergeInteractionStatMaps = (base = {}, incoming = {}) => {
  const result = { ...(base || {}) };
  Object.entries(incoming || {}).forEach(([templateId, stats]) => {
    if (!stats) return;
    const current = result[templateId] || { saveCount: 0, spendCount: 0, lastInteractionAt: 0 };
    const saveCount = (current.saveCount || 0) + (stats.saveCount || 0);
    const spendCount = (current.spendCount || 0) + (stats.spendCount || 0);
    const lastInteractionAt = Math.max(current.lastInteractionAt || 0, stats.lastInteractionAt || 0);
    result[templateId] = {
      saveCount,
      spendCount,
      lastInteractionAt,
    };
  });
  return result;
};

const useFadeIn = () => {
  const fade = useRef(new Animated.Value(0)).current;
  useEffect(() => {
    Animated.timing(fade, {
      toValue: 1,
      duration: 350,
      useNativeDriver: true,
    }).start();
  }, [fade]);
  return fade;
};

const FEED_FREQUENT_PIN_LIMIT = 5;

const TRANSLATIONS = {
  ru: {
    appTagline: "–í–∏—Ç—Ä–∏–Ω–∞ –∏—Å–∫—É—à–µ–Ω–∏–π –∫–æ—Ç–æ—Ä–∞—è –ø–æ–º–æ–≥–∞–µ—Ç –∫–æ–ø–∏—Ç—å",
    tamagotchiHungryBubble: "üêü",
    tamagotchiFoodMenuTitle: "–ú–µ–Ω—é –ê–ª–º–∏",
    tamagotchiFoodBoostLabel: "+{{percent}}% —Å—ã—Ç–æ—Å—Ç–∏",
    tamagotchiFoodWantLabel: "–•–æ—á—É",
    tamagotchiSkinTitle: "–û–±—Ä–∞–∑ –ê–ª–º–∏",
    tamagotchiSkinSubtitle: "–ù–æ–≤—ã–π —Å—Ç–∏–ª—å –ê–ª–º–∏ –º–æ—Ç–∏–≤–∏—Ä—É–µ—Ç —ç–∫–æ–Ω–æ–º–∏—Ç—å –ø–æ-–Ω–æ–≤–æ–º—É",
    tamagotchiSkinCurrent: "–ê–∫—Ç–∏–≤–Ω–æ",
    tamagotchiSkinUnlockTitle: "Almost —Ç–æ–ª—å–∫–æ –∑–∞–ø—É—Å—Ç–∏–ª—Å—è üöÄ",
    tamagotchiSkinUnlockDescription:
      "–ü–æ–º–æ–≥–∏ –Ω–∞–º —Å—Ç–∞—Ç—å –ª—É—á—à–µ: –æ—Ç–ø—Ä–∞–≤—å –æ—Ç–∑—ã–≤ –Ω–∞ {{email}} –∏ —Ä–∞–∑–±–ª–æ–∫–∏—Ä—É–π –≤—Å–µ –æ–±—Ä–∞–∑—ã.",
    tamagotchiSkinUnlockButton: "–ù–∞–ø–∏—Å–∞—Ç—å –æ—Ç–∑—ã–≤ –∏ –æ—Ç–∫—Ä—ã—Ç—å —Å–∫–∏–Ω—ã",
    tamagotchiSkinLockedBadge: "–ó–∞–∫—Ä—ã—Ç–æ",
    tamagotchiName: "–ê–ª–º–∏",
    tamagotchiFullnessLabel: "–°—ã—Ç–æ—Å—Ç—å",
    tamagotchiCoinsLabel: "–ú–æ–Ω–µ—Ç–∫–∏",
    tamagotchiFedAtLabel: "–ü–æ–∫–æ—Ä–º–ª–µ–Ω",
    tamagotchiAwaitingFirstCoin: "–ê–ª–º–∏ –∂–¥—ë—Ç –ø–µ—Ä–≤—É—é –º–æ–Ω–µ—Ç–∫—É",
    tamagotchiFullMessage: "–ê–ª–º–∏ —Å—ã—Ç–∞ –Ω–∞ 100%. –í–µ—Ä–Ω–∏—Å—å –ø–æ–∑–∂–µ, –∫–æ–≥–¥–∞ –ø–æ—è–≤–∏—Ç—Å—è –≥–æ–ª–æ–¥.",
    tamagotchiEarnCoinsHint: "–ü–æ–ø–æ–ª–Ω—è–π –º–æ–Ω–µ—Ç–∫–∏ —á–µ—Ä–µ–∑ –æ—Ç–∫–∞–∑—ã, —É—Ä–æ–≤–Ω–∏ –∏ –Ω–∞–≥—Ä–∞–¥—ã.",
    tamagotchiNeedCoinsMessage: "–ù—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º {{cost}} –º–æ–Ω–µ—Ç –Ω–∞ {{emoji}}.",
    tamagotchiPartyNeedCoinsMessage: "–ù—É–∂–Ω–æ {{amount}} —Å–∏–Ω–∏—Ö –º–æ–Ω–µ—Ç –Ω–∞ –≤–µ—á–µ—Ä–∏–Ω–∫—É.",
    tamagotchiPartyButtonLabel: "–í–µ—á–µ—Ä–∏–Ω–∫–∞ √ó{{cost}}",
    tamagotchiFullHint: "–ê–ª–º–∏ —Å—ã—Ç, –ø–æ–∫–æ—Ä–º–∏ –ø–æ–∑–∂–µ.",
    tamagotchiSkinFeedbackSubject: "–û—Ç–∑—ã–≤ –¥–ª—è Almost",
    tamagotchiSkinFeedbackBody: "–ü—Ä–∏–≤–µ—Ç, Almost! –î–µ–ª—é—Å—å —Å–≤–æ–∏–º–∏ –≤–ø–µ—á–∞—Ç–ª–µ–Ω–∏—è–º–∏ –æ–± –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏:\\n\\n",
    heroAwaiting: "–í –ª–∏—Å—Ç–µ –∂–µ–ª–∞–Ω–∏–π",
    heroSpendLine: {
      female: "–ü–æ—Å–ª–µ–¥–Ω—è—è —ç–∫–æ–Ω–æ–º–∏—è: ¬´{{title}}¬ª.",
      male: "–ü–æ—Å–ª–µ–¥–Ω—è—è —ç–∫–æ–Ω–æ–º–∏—è: ¬´{{title}}¬ª.",
      none: "–ü–æ—Å–ª–µ–¥–Ω—è—è —ç–∫–æ–Ω–æ–º–∏—è: ¬´{{title}}¬ª.",
    },
    heroSpendRecentTitle: "–ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è:",
    heroSpendFallback: {
      female: "–ö–∞–∂–¥—ã–π –æ—Ç–∫–∞–∑ –ø—Ä–∏–±–ª–∏–∂–∞–µ—Ç –∫ —Ü–µ–ª–∏. –ü—Ä–æ–¥–æ–ª–∂–∞–π —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å –ø–æ–±–µ–¥—ã.",
      male: "–ö–∞–∂–¥—ã–π –æ—Ç–∫–∞–∑ –ø—Ä–∏–±–ª–∏–∂–∞–µ—Ç –∫ —Ü–µ–ª–∏. –ü—Ä–æ–¥–æ–ª–∂–∞–π —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å –ø–æ–±–µ–¥—ã.",
      none: "–ö–∞–∂–¥—ã–π –æ—Ç–∫–∞–∑ –ø—Ä–∏–±–ª–∏–∂–∞–µ—Ç –∫ —Ü–µ–ª–∏. –ü—Ä–æ–¥–æ–ª–∂–∞–π —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å –ø–æ–±–µ–¥—ã.",
    },
    heroEconomyContinues: "–≠–∫–æ–Ω–æ–º–∏—è –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è.",
    heroExpand: "–ü–æ–∫–∞–∑–∞—Ç—å –¥–µ—Ç–∞–ª–∏",
    heroCollapse: "–°–∫—Ä—ã—Ç—å –¥–µ—Ç–∞–ª–∏",
    heroDailyTitle: "–ù–µ–¥–µ–ª—è —ç–∫–æ–Ω–æ–º–∏–∏/—Ç—Ä–∞—Ç",
    heroDailyEmpty: "–ü–æ–∫–∞ –ø—É—Å—Ç–æ, –ø–æ–ø—Ä–æ–±—É–π –æ—Ç–∫–∞–∑–∞—Ç—å —Å–µ–±–µ —Ö–æ—Ç—è –±—ã —Ä–∞–∑.",
    defaultDeclineLabel: "–û—Ç–∫–∞–∑",
    defaultWishTitle: "–ü—Ä–∏–≤—ã—á–∫–∞",
    heroWeeklySavingsDelta: "–°–±–µ—Ä–µ–∂–µ–Ω–∏—è",
    heroWeeklySpendingDelta: "–¢—Ä–∞—Ç—ã",
    feedEmptyTitle: "–§–∏–ª—å—Ç—Ä –ø—É—Å—Ç",
    feedEmptySubtitle: "–ü–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥–æ–π —Ç–µ–≥ –∏–ª–∏ –æ–±–Ω–æ–≤–∏ –∫–∞—Ç–∞–ª–æ–≥",
    buyNow: "–û–ø–ª–∞—Ç–∏—Ç—å —á–µ—Ä–µ–∑ {{pay}}",
    addToCart: "–û—Ç–ª–æ–∂–∏—Ç—å –∏ –ø–æ–¥—É–º–∞—Ç—å",
    buyExternal: "–ü–µ—Ä–µ–π—Ç–∏ –∫ —Ç–æ–≤–∞—Ä—É",
    cartTitle: "–ö–æ—Ä–∑–∏–Ω–∞",
    cartEmptyTitle: "–ì—Ä—É—Å—Ç–Ω–æ –±–µ–∑ —Ç–≤–æ–∏—Ö —Ö–æ—Ç–µ–ª–æ–∫",
    cartEmptySubtitle: "–î–æ–±–∞–≤—å —Ç–æ, —á—Ç–æ —Ä–µ–∞–ª—å–Ω–æ –Ω—É–∂–Ω–æ: –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—é –Ω—Ä–∞–≤–∏—Ç—Å—è —Å–ø–∞—Å–∞—Ç—å –±—é–¥–∂–µ—Ç",
    buyLabel: "–í–∑—è—Ç—å",
    buyAllLabel: "–û—Ñ–æ—Ä–º–∏—Ç—å –≤—Å—ë –∏ —ç–∫–æ–Ω–æ–º–∏—Ç—å",
    totalLabel: "–°—É–º–º–∞",
    cartRemove: "–£–¥–∞–ª–∏—Ç—å",
    wishlistTitle: "–ú–æ–∏ —Ü–µ–ª–∏",
    wishlistEmptyTitle: "–ü–æ–∫–∞ –Ω–µ—Ç —Ü–µ–ª–µ–π",
    wishlistEmptySubtitle: "–î–æ–±–∞–≤—å –º–µ—á—Ç—É –∏–∑ –ª–µ–Ω—Ç—ã –∏ –Ω–∞—á–∏–Ω–∞–π –∫–æ–ø–∏—Ç—å –≤ —Å–≤–æ—ë–º —Ç–µ–º–ø–µ",
    wishlistTab: "–¶–µ–ª–∏",
    wishlistProgress: "{{current}} –∏–∑ {{target}}",
    wishlistSavedHint: "–°–∫–æ–ª—å–∫–æ –Ω—É–∂–Ω–æ –Ω–∞–∫–æ–ø–∏—Ç—å",
    wishlistSaveProgress: "–û–±–Ω–æ–≤–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å",
    wishlistSetActive: "–°–¥–µ–ª–∞—Ç—å –∞–∫—Ç–∏–≤–Ω–æ–π",
    wishlistActive: "–ê–∫—Ç–∏–≤–Ω–∞—è —Ü–µ–ª—å",
    wishlistRemove: "–£–±—Ä–∞—Ç—å",
    wishlistRemoveConfirm: "–£–±—Ä–∞—Ç—å —ç—Ç—É —Ö–æ—Ç–µ–ª–∫—É?",
    wishlistDoneLabel: "–ì–æ—Ç–æ–≤–æ",
    wishlistSummary: "–í—Å–µ–≥–æ —Ü–µ–ª–µ–π –Ω–∞ {{amount}}",
    freeDayButton: "–ë–µ—Å–ø–ª–∞—Ç–Ω—ã–π –¥–µ–Ω—å",
    freeDayLocked: "–ü–æ—Å–ª–µ 18:00",
    freeDayBlocked: "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ",
    freeDayStatusAvailable: "–ó–∞–ø–∏—Å–∞—Ç—å",
    freeDayStatusLogged: "–ó–∞–ø–∏—Å–∞–Ω–æ",
    freeDayLoggedToday: "–ó–∞–ø–∏—Å–∞–Ω–æ",
    freeDayConfirm: "–£–¥–∞–ª–æ—Å—å –ø—Ä–æ–∂–∏—Ç—å –¥–µ–Ω—å –±–µ–∑ –ª–∏—à–Ω–∏—Ö —Ç—Ä–∞—Ç?",
    freeDayCongrats: "–°–µ—Ä–∏—è {{days}} –¥–Ω—è(–µ–π)! –û—Ç–ª–∏—á–Ω—ã–π —Ñ–æ–∫—É—Å.",
    freeDayMilestone: "–°–µ—Ä–∏—è {{days}} –¥–Ω–µ–π! –ù–æ–≤—ã–π —Ç–∏—Ç—É–ª!",
    freeDayCardTitle: "–°–µ—Ä–∏—è –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –¥–Ω–µ–π",
    freeDayActiveLabel: "–°–µ—Ä–∏—è {{days}} –¥–Ω—è",
    freeDayInactiveLabel: "–û—Ç–º–µ—Ç—å –¥–µ–Ω—å –±–µ–∑ —Ç—Ä–∞—Ç",
    freeDayCurrentLabel: "–¢–µ–∫—É—â–∞—è",
    freeDayBestLabel: "–õ—É—á—à–∞—è",
    freeDayTotalShort: "–í—Å–µ–≥–æ",
    freeDayWeekTitle: "–≠—Ç–∞ –Ω–µ–¥–µ–ª—è",
    freeDayExpand: "–ü–æ–∫–∞–∑–∞—Ç—å –¥–µ—Ç–∞–ª–∏",
    freeDayCollapse: "–°–∫—Ä—ã—Ç—å",
    freeDayTotalLabel: "–í—Å–µ–≥–æ: {{total}}",
    freeDayRescueTitle: "–ü—Ä–æ–ø—É—â–µ–Ω –¥–µ–Ω—å?",
    freeDayRescueSubtitle: "–ü–æ—Ç—Ä–∞—Ç—å {{cost}} –∑–¥–æ—Ä–æ–≤—å—è, —á—Ç–æ–±—ã —Å–µ—Ä–∏—è –∂–∏–ª–∞.",
    freeDayRescueButton: "–°–ø–∞—Å—Ç–∏ —Å–µ—Ä–∏—é",
    freeDayRescuePillLabel: "–°–ø–∞—Å—Ç–∏ √ó{{count}}",
    freeDayRescueNeedHealth: "–ù—É–∂–Ω–æ {{cost}} –∑–¥–æ—Ä–æ–≤—å—è",
    freeDayRescueNeedTime: "–î–æ—Å—Ç—É–ø–Ω–æ –ø–æ—Å–ª–µ 18:00",
    freeDayRescueOverlay: "–°–µ—Ä–∏—è —Å–ø–∞—Å–µ–Ω–∞",
    freeDayCoinReward: "–ë–µ—Å–ø–ª–∞—Ç–Ω—ã–π –¥–µ–Ω—å: +{{coins}} —Å–∏–Ω–∏–µ –º–æ–Ω–µ—Ç—ã.",
    freeDayCoinRewardStreak: "üî• –°–µ—Ä–∏—è {{days}} –¥–Ω—è(–µ–π): –µ—â—ë +{{coins}} —Å–∏–Ω–∏–µ –º–æ–Ω–µ—Ç—ã.",
    impulseCardTitle: "–ò–º–ø—É–ª—å—Å-–∫–∞—Ä—Ç–∞",
    impulseCardSubtitle: "–§–∏–∫—Å–∏—Ä—É–µ–º, –≥–¥–µ –∏—Å–∫—É—à–µ–Ω–∏—è —á–∞—â–µ –≤—Å–µ–≥–æ –ø–æ–±–µ–∂–¥–∞—é—Ç –∏–ª–∏ –ø—Ä–æ–∏–≥—Ä—ã–≤–∞—é—Ç.",
    impulseLoseLabel: "–ß–∞—â–µ —Å–¥–∞—ë—à—å—Å—è",
    impulseLoseCopy: "{{temptation}} —á–∞—â–µ —Ü–µ–ø–ª—è–µ—Ç –≤ –æ–∫–Ω–æ {{time}}.",
    impulseLoseEmpty: "–°–ª–∞–±—ã—Ö –∑–æ–Ω –ø–æ–∫–∞ –Ω–µ—Ç.",
    impulseWinLabel: "–ß–∞—â–µ –ø–æ–±–µ–∂–¥–∞–µ—à—å",
    impulseWinCopy: "–ù–∞ {{temptation}} —á–∞—â–µ –≤—Å–µ–≥–æ –æ—Ç–∫–∞–∑—ã–≤–∞–µ—à—å —Å–µ–±–µ –≤ {{time}}.",
    impulseWinEmpty: "–ü–æ–∫–∞ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ –ø–æ–±–µ–¥–∞—Ö - –ø–æ–ø—Ä–æ–±—É–π –Ω–∞–∂–∞—Ç—å ¬´–∫–æ–ø–∏—Ç—å¬ª.",
    impulseTrendLabel: "–ë–æ–ª—å—à–µ –≤—Å–µ–≥–æ –∏–º–ø—É–ª—å—Å–æ–≤ –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {{category}}",
    impulseCategorySave: "–°–ø–∞—Å–µ–Ω–∏—è: {{count}}",
    impulseCategorySpend: "–°—Ä—ã–≤—ã: {{count}}",
    impulseAnytimeLabel: "–ª—é–±–æ–µ –≤—Ä–µ–º—è",
    impulseExpand: "–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å",
    impulseCollapse: "–°–∫—Ä—ã—Ç—å –∫–∞—Ä—Ç—É",
    impulseAlertTitle: "–ó–æ–Ω–∞ –∏–º–ø—É–ª—å—Å–∞",
    impulseAlertMessage:
      "–¢—ã –≤ –∑–æ–Ω–µ –∏–º–ø—É–ª—å—Å–∏–≤–Ω—ã—Ö —Ç—Ä–∞—Ç –Ω–∞ {{temptation}} ({{window}}). –û—Ç–∫–∞–∂–∏—Å—å –∏ –æ—Ç–ø—Ä–∞–≤—å {{amount}} –≤ –∫–æ–ø–∏–ª–∫—É!",
    impulseNotificationTitle: "Almost –∑–∞–º–µ—Ç–∏–ª –∏–º–ø—É–ª—å—Å: ¬´{{temptation}}¬ª",
    impulseNotificationBody: "–í —ç—Ç–æ –≤—Ä–µ–º—è —Ç—ã –æ–±—ã—á–Ω–æ —Ç—Ä–∞—Ç–∏—à—å—Å—è. –°–¥–µ–ª–∞–π –ø–∞—É–∑—É –∏ –æ—Ç–ø—Ä–∞–≤—å {{amount}} –≤ Almost.",
    impulseAlertBadgeLabel: "—É–º–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ",
    impulseAlertWindowLabel: "–ü–∏–∫ –∏–º–ø—É–ª—å—Å–∞",
    impulseAlertAmountLabel: "–°—É–º–º–∞ —Ä–∏—Å–∫–∞",
    impulseAlertButtonLabel: "–î–µ—Ä–∂–∞—Ç—å –∫—É—Ä—Å",
    impulseCategoryLabel: "–ö–∞—Ç–µ–≥–æ—Ä–∏—è –∏–º–ø—É–ª—å—Å–∞",
    focusDigestPositiveTitle: "–î–µ—Ä–∂–∏—à—å –∫—É—Ä—Å!",
    focusDigestPositiveBody:
      "–¢—ã —á–∞—â–µ –æ—Ç–∫–∞–∑—ã–≤–∞–µ—à—å—Å—è, —á–µ–º —Ç—Ä–∞—Ç–∏—à—å.\n–°–∏–ª—å–Ω–∞—è —Å—Ç–æ—Ä–æ–Ω–∞: ¬´{{strong}}¬ª.\n–°–ª–∞–±–∞—è —Å—Ç–æ—Ä–æ–Ω–∞: ¬´{{weak}}¬ª.",
    focusDigestNegativeTitle: "–í–Ω–∏–º–∞–Ω–∏–µ –∫ —Ä–∞—Å—Ö–æ–¥–∞–º",
    focusDigestNegativeBody:
      "–¢—Ä–∞—Ç —Å—Ç–∞–ª–æ –±–æ–ª—å—à–µ.\n–ì–ª–∞–≤–Ω–∞—è —Ç—Ä–∞—Ç–∞: ¬´{{weak}}¬ª. –°—Ñ–æ–∫—É—Å–∏—Ä—É–π—Å—è –Ω–∞ –Ω–µ–π.",
    focusDigestStrongLabel: "–°–∏–ª—å–Ω–∞—è —Å—Ç–æ—Ä–æ–Ω–∞",
    focusDigestWeakLabel: "–°–ª–∞–±–∞—è —Å—Ç–æ—Ä–æ–Ω–∞",
    focusDigestButton: "–°—Ñ–æ–∫—É—Å–∏—Ä–æ–≤–∞—Ç—å—Å—è",
    focusDigestDismiss: "–ü–æ–∑–∂–µ",
    focusDigestMissing: "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö",
    focusBadgeLabel: "–§–æ–∫—É—Å",
    focusPromptTitle: "–í–æ–∑—å–º–∏ –ø–æ–¥ –∫–æ–Ω—Ç—Ä–æ–ª—å",
    focusPromptBody: "–¢—ã –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑ –ø–æ–¥–¥–∞–ª–∞—Å—å –Ω–∞ ¬´{{title}}¬ª. –°–¥–µ–ª–∞–µ–º –µ–≥–æ —Ñ–æ–∫—É—Å–æ–º?",
    focusVictoryReward: "–§–æ–∫—É—Å ¬´{{title}}¬ª –ø–æ–±–µ–∂–¥—ë–Ω! +3 –∑–µ–ª—ë–Ω—ã—Ö –º–æ–Ω–µ—Ç—ã",
    focusRewardTitle: "–§–æ–∫—É—Å –ø–æ–±–µ–∂–¥—ë–Ω!",
    focusRewardSubtitle: "–¢—ã —Ç—Ä–∏–∂–¥—ã –æ—Ç–∫–∞–∑–∞–ª–∞—Å—å –æ—Ç ¬´{{title}}¬ª. +{{amount}} –∑–µ–ª—ë–Ω—ã—Ö –º–æ–Ω–µ—Ç.",
    dailyReflectionReminderTitle: "–í–µ—á–µ—Ä–Ω–∏–π —á–µ–∫-–∏–Ω Almost",
    dailyReflectionReminderBody:
      "–î–æ –ø–æ–ª—É–Ω–æ—á–∏ {{time}}. –ó–∞–ø–∏—à–∏ —Ç—Ä–∞—Ç—É –∏–ª–∏ —ç–∫–æ–Ω–æ–º–∏—é - —Ç–∞–∫ —É–º–Ω—ã–µ –ø–æ–¥—Å–∫–∞–∑–∫–∏ –æ—Å—Ç–∞–Ω—É—Ç—Å—è —Ç–æ—á–Ω—ã–º–∏.",
    pendingTab: "–î—É–º–∞–µ–º",
    pendingTitle: "–î—É–º–∞–µ–º",
    pendingEmptyTitle: "–í ¬´–¥—É–º–∞–µ–º¬ª –ø—É—Å—Ç–æ",
    pendingEmptySubtitle: "–û—Ç–ø—Ä–∞–≤–ª—è–π —Ü–µ–ª–∏ –≤ ¬´–¥—É–º–∞–µ–º¬ª, –∏ –º—ã –≤–µ—Ä–Ω—ë–º—Å—è —á–µ—Ä–µ–∑ 14 –¥–Ω–µ–π.",
    pendingDaysLeft: "–û—Å—Ç–∞–ª–æ—Å—å {{days}} –¥.",
    pendingExpired: "–°—Ä–æ–∫ –≤—ã—à–µ–ª",
    pendingDueToday: "–†–µ—à–∏ —Å–µ–≥–æ–¥–Ω—è",
    pendingActionWant: "–ù–∞—á–∞—Ç—å –∫–æ–ø–∏—Ç—å",
    pendingActionDecline: "–°—ç–∫–æ–Ω–æ–º–∏—Ç—å",
    pendingNotificationTitle: "Almost: –ø–æ—Ä–∞ —Ä–µ—à–∏—Ç—å ¬´{{title}}¬ª",
    pendingNotificationBody: {
      female: "–î–≤–µ –Ω–µ–¥–µ–ª–∏ –ø—Ä–æ—à–ª–∏. –ù–∞—á–Ω—ë–º –∫–æ–ø–∏—Ç—å –Ω–∞ ¬´{{title}}¬ª –∏–ª–∏ –æ—Ç–ø—É—Å—Ç–∏–º –µ–≥–æ?",
      male: "–î–≤–µ –Ω–µ–¥–µ–ª–∏ –ø—Ä–æ—à–ª–∏. –ù–∞—á–Ω—ë–º –∫–æ–ø–∏—Ç—å –Ω–∞ ¬´{{title}}¬ª –∏–ª–∏ –æ—Ç–ø—É—Å—Ç–∏–º –µ–≥–æ?",
      none: "–î–≤–µ –Ω–µ–¥–µ–ª–∏ –ø—Ä–æ—à–ª–∏. –ß—Ç–æ –¥–µ–ª–∞–µ–º —Å ¬´{{title}}¬ª - –∫–æ–ø–∏–º –∏–ª–∏ –æ—Ç–ø—É—Å–∫–∞–µ–º?",
    },
    pendingAdded: "–î–æ–±–∞–≤–ª–µ–Ω–æ –≤ ¬´–¥—É–º–∞–µ–º¬ª. –ù–∞–ø–æ–º–Ω–∏–º –≤–æ–≤—Ä–µ–º—è.",
    pendingDeleteConfirm: "–£–±—Ä–∞—Ç—å —ç—Ç—É —Ö–æ—Ç–µ–ª–∫—É –∏–∑ ¬´–¥—É–º–∞–µ–º¬ª?",
    pendingCustomError: "–£–∫–∞–∂–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∏ —Å—Ç–æ–∏–º–æ—Å—Ç—å —Ö–æ—Ç–µ–ª–∫–∏.",
    feedTab: "–õ–µ–Ω—Ç–∞",
    profileTab: "–ü—Ä–æ—Ñ–∏–ª—å",
    payButton: "–û–ø–ª–∞—Ç–∏—Ç—å",
    cartOverlay: "–≠–∫–æ–Ω–æ–º–∏—è –ø–æ–ø–æ–ª–Ω–µ–Ω–∞",
    purchasesTitle: "–ù–∞–≥—Ä–∞–¥—ã",
    purchasesSubtitle: "–°–ª–µ–¥–∏ –∑–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è–º–∏ –∏ –Ω–∞–ø–æ–º–∏–Ω–∞–π —Å–µ–±–µ, –∑–∞—á–µ–º –∫–æ–ø–∏—à—å",
    progressLabel: "–£—Ä–æ–≤–µ–Ω—å –æ—Å–æ–∑–Ω–∞–Ω–Ω–æ—Å—Ç–∏",
    progressGoal: "{{current}} / {{goal}}",
    progressHint: "–û—Å—Ç–∞–ª–æ—Å—å {{amount}} –¥–æ —Ç–∏—Ç—É–ª–∞ ‚Äò–≥–µ—Ä–æ–π —Ñ–∏–Ω–∞–Ω—Å–æ–≤–æ–≥–æ –¥–∑–µ–Ω–∞‚Äô",
    emptyPurchases: "–ü–æ–∫–∞ —á–∏—Å—Ç–æ. –ó–Ω–∞—á–∏—Ç, —Ç—ã –≤ –ø–ª—é—Å–µ",
    profileEdit: "–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å",
    profileSave: "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å",
    profileCancel: "–û—Ç–º–µ–Ω–∞",
    profileOk: "–æ–∫",
    profileJoinDate: "–í –æ—Å–æ–∑–Ω–∞–Ω–Ω–æ–π —ç–∫–æ–Ω–æ–º–∏–∏ —Å {{date}}",
    settingsTitle: "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏—è",
    analyticsOptInLabel: "–û—Ç–ø—Ä–∞–≤–ª—è—Ç—å –∞–Ω–æ–Ω–∏–º–Ω—É—é –∞–Ω–∞–ª–∏—Ç–∏–∫—É",
    analyticsOptInHint: "–ü–æ–º–æ–≥–∞–µ—Ç —É–ª—É—á—à–∞—Ç—å Almost –±–µ–∑ –ø–µ—Ä–µ–¥–∞—á–∏ –ª–∏—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö",
    themeLabel: "–¢–µ–º–∞",
    themeLight: "–°–≤–µ—Ç–ª–∞—è",
    themeDark: "–¢—ë–º–Ω–∞—è",
    languageLabel: "–Ø–∑—ã–∫",
    languageRussian: "–†—É—Å—Å–∫–∏–π",
    languageEnglish: "English",
    languageSpanish: "–ò—Å–ø–∞–Ω—Å–∫–∏–π",
    languageFrench: "–§—Ä–∞–Ω—Ü—É–∑—Å–∫–∏–π",
    partialInfo: "–ß–∞—Å—Ç–∏—á–Ω–∞—è –æ–ø–ª–∞—Ç–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ –¥–ª—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Ç–æ–≤–∞—Ä–æ–≤",
    partialLabel: "–í–≤–µ–¥–∏ —Å—É–º–º—É (–¥–æ {{amount}})",
    partialError: "–ù—É–∂–Ω–∞ —Å—É–º–º–∞ –æ—Ç 1 –∏ –Ω–µ –±–æ–ª—å—à–µ –ø–æ–ª–Ω–æ–π —Å—Ç–æ–∏–º–æ—Å—Ç–∏",
    buyFull: "–ö—É–ø–∏—Ç—å —Ü–µ–ª–∏–∫–æ–º",
    buyPartial: "–ö—É–ø–∏—Ç—å —á–∞—Å—Ç—å",
    thinkLater: "–ü–æ–¥—É–º–∞—é –ø–æ–∑–∂–µ",
    wantAction: "–í —Ü–µ–ª–∏",
    saveAction: "–ö–æ–ø–∏—Ç—å",
    maybeAction: "–ü–æ–¥—É–º–∞—é",
    spendAction: "–ü–æ—Ç—Ä–∞—Ç–∏—Ç—å",
    editPrice: "–ò–∑–º–µ–Ω–∏—Ç—å —Ü–µ–Ω—É",
    actionSoon: "–°–∫–æ—Ä–æ –¥–æ–±–∞–≤–∏–º –¥–µ–π—Å—Ç–≤–∏–µ",
    saveSpamWarningItem: "–ö–∞–∂–µ—Ç—Å—è, –≤—ã —É–∂–µ —Ç—Ä–∏–∂–¥—ã –ø–æ–¥—Ä—è–¥ –Ω–∞–∂–∞–ª–∏ ¬´–∫–æ–ø–∏—Ç—å¬ª –Ω–∞ —ç—Ç–æ–π –∫–∞—Ä—Ç–æ—á–∫–µ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ –ø—è—Ç—å –º–∏–Ω—É—Ç. –°–¥–µ–ª–∞–π—Ç–µ –ø–∞—É–∑—É, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å —Å–ª—É—á–∞–π–Ω—ã—Ö –Ω–∞–∂–∞—Ç–∏–π.",
    saveSpamWarningGlobal: "–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –±—ã—Å—Ç—Ä—ã—Ö –Ω–∞–∂–∞—Ç–∏–π ¬´–∫–æ–ø–∏—Ç—å¬ª. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —á—Ç–æ —ç—Ç–æ –Ω–µ —Å–ª—É—á–∞–π–Ω–æ—Å—Ç—å, –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —á—É—Ç—å –ø–æ–∑–∂–µ.",
    priceEditTitle: "–ù–∞—Å—Ç—Ä–æ–π —Ü–µ–Ω—É",
    priceEditPlaceholder: "–°—É–º–º–∞ –≤ —Ç–µ–∫—É—â–µ–π –≤–∞–ª—é—Ç–µ",
    priceEditSave: "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å",
    priceEditReset: "–°–±—Ä–æ—Å–∏—Ç—å",
    priceEditCancel: "–û—Ç–º–µ–Ω–∞",
    priceEditDelete: "–£–¥–∞–ª–∏—Ç—å –∏—Å–∫—É—à–µ–Ω–∏–µ",
    priceEditDeleteConfirm: "–£–¥–∞–ª–∏—Ç—å —ç—Ç–æ –∏—Å–∫—É—à–µ–Ω–∏–µ?",
    priceEditError: "–í–≤–µ–¥–∏ —Å—É–º–º—É –±–æ–ª—å—à–µ –Ω—É–ª—è",
    priceEditNameLabel: "–ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç–æ—á–∫–∏",
    priceEditAmountLabel: "–°—Ç–æ–∏–º–æ—Å—Ç—å ({{currency}})",
    wishAdded: "–î–æ–±–∞–≤–ª–µ–Ω–æ –≤ —Ü–µ–ª–∏: {{title}}",
    wishDeclined: "+{{amount}} –∫ –∫–æ–ø–∏–ª–∫–µ. –û—Ç–ª–∏—á–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ!",
    customTemptationAdded: "–î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –∏—Å–∫—É—à–µ–Ω–∏—è: {{title}}",
    saveCelebrateTitlePrefix: "–°—ç–∫–æ–Ω–æ–º–ª–µ–Ω–æ –Ω–∞:",
    saveCelebrateSubtitle: "–ê–ª–º–∏ —Ä–∞–¥—É–µ—Ç—Å—è, —Å—á—ë—Ç –ø–æ–ø–æ–ª–Ω–µ–Ω!",
    saveGoalRemaining: "–ü—Ä–∏–º–µ—Ä–Ω–æ {{count}} —Ç–∞–∫–∏—Ö —Ä–µ—à–µ–Ω–∏–π –¥–æ —Ü–µ–ª–∏ ¬´{{goal}}¬ª.",
    saveGoalComplete: "–¶–µ–ª—å ¬´{{goal}}¬ª –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞! –ú–æ–∂–Ω–æ –ø—Ä–∞–∑–¥–Ω–æ–≤–∞—Ç—å.",
    saveOverlayCoinReward: "+{{amount}} –º–æ–Ω–µ—Ç –≤ –∫–æ–ø–∏–ª–∫—É –ê–ª–º–∏",
    statsSpent: "–ó–∞–∫—Ä—ã—Ç–æ —Ü–µ–ª–µ–π",
    statsSaved: "–°–ø–∞—Å–µ–Ω–æ",
    statsItems: "–¶–µ–ª–µ–π",
    statsCart: "–í –ª–∏—Å—Ç–µ",
    statsDeclines: "–≠–∫–æ–Ω–æ–º–∏–π",
    statsSpends: "–¢—Ä–∞—Ç",
    statsFreeDays: "–°–µ—Ä–∏—è",
    savingsBreakdownTitle: "–†–∞–∑–±–∏–≤–∫–∞ —ç–∫–æ–Ω–æ–º–∏–∏",
    savingsBreakdownOtherLabel: "–î—Ä—É–≥–∏–µ",
    analyticsTitle: "–ü—Ä–æ–≥—Ä–µ—Å—Å",
    analyticsPendingToBuy: "–¶–µ–ª–∏",
    analyticsPendingToDecline: "–û—Ç–∫–∞–∑—ã",
    analyticsFridgeCount: "–¢—Ä–∞—Ç—ã",
    analyticsBestStreak: "–ë–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –¥–Ω–µ–π",
    analyticsConsentTitle: "–ü–æ–º–æ–∂–µ—à—å –Ω–∞–º —Å—Ç–∞—Ç—å –ª—É—á—à–µ?",
    analyticsConsentBody:
      "–ú—ã —Å–æ–±–∏—Ä–∞–µ–º –∞–Ω–æ–Ω–∏–º–Ω—É—é –∞–Ω–∞–ª–∏—Ç–∏–∫—É, —á—Ç–æ–±—ã –ø–æ–Ω–∏–º–∞—Ç—å, –∫–∞–∫–∏–µ —Ä–µ—à–µ–Ω–∏—è –ø–æ–º–æ–≥–∞—é—Ç —ç–∫–æ–Ω–æ–º–∏—Ç—å —á–∞—â–µ. –ù–∏–∫–∞–∫–∏–µ –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–µ–º.",
    analyticsConsentAgree: "–î–µ–ª–∏—Ç—å—Å—è –∞–Ω–∞–ª–∏—Ç–∏–∫–æ–π",
    analyticsConsentSkip: "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –±–µ–∑ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏",
    onboardingBack: "–ù–∞–∑–∞–¥",
    historyTitle: "–ò—Å—Ç–æ—Ä–∏—è —Å–æ–±—ã—Ç–∏–π",
    historyEmpty: "–¢–∏—à–∏–Ω–∞. –î–æ–±–∞–≤—å —Ü–µ–ª—å –∏–ª–∏ –æ—Ç–º–µ—Ç—å –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π –¥–µ–Ω—å.",
    privacyPolicyLink: "–ü–æ–ª–∏—Ç–∏–∫–∞ –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ—Å—Ç–∏",
    privacyPolicyHint: "–û—Ç–∫—Ä–æ–µ–º –¥–æ–∫—É–º–µ–Ω—Ç –≤ –±—Ä–∞—É–∑–µ—Ä–µ.",
    supportLink: "–ü–æ–¥–¥–µ—Ä–∂–∫–∞",
    supportHint: "almostappsup@gmail.com",
    ratingPromptTitle: "–û—Ü–µ–Ω–∏ Almost –≤ —Å—Ç–æ—Ä–µ",
    ratingPromptBody: "–ï—Å–ª–∏ Almost –ø–æ–º–æ–≥–∞–µ—Ç –¥–µ—Ä–∂–∞—Ç—å –∏–º–ø—É–ª—å—Å—ã –ø–æ–¥ –∫–æ–Ω—Ç—Ä–æ–ª–µ–º, –ø–æ—Å—Ç–∞–≤—å –æ—Ü–µ–Ω–∫—É - —ç—Ç–æ –æ—á–µ–Ω—å –ø–æ–¥–¥–µ—Ä–∂–∏—Ç –∫–æ–º–∞–Ω–¥—É.",
    ratingPromptLater: "–ü–æ–∑–∂–µ",
    ratingPromptAction: "–û—Ü–µ–Ω–∏—Ç—å",
    levelShareButton: "–ü–æ–¥–µ–ª–∏—Ç—å—Å—è —É—Ä–æ–≤–Ω–µ–º",
    levelShareModalTitle: "–ù–æ–≤—ã–π —É—Ä–æ–≤–µ–Ω—å!",
    levelShareModalCaption: "–°–∫—Ä–∏–Ω—å –∫–∞—Ä—Ç–æ—á–∫—É –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–π –¥—Ä—É–∑—å—è–º",
    levelShareModalShare: "–î–µ–ª–∏—Ç—å—Å—è –∫–∞—Ä—Ç–∏–Ω–∫–æ–π",
    levelShareModalClose: "–ó–∞–∫—Ä—ã—Ç—å",
    levelShareError: "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–µ–ª–∏—Ç—å—Å—è. –ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ.",
    levelShareShareMessage: "–Ø –Ω–∞ —É—Ä–æ–≤–Ω–µ {{level}} –≤ Almost. –ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Å—è –∫ –æ—Å–æ–∑–Ω–∞–Ω–Ω—ã–º —Ç—Ä–∞—Ç–∞–º!",
    levelShareCardBadge: "ALMOST HERO",
    levelShareCardTitle: "–£—Ä–æ–≤–µ–Ω—å {{level}}",
    levelShareCardSubtitle: "–ê–ª–º–∏ —Ä–∞–¥—É–µ—Ç—Å—è –º–æ–µ–º—É –ø—Ä–æ–≥—Ä–µ—Å—Å—É",
    levelShareJoin: "–ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Å—è –∫ –æ—Å–æ–∑–Ω–∞–Ω–Ω—ã–º —Ä–∞—Å—Ö–æ–¥–∞–º",
    levelShareFooterBrand: "Almost",
    levelShareFooterHint: "APP",
    historyWishAdded: "–î–æ–±–∞–≤–ª–µ–Ω–∞ —Ö–æ—Ç–µ–ª–∫–∞: {{title}}",
    historyWishProgress: "–ü—Ä–æ–≥—Ä–µ—Å—Å –ø–æ ¬´{{title}}¬ª: {{amount}} –∏–∑ {{target}}",
    historyWishDone: "–¶–µ–ª—å –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞: {{title}}",
    historyDecline: "–û—Ç–∫–∞–∑ –æ—Ç {{title}} (+{{amount}})",
    historyRefuseSpend: "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –Ω–∞ ¬´{{title}}¬ª (+{{amount}})",
    historyPendingAdded: "–û—Ç–ª–æ–∂–µ–Ω–æ –Ω–∞ 14 –¥–Ω–µ–π: {{title}}",
    historyPendingWant: "–ü–æ—Å–ª–µ –ø–∞—É–∑—ã —Ä–µ—à–∏–ª–∏ –∫–æ–ø–∏—Ç—å: {{title}}",
    historyPendingDecline: "–ü–æ—Å–ª–µ –ø–∞—É–∑—ã –æ—Ç–∫–∞–∑: {{title}} (+{{amount}})",
    historyPendingRemoved: "–£–¥–∞–ª–µ–Ω–æ –∏–∑ ¬´–¥—É–º–∞–µ–º¬ª: {{title}}",
    historyFreeDay: "–ë–µ—Å–ø–ª–∞—Ç–Ω—ã–π –¥–µ–Ω—å ‚Ññ{{total}}",
    historySpend: {
      female: "–ü–æ—Ç—Ä–∞—Ç–∏–ª–∞: {{title}} (-{{amount}})",
      male: "–ü–æ—Ç—Ä–∞—Ç–∏–ª: {{title}} (-{{amount}})",
      none: "–ü–æ—Ç—Ä–∞—á–µ–Ω–æ: {{title}} (-{{amount}})",
    },
    historyWishRemoved: "–£–¥–∞–ª–µ–Ω–∞ —Ü–µ–ª—å: {{title}}",
    historyGoalStarted: "–ù–∞—á–∞—Ç–∞ —Ü–µ–ª—å: {{title}}",
    historyGoalCancelled: "–û—Ç–º–µ–Ω–µ–Ω–∞ —Ü–µ–ª—å: {{title}}",
    historyRewardClaimed: "–ü–æ–ª—É—á–µ–Ω–æ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ: {{title}}",
    historyTimestamp: "{{date}} ¬∑ {{time}}",
    historyUnknown: "–°–æ–±—ã—Ç–∏–µ",
    progressHeroTitle: "–†–µ–∞–ª—å–Ω–æ —Å–ø–∞—Å–µ–Ω–æ",
    progressHeroLevel: "–£—Ä–æ–≤–µ–Ω—å {{level}}",
    progressHeroNext: "–î–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ —É—Ä–æ–≤–Ω—è {{amount}}",
    levelCelebrate: {
      female: "–¢—ã –¥–æ—Å—Ç–∏–≥–ª–∞ —É—Ä–æ–≤–Ω—è {{level}}! –≠–∫–æ–Ω–æ–º–∏—è —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –ø—Ä–∏–≤—ã—á–∫–æ–π.",
      male: "–¢—ã –¥–æ—Å—Ç–∏–≥ —É—Ä–æ–≤–Ω—è {{level}}! –≠–∫–æ–Ω–æ–º–∏—è —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –ø—Ä–∏–≤—ã—á–∫–æ–π.",
      none: "–ù–æ–≤—ã–π —É—Ä–æ–≤–µ–Ω—å {{level}}! –≠–∫–æ–Ω–æ–º–∏—è —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –ø—Ä–∏–≤—ã—á–∫–æ–π.",
    },
    tileRefuseCount: {
      female: "–û—Ç–∫–∞–∑–∞–ª–∞—Å—å —É–∂–µ {{count}} —Ä–∞–∑ ¬∑ +{{amount}}",
      male: "–û—Ç–∫–∞–∑–∞–ª—Å—è —É–∂–µ {{count}} —Ä–∞–∑ ¬∑ +{{amount}}",
      none: "–û—Ç–∫–∞–∑–∞–ª–∏—Å—å —É–∂–µ {{count}} —Ä–∞–∑ ¬∑ +{{amount}}",
    },
    tileRefuseMessage: "–¢–æ—á–Ω–æ –Ω–µ –ø–æ–∫—É–ø–∞–π —ç—Ç–æ —Å–µ–≥–æ–¥–Ω—è, —Ç–∞–∫ —Ç—ã –¥–µ–π—Å—Ç–≤—É–µ—à—å –≤ —Å–≤–æ–∏—Ö –∏–Ω—Ç–µ—Ä–µ—Å–∞—Ö.",
    tileReady: "–î–æ—Å—Ç—É–ø–Ω–æ",
    tileLocked: "–ü–æ–∫–∞ –∫–æ–ø–∏–º",
    spendWarning: {
      female: "–ü–æ—Ç—Ä–∞—Ç–∏—à—å {{amount}}, —Ç–æ—á–Ω–æ –≥–æ—Ç–æ–≤–∞?",
      male: "–ü–æ—Ç—Ä–∞—Ç–∏—à—å {{amount}}, —Ç–æ—á–Ω–æ –≥–æ—Ç–æ–≤?",
      none: "–ü–æ—Ç—Ä–∞—Ç–∏—à—å {{amount}}, —Ç–æ—á–Ω–æ –≥–æ—Ç–æ–≤(–∞)?",
    },
    spendSheetTitle: "Almost Pay",
    spendSheetSubtitle: "–®—É—Ç–ª–∏–≤—ã–π Pay –Ω–∞–ø–æ–º–∏–Ω–∞–µ—Ç: —ç–∫–æ–Ω–æ–º–∏—è –ª—é–±–∏—Ç —Ç–µ—Ä–ø–µ–Ω–∏–µ.",
    spendSheetHint: "–î–≤–∞–∂–¥—ã –Ω–∞–∂–º–∏ (–º—ã—Å–ª–µ–Ω–Ω–æ) –Ω–∞ –∫–Ω–æ–ø–∫—É, –µ—Å–ª–∏ –≤—Å—ë-—Ç–∞–∫–∏ —Ç—Ä–∞—Ç–∏—à—å.",
    spendSheetCancel: "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∫–æ–ø–∏—Ç—å",
    spendSheetConfirm: "–ü–æ—Ç—Ä–∞—Ç–∏—Ç—å –≤—Å—ë —Ä–∞–≤–Ω–æ",
    stormOverlayMessage: "–ì—Ä–æ–∑–∞ —Ç—Ä–∞—Ç –≥—Ä–µ–º–∏—Ç. –ú–æ–∂–µ—Ç, —Å–ø—Ä—è—á–µ–º –∫–∞—Ä—Ç—É?",
    rewardsEmpty: "–°–æ–±–µ—Ä–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è: –æ—Ç–∫–∞–∂–∏—Å—å –æ—Ç –ø–∞—Ä—ã –ª–∏—à–Ω–∏—Ö —Ö–æ—Ç–µ–ª–æ–∫ –∏–ª–∏ –æ—Ç–º–µ—Ç—å –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π –¥–µ–Ω—å.",
    goalsTitle: "–¶–µ–ª–∏ –∏ –Ω–∞–≥—Ä–∞–¥—ã",
    rewardUnlocked: "–î–æ—Å—Ç–∏–≥–Ω—É—Ç–æ",
    rewardLocked: "–û—Å—Ç–∞–ª–æ—Å—å {{amount}}",
    rewardRemainingAmount: "–û—Å—Ç–∞–ª–æ—Å—å {{amount}}",
    rewardRemainingDays: "–û—Å—Ç–∞–ª–æ—Å—å {{count}} –¥–Ω–µ–π",
    rewardRemainingRefuse: "–û—Å—Ç–∞–ª–æ—Å—å {{count}} –æ—Ç–∫–∞–∑–æ–≤",
    rewardRemainingFridge: "–û—Å—Ç–∞–ª–æ—Å—å {{count}} —Ö–æ—Ç–µ–ª–æ–∫ –≤ ¬´–¥—É–º–∞–µ–º¬ª",
    rewardRemainingDecisions: "–û—Å—Ç–∞–ª–æ—Å—å {{count}} —Ä–µ—à–µ–Ω–∏–π –∏–∑ ¬´–¥—É–º–∞–µ–º¬ª",
    rewardLockedGeneric: "–û—Å—Ç–∞–ª–æ—Å—å {{count}} —à–∞–≥–æ–≤",
    rewardBadgeLabel: "–ù–∞–≥—Ä–∞–¥–∞",
    rewardBadgeLabelPlural: "–Ω–∞–≥—Ä–∞–¥",
    rewardBadgeClaimed: "–ü–æ–ª—É—á–µ–Ω–æ!",
    rewardClaimCta: "–°–æ–±—Ä–∞—Ç—å",
    rewardClaimHint: "–°–æ–±–µ—Ä–∏ –∏ –ø–æ–ª—É—á–∏ {{amount}}",
    rewardClaimedStatus: "–ó–¥–æ—Ä–æ–≤—å–µ –ø–æ–ª—É—á–µ–Ω–æ",
    rewardHealthBonus: "+{{amount}}",
    freeDayHealthTitle: "–ú–æ–Ω–µ—Ç–∫–∏",
    freeDayHealthSubtitle: "–¢—Ä–∞—Ç—è—Ç—Å—è –Ω–∞ —Å–ø–∞—Å–µ–Ω–∏–µ —Å–µ—Ä–∏–∏ –∏ –ê–ª–º–∏.",
    rewardCelebrateTitle: "–ù–∞–≥—Ä–∞–¥–∞ {{title}} –ø–æ–ª—É—á–µ–Ω–∞!",
    rewardCelebrateSubtitle: "–ê–ª–º–∏ –ª–∏–∫—É–µ—Ç: –ø—Ä–æ–¥–æ–ª–∂–∞–π –Ω–∞–∫–∞–ø–ª–∏–≤–∞—Ç—å –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è.",
    challengeTabTitle: "–ß–µ–ª–ª–µ–Ω–¥–∂–∏",
    challengeRewardsTabTitle: "–ù–∞–≥—Ä–∞–¥—ã",
    challengeStartCta: "–í–∑—è—Ç—å —á–µ–ª–ª–µ–Ω–¥–∂",
    challengeClaimCta: "–°–æ–±—Ä–∞—Ç—å –Ω–∞–≥—Ä–∞–¥—É",
    challengeActiveCta: "–í –ø—Ä–æ—Ü–µ—Å—Å–µ",
    challengeStatusAvailable: "–ì–æ—Ç–æ–≤ –∫ —Å—Ç–∞—Ä—Ç—É",
    challengeStatusActive: "–ê–∫—Ç–∏–≤–µ–Ω",
    challengeStatusCompleted: "–ì–æ—Ç–æ–≤ –∫ –≤—ã–¥–∞—á–µ",
    challengeStatusExpired: "–ü—Ä–æ—Å—Ä–æ—á–µ–Ω",
    challengeStatusClaimed: "–ü—Ä–æ–π–¥–µ–Ω",
    challengeRewardLabel: "–ù–∞–≥—Ä–∞–¥–∞",
    challengeRewardHealth: "+{{amount}}",
    challengeProgressLabel: "{{current}} / {{target}}",
    challengeDurationLabel: "–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {{days}} –¥–Ω.",
    challengeTimeLeftLabel: "–û—Å—Ç–∞–ª–æ—Å—å {{time}}",
    challengeTimeDayShort: "–¥",
    challengeTimeHourShort: "—á",
    challengeTimeMinuteShort: "–º",
    challengeTimeExpired: "–í—Ä–µ–º—è –≤—ã—à–ª–æ",
    challengeReadyToClaim: "–ì–æ—Ç–æ–≤ –∫ –≤—ã–¥–∞—á–µ",
    challengeRestartHint: "–ú–æ–∂–Ω–æ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å - –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å {{days}} –¥–Ω.",
    challengeStartedOverlay: "–ß–µ–ª–ª–µ–Ω–¥–∂ ¬´{{title}}¬ª –∑–∞–ø—É—â–µ–Ω",
    challengeCompletedOverlay: "¬´{{title}}¬ª –≤—ã–ø–æ–ª–Ω–µ–Ω - –∑–∞–±–µ—Ä–∏ –Ω–∞–≥—Ä–∞–¥—É!",
    challengeClaimedOverlay: "–ó–∞ —á–µ–ª–ª–µ–Ω–¥–∂ ¬´{{title}}¬ª ¬∑ +{{amount}}",
    challengeReminderTitle: "–ß–µ–ª–ª–µ–Ω–¥–∂ Almost ¬´{{title}}¬ª",
    challengeReminderBody: "–î–æ —Ñ–∏–Ω–∏—à–∞ —Ä—É–∫–æ–π –ø–æ–¥–∞—Ç—å. –û—Ç–º–µ—Ç—å –æ—Ç–∫–∞–∑ –∏ –∑–∞–±–µ—Ä–∏ –Ω–∞–≥—Ä–∞–¥—É –∑–∞ ¬´{{title}}¬ª.",
    challengeCancelAction: "–û—Ç–º–µ–Ω–∏—Ç—å",
    challengeAcceptConfirmTitle: "–ù–∞—á–∞—Ç—å —á–µ–ª–ª–µ–Ω–¥–∂?",
    challengeAcceptConfirmMessage: "–ó–∞–ø—É—Å—Ç–∏—Ç—å ¬´{{title}}¬ª? –í—Ä–µ–º—è –ø–æ–π–¥—ë—Ç —Å—Ä–∞–∑—É.",
    challengeAcceptConfirmYes: "–ù–∞—á–∞—Ç—å",
    challengeAcceptConfirmNo: "–ù–µ —Å–µ–π—á–∞—Å",
    challengeCancelConfirmTitle: "–û—Ç–º–µ–Ω–∏—Ç—å —á–µ–ª–ª–µ–Ω–¥–∂?",
    challengeCancelConfirmMessage: "–ü—Ä–µ—Ä–≤–∞—Ç—å ¬´{{title}}¬ª? –ü—Ä–æ–≥—Ä–µ—Å—Å –æ–±–Ω—É–ª–∏—Ç—Å—è.",
    challengeCancelConfirmYes: "–û—Ç–º–µ–Ω–∏—Ç—å",
    challengeCancelConfirmNo: "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å",
    challengeLimitReachedAction: "–ú–∞–∫—Å. {{limit}} —á–µ–ª–ª–µ–Ω–¥–∂–∞",
    challengeLimitReachedTitle: "–õ–∏–º–∏—Ç —á–µ–ª–ª–µ–Ω–¥–∂–µ–π",
    challengeLimitReachedMessage: "–ú–æ–∂–Ω–æ –≤–µ—Å—Ç–∏ –Ω–µ –±–æ–ª–µ–µ {{limit}} —á–µ–ª–ª–µ–Ω–¥–∂–µ–π –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ. –ó–∞–≤–µ—Ä—à–∏ –∞–∫—Ç–∏–≤–Ω—ã–π —á–µ–ª–ª–µ–Ω–¥–∂, —á—Ç–æ–±—ã –≤–∑—è—Ç—å –Ω–æ–≤—ã–π.",
    dailyChallengeOfferBadge: "–º–∏–Ω–∏-—á–µ–ª–ª–µ–Ω–¥–∂",
    dailyChallengeOfferTitle: "–í—ã–∑–æ–≤ –¥–Ω—è",
    dailyChallengeOfferSubtitle: "–ü–æ–ø—Ä–æ–±—É–π –ø—Ä–æ–≤–µ—Å—Ç–∏ –¥–µ–Ω—å –±–µ–∑ ¬´{{temptation}}¬ª",
    dailyChallengeOfferHint: "–û—Ç–∫–∞–∂–∏—Å—å —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Ä–∞–∑ –∏ –ø–æ–ª—É—á–∏—à—å –¥–≤–æ–π–Ω—É—é –Ω–∞–≥—Ä–∞–¥—É.",
    dailyChallengeOfferReward: "+{{amount}} —Å–≤–µ—Ä—Ö—É",
    dailyChallengeOfferAccept: "–ü—Ä–∏–Ω—è—Ç—å –≤—ã–∑–æ–≤",
    dailyChallengeOfferLater: "–ü–æ–∑–∂–µ",
    dailyChallengeWidgetBadge: "–º–∏–Ω–∏-—á–µ–ª–ª–µ–Ω–¥–∂",
    dailyChallengeWidgetTitle: "–ê–∫—Ç–∏–≤–Ω—ã–π —á–µ–ª–ª–µ–Ω–¥–∂",
    dailyChallengeWidgetDesc: "–î–µ–Ω—å –±–µ–∑ ¬´{{temptation}}¬ª = –º–æ–Ω–µ—Ç—ã —Ö2",
    dailyChallengeWidgetProgress: "–ü—Ä–æ–≥—Ä–µ—Å—Å {{current}} / {{target}}",
    dailyChallengeWidgetReward: "+{{amount}}",
    dailyChallengeRewardReason: "–ú–∏–Ω–∏-—á–µ–ª–ª–µ–Ω–¥–∂ ¬´{{temptation}}¬ª –≤—ã–ø–æ–ª–Ω–µ–Ω",
    dailyChallengeRewardNotificationTitle: "Almost: –º–∏–Ω–∏-—á–µ–ª–ª–µ–Ω–¥–∂ –∑–∞–∫—Ä—ã—Ç",
    dailyChallengeRewardNotificationBody: "¬´{{temptation}}¬ª —Å–¥–∞–ª–æ—Å—å - –∑–∞–±–µ—Ä–∏ –±–æ–Ω—É—Å +{{amount}}.",
    dailyChallengeFailedText: "–°–µ–≥–æ–¥–Ω—è ¬´{{temptation}}¬ª –æ–∫–∞–∑–∞–ª–æ—Å—å —Å–∏–ª—å–Ω–µ–µ",
    healthCelebrateTitle: "+{{amount}}",
    healthCelebrateSubtitle: "–°–æ—Ö—Ä–∞–Ω—è–π —Å–µ—Ä–∏—é –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –¥–Ω–µ–π.",
    healthCelebrateLevel: "–ù–æ–≤—ã–π —É—Ä–æ–≤–µ–Ω—å! –ê–ª–º–∏ –¥–æ–≤–æ–ª–µ–Ω.",
    healthCelebrateReward: "–ù–∞–≥—Ä–∞–¥–∞ —Å–æ–±—Ä–∞–Ω–∞ - –∑–¥–æ—Ä–æ–≤—å–µ –ø–æ–ø–æ–ª–Ω–µ–Ω–æ.",
    rainMessage: "–ö–∞–∫ –∂–µ —Ç–∞–∫? –°–ø–∞—Å–∏ –¥–µ–Ω–µ–∂–∫–∏.",
    developerReset: "–°–±—Ä–æ—Å–∏—Ç—å –¥–∞–Ω–Ω—ã–µ",
    developerResetConfirm: "–û—á–∏—Å—Ç–∏—Ç—å —Ü–µ–ª–∏, –∏—Å—Ç–æ—Ä–∏—é –∏ –ø—Ä–æ—Ñ–∏–ª—å?",
    developerResetCancel: "–û—Å—Ç–∞–≤–∏—Ç—å",
    developerResetApply: "–°–±—Ä–æ—Å–∏—Ç—å",
    openSettings: "–ù–∞—Å—Ç—Ä–æ–π–∫–∏",
    defaultDealTitle: "–¶–µ–ª—å",
    defaultDealDesc: "–û–ø–∏—à–∏, –∑–∞—á–µ–º —Ç—ã –∫–æ–ø–∏—à—å",
    photoLibrary: "–ò–∑ –≥–∞–ª–µ—Ä–µ–∏",
    photoCamera: "–ß–µ—Ä–µ–∑ –∫–∞–º–µ—Ä—É",
    photoTapHint: "–¢–∞–ø–Ω–∏, —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å —Ñ–æ—Ç–æ",
    photoPromptTitle: "–î–æ–±–∞–≤–∏–º —Ñ–æ—Ç–æ?",
    photoPromptSubtitle: "–í—ã–±–µ—Ä–∏: –∫–∞–º–µ—Ä–∞ –∏–ª–∏ –≥–∞–ª–µ—Ä–µ—è",
    photoPermissionDenied: "–ù—É–∂–Ω–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –Ω–∞ –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ –∏–ª–∏ —Ñ–æ—Ç–æ, —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å –∞–≤–∞—Ç–∞—Ä.",
    photoPermissionSettings: "–û—Ç–∫—Ä–æ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–∏, —á—Ç–æ–±—ã –¥–∞—Ç—å –¥–æ—Å—Ç—É–ø Almost –∫ –∫–∞–º–µ—Ä–µ –∏ —Ñ–æ—Ç–æ.",
    photoPickerError: "–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑.",
    registrationTitle: "–ü–æ–∑–Ω–∞–∫–æ–º–∏–º—Å—è",
    registrationSubtitle: "–†–∞—Å—Å–∫–∞–∂–∏ –æ —Å–µ–±–µ, —á—Ç–æ–±—ã Almost –≥–æ–≤–æ—Ä–∏–ª –Ω–∞ —Ç–≤–æ—ë–º —è–∑—ã–∫–µ",
    languageTitle: "–í—ã–±–µ—Ä–∏ —è–∑—ã–∫",
    languageSubtitle: "–ß—Ç–æ–±—ã –ø–æ–¥—Å–∫–∞–∑–∫–∏ –∑–≤—É—á–∞–ª–∏ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ",
    languageCurrencyHint: "–Ø–∑—ã–∫ –∏ –≤–∞–ª—é—Ç—É –º–æ–∂–Ω–æ –ø–æ–º–µ–Ω—è—Ç—å –ø–æ–∑–∂–µ –≤ –ø—Ä–æ—Ñ–∏–ª–µ.",
    currencySwipeHint: "–°–≤–∞–π–ø–Ω–∏, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –≤—Å–µ –≤–∞–ª—é—Ç—ã ‚Üí",
    languageTermsHint: "–ù–∞–∂–∏–º–∞—è ¬´–î–∞–ª—å—à–µ¬ª, –≤—ã –ø—Ä–∏–Ω–∏–º–∞–µ—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ —Å–æ–≥–ª–∞—à–µ–Ω–∏–µ Almost.",
    languageTermsAccepted: "–ü—Ä–∏–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ —Å–æ–≥–ª–∞—à–µ–Ω–∏–µ, —á—Ç–æ–±—ã –¥–≤–∏–≥–∞—Ç—å—Å—è –¥–∞–ª—å—à–µ.",
    languageTermsLink: "–ü—Ä–æ—á–∏—Ç–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ —Å–æ–≥–ª–∞—à–µ–Ω–∏–µ",
    inputFirstName: "–ò–º—è",
    inputLastName: "–§–∞–º–∏–ª–∏—è",
    inputMotto: "–î–µ–≤–∏–∑ –¥–Ω—è",
    currencyLabel: "–í–∞–ª—é—Ç–∞ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–π",
    nextButton: "–î–∞–ª—å—à–µ",
    goalTitle: "–û–ø—Ä–µ–¥–µ–ª–∏–º —Ü–µ–ª—å",
    goalSubtitle: "–í—ã–±–µ—Ä–∏ –≥–ª–∞–≤–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —ç–∫–æ–Ω–æ–º–∏–∏",
    goalCustomSectionTitle: "–°–≤–æ–∏ —Ü–µ–ª–∏",
    goalCustomCreate: "–î–æ–±–∞–≤–∏—Ç—å —Å–≤–æ—é —Ü–µ–ª—å",
    goalButton: "–ì–æ—Ç–æ–≤–æ",
    goalPrimaryBadge: "–ì–ª–∞–≤–Ω–∞—è —Ü–µ–ª—å",
    goalTargetTitle: "–°–∫–æ–ª—å–∫–æ –Ω—É–∂–Ω–æ –Ω–∞ —Ü–µ–ª—å?",
    goalTargetSubtitle: "–£–∫–∞–∂–∏ —Å—É–º–º—É - Almost –±—É–¥–µ—Ç –¥–µ—Ä–∂–∞—Ç—å —Ñ–æ–∫—É—Å –∏ –ø—Ä–æ–≥—Ä–µ—Å—Å.",
    goalTargetPlaceholder: "–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É",
    goalTargetHint: "–°—É–º–º—É –º–æ–∂–Ω–æ –ø–æ–º–µ–Ω—è—Ç—å –ø–æ–∑–∂–µ –≤ –ø—Ä–æ—Ñ–∏–ª–µ.",
    goalTargetCTA: "–ó–∞–ø–æ–º–Ω–∏—Ç—å",
    goalTargetError: "–í–≤–µ–¥–∏ —Å—É–º–º—É —Ü–µ–ª–∏",
    goalTargetLabel: "–°—É–º–º–∞ –≥–ª–∞–≤–Ω–æ–π —Ü–µ–ª–∏",
    primaryGoalLabel: "–ì–ª–∞–≤–Ω–∞—è —Ü–µ–ª—å",
    primaryGoalLocked: "–≠—Ç—É —Ü–µ–ª—å –º–æ–∂–Ω–æ –ø–æ–º–µ–Ω—è—Ç—å —Ç–æ–ª—å–∫–æ –≤ –ø—Ä–æ—Ñ–∏–ª–µ.",
    primaryGoalRemaining: "–û—Å—Ç–∞–ª–æ—Å—å {{amount}}",
    goalWidgetTargetLabel: "–¶–µ–ª—å: {{amount}}",
    goalWidgetRemaining: "–û—Å—Ç–∞–ª–æ—Å—å {{amount}}",
    goalWidgetComplete: "–¶–µ–ª—å –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞",
    goalWidgetTitle: "–î–æ —Ü–µ–ª–∏",
    goalWidgetCompleteTagline: "–≠–∫–æ–Ω–æ–º–∏—è –ø—Ä–æ–¥–æ–ª–∂–∞–ª–∞—Å—å - –∏ —Ü–µ–ª—å –∑–∞–∫—Ä—ã—Ç–∞.",
    goalAssignPromptTitle: "–ö—É–¥–∞ –∑–∞—á–µ—Å—Ç—å —ç–∫–æ–Ω–æ–º–∏—é?",
    goalAssignPromptSubtitle: "–í—ã–±–µ—Ä–∏ —Ü–µ–ª—å, –∫–æ—Ç–æ—Ä—É—é –Ω–∞–ø–æ–ª–Ω—è–µ—Ç ¬´{{title}}¬ª.",
    goalAssignNone: "–ü–æ–∫–∞ –±–µ–∑ —Ü–µ–ª–∏",
    goalAssignTemptationTitle: "–ù–∞–∑–Ω–∞—á–∏—Ç—å –∏—Å–∫—É—à–µ–Ω–∏–µ",
    goalAssignTemptationSubtitle: "–ß—Ç–æ –±—É–¥–µ—Ç –ø–æ–ø–æ–ª–Ω—è—Ç—å ¬´{{goal}}¬ª?",
    goalAssignClear: "–°–±—Ä–æ—Å–∏—Ç—å –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ",
    goalAssignFieldLabel: "–ö—É–¥–∞ –∫–æ–ø–∏–º",
    goalMainTemptationError: "–ì–ª–∞–≤–Ω–æ–µ –∏—Å–∫—É—à–µ–Ω–∏–µ –Ω–µ–ª—å–∑—è —Å–¥–µ–ª–∞—Ç—å —Ü–µ–ª—å—é.",
    goalDestinationLabel: "–ö—É–¥–∞ –∫–æ–ø–∏–º",
    goalStatusInWishlist: "–≤ —Ü–µ–ª–∏",
    goalSwipeAdd: "–≤ —Ü–µ–ª–∏",
    goalSwipeDelete: "–£–¥–∞–ª–∏—Ç—å",
    goalPinnedBadge: "–¶–µ–ª—å",
    goalRemoved: "–ö–∞—Ä—Ç–æ—á–∫–∞ —É–±—Ä–∞–Ω–∞ –∏–∑ —Ü–µ–ª–µ–π",
    goalEditAction: "–ò–∑–º–µ–Ω–∏—Ç—å",
    goalDeleteAction: "–£–¥–∞–ª–∏—Ç—å",
    goalEditModalTitle: "–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Ü–µ–ª—å",
    goalEditNameLabel: "–ù–∞–∑–≤–∞–Ω–∏–µ —Ü–µ–ª–∏",
    goalEditTargetLabel: "–°—É–º–º–∞ —Ü–µ–ª–∏",
    goalEditEmojiLabel: "–≠–º–æ–¥–∑–∏ —Ü–µ–ª–∏",
    goalEditSave: "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å",
    goalEditCancel: "–û—Ç–º–µ–Ω–∞",
    goalEditNameError: "–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ü–µ–ª–∏",
    goalEditTargetError: "–í–≤–µ–¥–∏ —Å—É–º–º—É —Ü–µ–ª–∏",
    goalAssignPromptTitle: "–ö—É–¥–∞ –∑–∞—á–µ—Å—Ç—å —ç–∫–æ–Ω–æ–º–∏—é?",
    goalAssignPromptSubtitle: "–í—ã–±–µ—Ä–∏ —Ü–µ–ª—å, –∫–æ—Ç–æ—Ä—É—é –Ω–∞–ø–æ–ª–Ω—è–µ—Ç ¬´{{title}}¬ª.",
    goalAssignNone: "–ü–æ–∫–∞ –±–µ–∑ —Ü–µ–ª–∏",
    goalAssignTemptationTitle: "–ù–∞–∑–Ω–∞—á–∏—Ç—å –∏—Å–∫—É—à–µ–Ω–∏–µ",
    goalAssignTemptationSubtitle: "–ß—Ç–æ –±—É–¥–µ—Ç –ø–æ–ø–æ–ª–Ω—è—Ç—å ¬´{{goal}}¬ª?",
    goalAssignClear: "–°–±—Ä–æ—Å–∏—Ç—å –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ",
    goalAssignFieldLabel: "–ö—É–¥–∞ –∫–æ–ø–∏–º",
    goalCelebrationTitle: "–ì–ª–∞–≤–Ω–∞—è —Ü–µ–ª—å –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞!",
    goalCelebrationSubtitle: "–ê–ª–º–∏ –≥–æ—Ä–¥–∏—Ç—Å—è —Ç–æ–±–æ–π. –ú–æ–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å –Ω–æ–≤—É—é –º–µ—á—Ç—É.",
    goalCelebrationTarget: "–°–æ–±—Ä–∞–Ω–æ {{amount}}",
    goalRenewalTitle: "–ù–æ–≤–∞—è –≥–ª–∞–≤–Ω–∞—è —Ü–µ–ª—å?",
    goalRenewalSubtitle: "–ó–∞—Ñ–∏–∫—Å–∏—Ä—É–π —Å–ª–µ–¥—É—é—â—É—é –º–µ—á—Ç—É, —á—Ç–æ–±—ã Almost –ø—Ä–æ–¥–æ–ª–∂–∞–ª –≤–µ—Å—Ç–∏ —Ç–µ–±—è –∫ –Ω–µ–π.",
    goalRenewalCreate: "–°–æ–∑–¥–∞—Ç—å —Ü–µ–ª—å",
    goalRenewalLater: "–ü–æ–∑–∂–µ",
    levelWidgetTitle: "–ü—Ä–æ–≥—Ä–µ—Å—Å —É—Ä–æ–≤–Ω–µ–π",
    levelWidgetCurrent: "–£—Ä–æ–≤–µ–Ω—å {{level}}",
    levelWidgetSubtitle: "–î–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ —É—Ä–æ–≤–Ω—è {{amount}}",
    levelWidgetTarget: "–°–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å –ø—Ä–∏ {{amount}}",
    levelWidgetMaxed: "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å –¥–æ—Å—Ç–∏–≥–Ω—É—Ç!",
    onboardingGuideTitle: "–°–º—ã—Å–ª Almost",
    onboardingGuideSubtitle: "–ü–µ—Ä–≤—ã–µ —à–∞–≥–∏ –≤ –±–æ—Ä—å–±–µ —Å –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—å—Å—Ç–≤–æ–º –∏ –∏–º–ø—É–ª—å—Å–∏–≤–Ω—ã–º–∏ —Ç—Ä–∞—Ç–∞–º–∏.",
    onboardingGuideButton: "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å",
    termsTitle: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ —Å–æ–≥–ª–∞—à–µ–Ω–∏–µ",
    termsSubtitle: "–ü—Ä–æ—á–∏—Ç–∞–π –∫–ª—é—á–µ–≤—ã–µ —É—Å–ª–æ–≤–∏—è Almost. –ü—Ä–æ–¥–æ–ª–∂–∞—è, —Ç—ã –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—à—å —Å–æ–≥–ª–∞—Å–∏–µ —Å –Ω–∏–º–∏.",
    termsViewFull: "–û—Ç–∫—Ä—ã—Ç—å –ø–æ–ª–Ω—É—é –≤–µ—Ä—Å–∏—é",
    termsLinkHint: "–°—Å—ã–ª–∫–∞ –æ—Ç–∫—Ä–æ–µ—Ç –¥–æ–∫—É–º–µ–Ω—Ç –≤ –±—Ä–∞—É–∑–µ—Ä–µ.",
    termsAccept: "–ü—Ä–∏–Ω–∏–º–∞—é",
    termsDecline: "–û—Ç–º–µ–Ω–∏—Ç—å",
    guideStepTrackTitle: "–ì–ª–∞–≤–Ω–∞—è —Ü–µ–ª—å: –æ—Å–æ–∑–Ω–∞–Ω–Ω–æ—Å—Ç—å",
    guideStepTrackDesc: "–ú—ã –ø–æ–º–æ–≥–∞–µ–º —Ç—Ä–∞—Ç–∏—Ç—å –¥–µ–Ω—å–≥–∏ —Ç–æ–ª—å–∫–æ –Ω–∞ –≤–∞–∂–Ω–æ–µ, —Å–æ—Ö—Ä–∞–Ω—è—è –±—é–¥–∂–µ—Ç –∏ —Ñ–æ–∫—É—Å –Ω–∞ –∫—Ä—É–ø–Ω—ã—Ö —Ü–µ–ª—è—Ö.",
    guideStepDecisionTitle: "–ú–µ–Ω—é –∏—Å–∫—É—à–µ–Ω–∏–π",
    guideStepDecisionDesc: "–û—Ç–º–µ—á–∞–π –∫–∞–∂–¥–æ–µ –∏—Å–∫—É—à–µ–Ω–∏–µ –∏ —É—Å—Ç–∞–≤–∞–π –ø–µ—Ä–µ–¥ –Ω–∏–º, –∏ —Ç–æ–≥–¥–∞ –¥–µ–Ω—å–≥–∏ –æ—Å—Ç–∞—é—Ç—Å—è –≤ –∫–æ—à–µ–ª—å–∫–µ, –∞ Almost —Ñ–∏–∫—Å–∏—Ä—É–µ—Ç –ø–æ–±–µ–¥—ã.",
    guideStepRewardTitle: "–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞",
    guideStepRewardDesc: "–ù–µ –∑–∞–±—ã–≤–∞–π –æ—Ç–º–µ—á–∞—Ç—å, –Ω–∞ —á—ë–º —Å—ç–∫–æ–Ω–æ–º–∏–ª–∞: –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –ø—É—Ç—å –∫ –≥–ª–æ–±–∞–ª—å–Ω–æ–π —Ü–µ–ª–∏ –∏ –¥–∞—ë—Ç –º–æ—Ç–∏–≤–∞—Ü–∏—é.",
    personaTitle: "–†–∞—Å—Å–∫–∞–∂–∏ –ø—Ä–æ —Å–µ–±—è",
    personaSubtitle: "–†–∞—Å—Å–∫–∞–∂–∏ –æ —Å–µ–±–µ, —á—Ç–æ–±—ã –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –±—ã–ª–æ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º.",
    personaGenderLabel: "–ö–∞–∫ –∫ —Ç–µ–±–µ –æ–±—Ä–∞—â–∞—Ç—å—Å—è?",
    personaHabitLabel: "–ü—Ä–æ—Ñ–∏–ª—å, –∫–æ—Ç–æ—Ä—ã–π –±–ª–∏–∂–µ –≤—Å–µ–≥–æ",
    personaConfirm: "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å",
    customSpendTitle: "–¢–≤–æ—ë –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–µ –∏—Å–∫—É—à–µ–Ω–∏–µ",
    customSpendSubtitle: "–î–∞–π –µ–º—É –∏–º—è - Almost –ø–æ–º–æ–∂–µ—Ç –æ—Ç–∫–∞–∑—ã–≤–∞—Ç—å—Å—è —á–∞—â–µ.",
    customSpendNamePlaceholder: "–ú–∞—Ç—á–∞, —Å–∏–≥–∞—Ä–µ—Ç—ã, –º–∞–Ω–∏–∫—é—Ä...",
    customSpendAmountLabel: "–°–∫–æ–ª—å–∫–æ —Å—Ç–æ–∏—Ç –æ–¥–∏–Ω —Ä–∞–∑?",
    customSpendAmountPlaceholder: "–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É",
    customSpendFrequencyLabel: "–°–∫–æ–ª—å–∫–æ —Ä–∞–∑ –≤ –Ω–µ–¥–µ–ª—é –ø–æ–¥–¥–∞—ë—à—å—Å—è?",
    customSpendFrequencyPlaceholder: "–ù–∞–ø—Ä–∏–º–µ—Ä 4",
    customSpendHint: "–≠—Ç–æ –≤—Å–µ–≥–¥–∞ –º–æ–∂–Ω–æ –ø–æ–º–µ–Ω—è—Ç—å –≤ –ø—Ä–æ—Ñ–∏–ª–µ.",
    customSpendSkip: "–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å",
    smartReminderTitle: [
      "Almost –ª–æ–≤–∏—Ç ¬´{{temptation}}¬ª",
      "–ê–ª–º–∏ —á—É–µ—Ç ¬´{{temptation}}¬ª",
      "–ü–∏–Ω–≥ Almost: ¬´{{temptation}}¬ª",
    ],
    smartReminderBody: [
      "–ù–µ–¥–∞–≤–Ω–æ Almost –∑–∞–ø–∏—Å–∞–ª ¬´{{temptation}}¬ª. –ü–æ–≤—Ç–æ—Ä–∏ –ø–∞—É–∑—É –∏ –Ω–∞–ø—Ä–∞–≤—å –¥–µ–Ω—å–≥–∏ –≤ —Ü–µ–ª—å.",
      "Almost –∑–∞–º–µ—Ç–∏–ª –ø—Ä–∏–≤—ã—á–∫—É: –≤–¥–æ—Ö–Ω–∏ –ø–µ—Ä–µ–¥ ¬´{{temptation}}¬ª –∏ –≤—ã–±–µ—Ä–∏ –∫–æ–ø–∏–ª–∫—É.",
      "–î–µ—Ä–∂–∏–º —Å–µ—Ä–∏—é –æ—Ç–∫–∞–∑–æ–≤ - ¬´{{temptation}}¬ª –ø–æ–¥–æ–∂–¥—ë—Ç –µ—â—ë —á—É—Ç—å-—á—É—Ç—å.",
      "–ê–ª–º–∏ —à–µ–ø—á–µ—Ç: —á–µ–º —á–∞—â–µ –≤—ã–±–∏—Ä–∞–µ—à—å –∫–æ–ø–∏–ª–∫—É –≤–º–µ—Å—Ç–æ ¬´{{temptation}}¬ª, —Ç–µ–º —É–º–Ω–µ–µ –ø–æ–¥—Å–∫–∞–∑–∫–∏.",
    ],
    smartInsightDeclineTitle: {
      female: "–í—á–µ—Ä–∞ –ø–æ–±–µ–¥–∏–ª ¬´{{temptation}}¬ª",
      male: "–í—á–µ—Ä–∞ –ø–æ–±–µ–¥–∏–ª ¬´{{temptation}}¬ª",
      none: "–í—á–µ—Ä–∞ –ø–æ–±–µ–¥–∏–ª ¬´{{temptation}}¬ª",
    },
    smartInsightDeclineBody: "–ü–æ–≤—Ç–æ—Ä–∏ –ø–æ–±–µ–¥—É —Å–µ–≥–æ–¥–Ω—è - Almost –∑–∞–ø–∏—à–µ—Ç –Ω–æ–≤—É—é —Å–µ—Ä–∏—é.",
    smartInsightSpendTitle: {
      female: "–í—á–µ—Ä–∞ ¬´{{temptation}}¬ª –≤—ã–∏–≥—Ä–∞–ª–æ",
      male: "–í—á–µ—Ä–∞ ¬´{{temptation}}¬ª –≤—ã–∏–≥—Ä–∞–ª–æ",
      none: "–í—á–µ—Ä–∞ ¬´{{temptation}}¬ª –≤—ã–∏–≥—Ä–∞–ª–æ",
    },
    smartInsightSpendBody: "–°–¥–µ–ª–∞–π –ø–∞—É–∑—É —Å–µ–≥–æ–¥–Ω—è, –∏ Almost –æ—Ç–º–µ—Ç–∏—Ç –ø–æ–±–µ–¥—É –≤ –∫–æ–ø–∏–ª–∫–µ.",
    dailyNudgeMorningTitle: ["–£—Ç—Ä–µ–Ω–Ω–∏–π –ø–∏–Ω–≥ Almost", "–ê–ª–º–∏ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç —Ñ–æ–∫—É—Å"],
    dailyNudgeMorningBody: [
      "–ù–∞—á–Ω–∏ –¥–µ–Ω—å –æ—Å–æ–∑–Ω–∞–Ω–Ω–æ: –≤—Å–ø–æ–º–Ω–∏, —Ä–∞–¥–∏ –∫–∞–∫–æ–π —Ü–µ–ª–∏ —Ç—ã –∫–æ–ø–∏—à—å.",
      "–ê–ª–º–∏ —Å–ª–µ–¥–∏—Ç –∑–∞ –∏–º–ø—É–ª—å—Å–∞–º–∏ - —Å–¥–µ–ª–∞–π –ø–∞—É–∑—É –ø–µ—Ä–µ–¥ –ø–µ—Ä–≤–æ–π –ø–æ–∫—É–ø–∫–æ–π.",
    ],
    dailyNudgeDayTitle: ["–î–Ω–µ–≤–Ω–æ–π —á–µ–∫ Almost", "–ê–ª–º–∏ –¥–µ—Ä–∂–∏—Ç —Ñ–æ–∫—É—Å"],
    dailyNudgeDayBody: [
      "–í —Å–µ—Ä–µ–¥–∏–Ω–µ –¥–Ω—è –∏–º–ø—É–ª—å—Å—ã —Ä–∞—Å—Ç—É—Ç. –ü–æ–¥—É–º–∞–π, –ø–æ–¥–¥–µ—Ä–∂–∏—Ç –ª–∏ –ø–æ–∫—É–ø–∫–∞ —Ç–≤–æ—é —Ü–µ–ª—å.",
      "–ï—Å–ª–∏ —Ä—É–∫–∞ —Ç—è–Ω–µ—Ç—Å—è –∫ –∫–æ—à–µ–ª—å–∫—É, –≤—Å–ø–æ–º–Ω–∏ –ø—Ä–æ Almost –∏ –≤—ã–±–µ—Ä–∏ –∫–æ–ø–∏–ª–∫—É.",
    ],
    dailyNudgeAfternoonTitle: ["–ü–æ—Å–ª–µ–æ–±–µ–¥–µ–Ω–Ω—ã–π –ø–∏–Ω–≥ Almost", "–ê–ª–º–∏ —Å–±–∞–≤–ª—è–µ—Ç —Ç–µ–º–ø"],
    dailyNudgeAfternoonBody: [
      "–°–¥–µ–ª–∞–π —á–µ–∫-–∏–Ω –ø–µ—Ä–µ–¥ –ª—é–±–æ–π –ø–æ–∫—É–ø–∫–æ–π –∏ –æ—Ç–ø—Ä–∞–≤—å —Å–≤–æ–±–æ–¥–Ω—ã–µ –¥–µ–Ω—å–≥–∏ –≤ Almost.",
      "–ò—Å–∫—É—à–µ–Ω–∏—è –Ω–∞—Å—Ç—É–ø–∞—é—Ç? –î–µ—Ä–∂–∏—Å—å –∏ –ø–æ–º–Ω–∏ –æ —Å–≤–æ–µ–π —Ü–µ–ª–∏.",
    ],
    dailyNudgeEveningTitle: ["–í–µ—á–µ—Ä–Ω–∏–π —â–∏—Ç Almost", "–ê–ª–º–∏ –±–µ—Ä–µ–∂—ë—Ç —Ç–≤–æ–π –≤–µ—á–µ—Ä"],
    dailyNudgeEveningBody: [
      "–í–µ—á–µ—Ä–æ–º –æ—Å–æ–±–µ–Ω–Ω–æ —Ç—è–Ω–µ—Ç —Ç—Ä–∞—Ç–∏—Ç—å. –ó–∞–ø–∏—à–∏ –ø–æ–±–µ–¥—É, –¥–∞–∂–µ –µ—Å–ª–∏ –æ–Ω–∞ –º–∞–ª–µ–Ω—å–∫–∞—è.",
      "–ó–∞–∫—Ä–æ–π –¥–µ–Ω—å –∑–∞–ø–∏—Å—å—é –≤ Almost - —Ç–∞–∫ –ø–æ–¥—Å–∫–∞–∑–∫–∏ –æ—Å—Ç–∞–Ω—É—Ç—Å—è —É–º–Ω—ã–º–∏.",
    ],
    dailySummaryBadgeLabel: "–≤–µ—á–µ—Ä–Ω–∏–π –æ—Ç—á—ë—Ç",
    dailySummaryTitle: "–ò—Ç–æ–≥–∏ –¥–Ω—è",
    dailySummarySubtitle: "–¢–∞–∫ –¥–µ—Ä–∂–∞—Ç—å, –ø—Ä–æ–¥–æ–ª–∂–∞–π –≤ —Ç–æ–º –∂–µ –¥—É—Ö–µ!",
    dailySummarySavedLabel: "–°—ç–∫–æ–Ω–æ–º–ª–µ–Ω–æ —Å–µ–≥–æ–¥–Ω—è",
    dailySummarySavedSub: "–ö–∞–∂–¥—ã–π –æ—Ç–∫–∞–∑ –ø—Ä–∏–±–ª–∏–∂–∞–µ—Ç –∫ —Ü–µ–ª–∏",
    dailySummarySpendsLabel: "–¢—Ä–∞—Ç—ã",
    dailySummaryContinue: "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å",
    dailySummaryHint: "–ó–∞–≥–ª—è–Ω—É –∑–∞–≤—Ç—Ä–∞ —Å –Ω–æ–≤—ã–º–∏ —Ü–∏—Ñ—Ä–∞–º–∏.",
    baselineTitle: "–°–∫–æ–ª—å–∫–æ —É—Ö–æ–¥–∏—Ç –Ω–∞ –º–µ–ª–∫–∏–µ –∏–º–ø—É–ª—å—Å—ã?",
    baselineSubtitle: "–ü—Ä–∏–∫–∏–Ω—å –º–µ—Å—è—á–Ω—É—é —Å—É–º–º—É - Almost —Å—Ä–∞–≤–Ω–∏—Ç –µ—ë —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ –ø–æ–±–µ–¥–∞–º–∏.",
    baselinePlaceholder: "–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É",
    baselineCTA: "–ó–∞–ø–æ–º–Ω–∏—Ç—å",
    baselineHint: "–≠—Ç–æ –æ—Ä–∏–µ–Ω—Ç–∏—Ä, –ø–æ–∑–∂–µ –º–æ–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å –µ–≥–æ –≤ –ø—Ä–æ—Ñ–∏–ª–µ.",
    baselineInputError: "–í–≤–µ–¥–∏ —Å—É–º–º—É –µ–∂–µ–º–µ—Å—è—á–Ω—ã—Ö –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö —Ç—Ä–∞—Ç",
    potentialBlockTitle: "–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª —ç–∫–æ–Ω–æ–º–∏–∏",
    potentialBlockSubtitle: "",
    potentialBlockStatusAhead: "–û–≥–æ! –¢—ã –æ–ø–µ—Ä–µ–∂–∞–µ—à—å –ø—Ä–æ–≥–Ω–æ–∑. –î–µ—Ä–∂–∏ —Ç–µ–º–ø!",
    potentialBlockStatusStart: "–ù–∞—á–Ω–∏ –æ—Ç–º–µ—á–∞—Ç—å –æ—Ç–∫–∞–∑—ã - –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª –∂–¥—ë—Ç.",
    potentialBlockStatusBehind: "–¢—ã –Ω–∞ –ø—É—Ç–∏, –Ω–æ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª –≤—ã—à–µ.",
    potentialBlockStatusOnTrack: "–¢—ã –ø–æ—á—Ç–∏ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏—Å–ø–æ–ª—å–∑—É–µ—à—å –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª. –ü—Ä–æ–¥–æ–ª–∂–∞–π!",
    potentialBlockActualLabel: "–†–µ–∞–ª—å–Ω–æ —Å–ø–∞—Å–µ–Ω–æ",
    potentialBlockPotentialLabel: "–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª",
    potentialBlockHint: "–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª –µ—â—ë {{amount}}. –ù–µ –≤—Å—ë –ø–æ—Ç–µ—Ä—è–Ω–æ üôÇ",
    potentialBlockDetails:
      "–û–Ω –±–µ—Ä—ë—Ç –≤–∞—à –µ–∂–µ–º–µ—Å—è—á–Ω—ã–π –±—é–¥–∂–µ—Ç –Ω–∞ –∏—Å–∫—É—à–µ–Ω–∏—è (—Ç–æ—Ç, —á—Ç–æ –≤—ã —É–∫–∞–∑–∞–ª–∏ –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏), –¥–µ–ª–∏—Ç —Å—É–º–º—É –Ω–∞ —Å–µ–∫—É–Ω–¥—ã –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, —Å–∫–æ–ª—å–∫–æ –¥–µ–Ω–µ–≥ –º–æ–∂–Ω–æ –±—ã–ª–æ –±—ã —Å–ø–∞—Å—Ç–∏ –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å.",
    potentialBlockCta: "–†–∞—Å—Å–∫–∞–∂–∏, —Å–∫–æ–ª—å–∫–æ —É—Ö–æ–¥–∏—Ç –Ω–∞ –º–µ–ª–∫–∏–µ —Ç—Ä–∞—Ç—ã, –∏ –º—ã –ø–æ–∫–∞–∂–µ–º, —Å–∫–æ–ª—å–∫–æ —Ç—ã –º–æ–≥ –±—ã —É–∂–µ —Å–ø–∞—Å—Ç–∏.",
    potentialPushAheadTitle: "–û–ø–µ—Ä–µ–¥–∏–ª –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª!",
    potentialPushAheadBody:
      "–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª –¥–æ—à—ë–ª –¥–æ {{potential}}, –∞ —É —Ç–µ–±—è —É–∂–µ {{actual}}. –ü—Ä–æ–¥–æ–ª–∂–∞–π –¥–µ—Ä–∂–∞—Ç—å —Ç–µ–º–ø.",
    potentialPushBehindTitle: "–î–æ–≥–æ–Ω–∏ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª",
    potentialPushBehindBody:
      "–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª —É–∂–µ {{potential}}, –¥–æ –Ω–µ–≥–æ –æ—Å—Ç–∞–ª–æ—Å—å {{shortfall}}. –°–¥–µ–ª–∞–π –ø–∞—É–∑—É –ø–µ—Ä–µ–¥ —Ç—Ä–∞—Ç–æ–π –∏ –æ—Ç–º–µ—Ç—å –Ω–æ–≤—É—é —ç–∫–æ–Ω–æ–º–∏—é.",
    quickCustomTitle: "–ù–æ–≤–æ–µ –∏—Å–∫—É—à–µ–Ω–∏–µ",
    quickCustomSubtitle: "–û–ø–∏—à–∏ —Ç—Ä–∞—Ç—ã, –æ—Ç –∫–æ—Ç–æ—Ä—ã—Ö —Ö–æ—á–µ—à—å –æ—Ç–∫–∞–∑–∞—Ç—å—Å—è –ø–µ—Ä–≤–æ–π",
    quickCustomNameLabel: "–ù–∞–∑–≤–∞–Ω–∏–µ",
    quickCustomAmountLabel: "–°—Ç–æ–∏–º–æ—Å—Ç—å ({{currency}})",
    quickCustomEmojiLabel: "–≠–º–æ–¥–∑–∏ –∫–∞—Ä—Ç–æ—á–∫–∏",
    quickCustomConfirm: "–î–æ–±–∞–≤–∏—Ç—å",
    quickCustomCancel: "–û—Ç–º–µ–Ω–∞",
    coinEntryTitle: "–°–∫–æ–ª—å–∫–æ –≤–Ω–µ—Å—Ç–∏?",
    coinEntrySubtitle: "–ü—Ä–æ–≤–µ–¥–∏ –º–æ–Ω–µ—Ç–∫—É –≤–≤–µ—Ä—Ö-–≤–Ω–∏–∑ –∏ –≤—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é.",
    coinEntryHint: "–ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –≤—ã—à–µ, —á—Ç–æ–±—ã –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –∫–æ–ø–∏–ª–∫—É –∏–ª–∏ —Ç—Ä–∞—Ç—É.",
    coinEntryManual: "...",
    coinEntryManualTitle: "–í—ã–±–µ—Ä–∏ –Ω–æ–≤—ã–π –º–∞–∫—Å–∏–º—É–º",
    coinEntryManualPlaceholder: "–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É",
    coinEntryManualSave: "–ó–∞–ø–æ–º–Ω–∏—Ç—å",
    coinEntryManualCancel: "–û—Ç–º–µ–Ω–∞",
    coinEntryManualError: "–í–≤–µ–¥–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—É–º–º—É",
    coinEntryManualAmountTitle: "–í–≤–µ–¥–∏ —Å—É–º–º—É –≤—Ä—É—á–Ω—É—é",
    coinEntryManualAmountPlaceholder: "–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É",
    coinEntryCategoryLabel: "–ö–∞—Ç–µ–≥–æ—Ä–∏—è",
    coinEntryCategoryError: "–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é",
    coinEntrySaveLabel: "–ë—ã—Å—Ç—Ä–æ–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–µ",
    coinEntrySpendLabel: "–ë—ã—Å—Ç—Ä–∞—è —Ç—Ä–∞—Ç–∞",
    fabNewGoal: "–ù–æ–≤–∞—è —Ü–µ–ª—å",
    fabNewTemptation: "–ù–æ–≤–∞—è —Ç—Ä–∞—Ç–∞",
    fabQuickActionTitle: "–ü–æ—Å–ª–µ–¥–Ω–µ–µ –∏—Å–∫—É—à–µ–Ω–∏–µ",
    fabQuickActionSubtitle: "–ü–æ–≤—Ç–æ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ –¥–ª—è ¬´{{title}}¬ª",
    fabQuickActionEmpty: "–ù–µ –Ω–∞—à–ª–æ—Å—å –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è. –°–Ω–∞—á–∞–ª–∞ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤—É–π —Å –∫–∞—Ä—Ç–æ—á–∫–æ–π.",
    fabTutorialTitle: "–ö–Ω–æ–ø–∫–∞ ¬´+¬ª",
    fabTutorialDesc:
      "–¢–∞–ø–∞–π, —á—Ç–æ–±—ã –±—ã—Å—Ç—Ä–æ –∑–∞–ø–∏—Å–∞—Ç—å –∫–∞—Å—Ç–æ–º–Ω—É—é —Ç—Ä–∞—Ç—É –∏–ª–∏ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–µ. –ó–∞–∂–º–∏, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å —Ü–µ–ª—å –∏–ª–∏ –∏—Å–∫—É—à–µ–Ω–∏–µ.",
    fabTutorialAction: "–ü–æ–Ω—è—Ç–Ω–æ",
    newGoalTitle: "–ù–æ–≤–∞—è —Ü–µ–ª—å",
    newGoalSubtitle: "–ö–∞–∫ –Ω–∞–∑–æ–≤—ë–º –º–µ—á—Ç—É –∏ —Å–∫–æ–ª—å–∫–æ –æ–Ω–∞ —Å—Ç–æ–∏—Ç?",
    newGoalNameLabel: "–ù–∞–∑–≤–∞–Ω–∏–µ —Ü–µ–ª–∏",
    newGoalTargetLabel: "–°—É–º–º–∞ ({{currency}})",
    newGoalEmojiLabel: "–≠–º–æ–¥–∑–∏ —Ü–µ–ª–∏",
    newGoalCreate: "–°–æ–∑–¥–∞—Ç—å —Ü–µ–ª—å",
    newGoalCancel: "–û—Ç–º–µ–Ω–∞",
    newPendingTitle: "–ù–æ–≤–æ–µ ¬´–¥—É–º–∞–µ–º¬ª",
    newPendingSubtitle: "–û–ø–∏—à–∏ –∏—Å–∫—É—à–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ —Ä–∞–∑—É–º–Ω–æ –æ—Ç–ª–æ–∂–∏—Ç—å –Ω–∞ 14 –¥–Ω–µ–π.",
    newPendingNameLabel: "–ù–∞–∑–≤–∞–Ω–∏–µ",
    newPendingAmountLabel: "–°—Ç–æ–∏–º–æ—Å—Ç—å ({{currency}})",
    newPendingEmojiLabel: "–≠–º–æ–¥–∑–∏ –∫–∞—Ä—Ç–æ—á–∫–∏",
    newPendingCreate: "–î–æ–±–∞–≤–∏—Ç—å –≤ ¬´–¥—É–º–∞–µ–º¬ª",
    newPendingCancel: "–û—Ç–º–µ–Ω–∞",
    tutorialFeedTitle: "–õ–µ–Ω—Ç–∞ –∏—Å–∫—É—à–µ–Ω–∏–π",
    tutorialFeedDesc: "–û—Ç–º–µ—á–∞–π –∏–º–ø—É–ª—å—Å—ã –∏ –≤—ã–±–∏—Ä–∞–π: –∫–æ–ø–∏—Ç—å, –¥–æ–±–∞–≤–∏—Ç—å –≤ —Ü–µ–ª–∏ –∏–ª–∏ –ø–æ–¥—É–º–∞—Ç—å 14 –¥–Ω–µ–π.",
    tutorialGoalsTitle: "–¶–µ–ª–∏",
    tutorialGoalsDesc: "–ó–¥–µ—Å—å –∂–∏–≤—É—Ç –º–µ—á—Ç—ã. –°–ª–µ–¥–∏ –∑–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–æ–º –∏ –æ–±–Ω–æ–≤–ª—è–π —Ü–µ–ª—å.",
    tutorialThinkingTitle: "–ú–µ–Ω—é ¬´–î—É–º–∞–µ–º¬ª",
    tutorialThinkingDesc: "–û—Ç–ø—Ä–∞–≤–ª—è–π –∏–º–ø—É–ª—å—Å—ã –Ω–∞ –ø–∞—É–∑—É –∏ –≤–æ–∑–≤—Ä–∞—â–∞–π—Å—è –∫ –Ω–∏–º —á–µ—Ä–µ–∑ 14 –¥–Ω–µ–π, —á—Ç–æ–±—ã —Ä–µ—à–∏—Ç—å —Ç—Ä–µ–∑–≤–æ.",
    tutorialRewardsTitle: "–ù–∞–≥—Ä–∞–¥—ã –∏ —á–µ–ª–ª–µ–Ω–¥–∂–∏",
    tutorialRewardsDesc: "–ó–∞–≥–ª—è–¥—ã–≤–∞–π —Å—é–¥–∞, —á—Ç–æ–±—ã —Å–æ–±–∏—Ä–∞—Ç—å –Ω–∞–≥—Ä–∞–¥—ã –∑–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å –∏ –∑–∞–ø—É—Å–∫–∞—Ç—å —á–µ–ª–ª–µ–Ω–¥–∂–∏ —Å –±–æ–Ω—É—Å–∞–º–∏.",
    tutorialProfileTitle: "–ü—Ä–æ—Ñ–∏–ª—å –∏ –º–æ—Ç–∏–≤–∞—Ü–∏—è",
    tutorialProfileDesc: "–¢—É—Ç –º–µ–Ω—è–µ—à—å —Ç–µ–º—É, —è–∑—ã–∫, –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –∏ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏—é –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –ø–æ–¥ —Å–µ–±—è.",
    tutorialSkip: "–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å",
    tutorialNext: "–î–∞–ª—å—à–µ",
    tutorialDone: "–ó–∞–≤–µ—Ä—à–∏—Ç—å",
    tutorialProgress: "{{current}} –∏–∑ {{total}}",
    tabHintFeedTitle: "–ì–ª–∞–≤–Ω—ã–π —ç–∫—Ä–∞–Ω",
    tabHintFeedBody: "–§–∏–∫—Å–∏—Ä—É–π –∏–º–ø—É–ª—å—Å—ã –∏ –≤—ã–±–∏—Ä–∞–π: –∫–æ–ø–∏—Ç—å, –¥–æ–±–∞–≤–∏—Ç—å –≤ —Ü–µ–ª–∏ –∏–ª–∏ –æ—Ç–ª–æ–∂–∏—Ç—å –Ω–∞ –ø–æ—Ç–æ–º.",
    tabHintCartTitle: "–¶–µ–ª–∏",
    tabHintCartBody: "–°—Ç–∞–≤—å –º–µ—á—Ç—ã –≤ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –∏ –æ–±–Ω–æ–≤–ª—è–π –ø—Ä–æ–≥—Ä–µ—Å—Å, –∫–æ–≥–¥–∞ –∫–æ–ø–∏—à—å.",
    tabHintPendingTitle: "–ú–µ–Ω—é ¬´–î—É–º–∞–µ–º¬ª",
    tabHintPendingBody: "–û—Ç–ø—Ä–∞–≤–ª—è–π –ø–æ–∫—É–ø–∫–∏ –Ω–∞ –ø–∞—É–∑—É –∏ –≤–æ–∑–≤—Ä–∞—â–∞–π—Å—è —á–µ—Ä–µ–∑ 14 –¥–Ω–µ–π, —á—Ç–æ–±—ã —Ä–µ—à–∏—Ç—å —Ç—Ä–µ–∑–≤–æ.",
    tabHintPurchasesTitle: "–ù–∞–≥—Ä–∞–¥—ã",
    tabHintPurchasesBody: "–°–æ–±–∏—Ä–∞–π –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –∏ –∑–∞–ø—É—Å–∫–∞–π —á–µ–ª–ª–µ–Ω–¥–∂–∏ —Å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–º–∏ –º–æ–Ω–µ—Ç–∞–º–∏.",
    tabHintProfileTitle: "–ü—Ä–æ—Ñ–∏–ª—å",
    tabHintProfileBody: "–ù–∞—Å—Ç—Ä–∞–∏–≤–∞–π —Ç–µ–º—É, —è–∑—ã–∫, –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –∏ –ª–∏—á–Ω—ã–µ —Ü–µ–ª–∏.",
    tabHintGotIt: "–ü–æ–Ω—è—Ç–Ω–æ",
  },
  en: {
    appTagline: "An offline temptation board that keeps savings safe",
    tamagotchiHungryBubble: "üêü",
    tamagotchiFoodMenuTitle: "Almi's menu",
    tamagotchiFoodBoostLabel: "+{{percent}}% fullness",
    tamagotchiFoodWantLabel: "Want",
    tamagotchiSkinTitle: "Almi skins",
    tamagotchiSkinSubtitle: "A new vibe for Almi keeps your savings fresh",
    tamagotchiSkinCurrent: "Selected",
    tamagotchiSkinUnlockTitle: "Almost just launched üöÄ",
    tamagotchiSkinUnlockDescription:
      "Help us get better: send feedback to {{email}} and unlock every skin.",
    tamagotchiSkinUnlockButton: "Send feedback & unlock skins",
    tamagotchiSkinLockedBadge: "Locked",
    tamagotchiName: "Almi",
    tamagotchiFullnessLabel: "Fullness",
    tamagotchiCoinsLabel: "Coins",
    tamagotchiFedAtLabel: "Fed at",
    tamagotchiAwaitingFirstCoin: "Almi awaits the first coin",
    tamagotchiFullMessage: "Almi is already full. Come back later when she gets hungry.",
    tamagotchiEarnCoinsHint: "Earn coins via saves, levels, and rewards.",
    tamagotchiNeedCoinsMessage: "You need at least {{cost}} coins for {{emoji}}.",
    tamagotchiPartyNeedCoinsMessage: "You need {{amount}} blue coins to start a party.",
    tamagotchiPartyButtonLabel: "Party √ó{{cost}}",
    tamagotchiFullHint: "He is full, try again later.",
    tamagotchiSkinFeedbackSubject: "Feedback for Almost",
    tamagotchiSkinFeedbackBody: "Hi Almost team! Sharing my thoughts about the app:\\n\\n",
    heroAwaiting: "On the wish list",
    heroSpendLine: {
      female: "Latest save: ‚Äú{{title}}‚Äù.",
      male: "Latest save: ‚Äú{{title}}‚Äù.",
      none: "Latest save: ‚Äú{{title}}‚Äù.",
    },
    heroSpendRecentTitle: "Recent activity:",
    heroSpendFallback: "Every mindful pause fuels the freedom fund",
    heroEconomyContinues: "Savings continue.",
    heroExpand: "Show details",
    heroCollapse: "Hide details",
    heroDailyTitle: "Weekly savings/spend",
    heroDailyEmpty: "No skips yet. Try saving once this week.",
    defaultDeclineLabel: "Skip",
    defaultWishTitle: "Wish",
    heroWeeklySavingsDelta: "Saved",
    heroWeeklySpendingDelta: "Spent",
    feedEmptyTitle: "Nothing here",
    feedEmptySubtitle: "Try another tag or refresh the catalog",
    buyNow: "Pay with {{pay}}",
    addToCart: "Save for later",
    buyExternal: "Open product page",
    wishlistTitle: "Goals",
    wishlistEmptyTitle: "No goals yet",
    wishlistEmptySubtitle: "Pick a temptation from the feed and start saving for it",
    buyLabel: "Grab",
    buyAllLabel: "Check out everything",
    totalLabel: "Total",
    cartRemove: "Remove",
    wishlistTab: "Goals",
    wishlistProgress: "{{current}} of {{target}}",
    wishlistSavedHint: "How much you need to save",
    wishlistSaveProgress: "Update progress",
    wishlistSetActive: "Set active",
    wishlistActive: "Active goal",
    wishlistRemove: "Remove",
    wishlistRemoveConfirm: "Remove this wish?",
    wishlistDoneLabel: "Done",
    wishlistSummary: "Total targets worth {{amount}}",
    freeDayButton: "Free day",
    freeDayLocked: "After 6 pm",
    freeDayBlocked: "Unavailable",
    freeDayStatusAvailable: "Log day",
    freeDayStatusLogged: "Logged",
    freeDayLoggedToday: "Logged today",
    freeDayConfirm: "Stayed away from impulse buys today?",
    freeDayCongrats: "{{days}} day streak! Budget loves it.",
    freeDayMilestone: "{{days}} days in a row! New badge unlocked.",
    freeDayCardTitle: "Free-day streak",
    freeDayActiveLabel: "Streak {{days}} days",
    freeDayInactiveLabel: "Log an impulse-free evening",
    freeDayCurrentLabel: "Current",
    freeDayBestLabel: "Best",
    freeDayTotalShort: "Total",
    freeDayWeekTitle: "This week",
    freeDayExpand: "Show details",
    freeDayCollapse: "Hide",
    freeDayTotalLabel: "Total: {{total}}",
    freeDayRescueTitle: "Missed a day?",
    freeDayRescueSubtitle: "Spend {{cost}} health to keep the streak alive.",
    freeDayRescueButton: "Rescue streak",
    freeDayRescuePillLabel: "Rescue √ó{{count}}",
    freeDayRescueNeedHealth: "Need {{cost}} health",
    freeDayRescueNeedTime: "Available after 6 pm",
    freeDayRescueOverlay: "Streak rescued",
    freeDayCoinReward: "Free day logged: +{{coins}} blue coins.",
    freeDayCoinRewardStreak: "üî• {{days}}-day streak: +{{coins}} blue coins.",
    impulseCardTitle: "Impulse map",
    impulseCardSubtitle: "See when temptations usually win or when you stay strong.",
    impulseLoseLabel: "Weak spot",
    impulseLoseCopy: "{{temptation}} usually wins around {{time}}.",
    impulseLoseEmpty: "No weak spots yet.",
    impulseWinLabel: "Winning streak",
    impulseWinCopy: "You resist {{temptation}} most often around {{time}}.",
    impulseWinEmpty: "Wins will show up once you log more saves.",
    impulseTrendLabel: "Most impulses land in {{category}}",
    impulseCategorySave: "Saves: {{count}}",
    impulseCategorySpend: "Splurges: {{count}}",
    impulseAnytimeLabel: "any time",
    impulseExpand: "Expand",
    impulseCollapse: "Hide map",
    impulseAlertTitle: "Impulse alert",
    impulseAlertMessage:
      "You‚Äôre entering a high-impulse zone for {{temptation}} ({{window}}). Skip it and stash {{amount}}!",
    impulseNotificationTitle: "Almost spotted an impulse: ‚Äú{{temptation}}‚Äù",
    impulseNotificationBody: "You usually cave now. Take an Almost pause and stash {{amount}}.",
    impulseAlertBadgeLabel: "smart insight",
    impulseAlertWindowLabel: "Hot zone",
    impulseAlertAmountLabel: "At stake",
    impulseAlertButtonLabel: "Stay focused",
    impulseCategoryLabel: "Impulse category",
    focusDigestPositiveTitle: "Trend is on track",
    focusDigestPositiveBody:
      "You resist more than you spend.\nBiggest win: ‚Äú{{strong}}‚Äù.\nWatch ‚Äú{{weak}}‚Äù.",
    focusDigestNegativeTitle: "Time to refocus",
    focusDigestNegativeBody:
      "Spending is outpacing saves.\nBiggest leak: ‚Äú{{weak}}‚Äù. Focus on it.",
    focusDigestStrongLabel: "Biggest win",
    focusDigestWeakLabel: "Needs attention",
    focusDigestButton: "Focus",
    focusDigestDismiss: "Later",
    focusDigestMissing: "No data yet",
    focusBadgeLabel: "Focus",
    focusPromptTitle: "Refocus time",
    focusPromptBody: "You caved to ‚Äú{{title}}‚Äù a few times. Make it your focus?",
    focusVictoryReward: "Focus ‚Äú{{title}}‚Äù conquered! +3 green coins",
    focusRewardTitle: "Focus conquered!",
    focusRewardSubtitle: "You resisted ‚Äú{{title}}‚Äù three times. +{{amount}} green coins.",
    dailyReflectionReminderTitle: "Almost nightly check-in",
    dailyReflectionReminderBody:
      "{{time}} left today. Log a save or spend so our smart nudges stay relevant.",
    pendingTab: "Thinking",
    pendingTitle: "Thinking",
    pendingEmptyTitle: "Nothing in Thinking",
    pendingEmptySubtitle: "Park temptations in Thinking and we‚Äôll remind you in 14 days.",
    pendingDaysLeft: "{{days}} days left",
    pendingExpired: "Decision overdue",
    pendingDueToday: "Decide today",
    pendingActionWant: "Start saving",
    pendingActionDecline: "Save it",
    pendingNotificationTitle: "Almost check-in: decide on ‚Äú{{title}}‚Äù",
    pendingNotificationBody: "Two weeks are up. Start saving for ‚Äú{{title}}‚Äù or let it go?",
    pendingAdded: "Sent to Thinking. We‚Äôll remind you in 2 weeks.",
    pendingDeleteConfirm: "Remove this item from Thinking?",
    pendingCustomError: "Add a name and price for this temptation.",
    feedTab: "Inicio",
    profileTab: "Profile",
    payButton: "Pay",
    cartOverlay: "Savings updated",
    purchasesTitle: "Rewards",
    purchasesSubtitle: "Track achievements and remind yourself why you save",
    progressLabel: "Mindful level",
    progressGoal: "{{current}} / {{goal}}",
    progressHint: "Only {{amount}} left until ‚Äòbudget zen master‚Äô",
    emptyPurchases: "Nothing yet. Which already saves money",
    profileEdit: "Edit",
    profileSave: "Save",
    profileCancel: "Cancel",
    profileOk: "Ok",
    profileJoinDate: "Mindful saving since {{date}}",
    settingsTitle: "Settings & personalisation",
    analyticsOptInLabel: "Send anonymous analytics",
    analyticsOptInHint: "Helps improve Almost without sharing personal data",
    themeLabel: "Theme",
    themeLight: "Light",
    themeDark: "Dark",
    languageLabel: "Language",
    languageRussian: "–†—É—Å—Å–∫–∏–π",
    languageEnglish: "English",
    languageSpanish: "Spanish",
    languageFrench: "French",
    partialInfo: "Partial payment isn‚Äôt available for bundles",
    partialLabel: "Enter amount (up to {{amount}})",
    partialError: "Enter a value between 1 and the total cost",
    buyFull: "Pay full",
    buyPartial: "Pay partially",
    thinkLater: "Think later",
    wantAction: "Add to goals",
    saveAction: "Save it",
    maybeAction: "Think later",
    spendAction: "Spend it",
    editPrice: "Edit price",
    actionSoon: "Detailed flow is coming in the next update.",
    saveSpamWarningItem: "Looks like you tapped ‚ÄúSave it‚Äù on this card several times within five minutes. Take a short pause to avoid accidental taps.",
    saveSpamWarningGlobal: "Lots of fast ‚ÄúSave it‚Äù taps in a row. Double-check that it‚Äôs intentional and try again in a moment.",
    priceEditTitle: "Adjust the target amount",
    priceEditPlaceholder: "Enter amount",
    priceEditSave: "Save",
    priceEditReset: "Reset",
    priceEditCancel: "Cancel",
    priceEditDelete: "Delete temptation",
    priceEditDeleteConfirm: "Remove this temptation?",
    priceEditError: "Enter a positive number",
    priceEditNameLabel: "Card name",
    priceEditAmountLabel: "Amount ({{currency}})",
    wishAdded: "Added to wishes: {{title}}",
    wishDeclined: "+{{amount}} safely tucked away",
    customTemptationAdded: "Added to temptations: {{title}}",
    saveCelebrateTitlePrefix: "Skipped:",
    saveCelebrateSubtitle: "Almi purrs: savings up!",
    saveGoalRemaining: "Roughly {{count}} more skips to reach ‚Äú{{goal}}‚Äù.",
    saveGoalComplete: "Goal ‚Äú{{goal}}‚Äù reached! Celebrate the win.",
    saveOverlayCoinReward: "+{{amount}} coins for Almi",
    freeDayButton: "Free day",
    freeDayLocked: "After 6 pm",
    freeDayBlocked: "Unavailable",
    freeDayStatusAvailable: "Log day",
    freeDayStatusLogged: "Logged",
    freeDayLoggedToday: "Logged today",
    freeDayConfirm: "Stayed away from impulse buys today?",
    freeDayCongrats: "{{days}} day streak! Budget loves it.",
    freeDayMilestone: "{{days}} days in a row! New badge unlocked.",
    freeDayStreakLabel: "Free-day streak",
    freeDayTotalLabel: "Total: {{total}}",
    statsSpent: "Finished goals",
    statsSaved: "Saved",
    statsItems: "Goals",
    statsCart: "In list",
    statsDeclines: "Saves",
    statsSpends: "Spends",
    statsFreeDays: "Streak",
    savingsBreakdownTitle: "Savings breakdown",
    savingsBreakdownOtherLabel: "Other",
    analyticsTitle: "Progress",
    analyticsPendingToBuy: "Wishes",
    analyticsPendingToDecline: "Savings",
    analyticsFridgeCount: "Spends",
    analyticsBestStreak: "Free days",
    analyticsConsentTitle: "Help us improve?",
    analyticsConsentBody:
      "We collect anonymous analytics to see which moments inspire more saving. No personal data is stored.",
    analyticsConsentAgree: "Share analytics",
    analyticsConsentSkip: "Skip for now",
    onboardingBack: "Back",
    historyTitle: "Event log",
    historyEmpty: "Nothing yet. Add a goal or mark a free day.",
    privacyPolicyLink: "Privacy policy",
    privacyPolicyHint: "Opens in your browser.",
    supportLink: "Contact support",
    supportHint: "almostappsup@gmail.com",
    ratingPromptTitle: "Enjoying Almost?",
    ratingPromptBody: "If it helps tame impulse buys, leave a quick store review - it keeps the team motivated.",
    ratingPromptLater: "Maybe later",
    ratingPromptAction: "Rate Almost",
    levelShareButton: "Share level",
    levelShareModalTitle: "Level unlocked!",
    levelShareModalCaption: "Grab this card and hype your win",
    levelShareModalShare: "Share this card",
    levelShareModalClose: "Close",
    levelShareError: "Couldn‚Äôt share this time. Try again later.",
    levelShareShareMessage: "I'm already level {{level}} in Almost. Join the mindful crew!",
    levelShareCardBadge: "ALMOST HERO",
    levelShareCardTitle: "Level {{level}}",
    levelShareCardSubtitle: "Almi is cheering for me",
    levelShareJoin: "Join mindful spenders",
    levelShareFooterBrand: "Almost",
    levelShareFooterHint: "APP",
    historyWishAdded: "Wish added: {{title}}",
    historyWishProgress: "Progress ‚Äú{{title}}‚Äù: {{amount}} of {{target}}",
    historyWishDone: "Goal completed: {{title}}",
    historyDecline: "Declined {{title}} (+{{amount}} saved)",
    historyRefuseSpend: "Skipped {{title}} (+{{amount}} saved)",
    historyPendingAdded: "Queued for later: {{title}}",
    historyPendingWant: "Later decision ‚Üí saving: {{title}}",
    historyPendingDecline: "Later decision ‚Üí decline: {{title}} (+{{amount}})",
    historyPendingRemoved: "Removed from Thinking: {{title}}",
    historyFreeDay: "Free day #{{total}}",
    historySpend: "Spent on {{title}} (-{{amount}})",
    historyWishRemoved: "Goal removed: {{title}}",
    historyGoalStarted: "Goal started: {{title}}",
    historyGoalCancelled: "Goal cancelled: {{title}}",
    historyRewardClaimed: "Reward claimed: {{title}}",
    historyTimestamp: "{{date}} ¬∑ {{time}}",
    historyUnknown: "Event",
    progressHeroTitle: "Real savings",
    progressHeroLevel: "Level {{level}}",
    progressHeroNext: "To next level {{amount}}",
    levelCelebrate: "Level {{level}} unlocked, savings armor upgraded!",
    tileRefuseCount: "Already skipped {{count}}√ó ¬∑ +{{amount}}",
    tileRefuseMessage: "Skip it today and your savings will thank you",
    tileReady: "Ready to enjoy",
    tileLocked: "Still saving",
    spendWarning: "Spending {{amount}}. Sure about it?",
    spendSheetTitle: "Almost Pay",
    spendSheetSubtitle: "Our playful Pay suggests saving just a bit longer.",
    spendSheetHint: "Double-press (in spirit) to go ahead anyway.",
    spendSheetCancel: "Keep saving",
    spendSheetConfirm: "Spend anyway",
    stormOverlayMessage: "Stormy spending vibes. Still want to swipe?",
    rewardsEmpty: "Earn achievements by skipping temptations or logging a free day.",
    goalsTitle: "Goals & rewards",
    rewardUnlocked: "Unlocked",
    rewardLocked: "{{amount}} to go",
    rewardRemainingAmount: "{{amount}} to go",
    rewardRemainingDays: "{{count}} days remaining",
    rewardRemainingRefuse: "{{count}} more skips",
    rewardRemainingFridge: "{{count}} more Thinking items",
    rewardRemainingDecisions: "{{count}} Thinking decisions left",
    rewardLockedGeneric: "{{count}} steps remaining",
    rewardBadgeLabel: "Reward",
    rewardBadgeLabelPlural: "rewards",
    rewardBadgeClaimed: "Claimed!",
    rewardClaimCta: "Collect",
    rewardClaimHint: "Collect to gain {{amount}}",
    rewardClaimedStatus: "Health banked",
    rewardHealthBonus: "+{{amount}}",
    freeDayHealthTitle: "Coins",
    freeDayHealthSubtitle: "Spend to rescue streaks and feed Almi.",
    rewardCelebrateTitle: "{{title}} unlocked!",
    rewardCelebrateSubtitle: "Almi is proud-keep the streak going.",
    challengeTabTitle: "Challenges",
    challengeRewardsTabTitle: "Rewards",
    challengeStartCta: "Start challenge",
    challengeClaimCta: "Collect reward",
    challengeActiveCta: "In progress",
    challengeStatusAvailable: "Ready to start",
    challengeStatusActive: "Active",
    challengeStatusCompleted: "Ready to claim",
    challengeStatusExpired: "Expired",
    challengeStatusClaimed: "Completed",
    challengeRewardLabel: "Reward",
    challengeRewardHealth: "+{{amount}}",
    challengeProgressLabel: "{{current}} / {{target}}",
    challengeDurationLabel: "Duration: {{days}} days",
    challengeTimeLeftLabel: "{{time}} left",
    challengeTimeDayShort: "d",
    challengeTimeHourShort: "h",
    challengeTimeMinuteShort: "m",
    challengeTimeExpired: "Time is up",
    challengeReadyToClaim: "Reward ready",
    challengeRestartHint: "Repeat anytime ({{days}}-day run)",
    challengeStartedOverlay: "Challenge ‚Äú{{title}}‚Äù started",
    challengeCompletedOverlay: "‚Äú{{title}}‚Äù complete - collect the bonus!",
    challengeClaimedOverlay: "Challenge ‚Äú{{title}}‚Äù ¬∑ +{{amount}}",
    challengeReminderTitle: "Almost challenge ‚Äú{{title}}‚Äù",
    challengeReminderBody: "You're close to the finish. Log another save for ‚Äú{{title}}‚Äù and claim the reward.",
    challengeCancelAction: "Cancel",
    challengeAcceptConfirmTitle: "Start challenge?",
    challengeAcceptConfirmMessage: "Kick off ‚Äú{{title}}‚Äù? The timer starts right away.",
    challengeAcceptConfirmYes: "Start",
    challengeAcceptConfirmNo: "Not now",
    challengeCancelConfirmTitle: "Cancel this challenge?",
    challengeCancelConfirmMessage: "Stop ‚Äú{{title}}‚Äù? All progress will reset.",
    challengeCancelConfirmYes: "Cancel",
    challengeCancelConfirmNo: "Keep going",
    challengeLimitReachedAction: "Max {{limit}} challenges",
    challengeLimitReachedTitle: "Challenge limit",
    challengeLimitReachedMessage: "You can run at most {{limit}} challenges at once. Finish one to start another.",
    dailyChallengeOfferBadge: "daily challenge",
    dailyChallengeOfferTitle: "Today‚Äôs mini challenge",
    dailyChallengeOfferSubtitle: "Go a day without ‚Äú{{temptation}}‚Äù",
    dailyChallengeOfferHint: "Skip it once today and grab double rewards.",
    dailyChallengeOfferReward: "+{{amount}} bonus",
    dailyChallengeOfferAccept: "Accept challenge",
    dailyChallengeOfferLater: "Maybe later",
    dailyChallengeWidgetBadge: "daily challenge",
    dailyChallengeWidgetTitle: "Active mini challenge",
    dailyChallengeWidgetDesc: "Day without ‚Äú{{temptation}}‚Äù = coins x2",
    dailyChallengeWidgetProgress: "Progress {{current}} / {{target}}",
    dailyChallengeWidgetReward: "+{{amount}}",
    dailyChallengeRewardReason: "Mini challenge ‚Äú{{temptation}}‚Äù complete",
    dailyChallengeRewardNotificationTitle: "Almost daily challenge complete",
    dailyChallengeRewardNotificationBody: "‚Äú{{temptation}}‚Äù gave in - grab your +{{amount}} bonus.",
    dailyChallengeFailedText: "‚Äú{{temptation}}‚Äù won today",
    healthCelebrateTitle: "+{{amount}}",
    healthCelebrateSubtitle: "Use it to rescue your free-day streak.",
    healthCelebrateLevel: "Level up! Almi is happy.",
    healthCelebrateReward: "Reward collected - health restored.",
    rainMessage: "Oh no! Protect the cash.",
    developerReset: "Reset data",
    developerResetConfirm: "Clear wishes, history and profile?",
    developerResetCancel: "Keep",
    developerResetApply: "Reset",
    openSettings: "Settings",
    defaultDealTitle: "Goal",
    defaultDealDesc: "Describe what you‚Äôre saving for",
    photoLibrary: "From library",
    photoCamera: "Use camera",
    photoTapHint: "Tap to add a photo",
    photoPromptTitle: "Add a photo?",
    photoPromptSubtitle: "Choose camera or library",
    photoPermissionDenied: "We need camera or photo access to update your avatar.",
    photoPermissionSettings: "Open Settings to let Almost access the camera and photos.",
    photoPickerError: "Something went wrong. Please try again.",
    registrationTitle: "Let‚Äôs set things up",
    registrationSubtitle: "Tell us who you are so Almost speaks your language",
    languageTitle: "Choose a language",
    languageSubtitle: "We‚Äôll tailor every hint to you",
    languageCurrencyHint: "You can adjust language and currency later in Profile.",
    currencySwipeHint: "Swipe to view all currencies ‚Üí",
    languageTermsHint: "By continuing you accept Almost‚Äôs Terms of Use.",
    languageTermsAccepted: "Accept the Terms of Use to keep going.",
    languageTermsLink: "Read the full Terms of Use",
    inputFirstName: "First name",
    inputLastName: "Last name",
    inputMotto: "Personal motto",
    currencyLabel: "Savings currency",
    nextButton: "Continue",
    goalTitle: "Pick a goal",
    goalSubtitle: "Where should your mindful deals lead?",
    goalCustomSectionTitle: "Your goals",
    goalCustomCreate: "Add your own goal",
    goalButton: "Start saving",
    goalPrimaryBadge: "Primary goal",
    goalTargetTitle: "How big is this goal?",
    goalTargetSubtitle: "Set the amount so Almost tracks every dollar toward it.",
    goalTargetPlaceholder: "Enter amount",
    goalTargetHint: "You can edit the amount later in the profile.",
    goalTargetCTA: "Save amount",
    goalTargetError: "Enter a goal amount",
    goalTargetLabel: "Goal amount",
    primaryGoalLabel: "Primary goal",
    primaryGoalLocked: "Change this goal later from your profile.",
    primaryGoalRemaining: "Remaining {{amount}}",
    goalWidgetTargetLabel: "Goal: {{amount}}",
    goalWidgetRemaining: "{{amount}} to go",
    goalWidgetComplete: "Goal completed",
    goalWidgetTitle: "To goal",
    goalWidgetCompleteTagline: "Savings kept rolling - mission accomplished.",
    goalAssignPromptTitle: "Where should this savings go?",
    goalAssignPromptSubtitle: "Pick the goal that ‚Äú{{title}}‚Äù will fund.",
    goalAssignNone: "No goal yet",
    goalAssignTemptationTitle: "Assign temptation",
    goalAssignTemptationSubtitle: "Which habit fills ‚Äú{{goal}}‚Äù?",
    goalAssignClear: "Clear assignment",
    goalAssignFieldLabel: "Sends savings to",
    goalMainTemptationError: "The main temptation can‚Äôt be turned into a goal.",
    goalDestinationLabel: "Saving for",
    goalStatusInWishlist: "Add to goal",
    goalSwipeAdd: "Add to goal",
    goalSwipeDelete: "Delete",
    goalPinnedBadge: "Goal",
    goalRemoved: "Goal removed",
    goalEditAction: "Edit",
    goalDeleteAction: "Remove",
    goalEditModalTitle: "Edit goal",
    goalEditNameLabel: "Goal name",
    goalEditTargetLabel: "Goal amount",
    goalEditEmojiLabel: "Goal emoji",
    goalEditSave: "Save",
    goalEditCancel: "Cancel",
    goalEditNameError: "Enter a goal name",
    goalEditTargetError: "Set a goal amount",
    goalCelebrationTitle: "Main goal complete!",
    goalCelebrationSubtitle: "Almi is proud - time to pick the next dream.",
    goalCelebrationTarget: "Saved {{amount}}",
    goalRenewalTitle: "Pick a new main goal",
    goalRenewalSubtitle: "You finished this one - lock in a fresh target to keep the streak alive.",
    goalRenewalCreate: "Set new goal",
    goalRenewalLater: "Later",
    levelWidgetTitle: "Level progress",
    levelWidgetCurrent: "Level {{level}}",
    levelWidgetSubtitle: "{{amount}} to the next level",
    levelWidgetTarget: "Next level at {{amount}} total",
    levelWidgetMaxed: "Top level reached - legendary saver!",
    onboardingGuideTitle: "What Almost is about",
    onboardingGuideSubtitle: "A mindful antidote to consumerism and impulse buys.",
    onboardingGuideButton: "Got it",
    termsTitle: "Terms of Use",
    termsSubtitle: "Please review the key points. Continuing means you agree to the Almost Terms.",
    termsViewFull: "Open the full document",
    termsLinkHint: "We‚Äôll open the document in your browser.",
    termsAccept: "I agree",
    termsDecline: "Not now",
    guideStepTrackTitle: "Your main mission",
    guideStepTrackDesc: "Spend consciously, protect the budget, and focus on the goals that actually matter.",
    guideStepDecisionTitle: "Temptation menu",
    guideStepDecisionDesc: "Log each temptation and resist it so Almost records the win and keeps that cash untouched.",
    guideStepRewardTitle: "See the big picture",
    guideStepRewardDesc: "Check off every saved item and watch the app visualize the bigger goal you‚Äôre working toward.",
    personaTitle: "Tell us about you",
    personaSubtitle: "Tell us about yourself so the app can be personalized.",
    personaGenderLabel: "How should we address you?",
    personaHabitLabel: "Pick a starter profile",
    personaConfirm: "Continue",
    customSpendTitle: "Your daily temptation",
    customSpendSubtitle: "Give it a short name and Almost will help you resist it more often.",
    customSpendNamePlaceholder: "Morning latte, cigarettes, nail art‚Ä¶",
    customSpendAmountLabel: "Cost per attempt",
    customSpendAmountPlaceholder: "Enter amount",
    customSpendFrequencyLabel: "How many times per week does it usually win?",
    customSpendFrequencyPlaceholder: "E.g. 4",
    customSpendHint: "You can change this anytime in the profile.",
    customSpendSkip: "Skip for now",
    smartReminderTitle: [
      "Almost spotted ‚Äú{{temptation}}‚Äù",
      "Almi flags ‚Äú{{temptation}}‚Äù",
      "Almost ping: ‚Äú{{temptation}}‚Äù",
    ],
    smartReminderBody: [
      "You logged ‚Äú{{temptation}}‚Äù recently. Repeat the pause and send the cash to your goal.",
      "Almost flagged this routine - take a breath before ‚Äú{{temptation}}‚Äù and choose savings.",
      "Keep the streak alive. ‚Äú{{temptation}}‚Äù can wait a little longer.",
      "Smart tip: every time you skip ‚Äú{{temptation}}‚Äù, Almost keeps your insights sharp.",
    ],
    smartInsightDeclineTitle: "Yesterday‚Äôs win: ‚Äú{{temptation}}‚Äù",
    smartInsightDeclineBody: "Say no again today and Almost will lock in the streak.",
    smartInsightSpendTitle: "Yesterday ‚Äú{{temptation}}‚Äù won",
    smartInsightSpendBody: "Hold the line today so Almost can celebrate a save.",
    dailyNudgeMorningTitle: ["Morning nudge from Almost", "Focus check from Almi"],
    dailyNudgeMorningBody: [
      "Set the tone: skip the first impulse and remember your goal.",
      "Almi is checking in - pause before the first swipe today.",
    ],
    dailyNudgeDayTitle: ["Midday Almost check-in", "Focus boost from Almi"],
    dailyNudgeDayBody: [
      "Afternoon impulses climb. Ask if this buy still serves your goal.",
      "Almost noticed lunch-time splurges. Take a mindful pause.",
    ],
    dailyNudgeAfternoonTitle: ["Post-lunch ping from Almost", "Tap the brakes with Almi"],
    dailyNudgeAfternoonBody: [
      "Take a breath before tapping buy and reroute that money to savings.",
      "Temptations creeping in? Hold the line and remember your goal.",
    ],
    dailyNudgeEveningTitle: ["Evening shield from Almost", "Almi wraps up your day"],
    dailyNudgeEveningBody: [
      "Evenings tempt the most. Log a win before bed.",
      "Close the day inside Almost - even a tiny save keeps nudges smart.",
    ],
    dailySummaryBadgeLabel: "daily recap",
    dailySummaryTitle: "Today‚Äôs recap",
    dailySummarySubtitle: "Great momentum - keep it up!",
    dailySummarySavedLabel: "Saved today",
    dailySummarySavedSub: "Every skip nudges the goal closer",
    dailySummarySpendsLabel: "Spends",
    dailySummaryContinue: "Continue",
    dailySummaryHint: "See you tomorrow with fresh numbers.",
    baselineTitle: "How much slips on small stuff?",
    baselineSubtitle: "Estimate one month of coffees, snacks and impulse buys to compare with real wins.",
    baselinePlaceholder: "Enter amount",
    baselineCTA: "Save amount",
    baselineHint: "Rough number is fine - you can tweak it later in Profile.",
    baselineInputError: "Enter your rough monthly spend on non‚Äëessentials",
    potentialBlockTitle: "Potential vs real savings",
    potentialBlockSubtitle: "",
    potentialBlockStatusAhead: "Whoa, you‚Äôre beating the forecast!",
    potentialBlockStatusStart: "Start logging wins - the potential is waiting.",
    potentialBlockStatusBehind: "You're on track, but there‚Äôs even more potential.",
    potentialBlockStatusOnTrack: "You‚Äôre tapping almost all the potential. Keep going!",
    potentialBlockActualLabel: "Actually saved",
    potentialBlockPotentialLabel: "Potential",
    potentialBlockHint: "There‚Äôs still {{amount}} of potential left. Keep it up üôÇ",
    potentialBlockDetails:
      "It grabs the monthly temptation budget you set during onboarding, slices it into seconds, and shows how much you could have already saved right now.",
    potentialBlockCta: "Tell us how much usually slips on small extras and we‚Äôll show the potential savings.",
    potentialPushAheadTitle: "Ahead of potential!",
    potentialPushAheadBody:
      "The potential counter just hit {{potential}}, and you‚Äôre already at {{actual}}. Keep that streak going!",
    potentialPushBehindTitle: "Catch potential up",
    potentialPushBehindBody:
      "Potential is already {{potential}} ‚Äì only {{shortfall}} to catch up. Pause before the next purchase and log a win.",
    quickCustomTitle: "Add temptation",
    quickCustomSubtitle: "Name the impulse and set a price to add it to the deck",
    quickCustomNameLabel: "Name",
    quickCustomAmountLabel: "Cost ({{currency}})",
    quickCustomEmojiLabel: "Card emoji",
    quickCustomConfirm: "Add",
    quickCustomCancel: "Cancel",
    coinEntryTitle: "How much?",
    coinEntrySubtitle: "Slide the coin and pick a category.",
    coinEntryHint: "Use the buttons above to save or spend.",
    coinEntryManual: "...",
    coinEntryManualTitle: "Set new slider max",
    coinEntryManualPlaceholder: "Enter amount",
    coinEntryManualSave: "Remember",
    coinEntryManualCancel: "Cancel",
    coinEntryManualError: "Enter a valid amount",
    coinEntryManualAmountTitle: "Enter custom amount",
    coinEntryManualAmountPlaceholder: "Enter amount",
    coinEntryCategoryLabel: "Category",
    coinEntryCategoryError: "Pick a category first",
    coinEntrySaveLabel: "Quick save",
    coinEntrySpendLabel: "Quick spend",
    fabNewGoal: "New goal",
    fabNewTemptation: "New spend",
    fabQuickActionTitle: "Last temptation",
    fabQuickActionSubtitle: "Repeat action for ‚Äú{{title}}‚Äù",
    fabQuickActionEmpty: "No recent temptation yet. Interact with a card first.",
    fabTutorialTitle: "Meet the ‚Äú+‚Äù",
    fabTutorialDesc:
      "Tap to log a custom impulse with your own amount and category. Hold to create new goals or custom spends.",
    fabTutorialAction: "Got it",
    newGoalTitle: "New goal",
    newGoalSubtitle: "Name the dream and set its target.",
    newGoalNameLabel: "Goal name",
    newGoalTargetLabel: "Target ({{currency}})",
    newGoalEmojiLabel: "Goal emoji",
    newGoalCreate: "Create goal",
    newGoalCancel: "Cancel",
    newPendingTitle: "New Thinking item",
    newPendingSubtitle: "Describe the temptation you want to park for 14 days.",
    newPendingNameLabel: "Name",
    newPendingAmountLabel: "Price ({{currency}})",
    newPendingEmojiLabel: "Card emoji",
    newPendingCreate: "Add to Thinking",
    newPendingCancel: "Cancel",
    tutorialFeedTitle: "Temptation feed",
    tutorialFeedDesc: "Log every impulse and choose: save it, add to goals, or park it for 14 days.",
    tutorialGoalsTitle: "Goals",
    tutorialGoalsDesc: "All dreams live here. Track progress and top up your goal.",
    tutorialThinkingTitle: "Thinking tab",
    tutorialThinkingDesc: "Park temptations for 14 days and return with a cooler head before deciding.",
    tutorialRewardsTitle: "Rewards & challenges",
    tutorialRewardsDesc: "Visit this tab to claim achievements and start challenges with bonus health.",
    tutorialProfileTitle: "Profile & motivation",
    tutorialProfileDesc: "Adjust theme, language, reminders, and all personalization tweaks that keep Almost yours.",
    tutorialSkip: "Skip",
    tutorialNext: "Next",
    tutorialDone: "Finish",
    tutorialProgress: "{{current}} of {{total}}",
    tabHintFeedTitle: "Temptation feed",
    tabHintFeedBody: "Log impulses here and decide to save, add to goals, or park for later.",
    tabHintCartTitle: "Goals",
    tabHintCartBody: "Track your dreams, set priorities, and update progress as you save.",
    tabHintPendingTitle: "Thinking tab",
    tabHintPendingBody: "Send wants to a 14-day pause and come back with a cooler head.",
    tabHintPurchasesTitle: "Rewards",
    tabHintPurchasesBody: "Claim achievements and start challenges for bonus health coins.",
    tabHintProfileTitle: "Profile",
    tabHintProfileBody: "Tune theme, language, reminders, and personal targets.",
    tabHintGotIt: "Got it",
  },  fr: {
    appTagline: "Un tableau hors ligne des tentations qui prot√®ge tes √©conomies",
    tamagotchiHungryBubble: "üêü",
    tamagotchiFoodMenuTitle: "Menu d'Almi",
    tamagotchiFoodBoostLabel: "+{{percent}} % de sati√©t√©",
    tamagotchiFoodWantLabel: "Je veux",
    tamagotchiSkinTitle: "Apparences d'Almi",
    tamagotchiSkinSubtitle: "Un nouveau style pour Almi ravive ta motivation d'√©pargner",
    tamagotchiSkinCurrent: "Actif",
    tamagotchiSkinUnlockTitle: "Almost vient d'arriver üöÄ",
    tamagotchiSkinUnlockDescription:
      "Aide-nous √† progresser : envoie ton avis √† {{email}} et d√©bloque tous les skins.",
    tamagotchiSkinUnlockButton: "Envoyer un avis et d√©bloquer les skins",
    tamagotchiSkinLockedBadge: "Verrouill√©",
    tamagotchiName: "Almi",
    tamagotchiFullnessLabel: "Sati√©t√©",
    tamagotchiCoinsLabel: "Pi√®ces",
    tamagotchiFedAtLabel: "Nourri √†",
    tamagotchiAwaitingFirstCoin: "Almi attend sa premi√®re pi√®ce",
    tamagotchiFullMessage: "Almi est repue pour l'instant. Reviens quand elle aura faim.",
    tamagotchiEarnCoinsHint: "Gagne des pi√®ces via tes refus, niveaux et r√©compenses.",
    tamagotchiNeedCoinsMessage: "Il faut au moins {{cost}} pi√®ces pour {{emoji}}.",
    tamagotchiPartyNeedCoinsMessage: "Il faut {{amount}} pi√®ces bleues pour lancer la f√™te.",
    tamagotchiPartyButtonLabel: "F√™te √ó{{cost}}",
    tamagotchiFullHint: "Elle est rassasi√©e, r√©essaie plus tard.",
    tamagotchiSkinFeedbackSubject: "Avis pour Almost",
    tamagotchiSkinFeedbackBody: "Salut l'√©quipe Almost ! Je partage mes impressions sur l'app :\n\n",
    heroAwaiting: "Dans la liste de souhaits",
    heroSpendLine: {
      female: "Derni√®re √©conomie : ¬´ {{title}} ¬ª.",
      male: "Derni√®re √©conomie : ¬´ {{title}} ¬ª.",
      none: "Derni√®re √©conomie : ¬´ {{title}} ¬ª.",
    },
    heroSpendRecentTitle: "Activit√© r√©cente :",
    heroSpendFallback: "Chaque pause consciente alimente ton fonds de libert√©",
    heroEconomyContinues: "L'√©pargne continue.",
    heroExpand: "Voir les d√©tails",
    heroCollapse: "Masquer",
    heroDailyTitle: "√âpargne/d√©penses de la semaine",
    heroDailyEmpty: "Aucun refus pour l'instant. Essaie d'√©conomiser une fois cette semaine.",
    defaultDeclineLabel: "Refuser",
    defaultWishTitle: "Envie",
    heroWeeklySavingsDelta: "√âconomis√©",
    heroWeeklySpendingDelta: "D√©pens√©",
    feedEmptyTitle: "Rien ici",
    feedEmptySubtitle: "Essaie un autre tag ou rafra√Æchis le catalogue",
    buyNow: "Payer avec {{pay}}",
    addToCart: "Mettre de c√¥t√©",
    buyExternal: "Ouvrir la fiche produit",
    wishlistTitle: "Objectifs",
    wishlistEmptyTitle: "Aucun objectif pour l'instant",
    wishlistEmptySubtitle: "Choisis une tentation dans le flux et commence √† √©conomiser",
    buyLabel: "Prendre",
    buyAllLabel: "Tout valider",
    totalLabel: "Total",
    cartRemove: "Supprimer",
    wishlistTab: "Objectifs",
    wishlistProgress: "{{current}} sur {{target}}",
    wishlistSavedHint: "Montant √† √©conomiser",
    wishlistSaveProgress: "Mettre √† jour",
    wishlistSetActive: "Activer",
    wishlistActive: "Objectif actif",
    wishlistRemove: "Retirer",
    wishlistRemoveConfirm: "Retirer cette envie ?",
    wishlistDoneLabel: "Termin√©",
    wishlistSummary: "Objectifs totalisant {{amount}}",
    freeDayButton: "Jour gratuit",
    freeDayLocked: "Apr√®s 18 h",
    freeDayBlocked: "Indisponible",
    freeDayStatusAvailable: "Enregistrer",
    freeDayStatusLogged: "Enregistr√©",
    freeDayLoggedToday: "Not√© aujourd'hui",
    freeDayConfirm: "Tu as √©vit√© les achats impulsifs aujourd'hui ?",
    freeDayCongrats: "S√©rie de {{days}} jours ! Ton budget adore.",
    freeDayMilestone: "{{days}} jours d'affil√©e ! Nouveau badge.",
    freeDayCardTitle: "S√©rie de jours gratuits",
    freeDayActiveLabel: "S√©rie {{days}} jours",
    freeDayInactiveLabel: "Note une soir√©e sans impulsion",
    freeDayCurrentLabel: "Actuel",
    freeDayBestLabel: "Record",
    freeDayTotalShort: "Total",
    freeDayWeekTitle: "Cette semaine",
    freeDayExpand: "Voir les d√©tails",
    freeDayCollapse: "Masquer",
    freeDayTotalLabel: "Total : {{total}}",
    freeDayRescueTitle: "Jour manqu√© ?",
    freeDayRescueSubtitle: "D√©pense {{cost}} de sant√© pour sauver la s√©rie.",
    freeDayRescueButton: "Sauver la s√©rie",
    freeDayRescuePillLabel: "Sauver √ó{{count}}",
    freeDayRescueNeedHealth: "Besoin de {{cost}} sant√©",
    freeDayRescueNeedTime: "Disponible apr√®s 18 h",
    freeDayRescueOverlay: "S√©rie sauv√©e",
    freeDayCoinReward: "Jour gratuit enregistr√© : +{{coins}} pi√®ces bleues.",
    freeDayCoinRewardStreak: "üî• S√©rie de {{days}} jours : +{{coins}} pi√®ces bleues.",
    impulseCardTitle: "Carte des impulsions",
    impulseCardSubtitle: "Vois quand les tentations gagnent ou quand tu restes solide.",
    impulseLoseLabel: "Zone fragile",
    impulseLoseCopy: "{{temptation}} gagne souvent vers {{time}}.",
    impulseLoseEmpty: "Encore aucune zone faible.",
    impulseWinLabel: "S√©rie gagnante",
    impulseWinCopy: "Tu r√©sistes le plus souvent √† {{temptation}} vers {{time}}.",
    impulseWinEmpty: "Les victoires appara√Ætront quand tu loggueras plus d'√©conomies.",
    impulseTrendLabel: "La plupart des impulsions tombent dans {{category}}",
    impulseCategorySave: "√âconomies : {{count}}",
    impulseCategorySpend: "Craquages : {{count}}",
    impulseAnytimeLabel: "n'importe quand",
    impulseExpand: "D√©ployer",
    impulseCollapse: "Masquer la carte",
    impulseAlertTitle: "Alerte d'impulsion",
    impulseAlertMessage:
      "Tu entres dans une zone √† forte impulsion pour {{temptation}} ({{window}}). R√©siste et mets {{amount}} de c√¥t√© !",
    impulseNotificationTitle: "Almost a d√©tect√© l'impulsion : ¬´ {{temptation}} ¬ª",
    impulseNotificationBody: "Tu c√®des d'habitude maintenant. Fais une pause Almost et √©conomise {{amount}}.",
    impulseAlertBadgeLabel: "astuce intelligente",
    impulseAlertWindowLabel: "Zone chaude",
    impulseAlertAmountLabel: "En jeu",
    impulseAlertButtonLabel: "Rester concentr√©(e)",
    impulseCategoryLabel: "Cat√©gorie d'impulsion",
    focusDigestPositiveTitle: "La tendance est bonne",
    focusDigestPositiveBody:
      "Tu r√©sistes plus que tu ne d√©penses.\nPlus belle victoire : ¬´ {{strong}} ¬ª.\nSurveille ¬´ {{weak}} ¬ª.",
    focusDigestNegativeTitle: "Il faut se recentrer",
    focusDigestNegativeBody:
      "Les d√©penses d√©passent les √©conomies.\nPire fuite : ¬´ {{weak}} ¬ª. Concentre-toi dessus.",
    focusDigestStrongLabel: "Plus belle victoire",
    focusDigestWeakLabel: "√Ä surveiller",
    focusDigestButton: "Focus",
    focusDigestDismiss: "Plus tard",
    focusDigestMissing: "Pas encore de donn√©es",
    focusBadgeLabel: "Focus",
    focusPromptTitle: "Moment de focus",
    focusPromptBody: "Tu as c√©d√© plusieurs fois √† ¬´ {{title}} ¬ª. On en fait ton focus ?",
    focusVictoryReward: "Focus ¬´ {{title}} ¬ª dompt√© ! +3 pi√®ces vertes",
    focusRewardTitle: "Focus vaincu",
    focusRewardSubtitle: "Tu as r√©sist√© trois fois √† ¬´ {{title}} ¬ª. +{{amount}} pi√®ces vertes.",
    dailyReflectionReminderTitle: "Check-in du soir Almost",
    dailyReflectionReminderBody:
      "Il reste {{time}} aujourd'hui. Note une √©conomie ou une d√©pense pour garder nos rappels pertinents.",
    pendingTab: "En pause",
    pendingTitle: "En pause",
    pendingEmptyTitle: "Aucun √©l√©ment en pause",
    pendingEmptySubtitle: "Mets les tentations en pause et on te relance dans 14 jours.",
    pendingDaysLeft: "{{days}} jours restants",
    pendingExpired: "D√©cision en retard",
    pendingDueToday: "D√©cider aujourd'hui",
    pendingActionWant: "Commencer √† √©pargner",
    pendingActionDecline: "√âconomiser",
    pendingNotificationTitle: "Almost te relance : que faire de ¬´ {{title}} ¬ª ?",
    pendingNotificationBody: "Deux semaines sont pass√©es. On commence √† √©pargner pour ¬´ {{title}} ¬ª ou on laisse tomber ?",
    pendingAdded: "Envoy√© en pause. Rappel dans 2 semaines.",
    pendingDeleteConfirm: "Retirer cet √©l√©ment de En pause ?",
    pendingCustomError: "Ajoute un nom et un prix pour cette tentation.",
    feedTab: "Flux",
    profileTab: "Profil",
    payButton: "Payer",
    cartOverlay: "√âpargne mise √† jour",
    purchasesTitle: "Bonus",
    purchasesSubtitle: "Suis tes succ√®s et rappelle-toi pourquoi tu √©conomises",
    progressLabel: "Niveau de conscience",
    progressGoal: "{{current}} / {{goal}}",
    progressHint: "Plus que {{amount}} avant le statut ‚Äòma√Ætre zen du budget‚Äô",
    emptyPurchases: "Rien encore. Ce qui fait d√©j√† √©conomiser",
    profileEdit: "Modifier",
    profileSave: "Enregistrer",
    profileCancel: "Annuler",
    profileOk: "Ok",
    profileJoinDate: "√âpargne consciente depuis le {{date}}",
    settingsTitle: "R√©glages et personnalisation",
    analyticsOptInLabel: "Envoyer des donn√©es anonymes",
    analyticsOptInHint: "√áa aide Almost √† s'am√©liorer sans partager de donn√©es perso",
    themeLabel: "Th√®me",
    themeLight: "Clair",
    themeDark: "Sombre",
    languageLabel: "Langue",
    languageRussian: "–†—É—Å—Å–∫–∏–π",
    languageEnglish: "English",
    languageSpanish: "Espa√±ol",
    languageFrench: "Fran√ßais",
    partialInfo: "Le paiement partiel n'est pas dispo pour les lots",
    partialLabel: "Entre un montant (jusqu'√† {{amount}})",
    partialError: "Entre une valeur entre 1 et le total",
    buyFull: "Payer en entier",
    buyPartial: "Payer partiellement",
    thinkLater: "R√©fl√©chir plus tard",
    wantAction: "Ajouter aux objectifs",
    saveAction: "√âconomiser",
    maybeAction: "Je verrai",
    spendAction: "D√©penser",
    editPrice: "Modifier le prix",
    actionSoon: "Le flux d√©taill√© arrive dans la prochaine mise √† jour.",
    saveSpamWarningItem:
      "On dirait que tu as tap√© ¬´ √âconomiser ¬ª plusieurs fois sur cette carte en cinq minutes. Fais une pause pour √©viter les appuis accidentels.",
    saveSpamWarningGlobal:
      "Beaucoup de taps rapides sur ¬´ √âconomiser ¬ª. V√©rifie que c'est volontaire et r√©essaie dans un instant.",
    priceEditTitle: "Ajuster le montant cible",
    priceEditPlaceholder: "Entre un montant",
    priceEditSave: "Enregistrer",
    priceEditReset: "R√©initialiser",
    priceEditCancel: "Annuler",
    priceEditDelete: "Supprimer la tentation",
    priceEditDeleteConfirm: "Supprimer cette tentation ?",
    priceEditError: "Entre un nombre positif",
    priceEditNameLabel: "Nom de la carte",
    priceEditAmountLabel: "Montant ({{currency}})",
    wishAdded: "Ajout√© aux envies : {{title}}",
    wishDeclined: "+{{amount}} mis de c√¥t√©",
    customTemptationAdded: "Ajout√© aux tentations : {{title}}",
    saveCelebrateTitlePrefix: "Saut√© :",
    saveCelebrateSubtitle: "Almi ronronne : √©conomise engrang√©e !",
    saveGoalRemaining: "Encore environ {{count}} refus pour atteindre ¬´ {{goal}} ¬ª.",
    saveGoalComplete: "Objectif ¬´ {{goal}} ¬ª atteint ! On c√©l√®bre ?",
    saveOverlayCoinReward: "+{{amount}} pi√®ces pour Almi",
    freeDayStreakLabel: "S√©rie de jours gratuits",
    freeDayTotalLabel: "Total : {{total}}",
    statsSpent: "Objectifs finis",
    statsSaved: "√âconomis√©",
    statsItems: "Objectifs",
    statsCart: "Dans la liste",
    statsDeclines: "Refus",
    statsSpends: "D√©penses",
    statsFreeDays: "S√©rie",
    savingsBreakdownTitle: "R√©partition de l'√©pargne",
    savingsBreakdownOtherLabel: "Autres",
    analyticsTitle: "Progression",
    analyticsPendingToBuy: "Envies",
    analyticsPendingToDecline: "√âconomies",
    analyticsFridgeCount: "D√©penses",
    analyticsBestStreak: "Jours gratuits",
    analyticsConsentTitle: "Tu nous aides √† progresser ?",
    analyticsConsentBody:
      "On collecte des stats anonymes pour savoir quels moments inspirent plus d'√©pargne. Aucune donn√©e perso n'est stock√©e.",
    analyticsConsentAgree: "Partager les stats",
    analyticsConsentSkip: "Ignorer pour l'instant",
    onboardingBack: "Retour",
    historyTitle: "Journal des √©v√©nements",
    historyEmpty: "Rien pour l'instant. Ajoute un objectif ou note un jour gratuit.",
    privacyPolicyLink: "Politique de confidentialit√©",
    privacyPolicyHint: "S'ouvrira dans ton navigateur.",
    supportLink: "Contacter le support",
    supportHint: "almostappsup@gmail.com",
    ratingPromptTitle: "Almost te pla√Æt ?",
    ratingPromptBody:
      "Si l'app aide √† calmer les achats impulsifs, laisse une √©valuation rapide dans le store - √ßa motive l'√©quipe.",
    ratingPromptLater: "Plus tard",
    ratingPromptAction: "Noter Almost",
    levelShareButton: "Partager mon niveau",
    levelShareModalTitle: "Niveau d√©bloqu√© !",
    levelShareModalCaption: "Capture cette carte et c√©l√®bre ta victoire",
    levelShareModalShare: "Partager la carte",
    levelShareModalClose: "Fermer",
    levelShareError: "Impossible de partager cette fois. R√©essaie plus tard.",
    levelShareShareMessage: "Je suis d√©j√† niveau {{level}} dans Almost. Rejoins l'√©quipe mindful !",
    levelShareCardBadge: "ALMOST HERO",
    levelShareCardTitle: "Niveau {{level}}",
    levelShareCardSubtitle: "Almi m'encourage",
    levelShareJoin: "Rejoins les d√©pensiers conscients",
    levelShareFooterBrand: "Almost",
    levelShareFooterHint: "APP",
    historyWishAdded: "Envie ajout√©e : {{title}}",
    historyWishProgress: "Progression ¬´ {{title}} ¬ª : {{amount}} / {{target}}",
    historyWishDone: "Objectif termin√© : {{title}}",
    historyDecline: "Refus√© {{title}} (+{{amount}} √©conomis√©s)",
    historyRefuseSpend: "Saut√© {{title}} (+{{amount}} √©conomis√©s)",
    historyPendingAdded: "Mis de c√¥t√© pour plus tard : {{title}}",
    historyPendingWant: "D√©cision diff√©r√©e ‚Üí on √©pargne : {{title}}",
    historyPendingDecline: "D√©cision diff√©r√©e ‚Üí refus : {{title}} (+{{amount}})",
    historyPendingRemoved: "Retir√© de En pause : {{title}}",
    historyFreeDay: "Jour gratuit n¬∞{{total}}",
    historySpend: "D√©pens√© pour {{title}} (-{{amount}})",
    historyWishRemoved: "Objectif retir√© : {{title}}",
    historyGoalStarted: "Objectif lanc√© : {{title}}",
    historyGoalCancelled: "Objectif annul√© : {{title}}",
    historyRewardClaimed: "R√©compense r√©cup√©r√©e : {{title}}",
    historyTimestamp: "{{date}} ¬∑ {{time}}",
    historyUnknown: "√âv√©nement",
    progressHeroTitle: "√âpargne r√©elle",
    progressHeroLevel: "Niveau {{level}}",
    progressHeroNext: "Encore {{amount}} jusqu'au suivant",
    levelCelebrate: "Niveau {{level}} d√©bloqu√©, armure d'√©pargne am√©lior√©e !",
    tileRefuseCount: "D√©j√† refus√© {{count}}√ó ¬∑ +{{amount}}",
    tileRefuseMessage: "Dis-lui non aujourd'hui, tes √©conomies diront merci",
    tileReady: "Pr√™t √† profiter",
    tileLocked: "Encore en √©pargne",
    spendWarning: "Tu vas d√©penser {{amount}}. C'est s√ªr ?",
    spendSheetTitle: "Almost Pay",
    spendSheetSubtitle: "Notre Pay joueur sugg√®re d'√©conomiser encore un peu.",
    spendSheetHint: "Double-tape (en esprit) pour continuer quand m√™me.",
    spendSheetCancel: "Continuer √† √©pargner",
    spendSheetConfirm: "D√©penser malgr√© tout",
    stormOverlayMessage: "Ambiance de d√©penses orageuse. Tu veux toujours valider ?",
    rewardsEmpty: "Gagne des succ√®s en refusant les tentations ou en notant un jour gratuit.",
    goalsTitle: "Objectifs & r√©compenses",
    rewardUnlocked: "D√©bloqu√©e",
    rewardLocked: "Encore {{amount}}",
    rewardRemainingAmount: "Encore {{amount}}",
    rewardRemainingDays: "{{count}} jours restants",
    rewardRemainingRefuse: "Encore {{count}} refus",
    rewardRemainingFridge: "Encore {{count}} √©l√©ments en pause",
    rewardRemainingDecisions: "{{count}} d√©cisions En pause restantes",
    rewardLockedGeneric: "Encore {{count}} √©tapes",
    rewardBadgeLabel: "R√©compense",
    rewardBadgeLabelPlural: "r√©compenses",
    rewardBadgeClaimed: "R√©colt√©e !",
    rewardClaimCta: "R√©cup√©rer",
    rewardClaimHint: "Permet de gagner {{amount}}",
    rewardClaimedStatus: "Sant√© stock√©e",
    rewardHealthBonus: "+{{amount}}",
    freeDayHealthTitle: "Pi√®ces",
    freeDayHealthSubtitle: "√Ä utiliser pour sauver tes s√©ries et nourrir Almi.",
    rewardCelebrateTitle: "{{title}} d√©bloqu√©e !",
    rewardCelebrateSubtitle: "Almi est fier¬∑e : garde la s√©rie.",
    challengeTabTitle: "D√©fis",
    challengeRewardsTabTitle: "Bonus",
    challengeStartCta: "Lancer le d√©fi",
    challengeClaimCta: "R√©cup√©rer la r√©compense",
    challengeActiveCta: "En cours",
    challengeStatusAvailable: "Pr√™t √† d√©marrer",
    challengeStatusActive: "Actif",
    challengeStatusCompleted: "Pr√™t √† √™tre r√©clam√©",
    challengeStatusExpired: "Expir√©",
    challengeStatusClaimed: "Termin√©",
    challengeRewardLabel: "R√©compense",
    challengeRewardHealth: "+{{amount}}",
    challengeProgressLabel: "{{current}} / {{target}}",
    challengeDurationLabel: "Dur√©e : {{days}} jours",
    challengeTimeLeftLabel: "{{time}} restantes",
    challengeTimeDayShort: "j",
    challengeTimeHourShort: "h",
    challengeTimeMinuteShort: "m",
    challengeTimeExpired: "Temps √©coul√©",
    challengeReadyToClaim: "R√©compense pr√™te",
    challengeRestartHint: "Rejouable √† tout moment (d√©fi de {{days}} jours)",
    challengeStartedOverlay: "D√©fi ¬´ {{title}} ¬ª lanc√©",
    challengeCompletedOverlay: "¬´ {{title}} ¬ª termin√© : prends le bonus !",
    challengeClaimedOverlay: "D√©fi ¬´ {{title}} ¬ª ¬∑ +{{amount}}",
    challengeReminderTitle: "D√©fi Almost ¬´ {{title}} ¬ª",
    challengeReminderBody: "Tu touches au but. Enregistre encore une √©conomie pour ¬´ {{title}} ¬ª et prends la r√©compense.",
    challengeCancelAction: "Annuler",
    challengeAcceptConfirmTitle: "Commencer ce d√©fi ?",
    challengeAcceptConfirmMessage: "On lance ¬´ {{title}} ¬ª ? Le chrono d√©marre tout de suite.",
    challengeAcceptConfirmYes: "D√©marrer",
    challengeAcceptConfirmNo: "Pas maintenant",
    challengeCancelConfirmTitle: "Annuler ce d√©fi ?",
    challengeCancelConfirmMessage: "On stoppe ¬´ {{title}} ¬ª ? Le progr√®s sera perdu.",
    challengeCancelConfirmYes: "Annuler",
    challengeCancelConfirmNo: "Continuer",
    challengeLimitReachedAction: "Limite : {{limit}} d√©fis",
    challengeLimitReachedTitle: "Limite de d√©fis",
    challengeLimitReachedMessage: "Tu peux mener au plus {{limit}} d√©fis en parall√®le. Termine-en un pour en lancer un nouveau.",
    dailyChallengeOfferBadge: "d√©fi du jour",
    dailyChallengeOfferTitle: "Mini d√©fi du jour",
    dailyChallengeOfferSubtitle: "Passe une journ√©e sans ¬´ {{temptation}} ¬ª",
    dailyChallengeOfferHint: "√âvite-le une fois aujourd'hui et gagne une r√©compense doubl√©e.",
    dailyChallengeOfferReward: "+{{amount}} bonus",
    dailyChallengeOfferAccept: "Accepter le d√©fi",
    dailyChallengeOfferLater: "Plus tard",
    dailyChallengeWidgetBadge: "d√©fi du jour",
    dailyChallengeWidgetTitle: "Mini d√©fi actif",
    dailyChallengeWidgetDesc: "Journ√©e sans ¬´ {{temptation}} ¬ª = pi√®ces √ó2",
    dailyChallengeWidgetProgress: "Progression {{current}} / {{target}}",
    dailyChallengeWidgetReward: "+{{amount}}",
    dailyChallengeRewardReason: "Mini d√©fi ¬´ {{temptation}} ¬ª r√©ussi",
    dailyChallengeRewardNotificationTitle: "D√©fi quotidien Almost termin√©",
    dailyChallengeRewardNotificationBody: "¬´ {{temptation}} ¬ª a c√©d√© - prends ton bonus de +{{amount}}.",
    dailyChallengeFailedText: "¬´ {{temptation}} ¬ª a gagn√© aujourd'hui",
    healthCelebrateTitle: "+{{amount}}",
    healthCelebrateSubtitle: "√Ä utiliser pour sauver ta s√©rie de jours gratuits.",
    healthCelebrateLevel: "Niveau sup√©rieur ! Almi est content(e).",
    healthCelebrateReward: "R√©compense r√©colt√©e : sant√© restaur√©e.",
    rainMessage: "Oh non ! Prot√®ge l'argent.",
    developerReset: "R√©initialiser les donn√©es",
    developerResetConfirm: "Effacer envies, historique et profil ?",
    developerResetCancel: "Conserver",
    developerResetApply: "R√©initialiser",
    openSettings: "R√©glages",
    defaultDealTitle: "Objectif",
    defaultDealDesc: "D√©cris ce que tu veux financer",
    photoLibrary: "Depuis la galerie",
    photoCamera: "Utiliser la cam√©ra",
    photoTapHint: "Tape pour ajouter une photo",
    photoPromptTitle: "Ajouter une photo ?",
    photoPromptSubtitle: "Choisis cam√©ra ou galerie",
    photoPermissionDenied: "Nous avons besoin de l'acc√®s cam√©ra ou photos pour changer ton avatar.",
    photoPermissionSettings: "Ouvre R√©glages pour accorder l'acc√®s √† la cam√©ra et aux photos.",
    photoPickerError: "Un souci est survenu. R√©essaie.",
    registrationTitle: "Mettons tout en place",
    registrationSubtitle: "Pr√©sente-toi pour qu'Almost parle ta langue",
    languageTitle: "Choisis une langue",
    languageSubtitle: "Chaque astuce sera adapt√©e pour toi",
    languageCurrencyHint: "Tu pourras changer la langue et la devise dans Profil.",
    currencySwipeHint: "Balaye pour voir toutes les devises ‚Üí",
    languageTermsHint: "En continuant, vous acceptez les conditions d'utilisation d'Almost.",
    languageTermsAccepted: "Accepte les conditions d'utilisation pour continuer.",
    languageTermsLink: "Lire les Conditions compl√®tes",
    inputFirstName: "Pr√©nom",
    inputLastName: "Nom",
    inputMotto: "Devise personnelle",
    currencyLabel: "Devise d'√©pargne",
    nextButton: "Continuer",
    goalTitle: "Choisis un objectif",
    goalSubtitle: "√Ä quoi doivent servir tes d√©cisions conscientes ?",
    goalCustomSectionTitle: "Tes objectifs",
    goalCustomCreate: "Ajouter ton propre objectif",
    goalButton: "Commencer √† √©pargner",
    goalPrimaryBadge: "Objectif principal",
    goalTargetTitle: "Quelle taille pour cet objectif ?",
    goalTargetSubtitle: "D√©finis le montant pour qu'Almost suive chaque unit√©.",
    goalTargetPlaceholder: "Entre le montant",
    goalTargetHint: "Tu pourras le modifier plus tard dans le profil.",
    goalTargetCTA: "Enregistrer le montant",
    goalTargetError: "Entre un montant",
    goalTargetLabel: "Montant de l'objectif",
    primaryGoalLabel: "Objectif principal",
    primaryGoalLocked: "Tu pourras changer √ßa plus tard dans ton profil.",
    primaryGoalRemaining: "Il reste {{amount}}",
    goalWidgetTargetLabel: "Objectif : {{amount}}",
    goalWidgetRemaining: "Encore {{amount}}",
    goalWidgetComplete: "Objectif atteint",
    goalWidgetTitle: "Vers l'objectif",
    goalWidgetCompleteTagline: "Les √©conomies continuent - mission accomplie.",
    goalAssignPromptTitle: "O√π envoyer cette √©conomie ?",
    goalAssignPromptSubtitle: "Choisis l'objectif qui recevra ¬´ {{title}} ¬ª.",
    goalAssignNone: "Pas encore d'objectif",
    goalAssignTemptationTitle: "Associer une tentation",
    goalAssignTemptationSubtitle: "Quelle habitude alimente ¬´ {{goal}} ¬ª ?",
    goalAssignClear: "Retirer l'association",
    goalAssignFieldLabel: "Envoyer l'√©pargne vers",
    goalMainTemptationError: "La tentation principale ne peut pas devenir un objectif.",
    goalDestinationLabel: "J'√©pargne pour",
    goalStatusInWishlist: "Ajouter √† l'objectif",
    goalSwipeAdd: "Ajouter",
    goalSwipeDelete: "Supprimer",
    goalPinnedBadge: "Objectif",
    goalRemoved: "Objectif supprim√©",
    goalEditAction: "Modifier",
    goalDeleteAction: "Retirer",
    goalEditModalTitle: "Modifier l'objectif",
    goalEditNameLabel: "Nom de l'objectif",
    goalEditTargetLabel: "Montant",
    goalEditEmojiLabel: "Emoji",
    goalEditSave: "Enregistrer",
    goalEditCancel: "Annuler",
    goalEditNameError: "Entre un nom",
    goalEditTargetError: "Sp√©cifie un montant",
    goalCelebrationTitle: "Objectif principal atteint !",
    goalCelebrationSubtitle: "Almi est fier : choisis le prochain r√™ve.",
    goalCelebrationTarget: "√âconomis√© {{amount}}",
    goalRenewalTitle: "Choisis un nouvel objectif principal",
    goalRenewalSubtitle: "Celui-ci est termin√© : fixe-en un nouveau pour garder l'√©lan.",
    goalRenewalCreate: "Cr√©er un objectif",
    goalRenewalLater: "Plus tard",
    levelWidgetTitle: "Progression du niveau",
    levelWidgetCurrent: "Niveau {{level}}",
    levelWidgetSubtitle: "{{amount}} avant le prochain niveau",
    levelWidgetTarget: "Niveau suivant √† {{amount}}",
    levelWidgetMaxed: "Niveau ultime atteint - √©pargnant l√©gendaire !",
    onboardingGuideTitle: "La promesse d'Almost",
    onboardingGuideSubtitle: "Un antidote conscient contre le consum√©risme et les achats impulsifs.",
    onboardingGuideButton: "Compris",
    termsTitle: "Conditions d'utilisation",
    termsSubtitle: "Lis les points cl√©s. Continuer signifie accepter les Conditions Almost.",
    termsViewFull: "Ouvrir le document complet",
    termsLinkHint: "Nous l'ouvrirons dans ton navigateur.",
    termsAccept: "J'accepte",
    termsDecline: "Pas maintenant",
    guideStepTrackTitle: "Ta mission principale",
    guideStepTrackDesc: "D√©pense consciemment, prot√®ge ton budget et concentre-toi sur ce qui compte.",
    guideStepDecisionTitle: "Menu des tentations",
    guideStepDecisionDesc: "Note chaque tentation et r√©siste pour qu'Almost enregistre la victoire et garde l'argent au chaud.",
    guideStepRewardTitle: "Voir la vue d'ensemble",
    guideStepRewardDesc: "Valide chaque √©conomie et observe l'app dessiner le grand objectif.",
    personaTitle: "Parle-nous de toi",
    personaSubtitle: "Pour personnaliser l'exp√©rience.",
    personaGenderLabel: "Comment devons-nous t'appeler ?",
    personaHabitLabel: "Choisis un profil de d√©part",
    personaConfirm: "Continuer",
    customSpendTitle: "Ta tentation quotidienne",
    customSpendSubtitle: "Donne-lui un petit nom et Almost t'aidera √† la battre plus souvent.",
    customSpendNamePlaceholder: "Matcha du matin, cigarettes, nail art‚Ä¶",
    customSpendAmountLabel: "Co√ªt par occasion",
    customSpendAmountPlaceholder: "Entre le montant",
    customSpendFrequencyLabel: "Combien de fois par semaine gagne-t-elle ?",
    customSpendFrequencyPlaceholder: "Ex. 4",
    customSpendHint: "Tu peux changer √ßa √† tout moment dans le profil.",
    customSpendSkip: "Passer pour l'instant",
    smartReminderTitle: [
      "Almost a rep√©r√© ¬´ {{temptation}} ¬ª",
      "Almi veille : ¬´ {{temptation}} ¬ª",
      "Ping Almost : ¬´ {{temptation}} ¬ª",
    ],
    smartReminderBody: [
      "Tu as enregistr√© ¬´ {{temptation}} ¬ª r√©cemment. Refais une pause et envoie l'argent vers ton objectif.",
      "Almost a signal√© cette routine - respire avant ¬´ {{temptation}} ¬ª et choisis l'√©pargne.",
      "Garde la s√©rie en vie. ¬´ {{temptation}} ¬ª peut attendre un peu.",
      "Astuce : chaque fois que tu √©vites ¬´ {{temptation}} ¬ª, Almost affine ses id√©es.",
    ],
    smartInsightDeclineTitle: "Victoire hier : ¬´ {{temptation}} ¬ª",
    smartInsightDeclineBody: "Redis-lui non aujourd'hui et Almost verrouillera la s√©rie.",
    smartInsightSpendTitle: "Hier, ¬´ {{temptation}} ¬ª a gagn√©",
    smartInsightSpendBody: "Tiens bon aujourd'hui pour c√©l√©brer une √©conomie.",
    dailyNudgeMorningTitle: ["Coup de pouce matinal d'Almost", "Contr√¥le focus d'Almi"],
    dailyNudgeMorningBody: [
      "Donne le ton : saute la premi√®re impulsion et rappelle-toi ta cible.",
      "Almi v√©rifie - fais une pause avant la premi√®re d√©pense",
    ],
    dailyNudgeDayTitle: ["Check-in Almost de midi", "Boost de focus d'Almi"],
    dailyNudgeDayBody: [
      "Les impulsions montent √† cette heure. Demande-toi si cet achat sert toujours ton objectif.",
      "Almost a remarqu√© des craquages du midi. Prends une pause consciente.",
    ],
    dailyNudgeAfternoonTitle: ["Ping apr√®m d‚ÄôAlmost", "Freine avec Almi"],
    dailyNudgeAfternoonBody: [
      "Respire avant de cliquer sur acheter et redirige l'argent vers ton √©pargne.",
      "Les tentations s'approchent ? Garde le cap et pense √† ton objectif.",
    ],
    dailyNudgeEveningTitle: ["Bouclier du soir d'Almost", "Almi cl√¥t ta journ√©e"],
    dailyNudgeEveningBody: [
      "Les soir√©es sont les plus tentantes. Note une victoire avant de dormir.",
      "Termine ta journ√©e dans Almost - m√™me une mini-√©conomie tient les rappels √† jour.",
    ],
    dailySummaryBadgeLabel: "r√©cap du jour",
    dailySummaryTitle: "R√©cap du jour",
    dailySummarySubtitle: "Super rythme - continue !",
    dailySummarySavedLabel: "√âconomis√© aujourd'hui",
    dailySummarySavedSub: "Chaque refus rapproche la cible",
    dailySummarySpendsLabel: "D√©penses",
    dailySummaryContinue: "Continuer",
    dailySummaryHint: "√Ä demain avec des chiffres frais.",
    baselineTitle: "Combien part dans les petites folies ?",
    baselineSubtitle:
      "Estime un mois de caf√©s, snacks et achats impulsifs pour le comparer aux vraies victoires.",
    baselinePlaceholder: "Entre le montant",
    baselineCTA: "Enregistrer le montant",
    baselineHint: "Un chiffre approximatif suffit ; tu pourras l'ajuster dans Profil.",
    baselineInputError: "Entre ta d√©pense mensuelle estim√©e en extras",
    potentialBlockTitle: "Potentiel vs √©pargne r√©elle",
    potentialBlockSubtitle: "",
    potentialBlockStatusAhead: "Wow, tu d√©passes le pronostic !",
    potentialBlockStatusStart: "Commence √† noter tes victoires - le potentiel t'attend.",
    potentialBlockStatusBehind: "Tu es sur la bonne voie, mais il reste du potentiel.",
    potentialBlockStatusOnTrack: "Tu captes presque tout le potentiel. Continue !",
    potentialBlockActualLabel: "Vraiment √©conomis√©",
    potentialBlockPotentialLabel: "Potentiel",
    potentialBlockHint: "Il reste {{amount}} de potentiel. On garde le rythme üôÇ",
    potentialBlockDetails:
      "On utilise le budget mensuel des tentations d√©fini √† l'onboarding, on le d√©coupe par seconde et on montre combien tu pourrais d√©j√† avoir √©conomis√©.",
    potentialBlockCta: "Dis-nous combien fuient dans les extras et on t'affiche le potentiel.",
    potentialPushAheadTitle: "En avance sur le potentiel !",
    potentialPushAheadBody:
      "Le compteur potentiel atteint {{potential}} et tu es d√©j√† √† {{actual}}. Garde cette dynamique.",
    potentialPushBehindTitle: "Rattrape le potentiel",
    potentialPushBehindBody:
      "Le potentiel est √† {{potential}} - plus que {{shortfall}} pour rattraper. Fais une pause avant le prochain achat et note une victoire.",
    quickCustomTitle: "Ajouter une tentation",
    quickCustomSubtitle: "Nomme l'impulsion et fixe un prix pour l'ajouter au deck",
    quickCustomNameLabel: "Nom",
    quickCustomAmountLabel: "Co√ªt ({{currency}})",
    quickCustomEmojiLabel: "Emoji",
    quickCustomConfirm: "Ajouter",
    quickCustomCancel: "Annuler",
    coinEntryTitle: "Quel montant ?",
    coinEntrySubtitle: "Fais glisser la pi√®ce et choisis une cat√©gorie.",
    coinEntryHint: "Utilise les boutons pour √©conomiser ou d√©penser.",
    coinEntryManual: "...",
    coinEntryManualTitle: "D√©finir un nouveau maximum",
    coinEntryManualPlaceholder: "Entre le montant",
    coinEntryManualSave: "M√©moriser",
    coinEntryManualCancel: "Annuler",
    coinEntryManualError: "Entre un montant valide",
    coinEntryManualAmountTitle: "Saisir un montant manuel",
    coinEntryManualAmountPlaceholder: "Entre le montant",
    coinEntryCategoryLabel: "Cat√©gorie",
    coinEntryCategoryError: "Choisis d'abord une cat√©gorie",
    coinEntrySaveLabel: "√âconomie rapide",
    coinEntrySpendLabel: "D√©pense rapide",
    fabNewGoal: "Nouvel objectif",
    fabNewTemptation: "Nouvelle d√©pense",
    fabQuickActionTitle: "Derni√®re tentation",
    fabQuickActionSubtitle: "R√©p√©ter l'action pour ¬´ {{title}} ¬ª",
    fabQuickActionEmpty: "Aucune tentation r√©cente. Interagis d'abord avec une carte.",
    fabTutorialTitle: "D√©couvre le ¬´ + ¬ª",
    fabTutorialDesc:
      "Tape pour enregistrer une impulsion personnalis√©e avec ton montant et ta cat√©gorie. Maintiens pour cr√©er objectifs ou d√©penses custom.",
    fabTutorialAction: "Compris",
    newGoalTitle: "Nouvel objectif",
    newGoalSubtitle: "Nomme le r√™ve et fixe sa cible.",
    newGoalNameLabel: "Nom",
    newGoalTargetLabel: "Montant ({{currency}})",
    newGoalEmojiLabel: "Emoji",
    newGoalCreate: "Cr√©er",
    newGoalCancel: "Annuler",
    newPendingTitle: "Nouvel √©l√©ment En pause",
    newPendingSubtitle: "D√©cris la tentation √† mettre en pause 14 jours.",
    newPendingNameLabel: "Nom",
    newPendingAmountLabel: "Prix ({{currency}})",
    newPendingEmojiLabel: "Emoji",
    newPendingCreate: "Ajouter √† En pause",
    newPendingCancel: "Annuler",
    tutorialFeedTitle: "Flux de tentations",
    tutorialFeedDesc: "Enregistre chaque impulsion et d√©cide : √©conomiser, ajouter √† l'objectif ou mettre en pause 14 jours.",
    tutorialGoalsTitle: "Objectifs",
    tutorialGoalsDesc: "Tous les r√™ves vivent ici. Suis le progr√®s et recharge ton objectif.",
    tutorialThinkingTitle: "Onglet En pause",
    tutorialThinkingDesc: "Mets les achats en pause 14 jours et reviens l'esprit clair.",
    tutorialRewardsTitle: "R√©compenses & d√©fis",
    tutorialRewardsDesc: "Dans cet onglet tu r√©coltes les succ√®s et lances des d√©fis avec bonus sant√©.",
    tutorialProfileTitle: "Profil & motivation",
    tutorialProfileDesc: "Ajuste th√®me, langue, rappels et personnalisation.",
    tutorialSkip: "Passer",
    tutorialNext: "Suivant",
    tutorialDone: "Terminer",
    tutorialProgress: "{{current}} sur {{total}}",
    tabHintFeedTitle: "Flux de tentations",
    tabHintFeedBody: "Note les impulsions et d√©cide de les √©conomiser, de les ajouter √† un objectif ou de les mettre en pause.",
    tabHintCartTitle: "Objectifs",
    tabHintCartBody: "Classe tes r√™ves, fixe les priorit√©s et mets √† jour ton progr√®s.",
    tabHintPendingTitle: "Onglet En pause",
    tabHintPendingBody: "Envoie les envies dans une pause de 14 jours et reviens plus lucide.",
    tabHintPurchasesTitle: "R√©compenses",
    tabHintPurchasesBody: "R√©cup√®re les succ√®s et lance des d√©fis pour gagner de la sant√©.",
    tabHintProfileTitle: "Profil",
    tabHintProfileBody: "R√®gle th√®me, langue, rappels et objectifs personnels.",
    tabHintGotIt: "Compris",
  },

  es: {
    appTagline: "Un panel offline de tentaciones que protege tus ahorros",
    tamagotchiHungryBubble: "üêü",
    tamagotchiFoodMenuTitle: "Men√∫ de Almi",
    tamagotchiFoodBoostLabel: "+{{percent}}% de saciedad",
    tamagotchiFoodWantLabel: "Lo quiero",
    tamagotchiSkinTitle: "Aspectos de Almi",
    tamagotchiSkinSubtitle: "Un nuevo estilo para Almi mantiene fresca la motivaci√≥n de ahorro",
    tamagotchiSkinCurrent: "Seleccionado",
    tamagotchiSkinUnlockTitle: "Almost acaba de despegar üöÄ",
    tamagotchiSkinUnlockDescription:
      "Ay√∫danos a mejorar: env√≠a feedback a {{email}} y desbloquea todos los aspectos.",
    tamagotchiSkinUnlockButton: "Enviar feedback y desbloquear skins",
    tamagotchiSkinLockedBadge: "Bloqueado",
    tamagotchiName: "Almi",
    tamagotchiFullnessLabel: "Saciedad",
    tamagotchiCoinsLabel: "Monedas",
    tamagotchiFedAtLabel: "Alimentado",
    tamagotchiAwaitingFirstCoin: "Almi espera su primera moneda",
    tamagotchiFullMessage: "Almi ya est√° llena. Vuelve cuando vuelva a tener hambre.",
    tamagotchiEarnCoinsHint: "Consigue monedas con rechazos, niveles y recompensas.",
    tamagotchiNeedCoinsMessage: "Necesitas al menos {{cost}} monedas para {{emoji}}.",
    tamagotchiPartyNeedCoinsMessage: "Necesitas {{amount}} monedas azules para iniciar una fiesta.",
    tamagotchiPartyButtonLabel: "Fiesta √ó{{cost}}",
    tamagotchiFullHint: "Est√° lleno, int√©ntalo m√°s tarde.",
    tamagotchiSkinFeedbackSubject: "Comentarios para Almost",
    tamagotchiSkinFeedbackBody: "Hola equipo Almost. Comparto mis impresiones de la app:\\n\\n",
    heroAwaiting: "En la lista de deseos",
    heroSpendLine: {
      female: "√öltimo ahorro: ¬´{{title}}¬ª.",
      male: "√öltimo ahorro: ¬´{{title}}¬ª.",
      none: "√öltimo ahorro: ¬´{{title}}¬ª.",
    },
    heroSpendRecentTitle: "Actividad reciente:",
    heroSpendFallback: "Cada pausa consciente alimenta el fondo de libertad",
    heroEconomyContinues: "El ahorro sigue en marcha.",
    heroExpand: "Mostrar detalles",
    heroCollapse: "Ocultar detalles",
    heroDailyTitle: "Ahorros/gastos semanales",
    heroDailyEmpty: "A√∫n no has rechazado nada. Intenta ahorrar una vez esta semana.",
    defaultDeclineLabel: "Rechazo",
    defaultWishTitle: "Deseo",
    heroWeeklySavingsDelta: "Ahorrado",
    heroWeeklySpendingDelta: "Gastado",
    feedEmptyTitle: "Aqu√≠ no hay nada",
    feedEmptySubtitle: "Prueba otro tag o actualiza el cat√°logo",
    buyNow: "Pagar con {{pay}}",
    addToCart: "Guardar para despu√©s",
    buyExternal: "Abrir p√°gina del producto",
    wishlistTitle: "Metas",
    wishlistEmptyTitle: "Todav√≠a no hay metas",
    wishlistEmptySubtitle: "Elige una tentaci√≥n del feed y empieza a ahorrar para ella",
    buyLabel: "Tomar",
    buyAllLabel: "Comprar todo",
    totalLabel: "Total",
    cartRemove: "Eliminar",
    wishlistTab: "Metas",
    wishlistProgress: "{{current}} de {{target}}",
    wishlistSavedHint: "Lo que necesitas ahorrar",
    wishlistSaveProgress: "Actualizar progreso",
    wishlistSetActive: "Marcar como activa",
    wishlistActive: "Meta activa",
    wishlistRemove: "Eliminar",
    wishlistRemoveConfirm: "¬øQuitar este deseo?",
    wishlistDoneLabel: "Listo",
    wishlistSummary: "Metas por un total de {{amount}}",
    freeDayButton: "D√≠a gratis",
    freeDayLocked: "Despu√©s de las 18:00",
    freeDayBlocked: "No disponible",
    freeDayStatusAvailable: "Registrar d√≠a",
    freeDayStatusLogged: "Registrado",
    freeDayLoggedToday: "Anotado hoy",
    freeDayConfirm: "¬øHoy evitaste las compras impulsivas?",
    freeDayCongrats: "Racha de {{days}} d√≠as. ¬°Al presupuesto le encanta!",
    freeDayMilestone: "{{days}} d√≠as seguidos. ¬°Nuevo logro desbloqueado!",
    freeDayCardTitle: "Racha de d√≠as gratis",
    freeDayActiveLabel: "Racha de {{days}} d√≠as",
    freeDayInactiveLabel: "Registra una noche sin impulsos",
    freeDayCurrentLabel: "Actual",
    freeDayBestLabel: "Mejor",
    freeDayTotalShort: "Total",
    freeDayWeekTitle: "Esta semana",
    freeDayExpand: "Mostrar detalles",
    freeDayCollapse: "Ocultar",
    freeDayTotalLabel: "Total: {{total}}",
    freeDayRescueTitle: "¬øSe rompi√≥ la racha?",
    freeDayRescueSubtitle: "Invierte {{cost}} de salud para mantenerla viva.",
    freeDayRescueButton: "Salvar racha",
    freeDayRescuePillLabel: "Salvar √ó{{count}}",
    freeDayRescueNeedHealth: "Necesitas {{cost}} de salud",
    freeDayRescueNeedTime: "Disponible despu√©s de las 18:00",
    freeDayRescueOverlay: "Racha salvada",
    freeDayCoinReward: "D√≠a gratis registrado: +{{coins}} monedas azules.",
    freeDayCoinRewardStreak: "üî• Racha de {{days}} d√≠as: +{{coins}} monedas azules.",
    impulseCardTitle: "Mapa de impulsos",
    impulseCardSubtitle: "Descubre cu√°ndo suelen ganar las tentaciones o cu√°ndo mantienes el control.",
    impulseLoseLabel: "Zona d√©bil",
    impulseLoseCopy: "{{temptation}} suele ganar alrededor de las {{time}}.",
    impulseLoseEmpty: "A√∫n no hay zonas d√©biles.",
    impulseWinLabel: "Racha ganadora",
    impulseWinCopy: "Resistes {{temptation}} sobre todo alrededor de las {{time}}.",
    impulseWinEmpty: "Los logros aparecen cuando registres m√°s ahorros.",
    impulseTrendLabel: "La mayor√≠a de impulsos aparecen en {{category}}",
    impulseCategorySave: "Ahorros: {{count}}",
    impulseCategorySpend: "Gastos: {{count}}",
    impulseAnytimeLabel: "en cualquier momento",
    impulseExpand: "Expandir",
    impulseCollapse: "Ocultar mapa",
    impulseAlertTitle: "Alerta de impulso",
    impulseAlertMessage:
      "Est√°s entrando en una zona de alto impulso para {{temptation}} ({{window}}). Salt√©alo y guarda {{amount}}.",
    impulseNotificationTitle: "Almost detect√≥ un impulso: ¬´{{temptation}}¬ª",
    impulseNotificationBody: "Normalmente cedes ahora. Haz una pausa Almost y guarda {{amount}}.",
    impulseAlertBadgeLabel: "alerta inteligente",
    impulseAlertWindowLabel: "Pico de impulso",
    impulseAlertAmountLabel: "En juego",
    impulseAlertButtonLabel: "Mantener el enfoque",
    impulseCategoryLabel: "Categor√≠a del impulso",
    focusDigestPositiveTitle: "La tendencia va bien",
    focusDigestPositiveBody:
      "Resistes m√°s de lo que gastas.\nMayor victoria: ¬´{{strong}}¬ª.\nAtiende a ¬´{{weak}}¬ª.",
    focusDigestNegativeTitle: "Hora de reenfocar",
    focusDigestNegativeBody:
      "Los gastos superan a los ahorros.\nLa mayor fuga es ¬´{{weak}}¬ª. Conc√©ntrate en ella.",
    focusDigestStrongLabel: "Mayor victoria",
    focusDigestWeakLabel: "Necesita atenci√≥n",
    focusDigestButton: "Focalizar",
    focusDigestDismiss: "Despu√©s",
    focusDigestMissing: "Sin datos a√∫n",
    focusBadgeLabel: "Foco",
    focusPromptTitle: "Momento de reenfoque",
    focusPromptBody: "Ca√≠ste ante ¬´{{title}}¬ª varias veces. ¬øLo hacemos tu foco?",
    focusVictoryReward: "Foco ¬´{{title}}¬ª conquistado. +3 monedas verdes",
    focusRewardTitle: "Foco conquistado",
    focusRewardSubtitle: "Resististe ¬´{{title}}¬ª tres veces. +{{amount}} monedas verdes.",
    dailyReflectionReminderTitle: "Chequeo nocturno de Almost",
    dailyReflectionReminderBody:
      "Quedan {{time}} hoy. Registra un ahorro o un gasto para que los recordatorios sigan siendo certeros.",
    pendingTab: "En pausa",
    pendingTitle: "En pausa",
    pendingEmptyTitle: "Nada en pausa",
    pendingEmptySubtitle: "Env√≠a tentaciones a En pausa y te recordaremos en 14 d√≠as.",
    pendingDaysLeft: "Quedan {{days}} d√≠as",
    pendingExpired: "Decisi√≥n atrasada",
    pendingDueToday: "Decide hoy",
    pendingActionWant: "Empezar a ahorrar",
    pendingActionDecline: "Ahorrar",
    pendingNotificationTitle: "Almost pregunta: ¬øqu√© hacemos con ¬´{{title}}¬ª?",
    pendingNotificationBody: "Han pasado dos semanas. ¬øEmpezamos a ahorrar para ¬´{{title}}¬ª o lo soltamos?",
    pendingAdded: "Enviado a En pausa. Recordaremos en dos semanas.",
    pendingDeleteConfirm: "¬øQuitar este elemento de En pausa?",
    pendingCustomError: "A√±ade un nombre y un precio para esta tentaci√≥n.",
    feedTab: "Feed",
    profileTab: "Perfil",
    payButton: "Pagar",
    cartOverlay: "Ahorro actualizado",
    purchasesTitle: "Premios",
    purchasesSubtitle: "Sigue tus logros y recuerda por qu√© ahorras",
    progressLabel: "Nivel de consciencia",
    progressGoal: "{{current}} / {{goal}}",
    progressHint: "Solo faltan {{amount}} para alcanzar el ‚Äòmaestro zen del presupuesto‚Äô",
    emptyPurchases: "Todav√≠a nada. Lo cual ya ahorra dinero",
    profileEdit: "Editar",
    profileSave: "Guardar",
    profileCancel: "Cancelar",
    profileOk: "Ok",
    profileJoinDate: "Ahorro consciente desde {{date}}",
    settingsTitle: "Ajustes y personalizaci√≥n",
    analyticsOptInLabel: "Enviar anal√≠ticas an√≥nimas",
    analyticsOptInHint: "Ayuda a mejorar Almost sin compartir datos personales",
    themeLabel: "Tema",
    themeLight: "Claro",
    themeDark: "Oscuro",
    languageLabel: "Idioma",
    languageRussian: "–†—É—Å—Å–∫–∏–π",
    languageEnglish: "English",
    languageSpanish: "Espa√±ol",
    languageFrench: "Franc√©s",
    partialInfo: "El pago parcial no est√° disponible para packs",
    partialLabel: "Introduce un monto (hasta {{amount}})",
    partialError: "Ingresa un valor entre 1 y el total",
    buyFull: "Pagar completo",
    buyPartial: "Pagar parcialmente",
    thinkLater: "Pensar luego",
    wantAction: "A√±adir a metas",
    saveAction: "Ahorrarlo",
    maybeAction: "Lo pensar√©",
    spendAction: "Gastarlo",
    editPrice: "Editar precio",
    actionSoon: "El flujo detallado llegar√° en la pr√≥xima actualizaci√≥n.",
    saveSpamWarningItem: "Parece que pulsaste ‚ÄúAhorrarlo‚Äù varias veces en esta tarjeta en cinco minutos. Haz una pausa para evitar toques accidentales.",
    saveSpamWarningGlobal: "Demasiados toques r√°pidos en ‚ÄúAhorrarlo‚Äù. Aseg√∫rate de que sea intencional y vuelve a intentar en un momento.",
    priceEditTitle: "Ajustar el monto objetivo",
    priceEditPlaceholder: "Introduce un monto",
    priceEditSave: "Guardar",
    priceEditReset: "Restablecer",
    priceEditCancel: "Cancelar",
    priceEditDelete: "Eliminar tentaci√≥n",
    priceEditDeleteConfirm: "¬øEliminar esta tentaci√≥n?",
    priceEditError: "Introduce un n√∫mero positivo",
    priceEditNameLabel: "Nombre de la tarjeta",
    priceEditAmountLabel: "Monto ({{currency}})",
    wishAdded: "A√±adido a deseos: {{title}}",
    wishDeclined: "+{{amount}} resguardados",
    customTemptationAdded: "A√±adido a tentaciones: {{title}}",
    saveCelebrateTitlePrefix: "Saltado:",
    saveCelebrateSubtitle: "Almi ronronea: ¬°ahorros arriba!",
    saveGoalRemaining: "Aproximadamente faltan {{count}} rechazos para llegar a ¬´{{goal}}¬ª.",
    saveGoalComplete: "Meta ¬´{{goal}}¬ª alcanzada. A celebrar.",
    saveOverlayCoinReward: "+{{amount}} monedas para Almi",
    freeDayStreakLabel: "Racha de d√≠as gratis",
    freeDayTotalLabel: "Total: {{total}}",
    statsSpent: "Metas completadas",
    statsSaved: "Ahorrado",
    statsItems: "Metas",
    statsCart: "En lista",
    statsDeclines: "Rechazos",
    statsSpends: "Gastos",
    statsFreeDays: "Racha",
    savingsBreakdownTitle: "Detalle del ahorro",
    savingsBreakdownOtherLabel: "Otros",
    analyticsTitle: "Progreso",
    analyticsPendingToBuy: "Deseos",
    analyticsPendingToDecline: "Ahorros",
    analyticsFridgeCount: "Gastos",
    analyticsBestStreak: "D√≠as gratis",
    analyticsConsentTitle: "¬øNos ayudas a mejorar?",
    analyticsConsentBody:
      "Recopilamos anal√≠ticas an√≥nimas para entender qu√© momentos inspiran m√°s ahorro. No guardamos datos personales.",
    analyticsConsentAgree: "Compartir anal√≠ticas",
    analyticsConsentSkip: "Omitir por ahora",
    onboardingBack: "Atr√°s",
    historyTitle: "Registro de eventos",
    historyEmpty: "A√∫n nada. A√±ade una meta o marca un d√≠a gratis.",
    privacyPolicyLink: "Pol√≠tica de privacidad",
    privacyPolicyHint: "Se abrir√° en tu navegador.",
    supportLink: "Soporte",
    supportHint: "almostappsup@gmail.com",
    ratingPromptTitle: "¬øDisfrutas Almost?",
    ratingPromptBody: "Si te ayuda a domar las compras impulsivas, deja una rese√±a r√°pida: motiva mucho al equipo.",
    ratingPromptLater: "Quiz√° luego",
    ratingPromptAction: "Calificar Almost",
    levelShareButton: "Compartir nivel",
    levelShareModalTitle: "¬°Nivel desbloqueado!",
    levelShareModalCaption: "Captura esta tarjeta y presume tu logro",
    levelShareModalShare: "Compartir tarjeta",
    levelShareModalClose: "Cerrar",
    levelShareError: "No pudimos compartir ahora. Intenta de nuevo m√°s tarde.",
    levelShareShareMessage: "Ya voy en el nivel {{level}} en Almost. ¬°√önete a los gastos conscientes!",
    levelShareCardBadge: "ALMOST HERO",
    levelShareCardTitle: "Nivel {{level}}",
    levelShareCardSubtitle: "Almi celebra mi progreso",
    levelShareJoin: "√önete a los ahorradores conscientes",
    levelShareFooterBrand: "Almost",
    levelShareFooterHint: "APP",
    historyWishAdded: "Deseo a√±adido: {{title}}",
    historyWishProgress: "Progreso ¬´{{title}}¬ª: {{amount}} de {{target}}",
    historyWishDone: "Meta completada: {{title}}",
    historyDecline: "Rechazado {{title}} (+{{amount}} ahorrados)",
    historyRefuseSpend: "Saltado {{title}} (+{{amount}} ahorrados)",
    historyPendingAdded: "Puesto en En pausa: {{title}}",
    historyPendingWant: "Decisi√≥n tard√≠a ‚Üí ahorrar: {{title}}",
    historyPendingDecline: "Decisi√≥n tard√≠a ‚Üí rechazo: {{title}} (+{{amount}})",
    historyPendingRemoved: "Eliminado de En pausa: {{title}}",
    historyFreeDay: "D√≠a gratis #{{total}}",
    historySpend: "Gastado en {{title}} (-{{amount}})",
    historyWishRemoved: "Meta eliminada: {{title}}",
    historyGoalStarted: "Meta iniciada: {{title}}",
    historyGoalCancelled: "Meta cancelada: {{title}}",
    historyRewardClaimed: "Recompensa reclamada: {{title}}",
    historyTimestamp: "{{date}} ¬∑ {{time}}",
    historyUnknown: "Evento",
    progressHeroTitle: "Ahorros reales",
    progressHeroLevel: "Nivel {{level}}",
    progressHeroNext: "Para el siguiente nivel {{amount}}",
    levelCelebrate: "Nivel {{level}} desbloqueado, armadura de ahorro mejorada",
    tileRefuseCount: "Ya se rechaz√≥ {{count}}√ó ¬∑ +{{amount}}",
    tileRefuseMessage: "Rech√°zalo hoy y tus ahorros te lo agradecer√°n",
    tileReady: "Listo para disfrutar",
    tileLocked: "Sigue ahorrando",
    spendWarning: "Gastando {{amount}}. ¬øSeguro?",
    spendSheetTitle: "Almost Pay",
    spendSheetSubtitle: "Nuestro Pay juguet√≥n sugiere ahorrar un poco m√°s.",
    spendSheetHint: "Pulsa dos veces (de esp√≠ritu) para continuar.",
    spendSheetCancel: "Seguir ahorrando",
    spendSheetConfirm: "Gastar de todas formas",
    stormOverlayMessage: "Ambiente de gasto tormentoso. ¬øA√∫n quieres deslizar?",
    rewardsEmpty: "Consigue logros al saltar tentaciones o registrar un d√≠a gratis.",
    goalsTitle: "Metas y recompensas",
    rewardUnlocked: "Desbloqueada",
    rewardLocked: "Faltan {{amount}}",
    rewardRemainingAmount: "Faltan {{amount}}",
    rewardRemainingDays: "Quedan {{count}} d√≠as",
    rewardRemainingRefuse: "Faltan {{count}} rechazos",
    rewardRemainingFridge: "{{count}} elementos m√°s en En pausa",
    rewardRemainingDecisions: "Quedan {{count}} decisiones en En pausa",
    rewardLockedGeneric: "Faltan {{count}} pasos",
    rewardBadgeLabel: "Recompensa",
    rewardBadgeLabelPlural: "recompensas",
    rewardBadgeClaimed: "¬°Cobrada!",
    rewardClaimCta: "Cobrar",
    rewardClaimHint: "Obt√©n {{amount}}",
    rewardClaimedStatus: "Salud almacenada",
    rewardHealthBonus: "+{{amount}}",
    freeDayHealthTitle: "Monedas",
    freeDayHealthSubtitle: "√ösalas para salvar rachas y alimentar a Almi.",
    rewardCelebrateTitle: "{{title}} desbloqueada",
    rewardCelebrateSubtitle: "Almi est√° orgulloso: mant√©n la racha.",
    challengeTabTitle: "Retos",
    challengeRewardsTabTitle: "Recompensas",
    challengeStartCta: "Iniciar reto",
    challengeClaimCta: "Cobrar recompensa",
    challengeActiveCta: "En progreso",
    challengeStatusAvailable: "Listo para empezar",
    challengeStatusActive: "Activo",
    challengeStatusCompleted: "Listo para cobrar",
    challengeStatusExpired: "Expirado",
    challengeStatusClaimed: "Completado",
    challengeRewardLabel: "Recompensa",
    challengeRewardHealth: "+{{amount}}",
    challengeProgressLabel: "{{current}} / {{target}}",
    challengeDurationLabel: "Duraci√≥n: {{days}} d√≠as",
    challengeTimeLeftLabel: "Queda {{time}}",
    challengeTimeDayShort: "d",
    challengeTimeHourShort: "h",
    challengeTimeMinuteShort: "m",
    challengeTimeExpired: "Tiempo agotado",
    challengeReadyToClaim: "Recompensa lista",
    challengeRestartHint: "Rep√≠telo cuando quieras (reto de {{days}} d√≠as)",
    challengeStartedOverlay: "Reto ¬´{{title}}¬ª iniciado",
    challengeCompletedOverlay: "¬´{{title}}¬ª listo: cobra el bono",
    challengeClaimedOverlay: "Reto ¬´{{title}}¬ª ¬∑ +{{amount}}",
    challengeReminderTitle: "Reto Almost ¬´{{title}}¬ª",
    challengeReminderBody: "Ya casi lo logras. Registra un ahorro m√°s para ¬´{{title}}¬ª y cobra la recompensa.",
    challengeCancelAction: "Cancelar",
    challengeAcceptConfirmTitle: "¬øComenzar este reto?",
    challengeAcceptConfirmMessage: "¬øArrancamos ¬´{{title}}¬ª? El cron√≥metro empieza ya.",
    challengeAcceptConfirmYes: "Empezar",
    challengeAcceptConfirmNo: "Ahora no",
    challengeCancelConfirmTitle: "¬øCancelar el reto?",
    challengeCancelConfirmMessage: "¬øDetenemos ¬´{{title}}¬ª? Se perder√° el progreso.",
    challengeCancelConfirmYes: "Cancelar",
    challengeCancelConfirmNo: "Seguir",
    challengeLimitReachedAction: "M√°x. {{limit}} retos",
    challengeLimitReachedTitle: "L√≠mite de retos",
    challengeLimitReachedMessage: "Solo puedes tener {{limit}} retos activos a la vez. Termina uno para iniciar otro.",
    dailyChallengeOfferBadge: "reto diario",
    dailyChallengeOfferTitle: "Mini reto de hoy",
    dailyChallengeOfferSubtitle: "Pasa un d√≠a sin ¬´{{temptation}}¬ª",
    dailyChallengeOfferHint: "S√°ltalo una vez hoy y consigue recompensas dobles.",
    dailyChallengeOfferReward: "+{{amount}} extra",
    dailyChallengeOfferAccept: "Aceptar reto",
    dailyChallengeOfferLater: "Quiz√° luego",
    dailyChallengeWidgetBadge: "reto diario",
    dailyChallengeWidgetTitle: "Mini reto activo",
    dailyChallengeWidgetDesc: "D√≠a sin ¬´{{temptation}}¬ª = monedas x2",
    dailyChallengeWidgetProgress: "Progreso {{current}} / {{target}}",
    dailyChallengeWidgetReward: "+{{amount}}",
    dailyChallengeRewardReason: "Mini reto ¬´{{temptation}}¬ª completado",
    dailyChallengeRewardNotificationTitle: "Reto diario Almost completado",
    dailyChallengeRewardNotificationBody: "¬´{{temptation}}¬ª cedi√≥. Toma tu bono de +{{amount}}.",
    dailyChallengeFailedText: "¬´{{temptation}}¬ª gan√≥ hoy",
    healthCelebrateTitle: "+{{amount}}",
    healthCelebrateSubtitle: "√ösalo para rescatar tu racha de d√≠as gratis.",
    healthCelebrateLevel: "Subiste de nivel. Almi est√° feliz.",
    healthCelebrateReward: "Recompensa cobrada: salud restaurada.",
    rainMessage: "¬°Oh no! Protege el dinero.",
    developerReset: "Restablecer datos",
    developerResetConfirm: "¬øBorrar deseos, historial y perfil?",
    developerResetCancel: "Conservar",
    developerResetApply: "Restablecer",
    openSettings: "Ajustes",
    defaultDealTitle: "Meta",
    defaultDealDesc: "Describe para qu√© est√°s ahorrando",
    photoLibrary: "Desde galer√≠a",
    photoCamera: "Usar c√°mara",
    photoTapHint: "Toca para a√±adir una foto",
    photoPromptTitle: "¬øA√±adir foto?",
    photoPromptSubtitle: "Elige c√°mara o galer√≠a",
    photoPermissionDenied: "Necesitamos acceso a c√°mara o fotos para actualizar tu avatar.",
    photoPermissionSettings: "Abre Ajustes para conceder acceso a c√°mara y fotos.",
    photoPickerError: "Algo sali√≥ mal. Intenta de nuevo.",
    registrationTitle: "Configuremos todo",
    registrationSubtitle: "Cu√©ntanos qui√©n eres para que Almost hable tu idioma",
    languageTitle: "Elige un idioma",
    languageSubtitle: "Personalizaremos cada pista para ti",
    languageCurrencyHint: "Podr√°s cambiar idioma y moneda luego en el Perfil.",
    currencySwipeHint: "Desliza para ver todas las monedas ‚Üí",
    languageTermsHint: "Al continuar, usted acepta los t√©rminos de Almost.",
    languageTermsAccepted: "Acepta los t√©rminos de uso para seguir.",
    languageTermsLink: "Leer los T√©rminos completos",
    inputFirstName: "Nombre",
    inputLastName: "Apellido",
    inputMotto: "Lema personal",
    currencyLabel: "Moneda de ahorro",
    nextButton: "Continuar",
    goalTitle: "Elige una meta",
    goalSubtitle: "¬øHacia d√≥nde deben ir tus decisiones conscientes?",
    goalCustomSectionTitle: "Tus metas",
    goalCustomCreate: "A√±adir meta propia",
    goalButton: "Empezar a ahorrar",
    goalPrimaryBadge: "Meta principal",
    goalTargetTitle: "¬øQu√© tan grande es esta meta?",
    goalTargetSubtitle: "Configura el monto para que Almost registre cada unidad.",
    goalTargetPlaceholder: "Ingresa el monto",
    goalTargetHint: "Siempre podr√°s editarlo en el perfil.",
    goalTargetCTA: "Guardar monto",
    goalTargetError: "Introduce un monto objetivo",
    goalTargetLabel: "Monto de la meta",
    primaryGoalLabel: "Meta principal",
    primaryGoalLocked: "Podr√°s cambiar la meta principal desde el perfil.",
    primaryGoalRemaining: "Quedan {{amount}}",
    goalWidgetTargetLabel: "Meta: {{amount}}",
    goalWidgetRemaining: "Faltan {{amount}}",
    goalWidgetComplete: "Meta completada",
    goalWidgetTitle: "Hacia la meta",
    goalWidgetCompleteTagline: "Los ahorros siguieron llegando: misi√≥n cumplida.",
    goalAssignPromptTitle: "¬øA qu√© meta ir√° este ahorro?",
    goalAssignPromptSubtitle: "Elige la meta que financiar√° ¬´{{title}}¬ª.",
    goalAssignNone: "Sin meta a√∫n",
    goalAssignTemptationTitle: "Asignar tentaci√≥n",
    goalAssignTemptationSubtitle: "¬øQu√© h√°bito alimenta ¬´{{goal}}¬ª?",
    goalAssignClear: "Quitar asignaci√≥n",
    goalAssignFieldLabel: "Env√≠a el ahorro a",
    goalMainTemptationError: "La tentaci√≥n principal no se puede convertir en una meta.",
    goalDestinationLabel: "Ahorrando para",
    goalStatusInWishlist: "A√±adir a la meta",
    goalSwipeAdd: "A√±adir a meta",
    goalSwipeDelete: "Eliminar",
    goalPinnedBadge: "Meta",
    goalRemoved: "Meta eliminada",
    goalEditAction: "Editar",
    goalDeleteAction: "Quitar",
    goalEditModalTitle: "Editar meta",
    goalEditNameLabel: "Nombre de la meta",
    goalEditTargetLabel: "Monto objetivo",
    goalEditEmojiLabel: "Emoji",
    goalEditSave: "Guardar",
    goalEditCancel: "Cancelar",
    goalEditNameError: "Introduce un nombre",
    goalEditTargetError: "Define un monto",
    goalCelebrationTitle: "¬°Meta principal cumplida!",
    goalCelebrationSubtitle: "Almi est√° orgulloso: elige el siguiente sue√±o.",
    goalCelebrationTarget: "Ahorrado {{amount}}",
    goalRenewalTitle: "Elige una nueva meta principal",
    goalRenewalSubtitle: "Esta ya est√° lista: fija un nuevo objetivo para mantener la racha.",
    goalRenewalCreate: "Crear meta",
    goalRenewalLater: "Luego",
    levelWidgetTitle: "Progreso de nivel",
    levelWidgetCurrent: "Nivel {{level}}",
    levelWidgetSubtitle: "{{amount}} para el siguiente nivel",
    levelWidgetTarget: "Siguiente nivel a {{amount}}",
    levelWidgetMaxed: "¬°Lograste el nivel m√°ximo!",
    onboardingGuideTitle: "De qu√© trata Almost",
    onboardingGuideSubtitle: "Un ant√≠doto consciente contra el consumismo y los impulsos.",
    onboardingGuideButton: "Continuar",
    termsTitle: "T√©rminos de uso",
    termsSubtitle: "Revisa los puntos clave. Al seguir, aceptas los T√©rminos de Almost.",
    termsViewFull: "Abrir documento completo",
    termsLinkHint: "Lo abriremos en el navegador.",
    termsAccept: "Acepto",
    termsDecline: "Cancelar",
    guideStepTrackTitle: "Tu misi√≥n principal",
    guideStepTrackDesc: "Gasta de forma consciente, protege el presupuesto y enf√≥cate en lo que importa.",
    guideStepDecisionTitle: "Men√∫ de tentaciones",
    guideStepDecisionDesc: "Registra cada impulso y res√≠stelo para que Almost cuente la victoria.",
    guideStepRewardTitle: "Visualiza el panorama",
    guideStepRewardDesc: "Marca cada ahorro y observa c√≥mo la app dibuja la meta mayor.",
    personaTitle: "Cu√©ntanos de ti",
    personaSubtitle: "As√≠ personalizamos la experiencia.",
    personaGenderLabel: "¬øC√≥mo te llamamos?",
    personaHabitLabel: "Perfil con el que m√°s te identificas",
    personaConfirm: "Continuar",
    customSpendTitle: "Tu tentaci√≥n diaria",
    customSpendSubtitle: "Ponle un nombre y Almost te ayudar√° a decir que no.",
    customSpendNamePlaceholder: "Matcha, cigarros, manicura...",
    customSpendAmountLabel: "¬øCu√°nto cuesta cada vez?",
    customSpendAmountPlaceholder: "Ingresa el monto",
    customSpendFrequencyLabel: "¬øCu√°ntas veces por semana gana?",
    customSpendFrequencyPlaceholder: "Ej. 4",
    customSpendHint: "Puedes cambiarlo en tu perfil.",
    customSpendSkip: "Saltar",
    smartReminderTitle: [
      "Almost detect√≥ ¬´{{temptation}}¬ª",
      "Almi avisa: ¬´{{temptation}}¬ª",
      "Ping Almost: ¬´{{temptation}}¬ª",
    ],
    smartReminderBody: [
      "Registraste ¬´{{temptation}}¬ª hace poco. Repite la pausa y env√≠a el dinero a tu meta.",
      "Almost vio este h√°bito: respira antes de ¬´{{temptation}}¬ª y elige ahorrar.",
      "Mant√©n la racha. ¬´{{temptation}}¬ª puede esperar un poco m√°s.",
      "Tip: cada vez que saltas ¬´{{temptation}}¬ª, Almost afina sus ideas.",
    ],
    smartInsightDeclineTitle: "Victoria ayer: ¬´{{temptation}}¬ª",
    smartInsightDeclineBody: "Dile que no otra vez hoy y Almost fijar√° la racha.",
    smartInsightSpendTitle: "Ayer gan√≥ ¬´{{temptation}}¬ª",
    smartInsightSpendBody: "Mant√©n la calma hoy para celebrar un ahorro.",
    dailyNudgeMorningTitle: ["Empuj√≥n matutino de Almost", "Chequeo de enfoque de Almi"],
    dailyNudgeMorningBody: [
      "Marca el ritmo: salta el primer impulso y recuerda tu meta.",
      "Almi pasa revista: haz una pausa antes del primer pago de hoy.",
    ],
    dailyNudgeDayTitle: ["Chequeo Almost al mediod√≠a", "Impulso de enfoque de Almi"],
    dailyNudgeDayBody: [
      "Los impulsos suben a esta hora. Pregunta si la compra sirve a tu meta.",
      "Almost not√≥ caprichos a la hora de comer. Haz una pausa consciente.",
    ],
    dailyNudgeAfternoonTitle: ["Ping tarde de Almost", "Frena con Almi"],
    dailyNudgeAfternoonBody: [
      "Respira antes de tocar comprar y redirige el dinero al ahorro.",
      "¬øTentaciones al acecho? Mant√©n el rumbo y recuerda tu meta.",
    ],
    dailyNudgeEveningTitle: ["Escudo nocturno de Almost", "Cierre del d√≠a con Almi"],
    dailyNudgeEveningBody: [
      "Las noches tientan m√°s. Registra una victoria antes de dormir.",
      "Cierra el d√≠a en Almost: incluso un peque√±o ahorro mantiene listos los recordatorios.",
    ],
    dailySummaryBadgeLabel: "reporte nocturno",
    dailySummaryTitle: "Resumen del d√≠a",
    dailySummarySubtitle: "Qu√© ritmo, sigue as√≠.",
    dailySummarySavedLabel: "Ahorro de hoy",
    dailySummarySavedSub: "Cada renuncia acerca la meta.",
    dailySummarySpendsLabel: "Gastos",
    dailySummaryContinue: "Continuar",
    dailySummaryHint: "Ma√±ana vuelvo con n√∫meros frescos.",
    baselineTitle: "¬øCu√°nto se va en peque√±os caprichos?",
    baselineSubtitle: "Calcula un mes de caf√©s, snacks y compras impulsivas para compararlo con tus victorias reales.",
    baselinePlaceholder: "Ingresa el monto",
    baselineCTA: "Guardar monto",
    baselineHint: "Un aproximado basta; podr√°s ajustarlo en Perfil.",
    baselineInputError: "Introduce tu gasto mensual estimado en extras",
    potentialBlockTitle: "Potencial vs ahorro real",
    potentialBlockSubtitle: "",
    potentialBlockStatusAhead: "¬°Vas por delante del pron√≥stico!",
    potentialBlockStatusStart: "Empieza a registrar rechazos: el potencial espera.",
    potentialBlockStatusBehind: "Vas bien, pero el potencial es mayor.",
    potentialBlockStatusOnTrack: "Est√°s aprovechando casi todo el potencial. Sigue as√≠.",
    potentialBlockActualLabel: "Ahorrado",
    potentialBlockPotentialLabel: "Potencial",
    potentialBlockHint: "A√∫n quedan {{amount}} de potencial. Nothing is lost üôÇ",
    potentialBlockDetails:
      "Usamos el presupuesto mensual de tentaciones que pusiste en el onboarding, lo dividimos en segundos y mostramos cu√°nto podr√≠as haber ahorrado hasta ahora.",
    potentialBlockCta: "Cu√©ntanos cu√°nto suele escaparse en extras y te mostraremos el potencial.",
    potentialPushAheadTitle: "¬°Vas delante del potencial!",
    potentialPushAheadBody:
      "El contador lleg√≥ a {{potential}} y t√∫ ya est√°s en {{actual}}. Mant√©n ese ritmo.",
    potentialPushBehindTitle: "Alcanza el potencial",
    potentialPushBehindBody:
      "El potencial ya va por {{potential}}; faltan {{shortfall}}. Pausa antes de comprar y registra un ahorro.",
    quickCustomTitle: "A√±adir tentaci√≥n",
    quickCustomSubtitle: "Nombra el impulso y define un precio para a√±adirlo al mazo",
    quickCustomNameLabel: "Nombre",
    quickCustomAmountLabel: "Costo ({{currency}})",
    quickCustomEmojiLabel: "Emoji",
    quickCustomConfirm: "A√±adir",
    quickCustomCancel: "Cancelar",
    coinEntryTitle: "¬øCu√°nto?",
    coinEntrySubtitle: "Desliza la moneda y elige categor√≠a.",
    coinEntryHint: "Usa los botones de arriba para ahorrar o gastar.",
    coinEntryManual: "...",
    coinEntryManualTitle: "Define un nuevo m√°ximo",
    coinEntryManualPlaceholder: "Ingresa el monto",
    coinEntryManualSave: "Recordar",
    coinEntryManualCancel: "Cancelar",
    coinEntryManualError: "Introduce un monto v√°lido",
    coinEntryManualAmountTitle: "Ingresa un monto manual",
    coinEntryManualAmountPlaceholder: "Ingresa el monto",
    coinEntryCategoryLabel: "Categor√≠a",
    coinEntryCategoryError: "Primero elige una categor√≠a",
    coinEntrySaveLabel: "Ahorro r√°pido",
    coinEntrySpendLabel: "Gasto r√°pido",
    fabNewGoal: "Nueva meta",
    fabNewTemptation: "Nuevo gasto",
    fabQuickActionTitle: "√öltima tentaci√≥n",
    fabQuickActionSubtitle: "Repite la acci√≥n para ¬´{{title}}¬ª",
    fabQuickActionEmpty: "A√∫n no hay tentaci√≥n reciente. Interact√∫a con una tarjeta.",
    fabTutorialTitle: "Conoce el ‚Äú+‚Äù",
    fabTutorialDesc:
      "Toca para registrar impulsos con tu propio monto y categor√≠a. Mant√©n presionado para crear metas o gastos personalizados.",
    fabTutorialAction: "Entendido",
    newGoalTitle: "Nueva meta",
    newGoalSubtitle: "Ponle nombre al sue√±o y define su importe.",
    newGoalNameLabel: "Nombre",
    newGoalTargetLabel: "Objetivo ({{currency}})",
    newGoalEmojiLabel: "Emoji",
    newGoalCreate: "Crear meta",
    newGoalCancel: "Cancelar",
    newPendingTitle: "Nuevo elemento En pausa",
    newPendingSubtitle: "Describe la tentaci√≥n que quieres aparcar 14 d√≠as.",
    newPendingNameLabel: "Nombre",
    newPendingAmountLabel: "Precio ({{currency}})",
    newPendingEmojiLabel: "Emoji",
    newPendingCreate: "A√±adir a En pausa",
    newPendingCancel: "Cancelar",
    tutorialFeedTitle: "Feed de tentaciones",
    tutorialFeedDesc: "Registra cada impulso y decide: guardar, a√±adir a metas o pausar 14 d√≠as.",
    tutorialGoalsTitle: "Metas",
    tutorialGoalsDesc: "Aqu√≠ viven los sue√±os. Sigue el progreso y recarga tu meta.",
    tutorialThinkingTitle: "Pesta√±a En pausa",
    tutorialThinkingDesc: "Pon las compras en pausa 14 d√≠as y vuelve con la cabeza fr√≠a.",
    tutorialRewardsTitle: "Recompensas y retos",
    tutorialRewardsDesc: "En esta pesta√±a cobras logros y lanzas retos con bono de salud.",
    tutorialProfileTitle: "Perfil y motivaci√≥n",
    tutorialProfileDesc: "Ajusta tema, idioma, recordatorios y tus objetivos personales.",
    tutorialSkip: "Saltar",
    tutorialNext: "Siguiente",
    tutorialDone: "Finalizar",
    tutorialProgress: "{{current}} de {{total}}",
    tabHintFeedTitle: "Feed de tentaciones",
    tabHintFeedBody: "Registra impulsos y decide si ahorras, lo a√±ades a metas o lo pospones.",
    tabHintCartTitle: "Metas",
    tabHintCartBody: "Ordena tus sue√±os, fija prioridades y actualiza el progreso.",
    tabHintPendingTitle: "En pausa",
    tabHintPendingBody: "Env√≠a compras a una espera de 14 d√≠as y vuelve m√°s objetiva.",
    tabHintPurchasesTitle: "Recompensas",
    tabHintPurchasesBody: "Cobra logros y activa retos para ganar salud adicional.",
    tabHintProfileTitle: "Perfil",
    tabHintProfileBody: "Ajusta tema, idioma, recordatorios y metas personales.",
    tabHintGotIt: "Entendido",
  },
};

const LANGUAGE_OVERRIDES = {
  es: {
    languageLabel: "Idioma",
    languageTitle: "Elige idioma",
    languageSubtitle: "Configura el idioma y la moneda antes de empezar",
    languageRussian: "Ruso",
    languageEnglish: "Ingl√©s",
    languageSpanish: "Espa√±ol",
  },
  fr: {
    languageLabel: "Langue",
    languageTitle: "Choisir une langue",
    languageSubtitle: "Configure la langue et la devise avant de commencer",
    languageRussian: "Russe",
    languageEnglish: "Anglais",
    languageSpanish: "Espagnol",
    languageFrench: "Fran√ßais",
  },
};
const resolveTranslationValueForLanguage = (language, key, gender = "none") => {
  const normalizedLanguage = normalizeLanguage(language);
  const override = LANGUAGE_OVERRIDES[normalizedLanguage]?.[key];
  const dictionary = TRANSLATIONS[normalizedLanguage] || {};
  let raw =
    override !== undefined
      ? override
      : dictionary[key] ??
        TRANSLATIONS[FALLBACK_LANGUAGE]?.[key] ??
        TRANSLATIONS[DEFAULT_LANGUAGE]?.[key];
  if (raw && typeof raw === "object" && !Array.isArray(raw)) {
    const genderValue = raw[gender];
    if (typeof genderValue === "string") {
      raw = genderValue;
    } else if (typeof raw.none === "string") {
      raw = raw.none;
    } else {
      const fallbackValue = Object.values(raw).find((value) => typeof value === "string");
      raw = fallbackValue !== undefined ? fallbackValue : undefined;
    }
  }
  return raw;
};

const resolveLanguageMapValue = (value, language) => {
  if (!value || typeof value !== "object" || Array.isArray(value)) return null;
  const normalizedLanguage = normalizeLanguage(language);
  const direct = value[normalizedLanguage];
  if (typeof direct === "string" && direct.length) {
    return direct;
  }
  const fallback = value[FALLBACK_LANGUAGE];
  if (typeof fallback === "string" && fallback.length) {
    return fallback;
  }
  const defaultValue = value[DEFAULT_LANGUAGE];
  if (typeof defaultValue === "string" && defaultValue.length) {
    return defaultValue;
  }
  const generic = Object.values(value).find((entry) => typeof entry === "string" && entry.length);
  return typeof generic === "string" ? generic : null;
};
const collectDailyNudgeVariants = (keys = []) => {
  const variants = new Set();
  DAILY_NUDGE_LANGUAGES.forEach((lng) => {
    const dict = TRANSLATIONS[lng] || TRANSLATIONS[FALLBACK_LANGUAGE] || {};
    keys.forEach((key) => {
      const raw = dict[key];
      if (Array.isArray(raw)) {
        raw.forEach((value) => {
          if (typeof value === "string") {
            const normalized = value.trim();
            if (normalized.length) {
              variants.add(normalized);
            }
          }
        });
      } else if (typeof raw === "string") {
        const normalized = raw.trim();
        if (normalized.length) {
          variants.add(normalized);
        }
      }
    });
  });
  return variants;
};
const DAILY_NUDGE_TITLE_VARIANTS = collectDailyNudgeVariants(DAILY_NUDGE_TITLE_KEYS);
const DAILY_NUDGE_BODY_VARIANTS = collectDailyNudgeVariants(DAILY_NUDGE_BODY_KEYS);
const matchesDailyNudgeText = (text, variants) => {
  if (typeof text !== "string") return false;
  const normalized = text.trim();
  return normalized.length > 0 && variants.has(normalized);
};
const isKnownDailyNudgeNotification = (content = {}) => {
  if (!content) return false;
  const data = content.data;
  if (data?.type === DAILY_NUDGE_NOTIFICATION_TAG || data?.tag === DAILY_NUDGE_NOTIFICATION_TAG) {
    return true;
  }
  return (
    matchesDailyNudgeText(content.title, DAILY_NUDGE_TITLE_VARIANTS) &&
    matchesDailyNudgeText(content.body, DAILY_NUDGE_BODY_VARIANTS)
  );
};

const CATEGORY_LABELS = {
  all: { ru: "–≤—Å–µ", en: "all", es: "todo", fr: "tout" },
  tech: { ru: "—Ç–µ—Ö–Ω–∏–∫–∞", en: "tech", es: "tecnolog√≠a", fr: "tech" },
  flagship: { ru: "—Ñ–ª–∞–≥–º–∞–Ω", en: "flagship", es: "gama alta", fr: "haut de gamme" },
  iphone: { ru: "iphone", en: "iphone", es: "iphone", fr: "iphone" },
  laptop: { ru: "–Ω–æ—É—Ç", en: "laptop", es: "port√°til", fr: "portable" },
  work: { ru: "—Ä–∞–±–æ—Ç–∞", en: "work", es: "trabajo", fr: "travail" },
  audio: { ru: "–∞—É–¥–∏–æ", en: "audio", es: "audio", fr: "audio" },
  style: { ru: "—Å—Ç–∏–ª—å", en: "style", es: "estilo", fr: "style" },
  wearable: { ru: "–Ω–æ—Å–∏–º–æ–µ", en: "wearable", es: "wearable", fr: "wearable" },
  sport: { ru: "—Å–ø–æ—Ä—Ç", en: "sport", es: "deporte", fr: "sport" },
  home: { ru: "–¥–æ–º", en: "home", es: "hogar", fr: "maison" },
  wow: { ru: "–≤–∞—É", en: "wow", es: "wow", fr: "wow" },
  gift: { ru: "–ø–æ–¥–∞—Ä–∫–∏", en: "gift", es: "regalo", fr: "cadeau" },
  coffee: { ru: "–∫–æ—Ñ–µ", en: "coffee", es: "caf√©", fr: "caf√©" },
  eco: { ru: "—ç–∫–æ", en: "eco", es: "eco", fr: "√©co" },
  food: { ru: "–µ–¥–∞", en: "food", es: "comida", fr: "nourriture" },
  wellness: { ru: "–∑–∞–±–æ—Ç–∞", en: "wellness", es: "bienestar", fr: "bien-√™tre" },
  retro: { ru: "—Ä–µ—Ç—Ä–æ", en: "retro", es: "retro", fr: "r√©tro" },
  lifestyle: { ru: "–ª–∞–π—Ñ", en: "lifestyle", es: "lifestyle", fr: "lifestyle" },
  stationery: { ru: "–±—É–º–∞–≥–∞", en: "stationery", es: "papeler√≠a", fr: "papeterie" },
  phone: { ru: "—Ç–µ–ª–µ—Ñ–æ–Ω", en: "phone", es: "tel√©fono", fr: "t√©l√©phone" },
  travel: { ru: "–ø—É—Ç–µ—à–µ—Å—Ç–≤–∏—è", en: "travel", es: "viajes", fr: "voyage" },
  dream: { ru: "–º–µ—á—Ç—ã", en: "dream", es: "sue√±os", fr: "r√™ves" },
  habit: { ru: "–ø—Ä–∏–≤—ã—á–∫–∏", en: "habit", es: "h√°bito", fr: "habitudes" },
  habbit: { ru: "–ø—Ä–∏–≤—ã—á–∫–∏", en: "habit", es: "h√°bito", fr: "habitudes" },
  custom: { ru: "—Å–≤–æ–∏", en: "custom", es: "personal", fr: "perso" },
  daily: { ru: "–µ–∂–µ–¥–Ω–µ–≤–Ω–æ–µ", en: "daily", es: "diario", fr: "quotidien" },
  health: { ru: "–∑–¥–æ—Ä–æ–≤—å–µ", en: "health", es: "salud", fr: "sant√©" },
  vices: { ru: "–≤—Ä–µ–¥–Ω—ã–µ", en: "vices", es: "vicios", fr: "vices" },
};

const normalizeCategoryKey = (value) => {
  if (typeof value !== "string") return "";
  return value.trim().toLowerCase();
};

const resolveCategoryLabel = (categoryKey, language = "en") => {
  const normalized = normalizeCategoryKey(categoryKey);
  const entry = CATEGORY_LABELS[normalized] || CATEGORY_LABELS[categoryKey];
  const fallback = normalized || categoryKey || "";
  const localized = entry?.[language] || entry?.en || fallback;
  return localized.toUpperCase();
};

const CURRENCIES = ["AED", "AUD", "BYN", "CAD", "EUR", "GBP", "JPY", "KZT", "KRW", "MXN", "PLN", "RUB", "SAR", "USD"];

const CURRENCY_LOCALES = {
  AED: "en-AE",
  AUD: "en-AU",
  BYN: "be-BY",
  CAD: "en-CA",
  EUR: "de-DE",
  GBP: "en-GB",
  JPY: "ja-JP",
  KZT: "kk-KZ",
  KRW: "ko-KR",
  MXN: "es-MX",
  PLN: "pl-PL",
  RUB: "ru-RU",
  SAR: "en-US", // keep layout LTR; symbol handled manually
  USD: "en-US",
};

const TERMS_LINKS = {
  ru: "https://www.notion.so/RU-2b24e58ea9a0809ea04fe54138975e96",
  en: "https://www.notion.so/TERMS-OF-USE-EN-2b24e58ea9a0801292ead33eba50d02b",
  es: "https://www.notion.so/T-RMINOS-DE-USO-ES-2d14e58ea9a080988f5bed55ccea3c2e?source=copy_link",
  fr: "https://www.notion.so/CONDITIONS-D-UTILISATION-FR-2d14e58ea9a080dd9c53dcf52d5eb3e0?source=copy_link",
};

const PRIVACY_LINKS = {
  ru: "https://www.notion.so/RU-2b24e58ea9a08032b017d3a5c69bbf48",
  en: "https://www.notion.so/PRIVACY-POLICY-EN-2b24e58ea9a08033abe7e038e63a2003",
  es: "https://www.notion.so/POL-TICA-DE-PRIVACIDAD-ES-2d14e58ea9a080a09132c0bc8d722b7b?source=copy_link",
  fr: "https://www.notion.so/POLITIQUE-DE-CONFIDENTIALIT-FR-2d14e58ea9a080628e6bc7cdaef3f451?source=copy_link",
};

const TERMS_POINTS = {
  ru: [
    "Almost –ø–æ–º–æ–≥–∞–µ—Ç —Ä–∞–∑–≤–∏–≤–∞—Ç—å –æ—Å–æ–∑–Ω–∞–Ω–Ω–æ—Å—Ç—å –≤ —Ç—Ä–∞—Ç–∞—Ö –∏ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –±–∞–Ω–∫–æ–º, –±—Ä–æ–∫–µ—Ä–æ–º –∏–ª–∏ —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã–º –∫–æ–Ω—Å—É–ª—å—Ç–∞–Ω—Ç–æ–º. –õ—é–±—ã–µ —Ä–µ—à–µ–Ω–∏—è –æ —Ä–∞—Å—Ö–æ–¥–∞—Ö –∏ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è—Ö –æ—Å—Ç–∞—é—Ç—Å—è –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.",
    "–¢—ã –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—à—å, —á—Ç–æ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–µ—Ä–µ–¥–∞–Ω—ã –¥–æ–±—Ä–æ–≤–æ–ª—å–Ω–æ, —Ç–æ—á–Ω—ã –∏ –º–æ–≥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è Almost –¥–ª—è –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–µ—Ä–≤–∏—Å–∞, —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ –≤ –æ–±–µ–∑–ª–∏—á–µ–Ω–Ω–æ–º –≤–∏–¥–µ.",
    "–ú—ã —Å–æ–±–∏—Ä–∞–µ–º –∏ —Ö—Ä–∞–Ω–∏–º —Ç–æ–ª—å–∫–æ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –¥–∞–Ω–Ω—ã–µ –ø—Ä–æ—Ñ–∏–ª—è. –¢—ã –º–æ–∂–µ—à—å –æ–±–Ω–æ–≤–∏—Ç—å –∏–ª–∏ —É–¥–∞–ª–∏—Ç—å –∏—Ö —á–µ—Ä–µ–∑ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏ –ø–æ–¥–¥–µ—Ä–∂–∫—É. –ü—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è –º—ã —Å—Ç–∏—Ä–∞–µ–º —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è –∏ –∏—Å—Ç–æ—Ä–∏—é.",
    "–°–æ–≥–ª–∞—à–µ–Ω–∏–µ —Ä–µ–≥—É–ª–∏—Ä—É–µ—Ç—Å—è –∑–∞–∫–æ–Ω–æ–¥–∞—Ç–µ–ª—å—Å—Ç–≤–æ–º —Å—Ç—Ä–∞–Ω—ã —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ Almost. –°–ø–æ—Ä—ã —Ä–µ—à–∞—é—Ç—Å—è –ø–µ—Ä–µ–≥–æ–≤–æ—Ä–∞–º–∏, –∞ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ - –≤ —Å—É–¥–µ –ø–æ –º–µ—Å—Ç—É —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ —Å–µ—Ä–≤–∏—Å–∞.",
  ],
  en: [
    "Almost is a mindful spending companion, not a bank, broker, or financial advisor. Every decision about saving or spending remains your responsibility.",
    "You confirm that the information you share is accurate and voluntarily provided so Almost can personalise hints, notifications, and anonymised analytics.",
    "We store only the minimum profile data required to operate the app. You can edit or request deletion via settings and support, which wipes related history from our systems.",
    "This agreement is governed by the laws of the jurisdiction where Almost is registered. Any dispute is settled amicably first and, if needed, in the courts of that jurisdiction.",
  ],
  es: [
    "Almost te ayuda a desarrollar h√°bitos conscientes de gasto y no es un banco, br√≥ker ni asesor financiero. Cada decisi√≥n de ahorro o gasto sigue siendo tu responsabilidad.",
    "Confirmas que la informaci√≥n compartida es precisa y se entrega de forma voluntaria para que Almost pueda personalizar recordatorios, notificaciones y anal√≠ticas an√≥nimas.",
    "Guardamos solo los datos m√≠nimos del perfil para que la app funcione. Puedes editarlos o pedir su eliminaci√≥n desde los ajustes o soporte; al eliminar el perfil se borra tambi√©n el historial relacionado.",
    "Este acuerdo se rige por las leyes de la jurisdicci√≥n donde est√° registrado Almost. Los conflictos se intentan resolver de forma amistosa y, si es necesario, en los tribunales de dicha jurisdicci√≥n.",
  ],
  fr: [
    "Almost est un compagnon de d√©penses conscientes, pas une banque, un courtier ni un conseiller financier. Chaque d√©cision d‚Äô√©pargner ou de d√©penser reste sous ta responsabilit√©.",
    "Tu confirmes que les informations fournies sont exactes et transmises volontairement pour qu‚ÄôAlmost puisse personnaliser les conseils, notifications et analyses anonymis√©es.",
    "Nous conservons uniquement les donn√©es minimales du profil n√©cessaires au fonctionnement de l‚Äôapp. Tu peux les modifier ou demander leur suppression via les r√©glages ou le support ; la suppression efface aussi l‚Äôhistorique li√©.",
    "Le pr√©sent accord est r√©gi par les lois de la juridiction o√π Almost est enregistr√©. Les litiges se r√®glent d‚Äôabord √† l‚Äôamiable puis, si besoin, devant les tribunaux comp√©tents de cette juridiction.",
  ],
};

const HOW_IT_WORKS_STEPS = [
  { id: "track", emoji: "üì∏", titleKey: "guideStepTrackTitle", descKey: "guideStepTrackDesc" },
  { id: "decide", emoji: "üéØ", titleKey: "guideStepDecisionTitle", descKey: "guideStepDecisionDesc" },
  { id: "reward", emoji: "üèÜ", titleKey: "guideStepRewardTitle", descKey: "guideStepRewardDesc" },
];

const PERSONA_PRESETS = {
  mindful_coffee: {
    id: "mindful_coffee",
    emoji: "‚òïÔ∏è",
    title: {
      ru: "–õ—é–±–∏—Ç–µ–ª—å –∫–æ—Ñ–µ",
      en: "Coffee devotee",
      es: "Fan del caf√©",
      fr: "Fan de caf√©",
    },
    description: {
      ru: "–ü–µ—Ä–≤–∞—è —Ü–µ–ª—å: –∑–∞–º–µ–¥–ª–∏—Ç—å –ø–æ—Ö–æ–¥—ã –∑–∞ –∫–æ—Ñ–µ –Ω–∞–≤—ã–Ω–æ—Å.",
      en: "Goal one: slow down the take-away coffee habit.",
      es: "Primer paso: reducir los caf√©s para llevar.",
      fr: "Objectif n¬∞1 : freiner la manie du caf√© √† emporter.",
    },
    tagline: {
      ru: "–ö–∞–∂–¥–∞—è –Ω–µ–∫—É–ø–ª–µ–Ω–Ω–∞—è —á–∞—à–∫–∞ –¥–∞—Ä–∏—Ç +{{amount}} –∫–æ–ø–∏–ª–∫–µ.",
      en: "Every skipped cup adds +{{amount}} to the stash.",
      es: "Cada taza que saltas suma +{{amount}} al cofre.",
      fr: "Chaque tasse √©vit√©e ajoute +{{amount}} √† la cagnotte.",
    },
    habit: {
      emoji: "‚òïÔ∏è",
      color: "#FFF3E0",
      categories: ["habit", "daily"],
      basePriceUSD: 5,
      title: {
        ru: "–ö–æ—Ñ–µ –Ω–∞–≤—ã–Ω–æ—Å",
        en: "Coffee run",
        es: "Caf√© para llevar",
        fr: "Course caf√©",
      },
      description: {
        ru: "–°–ª–∞–¥–∫–∏–π –º–æ–º–µ–Ω—Ç —Å–ª–∞–±–æ—Å—Ç–∏ –∫–∞–∂–¥–æ–µ —É—Ç—Ä–æ.",
        en: "Sweet little impulse every morning.",
        es: "Ese peque√±o impulso dulce de cada ma√±ana.",
        fr: "Petit √©cart sucr√© de chaque matin.",
      },
    },
  },
  habit_smoking: {
    id: "habit_smoking",
    emoji: "üö¨",
    title: {
      ru: "–û—Ç–∫–∞–∑ –æ—Ç —Å–∏–≥–∞—Ä–µ—Ç",
      en: "Quit smoking",
      es: "Dejar de fumar",
      fr: "Arr√™ter de fumer",
    },
    description: {
      ru: "–ü–µ—Ä–≤–∞—è —Å—Ç—É–ø–µ–Ω—å: –º–µ–Ω—å—à–µ —Å–ª—É—á–∞–π–Ω—ã—Ö —Å–∏–≥–∞—Ä–µ—Ç –∏ –ø–µ—Ä–µ–∫—É—Ä–æ–≤.",
      en: "First tier: fewer casual cigarettes and smoke breaks.",
      es: "Primer nivel: menos cigarrillos casuales y descansos de humo.",
      fr: "Premier palier : moins de cigarettes prises ¬´ au cas o√π ¬ª et de pauses clope.",
    },
    tagline: {
      ru: "–ö–∞–∂–¥–∞—è –ø—Ä–æ–ø—É—â–µ–Ω–Ω–∞—è —Å–∏–≥–∞—Ä–µ—Ç–∞ –¥–µ—Ä–∂–∏—Ç –±—é–¥–∂–µ—Ç –≤ —Ç–æ–Ω—É—Å–µ.",
      en: "Every skipped cigarette keeps the budget sharp.",
      es: "Cada cigarro que saltas mantiene el presupuesto firme.",
      fr: "Chaque cigarette √©vit√©e garde ton budget aff√ªt√©.",
    },
    habit: {
      emoji: "üö¨",
      color: "#FFE8E0",
      categories: ["habit", "health"],
      basePriceUSD: 7,
      title: {
        ru: "–ü–∞—á–∫–∞ —Å–∏–≥–∞—Ä–µ—Ç",
        en: "Pack of cigarettes",
        es: "Paquete de cigarrillos",
        fr: "Paquet de cigarettes",
      },
      description: {
        ru: "–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å –ø–µ—Ä–µ–∫—É—Ä –∑–Ω–∞—á–∏—Ç —É—Å–∫–æ—Ä–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å.",
        en: "Skip the smoke break, speed up the progress.",
        es: "Saltarte el cigarro acelera el progreso.",
        fr: "Sauter une pause clope acc√©l√®re le progr√®s.",
      },
    },
  },
  glam_beauty: {
    id: "glam_beauty",
    emoji: "üíÑ",
    audience: ["female"],
    title: {
      ru: "–ë—å—é—Ç–∏-—Ñ–∞–Ω–∞—Ç",
      en: "Beauty fan",
      es: "Fan√°tica del beauty",
      fr: "Fan de beaut√©",
    },
    description: {
      ru: "–ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ–º —Å–ø–æ–Ω—Ç–∞–Ω–Ω—ã–µ –±—å—é—Ç–∏-–ø–æ–∫—É–ø–∫–∏ –∏ –ø–æ–¥–ø–∏—Å–∫–∏.",
      en: "Keep beauty splurges and subs in check.",
      es: "Domina las compras y suscripciones de belleza.",
      fr: "On garde les achats et abonnements beaut√© sous contr√¥le.",
    },
    tagline: {
      ru: "–û–¥–∏–Ω –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–π –±—å—é—Ç–∏-–¥—Ä–æ–ø = {{amount}} –¥–ª—è –±–æ–ª—å—à–æ–π —Ü–µ–ª–∏.",
      en: "One skipped beauty drop = {{amount}} toward the big goal.",
      es: "Cada beauty drop que saltas suma {{amount}} a la meta mayor.",
      fr: "Chaque drop beaut√© √©vit√© = {{amount}} en plus pour ton grand objectif.",
    },
    habit: {
      emoji: "üíÑ",
      color: "#FFE5F1",
      categories: ["style", "habit"],
      basePriceUSD: 18,
      title: {
        ru: "–ú–∏–Ω–∏ –±—å—é—Ç–∏-–¥—Ä–æ–ø",
        en: "Mini beauty haul",
        es: "Mini compra beauty",
        fr: "Mini craquage beaut√©",
      },
      description: {
        ru: "–¢–µ–Ω–∏, –ø–æ–º–∞–¥–∞ –∏ –µ—â—ë –æ–¥–∏–Ω ¬´–Ω—É–∂–Ω—ã–π¬ª —É—Ö–æ–¥.",
        en: "Shadow, lipstick and yet another ‚Äúneeded‚Äù serum.",
        es: "Sombras, labial y otro serum ‚Äúimprescindible‚Äù.",
        fr: "Fard, rouge et un √©ni√®me s√©rum soi-disant indispensable.",
      },
    },
  },
  gamer_loot: {
    id: "gamer_loot",
    emoji: "üéÆ",
    audience: ["male"],
    title: {
      ru: "–ì–µ–π–º–µ—Ä",
      en: "Gamer",
      es: "Gamer",
      fr: "Gamer",
    },
    description: {
      ru: "–ó–∞–º–µ–¥–ª—è–µ–º –¥–æ–Ω–∞—Ç—ã, –ª—É—Ç–±–æ–∫—Å—ã –∏ –Ω–æ—á–Ω—ã–µ DLC.",
      en: "Cool down loot boxes, microtransactions and DLC binges.",
      es: "Baja el ritmo de loot boxes, DLC y microtransacciones.",
      fr: "On calme les loot boxes, microtransactions et DLC nocturnes.",
    },
    tagline: {
      ru: "–ö–∞–∂–¥—ã–π –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–π –¥–æ–Ω–∞—Ç = {{amount}} –Ω–∞ –º–µ—á—Ç—É IRL.",
      en: "Every skipped microtransaction frees {{amount}} for IRL goals.",
      es: "Cada donaci√≥n que evitas libera {{amount}} para metas reales.",
      fr: "Chaque microtransaction √©vit√©e lib√®re {{amount}} pour tes buts IRL.",
    },
    habit: {
      emoji: "üéÆ",
      color: "#D9F7FF",
      categories: ["wow", "habit"],
      basePriceUSD: 10,
      title: {
        ru: "–ò–≥—Ä–æ–≤–æ–π –¥–æ–Ω–∞—Ç",
        en: "Game microtransaction",
        es: "Microtransacci√≥n",
        fr: "Microtransaction",
      },
      description: {
        ru: "–ü–∞—Ä–∞ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö —Å–∫–∏–Ω–æ–≤ –¥–∞—ë—Ç –ø–ª—é—Å –∫ –ø—Ä–æ–≥—Ä–µ—Å—Å—É.",
        en: "Skip a couple skins, gain momentum.",
        es: "Salta un par de skins y gana impulso.",
        fr: "Saute deux skins et tu gagnes en vitesse.",
      },
    },
  },
  foodie_delivery: {
    id: "foodie_delivery",
    emoji: "üçï",
    title: {
      ru: "–õ—é–±–∏—Ç–µ–ª—å –¥–æ—Å—Ç–∞–≤–∫–∏",
      en: "Delivery lover",
      es: "Fan de la entrega",
      fr: "Accro √† la livraison",
    },
    description: {
      ru: "–ü–µ—Ä–≤–∞—è –º–∏—Å—Å–∏—è: –º–µ–Ω—å—à–µ —Å–ø–æ–Ω—Ç–∞–Ω–Ω–æ–π –µ–¥—ã –∏–∑ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.",
      en: "Mission one: fewer random delivery orders.",
      es: "Misi√≥n uno: menos pedidos impulsivos en apps.",
      fr: "Mission 1 : moins de commandes impulsives via l'app.",
    },
    tagline: {
      ru: "–ü–µ—Ä–µ—Å–∫–æ—á–∏–ª –¥–æ—Å—Ç–∞–≤–∫—É –∏ —Å–æ—Ö—Ä–∞–Ω–∏–ª {{amount}} –Ω–∞ —Ä–µ–∞–ª—å–Ω—É—é —Ü–µ–ª—å.",
      en: "Skip delivery, unlock {{amount}} for real goals.",
      es: "Saltarte la entrega libera {{amount}} para la meta real.",
      fr: "Saute une livraison et lib√®re {{amount}} pour ton vrai but.",
    },
    habit: {
      emoji: "üçï",
      color: "#FFF8E3",
      categories: ["food", "habit"],
      basePriceUSD: 15,
      title: {
        ru: "–î–æ—Å—Ç–∞–≤–∫–∞ –≤–µ—á–µ—Ä–∫–æ–º",
        en: "Night delivery",
        es: "Delivery nocturno",
        fr: "Livraison nocturne",
      },
      description: {
        ru: "–ü–∏—Ü—Ü–∞, –ø–æ–∫–µ –∏–ª–∏ —Å—É—à–∏? –í—ã–±–∏—Ä–∞–µ—à—å –ø—Ä–æ–≥—Ä–µ—Å—Å.",
        en: "Pizza, poke or sushi? You choose progress.",
        es: "¬øPizza, poke o sushi? T√∫ eliges el progreso.",
        fr: "Pizza, poke ou sushi ? Tu choisis le progr√®s.",
      },
    },
  },
  online_impulse: {
    id: "online_impulse",
    emoji: "üì¶",
    title: {
      ru: "–û–Ω–ª–∞–π–Ω-—à–æ–ø–µ—Ä",
      en: "Online shopper",
      es: "Comprador online",
      fr: "Shoppeur en ligne",
    },
    description: {
      ru: "–õ—é–±–∏—Ç –∏–º–ø—É–ª—å—Å–∏–≤–Ω—ã–µ –æ–Ω–ª–∞–π–Ω-–ø–æ–∫—É–ø–∫–∏. –ö–ª–∞–¥—ë–º –≤ —Å–ø–∏—Å–æ–∫, –∞ –Ω–µ –≤ –∫–æ—Ä–∑–∏–Ω—É.",
      en: "Loves impulse online buys. Park them in a list instead of checkout.",
      es: "Le encantan las compras impulsivas online. Mejor gu√°rdalas en una lista.",
      fr: "Fan des achats impulsifs en ligne. On les range dans une liste plut√¥t que dans le panier.",
    },
    tagline: {
      ru: "–ö–∞–∂–¥—ã–π –Ω–µ—Å–æ—Å—Ç–æ—è–≤—à–∏–π—Å—è –∑–∞–∫–∞–∑ = {{amount}} –±–ª–∏–∂–µ –∫ —Ü–µ–ª–∏.",
      en: "Every skipped checkout moves {{amount}} closer to your goal.",
      es: "Cada carrito sin pagar acerca {{amount}} a tu meta.",
      fr: "Chaque panier abandonn√© rapproche de {{amount}} ta prochaine √©tape.",
    },
    habit: {
      emoji: "üì¶",
      color: "#E8F0FF",
      categories: ["wow", "things", "habit"],
      basePriceUSD: 25,
      title: {
        ru: "–û–Ω–ª–∞–π–Ω-–∏–º–ø—É–ª—å—Å",
        en: "Online impulse",
        es: "Impulso online",
        fr: "Impulsion en ligne",
      },
      description: {
        ru: "–ï—â—ë –æ–¥–Ω–∞ –ø–æ—Å—ã–ª–∫–∞, –∫–æ—Ç–æ—Ä–∞—è –º–æ–≥–ª–∞ —Å—Ç–∞—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å–æ–º.",
        en: "Another package that could have been progress.",
        es: "Otro paquete que podr√≠a haber sido progreso.",
        fr: "Un colis de plus qui aurait pu devenir du progr√®s.",
      },
    },
  },
  anime_fan: {
    id: "anime_fan",
    emoji: "üéå",
    title: {
      ru: "–õ—é–±–∏—Ç–µ–ª—å –∞–Ω–∏–º–µ",
      en: "Anime fan",
      es: "Fan del anime",
      fr: "Fan d'anime",
    },
    description: {
      ru: "–ú–µ—Ä—á, –º–∞–Ω–≥–∞ –∏ —Ñ–∏–≥—É—Ä–∫–∏. –§–∏–∫—Å–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ —Ç–æ, —á—Ç–æ —Ä–µ–∞–ª—å–Ω–æ –≤–∞–∂–Ω–æ.",
      en: "Merch, manga, figures. Log only what truly matters.",
      es: "Merch, manga, figuras. Registra solo lo que importa.",
      fr: "Merch, manga et figurines : on ne garde que l'essentiel.",
    },
    tagline: {
      ru: "–ü—Ä–æ–ø—É—Å—Ç–∏–ª –æ—á–µ—Ä–µ–¥–Ω–æ–π —Å–µ—Ç - {{amount}} –≤ –∫–æ–ø–∏–ª–∫—É –º–µ—á—Ç—ã.",
      en: "Skipped the next merch drop-{{amount}} to your dream.",
      es: "Saltarse el nuevo drop suma {{amount}} a tu sue√±o.",
      fr: "Skip le prochain drop = {{amount}} de plus pour ton r√™ve.",
    },
    habit: {
      emoji: "üéå",
      color: "#F2E8FF",
      categories: ["wow", "habit", "style"],
      basePriceUSD: 18,
      title: {
        ru: "–ê–Ω–∏–º–µ-–º–µ—Ä—á",
        en: "Anime merch",
        es: "Merch anime",
        fr: "Merch anime",
      },
      description: {
        ru: "–§–∏–≥—É—Ä–∫–∞, —Ç–æ–º–∏–∫ –∏–ª–∏ –±—Ä–µ–ª–æ–∫ - —Ä–µ—à–∞–π –æ—Å–æ–∑–Ω–∞–Ω–Ω–æ.",
        en: "Figure, volume, or keychain-choose mindfully.",
        es: "Figura, tomo o llavero: decide con consciencia.",
        fr: "Figurine, tome ou porte-cl√©s : d√©cide en conscience.",
      },
    },
  },
  sub_lover: {
    id: "sub_lover",
    emoji: "üßæ",
    title: {
      ru: "–õ—é–±–∏—Ç–µ–ª—å –ø–æ–¥–ø–∏—Å–æ–∫",
      en: "Subscription lover",
      es: "Fan de las suscripciones",
      fr: "Fan des abonnements",
    },
    description: {
      ru: "–°—Ç—Ä–∏–º–∏–Ω–≥, —Å–µ—Ä–≤–∏—Å—ã, –¥–æ–ø‚Äë—Ñ–∏—á–∏. –î–µ—Ä–∂–∏–º –ø–æ–¥–ø–∏—Å–∫–∏ –ø–æ–¥ –∫–æ–Ω—Ç—Ä–æ–ª–µ–º.",
      en: "Streaming, SaaS, extra features. Keep subs under control.",
      es: "Streaming, servicios, extras. Mant√©n a raya las suscripciones.",
      fr: "Streaming, services et options : on garde les abonnements sous contr√¥le.",
    },
    tagline: {
      ru: "–û—Ç–º–µ–Ω–∏–ª –ª–∏—à–Ω–µ–µ - {{amount}} –æ—Å—Ç–∞–ª–∞—Å—å –≤ —Ü–µ–ª—è—Ö.",
      en: "Cancel the extra sub-{{amount}} stays with your goals.",
      es: "Cancelar la suscripci√≥n extra deja {{amount}} en tus metas.",
      fr: "Annule un abonnement de trop et {{amount}} reste pour tes objectifs.",
    },
    habit: {
      emoji: "üßæ",
      color: "#E9FFF3",
      categories: ["habit", "daily"],
      basePriceUSD: 12,
      title: {
        ru: "–õ–∏—à–Ω—è—è –ø–æ–¥–ø–∏—Å–∫–∞",
        en: "Extra subscription",
        es: "Suscripci√≥n extra",
        fr: "Abonnement en trop",
      },
      description: {
        ru: "–ú–µ—Å—è—á–Ω—ã–µ –ø–ª–∞—Ç–µ–∂–∏, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ–∑–∞–º–µ—Ç–Ω–æ —Å—ä–µ–¥–∞—é—Ç –±—é–¥–∂–µ—Ç.",
        en: "Monthly payments quietly draining the budget.",
        es: "Pagos mensuales que se comen el presupuesto sin avisar.",
        fr: "Des pr√©l√®vements mensuels qui mangent le budget sans pr√©venir.",
      },
    },
  },
  fashion_fan: {
    id: "fashion_fan",
    emoji: "üëó",
    title: {
      ru: "–õ—é–±–∏—Ç–µ–ª—å —à–º–æ—Ç–æ–∫",
      en: "Fashion lover",
      es: "Fan de la moda",
      fr: "Passionn√©¬∑e de mode",
    },
    description: {
      ru: "–°–ª–µ–¥–∏—Ç –∑–∞ –¥—Ä–æ–ø–∞–º–∏ –∏ —Å–∫–∏–¥–∫–∞–º–∏. –£—á–∏–º—Å—è —Ç–æ—Ä–º–æ–∑–∏—Ç—å –∏–º–ø—É–ª—å—Å—ã.",
      en: "Tracks drops and sales. Time to slow the impulses.",
      es: "Sigue drops y rebajas. Toca frenar los impulsos.",
      fr: "Scrute les drops et promos. On apprend √† freiner les impulsions.",
    },
    tagline: {
      ru: "–ö–∞–∂–¥—ã–π –Ω–µ—Å–∫—É–ø–ª–µ–Ω–Ω—ã–π –¥—Ä–æ–ø = {{amount}} –∫ –±–æ–ª—å—à–æ–º—É –ø–ª–∞–Ω—É.",
      en: "Every unsnapped drop adds {{amount}} to the big plan.",
      es: "Cada drop que dejas pasar suma {{amount}} a tu plan grande.",
      fr: "Chaque drop laiss√© passer ajoute {{amount}} au grand plan.",
    },
    habit: {
      emoji: "üëú",
      color: "#FFF0F2",
      categories: ["style", "habit"],
      basePriceUSD: 35,
      title: {
        ru: "–ò–º–ø—É–ª—å—Å–Ω—ã–π —à–æ–ø–ø–∏–Ω–≥",
        en: "Impulse fashion pick",
        es: "Antojo de moda",
        fr: "Craquage mode",
      },
      description: {
        ru: "–°—É–º–∫–∞, —Ö—É–¥–∏ –∏–ª–∏ –∫—Ä–æ—Å—Å—ã - —Ñ–∏–∫—Å–∏—Ä—É–π, –∞ –Ω–µ —Ö–≤–∞—Ç–∞–π.",
        en: "Bag, hoodie or sneakers-log it, don't grab it.",
        es: "Bolso, hoodie o sneakers: reg√≠stralo antes de comprar.",
        fr: "Sac, hoodie ou sneakers : note-le avant de craquer.",
      },
    },
  },
};

const PERSONA_HABIT_TYPES = {
  mindful_coffee: "coffee",
  habit_smoking: "smoking",
  glam_beauty: "beauty",
  gamer_loot: "gaming",
  foodie_delivery: "delivery",
  online_impulse: "shopping",
  anime_fan: "anime",
  sub_lover: "subscriptions",
  fashion_fan: "fashion",
};

const DEFAULT_PERSONA_ID = "mindful_coffee";

const GENDER_OPTIONS = [
  { id: "female", label: { ru: "–ñ–µ–Ω—â–∏–Ω–∞", en: "Female", es: "Mujer", fr: "Femme" }, emoji: "üíÅ‚Äç‚ôÄÔ∏è" },
  { id: "male", label: { ru: "–ú—É–∂—á–∏–Ω–∞", en: "Male", es: "Hombre", fr: "Homme" }, emoji: "üßë‚Äçü¶±" },
  {
    id: "none",
    label: {
      ru: "–ù–µ —É–∫–∞–∑—ã–≤–∞—Ç—å",
      en: "Prefer not to say",
      es: "Prefiero no decirlo",
      fr: "Je pr√©f√®re ne pas le dire",
    },
    emoji: "ü§´",
  },
];

const GOAL_PRESETS = [
  { id: "travel", ru: "–ü—É—Ç–µ—à–µ—Å—Ç–≤–∏—è", en: "Travel", es: "Viajes", fr: "Voyages", emoji: "‚úàÔ∏è", targetUSD: 1500 },
  { id: "tech", ru: "–¢–µ—Ö–Ω–∏–∫–∞", en: "Tech upgrade", es: "Tecnolog√≠a", fr: "Upgrade tech", emoji: "üíª", targetUSD: 900 },
  {
    id: "daily",
    ru: "–ï–∂–µ–¥–Ω–µ–≤–Ω—ã–µ —Ü–µ–ª–∏",
    en: "Daily treats",
    es: "Caprichos diarios",
    fr: "Plaisirs quotidiens",
    emoji: "üç©",
    targetUSD: 250,
  },
  {
    id: "save",
    ru: "–ü—Ä–æ—Å—Ç–æ –∫–æ–ø–∏—Ç—å",
    en: "Rainy-day fund",
    es: "Fondo de respaldo",
    fr: "Fonds de secours",
    emoji: "üí∞",
    targetUSD: 600,
  },
];

const PRIMARY_GOAL_KIND = "primary_goal";
const PRIMARY_GOAL_WISH_ID_LEGACY = "wish_primary_goal";
const getPrimaryGoalWishId = (goalId = "default") => `wish_primary_goal_${goalId}`;

const getGoalPreset = (goalId) => GOAL_PRESETS.find((goal) => goal.id === goalId);
const getGoalDefaultTargetUSD = (goalId) => {
  const preset = getGoalPreset(goalId);
  return preset?.targetUSD || 500;
};

const insertWishAfterPrimary = (list = [], newWish) => {
  if (!newWish) return list;
  const lastPrimaryIndex = list.reduce(
    (lastIndex, wish, index) => (wish?.kind === PRIMARY_GOAL_KIND ? index : lastIndex),
    -1
  );
  if (lastPrimaryIndex === -1) {
    return [newWish, ...list];
  }
  const before = list.slice(0, lastPrimaryIndex + 1);
  const after = list.slice(lastPrimaryIndex + 1);
  return [...before, newWish, ...after];
};

const removePrimaryGoalFromProfile = (profileState = {}, goalId) => {
  if (!goalId) return profileState;
  const currentGoals = Array.isArray(profileState.primaryGoals) ? profileState.primaryGoals : [];
  const filtered = currentGoals.filter((goal) => goal.id !== goalId);
  const nextGoalId = filtered[0]?.id || profileState.goal || DEFAULT_PROFILE.goal;
  const nextGoalTarget = filtered[0]
    ? (Number.isFinite(filtered[0].targetUSD) && filtered[0].targetUSD > 0
        ? filtered[0].targetUSD
        : getGoalDefaultTargetUSD(filtered[0].id))
    : getGoalDefaultTargetUSD(nextGoalId);
  return {
    ...profileState,
    primaryGoals: filtered,
    goal: nextGoalId,
    goalTargetUSD: nextGoalTarget,
    goalCelebrated: filtered.length ? profileState.goalCelebrated : false,
  };
};

const updatePrimaryGoalTargetInProfile = (profileState = {}, goalId, targetUSD, extra = {}) => {
  if (!goalId) return profileState;
  const currentGoals = Array.isArray(profileState.primaryGoals) ? profileState.primaryGoals : [];
  const updated = currentGoals.map((goal) =>
    goal.id === goalId ? { ...goal, targetUSD, ...extra } : goal
  );
  const activeGoalId = profileState.goal || updated[0]?.id || goalId;
  const activeEntry = updated.find((goal) => goal.id === activeGoalId) || updated[0] || null;
  const nextTarget = activeEntry
    ? (Number.isFinite(activeEntry.targetUSD) && activeEntry.targetUSD > 0
        ? activeEntry.targetUSD
        : getGoalDefaultTargetUSD(activeEntry.id))
    : getGoalDefaultTargetUSD(activeGoalId);
  return {
    ...profileState,
    primaryGoals: updated,
    goal: activeEntry?.id || activeGoalId,
    goalTargetUSD: nextTarget,
  };
};

const PROFILE_BIO_FALLBACKS = {
  ru: "–õ—é–±–ª—é –∫—Ä–∞—Å–∏–≤—ã–µ –≤–µ—â–∏, –Ω–æ –±–æ–ª—å—à–µ –ª—é–±–ª—é —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã–π –ø–ª–∞–Ω",
  en: "I love nice things, but I love my money plan even more",
  es: "Me encantan las cosas bonitas, pero m√°s mi plan financiero",
  fr: "J‚Äôaime les belles choses, mais j‚Äôadore encore plus mon plan financier",
};

const DEFAULT_PROFILE = {
  name: "Nina Cleanova",
  firstName: "Nina",
  lastName: "Cleanova",
  subtitle: "",
  motto: "",
  bio: PROFILE_BIO_FALLBACKS.en,
  avatar: "",
  currency: "USD",
  goal: "save",
  goalTargetUSD: getGoalDefaultTargetUSD("save"),
  primaryGoals: [{ id: "save", targetUSD: getGoalDefaultTargetUSD("save") }],
  goalCelebrated: false,
  goalRenewalPending: false,
  persona: "mindful_coffee",
  gender: "none",
  customSpend: null,
  spendingProfile: {
    baselineMonthlyWasteUSD: 0,
    baselineStartAt: null,
  },
  joinedAt: null,
};

const DEFAULT_PROFILE_PLACEHOLDER = {
  ...DEFAULT_PROFILE,
  name: "",
  firstName: "",
  lastName: "",
  subtitle: "",
  motto: "",
  bio: "",
};

const resolvePotentialPushStepUSD = (currencyCode = DEFAULT_PROFILE.currency) => {
  const normalizedCode =
    typeof currencyCode === "string" && currencyCode.trim().length > 0
      ? currencyCode.trim().toUpperCase()
      : DEFAULT_PROFILE.currency;
  const convertCode = CURRENCIES.includes(normalizedCode) ? normalizedCode : DEFAULT_PROFILE.currency;
  const localStep =
    POTENTIAL_PUSH_STEP_LOCAL_MAP[normalizedCode] ??
    POTENTIAL_PUSH_STEP_LOCAL_MAP[convertCode] ??
    POTENTIAL_PUSH_STEP_LOCAL_FALLBACK;
  const resolvedUSD = convertFromCurrency(localStep, convertCode);
  if (Number.isFinite(resolvedUSD) && resolvedUSD > 0) {
    return resolvedUSD;
  }
  return POTENTIAL_PUSH_STEP_USD;
};

const INITIAL_REGISTRATION = {
  firstName: "",
  lastName: "",
  motto: "",
  avatar: "",
  currency: "USD",
  gender: "none",
  persona: "mindful_coffee",
  customSpendTitle: "",
  customSpendAmount: "",
  customSpendFrequency: "",
   customSpendCategory: DEFAULT_IMPULSE_CATEGORY,
  baselineMonthlyWaste: "",
  baselineCapturedAt: null,
  goalSelections: [],
  goalTargetMap: {},
  customGoals: [],
  goalTargetConfirmed: [],
};

const DEFAULT_TEMPTATIONS = [
  {
    id: "coffee_to_go",
    emoji: "‚òïÔ∏è",
    image:
      "https://images.unsplash.com/photo-1517705008128-361805f42e86?auto=format&fit=crop&w=600&q=80",
    color: "#FFF3E0",
    categories: ["coffee", "food"],
    basePriceUSD: 5,
    priceUSD: 5,
    title: {
      ru: "–ö–æ—Ñ–µ –Ω–∞–≤—ã–Ω–æ—Å",
      en: "Coffee to-go",
      es: "Caf√© para llevar",
      fr: "Caf√© √† emporter",
    },
    description: {
      ru: "–°–∞–º–∞—è –º–µ–ª–∫–∞—è —Ç—Ä–∞—Ç–∞, –∫–æ—Ç–æ—Ä–∞—è, –µ—Å–ª–∏ –µ—ë –Ω–µ –∑–∞–º–µ—Ç–∏—Ç—å, —Å—ä–µ–¥–∞–µ—Ç –±—é–¥–∂–µ—Ç –∫–∞–∂–¥—ã–π –¥–µ–Ω—å.",
      en: "Tiny daily swipe that quietly eats the budget if you don‚Äôt watch it.",
      es: "Ese peque√±o pago diario que devora el presupuesto si no lo vigilas.",
      fr: "Ce petit achat quotidien finit par grignoter ton budget si tu ne le surveilles pas.",
    },
  },
  {
    id: "croissant_break",
    emoji: "ü•ê",
    image:
      "https://images.unsplash.com/photo-1464306076886-da185f6a9d12?auto=format&fit=crop&w=600&q=80",
    color: "#FFFBEA",
    categories: ["food", "coffee"],
    basePriceUSD: 8,
    priceUSD: 8,
    title: {
      ru: "–£—Ç—Ä–µ–Ω–Ω–∏–π –∫—Ä—É–∞—Å—Å–∞–Ω",
      en: "Morning croissant",
      es: "Croissant ma√±anero",
      fr: "Croissant du matin",
    },
    description: {
      ru: "–ú–∞–ª–µ–Ω—å–∫–æ–µ —É–¥–æ–≤–æ–ª—å—Å—Ç–≤–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –∑–∞–ø—É—Å–∫–∞–µ—Ç –±–æ–ª—å—à–æ–π –ø—Ä–æ–≥—Ä–µ—Å—Å, –µ—Å–ª–∏ –µ–≥–æ –æ—Ç–ª–æ–∂–∏—Ç—å.",
      en: "A tiny treat that becomes a big level boost once you skip it.",
      es: "Un peque√±o antojo que impulsa el progreso cuando lo pospones.",
      fr: "Ce petit plaisir devient un vrai boost de progression quand tu le remets √† plus tard.",
    },
  },
  {
    id: "fancy_latte",
    emoji: "ü•§",
    image:
      "https://images.unsplash.com/photo-1509043759401-136742328bb3?auto=format&fit=crop&w=600&q=80",
    color: "#E8F5E9",
    categories: ["coffee", "lifestyle"],
    basePriceUSD: 12,
    priceUSD: 12,
    title: {
      ru: "–ú–∞—Ç—á–∞-–ª–∞—Ç—Ç–µ",
      en: "Matcha latte",
      es: "Matcha latte",
      fr: "Matcha latte",
    },
    description: {
      ru: "–°—Ç–µ–∫–ª—è–Ω–Ω—ã–π —Å—Ç–∞–∫–∞–Ω + —Ç–æ–ø–∏–Ω–≥ = –ø–æ—á—Ç–∏ –∞–±–æ–Ω–µ–º–µ–Ω—Ç –≤ —Å–ø–æ—Ä—Ç–∑–∞–ª –∑–∞ –º–µ—Å—è—Ü.",
      en: "Glass cup + topping = nearly a gym pass per month if you bank it.",
      es: "Vaso chic + topping = casi una mensualidad de gimnasio si lo ahorras.",
      fr: "Verre styl√© + topping = presque un abonnement de gym par mois si tu l'√©conomises.",
    },
  },
  {
    id: "phone",
    emoji: "üì±",
    image:
      "https://images.unsplash.com/photo-1501426026826-31c667bdf23d?auto=format&fit=crop&w=600&q=80",
    color: "#F6DFFF",
    categories: ["tech", "flagship", "phone"],
    basePriceUSD: 1199,
    priceUSD: 1199,
    title: {
      ru: "–ù–æ–≤—ã–π —Å–º–∞—Ä—Ç—Ñ–æ–Ω",
      en: "New smartphone",
      es: "Smartphone nuevo",
      fr: "Nouveau smartphone",
    },
    description: {
      ru: "–°–≤–µ–∂–∏–π –≥–∞–¥–∂–µ—Ç —Å –¥–≤–æ–π–Ω–æ–π –∫–∞–º–µ—Ä–æ–π, –∫–æ—Ç–æ—Ä—ã–π —Ç–∞–∫ –ª–µ–≥–∫–æ –æ–ø—Ä–∞–≤–¥–∞—Ç—å. –ü—Ä–æ–≤–µ—Ä–∏–º, —Å—Ç–æ–∏—Ç –ª–∏ –æ–Ω —ç–º–æ—Ü–∏–π?",
      en: "Shiny dual-camera flagship tempting every scroll. Is the hype worth your savings?",
      es: "Nuevo flagship con doble c√°mara que tienta en cada scroll. ¬øVale tus ahorros?",
      fr: "Ce flagship brillant √† double cam√©ra tente √† chaque scroll. L'engouement m√©rite-t-il tes √©conomies ?",
    },
  },
  {
    id: "sneakers",
    emoji: "üëü",
    image:
      "https://images.unsplash.com/photo-1528701800489-20be3cbe2c05?auto=format&fit=crop&w=600&q=80",
    color: "#E3F6E8",
    categories: ["style", "sport"],
    basePriceUSD: 260,
    priceUSD: 260,
    title: {
      ru: "–õ–∏–º–∏—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫—Ä–æ—Å—Å—ã",
      en: "Limited sneakers",
      es: "Tenis limitados",
      fr: "Sneakers en √©dition limit√©e",
    },
    description: {
      ru: "–†–µ–¥–∫–∏–π –¥—Ä–æ–ø —Å –æ—á–µ—Ä–µ–¥—å—é –∏–∑ –∂–µ–ª–∞—é—â–∏—Ö. –ò–Ω–æ–≥–¥–∞ –≤–º–µ—Å—Ç–æ –æ—á–µ—Ä–µ–¥–∏ –ª—É—á—à–µ –ø–æ–ø–æ–ª–Ω–∏—Ç—å –∫–æ–ø–∏–ª–∫—É.",
      en: "Rare drop everyone chases. Maybe the real flex is topping up your stash.",
      es: "Drop limitado que todos persiguen. El verdadero lujo puede ser engordar la alcanc√≠a.",
      fr: "Un drop rare que tout le monde pourchasse. Et si le vrai flex √©tait de gonfler ta cagnotte ?",
    },
  },
  {
    id: "watch",
    emoji: "‚åöÔ∏è",
    image:
      "https://images.unsplash.com/photo-1523475472560-d2df97ec485c?auto=format&fit=crop&w=600&q=80",
    color: "#FFE5F1",
    categories: ["tech", "wearable"],
    basePriceUSD: 799,
    priceUSD: 799,
    title: {
      ru: "–ü—Ä–µ–º–∏–∞–ª—å–Ω—ã–µ —á–∞—Å—ã",
      en: "Premium watch",
      es: "Reloj premium",
      fr: "Montre premium",
    },
    description: {
      ru: "–û—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç –ø—É–ª—å—Å –∏ —Ä–∞—Å—Ö–æ–¥—ã, –µ—Å–ª–∏ –≤—Ä–∞–≥ –Ω–µ –Ω–æ—Å–∏—Ç –∏—Ö –∫–∞–∂–¥—ã–π –¥–µ–Ω—å.",
      en: "Tracks your pulse and spending if you resist wearing it daily.",
      es: "Controla tu pulso (y tu gasto) si lo dejas en la vitrina un d√≠a m√°s.",
      fr: "Suit ton pouls et tes d√©penses‚Ä¶ si tu r√©sistes √† la porter tous les jours.",
    },
  },
  {
    id: "console",
    emoji: "üéÆ",
    image:
      "https://images.unsplash.com/photo-1486401899868-0e435ed85128?auto=format&fit=crop&w=600&q=80",
    color: "#D9F7FF",
    categories: ["wow", "home"],
    audience: ["male"],
    basePriceUSD: 549,
    priceUSD: 549,
    title: {
      ru: "–ò–≥—Ä–æ–≤–∞—è –ø—Ä–∏—Å—Ç–∞–≤–∫–∞",
      en: "Game console",
      es: "Consola de juegos",
      fr: "Console de jeu",
    },
    description: {
      ru: "–õ—É—á—à–∏–π —Å–ø–æ—Å–æ–± –≤–µ—á–µ—Ä–∞–º–∏ —Å–ø–∞—Å–∞—Ç—å –º–∏—Ä –∏ –±—é–¥–∂–µ—Ç. –î–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞ —Ç—ã –Ω–µ –Ω–∞–∂–∞–ª ¬´–∫—É–ø–∏—Ç—å¬ª.",
      en: "Saves worlds at night and your budget if you pause before checkout.",
      es: "Salva mundos por la noche y tu presupuesto si te detienes antes de pagar.",
      fr: "Sauve des mondes le soir et ton budget si tu fais une pause avant de payer.",
    },
  },
  {
    id: "pizza",
    emoji: "üçï",
    image:
      "https://images.unsplash.com/photo-1542281286-9e0a16bb7366?auto=format&fit=crop&w=600&q=80",
    color: "#FFF4D5",
    categories: ["food", "wow"],
    basePriceUSD: 25,
    priceUSD: 25,
    title: {
      ru: "–°–µ—Ç –ø–∏—Ü—Ü –∏ —Ä–æ–ª–ª–æ–≤",
      en: "Pizza & rolls night",
      es: "Noche de pizza y rolls",
      fr: "Nuit pizza & rolls",
    },
    description: {
      ru: "–ü—è—Ç–Ω–∏—á–Ω—ã–π —Ä–∏—Ç—É–∞–ª, –∫–æ—Ç–æ—Ä—ã–π –ª–µ–≥–∫–æ –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤ —Ç—ã—Å—è—á—É —Ä—É–±–ª–µ–π, —É–ª–µ—Ç–µ–≤—à–∏—Ö –≤ –Ω–∏–∫—É–¥–∞.",
      en: "Friday ritual that quickly becomes a $40 habit. Maybe cook tonight?",
      es: "Ritual de viernes que se vuelve un h√°bito de $40. ¬øY si cocinas hoy?",
      fr: "Rituel du vendredi qui finit vite en habitude √† 40 $. Et si tu cuisinais ce soir ?",
    },
  },
  {
    id: "late_night_takeout",
    emoji: "üç±",
    image:
      "https://images.unsplash.com/photo-1466978913421-dad2ebd01d17?auto=format&fit=crop&w=900&q=80",
    color: "#FFEFE9",
    categories: ["food", "wow"],
    basePriceUSD: 35,
    priceUSD: 35,
    title: {
      ru: "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Å–µ—Ç —Ä–æ–ª–ª–æ–≤",
      en: "Extra sushi add-on",
      es: "Extra de sushi nocturno",
      fr: "Suppl√©ment sushi de nuit",
    },
    description: {
      ru: "–ö–∞–∂–µ—Ç—Å—è –º–µ–ª–æ—á—å—é –≤ –¥–æ—Å—Ç–∞–≤–∫–µ, –Ω–æ –∏–º–µ–Ω–Ω–æ –æ–Ω –¥–µ–ª–∞–µ—Ç —á–µ–∫ –∑–∞–º–µ—Ç–Ω–æ –≤—ã—à–µ.",
      en: "Tiny add-on in the cart that silently pushes the total over the top.",
      es: "Ese extra peque√±o en la app que dispara la cuenta final.",
      fr: "Ce petit extra dans le panier qui fait grimper la note sans pr√©venir.",
    },
  },
  {
    id: "movie_premiere_combo",
    emoji: "üé¨",
    image:
      "https://images.unsplash.com/photo-1489599849927-2ee91cede3ba?auto=format&fit=crop&w=900&q=80",
    color: "#F4F2FF",
    categories: ["fun", "food"],
    basePriceUSD: 45,
    priceUSD: 45,
    title: {
      ru: "–ö–∏–Ω–æ + –∑–∞–∫—É—Å–∫–∏",
      en: "Movie night combo",
      es: "Combo noche de cine",
      fr: "Combo soir√©e cin√©ma",
    },
    description: {
      ru: "–ë–∏–ª–µ—Ç—ã, –ø–æ–ø–∫–æ—Ä–Ω –∏ –ª–∏–º–æ–Ω–∞–¥, –∫–æ—Ç–æ—Ä—ã–µ –ª–µ–≥–∫–æ –ø—Ä–µ–≤—Ä–∞—Ç–∏—Ç—å –≤ –≤–∑–Ω–æ—Å –≤ –∫–æ–ø–∏–ª–∫—É.",
      en: "Tickets, popcorn and soda that could become a little boost to savings.",
      es: "Entradas, palomitas y refresco que podr√≠an ir directo al ahorro.",
      fr: "Tickets, pop-corn et soda qui pourraient devenir un coup de pouce pour l'√©pargne.",
    },
  },
  {
    id: "beauty_box",
    emoji: "üíÑ",
    image:
      "https://images.unsplash.com/photo-1524504388940-b1c1722653e1?auto=format&fit=crop&w=900&q=80",
    color: "#FFE9F2",
    categories: ["beauty", "lifestyle"],
    audience: ["female"],
    basePriceUSD: 65,
    priceUSD: 65,
    title: {
      ru: "Beauty-–±–æ–∫—Å –º–µ—Å—è—Ü–∞",
      en: "Monthly beauty box",
      es: "Caja beauty mensual",
      fr: "Box beaut√© du mois",
    },
    description: {
      ru: "–ö–æ—Ä–æ–±–æ—á–∫–∞ —Å—é—Ä–ø—Ä–∏–∑–æ–≤, –∫–æ—Ç–æ—Ä–∞—è –∫–∞–∂–¥—ã–π –º–µ—Å—è—Ü –ø–µ—Ä–µ—Ç—è–≥–∏–≤–∞–µ—Ç –±—é–¥–∂–µ—Ç.",
      en: "A curated surprise box that steals a chunk of the monthly plan.",
      es: "Caja sorpresa curada que se lleva parte del plan mensual.",
      fr: "Une box surprise bien pens√©e qui mord chaque mois dans ton budget.",
    },
  },
  {
    id: "grooming_upgrade_set",
    emoji: "ü™í",
    image:
      "https://images.unsplash.com/photo-1503342217505-b0a15ec3261c?auto=format&fit=crop&w=900&q=80",
    color: "#E9F8FF",
    categories: ["style", "lifestyle"],
    audience: ["male"],
    basePriceUSD: 70,
    priceUSD: 70,
    title: {
      ru: "–ü—Ä–µ–º–∏—É–º-–Ω–∞–±–æ—Ä –¥–ª—è —É—Ö–æ–¥–∞",
      en: "Premium grooming bundle",
      es: "Set premium de cuidado",
      fr: "Coffret grooming premium",
    },
    description: {
      ru: "–ë—Ä–∏—Ç–≤–∞, –º–∞—Å–ª–∞ –∏ —Ç—Ä–∏–º–º–µ—Ä, –∫–æ—Ç–æ—Ä—ã–µ –ª–µ–≥–∫–æ –∑–∞–º–µ–Ω–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å–æ–º –ø–æ —Ü–µ–ª—è–º.",
      en: "Razor, oils and trimmer that could become goal progress instead.",
      es: "Rasuradora, aceites y trimmer que podr√≠an ser avance hacia tu meta.",
      fr: "Rasoir, huiles et tondeuse qui pourraient devenir des points de progr√®s.",
    },
  },
  {
    id: "smart_band_upgrade",
    emoji: "üìø",
    image:
      "https://images.unsplash.com/photo-1517148815974-413097f4a0c0?auto=format&fit=crop&w=900&q=80",
    color: "#E9F5FF",
    categories: ["tech", "wearable"],
    basePriceUSD: 90,
    priceUSD: 90,
    title: {
      ru: "–ù–æ–≤—ã–π —Ñ–∏—Ç–Ω–µ—Å-–±—Ä–∞—Å–ª–µ—Ç",
      en: "Fresh fitness band",
      es: "Nueva smartband",
      fr: "Nouveau bracelet fitness",
    },
    description: {
      ru: "–≠–∫—Ä–∞–Ω –ø–æ–±–æ–ª—å—à–µ, –¥–∞—Ç—á–∏–∫–æ–≤ –ø–æ–±–æ–ª—å—à–µ –∏ –µ—â–µ –æ–¥–∏–Ω –ø–æ–≤–æ–¥ –æ—Ç–ª–æ–∂–∏—Ç—å upgrade.",
      en: "Bigger screen, more sensors and one more reason to pause the upgrade.",
      es: "Pantalla m√°s grande y sensores extra: otro motivo para frenar el upgrade.",
      fr: "√âcran plus grand, capteurs en plus et une raison de plus d'attendre avant l'upgrade.",
    },
  },
  {
    id: "weekend_brunch",
    emoji: "ü•û",
    image:
      "https://images.unsplash.com/photo-1504754524776-8f4f37790ca0?auto=format&fit=crop&w=900&q=80",
    color: "#FFF7EA",
    categories: ["food", "lifestyle"],
    basePriceUSD: 120,
    priceUSD: 120,
    title: {
      ru: "–ë—Ä–∞–Ω—á –≤—ã—Ö–æ–¥–Ω–æ–≥–æ –¥–Ω—è",
      en: "Weekend brunch ritual",
      es: "Ritual de brunch",
      fr: "Rituel brunch du week-end",
    },
    description: {
      ru: "–°–ª–æ–∏ –ø–∞–Ω–∫–µ–π–∫–æ–≤ –∏ –º–∏–º–æ–∑—ã –ª–µ–≥–∫–æ –ø—Ä–µ–≤—Ä–∞—â–∞—é—Ç—Å—è –≤ –ø—Ä–æ–≥—Ä–µ—Å—Å –ø–æ —Ü–µ–ª—è–º.",
      en: "Stacks of pancakes and mimosas that could have been goal progress.",
      es: "Capas de pancakes y mimosas que podr√≠an ser progreso de metas.",
      fr: "Des piles de pancakes et des mimosas qui pourraient devenir du progr√®s vers tes objectifs.",
    },
  },
  {
    id: "studio_pass",
    emoji: "üßò",
    image:
      "https://images.unsplash.com/photo-1518611012118-696072aa579a?auto=format&fit=crop&w=900&q=80",
    color: "#E9FFF2",
    categories: ["health", "lifestyle"],
    basePriceUSD: 180,
    priceUSD: 180,
    title: {
      ru: "–ü–∞–∫–µ—Ç –∏–∑ 10 —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫",
      en: "10-class studio pass",
      es: "Pase de 10 clases",
      fr: "Pass studio 10 s√©ances",
    },
    description: {
      ru: "–ö—Ä–∞—Å–∏–≤–∞—è –ø–æ–¥–ø–∏—Å–∫–∞, –∫–æ—Ç–æ—Ä–∞—è –æ–∫—É–ø–∏—Ç—Å—è, –µ—Å–ª–∏ –∫–æ–ø–∏–ª–∫–∞ –æ—Å—Ç–∞–Ω–µ—Ç—Å—è –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º.",
      en: "A shiny class pack that pays off only if the jar stays priority.",
      es: "Un paquete brillante que solo rinde si el ahorro sigue siendo prioridad.",
      fr: "Un pack de cours canon qui ne vaut le coup que si la cagnotte reste prioritaire.",
    },
  },
  {
    id: "streetwear_capsule",
    emoji: "üß•",
    image:
      "https://images.unsplash.com/photo-1475180098004-ca77a66827be?auto=format&fit=crop&w=900&q=80",
    color: "#EAF2FF",
    categories: ["style", "wow"],
    basePriceUSD: 220,
    priceUSD: 220,
    title: {
      ru: "–°—Ç—Ä–∏—Ç–≤–∏—Ä-–∫–∞–ø—Å—É–ª–∞",
      en: "Streetwear capsule",
      es: "C√°psula streetwear",
      fr: "Capsule streetwear",
    },
    description: {
      ru: "–•—É–¥–∏, –∫–µ–ø–∫–∞ –∏ –∞–∫—Å–µ—Å—Å—É–∞—Ä—ã, –∫–æ—Ç–æ—Ä—ã–µ –ª–µ–≥–∫–æ –ø—Ä–µ–≤—Ä–∞—Ç–∏—Ç—å –≤ –≤–∫–ª–∞–¥ –≤ –±–æ–ª—å—à—É—é –º–µ—á—Ç—É.",
      en: "Hoodie, cap and trinkets that could accelerate the bigger dream.",
      es: "Hoodie, gorra y accesorios que podr√≠an empujar tu gran sue√±o.",
      fr: "Hoodie, casquette et accessoires qui pourraient plut√¥t acc√©l√©rer ton grand r√™ve.",
    },
  },
  {
    id: "vacation",
    emoji: "üèùÔ∏è",
    image:
      "https://images.unsplash.com/photo-1496417263034-38ec4f0b665a?auto=format&fit=crop&w=600&q=80",
    color: "#E0F7FA",
    categories: ["travel", "dream"],
    basePriceUSD: 1800,
    priceUSD: 1800,
    title: {
      ru: "–≠–∫—Å–ø—Ä–µ—Å—Å-–ø—É—Ç–µ—à–µ—Å—Ç–≤–∏–µ",
      en: "Flash vacation",
      es: "Escapada expr√©s",
      fr: "Escapade √©clair",
    },
    description: {
      ru: "–õ–æ–≤–∏–º –±–∏–ª–µ—Ç—ã –Ω–∞ –º–æ—Ä–µ –¥–æ –∑–∞—Ä–ø–ª–∞—Ç—ã. –ò–ª–∏ –∫–æ–ø–∏–º –∑–∞—Ä–∞–Ω–µ–µ –∏ –ª–µ—Ç–∏–º –±–µ–∑ —Å—Ç—Ä–µ—Å—Å–∞.",
      en: "Spontaneous seaside flights before payday or a mindful trip later.",
      es: "Vuelos a la playa antes de cobrar o un viaje con calma si lo planificas.",
      fr: "Vols improvis√©s avant la paie ou voyage paisible si tu l'anticipes.",
    },
  },
  {
    id: "coffee",
    emoji: "‚òïÔ∏è",
    image:
      "https://images.unsplash.com/photo-1481391032119-d89fee407e44?auto=format&fit=crop&w=600&q=80",
    color: "#FAF0E6",
    categories: ["home", "coffee"],
    basePriceUSD: 320,
    priceUSD: 320,
    title: {
      ru: "–î–æ–º–∞—à–Ω—è—è –∫–æ—Ñ–µ–º–∞—à–∏–Ω–∞",
      en: "Home coffee setup",
      es: "Cafetera en casa",
      fr: "Machine √† caf√© maison",
    },
    description: {
      ru: "–ë–∞—Ä–∏—Å—Ç–∞ –Ω–∞ –∫—É—Ö–Ω–µ –∏ –º–∏–Ω—É—Å –¥–µ—Å—è—Ç–æ–∫ –ø–æ—Ö–æ–¥–æ–≤ –≤ –∫–æ—Ñ–µ–π–Ω—é –∫–∞–∂–¥—É—é –Ω–µ–¥–µ–ª—é.",
      en: "Barista on the countertop and fewer pricey coffee runs.",
      es: "Un barista en tu cocina y menos visitas costosas a la cafeter√≠a.",
      fr: "Un barista sur le plan de travail et moins d'allers-retours co√ªteux au caf√©.",
    },
  },
  {
    id: "bag",
    emoji: "üëú",
    image:
      "https://images.unsplash.com/photo-1507679799987-c73779587ccf?auto=format&fit=crop&w=600&q=80",
    color: "#F8F1FF",
    categories: ["style", "gift"],
    audience: ["female"],
    basePriceUSD: 950,
    priceUSD: 950,
    title: {
      ru: "–î–∏–∑–∞–π–Ω–µ—Ä—Å–∫–∞—è —Å—É–º–∫–∞",
      en: "Designer bag",
      es: "Bolso de dise√±ador",
      fr: "Sac de cr√©ateur",
    },
    description: {
      ru: "–í–µ—â—å –º–µ—á—Ç—ã, –∫–æ—Ç–æ—Ä–∞—è –ª–∏–±–æ –≤–¥–æ—Ö–Ω–æ–≤–ª—è–µ—Ç, –ª–∏–±–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫ —Å–ø–∏—Å–∫—É —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã—Ö —Ü–µ–ª–µ–π.",
      en: "Statement piece that either inspires or reminds you of bigger goals.",
      es: "Pieza so√±ada que inspira o te recuerda metas m√°s grandes.",
      fr: "Pi√®ce signature qui inspire ou te rappelle des objectifs plus grands.",
    },
  },
  {
    id: "city_escape",
    emoji: "üåÜ",
    image:
      "https://images.unsplash.com/photo-1505765050516-f72dcac9c60e?auto=format&fit=crop&w=600&q=80",
    color: "#E3E5FF",
    categories: ["travel", "dream"],
    basePriceUSD: 1200,
    priceUSD: 1200,
    title: {
      ru: "–£–∏–∫–µ–Ω–¥ –≤ –µ–≤—Ä–æ–ø–µ–π—Å–∫–æ–º –≥–æ—Ä–æ–¥–µ",
      en: "Weekend city escape",
      es: "Escapada urbana",
      fr: "Escapade urbaine",
    },
    description: {
      ru: "–î–≤–∞ –¥–Ω—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã –∏ –∫–æ—Ñ–µ –∏–ª–∏ –º–µ—Å—è—á–Ω—ã–π –∑–∞–ø–∞—Å —Å–±–µ—Ä–µ–∂–µ–Ω–∏–π.",
      en: "Two days of architecture and espresso or a month of savings momentum.",
      es: "Dos d√≠as de arquitectura y espresso o un mes de impulso de ahorro.",
      fr: "Deux jours d'architecture et d'espresso ou un mois d'√©lan d'√©pargne.",
    },
  },
  {
    id: "road_trip",
    emoji: "üöê",
    image:
      "https://images.unsplash.com/photo-1503736334956-4c8f8e92946d?auto=format&fit=crop&w=900&q=80",
    color: "#E0FFF6",
    categories: ["travel", "wow"],
    basePriceUSD: 3200,
    priceUSD: 3200,
    title: {
      ru: "–ü—É—Ç–µ—à–µ—Å—Ç–≤–∏–µ –Ω–∞ –º–∞—à–∏–Ω–µ –º–µ—á—Ç—ã",
      en: "Dream road trip",
      es: "Road trip so√±ado",
      fr: "Road trip de r√™ve",
    },
    description: {
      ru: "–ë–µ–Ω–∑–∏–Ω, –¥–æ–º –Ω–∞ –∫–æ–ª—ë—Å–∞—Ö –∏ —Å–≤–æ–±–æ–¥–∞. –í—Å—ë —ç—Ç–æ –º–æ–∂–µ—Ç –ø–æ–¥–æ–∂–¥–∞—Ç—å –¥–æ –ø–æ–ª–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞.",
      en: "Fuel, van life and freedom are all waiting once the progress bar hits max.",
      es: "Gasolina, van y libertad te esperan cuando la barra de progreso llegue al tope.",
      fr: "Carburant, vanlife et libert√© attendent une fois la barre de progression au max.",
    },
  },
  {
    id: "dream_car",
    emoji: "üöó",
    image:
      "https://images.unsplash.com/photo-1503736334956-4c8f8e92946d?auto=format&fit=crop&w=1200&q=80",
    color: "#FFE0E3",
    categories: ["dream", "travel"],
    basePriceUSD: 28000,
    priceUSD: 28000,
    title: {
      ru: "–ê–≤—Ç–æ–º–æ–±–∏–ª—å –º–µ—á—Ç—ã",
      en: "Dream car",
      es: "Auto de ensue√±o",
      fr: "Voiture de r√™ve",
    },
    description: {
      ru: "–ö–∞–∂–¥—ã–π ¬´—Å—ç–∫–æ–Ω–æ–º–∏—Ç—å¬ª –ø–µ—Ä–µ–≤–æ–¥–∏—Ç —Ç–æ–ø–ª–∏–≤–æ –∏–∑ —á–∞—Ç–∞ —Ö–æ—Ç–µ–ª–æ–∫ –≤ –≥–∞—Ä–∞–∂ –±—É–¥—É—â–µ–≥–æ.",
      en: "Every ‚Äúsave it‚Äù reroutes fuel from impulse chats into the future garage.",
      es: "Cada ‚Äúah√≥rralo‚Äù desv√≠a combustible de los impulsos al garaje futuro.",
      fr: "Chaque ¬´ j'√©conomise ¬ª d√©tourne du carburant des chats d'impulsion vers ton garage futur.",
    },
  },
  {
    id: "dream_home",
    emoji: "üè°",
    image:
      "https://images.unsplash.com/photo-1568605114967-8130f3a36994?auto=format&fit=crop&w=1200&q=80",
    color: "#FFF1E6",
    categories: ["dream", "home"],
    basePriceUSD: 90000,
    priceUSD: 90000,
    title: {
      ru: "–í–∑–Ω–æ—Å –∑–∞ –∫–≤–∞—Ä—Ç–∏—Ä—É",
      en: "Home down payment",
      es: "Enganche para casa",
      fr: "Apport pour la maison",
    },
    description: {
      ru: "–ü—É—Å—Ç—å –æ—Ç–∫–∞–∑ –æ—Ç –¥–æ—Å—Ç–∞–≤–æ–∫ –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤ –∫–∏—Ä–ø–∏—á–∏ —Ç–≤–æ–µ–≥–æ –±—É–¥—É—â–µ–≥–æ –∞–¥—Ä–µ—Å–∞.",
      en: "Every skipped delivery becomes a brick in your future address.",
      es: "Cada entrega que saltas se convierte en un ladrillo de tu futuro hogar.",
      fr: "Chaque livraison √©vit√©e devient une brique de ton adresse future.",
    },
  },
  {
    id: "private_jet",
    emoji: "üõ©Ô∏è",
    image:
      "https://images.unsplash.com/photo-1489515217757-5fd1be406fef?auto=format&fit=crop&w=1200&q=80",
    color: "#EDF7FF",
    categories: ["dream", "wow"],
    basePriceUSD: 250000,
    priceUSD: 250000,
    title: {
      ru: "–ß–∞—Å—Ç–Ω—ã–π —Å–∞–º–æ–ª—ë—Ç (–º–µ—á—Ç–∞)",
      en: "Private jet (why not)",
      es: "Jet privado (por qu√© no)",
      fr: "Jet priv√© (pourquoi pas)",
    },
    description: {
      ru: "–ß–∏—Å—Ç–∞—è –≥–µ–π–º–∏—Ñ–∏–∫–∞—Ü–∏—è: —É—Ä–æ–≤–µ–Ω—å ¬´—Å–∞–º–æ–ª—ë—Ç¬ª –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –±–µ–∑–ª–∏–º–∏—Ç–Ω—É—é –¥–∏—Å—Ü–∏–ø–ª–∏–Ω—É.",
      en: "Pure gamification: the jet tier proves your discipline is first class.",
      es: "Gamificaci√≥n pura: nivel jet demuestra disciplina de primera clase.",
      fr: "Pure gamification : ce palier ‚Äújet‚Äù prouve une discipline premi√®re classe.",
    },
  },
];

const findTemplateById = (id) => DEFAULT_TEMPTATIONS.find((item) => item.id === id);

const INITIAL_FREE_DAY_STATS = {
  total: 0,
  current: 0,
  best: 0,
  lastDate: null,
  achievements: [],
  blockedDate: null,
};

const FREE_DAY_MILESTONES = [3, 7, 30];
const HEALTH_PER_REWARD = ECONOMY_RULES.baseAchievementReward;
const FREE_DAY_RESCUE_COST = ECONOMY_RULES.freeDayRescueCost;
const FREE_DAY_LOGIN_BLUE_COINS = 2;

let activeCurrency = DEFAULT_PROFILE.currency;
const setActiveCurrency = (code) => {
  activeCurrency = CURRENCIES.includes(code) ? code : DEFAULT_PROFILE.currency;
};

const GOALS = [
  {
    id: "starter",
    target: 250,
    copy: {
      ru: { title: "–ó–∞–±—Ä–æ–Ω—å 250$", desc: "–º–µ–Ω—å—à–µ –∫–æ—Ñ–µ–µ–Ω, –±–æ–ª—å—à–µ —Ä–µ–∑–µ—Ä–≤–∞" },
      en: { title: "Lock $250", desc: "skip caf√©s, build reserves" },
      es: { title: "Asegura $250", desc: "menos caf√©s, m√°s reserva" },
      fr: { title: "Verrouille 250 $", desc: "moins de caf√©s, plus de r√©serve" },
    },
  },
  {
    id: "focus",
    target: 1000,
    copy: {
      ru: { title: "–°–¥–µ—Ä–∂–∏ 1000$", desc: "–æ—Å–æ–∑–Ω–∞–Ω–Ω—ã–µ –≥–∞–¥–∂–µ—Ç—ã –≤–º–µ—Å—Ç–æ —Ö–∞–æ—Å–∞" },
      en: { title: "Hold $1000", desc: "mindful tech deals only" },
      es: { title: "Ret√©n $1000", desc: "gadgets con consciencia" },
      fr: { title: "Garde 1 000 $", desc: "des gadgets r√©fl√©chis uniquement" },
    },
  },
  {
    id: "pro",
    target: 5000,
    copy: {
      ru: { title: "–ì–µ—Ä–æ–π —ç–∫–æ–Ω–æ–º–∏–∏", desc: "—Ç—ã –∑–∞–º–µ–Ω—è–µ—à—å —Ç—Ä–∞—Ç—ã –ø—Ä–∏–≤—ã—á–∫–æ–π" },
      en: { title: "Savings hero", desc: "deals became a habit" },
      es: { title: "H√©roe del ahorro", desc: "los rechazos son tu h√°bito" },
      fr: { title: "H√©ros de l'√©pargne", desc: "les refus sont devenus ton habitude" },
    },
  },
];

const SAVINGS_TIERS = [6, 20, 50, 100, 250, 500, 1000, 2500, 5000, 10000, 20000, 50000, 100000, 250000];
const LEVEL_TWO_TARGET_RUB_USD = convertFromCurrency(600, "RUB"); // level 2 at ‚ÇΩ600 instead of default $6
const LEVEL_TWO_TARGET_EUR_USD = convertFromCurrency(6, "EUR"); // keep ‚Ç¨6 requirement despite USD base
const LEVEL_TWO_TARGET_GBP_USD = convertFromCurrency(6, "GBP"); // keep ¬£6 requirement despite USD base
const LEVEL_TWO_TARGET_SAR_USD = convertFromCurrency(6, "SAR"); // keep Ô∑º6 requirement despite USD base
const LEVEL_TWO_TARGET_AED_USD = convertFromCurrency(6, "AED"); // keep ÿØ.ÿ•6 requirement despite USD base
const LEVEL_TWO_TARGET_AUD_USD = convertFromCurrency(6, "AUD"); // keep A$6 requirement despite USD base
const LEVEL_TWO_TARGET_BYN_USD = convertFromCurrency(6, "BYN"); // keep Br6 requirement despite USD base
const LEVEL_TWO_TARGET_CAD_USD = convertFromCurrency(6, "CAD"); // keep C$6 requirement despite USD base
const LEVEL_TWO_TARGET_PLN_USD = convertFromCurrency(6, "PLN"); // keep z≈Ç6 requirement despite USD base
const LEVEL_TWO_TARGET_KZT_USD = convertFromCurrency(3000, "KZT"); // keep ‚Ç∏3000 requirement despite USD base
const LEVEL_TWO_TARGET_JPY_USD = convertFromCurrency(1000, "JPY"); // keep ¬•1000 requirement despite USD base
const LEVEL_TWO_TARGET_KRW_USD = convertFromCurrency(15000, "KRW"); // keep ‚Ç©15000 requirement despite USD base
const LEVEL_TWO_TARGET_MXN_USD = convertFromCurrency(120, "MXN"); // keep MX$120 requirement despite USD base
const getTierTargetsUSD = (currencyCode = activeCurrency) => {
  const code = currencyCode || activeCurrency;
  if (code === "RUB") {
    return [LEVEL_TWO_TARGET_RUB_USD, ...SAVINGS_TIERS.slice(1)];
  }
  if (code === "EUR") {
    return [LEVEL_TWO_TARGET_EUR_USD, ...SAVINGS_TIERS.slice(1)];
  }
  if (code === "AUD") {
    return [LEVEL_TWO_TARGET_AUD_USD, ...SAVINGS_TIERS.slice(1)];
  }
  if (code === "BYN") {
    return [LEVEL_TWO_TARGET_BYN_USD, ...SAVINGS_TIERS.slice(1)];
  }
  if (code === "CAD") {
    return [LEVEL_TWO_TARGET_CAD_USD, ...SAVINGS_TIERS.slice(1)];
  }
  if (code === "GBP") {
    return [LEVEL_TWO_TARGET_GBP_USD, ...SAVINGS_TIERS.slice(1)];
  }
  if (code === "SAR") {
    return [LEVEL_TWO_TARGET_SAR_USD, ...SAVINGS_TIERS.slice(1)];
  }
  if (code === "AED") {
    return [LEVEL_TWO_TARGET_AED_USD, ...SAVINGS_TIERS.slice(1)];
  }
  if (code === "PLN") {
    return [LEVEL_TWO_TARGET_PLN_USD, ...SAVINGS_TIERS.slice(1)];
  }
  if (code === "KZT") {
    return [LEVEL_TWO_TARGET_KZT_USD, ...SAVINGS_TIERS.slice(1)];
  }
  if (code === "JPY") {
    return [LEVEL_TWO_TARGET_JPY_USD, ...SAVINGS_TIERS.slice(1)];
  }
  if (code === "KRW") {
    return [LEVEL_TWO_TARGET_KRW_USD, ...SAVINGS_TIERS.slice(1)];
  }
  if (code === "MXN") {
    return [LEVEL_TWO_TARGET_MXN_USD, ...SAVINGS_TIERS.slice(1)];
  }
  return SAVINGS_TIERS;
};

const formatCurrency = (value = 0, currency = activeCurrency, options = null) => {
  const locale = CURRENCY_LOCALES[currency] || "en-US";
  const displayPrecision = getCurrencyDisplayPrecision(currency);
  const precisionOverride =
    typeof options?.precisionOverride === "number" && Number.isFinite(options.precisionOverride)
      ? Math.max(0, Math.min(6, options.precisionOverride))
      : null;
  const friendlyRequested = Boolean(options?.friendly);
  const friendly = friendlyRequested && precisionOverride === null;
  const baseValue = Number(value) || 0;
  const adjusted = friendly ? applyFriendlyDisplayRounding(baseValue, currency) : baseValue;
  const precision = precisionOverride ?? displayPrecision;
  const normalized = roundCurrencyValue(adjusted, currency, precision);
  const minFractionDigits = precisionOverride !== null ? precision : 0;
  const maxFractionDigits = precision;
  try {
    if (RTL_CURRENCIES.has(currency)) {
      const digits = new Intl.NumberFormat("en-US", {
        minimumFractionDigits: minFractionDigits,
        maximumFractionDigits: maxFractionDigits,
      }).format(normalized);
      const symbol = CURRENCY_SIGNS[currency] || "";
      return `${LTR_MARK}${symbol}${digits}`;
    }
    return new Intl.NumberFormat(locale, {
      style: "currency",
      currency,
      minimumFractionDigits: minFractionDigits,
      maximumFractionDigits: maxFractionDigits,
    }).format(normalized);
  } catch {
    const symbol = CURRENCY_SIGNS[currency] || "$";
    const prefix = RTL_CURRENCIES.has(currency) ? `${LTR_MARK}${symbol}` : symbol;
    return `${prefix}${normalized.toLocaleString(locale, {
      minimumFractionDigits: minFractionDigits,
      maximumFractionDigits: maxFractionDigits,
    })}`;
  }
};

const formatCurrencyWhole = (value = 0, currency = activeCurrency, precisionOverride = null) => {
  const locale = CURRENCY_LOCALES[currency] || "en-US";
  const basePrecision = getCurrencyDisplayPrecision(currency);
  const normalizedPrecision =
    typeof precisionOverride === "number" && Number.isFinite(precisionOverride)
      ? Math.max(0, Math.min(6, precisionOverride))
      : basePrecision;
  const rounded = roundCurrencyValue(Number(value) || 0, currency, normalizedPrecision);
  try {
    if (RTL_CURRENCIES.has(currency)) {
      const digits = new Intl.NumberFormat("en-US", {
        minimumFractionDigits: normalizedPrecision,
        maximumFractionDigits: normalizedPrecision,
      }).format(rounded);
      const symbol = CURRENCY_SIGNS[currency] || "";
      return `${LTR_MARK}${symbol}${digits}`;
    }
    return new Intl.NumberFormat(locale, {
      style: "currency",
      currency,
      minimumFractionDigits: normalizedPrecision,
      maximumFractionDigits: normalizedPrecision,
    }).format(rounded);
  } catch {
    const symbol = CURRENCY_SIGNS[currency] || "$";
    const prefix = RTL_CURRENCIES.has(currency) ? `${LTR_MARK}${symbol}` : symbol;
    return `${prefix}${rounded.toLocaleString(locale, {
      minimumFractionDigits: normalizedPrecision,
      maximumFractionDigits: normalizedPrecision,
    })}`;
  }
};

const splitCurrencyLabel = (label = "", currency = activeCurrency) => {
  if (!label) return { value: "", symbol: "" };
  const normalized = `${label}`.replace(/[\u00A0\u202F]/g, " ").trim();
  if (!normalized) return { value: "", symbol: "" };
  const preferredSymbol = CURRENCY_SIGNS[currency] || "";
  const hasPreferredSymbol = preferredSymbol && normalized.includes(preferredSymbol);
  const fallbackSymbol = normalized.replace(/[-\d\s.,]/g, "").trim();
  const symbol = hasPreferredSymbol ? preferredSymbol : fallbackSymbol;
  const value = symbol ? normalized.replace(symbol, "").trim() : normalized;
  return {
    value: value.replace(/\s{2,}/g, " "),
    symbol,
  };
};

const getCopyForPurchase = (item, language, t) => {
  if (item.copy?.[language]) return item.copy[language];
  const product = DEFAULT_TEMPTATIONS.find((prod) => prod.id === item.productId);
  if (product) {
    return {
      title: product.title?.[language] || product.title?.en || product.id,
      desc: product.description?.[language] || product.description?.en || t("defaultDealDesc"),
    };
  }
  return {
    title: t("defaultDealTitle"),
    desc: t("defaultDealDesc"),
  };
};

const parseColor = (value) => {
  if (typeof value !== "string") return { r: 0, g: 0, b: 0 };
  if (value.startsWith("#")) {
    const full =
      value.length === 4
        ? `#${value[1]}${value[1]}${value[2]}${value[2]}${value[3]}${value[3]}`
        : value;
    const num = parseInt(full.slice(1), 16);
    if (Number.isNaN(num)) return { r: 0, g: 0, b: 0 };
    return { r: (num >> 16) & 255, g: (num >> 8) & 255, b: num & 255 };
  }
  const rgbMatch = value.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/i);
  if (rgbMatch) {
    return { r: Number(rgbMatch[1]), g: Number(rgbMatch[2]), b: Number(rgbMatch[3]) };
  }
  return { r: 0, g: 0, b: 0 };
};

const blendColors = (colorA, colorB, ratio = 0.5) => {
  const clamp = (num) => Math.max(0, Math.min(255, Math.round(num)));
  const t = Math.max(0, Math.min(1, ratio));
  const a = parseColor(colorA);
  const b = parseColor(colorB);
  const r = clamp(a.r * (1 - t) + b.r * t);
  const g = clamp(a.g * (1 - t) + b.g * t);
  const bl = clamp(a.b * (1 - t) + b.b * t);
  return `rgb(${r}, ${g}, ${bl})`;
};

const blendHexColors = (colorA, colorB, ratio = 0.5) => {
  const clamp = (num) => Math.max(0, Math.min(255, Math.round(num)));
  const toHex = (num) => clamp(num).toString(16).padStart(2, "0");
  const t = Math.max(0, Math.min(1, ratio));
  const a = parseColor(colorA);
  const b = parseColor(colorB);
  const r = a.r * (1 - t) + b.r * t;
  const g = a.g * (1 - t) + b.g * t;
  const bl = a.b * (1 - t) + b.b * t;
  return `#${toHex(r)}${toHex(g)}${toHex(bl)}`;
};

const colorWithAlpha = (color, alpha = 1) => {
  const normalized = Math.max(0, Math.min(1, alpha));
  const { r, g, b } = parseColor(color);
  return `rgba(${r}, ${g}, ${b}, ${normalized})`;
};

const getTierProgress = (savedUSD = 0, currencyCode = activeCurrency) => {
  const tierTargets = getTierTargetsUSD(currencyCode);
  let previousTarget = 0;
  for (let i = 0; i < tierTargets.length; i += 1) {
    const target = tierTargets[i];
    if (savedUSD < target) {
      return {
        level: i + 1,
        prevTargetUSD: previousTarget,
        nextTargetUSD: target,
      };
    }
    previousTarget = target;
  }
  return {
    level: tierTargets.length + 1,
    prevTargetUSD: previousTarget,
    nextTargetUSD: null,
  };
};

function CategoryChip({ label, isActive, onPress, colors }) {
  return (
    <TouchableOpacity
      onPress={onPress}
      style={[
        styles.categoryChip,
        { backgroundColor: isActive ? colors.text : colors.card, borderColor: colors.border },
      ]}
    >
      <Text
        style={[
          styles.categoryChipText,
          { color: isActive ? colors.background : colors.muted },
        ]}
      >
        {label}
      </Text>
    </TouchableOpacity>
  );
}

const resolveTemptationTitle = (item, language, override) => {
  if (override) return override;
  if (item.titleOverride) return item.titleOverride;
  const source = item.title;
  if (typeof source === "string") return source;
  return (
    source?.[language] ||
    source?.en ||
    (typeof source === "object" ? Object.values(source)[0] : null) ||
    "Wish"
  );
};

const buildTemptationDisplayTitle = (emojiValue, titleValue, fallbackTitle = "Wish") => {
  const emoji = (emojiValue || "").trim();
  const title = (titleValue || "").trim() || fallbackTitle || "";
  return emoji ? `${emoji} ${title}`.trim() : title;
};

const getTemptationPrice = (item) => {
  const price = typeof item?.priceUSD === "number" ? item.priceUSD : item?.basePriceUSD;
  if (typeof price === "number" && !Number.isNaN(price)) {
    return price;
  }
  return 0;
};

const getTemptationPricePrecision = (item) => {
  if (!item) return null;
  const precision = item.pricePrecision;
  if (typeof precision === "number" && Number.isFinite(precision) && precision >= 0) {
    return precision;
  }
  return null;
};

const formatTemptationPriceLabel = (item, currency) => {
  const priceUSD = getTemptationPrice(item);
  const precision = getTemptationPricePrecision(item);
  const hasOverride = precision !== null;
  return formatCurrency(convertToCurrency(priceUSD, currency), currency, {
    friendly: !hasOverride,
    precisionOverride: hasOverride ? precision : null,
  });
};

function TemptationCardComponent({
  item,
  language,
  colors,
  onAction,
  t,
  currency = activeCurrency,
  stats = {},
  feedback,
  titleOverride,
  descriptionOverride = null,
  goalLabel = null,
  isWishlistGoal = false,
  isFocusTarget = false,
  editCategoryValue = DEFAULT_IMPULSE_CATEGORY,
  onEditCategoryChange,
  onToggleEdit,
  isEditing = false,
  editTitleValue = "",
  editPriceValue = "",
  editGoalLabel = "",
  editEmojiValue = "",
  editDescriptionValue = "",
  onEditTitleChange,
  onEditPriceChange,
  onEditEmojiChange,
  onEditDescriptionChange,
  onEditSave,
  onEditCancel,
  onEditDelete,
  onEditGoalSelect,
  onSwipeDelete,
  onQuickGoalToggle,
  showEditorInline = false,
  cardStyle = null,
  isPrimaryTemptation = false,
}) {
  const title = resolveTemptationTitle(item, language, titleOverride);
  const isCustomCard =
    Array.isArray(item?.categories) && item.categories.some((category) => category === "custom");
  const descriptionString = typeof item.description === "string" ? item.description : null;
  const descriptionMap =
    item.description && typeof item.description === "object" && !Array.isArray(item.description)
      ? item.description
      : null;
  const customDescriptionFallback = isCustomCard
    ? buildCustomTemptationDescription(item?.gender || "none")
    : null;
  const customLanguageFallback = customDescriptionFallback
    ? resolveLanguageMapValue(customDescriptionFallback, language)
    : null;
  const descriptionLanguageValue = descriptionMap ? resolveLanguageMapValue(descriptionMap, language) : null;
  let resolvedDesc = descriptionOverride || null;
  if (!resolvedDesc) {
    const baseDescription = descriptionLanguageValue || descriptionString || "";
    resolvedDesc = isCustomCard ? baseDescription || customLanguageFallback || "" : baseDescription;
  }
  const desc = resolvedDesc || "";
  const priceLabel = formatTemptationPriceLabel(item, currency);
  const highlight = true;
  const isDarkTheme = colors.background === THEMES.dark.background;
  const baseColor = item.color || colors.card;
  const focusActive = isFocusTarget && !showEditorInline;
  const darkCardPalette = highlight
    ? {
        background: blendColors(baseColor, "#2B1A00", 0.4),
        border: "#F6C16B",
        text: "#FFEED0",
        muted: "rgba(255,238,208,0.75)",
        badgeBg: "rgba(255,255,255,0.2)",
        badgeBorder: "rgba(255,255,255,0.32)",
        swipeBg: "rgba(255,255,255,0.08)",
        swipeBorder: "rgba(255,255,255,0.18)",
      }
    : {
        background: "#101526",
        border: "rgba(255,255,255,0.08)",
        text: colors.text,
        muted: colors.muted,
        badgeBg: "rgba(255,255,255,0.08)",
        badgeBorder: "rgba(255,255,255,0.18)",
        swipeBg: "rgba(255,255,255,0.04)",
        swipeBorder: "rgba(255,255,255,0.08)",
      };
  const baseCardBackground = isDarkTheme
    ? blendColors(colors.card, baseColor, 0.2)
    : baseColor;
  const cardBackground = baseCardBackground;
  const cardSurfaceColor = isDarkTheme
    ? blendColors(cardBackground, "#FFFFFF", 0.08)
    : lightenColor(cardBackground, 0.18);
  const primaryHighlightColor = Platform.OS === "ios" ? "#FF6F7D" : "#FF4D5A";
  const cardTextColor = isDarkTheme ? darkCardPalette.text : colors.text;
  const cardMutedColor = isDarkTheme ? darkCardPalette.muted : colors.muted;
  const resolvedGoalLabel =
    typeof goalLabel === "string" && goalLabel.trim().length ? goalLabel.trim() : "";
  const coinBurstColor = isDarkTheme ? "#FFD78B" : "#FFF4B3";
  const effectiveWishlistGoal = isWishlistGoal && !isPrimaryTemptation;
  const highlightPinned = effectiveWishlistGoal && !showEditorInline;
  const textureSeedSource = item.id || title || "";
  const textureSeed = textureSeedSource
    ? textureSeedSource.split("").reduce((acc, char) => acc + char.charCodeAt(0), 0)
    : 0;
  const textureVariant = textureSeed % CARD_TEXTURE_ACCENTS.length;
  const accentPaletteColor = CARD_TEXTURE_ACCENTS[textureVariant];
  const textureShift = (textureSeed % 7) * 0.02;
  const texturePrimaryColor = blendColors(
    cardBackground,
    isDarkTheme ? "#080808" : "#FFFFFF",
    isDarkTheme ? 0.12 + textureShift : 0.42 + textureShift * 0.5
  );
  const textureAccentColor = blendColors(
    cardBackground,
    isPrimaryTemptation ? "#FF6B8F" : highlightPinned ? "#FFD36E" : accentPaletteColor,
    isDarkTheme ? 0.25 + textureShift : 0.5 + textureShift * 0.5
  );
  const textureHighlightColor = blendColors(
    cardBackground,
    highlightPinned ? "#FFF6C8" : isPrimaryTemptation ? "#FF9FB0" : "#D9F2FF",
    isDarkTheme ? 0.18 : 0.32
  );
  const showCardTexture = false;
  const defaultShadowColor = isDarkTheme ? "rgba(255,255,255,0.55)" : "rgba(15,23,42,0.22)";
  const redShadowColor = Platform.OS === "ios" ? "rgba(244,37,78,0.6)" : "rgba(244,37,78,0.88)";
  const goldShadowColor = "rgba(255,198,110,0.75)";
  const focusShadowColor = "rgba(255,92,92,0.85)";
  const shadowColor = isPrimaryTemptation
    ? redShadowColor
    : focusActive
    ? focusShadowColor
    : highlightPinned
    ? goldShadowColor
    : defaultShadowColor;
  const shadowRadius = isPrimaryTemptation
    ? Platform.OS === "ios" ? 28 : 36
    : focusActive
    ? 34
    : highlightPinned
    ? 30
    : isDarkTheme
    ? 28
    : 22;
  const shadowOpacity = isPrimaryTemptation
    ? Platform.OS === "ios" ? 0.6 : 0.8
    : focusActive
    ? 0.75
    : highlightPinned
    ? 0.6
    : isDarkTheme
    ? 0.55
    : 0.3;
  const shadowElevation = isPrimaryTemptation ? 16 : focusActive ? 18 : highlightPinned ? 14 : isDarkTheme ? 12 : 8;
  const shadowOffsetHeight = isPrimaryTemptation
    ? Platform.OS === "ios" ? 12 : 18
    : focusActive
    ? 16
    : highlightPinned
    ? 16
    : isDarkTheme
    ? 14
    : 12;
  const cardShadowStyle = Platform.select({
    ios: {
      shadowColor,
      shadowOpacity,
      shadowRadius,
      shadowOffset: { width: 0, height: shadowOffsetHeight },
    },
    android: {
      elevation: shadowElevation,
      shadowColor,
    },
    default: {},
  });
  const defaultGoalBadgeBackground = isDarkTheme ? "rgba(255,255,255,0.08)" : "rgba(0,0,0,0.04)";
  const defaultGoalBadgeBorder = isDarkTheme ? "rgba(255,255,255,0.24)" : "rgba(0,0,0,0.08)";
  const defaultGoalBadgeText = isDarkTheme ? "#FFF7E1" : colors.text;
  const canAssignGoal = !isPrimaryTemptation;
  const hasGoalAssigned = !!resolvedGoalLabel && canAssignGoal;
  const refuseCount = stats?.count || 0;
  const totalRefusedLabel = formatCurrency(
    convertToCurrency(stats?.totalUSD || 0, currency),
    currency
  );
  const actionConfig = [
    { type: "save", label: t("saveAction"), variant: "primary" },
    { type: "spend", label: t("spendAction"), variant: "ghost" },
    { type: "maybe", label: t("maybeAction"), variant: "outline" },
  ];
  const [coinBursts, setCoinBursts] = useState([]);
  const messageActive = feedback?.message;
  const burstKey = feedback?.burstKey;
  const translateX = useRef(new Animated.Value(0)).current;
  const swipeActionRef = useRef(false);

  useEffect(() => {
    translateX.setValue(0);
  }, [item.id, translateX]);

  const handleSwipeRelease = useCallback(
    (dx = 0) => {
      if (!showEditorInline) {
        if (dx > GOAL_SWIPE_THRESHOLD && onQuickGoalToggle) {
          if (!canAssignGoal) {
            Alert.alert(t("tamagotchiName"), t("goalMainTemptationError"));
          } else {
            swipeActionRef.current = true;
            onQuickGoalToggle(item);
          }
        } else if (dx < -DELETE_SWIPE_THRESHOLD && onSwipeDelete) {
          swipeActionRef.current = true;
          onSwipeDelete(item);
        }
      }
      Animated.timing(translateX, {
        toValue: 0,
        duration: 160,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }).start();
    },
    [item, onQuickGoalToggle, onSwipeDelete, showEditorInline, translateX]
  );

  const panResponder = useMemo(
    () =>
      PanResponder.create({
        onStartShouldSetPanResponder: () => false,
        onMoveShouldSetPanResponder: (_, gestureState) =>
          !showEditorInline &&
          Math.abs(gestureState.dx) > Math.abs(gestureState.dy) &&
          Math.abs(gestureState.dx) > 6,
        onPanResponderGrant: () => {
          translateX.stopAnimation();
        },
        onPanResponderMove: (_, gestureState) => {
          if (showEditorInline) return;
          const dx = Math.max(Math.min(gestureState.dx, 150), -180);
          translateX.setValue(dx);
        },
        onPanResponderRelease: (_, gestureState) => {
          handleSwipeRelease(gestureState.dx);
        },
        onPanResponderTerminationRequest: () => false,
        onPanResponderTerminate: () => handleSwipeRelease(0),
      }),
    [handleSwipeRelease, showEditorInline, translateX]
  );

  useEffect(() => {
  }, [messageActive]);

  useEffect(() => {
    if (!burstKey) return;
    const coins = Array.from({ length: 5 }).map((_, index) => ({
      id: `${burstKey}-${index}`,
      progress: new Animated.Value(0),
      offsetX: (Math.random() - 0.5) * 80,
      rotation: (Math.random() > 0.5 ? 1 : -1) * (200 + Math.random() * 160),
      delay: index * 80,
    }));
    setCoinBursts(coins);
    coins.forEach((coin) => {
      Animated.timing(coin.progress, {
        toValue: 1,
        duration: 900,
        delay: coin.delay,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }).start();
    });
    const timeout = setTimeout(() => setCoinBursts([]), 1100);
    return () => clearTimeout(timeout);
  }, [burstKey]);

  const handleCardPress = useCallback(() => {
    if (swipeActionRef.current) {
      swipeActionRef.current = false;
      return;
    }
    onToggleEdit?.(item);
  }, [item, onToggleEdit]);

  return (
    <View style={styles.temptationSwipeWrapper}>
      <View style={styles.temptationSwipeBackground} pointerEvents="none">
        <View
          style={[
            styles.swipeHint,
            styles.swipeHintLeft,
            {
              borderColor: isDarkTheme ? "rgba(255,255,255,0.12)" : colors.border,
              backgroundColor: isDarkTheme ? "rgba(246,193,107,0.2)" : "rgba(246,193,107,0.12)",
            },
          ]}
        >
          <Text style={[styles.swipeHintIcon, { color: GOAL_HIGHLIGHT_COLOR }]}>üéØ</Text>
          <Text style={[styles.swipeHintText, { color: GOAL_HIGHLIGHT_COLOR }]}>
            {isWishlistGoal ? t("goalAssignClear") : t("goalSwipeAdd")}
          </Text>
        </View>
        <View
          style={[
            styles.swipeHint,
            styles.swipeHintRight,
            {
              borderColor: isDarkTheme ? "rgba(255,255,255,0.12)" : colors.border,
              backgroundColor: isDarkTheme ? "rgba(255,87,115,0.15)" : "rgba(233,61,87,0.12)",
            },
          ]}
        >
          <Text style={[styles.swipeHintIcon, { color: "#E15555" }]}>üóëÔ∏è</Text>
          <Text style={[styles.swipeHintText, { color: "#E15555" }]}>{t("goalSwipeDelete")}</Text>
        </View>
      </View>
      <Animated.View
        {...panResponder.panHandlers}
        style={[
          styles.temptationCard,
          cardShadowStyle,
          cardStyle,
          {
            backgroundColor: cardSurfaceColor,
            transform: [{ translateX }],
          },
        ]}
      >
        <TouchableWithoutFeedback onPress={handleCardPress}>
          <View>
            {showCardTexture && (
              <View pointerEvents="none" style={styles.temptationTextureContainer}>
                <View
                  style={[
                    styles.temptationTextureOverlay,
                    { backgroundColor: texturePrimaryColor, opacity: isDarkTheme ? 0.08 : 0.18 },
                  ]}
                />
                <View
                  style={[
                    styles.temptationTextureOverlay,
                    styles.temptationTextureAccent,
                    { backgroundColor: textureAccentColor },
                  ]}
                />
                <View
                  style={[
                    styles.temptationTextureOverlay,
                    styles.temptationTextureHighlight,
                    { backgroundColor: textureHighlightColor },
                  ]}
                />
              </View>
            )}
      <View
        style={[
          styles.temptationHeader,
          !showEditorInline && effectiveWishlistGoal && canAssignGoal ? { paddingRight: 64 } : null,
        ]}
      >
        {showEditorInline ? (
          <View style={styles.titleEditWrapper}>
            <View
              style={[
                styles.emojiEditWrapper,
                { borderColor: colors.border, backgroundColor: colors.card },
              ]}
            >
              <TextInput
                style={[styles.emojiEditInput, { color: colors.text }]}
                value={editEmojiValue ?? ""}
                onChangeText={onEditEmojiChange}
                placeholder={item.emoji || DEFAULT_TEMPTATION_EMOJI}
                placeholderTextColor={colors.muted}
                selectTextOnFocus
                maxLength={2}
              />
              <Text style={[styles.emojiEditIcon, { color: colors.muted }]}>‚úèÔ∏è</Text>
            </View>
            <View style={styles.titleEditInputContainer}>
              <TextInput
                style={[
                  styles.titleEditInput,
                  {
                    borderColor: colors.border,
                    color: colors.text,
                    backgroundColor: colors.card,
                  },
                ]}
                value={editTitleValue}
                onChangeText={onEditTitleChange}
                placeholder={t("priceEditNameLabel")}
                placeholderTextColor={colors.muted}
              />
              <Text style={[styles.titleEditIcon, { color: colors.muted }]}>‚úèÔ∏è</Text>
            </View>
          </View>
        ) : (
          <>
            <View style={styles.emojiDisplayWrapper}>
              <Text style={[styles.temptationEmoji, { color: cardTextColor }]}>{item.emoji || "‚ú®"}</Text>
            </View>
            <Text style={[styles.temptationTitle, { color: cardTextColor }]}>{title}</Text>
          </>
        )}
      </View>
      {!showEditorInline && effectiveWishlistGoal && canAssignGoal && (
        <View style={styles.temptationBadgeStack} pointerEvents="none">
          {hasGoalAssigned && (
            <View
              style={[
                styles.temptationGoalBadge,
                styles.temptationGoalBadgeFloating,
                {
                  backgroundColor: isDarkTheme ? "#F6C16B22" : "#FFF2CC",
                  borderColor: isDarkTheme ? "#F6C16B55" : "#F6C16B",
                },
              ]}
            >
              <Text style={[styles.temptationGoalBadgeText, { color: isDarkTheme ? "#FEEAC4" : "#5C3A00" }]}>
                {t("goalPinnedBadge")}
              </Text>
            </View>
          )}
          {isWishlistGoal && (
            <View
              style={[
                styles.temptationPinnedBadge,
                {
                  borderColor: GOAL_HIGHLIGHT_COLOR,
                  backgroundColor: isDarkTheme ? "rgba(246,193,107,0.2)" : "rgba(246,193,107,0.12)",
                },
              ]}
            >
              <Text style={[styles.temptationPinnedBadgeText, { color: GOAL_HIGHLIGHT_COLOR }]}>
                {t("goalPinnedBadge")}
              </Text>
            </View>
          )}
        </View>
      )}
      {!showEditorInline && hasGoalAssigned && (
        <View
          style={[
            styles.temptationGoalBadge,
            {
              backgroundColor: isDarkTheme ? "rgba(246,193,107,0.18)" : "rgba(246,193,107,0.12)",
              borderColor: isDarkTheme ? "rgba(246,193,107,0.55)" : "rgba(246,193,107,0.65)",
            },
          ]}
        >
          <Text style={[styles.temptationGoalBadgeText, { color: isDarkTheme ? "#FEEAC4" : "#5C3A00" }]}>
            {t("goalDestinationLabel")}: {resolvedGoalLabel}
          </Text>
        </View>
      )}
      {focusActive && (
        <View
          style={[
            styles.temptationFocusBadge,
            {
              backgroundColor: isDarkTheme ? "rgba(255,92,92,0.15)" : "rgba(255,92,92,0.12)",
              borderColor: isDarkTheme ? "rgba(255,92,92,0.5)" : "rgba(255,92,92,0.45)",
            },
          ]}
        >
          <Text style={[styles.temptationFocusBadgeText, { color: isDarkTheme ? "#FFC0C0" : "#C2153B" }]}>
            {t("focusBadgeLabel")}
          </Text>
        </View>
      )}
      {showEditorInline ? (
        <TouchableOpacity
          style={[
            styles.temptationGoalBadge,
            styles.temptationGoalBadgeEditable,
            { borderColor: colors.border, backgroundColor: colors.card },
          ]}
          onPress={onEditGoalSelect}
        >
          <Text style={[styles.temptationGoalBadgeText, { color: colors.text }]}>
            {goalLabel || t("goalAssignFieldLabel")}
          </Text>
          <Text style={[styles.editorHintIcon, { color: colors.muted, marginLeft: 6 }]}>‚úèÔ∏è</Text>
        </TouchableOpacity>
      ) : null}
      {showEditorInline ? (
        <View style={styles.descriptionEditWrapper}>
          <TextInput
            multiline
            style={[
              styles.descriptionEditInput,
              {
                borderColor: colors.border,
                color: colors.text,
                backgroundColor: colors.card,
              },
            ]}
            value={editDescriptionValue ?? ""}
            onChangeText={onEditDescriptionChange}
            placeholder={t("priceEditDescriptionLabel")}
            placeholderTextColor={colors.muted}
          />
          <Text style={[styles.editorHintIcon, { color: colors.muted }]}>‚úèÔ∏è</Text>
        </View>
      ) : desc ? (
        <Text style={[styles.temptationDesc, { color: cardMutedColor }]}>
          {desc}
        </Text>
      ) : null}
      {refuseCount > 0 && (
        <Text style={[styles.temptationRefuseMeta, { color: cardMutedColor }]}>
          {t("tileRefuseCount", { count: refuseCount, amount: totalRefusedLabel })}
        </Text>
      )}
      <View style={styles.temptationPriceRow}>
        {showEditorInline ? (
          <View
            style={[
              styles.temptationPricePill,
              { borderColor: colors.border, backgroundColor: colors.card },
            ]}
          >
            <TextInput
              style={[
                styles.pricePillInput,
                { color: colors.text },
              ]}
              value={editPriceValue ?? ""}
              onChangeText={onEditPriceChange}
              keyboardType="decimal-pad"
              placeholder={t("priceEditAmountLabel", { currency })}
              placeholderTextColor={colors.muted}
            />
            <Text style={[styles.editorHintIcon, { color: colors.muted }]}>‚úèÔ∏è</Text>
          </View>
        ) : (
          <Text
            style={[
              styles.temptationPrice,
              { color: cardTextColor },
            ]}
          >
            {priceLabel}
          </Text>
        )}
      </View>
      {showEditorInline && (
        <View style={styles.categoryEditSection}>
          <Text style={[styles.categoryEditLabel, { color: colors.muted }]}>
            {t("impulseCategoryLabel")}
          </Text>
          <ImpulseCategorySelector
            value={editCategoryValue || DEFAULT_IMPULSE_CATEGORY}
            onChange={onEditCategoryChange}
            colors={colors}
            language={language}
            compact
          />
        </View>
      )}
      {!showEditorInline && (
        <View style={styles.temptationActions}>
        {actionConfig.map((action) => {
          let buttonStyle;
          let textStyle;
          if (action.type === "save") {
            buttonStyle = [
              styles.temptationButtonPrimary,
              { backgroundColor: SAVE_ACTION_COLOR, opacity: action.disabled ? 0.4 : 1 },
            ];
            textStyle = [styles.temptationButtonPrimaryText, { color: "#FFFFFF" }];
          } else if (action.type === "spend") {
            buttonStyle = [
              styles.temptationButtonGhost,
              { borderColor: SPEND_ACTION_COLOR, opacity: action.disabled ? 0.4 : 1 },
            ];
            textStyle = [styles.temptationButtonGhostText, { color: SPEND_ACTION_COLOR }];
          } else if (action.variant === "primary") {
            buttonStyle = [
              styles.temptationButtonPrimary,
              { backgroundColor: colors.text, opacity: action.disabled ? 0.35 : 1 },
            ];
            textStyle = [styles.temptationButtonPrimaryText, { color: colors.background }];
          } else if (action.variant === "ghost") {
            buttonStyle = [styles.temptationButtonGhost, { borderColor: colors.text }];
            textStyle = [styles.temptationButtonGhostText, { color: colors.text }];
          } else {
            buttonStyle = [styles.temptationButtonOutline, { borderColor: colors.border }];
            textStyle = [styles.temptationButtonOutlineText, { color: colors.muted }];
          }
          return (
            <TouchableOpacity
              key={action.type}
              style={buttonStyle}
              onPress={() => onAction(action.type, item)}
            >
              <Text style={textStyle}>{action.label}</Text>
            </TouchableOpacity>
          );
        })}
        </View>
      )}
      {coinBursts.map((coin) => {
        const translateY = coin.progress.interpolate({
          inputRange: [0, 1],
          outputRange: [0, -140],
        });
        const translateXCoin = coin.progress.interpolate({
          inputRange: [0, 1],
          outputRange: [0, coin.offsetX],
        });
        const rotate = coin.progress.interpolate({
          inputRange: [0, 1],
          outputRange: ["0deg", `${coin.rotation}deg`],
        });
        const scale = coin.progress.interpolate({
          inputRange: [0, 0.3, 1],
          outputRange: [0.3, 1, 0.6],
        });
        const opacity = coin.progress.interpolate({
          inputRange: [0, 0.6, 1],
          outputRange: [1, 1, 0],
        });
        return (
          <Animated.View
            key={coin.id}
            pointerEvents="none"
            style={[
              styles.coinBurst,
              {
                opacity,
                transform: [{ translateX: translateXCoin }, { translateY }, { rotate }, { scale }],
              },
            ]}
          >
            <View style={[styles.coinBurstInner, { backgroundColor: coinBurstColor }]} />
          </Animated.View>
        );
      })}
      {messageActive && null}
      {showEditorInline && isEditing && (
        <View style={[styles.temptationEditor, { borderTopColor: colors.border }]}>
          <View style={styles.temptationEditorActions}>
            <TouchableOpacity
              style={[styles.priceModalPrimary, { backgroundColor: colors.text }]}
              onPress={onEditSave}
            >
              <Text style={[styles.priceModalPrimaryText, { color: colors.background }]}>
                {t("priceEditSave")}
              </Text>
            </TouchableOpacity>
            <TouchableOpacity onPress={onEditCancel}>
              <Text style={[styles.priceModalCancel, { color: colors.muted }]}>
                {t("priceEditCancel")}
              </Text>
            </TouchableOpacity>
            <TouchableOpacity onPress={onEditDelete}>
              <Text style={[styles.priceModalDeleteText, { color: "#E15555" }]}>
                {t("priceEditDelete")}
              </Text>
            </TouchableOpacity>
          </View>
        </View>
      )}
          </View>
        </TouchableWithoutFeedback>
      </Animated.View>
    </View>
  );
}

const TemptationCard = React.memo(TemptationCardComponent);

function SavingsHeroCard({
  goldPalette,
  heroSpendCopy,
  heroRecentEvents = [],
  heroEncouragementLine,
  levelLabel,
  totalSavedLabel,
  progressPercent,
  progressPercentLabel,
  goalProgressLabel,
  isGoalComplete = false,
  completionLabel,
  t,
  dailySavings = [],
  analyticsPreview = [],
  potentialSavedUSD = 0,
  actualSavedUSD = 0,
  currency,
  hasBaseline = false,
  onBaselineSetup = () => {},
  onPotentialDetailsOpen = null,
  levelHasNext = false,
  levelRemainingLabel = "",
  levelTargetLabel = "",
  levelProgressValue = 0,
  healthPoints = 0,
  onBreakdownPress = () => {},
  weeklyComparison = null,
}) {
  const [expanded, setExpanded] = useState(false);
  const [levelExpanded, setLevelExpanded] = useState(false);
  const maxAmount = Math.max(...dailySavings.map((day) => day.amountUSD), 0);
  const potentialLocal = formatCurrency(convertToCurrency(potentialSavedUSD || 0, currency), currency);
  const actualLocal = formatCurrency(convertToCurrency(actualSavedUSD || 0, currency), currency);
  const coinEntries = useMemo(() => buildHealthCoinEntries(healthPoints), [healthPoints]);
  const hasCoinInventory = coinEntries.some((entry) => entry.count > 0);
  const potentialRatio = potentialSavedUSD > 0 ? Math.min(actualSavedUSD / potentialSavedUSD, 1) : 0;
  const missedUSD = Math.max(0, potentialSavedUSD - actualSavedUSD);
  const statusKey =
    actualSavedUSD > potentialSavedUSD
      ? "potentialBlockStatusAhead"
      : actualSavedUSD <= 0
      ? "potentialBlockStatusStart"
      : potentialRatio >= 0.8
      ? "potentialBlockStatusOnTrack"
      : "potentialBlockStatusBehind";
  const handlePotentialDetailsOpen = useCallback(() => {
    if (!hasBaseline) return;
    if (typeof onPotentialDetailsOpen === "function") {
      onPotentialDetailsOpen();
    }
  }, [hasBaseline, onPotentialDetailsOpen]);
  const weeklyTrend = useMemo(() => {
    if (!weeklyComparison) return null;
    const formatEntry = (entry, type) => {
      if (!entry) return null;
      const delta = Number(entry.deltaUSD) || 0;
      const absDelta = Math.abs(delta);
      const localValue = formatCurrency(convertToCurrency(absDelta, currency), currency);
      const symbol = delta >= 0 ? "‚ñ≤" : "‚ñº";
      let color = goldPalette.accent;
      if (type === "savings") {
        color = delta >= 0 ? goldPalette.accent : goldPalette.danger;
      } else {
        color = delta >= 0 ? goldPalette.danger : goldPalette.accent;
      }
      return {
        symbol,
        label: localValue,
        color,
      };
    };
    const savingsTrend = formatEntry(weeklyComparison.savings, "savings");
    const spendingTrend = formatEntry(weeklyComparison.spending, "spending");
    if (!savingsTrend && !spendingTrend) return null;
    return { savings: savingsTrend, spending: spendingTrend };
  }, [currency, goldPalette.accent, goldPalette.danger, weeklyComparison]);
  return (
    <View
      style={[
        styles.progressHeroCard,
        styles.savedHeroCard,
        {
          backgroundColor: goldPalette.background,
          borderColor: goldPalette.border,
          shadowColor: goldPalette.shadow,
        },
      ]}
    >
      <View pointerEvents="none" style={styles.savedHeroGlowWrap}>
        <View style={[styles.savedHeroGlow, { backgroundColor: goldPalette.glow }]} />
        <View
          style={[
            styles.savedHeroGlow,
            styles.savedHeroGlowBottom,
            { backgroundColor: goldPalette.glow },
          ]}
        />
      </View>
      <View style={styles.savedHeroContent}>
        <View style={styles.savedHeroHeader}>
          <Text style={[styles.progressHeroTitle, { color: goldPalette.text }]}>
            {t("progressHeroTitle")}
          </Text>
          <TouchableOpacity
            style={[styles.savedHeroLevelButton, styles.savedHeroLevelButtonFloating]}
            hitSlop={{ top: 12, bottom: 12, left: 12, right: 12 }}
            activeOpacity={0.85}
            onPress={() => setLevelExpanded((prev) => !prev)}
          >
            <View
              style={[
                styles.savedHeroLevelBadge,
                {
                  backgroundColor: goldPalette.badgeBg,
                  borderColor: goldPalette.badgeBorder,
                },
              ]}
            >
              <Text style={[styles.savedHeroLevelText, { color: goldPalette.badgeText }]}>
                {levelLabel}
              </Text>
            </View>
          </TouchableOpacity>
        </View>
        <View style={styles.savedHeroAmountWrap}>
          <Text style={[styles.progressHeroAmount, { color: goldPalette.text }]}>
            {totalSavedLabel}
          </Text>
        </View>
        {levelExpanded && (
          <View
            style={[
              styles.heroLevelDetails,
              {
                backgroundColor: goldPalette.badgeBg,
                borderColor: goldPalette.badgeBorder,
              },
            ]}
          >
            <Text style={[styles.heroLevelTitle, { color: goldPalette.text }]}>
              {t("levelWidgetTitle")}
            </Text>
            <Text style={[styles.heroLevelSubtitle, { color: goldPalette.subtext }]}>
              {levelHasNext
                ? t("levelWidgetSubtitle", { amount: levelRemainingLabel })
                : t("levelWidgetMaxed")}
            </Text>
            <View style={[styles.levelWidgetBar, { backgroundColor: goldPalette.barBg }]}>
              <View
                style={[
                  styles.levelWidgetFill,
                  { backgroundColor: goldPalette.accent, width: `${Math.min(Math.max(levelProgressValue, 0), 1) * 100}%` },
                ]}
              />
            </View>
          </View>
        )}
        {heroRecentEvents.length > 0 ? (
          <View style={styles.savedHeroRecentList}>
            <Text style={[styles.savedHeroRecentTitle, { color: goldPalette.subtext }]}>
              {t("heroSpendRecentTitle")}
            </Text>
            {heroRecentEvents.map((entry) => (
              <Text
                key={entry.id}
                style={[
                  styles.savedHeroRecentItem,
                  { color: entry.isSpend ? goldPalette.danger : goldPalette.subtext },
                ]}
                numberOfLines={1}
                ellipsizeMode="tail"
              >
                {entry.label}
              </Text>
            ))}
          </View>
        ) : (
          <Text style={[styles.savedHeroSubtitle, { color: goldPalette.subtext }]}>
            {heroSpendCopy || heroEncouragementLine}
          </Text>
        )}

        <TouchableOpacity
          style={[
            styles.heroPotentialCard,
            {
              backgroundColor: goldPalette.badgeBg,
              borderColor: goldPalette.badgeBorder,
            },
          ]}
          activeOpacity={0.9}
          onPress={handlePotentialDetailsOpen}
        >
          {hasBaseline ? (
            <>
              <View style={styles.heroPotentialHeader}>
                <Text style={[styles.heroPotentialLabel, { color: goldPalette.text }]}>
                  {t("potentialBlockTitle")}
                </Text>
                <Text style={[styles.heroPotentialValue, { color: goldPalette.text }]}>
                  {potentialLocal}
                </Text>
              </View>
              <Text style={[styles.heroPotentialStatus, { color: goldPalette.subtext }]}>
                {t(statusKey)}
              </Text>
            </>
          ) : (
            <>
              <Text style={[styles.heroPotentialLabel, { color: goldPalette.text }]}>
                {t("potentialBlockCta")}
              </Text>
              <TouchableOpacity
                style={[
                  styles.heroPotentialButton,
                  {
                    borderColor: goldPalette.text,
                  },
                ]}
                onPress={onBaselineSetup}
              >
                <Text style={[styles.heroPotentialButtonText, { color: goldPalette.text }]}>
                  {t("baselineCTA")}
                </Text>
              </TouchableOpacity>
            </>
          )}
        </TouchableOpacity>
      <View style={styles.savedHeroProgressRow}>
        <View
          style={[
            styles.progressHeroBar,
            styles.savedHeroBar,
            { backgroundColor: goldPalette.barBg },
          ]}
        >
          <View
            style={[
              styles.progressHeroFill,
              { backgroundColor: goldPalette.accent, width: `${progressPercent * 100}%` },
            ]}
          />
        </View>
        <View
          style={[
            styles.savedHeroPercentTag,
            { backgroundColor: goldPalette.badgeBg, borderColor: goldPalette.border },
          ]}
        >
          <Text style={[styles.savedHeroPercentText, { color: goldPalette.text }]}>
            {progressPercentLabel}%
          </Text>
        </View>
      </View>
      <View style={styles.savedHeroGoalRow}>
        <Text style={[styles.goalLabel, { color: goldPalette.subtext }]}>{t("goalWidgetTitle")}</Text>
        <TouchableOpacity
          style={styles.savedHeroToggleButton}
          onPress={() => setExpanded((prev) => !prev)}
        >
          <Text style={[styles.savedHeroToggleText, { color: goldPalette.subtext }]}>
            {expanded ? t("heroCollapse") : t("heroExpand")}
          </Text>
        </TouchableOpacity>
      </View>
      <View style={styles.savedHeroGoalMetaRow}>
        <Text style={[styles.savedHeroGoalLabel, { color: goldPalette.subtext }]}>{goalProgressLabel}</Text>
        {isGoalComplete && (
          <View
            style={[
              styles.goalCompleteBadge,
              { backgroundColor: goldPalette.badgeBg, borderColor: goldPalette.badgeBorder },
            ]}
          >
            <Text style={[styles.goalCompleteBadgeText, { color: goldPalette.badgeText }]}>
              {completionLabel}
            </Text>
          </View>
        )}
      </View>
      {expanded && (
        <TouchableOpacity
          activeOpacity={0.9}
          onPress={onBreakdownPress}
          style={styles.savedHeroExpanded}
        >
          <View
            style={[
              styles.savedHeroCoinsCard,
              { backgroundColor: goldPalette.badgeBg, borderColor: goldPalette.badgeBorder },
            ]}
          >
            <View style={styles.savedHeroCoinsText}>
              <Text style={[styles.savedHeroCoinsLabel, { color: goldPalette.text }]}>
                {t("freeDayHealthTitle")}
              </Text>
              <Text style={[styles.savedHeroCoinsSubtitle, { color: goldPalette.subtext }]}>
                {t("freeDayHealthSubtitle")}
              </Text>
              {hasCoinInventory && (
                <View style={styles.freeDayCoinRow}>
                  {coinEntries.map((entry) =>
                    entry.count ? (
                      <View
                        key={entry.id}
                        style={[
                          styles.freeDayCoinBadge,
                          { borderColor: goldPalette.border, backgroundColor: goldPalette.background },
                        ]}
                      >
                        <Image source={entry.asset} style={styles.freeDayCoinImage} />
                        <Text style={[styles.freeDayCoinCount, { color: goldPalette.text }]}>√ó{entry.count}</Text>
                      </View>
                    ) : null
                  )}
                </View>
              )}
            </View>
            <Text style={[styles.savedHeroCoinsValue, { color: goldPalette.accent }]}>
              {healthPoints}
            </Text>
          </View>

          <View style={styles.savedHeroDaily}>
            <Text style={[styles.savedHeroDailyTitle, { color: goldPalette.text }]}>
              {t("heroDailyTitle")}
            </Text>
            {weeklyTrend && (
              <View style={styles.weeklyTrendRow}>
                {weeklyTrend.savings && (
                  <View style={styles.weeklyTrendItem}>
                    <Text style={[styles.weeklyTrendLabel, { color: goldPalette.subtext }]}>
                      {t("heroWeeklySavingsDelta")}
                    </Text>
                    <Text style={[styles.weeklyTrendValue, { color: weeklyTrend.savings.color }]}>
                      {weeklyTrend.savings.symbol} {weeklyTrend.savings.label}
                    </Text>
                  </View>
                )}
                {weeklyTrend.spending && (
                  <View style={styles.weeklyTrendItem}>
                    <Text style={[styles.weeklyTrendLabel, { color: goldPalette.subtext }]}>
                      {t("heroWeeklySpendingDelta")}
                    </Text>
                    <Text style={[styles.weeklyTrendValue, { color: weeklyTrend.spending.color }]}>
                      {weeklyTrend.spending.symbol} {weeklyTrend.spending.label}
                    </Text>
                  </View>
                )}
              </View>
            )}
            {maxAmount > 0 ? (
              <View style={styles.savedHeroBars}>
                {dailySavings.map((day) => (
                  <View key={day.key} style={styles.savedHeroBarItem}>
                    <View style={styles.savedHeroBarAmountWrap}>
                      {day.amountValueLabel ? (
                        <View style={styles.savedHeroBarAmountBlock}>
                          <Text
                            style={[styles.savedHeroBarAmount, { color: goldPalette.text }]}
                            numberOfLines={1}
                          >
                            {day.amountValueLabel}
                            {day.amountCurrencySymbol ? (
                              <Text
                                style={[styles.savedHeroBarCurrency, { color: goldPalette.text }]}
                              >
                                {"\u00A0"}
                                {day.amountCurrencySymbol}
                              </Text>
                            ) : null}
                          </Text>
                        </View>
                      ) : null}
                      {day.spendValueLabel ? (
                        <View style={styles.savedHeroBarAmountBlock}>
                          <Text
                            style={[
                              styles.savedHeroBarSpend,
                              { color: day.amountUSD ? goldPalette.subtext : goldPalette.danger },
                            ]}
                            numberOfLines={1}
                          >
                            {day.spendValueLabel}
                            {day.spendCurrencySymbol ? (
                              <Text
                                style={[
                                  styles.savedHeroBarCurrency,
                                  { color: day.amountUSD ? goldPalette.subtext : goldPalette.danger },
                                ]}
                              >
                                {"\u00A0"}
                                {day.spendCurrencySymbol}
                              </Text>
                            ) : null}
                          </Text>
                        </View>
                      ) : null}
                    </View>
                    <View style={styles.savedHeroBarTrack}>
                      <View
                        style={[
                          styles.savedHeroBarColumn,
                          {
                            height: `${day.percent}%`,
                            backgroundColor: goldPalette.accent,
                          },
                        ]}
                      />
                      {day.spendPercent > 0 ? (
                        <View
                          style={[
                            styles.savedHeroBarColumnSpend,
                            {
                              height: `${day.spendPercent}%`,
                              backgroundColor: goldPalette.danger,
                              opacity: day.spendOverflow ? 0.95 : 0.8,
                            },
                          ]}
                        />
                      ) : null}
                    </View>
                    <Text style={[styles.savedHeroBarLabel, { color: goldPalette.subtext }]}>
                      {day.label}
                    </Text>
                  </View>
                ))}
              </View>
            ) : (
              <Text style={[styles.savedHeroDailyEmpty, { color: goldPalette.subtext }]}>
                {t("heroDailyEmpty")}
              </Text>
            )}
            {analyticsPreview.length > 0 && (
              <View style={styles.savedHeroStatsRow}>
                {analyticsPreview.map((stat) => (
                  <View
                    key={stat.label}
                    style={[
                      styles.savedHeroStatsItem,
                      { backgroundColor: goldPalette.background, borderColor: goldPalette.border },
                    ]}
                  >
                    <Text style={[styles.savedHeroStatsValue, { color: goldPalette.text }]}>
                      {stat.value}
                    </Text>
                    <Text style={[styles.savedHeroStatsLabel, { color: goldPalette.subtext }]}>
                      {stat.label}
                    </Text>
                  </View>
                ))}
              </View>
            )}
          </View>
        </TouchableOpacity>
      )}
      </View>
    </View>
  );
}

function FreeDayCard({
  colors,
  t,
  canLog,
  onLog,
  freeDayStats = INITIAL_FREE_DAY_STATS,
  todayKey,
  weekDays = [],
  weekCount = 0,
  canRescue = false,
  needsRescue = false,
  rescueStatus = null,
  rescueCost = FREE_DAY_RESCUE_COST,
  onRescue = () => {},
  hasRescueHealth = false,
}) {
  const [expanded, setExpanded] = useState(false);
  const streakActive = (freeDayStats.current || 0) > 0;
  const blockedToday = freeDayStats.blockedDate === todayKey;
  const palette = streakActive
    ? {
        background: "#E6F8EE",
        border: "#A8E5C5",
        accent: "#105B31",
      }
    : {
        background: colors.card,
        border: colors.border,
        accent: colors.text,
      };
  const buttonColor = streakActive ? palette.accent : "#20A36B";
  const statusLabel = canLog
    ? t("freeDayStatusAvailable")
    : freeDayStats.lastDate === todayKey
    ? t("freeDayStatusLogged")
    : blockedToday
    ? t("freeDayBlocked")
    : t("freeDayLocked");
  const stats = [
    { label: t("freeDayCurrentLabel"), value: `${freeDayStats.current || 0}` },
    { label: t("freeDayBestLabel"), value: `${freeDayStats.best || 0}` },
    { label: t("freeDayTotalShort"), value: `${freeDayStats.total || 0}` },
  ];
  const showRescueStatusAction = needsRescue && !canLog;
  const rescuePillDisabled = !hasRescueHealth;
  const rescuePillColor = "#FFD75E";
  const rescuePillTextColor = "#3C2A00";
  return (
    <View
      style={[
        styles.freeDayCard,
        {
          backgroundColor: palette.background,
          borderColor: palette.border,
        },
      ]}
    >
      <View style={styles.freeDayHeader}>
        <View style={styles.freeDayTitleBlock}>
          <Text style={[styles.freeDayLabel, { color: colors.text }]}>{t("freeDayCardTitle")}</Text>
        </View>
        {showRescueStatusAction ? (
          <TouchableOpacity
            style={[
              styles.freeDayStatusPill,
              { backgroundColor: rescuePillColor, borderColor: rescuePillColor },
              rescuePillDisabled && styles.freeDayStatusPillDisabled,
            ]}
            onPress={onRescue}
            disabled={rescuePillDisabled}
            activeOpacity={0.85}
          >
            <Text style={[styles.freeDayStatusText, { color: rescuePillTextColor }]}>
              {t("freeDayRescuePillLabel", { count: "1" })}
            </Text>
            {BLUE_HEALTH_COIN_ASSET ? (
              <Image source={BLUE_HEALTH_COIN_ASSET} style={styles.freeDayStatusCoin} />
            ) : null}
          </TouchableOpacity>
        ) : canLog ? (
          <TouchableOpacity
            style={[
              styles.freeDayStatusPill,
              { backgroundColor: buttonColor, borderColor: buttonColor },
            ]}
            onPress={onLog}
            activeOpacity={0.85}
          >
            <Text style={[styles.freeDayStatusText, { color: "#fff" }]}>{statusLabel}</Text>
          </TouchableOpacity>
        ) : (
          <View
            style={[
              styles.freeDayStatusPill,
              {
                borderColor: colors.border,
                backgroundColor: colors.background,
              },
            ]}
          >
            <Text style={[styles.freeDayStatusText, { color: colors.muted }]}>{statusLabel}</Text>
          </View>
        )}
      </View>
      <View style={styles.freeDaySummaryRow}>
        <View style={styles.freeDayChip}>
          <Text style={[styles.freeDayChipText, { color: palette.accent }]}>
            {t("freeDayWeekTitle")} ¬∑ {weekCount}/7
          </Text>
        </View>
        <TouchableOpacity style={styles.freeDayToggle} onPress={() => setExpanded((prev) => !prev)}>
          <Text style={[styles.freeDayToggleText, { color: colors.muted }]}>
            {expanded ? t("freeDayCollapse") : t("freeDayExpand")}
          </Text>
        </TouchableOpacity>
      </View>
      {needsRescue && (
        <View
          style={[
            styles.freeDayRescueBanner,
            { borderColor: colors.border, backgroundColor: colors.background },
          ]}
        >
          <View style={{ flex: 1 }}>
            <Text style={[styles.freeDayRescueTitle, { color: colors.text }]}>
              {t("freeDayRescueTitle")}
            </Text>
            <Text style={[styles.freeDayRescueSubtitle, { color: colors.muted }]}>
              {canRescue
                ? t("freeDayRescueSubtitle", { cost: rescueCost })
                : rescueStatus || t("freeDayRescueSubtitle", { cost: rescueCost })}
            </Text>
          </View>
          <TouchableOpacity
            style={[
              styles.freeDayRescueButton,
              { backgroundColor: palette.accent },
              !canRescue && styles.freeDayRescueButtonDisabled,
            ]}
            onPress={onRescue}
            disabled={!canRescue}
          >
            <Text
              style={[
                styles.freeDayRescueButtonText,
                !canRescue && { color: palette.accent, opacity: 0.6 },
              ]}
            >
              {t("freeDayRescueButton")}
            </Text>
          </TouchableOpacity>
        </View>
      )}
      {expanded && (
        <>
          <View style={styles.freeDayStatsRow}>
            {stats.map((stat) => (
              <View key={stat.label} style={styles.freeDayStat}>
                <Text style={[styles.freeDayStatLabel, { color: colors.muted }]}>{stat.label}</Text>
                <Text style={[styles.freeDayStatValue, { color: palette.accent }]}>
                  {stat.value}
                </Text>
              </View>
            ))}
          </View>
          <View
            style={[
              styles.freeDayCalendar,
              { backgroundColor: streakActive ? "rgba(255,255,255,0.4)" : colors.card },
            ]}
          >
            <View style={styles.freeDayCalendarHeader}>
              <Text style={[styles.freeDayCalendarTitle, { color: colors.muted }]}>
                {t("freeDayWeekTitle")}
              </Text>
              <Text style={[styles.freeDayCalendarTitle, { color: colors.muted }]}>
                {weekCount}/7
              </Text>
            </View>
            <View style={styles.freeDayCalendarDays}>
              {weekDays.map((day) => (
                <View key={day.key} style={styles.freeDayCalendarDay}>
                  <Text style={[styles.freeDayCalendarLabel, { color: colors.muted }]}>
                    {day.label}
                  </Text>
                  <View
                    style={[
                      styles.freeDayCalendarDot,
                      day.active && styles.freeDayCalendarDotActive,
                      day.isToday && styles.freeDayCalendarDotToday,
                    ]}
                  />
                </View>
              ))}
            </View>
          </View>
        </>
      )}
    </View>
  );
}

function SpendConfirmSheet({
  visible,
  item,
  currency = DEFAULT_PROFILE.currency,
  language = DEFAULT_LANGUAGE,
  onCancel,
  onConfirm,
  colors,
  t,
}) {
  const priceLabel = item
    ? formatTemptationPriceLabel(item, currency)
    : formatCurrency(0, currency, { friendly: true });
  const displayTitle =
    item?.title?.[language] || item?.title?.en || item?.title || t("defaultDealTitle");
  return (
    <Modal visible={visible} transparent animationType="fade" statusBarTranslucent>
      <View style={styles.payBackdrop}>
        <TouchableWithoutFeedback onPress={onCancel}>
          <View style={styles.payBackdropHit} />
        </TouchableWithoutFeedback>
        <View style={[styles.paySheet, { backgroundColor: colors.card }] }>
          <View style={styles.paySheetHandle} />
          <Text style={[styles.payBrand, { color: colors.text }]}>{t("spendSheetTitle")}</Text>
          <View style={[styles.payCard, { backgroundColor: colors.background }]}>
            <View style={styles.payCardIcon}>
              <Text style={styles.payCardEmoji}>{item?.emoji || "üí≥"}</Text>
            </View>
            <View style={styles.payCardTexts}>
              <Text style={[styles.payCardTitle, { color: colors.text }]}>{displayTitle}</Text>
            </View>
            <Text style={[styles.payCardAmount, { color: colors.text }]}>{priceLabel}</Text>
          </View>
          <Text style={[styles.paySheetSubtitle, { color: colors.muted }]}>
            {t("spendSheetSubtitle")}
          </Text>
          <View style={styles.paySheetHintRow}>
            <View style={styles.paySheetHintDot} />
            <Text style={[styles.paySheetHint, { color: colors.muted }]}>{t("spendSheetHint")}</Text>
          </View>
          <TouchableOpacity style={[styles.payConfirm, { backgroundColor: colors.text }]} onPress={onConfirm}>
            <Text style={[styles.payConfirmText, { color: colors.background }]}>
              {t("spendSheetConfirm")}
            </Text>
          </TouchableOpacity>
          <TouchableOpacity style={styles.payCancel} onPress={onCancel}>
            <Text style={[styles.payCancelText, { color: colors.muted }]}>{t("spendSheetCancel")}</Text>
          </TouchableOpacity>
        </View>
      </View>
    </Modal>
  );
}

function StormOverlay({ t }) {
  const flash = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    const loop = Animated.loop(
      Animated.sequence([
        Animated.delay(600),
        Animated.timing(flash, { toValue: 0.75, duration: 120, useNativeDriver: true }),
        Animated.timing(flash, { toValue: 0, duration: 320, useNativeDriver: true }),
        Animated.delay(700),
      ])
    );
    loop.start();
    return () => loop.stop();
  }, [flash]);

  return (
    <View style={styles.stormOverlay} pointerEvents="auto">
      <RainOverlay colors={{ muted: "rgba(173,196,255,0.5)" }} />
      <Animated.View style={[styles.stormFlash, { opacity: flash }]} />
      <View style={styles.stormMessageWrap}>
        <Text style={styles.stormMessage}>{t("stormOverlayMessage")}</Text>
      </View>
    </View>
  );
}

const hasImpulseHistory = (insights) => {
  if (!insights?.categories) return false;
  if ((insights.eventCount || 0) < MIN_IMPULSE_EVENTS_FOR_MAP) return false;
  return IMPULSE_CATEGORY_ORDER.some((id) => {
    const entry = insights.categories[id];
    return (entry?.save || 0) + (entry?.spend || 0) > 0;
  });
};

function ImpulseMapCard({ insights, colors, t, language, expanded = false, onToggle }) {
  if (!insights) return null;
  const fallbackTime = t("impulseAnytimeLabel");
  const loseText = insights.hotLose
    ? t("impulseLoseCopy", {
        temptation: insights.hotLose.title,
        time: insights.hotLose.windowLabel || fallbackTime,
      })
    : t("impulseLoseEmpty");
  const winText = insights.hotWin
    ? t("impulseWinCopy", {
        temptation: insights.hotWin.title,
        time: insights.hotWin.windowLabel || fallbackTime,
      })
    : t("impulseWinEmpty");
  const trendText =
    insights.hottestCategory && insights.hottestCategory.delta > 0
      ? t("impulseTrendLabel", {
          category: getImpulseCategoryLabel(insights.hottestCategory.id, language),
        })
      : null;
  const isDarkMode = colors.background === THEMES.dark.background;
  const dangerBg = isDarkMode ? "rgba(255,108,108,0.25)" : "#FFE5E5";
  const dangerBorder = isDarkMode ? "rgba(255,108,108,0.5)" : "rgba(255,108,108,0.45)";
  const successBg = isDarkMode ? "rgba(33,209,160,0.22)" : "#E5F8EE";
  const successBorder = isDarkMode ? "rgba(33,209,160,0.45)" : "rgba(33,209,160,0.4)";
  const neutralBg = isDarkMode ? "rgba(250,204,21,0.22)" : "#FFF4D5";
  const neutralBorder = isDarkMode ? "rgba(250,204,21,0.4)" : "rgba(250,204,21,0.45)";
  const toggleLabel = expanded ? t("impulseCollapse") : t("impulseExpand");
  const categories = IMPULSE_CATEGORY_ORDER.map((id) => {
    const entry = insights.categories?.[id] || { save: 0, spend: 0 };
    return {
      id,
      label: getImpulseCategoryLabel(id, language),
      save: entry.save || 0,
      spend: entry.spend || 0,
    };
  });
  return (
    <View style={[styles.impulseCard, { backgroundColor: colors.card, borderColor: colors.border }]}>
      <View style={styles.impulseHeaderRow}>
        <View style={styles.impulseHeader}>
          <Text style={[styles.impulseCardTitle, { color: colors.text }]}>{t("impulseCardTitle")}</Text>
          <Text style={[styles.impulseCardSubtitle, { color: colors.muted }]}>
            {t("impulseCardSubtitle")}
          </Text>
        </View>
        <TouchableOpacity
          onPress={onToggle}
          style={[
            styles.impulseToggle,
            { borderColor: colors.border, backgroundColor: lightenColor(colors.card, isDarkMode ? 0.1 : 0.25) },
          ]}
        >
          <Text style={[styles.impulseToggleText, { color: colors.text }]}>{toggleLabel}</Text>
        </TouchableOpacity>
      </View>
      <View style={styles.impulseSummaryGrid}>
        <View
          style={[
            styles.impulseBadge,
            { backgroundColor: dangerBg, borderColor: dangerBorder },
          ]}
        >
          <Text style={[styles.impulseSummaryLabel, { color: colors.text }]}>{t("impulseLoseLabel")}</Text>
          <Text style={[styles.impulseSummaryValue, { color: colors.text }]}>{loseText}</Text>
        </View>
        <View
          style={[
            styles.impulseBadge,
            { backgroundColor: successBg, borderColor: successBorder },
          ]}
        >
          <Text style={[styles.impulseSummaryLabel, { color: colors.text }]}>{t("impulseWinLabel")}</Text>
          <Text style={[styles.impulseSummaryValue, { color: colors.text }]}>{winText}</Text>
        </View>
      </View>
      {expanded && (
        <>
          {trendText ? (
            <View
              style={[
                styles.impulseTrendRow,
                { backgroundColor: neutralBg, borderColor: neutralBorder },
              ]}
            >
              <Text style={[styles.impulseTrendText, { color: colors.text }]}>{trendText}</Text>
            </View>
          ) : null}
          <View style={styles.impulseCategoryList}>
            {categories.map((category) => {
              const hasData = (category.save || 0) + (category.spend || 0) > 0;
              const isRisk = hasData && category.spend > category.save;
              const isWin = hasData && category.save > category.spend;
              let categoryBg = colors.card;
              let categoryBorder = colors.border;
              if (isRisk) {
                categoryBg = dangerBg;
                categoryBorder = dangerBorder;
              } else if (isWin) {
                categoryBg = successBg;
                categoryBorder = successBorder;
              }
              return (
                <View
                  key={category.id}
                  style={[
                    styles.impulseCategoryRow,
                    {
                      borderColor: categoryBorder,
                      backgroundColor: categoryBg,
                    },
                  ]}
                >
                  <Text style={[styles.impulseCategoryLabel, { color: colors.text }]}>
                    {category.label}
                  </Text>
                  <View style={styles.impulseCategoryStats}>
                    <Text style={[styles.impulseCategoryStat, { color: colors.text }]}>
                      {t("impulseCategorySave", { count: category.save })}
                    </Text>
                    <Text style={[styles.impulseCategoryStatSecondary, { color: colors.muted }]}>
                      {t("impulseCategorySpend", { count: category.spend })}
                    </Text>
                  </View>
                </View>
              );
            })}
          </View>
        </>
      )}
    </View>
  );
}

const FeedScreen = React.memo(function FeedScreen({
  products,
  categories,
  activeCategory,
  onCategorySelect,
  savedTotalUSD,
  wishes = [],
  onTemptationAction,
  onTemptationEditToggle,
  onTemptationQuickGoalToggle,
  t,
  language,
  colors,
  currency,
  freeDayStats,
  onFreeDayLog,
  healthPoints = 0,
  onFreeDayRescue,
  freeDayRescueCost = FREE_DAY_RESCUE_COST,
  analyticsStats = [],
  refuseStats = {},
  cardFeedback = {},
  historyEvents = [],
  profile,
  titleOverrides = {},
  descriptionOverrides = {},
  onLevelCelebrate,
  onBaselineSetup,
  goalAssignments = {},
  impulseInsights = null,
  moodPreset = null,
  onMoodDetailsOpen = () => {},
  onPotentialDetailsOpen = null,
  heroGoalTargetUSD = 0,
  heroGoalSavedUSD = 0,
  editingTemptationId = null,
  editingTitleValue = "",
  editingPriceValue = "",
  editingGoalLabel = "",
  editingEmojiValue = "",
  editingDescriptionValue = "",
  editingCategoryValue = DEFAULT_IMPULSE_CATEGORY,
  onTemptationEditTitleChange,
  onTemptationEditPriceChange,
  onTemptationEditEmojiChange,
  onTemptationEditDescriptionChange,
  onTemptationEditCategoryChange,
  onTemptationEditSave,
  onTemptationEditCancel,
  onTemptationEditDelete,
  onTemptationGoalSelect,
  onTemptationSwipeDelete,
  onSavingsBreakdownPress = () => {},
  mascotOverride = null,
  onMascotAnimationComplete = () => {},
  hideMascot = false,
  onMascotPress = () => {},
  resolveTemplateTitle = () => null,
  tamagotchiMood = null,
  tamagotchiDesiredFood = null,
  primaryTemptationId = null,
  primaryTemptationDescription = "",
  focusTemplateId = null,
  tamagotchiAnimations = CLASSIC_TAMAGOTCHI_ANIMATIONS,
  lifetimeSavedUSD = 0,
  interactionStats = {},
}) {
  const resolvedHistoryEvents = Array.isArray(historyEvents) ? historyEvents : [];
  const [impulseExpanded, setImpulseExpanded] = useState(false);
  const handleBaselineSetup = onBaselineSetup || (() => {});
  const realSavedUSD = useRealSavedAmount();
  const totalSavedLabel = useMemo(
    () => formatCurrency(convertToCurrency(realSavedUSD || 0, currency), currency),
    [realSavedUSD, currency]
  );
  const heroGoalSavedLabel = useMemo(
    () => formatCurrency(convertToCurrency(heroGoalSavedUSD || 0, currency), currency),
    [heroGoalSavedUSD, currency]
  );
  const heroTargetLabel = useMemo(
    () => formatCurrency(convertToCurrency(heroGoalTargetUSD || 0, currency), currency),
    [heroGoalTargetUSD, currency]
  );
  const isGoalComplete = heroGoalTargetUSD > 0 && heroGoalSavedUSD >= heroGoalTargetUSD;
  const goalProgress = heroGoalTargetUSD > 0 ? heroGoalSavedUSD / heroGoalTargetUSD : 0;
  const remainingLocal = formatCurrency(
    convertToCurrency(Math.max(heroGoalTargetUSD - heroGoalSavedUSD, 0), currency),
    currency
  );
  const goalProgressLabel = heroGoalTargetUSD
    ? t("progressGoal", { current: heroGoalSavedLabel, goal: heroTargetLabel })
    : t("progressGoal", { current: heroGoalSavedLabel, goal: heroGoalSavedLabel });
  const personaPreset = useMemo(() => getPersonaPreset(profile?.persona), [profile?.persona]);
  const recentActivity = useMemo(() => {
    const filtered = resolvedHistoryEvents.filter(
      (entry) => entry.kind === "refuse_spend" || entry.kind === "spend"
    );
    filtered.sort((a, b) => {
      const aTime = Number(a?.timestamp) || 0;
      const bTime = Number(b?.timestamp) || 0;
      return bTime - aTime;
    });
    return filtered.slice(0, 3);
  }, [resolvedHistoryEvents]);
  const heroRecentEvents = useMemo(
    () =>
      recentActivity.map((entry) => {
        const resolvedTitle =
          resolveTemplateTitle(entry?.meta?.templateId, entry?.meta?.title) ||
          entry?.title ||
          t("defaultDealTitle");
        const timestampLabel = formatLatestSavingTimestamp(entry?.timestamp, language);
        const isSpend = entry.kind === "spend";
        const prefix = isSpend ? "- " : "";
        return {
          id: entry.id,
          label: `${prefix}${resolvedTitle}${timestampLabel ? ` ¬∑ ${timestampLabel}` : ""}`,
          isSpend,
        };
      }),
    [language, recentActivity, resolveTemplateTitle, t]
  );
  const heroSpendCopy = useMemo(() => {
    if (heroRecentEvents.length > 0) {
      return "";
    }
    if (!realSavedUSD || realSavedUSD <= 0) {
      return t("heroSpendFallback");
    }
    const template = personaPreset?.tagline?.[language];
    if (template) {
      return template.replace("{{amount}}", totalSavedLabel);
    }
    return t("heroSpendFallback");
  }, [heroRecentEvents.length, language, personaPreset, realSavedUSD, t, totalSavedLabel]);
  const heroEncouragementLine = useMemo(() => {
    const heroLine = isGoalComplete
      ? moodPreset?.heroComplete || t("goalWidgetCompleteTagline")
      : moodPreset?.hero || t("heroEconomyContinues");
    if (moodPreset?.motivation) {
      return `${heroLine} ${moodPreset.motivation}`;
    }
    return heroLine;
  }, [isGoalComplete, moodPreset, t]);
  const isDarkMode = colors === THEMES.dark;
  const moodGradient = useMemo(
    () => applyThemeToMoodGradient(getMoodGradient(moodPreset?.id), isDarkMode ? "dark" : "light"),
    [moodPreset?.id, isDarkMode]
  );
  const mainTemptationId = primaryTemptationId;
  const goldPalette = useMemo(
    () =>
      isGoalComplete
        ? isDarkMode
          ? {
              background: "#07281C",
              border: "rgba(134,255,192,0.4)",
              glow: "rgba(46,182,125,0.35)",
              accent: "#7BFFB8",
              text: "#E9FFF5",
              subtext: "rgba(233,255,245,0.8)",
              badgeBg: "rgba(0,0,0,0.45)",
              badgeBorder: "rgba(123,255,184,0.5)",
              badgeText: "#9FFFCF",
              barBg: "rgba(0,0,0,0.3)",
              shadow: "#032015",
              danger: "#FF9C9C",
            }
          : {
              background: "#E7FFE8",
              border: "rgba(107,201,128,0.7)",
              glow: "rgba(185,255,210,0.6)",
              accent: "#1C8F4A",
              text: "#064321",
              subtext: "rgba(6,67,33,0.75)",
              badgeBg: "rgba(255,255,255,0.92)",
              badgeBorder: "rgba(6,67,33,0.12)",
              badgeText: "#0E5B30",
              barBg: "rgba(255,255,255,0.65)",
              shadow: "#B2F8C3",
              danger: "#D63B3B",
            }
        : isDarkMode
        ? {
            background: "#2B1A00",
            border: "rgba(255,214,143,0.5)",
            glow: "rgba(255,184,0,0.25)",
            accent: "#FFCF6B",
            text: "#FFEED0",
            subtext: "rgba(255,238,208,0.8)",
            badgeBg: "rgba(0,0,0,0.35)",
            badgeBorder: "rgba(255,223,165,0.5)",
            badgeText: "#FFEED0",
            barBg: "rgba(0,0,0,0.3)",
            shadow: "#1B1100",
            danger: "#FF8F8F",
          }
        : {
            background: "#FFF6D5",
            border: "rgba(240,196,92,0.8)",
            glow: "rgba(255,255,255,0.8)",
            accent: "#D8960B",
            text: "#5C3300",
            subtext: "rgba(92,51,0,0.75)",
            badgeBg: "rgba(255,255,255,0.75)",
            badgeBorder: "rgba(255,255,255,0.9)",
            badgeText: "#7A4A00",
            barBg: "rgba(255,255,255,0.6)",
            shadow: "#F3C75A",
            danger: "#D63B3B",
          },
    [isDarkMode, isGoalComplete]
  );
  const heroMoodBadgeStyle = useMemo(
    () =>
      isDarkMode
        ? { backgroundColor: "rgba(0,0,0,0.45)", borderWidth: 1, borderColor: "rgba(255,255,255,0.15)" }
        : null,
    [isDarkMode]
  );
  const heroMoodBadgeTextColor = isDarkMode ? colors.text : moodGradient.accent;
  const heroMascotWrapStyle = useMemo(
    () =>
      isDarkMode
        ? { backgroundColor: "rgba(0,0,0,0.3)", borderColor: "rgba(255,255,255,0.12)" }
        : null,
    [isDarkMode]
  );
  const showTamagotchiBubble = tamagotchiMood?.tone === "urgent";
  const tamagotchiBubbleTheme = useMemo(
    () =>
      isDarkMode
        ? {
            backgroundColor: "rgba(5,7,15,0.92)",
            borderColor: "rgba(255,255,255,0.25)",
            textColor: "#F7F9FF",
            shadowColor: "rgba(0,0,0,0.6)",
          }
        : {
            backgroundColor: "rgba(255,255,255,0.96)",
            borderColor: "rgba(28,26,42,0.12)",
            textColor: "#1C1A2A",
            shadowColor: "rgba(218,171,86,0.35)",
          },
    [isDarkMode]
  );
  const levelProgressUSD = Math.max(savedTotalUSD || 0, lifetimeSavedUSD || 0);
  const heroLevelCurrency = profile?.currency || DEFAULT_PROFILE.currency;
  const tierInfo = getTierProgress(levelProgressUSD || 0, heroLevelCurrency);
  const span = Math.max(
    (tierInfo.nextTargetUSD ?? tierInfo.prevTargetUSD ?? 1) -
      (tierInfo.prevTargetUSD ?? 0),
    1
  );
  const previousTierInfo = useRef(tierInfo.level);
  const tierProgress = tierInfo.nextTargetUSD
    ? (levelProgressUSD - tierInfo.prevTargetUSD) / span
    : 1;
  const heroLevelHasNext = !!tierInfo.nextTargetUSD;
  const heroLevelRemainingUSD = heroLevelHasNext
    ? Math.max(tierInfo.nextTargetUSD - levelProgressUSD, 0)
    : 0;
  const heroLevelRemainingLabel = heroLevelHasNext
    ? formatCurrency(convertToCurrency(heroLevelRemainingUSD, heroLevelCurrency), heroLevelCurrency)
    : "";
  const heroLevelTargetLabel = heroLevelHasNext
    ? formatCurrency(convertToCurrency(tierInfo.nextTargetUSD, heroLevelCurrency), heroLevelCurrency, {
        friendly: true,
      })
    : "";
  const heroLevelProgress = Math.min(Math.max(tierProgress, 0), 1);
  const previousSavedTotal = useRef(savedTotalUSD);
  useEffect(() => {
    if (savedTotalUSD > previousSavedTotal.current) {
      logEvent("savings_updated", {
        saved_usd_total: savedTotalUSD,
        tier_level: tierInfo.level,
        next_tier_usd: tierInfo.nextTargetUSD || null,
        profile_goal: profile.goal || "none",
      });
    }
    previousSavedTotal.current = savedTotalUSD;
  }, [savedTotalUSD, tierInfo.level, tierInfo.nextTargetUSD, profile.goal]);
  useEffect(() => {
    if (tierInfo.level > previousTierInfo.current) {
      const levelsEarned = tierInfo.level - previousTierInfo.current;
      logEvent("savings_level_up", {
        level: tierInfo.level,
        saved_usd_total: savedTotalUSD,
      });
      onLevelCelebrate?.(tierInfo.level, levelsEarned);
    }
    previousTierInfo.current = tierInfo.level;
  }, [tierInfo.level, onLevelCelebrate, savedTotalUSD]);
  const progressPercent = Math.min(Math.max(goalProgress, 0), 1);
  const progressPercentLabel = Math.round(progressPercent * 100);
  const levelLabel = t("progressHeroLevel", { level: tierInfo.level });
  const levelCurrency = profile?.currency || DEFAULT_PROFILE.currency;
  const levelProgress = Math.min(Math.max(tierProgress, 0), 1);
  const levelRemainingUSD = tierInfo.nextTargetUSD
    ? Math.max(tierInfo.nextTargetUSD - levelProgressUSD, 0)
    : 0;
  const levelRemainingLabel = formatCurrency(
    convertToCurrency(levelRemainingUSD, levelCurrency),
    levelCurrency
  );
  const levelTargetLabel = tierInfo.nextTargetUSD
    ? formatCurrency(convertToCurrency(tierInfo.nextTargetUSD, levelCurrency), levelCurrency, {
        friendly: true,
      })
    : "";
  const todayDate = new Date();
  const todayTimestamp = todayDate.getTime();
  const todayKey = getDayKey(todayDate);
  const dayBeforeYesterdayKey = getDayKey(new Date(todayDate.getTime() - DAY_MS * 2));
  const freeDayBlockedToday = freeDayStats.blockedDate === todayKey;
  const isEvening = new Date().getHours() >= 18;
  const canLogFreeDay = isEvening && freeDayStats.lastDate !== todayKey && !freeDayBlockedToday;
  const streakNeedsRescue =
    freeDayStats.current > 0 &&
    freeDayStats.lastDate === dayBeforeYesterdayKey &&
    freeDayStats.lastDate !== todayKey;
  const hasRescueHealth = healthPoints >= freeDayRescueCost;
  const canRescueFreeDay = streakNeedsRescue && hasRescueHealth;
  const rescueStatus = !streakNeedsRescue
    ? null
    : !hasRescueHealth
    ? t("freeDayRescueNeedHealth", { cost: freeDayRescueCost })
    : null;
  const potentialSavedUSD = useSavingsSimulation(
    profile?.spendingProfile?.baselineMonthlyWasteUSD || 0,
    profile?.spendingProfile?.baselineStartAt || null
  );
  const hasBaseline = !!(
    profile?.spendingProfile?.baselineMonthlyWasteUSD && profile?.spendingProfile?.baselineStartAt
  );
  const potentialDescription = useMemo(() => {
    const currencyCode = profile?.currency || DEFAULT_PROFILE.currency;
    const formatLocal = (valueUSD = 0) =>
      formatCurrency(convertToCurrency(Math.max(valueUSD, 0), currencyCode), currencyCode);
    const potentialLocal = formatLocal(potentialSavedUSD);
    const actualLocal = formatLocal(realSavedUSD);
    const deltaLocal = formatLocal(Math.max(potentialSavedUSD - realSavedUSD, 0));
    return t("potentialBlockDetails", {
      potential: potentialLocal,
      actual: actualLocal,
      delta: deltaLocal,
    });
  }, [profile?.currency, potentialSavedUSD, realSavedUSD, t]);
  const handlePotentialDetailsOpen = useCallback(() => {
    if (typeof onPotentialDetailsOpen === "function") {
      onPotentialDetailsOpen(potentialDescription);
    }
  }, [onPotentialDetailsOpen, potentialDescription]);

  const orderedProducts = useMemo(() => {
    const entries = Array.isArray(products) ? [...products] : [];
    if (!entries.length) return entries;
    let primaryCard = null;
    if (mainTemptationId) {
      const primaryIndex = entries.findIndex((item) => item.id === mainTemptationId);
      if (primaryIndex >= 0) {
        primaryCard = entries.splice(primaryIndex, 1)[0];
      }
    }
    const sortedEntries = entries
      .sort((a, b) => {
        const priceDiff = getTemptationPrice(a) - getTemptationPrice(b);
        if (priceDiff !== 0) {
          return priceDiff;
        }
        return (a.id || "").localeCompare(b.id || "");
      })
      .map((item, index) => ({ item, baseIndex: index }));
    const statsMap = interactionStats || {};
    const frequentEntries = sortedEntries
      .map((entry) => {
        const stats = statsMap[entry.item.id];
        if (!stats) return null;
        const total = (stats.saveCount || 0) + (stats.spendCount || 0);
        if (!total) return null;
        return {
          ...entry,
          total,
          lastInteractionAt: stats.lastInteractionAt || 0,
        };
      })
      .filter(Boolean)
      .sort((a, b) => {
        if (b.total !== a.total) return b.total - a.total;
        if (b.lastInteractionAt !== a.lastInteractionAt) {
          return (b.lastInteractionAt || 0) - (a.lastInteractionAt || 0);
        }
        return a.baseIndex - b.baseIndex;
      })
      .slice(0, FEED_FREQUENT_PIN_LIMIT);
    const pinnedIds = new Set(frequentEntries.map((entry) => entry.item.id));
    const ordered = [];
    if (primaryCard) {
      ordered.push(primaryCard);
    }
    frequentEntries.forEach((entry) => ordered.push(entry.item));
    sortedEntries
      .filter((entry) => !pinnedIds.has(entry.item.id))
      .forEach((entry) => ordered.push(entry.item));
    return ordered;
  }, [products, mainTemptationId, interactionStats]);

  const filteredProducts = useMemo(() => {
    if (activeCategory === "all") return orderedProducts;
    return orderedProducts.filter((product) => product.categories?.includes(activeCategory));
  }, [activeCategory, orderedProducts]);
  const feedKeyExtractor = useCallback((item) => item.id, []);
  const renderTemptationItem = useCallback(
    ({ item }) => {
      const assignedGoalId = goalAssignments?.[item.id];
      const assignedGoal = assignedGoalId ? wishesById[assignedGoalId] : null;
      const wishlistEntry = swipePinnedByTemplate[item.id];
      const isWishlistGoal = !!wishlistEntry;
      const overrideDescription =
        (descriptionOverrides && descriptionOverrides[item.id]) || null;
      const resolvedDescriptionOverride =
        overrideDescription ||
        (item.id === mainTemptationId ? primaryTemptationDescription : null);
      return (
        <TemptationCard
          item={item}
          language={language}
          colors={colors}
          t={t}
          descriptionOverride={resolvedDescriptionOverride}
          isFocusTarget={item.id === focusTemplateId}
          onToggleEdit={() => onTemptationEditToggle?.(item)}
          currency={currency}
          stats={refuseStats[item.id]}
          feedback={cardFeedback[item.id]}
          titleOverride={titleOverrides[item.id]}
          goalLabel={assignedGoal ? getWishTitleWithoutEmoji(assignedGoal) : null}
          isWishlistGoal={isWishlistGoal}
          isEditing={editingTemptationId === item.id}
          editTitleValue={editingTemptationId === item.id ? editingTitleValue : ""}
          editPriceValue={editingTemptationId === item.id ? editingPriceValue : ""}
          editGoalLabel={editingTemptationId === item.id ? editingGoalLabel : ""}
          editEmojiValue={editingTemptationId === item.id ? editingEmojiValue : ""}
          editDescriptionValue={editingTemptationId === item.id ? editingDescriptionValue : ""}
          editCategoryValue={
            editingTemptationId === item.id ? editingCategoryValue : DEFAULT_IMPULSE_CATEGORY
          }
          onEditTitleChange={onTemptationEditTitleChange}
          onEditPriceChange={onTemptationEditPriceChange}
          onEditEmojiChange={onTemptationEditEmojiChange}
          onEditDescriptionChange={onTemptationEditDescriptionChange}
          onEditCategoryChange={onTemptationEditCategoryChange}
          onEditSave={onTemptationEditSave}
          onEditCancel={onTemptationEditCancel}
          onEditDelete={() => onTemptationEditDelete?.(item)}
          onEditGoalSelect={() => onTemptationGoalSelect?.(item)}
          onSwipeDelete={() => onTemptationSwipeDelete?.(item)}
          onQuickGoalToggle={() => onTemptationQuickGoalToggle?.(item)}
          isPrimaryTemptation={item.id === mainTemptationId}
          onAction={async (type) => {
            await onTemptationAction(type, item);
          }}
        />
      );
    },
    [
      cardFeedback,
      colors,
      currency,
      descriptionOverrides,
      editingCategoryValue,
      editingDescriptionValue,
      editingEmojiValue,
      editingGoalLabel,
      editingPriceValue,
      editingTemptationId,
      editingTitleValue,
      focusTemplateId,
      goalAssignments,
      language,
      mainTemptationId,
      onTemptationAction,
      onTemptationEditCancel,
      onTemptationEditDelete,
      onTemptationEditDescriptionChange,
      onTemptationEditEmojiChange,
      onTemptationEditPriceChange,
      onTemptationEditSave,
      onTemptationEditTitleChange,
      onTemptationEditToggle,
      onTemptationGoalSelect,
      onTemptationQuickGoalToggle,
      onTemptationSwipeDelete,
      primaryTemptationDescription,
      refuseStats,
      swipePinnedByTemplate,
      t,
      titleOverrides,
      wishesById,
    ]
  );
  const freeDayEventKeys = useMemo(() => {
    const keys = new Set();
    resolvedHistoryEvents.forEach((entry) => {
      if (entry.kind === "free_day") {
        keys.add(getDayKey(entry.timestamp));
      }
    });
    return keys;
  }, [resolvedHistoryEvents]);
  const weekLabels = WEEKDAY_LABELS_MONDAY_FIRST[language] || WEEKDAY_LABELS_MONDAY_FIRST.en;
  const weekDays = useMemo(() => {
    const today = new Date(todayTimestamp);
    const start = new Date(today);
    const weekday = (today.getDay() + 6) % 7;
    start.setDate(today.getDate() - weekday);
    return Array.from({ length: 7 }).map((_, index) => {
      const date = new Date(start);
      date.setDate(start.getDate() + index);
      const key = getDayKey(date);
      return {
        key,
        label: weekLabels[index],
        active: freeDayEventKeys.has(key),
        isToday: key === todayKey,
      };
    });
  }, [freeDayEventKeys, todayTimestamp, todayKey, weekLabels]);
  const weekSuccessCount = useMemo(
    () => weekDays.filter((day) => day.active).length,
    [weekDays]
  );
  const weeklyComparison = useMemo(() => {
    const today = new Date(todayTimestamp);
    const currentStart = new Date(today);
    currentStart.setDate(today.getDate() - 6);
    const prevStart = new Date(currentStart);
    prevStart.setDate(currentStart.getDate() - 7);
    const currentRange = { start: currentStart.getTime(), end: today.getTime() };
    const prevRange = { start: prevStart.getTime(), end: currentStart.getTime() - 1 };
    let currentSavings = 0;
    let currentSpending = 0;
    let prevSavings = 0;
    let prevSpending = 0;
    resolvedHistoryEvents.forEach((entry) => {
      const timestamp = entry?.timestamp;
      if (!timestamp) return;
      const amount = Math.max(0, Number(entry?.meta?.amountUSD) || 0);
      if (!amount) return;
      if (timestamp >= currentRange.start && timestamp <= currentRange.end) {
        if (entry.kind === "refuse_spend") {
          currentSavings += amount;
        } else if (entry.kind === "spend") {
          currentSpending += amount;
        }
      } else if (timestamp >= prevRange.start && timestamp <= prevRange.end) {
        if (entry.kind === "refuse_spend") {
          prevSavings += amount;
        } else if (entry.kind === "spend") {
          prevSpending += amount;
        }
      }
    });
    const buildDelta = (current, previous) => {
      const deltaUSD = current - previous;
      const direction = deltaUSD >= 0 ? "up" : "down";
      return {
        deltaUSD,
        direction,
        previous,
      };
    };
    return {
      savings: buildDelta(currentSavings, prevSavings),
      spending: buildDelta(currentSpending, prevSpending),
      currentSavings,
      currentSpending,
    };
  }, [resolvedHistoryEvents, todayTimestamp]);
  const analyticsPreview = analyticsStats.slice(0, 3);
  const savingsDaily = useMemo(() => {
    const today = new Date(todayTimestamp);
    const start = new Date(today);
    start.setDate(today.getDate() - 6);
    const minTimestamp = start.getTime();
    const map = new Map();
    resolvedHistoryEvents.forEach((entry) => {
      if (!entry.timestamp || entry.timestamp < minTimestamp) return;
      if (entry.kind !== "refuse_spend" && entry.kind !== "spend") return;
      const amount = Math.max(0, Number(entry.meta?.amountUSD) || 0);
      if (!amount) return;
      const key = getDayKey(entry.timestamp);
      const current = map.get(key) || { saveUSD: 0, spendUSD: 0 };
      if (entry.kind === "refuse_spend") {
        current.saveUSD += amount;
      } else {
        current.spendUSD += amount;
      }
      map.set(key, current);
    });
    let maxSave = 0;
    const baseItems = Array.from({ length: 7 }).map((_, index) => {
      const date = new Date(start);
      date.setDate(start.getDate() + index);
      const key = getDayKey(date);
      const stats = map.get(key) || { saveUSD: 0, spendUSD: 0 };
      const saveUSD = stats.saveUSD || 0;
      const spendUSD = stats.spendUSD || 0;
      if (saveUSD > maxSave) maxSave = saveUSD;
      const weekdayIndex = (date.getDay() + 6) % 7;
      const label =
        WEEKDAY_LABELS_MONDAY_FIRST[language]?.[weekdayIndex] ||
        WEEKDAY_LABELS_MONDAY_FIRST.en[weekdayIndex];
      const saveLocal = convertToCurrency(saveUSD, currency);
      const spendLocal = convertToCurrency(spendUSD, currency);
      const amountLabel = saveUSD ? formatCurrency(saveLocal, currency) : "";
      const spendLabel = spendUSD ? `-${formatCurrency(spendLocal, currency)}` : "";
      const amountParts = splitCurrencyLabel(amountLabel, currency);
      const spendParts = splitCurrencyLabel(spendLabel, currency);
      const amountValueLabel =
        amountParts.value && typeof amountParts.value === "string"
          ? amountParts.value.replace(/ /g, "\u00A0")
          : amountParts.value;
      const spendValueLabel =
        spendParts.value && typeof spendParts.value === "string"
          ? spendParts.value.replace(/ /g, "\u00A0")
          : spendParts.value;
      return {
        key,
        label,
        amountUSD: saveUSD,
        saveUSD,
        spendUSD,
        amountLabel,
        amountValueLabel,
        amountCurrencySymbol: amountParts.symbol,
        spendLabel,
        spendValueLabel,
        spendCurrencySymbol: spendParts.symbol,
      };
    });
    const maxValue = Math.max(maxSave, 0.01);
    return baseItems.map((item) => {
      const percent = item.saveUSD > 0 ? Math.max((item.saveUSD / maxValue) * 100, 8) : 0;
      const spendPercent =
        item.saveUSD > 0 && item.spendUSD > 0
          ? Math.min(percent, Math.max((item.spendUSD / item.saveUSD) * percent, 2))
          : 0;
      return {
        ...item,
        percent,
        spendPercent,
        spendOverflow: item.spendUSD > item.saveUSD,
      };
    });
  }, [currency, resolvedHistoryEvents, language, todayTimestamp]);
  const showImpulseCard = useMemo(() => hasImpulseHistory(impulseInsights), [impulseInsights]);
  const { wishesById, swipePinnedByTemplate } = useMemo(() => {
    const byId = {};
    const swipePinned = {};
    (wishes || []).forEach((wish) => {
      if (wish?.id) {
        byId[wish.id] = wish;
      }
      if (wish?.templateId && wish?.pinnedSource === "swipe") {
        swipePinned[wish.templateId] = wish;
      }
    });
    return { wishesById: byId, swipePinnedByTemplate: swipePinned };
  }, [wishes]);

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: colors.background }] }>
      <FlatList
        style={styles.feedList}
        data={filteredProducts}
        keyExtractor={feedKeyExtractor}
        showsVerticalScrollIndicator={false}
        contentContainerStyle={styles.feedListContent}
        renderItem={renderTemptationItem}
        initialNumToRender={6}
        maxToRenderPerBatch={6}
        windowSize={7}
        updateCellsBatchingPeriod={50}
        removeClippedSubviews={Platform.OS === "android"}
        ListEmptyComponent={
          <View style={styles.emptyState}>
            <Text style={[styles.emptyStateTitle, { color: colors.text }]}>{t("feedEmptyTitle")}</Text>
            <Text style={[styles.emptyStateText, { color: colors.muted }]}>{t("feedEmptySubtitle")}</Text>
          </View>
        }
        ListHeaderComponent={
          <View style={styles.feedHero}>
            <View style={styles.feedHeroTop}>
              <MoodGradientBlock colors={moodGradient} style={styles.heroMoodGradient}>
                <View style={styles.heroMascotRow}>
                  <View style={styles.heroTextWrap}>
                    <Text style={[styles.appName, { color: colors.text }]}>Almost</Text>
                    <Text style={[styles.heroTagline, { color: colors.muted }]}>
                      {t("appTagline")}
                    </Text>
                  {moodPreset?.label && (
                    <TouchableOpacity
                      style={[styles.moodBadge, heroMoodBadgeStyle]}
                      onPress={onMoodDetailsOpen}
                    >
                      <Text style={[styles.moodBadgeText, { color: heroMoodBadgeTextColor }]}>
                        {moodPreset.label}
                      </Text>
                    </TouchableOpacity>
                  )}
                </View>
                {!hideMascot && (
                  <View style={styles.heroMascotContainer}>
                    {showTamagotchiBubble && (
                      <View
                        pointerEvents="none"
                        style={[
                          styles.mascotBubble,
                          {
                            backgroundColor: tamagotchiBubbleTheme.backgroundColor,
                            borderColor: tamagotchiBubbleTheme.borderColor,
                            shadowColor: tamagotchiBubbleTheme.shadowColor,
                          },
                        ]}
                      >
                        <Text style={[styles.mascotBubbleText, { color: tamagotchiBubbleTheme.textColor }]}>
                          {tamagotchiDesiredFood?.emoji || t("tamagotchiHungryBubble")}
                        </Text>
                        <View
                          style={[
                            styles.mascotBubbleTail,
                            {
                              left: "50%",
                              marginLeft: -6,
                              backgroundColor: tamagotchiBubbleTheme.backgroundColor,
                              borderLeftWidth: 1,
                              borderBottomWidth: 1,
                              borderLeftColor: tamagotchiBubbleTheme.borderColor,
                              borderBottomColor: tamagotchiBubbleTheme.borderColor,
                            },
                          ]}
                        />
                      </View>
                    )}
                    <TouchableOpacity onPress={onMascotPress} activeOpacity={0.9}>
                    <AlmiTamagotchi
                      style={heroMascotWrapStyle}
                      override={mascotOverride}
                      onOverrideComplete={onMascotAnimationComplete}
                      isStarving={tamagotchiMood?.tone === "urgent"}
                      animations={tamagotchiAnimations}
                    />
                    </TouchableOpacity>
                  </View>
                )}
              </View>
            </MoodGradientBlock>
          </View>
          <SavingsHeroCard
            goldPalette={goldPalette}
            heroSpendCopy={heroSpendCopy}
            heroRecentEvents={heroRecentEvents}
            heroEncouragementLine={heroEncouragementLine}
            levelLabel={levelLabel}
              totalSavedLabel={totalSavedLabel}
              progressPercent={progressPercent}
              progressPercentLabel={progressPercentLabel}
              goalProgressLabel={goalProgressLabel}
              isGoalComplete={isGoalComplete}
              completionLabel={t("goalWidgetComplete")}
              t={t}
              dailySavings={savingsDaily}
            analyticsPreview={analyticsPreview}
            potentialSavedUSD={potentialSavedUSD}
            actualSavedUSD={realSavedUSD}
            currency={currency}
            hasBaseline={hasBaseline}
            onBaselineSetup={handleBaselineSetup}
            onPotentialDetailsOpen={handlePotentialDetailsOpen}
            levelHasNext={heroLevelHasNext}
            levelRemainingLabel={heroLevelRemainingLabel}
            levelTargetLabel={heroLevelTargetLabel}
            levelProgressValue={heroLevelProgress}
            healthPoints={healthPoints}
            onBreakdownPress={onSavingsBreakdownPress}
            weeklyComparison={weeklyComparison}
            />
            <FreeDayCard
              colors={colors}
              t={t}
              canLog={canLogFreeDay}
              onLog={onFreeDayLog}
              freeDayStats={freeDayStats}
              todayKey={todayKey}
              weekDays={weekDays}
              weekCount={weekSuccessCount}
              canRescue={canRescueFreeDay}
              needsRescue={streakNeedsRescue}
              rescueStatus={rescueStatus}
              rescueCost={freeDayRescueCost}
              onRescue={onFreeDayRescue}
              hasRescueHealth={hasRescueHealth}
            />
            {showImpulseCard && (
              <ImpulseMapCard
                insights={impulseInsights}
                colors={colors}
                t={t}
                language={language}
                expanded={impulseExpanded}
                onToggle={() => setImpulseExpanded((prev) => !prev)}
              />
            )}
            <ScrollView horizontal showsHorizontalScrollIndicator={false} style={{ marginTop: 12 }}>
              {categories.map((cat) => (
                <CategoryChip
                  key={cat}
                  label={resolveCategoryLabel(cat, language)}
                  isActive={cat === activeCategory}
                  onPress={() => onCategorySelect(cat)}
                  colors={colors}
                />
              ))}
            </ScrollView>
          </View>
        }
      />
    </SafeAreaView>
  );
});

const SwipeableGoalRow = ({
  children,
  colors,
  t,
  onEdit,
  onDelete,
  onSwipeOpen,
  onSwipeClose,
}) => {
  const translateX = useRef(new Animated.Value(0)).current;
  const ACTION_WIDTH = 160;
  const gestureStartOffset = useRef(0);
  const externalCloserRef = useRef(null);

  const closeRow = useCallback(
    (notify = true) => {
      Animated.timing(translateX, {
        toValue: 0,
        duration: 150,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }).start(() => {
        if (notify) {
          onSwipeClose?.(externalCloserRef.current);
          externalCloserRef.current = null;
        }
      });
    },
    [onSwipeClose, translateX]
  );

  const notifyOpen = useCallback(() => {
    const closer = () => closeRow();
    externalCloserRef.current = closer;
    onSwipeOpen?.(closer);
  }, [closeRow, onSwipeOpen]);

  const panResponder = useMemo(
    () =>
      PanResponder.create({
        onMoveShouldSetPanResponder: (_, gestureState) =>
          Math.abs(gestureState.dx) > Math.abs(gestureState.dy) && Math.abs(gestureState.dx) > 6,
        onPanResponderGrant: () => {
          translateX.stopAnimation((value) => {
            gestureStartOffset.current = value;
          });
        },
        onPanResponderMove: (_, gestureState) => {
          const base = gestureStartOffset.current || 0;
          const next = Math.max(0, Math.min(base + gestureState.dx, ACTION_WIDTH));
          translateX.setValue(next);
        },
        onPanResponderRelease: () => {
          translateX.stopAnimation((value) => {
            const shouldOpen = value > ACTION_WIDTH * 0.35;
            Animated.timing(translateX, {
              toValue: shouldOpen ? ACTION_WIDTH : 0,
              duration: 180,
              easing: Easing.out(Easing.quad),
              useNativeDriver: true,
            }).start(() => {
              if (shouldOpen) {
                notifyOpen();
              } else {
                closeRow();
              }
            });
          });
        },
        onPanResponderTerminate: () => {
          closeRow();
        },
      }),
    [ACTION_WIDTH, closeRow, notifyOpen, translateX]
  );

  const handleEdit = () => {
    closeRow();
    onEdit?.();
  };

  const handleDelete = () => {
    closeRow();
    onDelete?.();
  };

  return (
    <View style={[styles.goalSwipeRow, { backgroundColor: colors.background }]}>
      <View style={[styles.goalSwipeActions, { backgroundColor: colors.background }]}>
        <TouchableOpacity
          style={[styles.goalSwipeButton, !onEdit && styles.goalSwipeButtonDisabled]}
          onPress={handleEdit}
          disabled={!onEdit}
        >
          <Text style={[styles.goalSwipeButtonText, { color: colors.text }]}>{t("goalEditAction")}</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.goalSwipeButton, !onDelete && styles.goalSwipeButtonDisabled]}
          onPress={handleDelete}
          disabled={!onDelete}
        >
          <Text style={[styles.goalSwipeButtonText, { color: colors.text }]}>{t("goalDeleteAction")}</Text>
        </TouchableOpacity>
      </View>
      <Animated.View style={[styles.goalSwipeContent, { transform: [{ translateX }] }]} {...panResponder.panHandlers}>
        {children}
      </Animated.View>
    </View>
  );
};

const resolveWishEmoji = (wish) => {
  if (wish?.emoji) return wish.emoji;
  const title = (wish?.title || "").trim();
  if (title) {
    const firstChar = Array.from(title)[0];
    if (firstChar && !/[A-Za-z–ê-–Ø–∞-—è0-9]/.test(firstChar)) {
      return firstChar;
    }
  }
  return DEFAULT_GOAL_EMOJI;
};

const getWishTitleWithoutEmoji = (wish) => {
  const title = typeof wish?.title === "string" ? wish.title : "";
  if (!title) return "";
  const trimmed = title.trimStart();
  if (!trimmed) return "";
  const wishEmoji = resolveWishEmoji(wish);
  if (wishEmoji) {
    const emojiToken = wishEmoji.trim();
    if (emojiToken && trimmed.startsWith(emojiToken)) {
      return trimmed.slice(emojiToken.length).trimStart();
    }
  }
  const firstChar = Array.from(trimmed)[0];
  if (!firstChar) return trimmed;
  const isSymbol = !/[A-Za-z–ê-–Ø–∞-—è0-9]/.test(firstChar);
  if (isSymbol && wishEmoji) {
    const rest = Array.from(trimmed).slice(1).join("").trimStart();
    return rest || trimmed;
  }
  return trimmed;
};

const selectMainGoalWish = (wishes = [], activeGoalId = null) => {
  const list = Array.isArray(wishes) ? wishes : [];
  if (activeGoalId) {
    const pinned = list.find(
      (wish) =>
        wish?.goalId === activeGoalId ||
        wish?.id === activeGoalId
    );
    if (pinned) return pinned;
  }
  const primaryActive = list.find(
    (wish) => wish?.kind === PRIMARY_GOAL_KIND && wish.status !== "done"
  );
  if (primaryActive) return primaryActive;
  return list.find((wish) => wish?.status !== "done") || null;
};

const WishListScreen = React.memo(function WishListScreen({
  wishes,
  currency = DEFAULT_PROFILE.currency,
  t,
  colors,
  onRemoveWish,
  primaryGoals = [],
  onGoalLongPress = null,
  onGoalEdit = null,
  activeGoalId = null,
  onSetActiveGoal = null,
  language = DEFAULT_LANGUAGE,
  catCuriousSource,
}) {
  const curiousImage = catCuriousSource || CLASSIC_TAMAGOTCHI_ANIMATIONS.curious;
  const isDarkTheme = colors.background === THEMES.dark.background;
  const primaryGoalIds = Array.isArray(primaryGoals)
    ? primaryGoals.map((goal) => goal?.id).filter(Boolean)
    : [];
  const listData = useMemo(() => {
    if (!Array.isArray(wishes)) return [];
    return wishes
      .map((wish, index) => ({ wish, index }))
      .sort((a, b) => {
        const aDone = a.wish?.status === "done";
        const bDone = b.wish?.status === "done";
        if (aDone === bDone) {
          return a.index - b.index;
        }
        return aDone ? 1 : -1;
      })
      .map((entry) => entry.wish);
  }, [wishes]);
  const swipeCloserRef = useRef(null);
  const handleSwipeOpen = useCallback((closeFn) => {
    if (swipeCloserRef.current && swipeCloserRef.current !== closeFn) {
      swipeCloserRef.current();
    }
    swipeCloserRef.current = closeFn;
  }, []);
  const handleSwipeClose = useCallback((closeFn) => {
    if (!closeFn || swipeCloserRef.current === closeFn) {
      swipeCloserRef.current = null;
    }
  }, []);
  if (listData.length === 0) {
    return (
      <View style={[styles.container, { backgroundColor: colors.background }] }>
        <Text style={[styles.header, { color: colors.text }]}>{t("wishlistTitle")}</Text>
        <View style={styles.cartEmptyState}>
          <Image source={curiousImage} style={[styles.catImage, styles.catImageLarge]} />
          <Text style={[styles.cartEmptyTitle, { color: colors.text }]}>{t("wishlistEmptyTitle")}</Text>
          <Text style={[styles.cartEmptySubtitle, { color: colors.muted }]}>
            {t("wishlistEmptySubtitle")}
          </Text>
        </View>
      </View>
    );
  }

  const totalTarget = formatCurrency(
    convertToCurrency(listData.reduce((sum, wish) => sum + (wish.targetUSD || 0), 0), currency),
    currency
  );

  const renderWithLongPress = useCallback(
    (wish, content) => {
      if (typeof onGoalLongPress === "function") {
        return (
          <TouchableOpacity
            activeOpacity={0.96}
            delayLongPress={320}
            onLongPress={() => onGoalLongPress(wish)}
          >
            {content}
          </TouchableOpacity>
        );
      }
      return content;
    },
    [onGoalLongPress]
  );

  const renderWishRow = useCallback(
    ({ item: wish }) => {
        const targetLocal = formatCurrency(
          convertToCurrency(wish.targetUSD || 0, currency),
          currency
        );
        const progress = Math.min((wish.savedUSD || 0) / (wish.targetUSD || 1), 1);
        const progressLabel = t("wishlistProgress", {
          current: formatCurrency(convertToCurrency(wish.savedUSD || 0, currency), currency),
          target: targetLocal,
        });
        const isPrimaryGoal = wish.kind === PRIMARY_GOAL_KIND;
        const goalId = wish.goalId || wish.id;
        const isActiveGoal = !!activeGoalId && activeGoalId === goalId;
        const badgeText = isPrimaryGoal
          ? isActiveGoal
            ? t("goalPrimaryBadge")
            : t("goalPrimaryBadge")
          : wish.status === "done"
          ? t("wishlistDoneLabel")
          : `${Math.round(progress * 100)}%`;
        const remainingUSD = Math.max((wish.targetUSD || 0) - (wish.savedUSD || 0), 0);
        const remainingLabel = formatCurrency(convertToCurrency(remainingUSD, currency), currency);
        const displayTitle = getWishTitleWithoutEmoji(wish);
        if (isPrimaryGoal) {
          const preset = getGoalPreset(wish.goalId || primaryGoalIds[0]);
          const emblem = wish.emoji || resolveWishEmoji(wish) || preset?.emoji || "üéØ";
          const secondaryColor = isDarkTheme
            ? "rgba(14,15,22,0.65)"
            : "rgba(246,247,251,0.8)";
          const badgeStyle = isDarkTheme
            ? {
                borderColor: "rgba(14,15,22,0.25)",
                backgroundColor: "rgba(14,15,22,0.08)",
              }
            : {
                borderColor: "rgba(246,247,251,0.35)",
                backgroundColor: "rgba(246,247,251,0.15)",
              };
          const trackColor = isDarkTheme
            ? "rgba(14,15,22,0.15)"
            : "rgba(246,247,251,0.2)";
          const fillColor = isDarkTheme
            ? "rgba(14,15,22,0.85)"
            : "rgba(246,247,251,0.95)";
          const auraColor = isDarkTheme
            ? "rgba(0,0,0,0.06)"
            : "rgba(255,255,255,0.18)";
          const cardContent = (
            <View
              style={[
                styles.primaryGoalCard,
                {
                  backgroundColor: colors.text,
                  borderColor: isActiveGoal ? GOAL_HIGHLIGHT_COLOR : colors.text,
                  borderWidth: isActiveGoal ? 2 : 0,
                },
              ]}
            >
              <View style={styles.primaryGoalTop}>
                <View style={{ flex: 1, gap: 8 }}>
                  <View
                    style={[
                      styles.primaryGoalBadge,
                      badgeStyle,
                    ]}
                  >
                    <Text style={[styles.primaryGoalBadgeText, { color: colors.background }]}>
                      {t("goalPrimaryBadge")}
                    </Text>
                  </View>
                  <Text style={[styles.primaryGoalTitle, { color: colors.background }]}>
                    {displayTitle}
                  </Text>
                </View>
                <View
                  style={[
                    styles.primaryGoalEmblem,
                    {
                      borderColor: badgeStyle.borderColor,
                      backgroundColor: badgeStyle.backgroundColor,
                    },
                  ]}
                >
                  <Text style={{ fontSize: 30 }}>{emblem}</Text>
                </View>
              </View>
              <Text style={[styles.primaryGoalSubtitle, { color: secondaryColor }]}>
                {t("primaryGoalRemaining", { amount: remainingLabel })}
              </Text>
              <Text style={[styles.primaryGoalSubtitle, { color: secondaryColor }]}>
                {progressLabel}
              </Text>
              <View style={styles.primaryGoalProgressRow}>
                <View
                  style={[
                    styles.primaryGoalProgressTrack,
                    {
                      backgroundColor: trackColor,
                    },
                  ]}
                >
                  <View
                    style={[
                      styles.primaryGoalProgressFill,
                      {
                        width: `${progress * 100}%`,
                        backgroundColor: fillColor,
                      },
                    ]}
                  />
                </View>
                <Text style={[styles.primaryGoalPercent, { color: colors.background }]}>
                  {`${Math.round(progress * 100)}%`}
                </Text>
              </View>
              <TouchableOpacity
                style={[
                  styles.goalSelectButton,
                  {
                    borderColor: isActiveGoal ? GOAL_HIGHLIGHT_COLOR : colors.border,
                    backgroundColor: isActiveGoal ? "rgba(246,193,107,0.15)" : colors.card,
                  },
                ]}
                activeOpacity={0.9}
                onPress={() => onSetActiveGoal?.(goalId)}
              >
                <Text
                  style={[
                    styles.goalSelectText,
                    { color: isActiveGoal ? GOAL_HIGHLIGHT_COLOR : colors.text },
                  ]}
                >
                  {isActiveGoal
                    ? (language || DEFAULT_LANGUAGE) === "ru"
                      ? "–ê–∫—Ç–∏–≤–Ω–∞—è —Ü–µ–ª—å"
                      : "Active goal"
                    : (language || DEFAULT_LANGUAGE) === "ru"
                    ? "–°–¥–µ–ª–∞—Ç—å –∞–∫—Ç–∏–≤–Ω–æ–π"
                    : "Set active"}
                </Text>
              </TouchableOpacity>
            </View>
          );
          return (
            <SwipeableGoalRow
              colors={colors}
              t={t}
              onEdit={onGoalEdit ? () => onGoalEdit(wish) : undefined}
              onDelete={() => onRemoveWish(wish.id)}
              onSwipeOpen={handleSwipeOpen}
              onSwipeClose={handleSwipeClose}
            >
              {renderWithLongPress(wish, cardContent)}
            </SwipeableGoalRow>
          );
        }
        const wishEmoji = resolveWishEmoji(wish);
        const wishTitle = displayTitle;
        const cardContent = (
          <View
            style={[
              styles.wishCard,
              {
                backgroundColor: colors.card,
                borderColor: isActiveGoal ? GOAL_HIGHLIGHT_COLOR : colors.border,
                borderWidth: isActiveGoal ? 2 : 1,
              },
            ]}
          >
            <View style={styles.wishHeader}>
              <View style={styles.wishTitleWrap}>
                <Text style={[styles.wishEmoji, { color: colors.text }]}>{wishEmoji}</Text>
                <View style={{ flex: 1 }}>
                  <Text style={[styles.wishTitle, { color: colors.text }]}>{wishTitle}</Text>
                  <Text style={[styles.wishSavedHint, { color: colors.muted }]}>
                    {t("wishlistSavedHint")}
                  </Text>
                </View>
              </View>
              <View
                style={[
                  styles.wishBadge,
                  {
                    borderColor: isDarkTheme ? "rgba(255,255,255,0.18)" : "rgba(0,0,0,0.08)",
                    backgroundColor: isDarkTheme ? "rgba(255,255,255,0.08)" : "rgba(0,0,0,0.04)",
                  },
                ]}
              >
                <Text style={[styles.wishBadgeText, { color: colors.text }]}>{badgeText}</Text>
              </View>
            </View>
            <Text style={[styles.pendingPrice, { color: colors.text }]}>{targetLocal}</Text>
            <View style={styles.wishProgressRow}>
              <View style={[styles.wishProgressTrack, { backgroundColor: colors.border }]}>
                <View
                  style={[
                    styles.wishProgressFill,
                    {
                      width: `${progress * 100}%`,
                      backgroundColor: colors.text,
                    },
                  ]}
                />
              </View>
              <Text style={[styles.wishProgressLabel, { color: colors.muted }]}>{progressLabel}</Text>
            </View>
            <View style={styles.pendingButtons}>
              <TouchableOpacity
                style={[styles.pendingButtonPrimary, { backgroundColor: colors.text }]}
                onPress={() => {
                  if (!isActiveGoal) {
                    onSetActiveGoal?.(goalId);
                  }
                }}
                disabled={isActiveGoal}
              >
                <Text style={[styles.pendingButtonPrimaryText, { color: colors.background }]}>
                  {isActiveGoal ? t("wishlistActive") : t("wishlistSetActive")}
                </Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.pendingButtonSecondary, { borderColor: colors.border }]}
                onPress={() => onRemoveWish(wish.id)}
              >
                <Text style={{ color: colors.muted }}>{t("wishlistRemove")}</Text>
              </TouchableOpacity>
            </View>
          </View>
        );
        return (
          <SwipeableGoalRow
            colors={colors}
            t={t}
            onEdit={onGoalEdit ? () => onGoalEdit(wish) : undefined}
            onDelete={() => onRemoveWish(wish.id)}
            onSwipeOpen={handleSwipeOpen}
            onSwipeClose={handleSwipeClose}
          >
            {renderWithLongPress(wish, cardContent)}
          </SwipeableGoalRow>
        );
      },
      [
        colors,
        currency,
        handleSwipeClose,
        handleSwipeOpen,
        isDarkTheme,
        onGoalEdit,
        onGoalLongPress,
        onRemoveWish,
        primaryGoalIds,
        renderWithLongPress,
        t,
      ]
    );

  return (
    <View style={[styles.container, { backgroundColor: colors.background }] }>
      <FlatList
        data={listData}
        keyExtractor={(item) => item.id}
        renderItem={renderWishRow}
        contentContainerStyle={{ paddingBottom: 200 }}
        ListHeaderComponent={
          <>
            <Text style={[styles.header, { color: colors.text }]}>{t("wishlistTitle")}</Text>
            <Text style={[styles.purchasesSubtitle, { color: colors.muted }]}>
              {t("wishlistSummary", { amount: totalTarget })}
            </Text>
          </>
        }
      />
    </View>
  );
});

function SwipeablePendingCard({ children, colors, t, onDelete, itemId }) {
  const translateX = useRef(new Animated.Value(0)).current;
  const isDarkTheme = colors.background === THEMES.dark.background;

  const handleSwipeRelease = useCallback(
    (dx = 0) => {
      if (dx < -DELETE_SWIPE_THRESHOLD && onDelete) {
        onDelete();
      }
      Animated.timing(translateX, {
        toValue: 0,
        duration: 160,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }).start();
    },
    [onDelete, translateX]
  );

  const panResponder = useMemo(
    () =>
      PanResponder.create({
        onStartShouldSetPanResponder: () => false,
        onMoveShouldSetPanResponder: (_, gestureState) =>
          Math.abs(gestureState.dx) > Math.abs(gestureState.dy) && Math.abs(gestureState.dx) > 6,
        onPanResponderGrant: () => {
          translateX.stopAnimation();
        },
        onPanResponderMove: (_, gestureState) => {
          const dx = Math.max(Math.min(gestureState.dx, 60), -180);
          translateX.setValue(dx);
        },
        onPanResponderRelease: (_, gestureState) => {
          handleSwipeRelease(gestureState.dx);
        },
        onPanResponderTerminationRequest: () => false,
        onPanResponderTerminate: () => handleSwipeRelease(0),
      }),
    [handleSwipeRelease, translateX]
  );

  useEffect(() => {
    translateX.setValue(0);
  }, [itemId, translateX]);

  return (
    <View style={styles.pendingSwipeWrapper}>
      <View style={styles.pendingSwipeBackground} pointerEvents="none">
        <View
          style={[
            styles.swipeHint,
            styles.swipeHintRight,
            {
              borderColor: isDarkTheme ? "rgba(255,255,255,0.12)" : colors.border,
              backgroundColor: isDarkTheme ? "rgba(255,87,115,0.15)" : "rgba(233,61,87,0.12)",
            },
          ]}
        >
          <Text style={[styles.swipeHintIcon, { color: "#E15555" }]}>üóëÔ∏è</Text>
          <Text style={[styles.swipeHintText, { color: "#E15555" }]}>{t("goalSwipeDelete")}</Text>
        </View>
      </View>
      <Animated.View style={{ transform: [{ translateX }] }} {...panResponder.panHandlers}>
        {children}
      </Animated.View>
    </View>
  );
}

const PendingScreen = React.memo(function PendingScreen({
  items,
  currency,
  t,
  colors,
  onResolve,
  onDelete,
  language,
  catCuriousSource,
}) {
  const curiousImage = catCuriousSource || CLASSIC_TAMAGOTCHI_ANIMATIONS.curious;
  const [nowTick, setNowTick] = useState(Date.now());
  const sorted = useMemo(
    () => [...items].sort((a, b) => (a.decisionDue || 0) - (b.decisionDue || 0)),
    [items]
  );
  useEffect(() => {
    if (!sorted.length) return undefined;
    const intervalId = setInterval(() => {
      setNowTick(Date.now());
    }, PENDING_COUNTDOWN_FAST_MS);
    return () => clearInterval(intervalId);
  }, [sorted.length]);

  const formatCountdown = useCallback(
    (ms) => {
      if (ms <= 0) return t("pendingExpired");
      const totalSeconds = Math.floor(ms / 1000);
      const days = Math.floor(totalSeconds / 86400);
      const hours = Math.floor((totalSeconds % 86400) / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      const hh = String(hours).padStart(2, "0");
      const mm = String(minutes).padStart(2, "0");
      const ss = String(seconds).padStart(2, "0");
      const daySuffix = resolveLanguageMapValue(PENDING_DAY_SUFFIX, language) || "d";
      return days > 0 ? `${days}${daySuffix} ${hh}:${mm}:${ss}` : `${hh}:${mm}:${ss}`;
    },
    [language, t]
  );

  if (!sorted.length) {
    return (
      <View style={[styles.container, { backgroundColor: colors.background }] }>
        <Text style={[styles.header, { color: colors.text }]}>{t("pendingTitle")}</Text>
        <View style={styles.cartEmptyState}>
          <Image source={curiousImage} style={[styles.catImage, styles.catImageLarge]} />
          <Text style={[styles.cartEmptyTitle, { color: colors.text }]}>{t("pendingEmptyTitle")}</Text>
          <Text style={[styles.cartEmptySubtitle, { color: colors.muted }]}>
            {t("pendingEmptySubtitle")}
          </Text>
        </View>
      </View>
    );
  }

  return (
    <ScrollView
      style={[styles.container, { backgroundColor: colors.background }] }
      contentContainerStyle={{ paddingBottom: 160, gap: 16 }}
    >
      <Text style={[styles.header, { color: colors.text }]}>{t("pendingTitle")}</Text>
      {sorted.map((item) => {
        const diff = (item.decisionDue || 0) - nowTick;
        const countdownLabel = formatCountdown(diff);
        const overdue = diff <= 0;
        const priceLabel = formatTemptationPriceLabel(item, currency);
        return (
          <SwipeablePendingCard
            key={item.id}
            colors={colors}
            t={t}
            onDelete={onDelete ? () => onDelete(item) : undefined}
            itemId={item.id}
          >
            <View
              style={[
                styles.pendingCard,
                {
                  backgroundColor: "rgba(210,230,255,0.9)",
                  borderColor: "rgba(120,170,255,0.65)",
                  borderWidth: 1,
                  shadowColor: "rgba(120,170,255,0.45)",
                  shadowOpacity: 0.12,
                  shadowRadius: 10,
                  shadowOffset: { width: 0, height: 6 },
                  elevation: 3,
                },
              ]}
            >
              <View style={styles.pendingHeader}>
                <Text style={[styles.pendingTitle, { color: colors.text }]}>{item.title}</Text>
              </View>
              <Text
                style={[
                  styles.pendingCountdown,
                  { color: overdue ? "#D9534F" : colors.text, textAlign: "center", fontSize: 20 },
                ]}
              >
                {countdownLabel}
              </Text>
              <Text style={[styles.pendingPrice, { color: colors.text }]}>{priceLabel}</Text>
              <View style={styles.pendingButtons}>
                <TouchableOpacity
                  style={[styles.pendingButtonPrimary, { backgroundColor: colors.text }]}
                  onPress={() => onResolve(item, "want")}
                >
                  <Text style={[styles.pendingButtonPrimaryText, { color: colors.background }]}>
                    {t("pendingActionWant")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.pendingButtonSecondary, { borderColor: colors.border }]}
                  onPress={() => onResolve(item, "decline")}
                >
                  <Text style={{ color: colors.muted }}>{t("pendingActionDecline")}</Text>
                </TouchableOpacity>
              </View>
            </View>
          </SwipeablePendingCard>
        );
      })}
    </ScrollView>
  );
});

const ACHIEVEMENT_METRIC_TYPES = {
  SAVED_AMOUNT: "SAVED_AMOUNT",
  FREE_DAYS_TOTAL: "FREE_DAYS_TOTAL",
  FREE_DAYS_STREAK: "FREE_DAYS_STREAK",
  REFUSE_COUNT: "REFUSE_COUNT",
  FRIDGE_ITEMS_COUNT: "FRIDGE_ITEMS_COUNT",
  FRIDGE_DECISIONS: "FRIDGE_DECISIONS",
};
const ACHIEVEMENT_CONDITION_MAP = {
  [ACHIEVEMENT_METRIC_TYPES.SAVED_AMOUNT]: "amount_saved",
  [ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_TOTAL]: "streak_days",
  [ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_STREAK]: "streak_days",
  [ACHIEVEMENT_METRIC_TYPES.REFUSE_COUNT]: "saves_count",
  [ACHIEVEMENT_METRIC_TYPES.FRIDGE_ITEMS_COUNT]: "pending_items",
  [ACHIEVEMENT_METRIC_TYPES.FRIDGE_DECISIONS]: "decisions_logged",
};

const ACHIEVEMENT_DEFS = [
  {
    id: "saved_50",
    metricType: ACHIEVEMENT_METRIC_TYPES.SAVED_AMOUNT,
    targetValue: 50,
    emoji: "üíæ",
    rewardHealth: 50,
    copy: {
      ru: { title: "–ü–µ—Ä–≤—ã–µ {{amount}}", desc: "–û—Ç–ª–æ–∂–µ–Ω–æ {{amount}} –Ω–∞ –º–∏–Ω–∏-–ø–æ–¥–∞—Ä–æ–∫." },
      en: { title: "First {{amount}}", desc: "Already banked {{amount}} for a mini gift." },
      es: { title: "Primeros {{amount}}", desc: "Ya guardaste {{amount}} para un mini regalo." },
      fr: { title: "Premiers {{amount}}", desc: "D√©j√† mis de c√¥t√© {{amount}} pour un mini cadeau." },
    },
  },
  {
    id: "saved_500",
    metricType: ACHIEVEMENT_METRIC_TYPES.SAVED_AMOUNT,
    targetValue: 500,
    emoji: "üíé",
    rewardHealth: 200,
    copy: {
      ru: { title: "–í –∫–æ–ø–∏–ª–∫–µ —É–∂–µ {{amount}}", desc: "–ú–æ–∂–Ω–æ —Å—Ç—Ä–æ–∏—Ç—å –ø–ª–∞–Ω—ã –Ω–∞ –∫—Ä—É–ø–Ω—É—é —Ü–µ–ª—å." },
      en: { title: "{{amount}} saved already", desc: "Time to plan for a bigger goal." },
      es: { title: "Ya van {{amount}}", desc: "Hora de planear una meta m√°s grande." },
      fr: { title: "{{amount}} d√©j√† √©pargn√©s", desc: "Il est temps de viser un objectif plus grand." },
    },
  },
  {
    id: "refuse_10",
    metricType: ACHIEVEMENT_METRIC_TYPES.REFUSE_COUNT,
    targetValue: 10,
    emoji: "üß†",
    rewardHealth: 70,
    copy: {
      ru: { title: "–û—Å–æ–∑–Ω–∞–Ω–Ω—ã–π –≥–µ—Ä–æ–π", desc: "10 –æ—Å–æ–∑–Ω–∞–Ω–Ω—ã—Ö –æ—Ç–∫–∞–∑–æ–≤ –ø–æ–¥—Ä—è–¥, –¥–∏—Å—Ü–∏–ø–ª–∏–Ω–∞ –Ω–∞ –º–µ—Å—Ç–µ." },
      en: { title: "Mindful hero", desc: "10 deliberate skips keep savings safe." },
      es: { title: "H√©roe consciente", desc: "10 rechazos intencionales mantienen seguros los ahorros." },
      fr: { title: "H√©ros conscient", desc: "10 refus r√©fl√©chis d'affil√©e s√©curisent ton √©pargne." },
    },
  },
  {
    id: "free_total_14",
    metricType: ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_STREAK,
    targetValue: 14,
    emoji: "üóìÔ∏è",
    rewardHealth: 70,
    copy: {
      ru: { title: "14 –¥–Ω–µ–π –±–µ–∑ –∏–º–ø—É–ª—å—Å–æ–≤", desc: "–î–≤–µ –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –Ω–µ–¥–µ–ª–∏ –∏ –∫–æ—à–µ–ª—ë–∫ –¥–æ–≤–æ–ª–µ–Ω." },
      en: { title: "14 impulse-free days", desc: "Two solid weeks of mindful focus." },
      es: { title: "14 d√≠as sin impulsos", desc: "Dos semanas completas de enfoque consciente." },
      fr: { title: "14 jours sans impulsion", desc: "Deux semaines pleines de focus conscient." },
    },
  },
  {
    id: "free_streak_7",
    metricType: ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_STREAK,
    targetValue: 7,
    emoji: "‚ö°Ô∏è",
    rewardHealth: 90,
    copy: {
      ru: { title: "–°–µ—Ä–∏—è –∏–∑ 7 –¥–Ω–µ–π", desc: "–ù–µ–¥–µ–ª—è –±–µ–∑ —Ç—Ä–∞—Ç, —Ç—ã –≤ –ø–æ—Ç–æ–∫–µ." },
      en: { title: "7-day streak", desc: "A full week in the mindful zone." },
      es: { title: "Racha de 7 d√≠as", desc: "Una semana completa en modo consciente." },
      fr: { title: "S√©rie de 7 jours", desc: "Une semaine enti√®re en mode mindful." },
    },
  },
  {
    id: "fridge_items_10",
    metricType: ACHIEVEMENT_METRIC_TYPES.FRIDGE_ITEMS_COUNT,
    targetValue: 10,
    emoji: "üßä",
    rewardHealth: 40,
    copy: {
      ru: { title: "10 —Ö–æ—Ç–µ–ª–æ–∫ –≤ ¬´–¥—É–º–∞–µ–º¬ª", desc: "10 —Ö–æ—Ç–µ–ª–æ–∫ –≤ ¬´–¥—É–º–∞–µ–º¬ª." },
      en: { title: "Thinking stash", desc: "10 temptations parked in Thinking." },
      es: { title: "Reserva en pausa", desc: "10 tentaciones estacionadas en En pausa." },
      fr: { title: "R√©serve en pause", desc: "10 tentations gar√©es dans l'onglet En pause." },
    },
  },
  {
    id: "fridge_decisions_5",
    metricType: ACHIEVEMENT_METRIC_TYPES.FRIDGE_DECISIONS,
    targetValue: 5,
    emoji: "ü•∂",
    rewardHealth: 70,
    copy: {
      ru: { title: "–í–∑–≤–µ—à–µ–Ω–Ω—ã–π –≤—ã–±–æ—Ä", desc: "–†–∞–∑–æ–±—Ä–∞–ª—Å—è —Å 5 —Ö–æ—Ç–µ–ª–∫–∞–º–∏ –∏–∑ ¬´–¥—É–º–∞–µ–º¬ª." },
      en: { title: "Clear-headed", desc: "Closed out 5 Thinking decisions with intent." },
      es: { title: "Decisi√≥n clara", desc: "Resolviste 5 decisiones en En pausa con intenci√≥n." },
      fr: { title: "Esprit clair", desc: "Tu as tranch√© 5 d√©cisions de l'onglet En pause en toute intention." },
    },
  },
];

const CHALLENGE_METRIC_TYPES = {
  SAVE_COUNT: "SAVE_COUNT",
  SAVE_AMOUNT: "SAVE_AMOUNT",
  FREE_DAY_STREAK: "FREE_DAY_STREAK",
  REFUSE_DAY_STREAK: "REFUSE_DAY_STREAK",
  PENDING_DECISIONS: "PENDING_DECISIONS",
  WISH_ADDED: "WISH_ADDED",
  PENDING_ADDED: "PENDING_ADDED",
  WEEKEND_SAVES: "WEEKEND_SAVES",
  MORNING_FREE_DAY: "MORNING_FREE_DAY",
  HIGH_VALUE_SAVE: "HIGH_VALUE_SAVE",
};

const CHALLENGE_STATUS = {
  IDLE: "idle",
  ACTIVE: "active",
  COMPLETED: "completed",
  CLAIMED: "claimed",
  EXPIRED: "expired",
};

const CHALLENGE_STATUS_ORDER = {
  [CHALLENGE_STATUS.COMPLETED]: 0,
  [CHALLENGE_STATUS.ACTIVE]: 1,
  [CHALLENGE_STATUS.IDLE]: 2,
  [CHALLENGE_STATUS.EXPIRED]: 3,
  [CHALLENGE_STATUS.CLAIMED]: 4,
};
const CHALLENGE_REMINDER_WINDOWS = [
  { hour: 9, minute: 0 },
  { hour: 12, minute: 30 },
  { hour: 16, minute: 0 },
  { hour: 19, minute: 30 },
  { hour: 21, minute: 15 },
];

const hashString = (value = "") => {
  const str = String(value);
  let hash = 0;
  for (let i = 0; i < str.length; i += 1) {
    hash = (hash << 5) - hash + str.charCodeAt(i);
    hash |= 0;
  }
  return Math.abs(hash);
};

const alignReminderSlotTime = (timestamp, slot, jitterMinutes = 0) => {
  if (!slot) return timestamp;
  const slotDate = new Date(timestamp);
  slotDate.setHours(slot.hour, slot.minute || 0, 0, 0);
  if (slotDate.getTime() < timestamp) {
    slotDate.setDate(slotDate.getDate() + 1);
  }
  if (jitterMinutes) {
    slotDate.setMinutes(slotDate.getMinutes() + jitterMinutes);
  }
  return slotDate.getTime();
};

const CHALLENGE_DEFS = [
  {
    id: "coffee_free_week",
    emoji: "üõ°Ô∏è",
    metricType: CHALLENGE_METRIC_TYPES.REFUSE_DAY_STREAK,
    targetValue: 7,
    durationDays: 12,
    rewardHealth: 140,
    reminderOffsetsHours: [24, 96, 168],
    copy: {
      ru: {
        title: "–ù–µ–¥–µ–ª—è –ø—Ä–∏–≤—ã—á–∫–∏",
        desc: "–ö–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ —Ç–µ—á–µ–Ω–∏–µ –Ω–µ–¥–µ–ª–∏ –æ—Ç–º–µ—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –æ—Ç–∫–∞–∑.",
      },
      en: {
        title: "Habit week",
        desc: "Log at least one refusal every day for a full week.",
      },
      es: {
        title: "Semana del h√°bito",
        desc: "Registra al menos un rechazo cada d√≠a durante toda la semana.",
      },
      fr: {
        title: "Semaine habitude",
        desc: "Note au moins un refus par jour pendant toute une semaine.",
      },
    },
  },
  {
    id: "micro_detox",
    emoji: "üåÄ",
    metricType: CHALLENGE_METRIC_TYPES.FREE_DAY_STREAK,
    targetValue: 3,
    durationDays: 5,
    rewardHealth: 80,
    reminderOffsetsHours: [24, 72],
    copy: {
      ru: {
        title: "–¢—Ä–∏ –¥–Ω—è —è—Å–Ω–æ—Å—Ç–∏",
        desc: "–°–æ–±–µ—Ä–∏ {{count}} –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –¥–Ω—è –ø–æ–¥—Ä—è–¥ –∏ –≤—Å—Ç—Ä—è—Ö–Ω–∏ –±—é–¥–∂–µ—Ç.",
      },
      en: {
        title: "Clarity streak",
        desc: "Log {{count}} impulse-free days in a row for a quick reset.",
      },
      es: {
        title: "Racha de claridad",
        desc: "Marca {{count}} d√≠as sin impulsos seguidos para reiniciar tu enfoque.",
      },
      fr: {
        title: "S√©rie clart√©",
        desc: "Note {{count}} jours sans impulsion d'affil√©e pour un reset express.",
      },
    },
  },
  {
    id: "refuse_sprint",
    emoji: "‚öîÔ∏è",
    metricType: CHALLENGE_METRIC_TYPES.SAVE_COUNT,
    targetValue: 6,
    durationDays: 4,
    rewardHealth: 60,
    reminderOffsetsHours: [24, 72],
    copy: {
      ru: {
        title: "–°–ø—Ä–∏–Ω—Ç –æ—Ç–∫–∞–∑–æ–≤",
        desc: "–ó–∞—Ñ–∏–∫—Å–∏—Ä—É–π {{count}} –æ—Å–æ–∑–Ω–∞–Ω–Ω—ã—Ö ¬´–Ω–µ—Ç¬ª –ø–æ–¥—Ä—è–¥ –∏ —É–∫—Ä–µ–ø–∏ –ø—Ä–∏–≤—ã—á–∫—É.",
      },
      en: {
        title: "Decline sprint",
        desc: "Record {{count}} mindful refusals in a row to lock the habit.",
      },
      es: {
        title: "Sprint de rechazos",
        desc: "Registra {{count}} ¬´no¬ª conscientes seguidos para afianzar la costumbre.",
      },
      fr: {
        title: "Sprint de refus",
        desc: "Consigne {{count}} refus lucides d'affil√©e pour ancrer l'habitude.",
      },
    },
  },
  {
    id: "health_boost",
    emoji: "üí∞",
    metricType: CHALLENGE_METRIC_TYPES.SAVE_AMOUNT,
    targetValue: 80,
    durationDays: 7,
    rewardHealth: 120,
    reminderOffsetsHours: [24, 96],
    copy: {
      ru: {
        title: "–£—Å–∫–æ—Ä–∏—Ç–µ–ª—å –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–π",
        desc: "–ù–∞–ø—Ä–∞–≤—å –≤ –∫–æ–ø–∏–ª–∫—É {{amount}} –æ—Ç–∫–∞–∑–∞–º–∏ –≤—Å–µ–≥–æ –∑–∞ –Ω–µ–¥–µ–ª—é.",
      },
      en: {
        title: "Savings boost",
        desc: "Route {{amount}} into savings through refusals this week.",
      },
      es: {
        title: "Impulso de ahorro",
        desc: "Env√≠a {{amount}} a la alcanc√≠a con tus rechazos esta semana.",
      },
      fr: {
        title: "Boost d'√©pargne",
        desc: "Dirige {{amount}} vers l'√©pargne gr√¢ce √† tes refus cette semaine.",
      },
    },
  },
  {
    id: "fridge_cleaner",
    emoji: "üßä",
    metricType: CHALLENGE_METRIC_TYPES.PENDING_DECISIONS,
    targetValue: 3,
    durationDays: 6,
    rewardHealth: 80,
    reminderOffsetsHours: [24, 72, 120],
    copy: {
      ru: {
        title: "–†–∞–∑–≥—Ä—É–∑–∏ ¬´–¥—É–º–∞–µ–º¬ª",
        desc: "–†–∞–∑—Ä—É–ª–∏ {{count}} –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã—Ö —Ä–µ—à–µ–Ω–∏–π –∏ –æ—Å–≤–æ–±–æ–¥–∏ –≥–æ–ª–æ–≤—É.",
      },
      en: {
        title: "Clear the shelf",
        desc: "Resolve {{count}} items from the thinking list and free up focus.",
      },
      es: {
        title: "Limpia En pausa",
        desc: "Resuelve {{count}} elementos de En pausa y libera espacio mental.",
      },
      fr: {
        title: "Vider l'√©tag√®re",
        desc: "R√©sous {{count}} √©l√©ments de la liste En pause et lib√®re ton esprit.",
      },
    },
  },
  {
    id: "goal_creator",
    emoji: "üß≠",
    metricType: CHALLENGE_METRIC_TYPES.WISH_ADDED,
    targetValue: 2,
    durationDays: 4,
    rewardHealth: 60,
    reminderOffsetsHours: [24, 48],
    copy: {
      ru: {
        title: "–ù–æ–≤–∞—è –∫–∞—Ä—Ç–∞ —Ü–µ–ª–µ–π",
        desc: "–î–æ–±–∞–≤—å {{count}} —Å–≤–µ–∂–∏—Ö —Ü–µ–ª–µ–π –∏ –Ω–∞–ø–æ–º–Ω–∏ —Å–µ–±–µ, —Ä–∞–¥–∏ —á–µ–≥–æ —ç–∫–æ–Ω–æ–º–∏—à—å.",
      },
      en: {
        title: "Goal-mapping",
        desc: "Add {{count}} new wishes to remember why you save.",
      },
      es: {
        title: "Mapa de metas",
        desc: "A√±ade {{count}} nuevos deseos para recordar por qu√© ahorras.",
      },
      fr: {
        title: "Carte des objectifs",
        desc: "Ajoute {{count}} nouvelles envies pour te rappeler pourquoi tu √©pargnes.",
      },
    },
  },
  {
    id: "weekend_focus",
    emoji: "üõ°Ô∏è",
    metricType: CHALLENGE_METRIC_TYPES.WEEKEND_SAVES,
    targetValue: 3,
    durationDays: 8,
    rewardHealth: 90,
    reminderOffsetsHours: [48, 96],
    copy: {
      ru: {
        title: "–í—ã—Ö–æ–¥–Ω—ã–µ –ø–æ–¥ –∑–∞—â–∏—Ç–æ–π",
        desc: "–°–¥–µ–ª–∞–π {{count}} –æ—Ç–∫–∞–∑–∞ –∏–º–µ–Ω–Ω–æ –≤ –≤—ã—Ö–æ–¥–Ω—ã–µ –∏ —Å–æ—Ö—Ä–∞–Ω–∏ —Å–ø–æ–∫–æ–π—Å—Ç–≤–∏–µ.",
      },
      en: {
        title: "Weekend shield",
        desc: "Log {{count}} refusals during the weekend rush.",
      },
      es: {
        title: "Escudo de fin de semana",
        desc: "Registra {{count}} rechazos durante el rush del fin de semana.",
      },
      fr: {
        title: "Bouclier week-end",
        desc: "Consigne {{count}} refus pendant la folie du week-end.",
      },
    },
  },
  {
    id: "morning_free",
    emoji: "üåÖ",
    metricType: CHALLENGE_METRIC_TYPES.MORNING_FREE_DAY,
    targetValue: 2,
    durationDays: 5,
    rewardHealth: 70,
    reminderOffsetsHours: [12, 48],
    copy: {
      ru: {
        title: "–£—Ç—Ä–µ–Ω–Ω–∏–π —Ñ–æ–∫—É—Å",
        desc: "–û—Ç–º–µ—á–∞–π –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π –¥–µ–Ω—å –¥–æ –ø–æ–ª—É–¥–Ω—è {{count}} —Ä–∞–∑–∞ - –Ω–∞—á–Ω–∏ –¥–µ–Ω—å —Å –ø–æ–±–µ–¥—ã.",
      },
      en: {
        title: "Morning focus",
        desc: "Log a free day before noon {{count}} times.",
      },
      es: {
        title: "Enfoque matutino",
        desc: "Marca un d√≠a gratis antes del mediod√≠a {{count}} veces.",
      },
      fr: {
        title: "Focus matinal",
        desc: "Note un jour gratuit avant midi {{count}} fois.",
      },
    },
  },
  {
    id: "high_roller_shield",
    emoji: "üíé",
    metricType: CHALLENGE_METRIC_TYPES.HIGH_VALUE_SAVE,
    targetValue: 2,
    durationDays: 7,
    rewardHealth: 140,
    minAmountUSD: 35,
    reminderOffsetsHours: [48, 120],
    copy: {
      ru: {
        title: "–©–∏—Ç –æ—Ç –±–æ–ª—å—à–∏—Ö —Ç—Ä–∞—Ç",
        desc: "–û—Ç–∫–∞–∂–∏—Å—å –æ—Ç {{count}} –∫—Ä—É–ø–Ω—ã—Ö –ø–æ–∫—É–ø–æ–∫ (–æ—Ç {{limit}}) –∏ –¥–µ—Ä–∂–∏ –∫—É—Ä—Å.",
      },
      en: {
        title: "High-roller shield",
        desc: "Decline {{count}} big spends (over {{limit}}) to stay on track.",
      },
      es: {
        title: "Escudo anti derroche",
        desc: "Rechaza {{count}} compras grandes (m√°s de {{limit}}) para mantener el rumbo.",
      },
      fr: {
        title: "Bouclier anti-gros achats",
        desc: "Dis non √† {{count}} grosses d√©penses (plus de {{limit}}) pour rester sur la voie.",
      },
    },
  },
  {
    id: "fridge_collector",
    emoji: "üì•",
    metricType: CHALLENGE_METRIC_TYPES.PENDING_ADDED,
    targetValue: 3,
    durationDays: 5,
    rewardHealth: 60,
    reminderOffsetsHours: [24, 72],
    copy: {
      ru: {
        title: "–ö–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä –ø–∞—É–∑",
        desc: "–û—Ç–ø—Ä–∞–≤—å {{count}} –∏–º–ø—É–ª—å—Å–æ–≤ –≤ ¬´–ø–æ–¥—É–º–∞—Ç—å –ø–æ–∑–∂–µ¬ª, —á—Ç–æ–±—ã –≤—ã–∏–≥—Ä–∞—Ç—å –≤—Ä–µ–º—è.",
      },
      en: {
        title: "Pause collector",
        desc: "Park {{count}} temptations into ‚Äúdecide later‚Äù to buy yourself time.",
      },
      es: {
        title: "Coleccionista de pausas",
        desc: "Env√≠a {{count}} tentaciones a ‚Äúpensar despu√©s‚Äù para ganar tiempo.",
      },
      fr: {
        title: "Collectionneur de pauses",
        desc: "Envoie {{count}} tentations dans ¬´ d√©cider plus tard ¬ª pour gagner du temps.",
      },
    },
  },
];

const CHALLENGE_DEF_MAP = CHALLENGE_DEFS.reduce((acc, def) => {
  acc[def.id] = def;
  return acc;
}, {});
const CHALLENGE_TYPE_LABELS = {
  [CHALLENGE_METRIC_TYPES.REFUSE_DAY_STREAK]: "no_spend_day",
  [CHALLENGE_METRIC_TYPES.FREE_DAY_STREAK]: "no_spend_day",
  [CHALLENGE_METRIC_TYPES.SAVE_COUNT]: "decline_count",
  [CHALLENGE_METRIC_TYPES.SAVE_AMOUNT]: "savings_amount",
};

const CHALLENGE_STATUS_LABELS = {
  [CHALLENGE_STATUS.IDLE]: "challengeStatusAvailable",
  [CHALLENGE_STATUS.ACTIVE]: "challengeStatusActive",
  [CHALLENGE_STATUS.COMPLETED]: "challengeStatusCompleted",
  [CHALLENGE_STATUS.EXPIRED]: "challengeStatusExpired",
  [CHALLENGE_STATUS.CLAIMED]: "challengeStatusClaimed",
};

const getActiveChallengesCount = (state) =>
  Object.values(state || {}).filter((entry) => entry?.status === CHALLENGE_STATUS.ACTIVE).length;

const createChallengeEntry = (id) => ({
  id,
  status: CHALLENGE_STATUS.IDLE,
  progress: 0,
  startedAt: null,
  expiresAt: null,
  completedAt: null,
  claimedAt: null,
  reminderNotificationIds: [],
  extra: {},
});

const createInitialChallengesState = () => {
  const base = {};
  CHALLENGE_DEFS.forEach((def) => {
    base[def.id] = createChallengeEntry(def.id);
  });
  return base;
};

const normalizeChallengesState = (rawState) => {
  const base = createInitialChallengesState();
  if (!rawState || typeof rawState !== "object") return base;
  Object.keys(base).forEach((id) => {
    const entry = rawState[id];
    if (!entry || typeof entry !== "object") return;
    base[id] = {
      ...base[id],
      ...entry,
      id,
      status: entry.status || CHALLENGE_STATUS.IDLE,
      progress: Number(entry.progress) || 0,
      extra: entry.extra && typeof entry.extra === "object" ? entry.extra : {},
      reminderNotificationIds: Array.isArray(entry.reminderNotificationIds)
        ? entry.reminderNotificationIds
        : [],
    };
  });
  return base;
};

const getChallengeCopy = (def, language = DEFAULT_LANGUAGE) => {
  const locale = getShortLanguageKey(language);
  return def.copy?.[locale] || def.copy?.en || {};
};

const isSaveEvent = (kind) => kind === "refuse_spend" || kind === "pending_to_decline";

const getDayIndexFromTimestamp = (timestamp) => {
  const date = new Date(timestamp);
  date.setHours(0, 0, 0, 0);
  return Math.floor(date.getTime() / DAY_MS);
};

const isWeekendTimestamp = (timestamp) => {
  const day = new Date(timestamp).getDay();
  return day === 0 || day === 6;
};

const isMorningTimestamp = (timestamp) => {
  const hours = new Date(timestamp).getHours();
  return hours < 12;
};

const finalizeChallengeEntry = (entry, def, timestamp) => {
  if ((entry.progress || 0) >= def.targetValue) {
    return {
      ...entry,
      progress: def.targetValue,
      status: CHALLENGE_STATUS.COMPLETED,
      completedAt: timestamp,
    };
  }
  return entry;
};

const applyChallengeEvent = (state = createInitialChallengesState(), event) => {
  if (!event) return state;
  let changed = false;
  const now = event.timestamp || Date.now();
  const nextState = { ...state };
  Object.keys(nextState).forEach((id) => {
    const entry = state[id] || createChallengeEntry(id);
    const def = CHALLENGE_DEF_MAP[id];
    if (!def || entry.status !== CHALLENGE_STATUS.ACTIVE) return;
    if (entry.expiresAt && now > entry.expiresAt) return;
    const updated = processChallengeEvent(entry, def, event, now);
    if (updated !== entry) {
      nextState[id] = updated;
      changed = true;
    }
  });
  return changed ? nextState : state;
};

const processChallengeEvent = (entry, def, event, now) => {
  const timestamp = event.timestamp || now;
  const meta = event.meta || {};
  let delta = 0;
  switch (def.metricType) {
    case CHALLENGE_METRIC_TYPES.SAVE_COUNT:
      if (isSaveEvent(event.kind)) {
        delta = 1;
      }
      break;
    case CHALLENGE_METRIC_TYPES.SAVE_AMOUNT:
      if (isSaveEvent(event.kind)) {
        const amount = Number(meta.amountUSD) || 0;
        if (amount > 0) {
          delta = amount;
        }
      }
      break;
    case CHALLENGE_METRIC_TYPES.PENDING_DECISIONS:
      if (event.kind === "pending_to_decline") {
        delta = 1;
      }
      break;
    case CHALLENGE_METRIC_TYPES.WISH_ADDED:
      if (event.kind === "wish_added") {
        delta = 1;
      }
      break;
    case CHALLENGE_METRIC_TYPES.PENDING_ADDED:
      if (event.kind === "pending_added") {
        delta = 1;
      }
      break;
    case CHALLENGE_METRIC_TYPES.WEEKEND_SAVES:
      if (isSaveEvent(event.kind) && isWeekendTimestamp(timestamp)) {
        delta = 1;
      }
      break;
    case CHALLENGE_METRIC_TYPES.HIGH_VALUE_SAVE:
      if (isSaveEvent(event.kind)) {
        const highAmount = Number(meta.amountUSD) || 0;
        if (highAmount >= (def.minAmountUSD || 0)) {
          delta = 1;
        }
      }
      break;
    case CHALLENGE_METRIC_TYPES.FREE_DAY_STREAK:
      if (event.kind === "free_day") {
        const dayIndex = getDayIndexFromTimestamp(timestamp);
        const lastDay =
          typeof entry.extra?.lastDayIndex === "number" ? entry.extra.lastDayIndex : null;
        const prevStreak = entry.extra?.currentStreak || 0;
        let nextStreak = 1;
        if (lastDay === dayIndex) {
          nextStreak = prevStreak;
        } else if (lastDay === dayIndex - 1) {
          nextStreak = prevStreak + 1;
        }
        const nextExtra = { ...entry.extra, lastDayIndex: dayIndex, currentStreak: nextStreak };
        if (nextStreak === prevStreak && lastDay === dayIndex) {
          return entry;
        }
        return finalizeChallengeEntry(
          {
            ...entry,
            progress: Math.min(def.targetValue, nextStreak),
            extra: nextExtra,
          },
          def,
          now
        );
      }
      break;
    case CHALLENGE_METRIC_TYPES.REFUSE_DAY_STREAK:
      if (isSaveEvent(event.kind)) {
        const dayIndex = getDayIndexFromTimestamp(timestamp);
        const lastDay =
          typeof entry.extra?.lastRefuseDayIndex === "number"
            ? entry.extra.lastRefuseDayIndex
            : null;
        const prevStreak = entry.extra?.refuseStreak ?? 0;
        let nextStreak = 1;
        if (lastDay === dayIndex) {
          nextStreak = prevStreak;
        } else if (lastDay === dayIndex - 1) {
          nextStreak = prevStreak + 1;
        }
        const nextExtra = {
          ...entry.extra,
          lastRefuseDayIndex: dayIndex,
          refuseStreak: nextStreak,
        };
        if (nextStreak === prevStreak && lastDay === dayIndex) {
          return entry;
        }
        return finalizeChallengeEntry(
          {
            ...entry,
            progress: Math.min(def.targetValue, nextStreak),
            extra: nextExtra,
          },
          def,
          now
        );
      }
      break;
    case CHALLENGE_METRIC_TYPES.MORNING_FREE_DAY:
      if (event.kind === "free_day" && isMorningTimestamp(timestamp)) {
        const dayIndex = getDayIndexFromTimestamp(timestamp);
        const seenDays = Array.isArray(entry.extra?.morningDays) ? entry.extra.morningDays : [];
        if (seenDays.includes(dayIndex)) {
          return entry;
        }
        const updatedDays = [...seenDays, dayIndex];
        return finalizeChallengeEntry(
          {
            ...entry,
            progress: Math.min(def.targetValue, (entry.progress || 0) + 1),
            extra: { ...entry.extra, morningDays: updatedDays },
          },
          def,
          now
        );
      }
      break;
    default:
      break;
  }
  if (!delta) return entry;
  return finalizeChallengeEntry(
    {
      ...entry,
      progress: Math.min(def.targetValue, (entry.progress || 0) + delta),
    },
    def,
    now
  );
};

const expireChallenges = (state = createInitialChallengesState(), now = Date.now()) => {
  let changed = false;
  const next = { ...state };
  Object.keys(next).forEach((id) => {
    const entry = next[id];
    if (
      entry?.status === CHALLENGE_STATUS.ACTIVE &&
      entry.expiresAt &&
      now > entry.expiresAt
    ) {
      next[id] = {
        ...entry,
        status: CHALLENGE_STATUS.EXPIRED,
      };
      changed = true;
    }
  });
  return changed ? next : state;
};

const rebuildChallengeProgressFromHistory = (history = [], state = createInitialChallengesState()) => {
  if (!Array.isArray(history) || !state) return state;
  const sortedEvents = history
    .filter((event) => event && typeof event.timestamp === "number")
    .sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
  if (!sortedEvents.length) return state;
  let changed = false;
  const nextState = { ...state };
  Object.keys(nextState).forEach((id) => {
    const entry = nextState[id];
    const def = CHALLENGE_DEF_MAP[id];
    if (
      !entry ||
      !def ||
      !entry.startedAt ||
      (entry.status !== CHALLENGE_STATUS.ACTIVE && entry.status !== CHALLENGE_STATUS.COMPLETED)
    ) {
      return;
    }
    let rebuilt = {
      ...entry,
      progress: 0,
      completedAt: null,
      status: CHALLENGE_STATUS.ACTIVE,
      extra: {},
    };
    sortedEvents.forEach((event) => {
      if (!event) return;
      const ts = event.timestamp || 0;
      if (ts < entry.startedAt) return;
      if (entry.expiresAt && ts > entry.expiresAt) return;
      rebuilt = processChallengeEvent(rebuilt, def, event, ts);
    });
    const extraChanged =
      JSON.stringify(rebuilt.extra || {}) !== JSON.stringify(entry.extra || {});
    if (
      rebuilt.progress !== entry.progress ||
      rebuilt.status !== entry.status ||
      (rebuilt.completedAt || null) !== (entry.completedAt || null) ||
      extraChanged
    ) {
      nextState[id] = {
        ...entry,
        progress: rebuilt.progress,
        status: rebuilt.status,
        completedAt: rebuilt.completedAt,
        extra: rebuilt.extra,
        claimedAt: rebuilt.status === CHALLENGE_STATUS.COMPLETED ? entry.claimedAt : null,
      };
      changed = true;
    }
  });
  return changed ? nextState : state;
};

const formatChallengeTimeLeft = (ms, t) => {
  if (ms <= 0) return t("challengeTimeExpired");
  const days = Math.floor(ms / DAY_MS);
  const hours = Math.floor((ms % DAY_MS) / (1000 * 60 * 60));
  const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
  if (days > 0) {
    return `${days}${t("challengeTimeDayShort")}${hours > 0 ? ` ${hours}${t("challengeTimeHourShort")}` : ""}`.trim();
  }
  if (hours > 0) {
    return `${hours}${t("challengeTimeHourShort")}${
      minutes > 0 ? ` ${minutes}${t("challengeTimeMinuteShort")}` : ""
    }`.trim();
  }
  return `${Math.max(minutes, 1)}${t("challengeTimeMinuteShort")}`;
};

const buildChallengesDisplay = ({ state, currency, language, t, maxActiveChallenges = Infinity }) => {
  const currencyCode = currency || DEFAULT_PROFILE.currency;
  const now = Date.now();
  const limitThreshold = Number.isFinite(maxActiveChallenges) ? maxActiveChallenges : Infinity;
  const activeCount = getActiveChallengesCount(state);
  const isLimitBlockingNewStart = Number.isFinite(limitThreshold) && activeCount >= limitThreshold;
  const list = CHALLENGE_DEFS.map((def) => {
    const entry = state?.[def.id] || createChallengeEntry(def.id);
    const progressValue = entry.progress || 0;
    const percent = def.targetValue > 0 ? Math.min(1, progressValue / def.targetValue) : 0;
    const copy = getChallengeCopy(def, language);
    const targetLabel =
      def.metricType === CHALLENGE_METRIC_TYPES.SAVE_AMOUNT
        ? formatCurrency(convertToCurrency(def.targetValue, currencyCode), currencyCode, { friendly: true })
        : `${def.targetValue}`;
    const progressLabelValue =
      def.metricType === CHALLENGE_METRIC_TYPES.SAVE_AMOUNT
        ? formatCurrency(convertToCurrency(progressValue, currencyCode), currencyCode)
        : `${Math.floor(progressValue)}`;
    const amountLabel =
      def.metricType === CHALLENGE_METRIC_TYPES.SAVE_AMOUNT
        ? targetLabel
        : "";
    const limitLabel = def.minAmountUSD
      ? formatCurrency(convertToCurrency(def.minAmountUSD, currencyCode), currencyCode, { friendly: true })
      : "";
    const description =
      copy.desc && copy.desc.length
        ? renderTemplateString(copy.desc, {
            count: def.targetValue,
            days: def.durationDays,
            amount: amountLabel,
            limit: limitLabel,
          })
        : "";
    let timerLabel = t("challengeDurationLabel", { days: def.durationDays });
    if (entry.status === CHALLENGE_STATUS.ACTIVE && entry.expiresAt) {
      timerLabel = t("challengeTimeLeftLabel", {
        time: formatChallengeTimeLeft(Math.max(0, entry.expiresAt - now), t),
      });
    } else if (entry.status === CHALLENGE_STATUS.COMPLETED) {
      timerLabel = t("challengeReadyToClaim");
    } else if (entry.status === CHALLENGE_STATUS.CLAIMED) {
      timerLabel = t("challengeRestartHint", { days: def.durationDays });
    }
    const baseCanStart =
      entry.status === CHALLENGE_STATUS.IDLE ||
      entry.status === CHALLENGE_STATUS.EXPIRED ||
      entry.status === CHALLENGE_STATUS.CLAIMED;
    const limitBlocksStart = baseCanStart && isLimitBlockingNewStart;
    const canStart = baseCanStart && !limitBlocksStart;
    const canClaim = entry.status === CHALLENGE_STATUS.COMPLETED;
    let actionLabel = t("challengeActiveCta");
    if (limitBlocksStart) {
      actionLabel = t("challengeLimitReachedAction", { limit: maxActiveChallenges });
    } else if (canClaim) {
      actionLabel = t("challengeClaimCta");
    } else if (canStart) {
      actionLabel = t("challengeStartCta");
    }
    const scaledReward = getScaledChallengeReward(def.rewardHealth);
    return {
      id: def.id,
      emoji: def.emoji,
      title: copy.title || "",
      description,
      rewardHealth: scaledReward,
      rewardLabel: formatHealthRewardLabel(scaledReward, language),
      status: entry.status,
      statusLabel: t(CHALLENGE_STATUS_LABELS[entry.status] || CHALLENGE_STATUS_LABELS[CHALLENGE_STATUS.IDLE]),
      progressPercent: percent,
      progressLabel: t("challengeProgressLabel", {
        current: progressLabelValue,
        target: targetLabel,
      }),
      timerLabel,
      canStart,
      canClaim,
      actionLabel,
    };
  });
  return list.sort(
    (a, b) => (CHALLENGE_STATUS_ORDER[a.status] || 99) - (CHALLENGE_STATUS_ORDER[b.status] || 99)
  );
};

const getAchievementRemainingLabel = (metricType, remaining, currency, t) => {
  if (!remaining || remaining <= 0) return "";
  const count = Math.max(1, Math.ceil(remaining));
  switch (metricType) {
    case ACHIEVEMENT_METRIC_TYPES.SAVED_AMOUNT:
      return t("rewardRemainingAmount", {
        amount: formatCurrency(convertToCurrency(remaining, currency), currency, { friendly: true }),
      });
    case ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_TOTAL:
    case ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_STREAK:
      return t("rewardRemainingDays", { count });
    case ACHIEVEMENT_METRIC_TYPES.REFUSE_COUNT:
      return t("rewardRemainingRefuse", { count });
    case ACHIEVEMENT_METRIC_TYPES.FRIDGE_ITEMS_COUNT:
      return t("rewardRemainingFridge", { count });
    case ACHIEVEMENT_METRIC_TYPES.FRIDGE_DECISIONS:
      return t("rewardRemainingDecisions", { count });
    default:
      return t("rewardLockedGeneric", { count });
  }
};

const buildAchievements = ({
  savedTotalUSD,
  declineCount,
  freeDayStats,
  declineStreak = 0,
  pendingCount,
  decisionStats,
  currency,
  t,
  language,
}) => {
  const fridgeDecisionsResolved =
    (decisionStats?.resolvedToDeclines || 0) + (decisionStats?.resolvedToWishes || 0);
  const metricValues = {
    [ACHIEVEMENT_METRIC_TYPES.SAVED_AMOUNT]: savedTotalUSD,
    [ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_TOTAL]: freeDayStats?.total || 0,
    [ACHIEVEMENT_METRIC_TYPES.FREE_DAYS_STREAK]: freeDayStats?.current || 0,
    [ACHIEVEMENT_METRIC_TYPES.REFUSE_COUNT]: declineStreak || 0,
    [ACHIEVEMENT_METRIC_TYPES.FRIDGE_ITEMS_COUNT]: pendingCount,
    [ACHIEVEMENT_METRIC_TYPES.FRIDGE_DECISIONS]: fridgeDecisionsResolved,
  };

  return ACHIEVEMENT_DEFS.map((def) => {
    const value = metricValues[def.metricType] || 0;
    const target = def.targetValue || 0;
    const unlocked = target ? value >= target : true;
    const progress = target ? Math.min(value / target, 1) : 1;
    const remaining = target ? Math.max(target - value, 0) : 0;
    const amountLabel =
      def.metricType === ACHIEVEMENT_METRIC_TYPES.SAVED_AMOUNT
        ? formatCurrency(convertToCurrency(def.targetValue || 0, currency), currency, { friendly: true })
        : null;
    const copySource = def.copy[language] || def.copy.en;
    const applyAmount = (text) =>
      typeof text === "string" && amountLabel ? text.replace("{{amount}}", amountLabel) : text || "";
    const remainingLabel = getAchievementRemainingLabel(def.metricType, remaining, currency, t);
    return {
      id: def.id,
      emoji: def.emoji,
      title: applyAmount(copySource.title),
      desc: applyAmount(copySource.desc),
      unlocked,
      progress,
      currentValue: value,
      targetValue: target,
      metricType: def.metricType,
      remainingLabel,
      rewardHealth: def.rewardHealth || HEALTH_PER_REWARD,
    };
  });
};

const RewardsScreen = React.memo(function RewardsScreen({
  achievements = [],
  challenges = [],
  activePane = "challenges",
  onPaneChange = () => {},
  onChallengeAccept = () => {},
  onChallengeClaim = () => {},
  onChallengeCancel = () => {},
  t,
  colors,
  savedTotalUSD = 0,
  currency = DEFAULT_PROFILE.currency,
  onRewardClaim = () => {},
  healthRewardAmount = HEALTH_PER_REWARD,
  language = DEFAULT_LANGUAGE,
  dailyChallenge = null,
}) {
  const isDarkTheme = colors.background === THEMES.dark.background;
  const pane = activePane === "rewards" ? "rewards" : "challenges";
  const challengeSwipeCloserRef = useRef(null);
  const handleChallengeSwipeOpen = useCallback((closer) => {
    if (challengeSwipeCloserRef.current && challengeSwipeCloserRef.current !== closer) {
      challengeSwipeCloserRef.current();
    }
    challengeSwipeCloserRef.current = closer;
  }, []);
  const handleChallengeSwipeClose = useCallback((closer) => {
    if (!closer || challengeSwipeCloserRef.current === closer) {
      challengeSwipeCloserRef.current = null;
    }
  }, []);
  const formatRewardLabel = useCallback(
    (amount) => formatHealthRewardLabel(amount, language),
    [language]
  );

  const renderChallengeCard = (challenge) => {
    const actionPalette = challenge.canClaim
      ? { background: SAVE_ACTION_COLOR, text: "#fff" }
      : challenge.canStart
      ? { background: colors.text, text: colors.background }
      : { background: colors.border, text: colors.muted };
    const confirmAccept = () => {
      Alert.alert(
        t("challengeAcceptConfirmTitle"),
        t("challengeAcceptConfirmMessage", { title: challenge.title }),
        [
          { text: t("challengeAcceptConfirmNo"), style: "cancel" },
          {
            text: t("challengeAcceptConfirmYes"),
            style: "default",
            onPress: () => onChallengeAccept?.(challenge.id),
          },
        ]
      );
    };
    const confirmCancel = () => {
      Alert.alert(
        t("challengeCancelConfirmTitle"),
        t("challengeCancelConfirmMessage", { title: challenge.title }),
        [
          { text: t("challengeCancelConfirmNo"), style: "cancel" },
          {
            text: t("challengeCancelConfirmYes"),
            style: "destructive",
            onPress: () => onChallengeCancel?.(challenge.id),
          },
        ]
      );
    };
    const handleActionPress = () => {
      if (challenge.canClaim) {
        onChallengeClaim?.(challenge.id);
      } else if (challenge.canStart) {
        confirmAccept();
      }
    };
    const isActionEnabled = challenge.canClaim || challenge.canStart;
    const isSwipeEnabled = challenge.status === CHALLENGE_STATUS.ACTIVE;
    const cardBody = (
      <View style={[styles.challengeCard, { backgroundColor: colors.card, borderColor: colors.border }]}>
        <View
          style={[
            styles.challengeRewardChip,
            styles.challengeRewardChipFloating,
            { backgroundColor: colors.text },
          ]}
        >
          <HealthRewardTokens
            amount={challenge.rewardHealth}
            color={colors.background}
            iconSize={12}
            maxItems={2}
            textSize={10}
            rowStyle={styles.healthRewardTokenRowCompact}
          />
        </View>
        <View style={styles.challengeHeader}>
          <Text style={styles.challengeEmoji}>{challenge.emoji}</Text>
          <View style={{ flex: 1, gap: 4 }}>
            <Text
              style={[styles.challengeTitle, { color: colors.text }]}
              numberOfLines={2}
              adjustsFontSizeToFit
              minimumFontScale={0.9}
            >
              {challenge.title}
            </Text>
            <Text style={[styles.challengeDesc, { color: colors.muted }]} numberOfLines={3}>
              {challenge.description}
            </Text>
          </View>
        </View>
        <View style={styles.challengeMetaRow}>
          <Text style={[styles.challengeStatus, { color: colors.muted }]}>{challenge.statusLabel}</Text>
          <Text style={[styles.challengeTimer, { color: colors.muted }]}>{challenge.timerLabel}</Text>
        </View>
        <View style={[styles.challengeProgressBar, { backgroundColor: colors.border }]}>
          <View
            style={[
              styles.challengeProgressFill,
              { width: `${challenge.progressPercent * 100}%`, backgroundColor: colors.text },
            ]}
          />
        </View>
        <Text style={[styles.challengeProgressLabel, { color: colors.muted }]}>{challenge.progressLabel}</Text>
        <TouchableOpacity
          style={[styles.challengeActionButton, { backgroundColor: actionPalette.background }]}
          activeOpacity={0.9}
          disabled={!isActionEnabled}
          onPress={handleActionPress}
        >
          <Text style={[styles.challengeActionText, { color: actionPalette.text }]}>
            {challenge.actionLabel}
          </Text>
        </TouchableOpacity>
      </View>
    );
    if (isSwipeEnabled) {
      return (
        <SwipeableChallengeCard
          key={challenge.id}
          colors={colors}
          cancelLabel={t("challengeCancelAction")}
          onCancel={confirmCancel}
          onSwipeOpen={handleChallengeSwipeOpen}
          onSwipeClose={handleChallengeSwipeClose}
        >
          {cardBody}
        </SwipeableChallengeCard>
      );
    }
    return (
      <View key={challenge.id}>
        {cardBody}
      </View>
    );
  };

  const renderRewardCard = (reward) => {
    const rewardPayout = reward.rewardHealth || healthRewardAmount;
    const rewardLabel = formatRewardLabel(rewardPayout);
    const rewardPalette = reward.unlocked
      ? isDarkTheme
        ? {
            background: "rgba(8,48,30,0.9)",
            border: "rgba(74,221,152,0.6)",
            text: "#D6FFE8",
            badgeBg: "rgba(74,221,152,0.2)",
            badgeText: "#82FFC6",
          }
        : {
            background: "#E6F9EE",
            border: "rgba(58,174,120,0.45)",
            text: "#0E512F",
            badgeBg: "rgba(58,174,120,0.15)",
            badgeText: "#0F5C35",
          }
      : {
          background: colors.card,
          border: colors.border,
          text: colors.text,
          badgeBg: colors.text,
          badgeText: colors.background,
        };
    const cardContent = (
      <View
        style={[
          styles.goalCard,
          {
            backgroundColor: rewardPalette.background,
            borderColor: rewardPalette.border,
            borderWidth: reward.unlocked ? 2 : 1,
            shadowOpacity: reward.unlocked ? 0.15 : 0,
            shadowColor: rewardPalette.border,
            shadowOffset: { width: 0, height: reward.unlocked ? 6 : 0 },
            shadowRadius: reward.unlocked ? 12 : 0,
            elevation: reward.unlocked ? 4 : 0,
          },
        ]}
      >
        <View style={styles.rewardHeader}>
          <View style={{ flexDirection: "row", gap: 12, alignItems: "center", flex: 1 }}>
            <Text style={{ fontSize: 28 }}>{reward.emoji}</Text>
            <View style={{ flex: 1 }}>
              <Text style={[styles.goalTitle, { color: rewardPalette.text }]}>{reward.title}</Text>
              <Text style={[styles.goalDesc, { color: colors.muted }]}>{reward.desc}</Text>
            </View>
          </View>
        {reward.unlocked && (
          <View style={styles.rewardBadgeContainer}>
            <View
              style={[
                styles.rewardBadge,
                styles.rewardBadgeFloating,
                { backgroundColor: rewardPalette.badgeBg },
              ]}
            >
              {reward.claimed ? (
                <Text style={[styles.rewardBadgeText, { color: rewardPalette.badgeText }]}>
                  {t("rewardBadgeClaimed")}
                </Text>
              ) : (
                <HealthRewardTokens
                  amount={rewardPayout}
                  color={rewardPalette.badgeText}
                  iconSize={18}
                  maxItems={3}
                />
              )}
            </View>
          </View>
        )}
        </View>
        <View style={[styles.goalProgressBar, { backgroundColor: colors.border }]}>
          <View
            style={[
              styles.goalProgressFill,
              {
                width: `${reward.progress * 100}%`,
                backgroundColor: reward.unlocked ? rewardPalette.badgeText : colors.muted,
              },
            ]}
          />
        </View>
        <Text style={[styles.goalDesc, { color: colors.muted }]}>
          {reward.unlocked
            ? reward.claimed
              ? t("rewardClaimedStatus")
              : t("rewardClaimHint", { amount: rewardLabel })
            : reward.remainingLabel || t("rewardLockedGeneric", { count: 1 })}
        </Text>
        {reward.unlocked && !reward.claimed && (
          <TouchableOpacity
            style={[styles.rewardClaimButton, { backgroundColor: rewardPalette.badgeText }]}
            onPress={(event) => {
              event?.stopPropagation?.();
              onRewardClaim?.(reward);
            }}
          >
            <Text style={[styles.rewardClaimButtonText, { color: rewardPalette.background }]}>
              {t("rewardClaimCta")}
            </Text>
          </TouchableOpacity>
        )}
      </View>
    );
    const isClaimable = reward.unlocked && !reward.claimed;
    return (
      <TouchableOpacity
        key={reward.id}
        activeOpacity={isClaimable ? 0.85 : 1}
        onPress={() => (isClaimable ? onRewardClaim?.(reward) : undefined)}
        disabled={!isClaimable}
      >
        {cardContent}
      </TouchableOpacity>
    );
  };
  const renderDailyChallengeWidget = () => {
    if (!dailyChallenge) return null;
    const progress = Math.min(
      Math.max(Number(dailyChallenge.progress) || 0, 0),
      Number(dailyChallenge.target) || 1
    );
    const target = Math.max(Number(dailyChallenge.target) || 1, 1);
    const rewardLabel = dailyChallengeRewardLabel;
    const percent = Math.min(Math.max(progress / target, 0), 1);
    const widgetBackground = colors.background === THEMES.dark.background ? "rgba(255,255,255,0.05)" : "#FFF7EA";
    const widgetBorder = colors.background === THEMES.dark.background ? "rgba(255,255,255,0.15)" : "rgba(0,0,0,0.06)";
    return (
      <View
        style={[
          styles.dailyChallengeWidget,
          { backgroundColor: widgetBackground, borderColor: widgetBorder },
        ]}
      >
        <View style={styles.dailyChallengeWidgetHeader}>
          <View style={[styles.dailyChallengeBadge, { borderColor: widgetBorder }]}>
            <Text style={[styles.dailyChallengeBadgeText, { color: colors.text }]}>
              {t("dailyChallengeWidgetBadge")}
            </Text>
          </View>
          <HealthRewardTokens amount={dailyChallenge.rewardBonus} color={colors.text} iconSize={16} />
        </View>
        <View style={styles.dailyChallengeWidgetBody}>
          <View style={styles.dailyChallengeEmojiPill}>
            <Text style={styles.dailyChallengeEmojiText}>{dailyChallenge.emoji || "‚ú®"}</Text>
          </View>
          <View style={{ flex: 1, gap: 2 }}>
            <Text style={[styles.dailyChallengeWidgetTitle, { color: colors.text }]}>
              {t("dailyChallengeWidgetTitle")}
            </Text>
            <Text style={[styles.dailyChallengeWidgetDesc, { color: colors.muted }]}>
              {t("dailyChallengeWidgetDesc", { temptation: dailyChallenge.title })}
            </Text>
          </View>
        </View>
        <View style={{ gap: 6 }}>
          <View style={[styles.dailyChallengeProgressBar, { backgroundColor: widgetBorder }]}>
            <View
              style={[
                styles.dailyChallengeProgressFill,
                { width: `${percent * 100}%`, backgroundColor: colors.text },
              ]}
            />
          </View>
          <View style={styles.dailyChallengeWidgetFooter}>
            <Text style={[styles.dailyChallengeProgressLabel, { color: colors.muted }]}>
              {t("dailyChallengeWidgetProgress", { current: `${progress}`, target: `${target}` })}
            </Text>
            <Text style={[styles.dailyChallengeRewardLabel, { color: colors.text }]}>
              {t("dailyChallengeWidgetReward", { amount: rewardLabel })}
            </Text>
          </View>
        </View>
      </View>
    );
  };

  const tabItems = [
    { id: "challenges", label: t("challengeTabTitle") },
    { id: "rewards", label: t("challengeRewardsTabTitle") },
  ];

  return (
    <ScrollView
      style={[styles.container, { backgroundColor: colors.background }]}
      contentContainerStyle={{ paddingBottom: 200, gap: 16 }}
      showsVerticalScrollIndicator={false}
    >
      <View>
        <Text style={[styles.header, { color: colors.text }]}>{t("purchasesTitle")}</Text>
        <Text style={[styles.purchasesSubtitle, { color: colors.muted }]}>
          {t("purchasesSubtitle")}
        </Text>
      </View>
      <View style={styles.rewardsTabs}>
        {tabItems.map((tab) => {
          const isActive = pane === tab.id;
          return (
            <TouchableOpacity
              key={tab.id}
              style={[
                styles.rewardsTabButton,
                {
                  backgroundColor: isActive ? colors.text : "transparent",
                  borderColor: isActive ? colors.text : colors.border,
                },
              ]}
              activeOpacity={0.85}
              onPress={() => {
                if (tab.id !== pane) {
                  onPaneChange?.(tab.id);
                }
              }}
            >
              <Text
                style={[
                  styles.rewardsTabText,
                  { color: isActive ? colors.background : colors.text },
                ]}
              >
                {tab.label}
              </Text>
            </TouchableOpacity>
          );
        })}
      </View>
      {pane === "challenges" ? (
        <View style={{ gap: 16 }}>
          {renderDailyChallengeWidget()}
          {challenges.map(renderChallengeCard)}
          {!challenges.length && (
            <Text style={[styles.historyEmpty, { color: colors.muted }]}>
              {t("rewardsEmpty")}
            </Text>
          )}
        </View>
      ) : (
        <View style={{ gap: 16 }}>
          {achievements.map(renderRewardCard)}
          {!achievements.some((item) => item.unlocked) && (
            <Text style={[styles.historyEmpty, { color: colors.muted }]}>{t("rewardsEmpty")}</Text>
          )}
        </View>
      )}
    </ScrollView>
  );
});

const ProfileScreen = React.memo(function ProfileScreen({
  profile,
  stats,
  isEditing,
  onFieldChange,
  onEditPress,
  onCancelEdit,
  onSaveEdit,
  onThemeToggle,
  onLanguageChange,
  onCurrencyChange,
  onGoalChange,
  onResetData,
  onPickImage,
  onHistoryDelete = () => {},
  theme,
  language,
  currencyValue,
  history = [],
  freeDayStats = INITIAL_FREE_DAY_STATS,
  rewardBadgeCount = 0,
  analyticsOptOut = false,
  onAnalyticsToggle = () => {},
  t,
  colors,
  moodPreset = null,
  mascotImageSource,
}) {
  const fallbackAvatar = mascotImageSource || CLASSIC_TAMAGOTCHI_ANIMATIONS.idle;
  const currentCurrency = currencyValue || profile.currency || DEFAULT_PROFILE.currency;
  const isDarkTheme = theme === "dark";
  const normalizedLanguageValue = normalizeLanguage(language || DEFAULT_LANGUAGE);
  const isRomanceLocale = normalizedLanguageValue === "es" || normalizedLanguageValue === "fr";
  const activeGoalId = profile.goal || DEFAULT_PROFILE.goal;
  const primaryGoalsList =
    Array.isArray(profile.primaryGoals) && profile.primaryGoals.length
      ? profile.primaryGoals
      : [
          {
            id: activeGoalId,
            targetUSD: getGoalDefaultTargetUSD(activeGoalId),
          },
        ];
  const historyEntries = Array.isArray(history) ? history : [];
  const locale = getFormatLocale(language);
  const formatLocalAmount = (valueUSD = 0) =>
    formatCurrency(convertToCurrency(valueUSD || 0, currentCurrency), currentCurrency);
  const [baselineInput, setBaselineInput] = useState("");
  const [customSpendInputs, setCustomSpendInputs] = useState({
    title: "",
    amount: "",
    frequency: "",
  });
  const profileEditingRef = useRef(isEditing);
  const profileCurrencyRef = useRef(currentCurrency);
  const profileCurrencyScrollRef = useRef(null);
  const profileCurrencyNudgeRan = useRef(false);
  useEffect(() => {
    if (profileCurrencyNudgeRan.current) return undefined;
    profileCurrencyNudgeRan.current = true;
    let backTimeout;
    const forwardTimeout = setTimeout(() => {
      profileCurrencyScrollRef.current?.scrollTo({ x: 48, animated: true });
      backTimeout = setTimeout(() => {
        profileCurrencyScrollRef.current?.scrollTo({ x: 0, animated: true });
      }, 650);
    }, 900);
    return () => {
      clearTimeout(forwardTimeout);
      if (backTimeout) clearTimeout(backTimeout);
    };
  }, []);
  useEffect(() => {
    const editingJustOpened = isEditing && !profileEditingRef.current;
    const currencyChanged = isEditing && profileCurrencyRef.current !== currentCurrency;
    profileEditingRef.current = isEditing;
    profileCurrencyRef.current = currentCurrency;
    if (!editingJustOpened && !currencyChanged) return;
    const baselineUSD = profile.spendingProfile?.baselineMonthlyWasteUSD || 0;
    setBaselineInput(
      baselineUSD > 0 ? formatNumberInputValue(convertToCurrency(baselineUSD, currentCurrency)) : ""
    );
    const customAmountUSD = resolveCustomPriceUSD(
      profile.customSpend,
      profile.currency || DEFAULT_PROFILE.currency
    );
    setCustomSpendInputs({
      title: profile.customSpend?.title || "",
      amount:
        customAmountUSD > 0
          ? formatNumberInputValue(convertToCurrency(customAmountUSD, currentCurrency))
          : "",
      frequency: profile.customSpend?.frequencyPerWeek
        ? `${profile.customSpend.frequencyPerWeek}`
        : "",
    });
  }, [
    currentCurrency,
    isEditing,
    profile.currency,
    profile.customSpend,
    profile.spendingProfile?.baselineMonthlyWasteUSD,
  ]);
  const baselineDisplayUSD = profile.spendingProfile?.baselineMonthlyWasteUSD || 0;
  const baselineLocalDisplay = baselineDisplayUSD
    ? formatCurrency(convertToCurrency(baselineDisplayUSD, currentCurrency), currentCurrency)
    : null;
  const customSpendAmountUSD = resolveCustomPriceUSD(
    profile.customSpend,
    profile.currency || DEFAULT_PROFILE.currency
  );
  const customSpendAmountDisplay =
    customSpendAmountUSD > 0
      ? formatCurrency(convertToCurrency(customSpendAmountUSD, currentCurrency), currentCurrency)
      : null;
  const customSpendFrequency = profile.customSpend?.frequencyPerWeek || null;
  const customSpendPlaceholderLabel = formatSampleAmount(CUSTOM_SPEND_SAMPLE_USD, currentCurrency);
  const baselinePlaceholderLabel = formatSampleAmount(BASELINE_SAMPLE_USD, currentCurrency);
  const avatarEditBadgeColors = useMemo(
    () => {
      const dark = theme === "dark";
      return {
        background: dark ? "rgba(0,0,0,0.6)" : "rgba(255,255,255,0.92)",
        border: dark ? "rgba(255,255,255,0.2)" : "rgba(0,0,0,0.08)",
        icon: dark ? colors.card : colors.text,
      };
    },
    [theme, colors.card, colors.text]
  );
  const handleBaselineInputChange = useCallback(
    (text) => {
      setBaselineInput(text);
      const trimmed = text.trim();
      const baseProfile = profile.spendingProfile || { ...DEFAULT_PROFILE.spendingProfile };
      if (!trimmed) {
        onFieldChange?.("spendingProfile", {
          ...baseProfile,
          baselineMonthlyWasteUSD: 0,
          baselineStartAt: null,
        });
        return;
      }
      const parsed = parseNumberInputValue(text);
      if (!Number.isFinite(parsed) || parsed <= 0) return;
      onFieldChange?.("spendingProfile", {
        ...baseProfile,
        baselineMonthlyWasteUSD: convertFromCurrency(parsed, currentCurrency),
        baselineStartAt: new Date().toISOString(),
      });
    },
    [currentCurrency, onFieldChange, profile.spendingProfile]
  );
  const applyCustomSpendDraft = useCallback(
    (nextState) => {
      const trimmedTitle = nextState.title.trim();
      const parsedAmount = parseNumberInputValue(nextState.amount);
      const frequencyValue = parseFloat((nextState.frequency || "").replace(",", "."));
      const hasAmount = Number.isFinite(parsedAmount) && parsedAmount > 0;
      const hasFrequency = Number.isFinite(frequencyValue) && frequencyValue > 0;
      if (!trimmedTitle && !hasAmount && !hasFrequency) {
        onFieldChange?.("customSpend", null);
        return;
      }
      const existing = profile.customSpend || {};
      const next = {
        ...existing,
      };
      next.id = next.id || existing.id || "custom_habit";
      if (trimmedTitle) {
        next.title = trimmedTitle;
      } else {
        delete next.title;
      }
      if (hasAmount) {
        next.amountUSD = convertFromCurrency(parsedAmount, currentCurrency);
        next.currency = currentCurrency;
      } else {
        delete next.amountUSD;
        delete next.currency;
      }
      if (hasFrequency) {
        next.frequencyPerWeek = Math.max(1, Math.round(frequencyValue));
      } else {
        delete next.frequencyPerWeek;
      }
      if (!next.title && !next.amountUSD && !next.frequencyPerWeek) {
        onFieldChange?.("customSpend", null);
        return;
      }
      onFieldChange?.("customSpend", next);
    },
    [currentCurrency, onFieldChange, profile.customSpend]
  );
  const handleCustomSpendInputChange = useCallback(
    (field, value) => {
      setCustomSpendInputs((prev) => {
        const nextState = { ...prev, [field]: value };
        applyCustomSpendDraft(nextState);
        return nextState;
      });
    },
    [applyCustomSpendDraft]
  );
  const describeHistory = (entry) => {
    if (!entry) return t("historyUnknown");
    const { kind, meta = {} } = entry;
    const title = meta.title || t("historyUnknown");
    switch (kind) {
      case "wish_added":
        return t("historyWishAdded", { title });
      case "wish_progress":
        return t("historyWishProgress", {
          title,
          amount: formatLocalAmount(meta.savedUSD),
          target: formatLocalAmount(meta.targetUSD),
        });
      case "wish_completed":
        return t("historyWishDone", { title });
      case "decline":
        return t("historyDecline", { title, amount: formatLocalAmount(meta.amountUSD) });
      case "refuse_spend":
        return t("historyRefuseSpend", { title, amount: formatLocalAmount(meta.amountUSD) });
      case "pending_added":
        return t("historyPendingAdded", { title });
      case "pending_to_wish":
        return t("historyPendingWant", { title });
      case "pending_to_decline":
        return t("historyPendingDecline", { title, amount: formatLocalAmount(meta.amountUSD) });
      case "pending_removed":
        return t("historyPendingRemoved", { title });
      case "free_day":
        return t("historyFreeDay", { total: meta.total || 0 });
      case "spend":
        return t("historySpend", { title, amount: formatLocalAmount(meta.amountUSD) });
      case "wish_removed":
        return t("historyWishRemoved", { title });
      case "goal_started":
        return t("historyGoalStarted", { title });
      case "goal_cancelled":
        return t("historyGoalCancelled", { title });
      case "reward_claimed":
        return t("historyRewardClaimed", { title: title || meta.rewardId || t("historyUnknown") });
      default:
        return t("historyUnknown");
    }
  };
  const formatHistoryMeta = (entry) => {
    if (!entry?.timestamp) return "";
    try {
      const date = new Date(entry.timestamp);
      const dateLabel = date.toLocaleDateString(locale, { day: "numeric", month: "short" });
      const timeLabel = date.toLocaleTimeString(locale, { hour: "2-digit", minute: "2-digit" });
      return t("historyTimestamp", { date: dateLabel, time: timeLabel });
    } catch {
      return "";
    }
  };
  const joinDateLabel = useMemo(() => {
    const stamp = profile.joinedAt || profile.spendingProfile?.baselineStartAt;
    if (!stamp) return null;
    try {
      const joinedDate = new Date(stamp);
      const dateLabel = joinedDate.toLocaleDateString(locale, {
        day: "numeric",
        month: "long",
        year: "numeric",
      });
      return t("profileJoinDate", { date: dateLabel });
    } catch {
      return null;
    }
  }, [profile.joinedAt, profile.spendingProfile?.baselineStartAt, locale, t]);
  const defaultBioByLanguage =
    PROFILE_BIO_FALLBACKS[normalizedLanguageValue] || PROFILE_BIO_FALLBACKS[FALLBACK_LANGUAGE];
  const profileBioValue = typeof profile?.bio === "string" ? profile.bio : "";
  const profileBioText = useMemo(() => {
    const raw = profileBioValue.trim();
    if (!raw) return defaultBioByLanguage;
    const matchedEntry = Object.entries(PROFILE_BIO_FALLBACKS).find(([, value]) => value === raw);
    if (matchedEntry && matchedEntry[0] !== normalizedLanguageValue) {
      return PROFILE_BIO_FALLBACKS[normalizedLanguageValue] || raw;
    }
    return raw;
  }, [defaultBioByLanguage, normalizedLanguageValue, profileBioValue]);
  const profileSubtitleAdjustments = useMemo(() => {
    if (!isRomanceLocale) return null;
    return {
      fontSize: PROFILE_SUBTITLE_FONT_SIZE * 0.9,
      lineHeight: PROFILE_SUBTITLE_LINE_HEIGHT * 0.9,
    };
  }, [isRomanceLocale]);
  const profileMoodGradient = useMemo(
    () =>
      applyThemeToMoodGradient(getMoodGradient(moodPreset?.id), isDarkTheme ? "dark" : "light"),
    [moodPreset?.id, isDarkTheme]
  );
  const handlePrivacyPolicyOpen = useCallback(() => {
    const normalizedLanguage = normalizeLanguage(language);
    const url = PRIVACY_LINKS[normalizedLanguage] || PRIVACY_LINKS.en;
    if (!url) return;
    triggerHaptic();
    Linking.openURL(url).catch((error) => console.warn("privacy policy", error));
  }, [language]);
  const handleSupportPress = useCallback(() => {
    triggerHaptic();
    Linking.openURL(`mailto:${SUPPORT_EMAIL}`).catch((error) => console.warn("support mail", error));
  }, []);
  return (
    <View style={[styles.container, { backgroundColor: colors.background }] }>
      <ScrollView
        style={{ flex: 1 }}
        contentContainerStyle={styles.profileScrollContent}
        keyboardShouldPersistTaps="handled"
        showsVerticalScrollIndicator={false}
      >
        <View style={[styles.profileCard, { backgroundColor: colors.card }] }>
          <View style={styles.profileMoodAura}>
            <MoodGradientBlock colors={profileMoodGradient} style={styles.profileMoodGradient}>
              <TouchableOpacity
                style={styles.profileAvatarWrap}
                activeOpacity={isEditing ? 0.85 : 1}
                onPress={() => isEditing && onPickImage?.()}
              >
                <Image
                  source={profile.avatar ? { uri: profile.avatar } : fallbackAvatar}
                  style={styles.profileAvatar}
                  resizeMode="cover"
                />
                {isEditing && (
                  <View
                    style={[
                      styles.profileAvatarEditBadge,
                      { backgroundColor: avatarEditBadgeColors.background, borderColor: avatarEditBadgeColors.border },
                    ]}
                  >
                    <Text style={[styles.profileAvatarEditIcon, { color: avatarEditBadgeColors.icon }]}>‚úèÔ∏é</Text>
                  </View>
                )}
              </TouchableOpacity>
            </MoodGradientBlock>
            {isEditing && (
              <Text style={[styles.profileAvatarHint, { color: colors.muted }]}>{t("photoTapHint")}</Text>
            )}
            {moodPreset?.label && (
              <Text style={[styles.profileMoodStatus, { color: profileMoodGradient.accent }]}>
                {moodPreset.label}
              </Text>
            )}
          </View>
          {isEditing ? (
            <>
              <TextInput
                style={[
                  styles.profileInput,
                  { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                ]}
                value={profile.name}
                onChangeText={(text) => onFieldChange("name", text)}
                placeholder="Name"
                placeholderTextColor={colors.muted}
              />
              <TextInput
                style={[
                  styles.profileInput,
                  styles.profileBioInput,
                  { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                ]}
                value={profile.bio}
                onChangeText={(text) => onFieldChange("bio", text)}
                placeholder="About you"
                multiline
                placeholderTextColor={colors.muted}
              />
            </>
          ) : (
            <>
            <View style={styles.profileNameRow}>
              <Text style={[styles.profileName, { color: colors.text }]}>{profile.name}</Text>
              {rewardBadgeCount > 0 && (
                <View style={[styles.rewardBadgeSmall, { backgroundColor: colors.text }]}>
                  <Text style={[styles.rewardBadgeSmallText, { color: colors.background }]}>
                    {rewardBadgeCount}{" "}
                    {rewardBadgeCount === 1 ? t("rewardBadgeLabel") : t("rewardBadgeLabelPlural")}
                  </Text>
                </View>
              )}
            </View>
            {joinDateLabel && (
              <Text
                style={[styles.profileSubtitle, { color: colors.muted }, profileSubtitleAdjustments]}
                numberOfLines={1}
                ellipsizeMode="tail"
              >
                {joinDateLabel}
              </Text>
            )}
            <Text style={[styles.profileBio, { color: colors.muted }]}>{profileBioText}</Text>
          </>
        )}

          <View style={styles.profileStatsRow}>
            {stats.map((stat) => (
              <View key={stat.label} style={styles.profileStat}>
                <View style={styles.profileStatValueRow}>
                  <Text style={[styles.profileStatValue, { color: colors.text }]}>{stat.value}</Text>
                  {!!stat.suffix && (
                    <Text style={[styles.profileStatValueSuffix, { color: colors.text }]}>
                      {stat.suffix}
                    </Text>
                  )}
                </View>
                <Text style={[styles.profileStatLabel, { color: colors.muted }]} numberOfLines={1}>
                  {stat.label}
                </Text>
              </View>
            ))}
          </View>

          <View style={styles.profileActions}>
            {isEditing ? (
              <>
                <TouchableOpacity
                  style={[styles.profileActionPrimary, { backgroundColor: colors.text }]}
                  onPress={onSaveEdit}
                >
                  <Text style={[styles.profileActionPrimaryText, { color: colors.background }]}>
                    {t("profileSave")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.profileActionSecondary, { borderColor: colors.border }]}
                  onPress={onCancelEdit}
                >
                  <Text style={[styles.profileActionSecondaryText, { color: colors.muted }]}>
                    {t("profileCancel")}
                  </Text>
                </TouchableOpacity>
              </>
            ) : (
              <TouchableOpacity
                style={[styles.profileActionPrimary, { backgroundColor: colors.text }]}
                onPress={onEditPress}
              >
                <Text style={[styles.profileActionPrimaryText, { color: colors.background }]}>
                  {t("profileEdit")}
                </Text>
              </TouchableOpacity>
            )}
          </View>
        </View>

        <View style={[styles.settingsCard, { backgroundColor: colors.card }] }>
          <View style={styles.profileSection}>
            <Text style={[styles.settingLabel, { color: colors.muted }]}>{t("primaryGoalLabel")}</Text>
            <View style={styles.profileGoalGrid}>
              {GOAL_PRESETS.map((goal) => {
                const active = activeGoalId === goal.id;
                return (
                  <TouchableOpacity
                    key={goal.id}
                    style={[
                      styles.profileGoalOption,
                      {
                        borderColor: colors.border,
                        backgroundColor: active ? colors.text : "transparent",
                      },
                    ]}
                    onPress={() => onGoalChange?.(goal.id)}
                  >
                    <Text style={styles.profileGoalEmoji}>{goal.emoji}</Text>
                    <Text
                      style={[
                        styles.profileGoalText,
                        { color: active ? colors.background : colors.text },
                      ]}
                    >
                      {goal[language] || goal.en}
                    </Text>
                  </TouchableOpacity>
                );
              })}
            </View>
          </View>
          <View style={styles.profileSection}>
            <Text style={[styles.settingLabel, { color: colors.muted }]}>{t("customSpendTitle")}</Text>
            {isEditing ? (
              <View style={{ gap: 10 }}>
                <TextInput
                  style={[
                    styles.profileInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  value={customSpendInputs.title}
                  onChangeText={(text) => handleCustomSpendInputChange("title", text)}
                  placeholder={t("customSpendNamePlaceholder")}
                  placeholderTextColor={colors.muted}
                />
                <TextInput
                  style={[
                    styles.profileInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  value={customSpendInputs.amount}
                  onChangeText={(text) => handleCustomSpendInputChange("amount", text)}
                  placeholder={t("customSpendAmountPlaceholder", { amount: customSpendPlaceholderLabel })}
                  keyboardType="decimal-pad"
                  placeholderTextColor={colors.muted}
                />
                <TextInput
                  style={[
                    styles.profileInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  value={customSpendInputs.frequency}
                  onChangeText={(text) => handleCustomSpendInputChange("frequency", text)}
                  placeholder={t("customSpendFrequencyPlaceholder")}
                  keyboardType="number-pad"
                  placeholderTextColor={colors.muted}
                />
              </View>
            ) : profile.customSpend ? (
              <View style={{ gap: 4 }}>
                <Text style={[styles.profileSettingValue, { color: colors.text }]}>
                  {profile.customSpend.title}
                </Text>
                {customSpendAmountDisplay && (
                  <Text style={[styles.profileHintText, { color: colors.muted }]}>
                    {t("customSpendAmountLabel")}: {customSpendAmountDisplay}
                  </Text>
                )}
                {customSpendFrequency ? (
                  <Text style={[styles.profileHintText, { color: colors.muted }]}>
                    {t("customSpendFrequencyLabel")}: {customSpendFrequency}
                  </Text>
                ) : null}
              </View>
            ) : (
              <Text style={[styles.profileHintText, { color: colors.muted }]}>{t("customSpendHint")}</Text>
            )}
          </View>
          <View style={styles.profileSection}>
            <Text style={[styles.settingLabel, { color: colors.muted }]}>{t("baselineTitle")}</Text>
            {isEditing ? (
              <View style={{ gap: 10 }}>
                <TextInput
                  style={[
                    styles.profileInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  value={baselineInput}
                  onChangeText={handleBaselineInputChange}
                  placeholder={t("baselinePlaceholder", { amount: baselinePlaceholderLabel })}
                  keyboardType="decimal-pad"
                  placeholderTextColor={colors.muted}
                />
              </View>
            ) : baselineLocalDisplay ? (
              <Text style={[styles.profileSettingValue, { color: colors.text }]}>
                {baselineLocalDisplay}
              </Text>
            ) : (
              <Text style={[styles.profileHintText, { color: colors.muted }]}>{t("baselineHint")}</Text>
            )}
          </View>

          <View style={[styles.settingsDivider, { backgroundColor: colors.border }]} />

          <Text style={[styles.settingsTitle, { color: colors.text }]}>{t("settingsTitle")}</Text>
        <View style={styles.settingRow}>
          <Text style={[styles.settingLabel, { color: colors.muted }]}>{t("themeLabel")}</Text>
          <View style={styles.settingChoices}>
            {(["light", "dark"]).map((mode) => (
              <TouchableOpacity
                key={mode}
                style={[
                  styles.settingChip,
                  {
                    backgroundColor: theme === mode ? colors.text : "transparent",
                    borderColor: colors.border,
                  },
                ]}
                onPress={() => onThemeToggle(mode)}
              >
                <Text
                  style={{
                    color: theme === mode ? colors.background : colors.muted,
                    fontWeight: "600",
                  }}
                >
                  {mode === "light" ? t("themeLight") : t("themeDark")}
                </Text>
              </TouchableOpacity>
            ))}
          </View>
        </View>
        <View style={styles.settingRow}>
          <Text style={[styles.settingLabel, { color: colors.muted }]}>{t("languageLabel")}</Text>
          <View style={styles.settingChoices}>
            {SUPPORTED_LANGUAGES.map((lng) => {
              const active = language === lng;
              return (
                <TouchableOpacity
                  key={lng}
                  style={[
                    styles.settingChip,
                    {
                      backgroundColor: active ? colors.text : "transparent",
                      borderColor: colors.border,
                    },
                  ]}
                  onPress={() => onLanguageChange(lng)}
                >
                  <Text
                    style={{
                      color: active ? colors.background : colors.muted,
                      fontWeight: "600",
                    }}
                  >
                    {t(getLanguageLabelKey(lng))}
                  </Text>
                </TouchableOpacity>
              );
            })}
          </View>
        </View>
        <View style={styles.settingRow}>
          <Text style={[styles.settingLabel, { color: colors.muted }]}>
            {t("currencyLabel")} <Text style={{ fontSize: 16 }}>‚Üí</Text>
          </Text>
          <View style={styles.settingCurrencyScrollWrapper}>
            <ScrollView
              ref={profileCurrencyScrollRef}
              horizontal
              showsHorizontalScrollIndicator={false}
              style={styles.settingCurrencyScroll}
              contentContainerStyle={styles.settingCurrencyScrollContent}
            >
              {CURRENCIES.map((code) => (
                <TouchableOpacity
                  key={code}
                  style={[
                    styles.settingChip,
                    {
                      backgroundColor: currentCurrency === code ? colors.text : "transparent",
                      borderColor: colors.border,
                    },
                  ]}
                  onPress={() => onCurrencyChange?.(code)}
                >
                  <Text
                    style={{
                      color: currentCurrency === code ? colors.background : colors.muted,
                      fontWeight: "600",
                    }}
                  >
                    {code}
                  </Text>
                </TouchableOpacity>
              ))}
            </ScrollView>
          </View>
        </View>
        <View style={[styles.settingRow, { alignItems: "center", justifyContent: "space-between" }]}>
          <View style={{ flex: 1, paddingRight: 12 }}>
            <Text style={[styles.settingLabel, { color: colors.text }]}>{t("analyticsOptInLabel")}</Text>
            <Text style={{ color: colors.muted }}>{t("analyticsOptInHint")}</Text>
          </View>
          <Switch
            style={styles.analyticsSwitch}
            value={!analyticsOptOut}
            onValueChange={onAnalyticsToggle}
            trackColor={{ false: colors.border, true: colors.text }}
            thumbColor={colors.card}
          />
        </View>
        <TouchableOpacity
          style={[styles.resetButton, { borderColor: colors.border }]}
          onPress={onResetData}
        >
          <Text style={[styles.resetButtonText, { color: colors.muted }]}>
            {t("developerReset")}
          </Text>
        </TouchableOpacity>
        </View>

        <View style={[styles.historyCard, { backgroundColor: colors.card }] }>
          <Text style={[styles.historyTitle, { color: colors.text }]}>{t("historyTitle")}</Text>
          {historyEntries.length === 0 ? (
            <Text style={[styles.historyEmpty, { color: colors.muted }]}>{t("historyEmpty")}</Text>
          ) : (
            <ScrollView
              style={[
                styles.historyList,
                {
                  borderColor: colors.border,
                  height: HISTORY_VIEWPORT_HEIGHT,
                },
              ]}
              contentContainerStyle={styles.historyListContent}
              showsVerticalScrollIndicator
              nestedScrollEnabled
              scrollEventThrottle={16}
            >
              {historyEntries.map((entry, index) => (
                <View
                  key={entry.id}
                  style={[
                    styles.historyItem,
                    {
                      borderColor: colors.border,
                      borderBottomWidth:
                        index === historyEntries.length - 1 ? 0 : StyleSheet.hairlineWidth,
                    },
                  ]}
                >
                  <View style={styles.historyRow}>
                    <View style={{ flex: 1 }}>
                      <Text style={[styles.historyItemTitle, { color: colors.text }]}>
                        {describeHistory(entry)}
                      </Text>
                      <Text style={[styles.historyItemMeta, { color: colors.muted }]}>
                        {formatHistoryMeta(entry)}
                      </Text>
                    </View>
                    <TouchableOpacity
                      style={[styles.historyDeleteBtn, { borderColor: colors.border }]}
                      onPress={() => onHistoryDelete?.(entry)}
                    >
                      <Text style={[styles.historyDeleteText, { color: colors.muted }]}>‚úï</Text>
                    </TouchableOpacity>
                  </View>
                </View>
              ))}
            </ScrollView>
          )}
        </View>
        <TouchableOpacity
          style={[
            styles.profileLinkButton,
            { borderColor: colors.border, backgroundColor: colors.card },
          ]}
          activeOpacity={0.85}
          onPress={handlePrivacyPolicyOpen}
        >
          <Text style={[styles.profileLinkText, { color: colors.text }]}>{t("privacyPolicyLink")}</Text>
          <Text style={[styles.profileLinkHint, { color: colors.muted }]}>{t("privacyPolicyHint")}</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[
            styles.profileLinkButton,
            { borderColor: colors.border, backgroundColor: colors.card },
          ]}
          activeOpacity={0.85}
          onPress={handleSupportPress}
        >
          <Text style={[styles.profileLinkText, { color: colors.text }]}>{t("supportLink")}</Text>
          <Text style={[styles.profileLinkHint, { color: colors.muted }]}>{t("supportHint")}</Text>
        </TouchableOpacity>
      </ScrollView>
    </View>
  );
});

function AppContent() {
  const [fontsLoaded, fontsError] = useFonts({
    Inter_300Light,
    Inter_400Regular,
    Inter_500Medium,
    Inter_600SemiBold,
    Inter_700Bold,
    Inter_800ExtraBold,
    Inter_900Black,
  });
  const [wishes, setWishes] = useState([]);
  const [wishesHydrated, setWishesHydrated] = useState(false);
  const [freeDayHydrated, setFreeDayHydrated] = useState(false);
  const [purchases, setPurchases] = useState([]);
  const [activeTab, setActiveTab] = useState("feed");
  const [catalogOverrides, setCatalogOverrides] = useState({});
  const [catalogHydrated, setCatalogHydrated] = useState(false);
  const [pricePrecisionOverrides, setPricePrecisionOverrides] = useState({});
  const [pricePrecisionOverridesHydrated, setPricePrecisionOverridesHydrated] = useState(false);
  const [titleOverrides, setTitleOverrides] = useState({});
  const [titleOverridesHydrated, setTitleOverridesHydrated] = useState(false);
  const [emojiOverrides, setEmojiOverrides] = useState({});
  const [emojiOverridesHydrated, setEmojiOverridesHydrated] = useState(false);
  const [categoryOverrides, setCategoryOverrides] = useState({});
  const [categoryOverridesHydrated, setCategoryOverridesHydrated] = useState(false);
  const [descriptionOverrides, setDescriptionOverrides] = useState({});
  const [descriptionOverridesHydrated, setDescriptionOverridesHydrated] = useState(false);
  const [temptations, setTemptations] = useState(DEFAULT_TEMPTATIONS);
  const [quickTemptations, setQuickTemptations] = useState([]);
  const [hiddenTemptations, setHiddenTemptations] = useState([]);
  const [priceEditor, setPriceEditor] = useState({
    item: null,
    value: "",
    title: "",
    emoji: "",
    category: DEFAULT_IMPULSE_CATEGORY,
    description: "",
  });
  const [customReminderId, setCustomReminderId] = useState(null);
  const [customReminderHydrated, setCustomReminderHydrated] = useState(false);
  const [smartReminders, setSmartReminders] = useState([]);
  const [smartRemindersHydrated, setSmartRemindersHydrated] = useState(false);
  const [potentialPushProgress, setPotentialPushProgress] = useState({
    ...DEFAULT_POTENTIAL_PUSH_STATE,
  });
  const [potentialPushHydrated, setPotentialPushHydrated] = useState(false);
  const [dailyNudgeNotificationIds, setDailyNudgeNotificationIds] = useState({});
  const [dailyNudgesHydrated, setDailyNudgesHydrated] = useState(false);
  const [dailyChallenge, setDailyChallenge] = useState(() => createInitialDailyChallengeState());
  const [dailyChallengeHydrated, setDailyChallengeHydrated] = useState(false);
  const [savedTotalUSD, setSavedTotalUSD] = useState(0);
  const [savedTotalHydrated, setSavedTotalHydrated] = useState(false);
  const [lifetimeSavedUSD, setLifetimeSavedUSD] = useState(0);
  const [lifetimeSavedHydrated, setLifetimeSavedHydrated] = useState(false);
  const [declineCount, setDeclineCount] = useState(0);
  const [pendingList, setPendingList] = useState([]);
  const [freeDayStats, setFreeDayStats] = useState({ ...INITIAL_FREE_DAY_STATS });
  const [healthPoints, setHealthPoints] = useState(0);
  const [healthHydrated, setHealthHydrated] = useState(false);
  const [claimedRewards, setClaimedRewards] = useState({});
  const [rewardClaimTotal, setRewardClaimTotal] = useState(0);
  const pruneClaimedRewards = useCallback(() => {
    setClaimedRewards((prev) => {
      const normalized = normalizeClaimedRewardsMap(prev || {});
      if (claimedRewardsEqual(prev || {}, normalized)) {
        return prev;
      }
      return normalized;
    });
  }, []);
  useEffect(() => {
    pruneClaimedRewards();
    const interval = setInterval(pruneClaimedRewards, DAY_MS);
    return () => clearInterval(interval);
  }, [pruneClaimedRewards]);
  const [challengesState, setChallengesState] = useState(() => createInitialChallengesState());
  const [rewardsPane, setRewardsPane] = useState("challenges");
  const [decisionStats, setDecisionStats] = useState({ ...INITIAL_DECISION_STATS });
  const [historyEvents, setHistoryEvents] = useState([]);
  const resolvedHistoryEvents = Array.isArray(historyEvents) ? historyEvents : [];
  const declineStreak = useMemo(() => computeRefuseStreak(resolvedHistoryEvents), [resolvedHistoryEvents]);
  const [coinEntryVisible, setCoinEntryVisible] = useState(false);
  const coinEntryContextRef = useRef({ source: null, openedAt: 0, submitted: false });
  const [coinSliderMaxUSD, setCoinSliderMaxUSD] = useState(DEFAULT_COIN_SLIDER_MAX_USD);
  const [coinSliderHydrated, setCoinSliderHydrated] = useState(false);
  const [pendingGoalTargets, setPendingGoalTargets] = useState(null);
  const [savingsBreakdownVisible, setSavingsBreakdownVisible] = useState(false);
  const products = temptations;
  const [activeCategory, setActiveCategory] = useState("all");
  const [profile, setProfile] = useState(() => ({
    ...DEFAULT_PROFILE_PLACEHOLDER,
    joinedAt: new Date().toISOString(),
  }));
  const [profileHydrated, setProfileHydrated] = useState(false);
  const [profileDraft, setProfileDraft] = useState(() => ({
    ...DEFAULT_PROFILE_PLACEHOLDER,
    joinedAt: new Date().toISOString(),
  }));
  const [northStarLogged, setNorthStarLogged] = useState(false);
  const [northStarHydrated, setNorthStarHydrated] = useState(false);
  const northStarLoggedRef = useRef(false);
  const potentialSavedUSD = useSavingsSimulation(
    profile?.spendingProfile?.baselineMonthlyWasteUSD || 0,
    profile?.spendingProfile?.baselineStartAt || null
  );
  const baselineMonthlyWasteUSD = Math.max(
    0,
    Number(profile?.spendingProfile?.baselineMonthlyWasteUSD) || 0
  );
  const baselineStartAt = profile?.spendingProfile?.baselineStartAt || null;
  const profileJoinedAt = profile?.joinedAt || null;
  const potentialBaselineKey =
    baselineMonthlyWasteUSD > 0 && baselineStartAt
      ? `${baselineStartAt}:${baselineMonthlyWasteUSD}`
      : null;
  const [language, setLanguage] = useState(DEFAULT_LANGUAGE);
  const normalizedLanguageValue = normalizeLanguage(language);
  const isRomanceLocale = normalizedLanguageValue === "es" || normalizedLanguageValue === "fr";
  const baseTabFontSize = Platform.OS === "ios" ? 12 : 13;
  const tabLabelFontSize = isRomanceLocale ? baseTabFontSize - 1 : baseTabFontSize;
  const [homeLayoutReady, setHomeLayoutReady] = useState(false);
  const primaryTemptationId = profile.customSpend ? profile.customSpend.id || "custom_habit" : null;
  const primaryTemptationDescription = useMemo(() => {
    const gender = profile?.gender || "none";
    const description = buildCustomTemptationDescription(gender);
    return description?.[language] || description?.en || "";
  }, [language, profile?.gender]);
  const [activeGoalId, setActiveGoalId] = useState(null);
  const [activeGoalHydrated, setActiveGoalHydrated] = useState(false);
  const [isEditingProfile, setIsEditingProfile] = useState(false);
  const [theme, setTheme] = useState("light");
  const isAndroid = Platform.OS === "android";
  const androidVersion = isAndroid ? Number(Platform.Version) : null;
  const canToggleNavVisibility =
    isAndroid && typeof androidVersion === "number" && !Number.isNaN(androidVersion) && androidVersion < 35;
  const resolveTemplateCard = useCallback(
    (templateId) => {
      if (!templateId) return null;
      const findInList = (list) => (list || []).find((card) => card?.id === templateId);
      return findInList(quickTemptations) || findInList(temptations) || findTemplateById(templateId) || null;
    },
    [quickTemptations, temptations]
  );
  const resolveTemplateTitle = useCallback(
    (templateId, fallback = null) => {
      if (!templateId) return fallback;
      const source = resolveTemplateCard(templateId);
      if (!source) return fallback;
      const rawTitle =
        source.titleOverride ||
        (typeof source.title === "string"
          ? source.title
          : source.title?.[language] || source.title?.en || source.title?.ru || source.title) ||
        fallback;
      const decorated = `${source.emoji || ""} ${rawTitle || ""}`.trim();
      return decorated || fallback;
    },
    [language, resolveTemplateCard]
  );
  const [overlay, setOverlay] = useState(null);
  const [confettiKey, setConfettiKey] = useState(0);
  const overlayTimer = useRef(null);
  const overlayRetryTimerRef = useRef(null);

  useEffect(() => {
    if (!FacebookSettings || typeof FacebookSettings.initializeSDK !== "function") return;
    try {
      if (typeof FacebookSettings.setAppID === "function") {
        FacebookSettings.setAppID(FACEBOOK_APP_ID);
      }
      FacebookSettings.initializeSDK();
      if (typeof FacebookSettings.setAdvertiserTrackingEnabled === "function") {
        const trackingPromise = FacebookSettings.setAdvertiserTrackingEnabled(true);
        if (trackingPromise?.catch) {
          trackingPromise.catch(() => {});
        }
      }
    } catch (error) {
      console.warn("facebook sdk init", error);
    }
  }, []);
  const overlayQueueRef = useRef([]);
  const overlayActiveRef = useRef(false);
  const [dailySummaryVisible, setDailySummaryVisible] = useState(false);
  const [dailySummaryData, setDailySummaryData] = useState(null);
  const [dailySummarySeenKey, setDailySummarySeenKey] = useState(null);
  const [pendingDailySummaryData, setPendingDailySummaryData] = useState(null);
  const [focusTemplateId, setFocusTemplateId] = useState(null);
  const [focusStateHydrated, setFocusStateHydrated] = useState(false);
  const [focusDigestSeenKey, setFocusDigestSeenKey] = useState(null);
  const [focusDigestHydrated, setFocusDigestHydrated] = useState(false);
  const [pendingFocusDigest, setPendingFocusDigest] = useState(null);
  const [focusDigestPromptShown, setFocusDigestPromptShown] = useState(false);
  const [focusSaveCount, setFocusSaveCount] = useState(0);
  const appStateRef = useRef(AppState.currentState || "active");
  const focusLossCountersRef = useRef({});
  const focusPromptActiveRef = useRef(false);
  const homeSessionRef = useRef({
    dateKey: getDayKey(Date.now()),
    sessionCount: 0,
    pendingIndex: null,
  });
  const dailyChallengePromptVisible =
    dailyChallenge.status === DAILY_CHALLENGE_STATUS.OFFER && !dailyChallenge.offerDismissed;
  const dailyNudgeIdsRef = useRef({});
  const smartRemindersRef = useRef([]);
  const handleDailySummaryContinue = useCallback(() => {
    setDailySummaryVisible(false);
    const todayKey = dailySummaryData?.todayKey || getDayKey(Date.now());
    if (!todayKey) return;
    setDailySummarySeenKey(todayKey);
    AsyncStorage.setItem(STORAGE_KEYS.DAILY_SUMMARY, todayKey).catch(() => {});
  }, [dailySummaryData]);
  const [tutorialSeen, setTutorialSeen] = useState(true);
  const [tutorialVisible, setTutorialVisible] = useState(false);
  const [tutorialStepIndex, setTutorialStepIndex] = useState(0);
  const [ratingPromptState, setRatingPromptState] = useState(() => createInitialRatingPromptState());
  const [ratingPromptHydrated, setRatingPromptHydrated] = useState(false);
  const [ratingPromptVisible, setRatingPromptVisible] = useState(false);
  const ratingPromptCompleted = ratingPromptState.completed;
  const ratingPromptFirstOpenAt = ratingPromptState.firstOpenAt;
  const [levelShareModal, setLevelShareModal] = useState({ visible: false, level: 1 });
  const [levelShareSharing, setLevelShareSharing] = useState(false);
  const levelShareCardRef = useRef(null);
  const [tabHintsSeen, setTabHintsSeen] = useState(DEFAULT_TAB_HINTS_STATE);
  const [tabHintsHydrated, setTabHintsHydrated] = useState(false);
  const [tabHintVisible, setTabHintVisible] = useState(null);
  const [tabBarHeight, setTabBarHeight] = useState(0);
  const [fabTutorialState, setFabTutorialState] = useState(FAB_TUTORIAL_STATUS.DONE);
  const [fabTutorialVisible, setFabTutorialVisible] = useState(false);
  const fabTutorialStateRef = useRef(FAB_TUTORIAL_STATUS.DONE);
  const fabTutorialLoggedRef = useRef(false);
  const fabButtonWrapperRef = useRef(null);
  const [fabTutorialAnchor, setFabTutorialAnchor] = useState(null);
  const [fabTutorialEligible, setFabTutorialEligible] = useState(false);
  const finishTutorial = useCallback(() => {
    setTutorialVisible(false);
    setTutorialSeen(true);
    setTutorialStepIndex(0);
    AsyncStorage.setItem(STORAGE_KEYS.TUTORIAL, "done").catch(() => {});
  }, []);
  const handleTutorialNext = useCallback(() => {
    if (tutorialStepIndex < APP_TUTORIAL_STEPS.length - 1) {
      setTutorialStepIndex((prev) => Math.min(prev + 1, APP_TUTORIAL_STEPS.length - 1));
      return;
    }
    finishTutorial();
  }, [tutorialStepIndex, finishTutorial]);
  const handleTutorialSkip = useCallback(() => {
    finishTutorial();
  }, [finishTutorial]);
  const dismissTabHint = useCallback(() => {
    setTabHintVisible(null);
  }, []);
  const markTabHintSeen = useCallback(
    (tabId) => {
      if (!tabId) return;
      setTabHintsSeen((prev) => {
        if (prev[tabId]) return prev;
        const nextState = { ...prev, [tabId]: true };
        if (tabHintsHydrated) {
          AsyncStorage.setItem(STORAGE_KEYS.TAB_HINTS, JSON.stringify(nextState)).catch(() => {});
        }
        return nextState;
      });
    },
    [tabHintsHydrated]
  );
  const updateFabAnchor = useCallback(() => {
    const node = fabButtonWrapperRef.current;
    if (!node || typeof node.measureInWindow !== "function") return;
    node.measureInWindow((x, y, width, height) => {
      const centerX = x + width / 2;
      const androidStatusBarOffset = Platform.OS === "android" ? RNStatusBar.currentHeight || 0 : 0;
      const centerY = y + height / 2 + androidStatusBarOffset;
      setFabTutorialAnchor((prev) => {
        if (prev && Math.abs(prev.x - centerX) < 0.5 && Math.abs(prev.y - centerY) < 0.5) {
          return prev;
        }
        return { x: centerX, y: centerY };
      });
    });
  }, []);
  const handleFabWrapperLayout = useCallback(() => {
    updateFabAnchor();
  }, [updateFabAnchor]);
  const handleTabBarLayout = useCallback((event) => {
    const height = event?.nativeEvent?.layout?.height;
    if (!height || height <= 0) return;
    setTabBarHeight((prev) => (Math.abs(prev - height) < 1 ? prev : height));
  }, []);
  const handleHomeLayout = useCallback(() => {
    setHomeLayoutReady((ready) => (ready ? ready : true));
  }, []);
  const setFabTutorialStateAndPersist = useCallback((nextState) => {
    fabTutorialStateRef.current = nextState;
    setFabTutorialState(nextState);
    AsyncStorage.setItem(STORAGE_KEYS.FAB_TUTORIAL, nextState).catch(() => {});
  }, []);
  const handleFabTutorialDismiss = useCallback(
    (source = "dismiss") => {
      if (fabTutorialStateRef.current !== FAB_TUTORIAL_STATUS.SHOWING) {
        setFabTutorialVisible(false);
        return;
      }
      setFabTutorialVisible(false);
      setFabTutorialStateAndPersist(FAB_TUTORIAL_STATUS.DONE);
      logEvent("fab_tutorial_completed", { source });
    },
    [logEvent, setFabTutorialStateAndPersist]
  );
  const updateRatingPromptState = useCallback((updater) => {
    setRatingPromptState((prev) => {
      const nextState = typeof updater === "function" ? updater(prev) : updater;
      AsyncStorage.setItem(STORAGE_KEYS.RATING_PROMPT, JSON.stringify(nextState)).catch(() => {});
      return nextState;
    });
  }, []);
  const triggerStoreReview = useCallback(async () => {
    try {
      if (StoreReview && typeof StoreReview.isAvailableAsync === "function") {
        const available = await StoreReview.isAvailableAsync();
        if (available && typeof StoreReview.requestReview === "function") {
          await StoreReview.requestReview();
          return;
        }
      }
    } catch (error) {
      console.warn("store review prompt", error);
    }
    if (Platform.OS !== "android") return;
    try {
      const canOpen = await Linking.canOpenURL(ANDROID_REVIEW_URL);
      if (canOpen) {
        await Linking.openURL(ANDROID_REVIEW_URL);
        return;
      }
    } catch (error) {
      console.warn("android review intent", error);
    }
    Linking.openURL(ANDROID_REVIEW_WEB_URL).catch(() => {});
  }, []);
  const handleRatingPromptLater = useCallback(() => {
    setRatingPromptVisible(false);
    const respondedAt = new Date().toISOString();
    updateRatingPromptState((prev) => ({
      ...prev,
      completed: true,
      lastAction: "later",
      respondedAt,
    }));
    logEvent("rating_prompt_action", { action: "later" });
  }, [logEvent, updateRatingPromptState]);
  const handleRatingPromptConfirm = useCallback(() => {
    setRatingPromptVisible(false);
    const respondedAt = new Date().toISOString();
    updateRatingPromptState((prev) => ({
      ...prev,
      completed: true,
      lastAction: "rate",
      respondedAt,
    }));
    logEvent("rating_prompt_action", { action: "rate" });
    // Wait until the prompt modal is fully dismissed before attempting to show the native review UI.
    InteractionManager.runAfterInteractions(() => {
      triggerStoreReview();
    });
  }, [logEvent, triggerStoreReview, updateRatingPromptState]);
  const openLevelShareModal = useCallback(
    (level = 1) => {
      setLevelShareModal({ visible: true, level });
      logEvent("level_share_opened", { level });
    },
    [logEvent]
  );
  const closeLevelShareModal = useCallback(() => {
    setLevelShareModal((prev) => ({ ...prev, visible: false }));
  }, []);
  const handleLevelSharePress = useCallback(
    (level) => {
      dismissOverlay();
      openLevelShareModal(level);
    },
    [dismissOverlay, openLevelShareModal]
  );
  const handleLevelShareConfirm = useCallback(async () => {
    if (!levelShareCardRef.current || levelShareSharing) return;
    let cleanupUri = null;
    try {
      setLevelShareSharing(true);
      await new Promise((resolve) => requestAnimationFrame(resolve));
      let sharingAvailable = false;
      if (Sharing && typeof Sharing.isAvailableAsync === "function" && typeof Sharing.shareAsync === "function") {
        try {
          sharingAvailable = await Sharing.isAvailableAsync();
        } catch (availabilityError) {
          console.warn("sharing availability", availabilityError);
          sharingAvailable = false;
        }
      }
      const captureOptions = sharingAvailable
        ? { format: "png", quality: 0.96, result: "tmpfile" }
        : { format: "png", quality: 0.96, result: "base64" };
      const captureResult = await captureViewShotRef(levelShareCardRef, captureOptions);
      if (!captureResult) {
        throw new Error("capture_failed");
      }
      let normalizedUri = captureResult;
      if (captureOptions.result === "base64") {
        const baseDir = FileSystem.cacheDirectory || FileSystem.documentDirectory || "";
        const targetUri = `${baseDir}almost-level-share-${Date.now()}.png`;
        await FileSystem.writeAsStringAsync(targetUri, captureResult, {
          encoding: FileSystem.EncodingType.Base64,
        });
        normalizedUri = targetUri.startsWith("file://") ? targetUri : `file://${targetUri}`;
      } else if (!normalizedUri.startsWith("file://")) {
        normalizedUri = `file://${normalizedUri}`;
      }
      cleanupUri = normalizedUri;
      const shareTitle = `${t("levelShareModalTitle")} ¬∑ ${t("levelShareFooterBrand")}`;
      const message = t("levelShareShareMessage", { level: levelShareModal.level });
      let sharedSuccessfully = false;
      if (sharingAvailable) {
        try {
          await Sharing.shareAsync(normalizedUri, {
            dialogTitle: shareTitle,
            mimeType: "image/png",
            UTI: "public.png",
          });
          sharedSuccessfully = true;
        } catch (sharingError) {
          console.warn("expo sharing failed", sharingError);
        }
      }
      if (!sharedSuccessfully) {
        if (Platform.OS === "ios" && ActionSheetIOS && typeof ActionSheetIOS.showShareActionSheetWithOptions === "function") {
          await new Promise((resolve, reject) => {
            ActionSheetIOS.showShareActionSheetWithOptions(
              {
                url: normalizedUri,
                subject: shareTitle,
              },
              (error) => {
                if (error) {
                  reject(error);
                } else {
                  resolve();
                }
              },
              () => resolve()
            );
          });
        } else {
          let fallbackUri = normalizedUri;
          if (Platform.OS === "android" && typeof FileSystem.getContentUriAsync === "function") {
            fallbackUri = await FileSystem.getContentUriAsync(normalizedUri);
          }
          await Share.share({
            url: fallbackUri,
            message,
            subject: Platform.OS === "ios" ? shareTitle : undefined,
          });
        }
      }
      logEvent("level_share_sent", { level: levelShareModal.level });
      closeLevelShareModal();
    } catch (error) {
      console.warn("level share", error);
      Alert.alert(t("levelShareModalTitle"), t("levelShareError") || "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–µ–ª–∏—Ç—å—Å—è. –ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ.");
    } finally {
      if (cleanupUri) {
        setTimeout(() => {
          FileSystem.deleteAsync(cleanupUri, { idempotent: true }).catch(() => {});
        }, 3500);
      }
      setLevelShareSharing(false);
    }
  }, [closeLevelShareModal, levelShareModal.level, levelShareSharing, logEvent, t]);
  const clearCompletedPrimaryGoal = useCallback(
    (goalId) => {
      if (!goalId) return;
      setWishes((prev) =>
        prev.filter(
          (w) => !(w.kind === PRIMARY_GOAL_KIND && (w.goalId || w.id) === goalId && w.status === "done")
        )
      );
    },
    [setWishes]
  );
  const ensureActiveGoalForNewWish = useCallback(
    (newWish) => {
      if (!newWish) return;
      if (!(mainGoalWish?.status === "done" || profile.goalCelebrated)) return;
      const targetUSD =
        Number.isFinite(newWish.targetUSD) && newWish.targetUSD > 0
          ? newWish.targetUSD
          : getGoalDefaultTargetUSD(newWish.goalId || newWish.id);
      const previousGoalId = activeGoalId || profile.goal;
      clearCompletedPrimaryGoal(previousGoalId);
      setActiveGoalId(newWish.id);
      setProfile((prev) => ({
        ...prev,
        goal: newWish.id,
        goalTargetUSD: targetUSD,
        goalCelebrated: false,
        goalRenewalPending: false,
      }));
      setProfileDraft((prev) => ({
        ...prev,
        goal: newWish.id,
        goalTargetUSD: targetUSD,
        goalCelebrated: false,
        goalRenewalPending: false,
      }));
      dismissGoalRenewalPrompt();
    },
    [
      activeGoalId,
      clearCompletedPrimaryGoal,
      dismissGoalRenewalPrompt,
      mainGoalWish?.status,
      profile.goal,
      profile.goalCelebrated,
    ]
  );
  const ensureGoalManualTracking = useCallback((wishId) => {
    if (!wishId) return;
    setWishes((prev) => {
      let changed = false;
      const next = prev.map((wish) => {
        if (wish.id === wishId && wish.autoManaged !== false) {
          changed = true;
          return { ...wish, autoManaged: false };
        }
        return wish;
      });
      return changed ? next : prev;
    });
  }, []);
  const [mascotOverride, setMascotOverride] = useState(null);
  const mascotQueueRef = useRef([]);
  const mascotBusyRef = useRef(false);
  const [tamagotchiState, setTamagotchiState] = useState({ ...TAMAGOTCHI_START_STATE });
  const [tamagotchiVisible, setTamagotchiVisible] = useState(false);
  const [tamagotchiSkinId, setTamagotchiSkinId] = useState(DEFAULT_TAMAGOTCHI_SKIN);
  const [tamagotchiSkinHydrated, setTamagotchiSkinHydrated] = useState(false);
  const [tamagotchiSkinsUnlocked, setTamagotchiSkinsUnlocked] = useState(false);
  const [tamagotchiSkinsUnlockHydrated, setTamagotchiSkinsUnlockHydrated] = useState(false);
  const [skinPickerVisible, setSkinPickerVisible] = useState(false);
  const tamagotchiSkin =
    TAMAGOTCHI_SKINS[tamagotchiSkinId] || TAMAGOTCHI_SKINS[DEFAULT_TAMAGOTCHI_SKIN];
  const tamagotchiAnimations = tamagotchiSkin.animations;
  const tamagotchiAvatarSource = tamagotchiSkin.avatar;
  const tamagotchiSkinsLocked = !tamagotchiSkinsUnlocked;
  const tamagotchiHydratedRef = useRef(false);
  const tamagotchiHungerPrevRef = useRef(
    Math.min(TAMAGOTCHI_MAX_HUNGER, Math.max(0, TAMAGOTCHI_START_STATE.hunger))
  );
  const tamagotchiModalAnim = useRef(new Animated.Value(0)).current;
  const partyGlow = useRef(new Animated.Value(0)).current;
  const [partyActive, setPartyActive] = useState(false);
  const [partyBurstKey, setPartyBurstKey] = useState(0);
  const partyGlowAnimRef = useRef(null);
  const processTamagotchiDecay = useCallback(
    (timestamp = Date.now()) => {
      setTamagotchiState((prev) => {
        const { state: nextState } = computeTamagotchiDecay(prev, timestamp);
        return nextState;
      });
    },
    [setTamagotchiState]
  );
  const saveActionLogRef = useRef([]);
  const cartBadgeScale = useRef(new Animated.Value(1)).current;
  useEffect(() => {
    const pulse = Animated.loop(
      Animated.sequence([
        Animated.delay(4200),
        Animated.timing(cartBadgeScale, {
          toValue: 1.08,
          duration: 400,
          easing: Easing.out(Easing.ease),
          useNativeDriver: true,
        }),
        Animated.timing(cartBadgeScale, {
          toValue: 1,
          duration: 420,
          easing: Easing.out(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    );
    pulse.start();
    return () => pulse.stop();
  }, [cartBadgeScale]);
  const openSkinPicker = useCallback(() => {
    triggerHaptic();
    setTamagotchiVisible(false);
    setSkinPickerVisible(true);
  }, []);
  const closeSkinPicker = useCallback(() => setSkinPickerVisible(false), []);
  const handleSkinSelect = useCallback(
    (skinId) => {
      if (!skinId || !TAMAGOTCHI_SKINS[skinId]) return;
      if (!tamagotchiSkinsUnlocked && skinId !== DEFAULT_TAMAGOTCHI_SKIN) {
        triggerHaptic();
        return;
      }
      setTamagotchiSkinId(skinId);
      setSkinPickerVisible(false);
      logEvent("tamagotchi_skin_selected", { skin_id: skinId });
    },
    [logEvent, tamagotchiSkinsUnlocked]
  );
  const handleUnlockSkinsPress = useCallback(() => {
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    const subject = t("tamagotchiSkinFeedbackSubject");
    const body = t("tamagotchiSkinFeedbackBody");
    const mailLink = `mailto:${SUPPORT_EMAIL}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(
      body
    )}`;
    Linking.openURL(mailLink).catch((error) => console.warn("tamagotchi skin unlock mail", error));
    setTamagotchiSkinsUnlocked(true);
    logEvent("tamagotchi_skin_unlock_feedback", { method: "support_mail" });
  }, [logEvent, t]);
  const [onboardingStep, setOnboardingStep] = useState("logo");
  const onboardingStepRef = useRef("logo");
  const onboardingHistoryRef = useRef([]);
  const [canGoBackOnboarding, setCanGoBackOnboarding] = useState(false);
  const [registrationData, setRegistrationData] = useState(INITIAL_REGISTRATION);
  const [termsModalVisible, setTermsModalVisible] = useState(false);
  const [termsAccepted, setTermsAccepted] = useState(false);
  const [termsContinuePending, setTermsContinuePending] = useState(false);
  const [showImageSourceSheet, setShowImageSourceSheet] = useState(false);
  const [showCustomSpend, setShowCustomSpend] = useState(false);
  const [quickSpendDraft, setQuickSpendDraft] = useState({
    title: "",
    amount: "",
    emoji: DEFAULT_TEMPTATION_EMOJI,
    category: DEFAULT_IMPULSE_CATEGORY,
  });
  useEffect(() => {
    onboardingStepRef.current = onboardingStep;
  }, [onboardingStep]);
  useEffect(() => {
    if (fontsLoaded) {
      ensureGlobalInterTypography();
    }
  }, [fontsLoaded]);
  useEffect(() => {
    if (fontsError) {
      console.warn("Inter font load error", fontsError);
    }
  }, [fontsError]);
  useEffect(() => {
    let mounted = true;
    AsyncStorage.getItem(STORAGE_KEYS.TAB_HINTS)
      .then((raw) => {
        if (!mounted) return;
        if (raw) {
          try {
            const parsed = JSON.parse(raw);
            if (parsed && typeof parsed === "object") {
              const { __disabled: _legacyDisabled, ...rest } = parsed;
              setTabHintsSeen({ ...DEFAULT_TAB_HINTS_STATE, ...(rest || {}) });
            } else {
              setTabHintsSeen(DEFAULT_TAB_HINTS_STATE);
            }
          } catch (error) {
            console.warn("tab hints parse", error);
            setTabHintsSeen(DEFAULT_TAB_HINTS_STATE);
          }
        } else {
          setTabHintsSeen(DEFAULT_TAB_HINTS_STATE);
        }
      })
      .catch(() => {
        setTabHintsSeen(DEFAULT_TAB_HINTS_STATE);
      })
      .finally(() => {
        if (mounted) setTabHintsHydrated(true);
      });
    return () => {
      mounted = false;
    };
  }, []);
  useEffect(() => {
    let mounted = true;
    AsyncStorage.getItem(STORAGE_KEYS.RATING_PROMPT)
      .then((raw) => {
        if (!mounted) return;
        if (raw) {
          try {
            const parsed = JSON.parse(raw);
            const fallback = createInitialRatingPromptState();
            const normalized = {
              firstOpenAt: typeof parsed?.firstOpenAt === "string" ? parsed.firstOpenAt : fallback.firstOpenAt,
              completed: Boolean(parsed?.completed),
              lastShownAt: typeof parsed?.lastShownAt === "string" ? parsed.lastShownAt : null,
              lastAction: typeof parsed?.lastAction === "string" ? parsed.lastAction : null,
              respondedAt: typeof parsed?.respondedAt === "string" ? parsed.respondedAt : null,
            };
            setRatingPromptState(normalized);
            const needsRewrite =
              normalized.firstOpenAt !== parsed?.firstOpenAt ||
              normalized.lastShownAt !== parsed?.lastShownAt ||
              normalized.lastAction !== parsed?.lastAction ||
              normalized.respondedAt !== parsed?.respondedAt ||
              normalized.completed !== Boolean(parsed?.completed);
            if (needsRewrite) {
              AsyncStorage.setItem(STORAGE_KEYS.RATING_PROMPT, JSON.stringify(normalized)).catch(() => {});
            }
            return;
          } catch (error) {
            console.warn("rating prompt hydrate", error);
          }
        }
        const initial = createInitialRatingPromptState();
        setRatingPromptState(initial);
        AsyncStorage.setItem(STORAGE_KEYS.RATING_PROMPT, JSON.stringify(initial)).catch(() => {});
      })
      .catch((error) => {
        console.warn("rating prompt hydrate", error);
      })
      .finally(() => {
        if (mounted) setRatingPromptHydrated(true);
      });
    return () => {
      mounted = false;
    };
  }, []);
  useEffect(() => {
    if (!tabHintsHydrated) return;
    AsyncStorage.setItem(STORAGE_KEYS.TAB_HINTS, JSON.stringify(tabHintsSeen)).catch(() => {});
  }, [tabHintsSeen, tabHintsHydrated]);
  useEffect(() => {
    if (!coinSliderHydrated) return;
    AsyncStorage.setItem(STORAGE_KEYS.COIN_SLIDER_MAX, String(coinSliderMaxUSD)).catch(() => {});
  }, [coinSliderHydrated, coinSliderMaxUSD]);
  useEffect(() => {
    beginHomeSession();
  }, [beginHomeSession]);
  useEffect(() => {
    tryLogHomeOpened();
  }, [tryLogHomeOpened]);
  useEffect(() => {
    if (!fabTutorialVisible) return;
    const timer = setTimeout(updateFabAnchor, 100);
    return () => clearTimeout(timer);
  }, [fabTutorialVisible, updateFabAnchor]);
  const fabTutorialBlocked = Boolean(overlay || dailySummaryVisible || priceEditor.item);
  useEffect(() => {
    if (
      fabTutorialState !== FAB_TUTORIAL_STATUS.SHOWING ||
      onboardingStep !== "done" ||
      tutorialVisible ||
      !homeLayoutReady ||
      startupLogoVisible ||
      fabTutorialBlocked
    ) {
      fabTutorialLoggedRef.current = false;
      if (fabTutorialVisible) {
        setFabTutorialVisible(false);
      }
      return;
    }
    const shouldShow = activeTab === "feed";
    if (fabTutorialVisible !== shouldShow) {
      setFabTutorialVisible(shouldShow);
    }
    if (shouldShow && !fabTutorialLoggedRef.current) {
      logEvent("fab_tutorial_shown");
      fabTutorialLoggedRef.current = true;
    }
  }, [
    activeTab,
    fabTutorialState,
    fabTutorialVisible,
    homeLayoutReady,
    logEvent,
    onboardingStep,
    startupLogoVisible,
    tutorialVisible,
    fabTutorialBlocked,
  ]);
  useEffect(() => {
    const handleAppStateChange = (nextState) => {
      const previousState = appStateRef.current;
      const wasBackground =
        typeof previousState === "string" && /inactive|background/.test(previousState);
      appStateRef.current = nextState;
      if (nextState !== "active") {
        setFabTutorialVisible(false);
        return;
      }
      if (wasBackground && nextState === "active") {
        processTamagotchiDecay();
        beginHomeSession();
        tryLogHomeOpened();
        if (pendingFocusDigest) {
          setFocusDigestPromptShown(false);
        }
      }
    };
    const subscription = AppState.addEventListener("change", handleAppStateChange);
    return () => subscription.remove();
  }, [
    beginHomeSession,
    pendingFocusDigest,
    processTamagotchiDecay,
    tryLogHomeOpened,
    setFabTutorialVisible,
  ]);
  useEffect(() => {
    if (!ratingPromptHydrated) return;
    if (ratingPromptCompleted) return;
    if (ratingPromptVisible) return;
    if (onboardingStep !== "done") return;
    const firstOpenDate = new Date(ratingPromptFirstOpenAt || "");
    if (Number.isNaN(firstOpenDate.getTime())) return;
    const daysElapsed = Math.floor((Date.now() - firstOpenDate.getTime()) / DAY_MS);
    if (daysElapsed < RATING_PROMPT_DELAY_DAYS) return;
    setRatingPromptVisible(true);
    updateRatingPromptState((prev) => ({
      ...prev,
      lastShownAt: new Date().toISOString(),
    }));
  }, [
    onboardingStep,
    ratingPromptHydrated,
    ratingPromptCompleted,
    ratingPromptFirstOpenAt,
    ratingPromptVisible,
    updateRatingPromptState,
  ]);
  useEffect(() => {
    if (!ratingPromptVisible) return;
    logEvent("rating_prompt_shown");
  }, [logEvent, ratingPromptVisible]);
  useEffect(() => {
    if (!focusStateHydrated) return;
    if (!focusTemplateId) {
      AsyncStorage.removeItem(STORAGE_KEYS.FOCUS_TARGET).catch(() => {});
      return;
    }
    AsyncStorage.setItem(
      STORAGE_KEYS.FOCUS_TARGET,
      JSON.stringify({ templateId: focusTemplateId, saveCount: focusSaveCount, updatedAt: Date.now() })
    ).catch(() => {});
  }, [focusSaveCount, focusStateHydrated, focusTemplateId]);
  useEffect(() => {
    if (!focusDigestHydrated) return;
    if (!focusDigestSeenKey) {
      AsyncStorage.removeItem(STORAGE_KEYS.FOCUS_DIGEST).catch(() => {});
      return;
    }
    AsyncStorage.setItem(STORAGE_KEYS.FOCUS_DIGEST, focusDigestSeenKey).catch(() => {});
  }, [focusDigestSeenKey, focusDigestHydrated]);
  useEffect(() => {
    if (!focusDigestHydrated) return;
    if (!pendingFocusDigest) {
      AsyncStorage.removeItem(STORAGE_KEYS.FOCUS_DIGEST_PENDING).catch(() => {});
      return;
    }
    AsyncStorage.setItem(STORAGE_KEYS.FOCUS_DIGEST_PENDING, JSON.stringify(pendingFocusDigest)).catch(() => {});
  }, [pendingFocusDigest, focusDigestHydrated]);
  const openTamagotchiOverlay = useCallback(() => setTamagotchiVisible(true), []);
  const closeTamagotchiOverlay = useCallback(() => setTamagotchiVisible(false), []);
  const [fabMenuVisible, setFabMenuVisible] = useState(false);
  const fabMenuAnim = useRef(new Animated.Value(0)).current;
  const tamagotchiMood = useMemo(
    () => getTamagotchiMood(tamagotchiState.hunger, language),
    [tamagotchiState.hunger, language]
  );
  const beginHomeSession = useCallback(() => {
    const todayKey = getDayKey(Date.now());
    if (homeSessionRef.current.dateKey !== todayKey) {
      homeSessionRef.current.dateKey = todayKey;
      homeSessionRef.current.sessionCount = 0;
    }
    homeSessionRef.current.sessionCount += 1;
    const sessionCount = homeSessionRef.current.sessionCount;
    setFabTutorialEligible((prev) => {
      if (prev) return prev;
      return sessionCount >= FAB_TUTORIAL_MIN_SESSIONS;
    });
    homeSessionRef.current.pendingIndex = homeSessionRef.current.sessionCount;
    if (
      onboardingStepRef.current === "done" &&
      fabTutorialStateRef.current === FAB_TUTORIAL_STATUS.PENDING
    ) {
      setFabTutorialStateAndPersist(FAB_TUTORIAL_STATUS.SHOWING);
    }
  }, [setFabTutorialStateAndPersist]);
  const tryLogHomeOpened = useCallback(() => {
    if (activeTab !== "feed") return;
    const pendingIndex = homeSessionRef.current.pendingIndex;
    if (!pendingIndex) return;
    logEvent("home_opened", { session_index: pendingIndex });
    homeSessionRef.current.pendingIndex = null;
  }, [activeTab, logEvent]);
  const isFabTutorialEnvironmentReady = useMemo(
    () =>
      onboardingStep === "done" &&
      homeLayoutReady &&
      !tutorialVisible &&
      !startupLogoVisible,
    [homeLayoutReady, onboardingStep, startupLogoVisible, tutorialVisible]
  );
  useEffect(() => {
    if (
      fabTutorialState === FAB_TUTORIAL_STATUS.PENDING &&
      fabTutorialEligible &&
      isFabTutorialEnvironmentReady
    ) {
      setFabTutorialStateAndPersist(FAB_TUTORIAL_STATUS.SHOWING);
    }
  }, [
    fabTutorialEligible,
    fabTutorialState,
    isFabTutorialEnvironmentReady,
    setFabTutorialStateAndPersist,
  ]);
  const tamagotchiHungerPercent = useMemo(
    () => Math.min(TAMAGOTCHI_MAX_HUNGER, Math.max(0, tamagotchiState.hunger)),
    [tamagotchiState.hunger]
  );
  const tamagotchiIsFull = tamagotchiHungerPercent >= TAMAGOTCHI_MAX_HUNGER;
  const tamagotchiCoins = healthPoints;
  const tamagotchiDesiredFood =
    TAMAGOTCHI_FOOD_MAP[tamagotchiState.desiredFoodId] ||
    TAMAGOTCHI_FOOD_MAP[TAMAGOTCHI_DEFAULT_FOOD_ID];
  const [newPendingModal, setNewPendingModal] = useState({
    visible: false,
    title: "",
    amount: "",
    emoji: DEFAULT_TEMPTATION_EMOJI,
  });
  const [newGoalModal, setNewGoalModal] = useState({
    visible: false,
    name: "",
    target: "",
    emoji: DEFAULT_GOAL_EMOJI,
    makePrimary: false,
    source: "unknown",
  });
  const openNewPendingModal = useCallback(
    () =>
      setNewPendingModal({
        visible: true,
        title: "",
        amount: "",
        emoji: DEFAULT_TEMPTATION_EMOJI,
      }),
    []
  );
  const openNewGoalModal = useCallback(
    (makePrimary = false, source = "unknown") => {
      setNewGoalModal({
        visible: true,
        name: "",
        target: "",
        emoji: DEFAULT_GOAL_EMOJI,
        makePrimary,
        source,
      });
      logEvent("goal_creator_opened", {
        source,
        make_primary: makePrimary ? 1 : 0,
      });
    },
    [logEvent]
  );
  const handleNewPendingChange = useCallback((field, value) => {
    setNewPendingModal((prev) => ({
      ...prev,
      [field]: field === "emoji" ? limitEmojiInput(value) : value,
    }));
  }, []);
  const handleNewPendingCancel = useCallback(() => {
    setNewPendingModal({ visible: false, title: "", amount: "", emoji: DEFAULT_TEMPTATION_EMOJI });
  }, []);
  const [onboardingGoalModal, setOnboardingGoalModal] = useState({
    visible: false,
    name: "",
    target: "",
    emoji: DEFAULT_GOAL_EMOJI,
  });
  const openFabMenu = useCallback(() => {
    if (fabMenuVisible) return;
    setFabMenuVisible(true);
    Animated.spring(fabMenuAnim, {
      toValue: 1,
      friction: 7,
      tension: 120,
      useNativeDriver: true,
    }).start();
  }, [fabMenuAnim, fabMenuVisible]);
  const closeFabMenu = useCallback(() => {
    Animated.timing(fabMenuAnim, {
      toValue: 0,
      duration: 160,
      easing: Easing.out(Easing.quad),
      useNativeDriver: true,
    }).start(() => setFabMenuVisible(false));
  }, [fabMenuAnim]);
  const handleFabPress = useCallback(() => {
    Keyboard.dismiss();
    handleFabTutorialDismiss("tap");
    triggerHaptic();
    if (fabMenuVisible) {
      closeFabMenu();
    }
    if (activeTab === "cart") {
      openNewGoalModal(false, "fab_cart");
    } else if (activeTab === "pending") {
      openNewPendingModal();
    } else {
      openCoinEntry(activeTab || "unknown");
    }
  }, [
    activeTab,
    closeFabMenu,
    fabMenuVisible,
    handleFabTutorialDismiss,
    openCoinEntry,
    openNewGoalModal,
    openNewPendingModal,
    triggerHaptic,
  ]);
  const handleFabLongPress = useCallback(() => {
    Keyboard.dismiss();
    handleFabTutorialDismiss("hold");
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    if (fabMenuVisible) {
      closeFabMenu();
    } else {
      openFabMenu();
    }
  }, [closeFabMenu, fabMenuVisible, handleFabTutorialDismiss, openFabMenu, triggerHaptic]);
  useEffect(() => {
    if (activeTab === "profile" && fabMenuVisible) {
      closeFabMenu();
    }
  }, [activeTab, closeFabMenu, fabMenuVisible]);
  const imagePickerResolver = useRef(null);
  const [refuseStats, setRefuseStats] = useState({});
  const [temptationInteractions, setTemptationInteractions] = useState({});
  const [temptationInteractionsHydrated, setTemptationInteractionsHydrated] = useState(false);
  const [impulseTracker, setImpulseTracker] = useState({ ...INITIAL_IMPULSE_TRACKER });
  const [moodState, setMoodState] = useState(() => createMoodStateForToday());
  const [cardFeedback, setCardFeedback] = useState({});
  const [moodHydrated, setMoodHydrated] = useState(false);
  const editOverlayAnim = useRef(new Animated.Value(0)).current;
  const [editOverlayVisible, setEditOverlayVisible] = useState(false);
  const cardFeedbackTimers = useRef({});
  const impulseAlertCooldownRef = useRef({});
  const lastInstantNotificationRef = useRef(0);
  const [notificationPermissionGranted, setNotificationPermissionGranted] = useState(null);
  const [spendPrompt, setSpendPrompt] = useState({ visible: false, item: null });
  const [stormActive, setStormActive] = useState(false);
  const safeAreaInsets = useSafeAreaInsets();
  const iosTabInset = Platform.OS === "ios" ? Math.max((safeAreaInsets.bottom || 0) - 8, 0) : 0;
  const tabBarBottomInset = iosTabInset;
  const resolvedTabBarHeight = tabBarHeight || tabBarBottomInset + TAB_BAR_BASE_HEIGHT;
  const tutorialOverlayInset = resolvedTabBarHeight;
  const tutorialCardOffset = resolvedTabBarHeight + (Platform.OS === "ios" ? 64 : 72);
  const topSafeInset =
    Platform.OS === "android" ? RNStatusBar.currentHeight || 24 : safeAreaInsets.top || 0;
  const [keyboardInset, setKeyboardInset] = useState(0);
  const [keyboardVisible, setKeyboardVisible] = useState(false);

  useEffect(() => {
    const showEvent = Platform.OS === "ios" ? "keyboardWillShow" : "keyboardDidShow";
    const hideEvent = Platform.OS === "ios" ? "keyboardWillHide" : "keyboardDidHide";
    const handleKeyboardShow = (event = {}) => {
      const keyboardHeight = event.endCoordinates?.height || 0;
      const safeGap = Math.max(0, keyboardHeight - tabBarBottomInset);
      const buffer = Platform.OS === "ios" ? 12 : 0;
      setKeyboardInset(safeGap ? safeGap + buffer : buffer);
      setKeyboardVisible(true);
    };
    const handleKeyboardHide = () => {
      setKeyboardInset(0);
      setKeyboardVisible(false);
    };
    const showSub = Keyboard.addListener(showEvent, handleKeyboardShow);
    const hideSub = Keyboard.addListener(hideEvent, handleKeyboardHide);
    return () => {
      showSub.remove();
      hideSub.remove();
    };
  }, [tabBarBottomInset]);
  const shouldRenderStatusGlass = Platform.OS === "ios" && topSafeInset > 0;
  const statusBlurAvailable = useMemo(() => {
    if (!shouldRenderStatusGlass) return false;
    const viewName = "ViewManagerAdapter_ExpoBlurView";
    if (typeof UIManager.getViewManagerConfig === "function") {
      return !!UIManager.getViewManagerConfig(viewName);
    }
    return !!UIManager[viewName];
  }, [shouldRenderStatusGlass]);
  const screenKeyboardAdjustmentStyle = useMemo(() => {
    if (Platform.OS === "ios") return null;
    return keyboardInset ? { paddingBottom: keyboardInset } : null;
  }, [keyboardInset]);

  const keyboardModalOffset = useMemo(() => {
    if (!keyboardInset) return 0;
    const effectiveInset =
      Platform.OS === "ios" ? keyboardInset * 0.6 : keyboardInset;
    return Math.min(effectiveInset, MAX_MODAL_KEYBOARD_OFFSET);
  }, [keyboardInset]);

  const modalKeyboardPaddingStyle = useMemo(
    () => (keyboardModalOffset ? { paddingBottom: keyboardModalOffset } : null),
    [keyboardModalOffset]
  );

  const fabTutorialCutout = useMemo(() => {
    const radius = FAB_TUTORIAL_HALO_SIZE / 2;
    const fallbackCenterX = SCREEN_WIDTH / 2;
    const androidStatusBarOffset = Platform.OS === "android" ? RNStatusBar.currentHeight || 0 : 0;
    const fallbackCenterY =
      SCREEN_HEIGHT - (tabBarBottomInset + FAB_CONTAINER_BOTTOM + FAB_BUTTON_SIZE / 2) + androidStatusBarOffset;
    const centerX = fabTutorialAnchor?.x ?? fallbackCenterX;
    const centerY = fabTutorialAnchor?.y ?? fallbackCenterY;
    const top = Math.max(0, centerY - radius);
    const bottom = Math.min(SCREEN_HEIGHT, centerY + radius);
    const left = Math.max(0, centerX - radius);
    const right = Math.min(SCREEN_WIDTH, centerX + radius);
    return {
      top,
      bottom,
      left,
      right,
      height: Math.max(0, bottom - top),
      width: Math.max(0, right - left),
      centerX,
      centerY,
    };
  }, [fabTutorialAnchor, tabBarBottomInset]);
  const [analyticsOptOut, setAnalyticsOptOutState] = useState(null);
  const [startupLogoVisible, setStartupLogoVisible] = useState(false);
  const startupLogoDismissedRef = useRef(false);
  const overlayEnvironmentReady =
    onboardingStep === "done" && homeLayoutReady && !startupLogoVisible && !dailySummaryVisible;

  const goToOnboardingStep = useCallback(
    (nextStep, { recordHistory = true, resetHistory = false } = {}) => {
      if (resetHistory) {
        onboardingHistoryRef.current = [];
        setCanGoBackOnboarding(false);
      }
      setOnboardingStep((prev) => {
        if (recordHistory && prev && prev !== nextStep) {
          const nextHistory = [...onboardingHistoryRef.current, prev];
          onboardingHistoryRef.current = nextHistory;
          setCanGoBackOnboarding(nextHistory.length > 0);
        }
        return nextStep;
      });
    },
    []
  );

  const handleOnboardingBack = useCallback(() => {
    if (!onboardingHistoryRef.current.length) return;
    const history = [...onboardingHistoryRef.current];
    const prevStep = history.pop();
    onboardingHistoryRef.current = history;
    setCanGoBackOnboarding(history.length > 0);
    setOnboardingStep(prevStep);
  }, []);
  const stormTimerRef = useRef(null);
  const [rewardCelebratedMap, setRewardCelebratedMap] = useState({});
  const [rewardCelebratedHydrated, setRewardCelebratedHydrated] = useState(false);
  const [rewardsReady, setRewardsReady] = useState(false);
  const challengesPrevRef = useRef(challengesState);
  const [temptationGoalMap, setTemptationGoalMap] = useState({});
  const [goalLinkPrompt, setGoalLinkPrompt] = useState({ visible: false, item: null, intent: null });
  const [goalTemptationPrompt, setGoalTemptationPrompt] = useState({ visible: false, wish: null });
  const [goalEditorPrompt, setGoalEditorPrompt] = useState({
    visible: false,
    wish: null,
    name: "",
    target: "",
    emoji: DEFAULT_GOAL_EMOJI,
  });
  const [goalRenewalPromptVisible, setGoalRenewalPromptVisible] = useState(false);
  const goalRenewalPromptPendingRef = useRef(false);
  const dismissGoalRenewalPrompt = useCallback(() => {
    goalRenewalPromptPendingRef.current = false;
    setGoalRenewalPromptVisible(false);
  }, []);
  const requestGoalRenewalPrompt = useCallback(() => {
    if (goalRenewalPromptVisible) return;
    if (overlay) {
      goalRenewalPromptPendingRef.current = true;
      return;
    }
    goalRenewalPromptPendingRef.current = false;
    setGoalRenewalPromptVisible(true);
  }, [goalRenewalPromptVisible, overlay]);
  const [moodDetailsVisible, setMoodDetailsVisible] = useState(false);
  const [potentialDetailsVisible, setPotentialDetailsVisible] = useState(false);
  const [potentialDetailsText, setPotentialDetailsText] = useState("");
  const openMoodDetails = useCallback(() => setMoodDetailsVisible(true), []);
  const closeMoodDetails = useCallback(() => setMoodDetailsVisible(false), []);
  const openPotentialDetails = useCallback((description) => {
    setPotentialDetailsText(description);
    setPotentialDetailsVisible(true);
  }, []);
  const closePotentialDetails = useCallback(() => setPotentialDetailsVisible(false), []);
  const openSavingsBreakdown = useCallback(() => setSavingsBreakdownVisible(true), []);
  const closeSavingsBreakdown = useCallback(() => setSavingsBreakdownVisible(false), []);
  const openGoalLinkPrompt = useCallback((item, intent = "edit") => {
    if (!item) return;
    setGoalLinkPrompt({ visible: true, item, intent });
  }, []);
  const [moodGradient, setMoodGradient] = useState(() =>
    applyThemeToMoodGradient(getMoodGradient(), theme)
  );
  const mainGoalWish = useMemo(
    () => selectMainGoalWish(wishes, activeGoalId || profile.goal),
    [wishes, activeGoalId, profile.goal]
  );
  useEffect(() => {
    if (mainGoalWish?.id) {
      ensureGoalManualTracking(mainGoalWish.id);
    }
  }, [mainGoalWish?.id, ensureGoalManualTracking]);
  const savingsBreakdown = useMemo(
    () =>
      buildSavingsBreakdown(
        resolvedHistoryEvents,
        profile.currency || DEFAULT_PROFILE.currency,
        resolveTemplateTitle,
        language
      ),
    [resolvedHistoryEvents, profile.currency, resolveTemplateTitle, language]
  );
  const fallbackGoalTargetUSD = useMemo(() => {
    if (Number.isFinite(profile?.goalTargetUSD) && profile.goalTargetUSD > 0) {
      return profile.goalTargetUSD;
    }
    return getGoalDefaultTargetUSD(profile?.goal || DEFAULT_PROFILE.goal);
  }, [profile?.goalTargetUSD, profile?.goal]);
  const heroGoalTargetUSD = mainGoalWish?.targetUSD || fallbackGoalTargetUSD;
  const heroGoalSavedUSD = mainGoalWish?.savedUSD ?? 0;
  const activeGender = profile.gender || registrationData.gender || DEFAULT_PROFILE.gender || "none";
  const analyticsOptOutValue = analyticsOptOut ?? false;
  const activeTutorialStep =
    APP_TUTORIAL_STEPS[tutorialStepIndex] ||
    APP_TUTORIAL_STEPS[APP_TUTORIAL_STEPS.length - 1] ||
    null;
  const tutorialHighlightTabs = useMemo(() => {
    if (!tutorialVisible || !activeTutorialStep?.tabs?.length) return null;
    return new Set(activeTutorialStep.tabs);
  }, [tutorialVisible, activeTutorialStep]);
  const fabOverlayColor = theme === "dark" ? "rgba(5,7,13,0.78)" : "rgba(5,7,13,0.55)";
  const resolveTranslationValue = useCallback((key) => {
    const normalizedLanguage = normalizeLanguage(language);
    const override = LANGUAGE_OVERRIDES[normalizedLanguage]?.[key];
    const dictionary = TRANSLATIONS[normalizedLanguage] || {};
    let raw =
      override !== undefined
        ? override
        : dictionary[key] ??
          TRANSLATIONS[FALLBACK_LANGUAGE]?.[key] ??
          TRANSLATIONS[DEFAULT_LANGUAGE]?.[key];
    if (raw && typeof raw === "object" && !Array.isArray(raw)) {
      const genderValue = raw[activeGender];
      if (typeof genderValue === "string") {
        raw = genderValue;
      } else if (typeof raw.none === "string") {
        raw = raw.none;
      } else {
        const fallbackValue = Object.values(raw).find((value) => typeof value === "string");
        raw = fallbackValue !== undefined ? fallbackValue : undefined;
      }
    }
    return raw;
  }, [activeGender, language]);

  const formatTranslationText = useCallback((value, replacements = {}) => {
    let text = value;
    if (text === undefined || text === null) {
      text = "";
    }
    text = String(text);
    Object.entries(replacements).forEach(([token, tokenValue]) => {
      text = text.replace(`{{${token}}}`, tokenValue);
    });
    return text;
  }, []);

  const t = useCallback(
    (key, replacements = {}) => {
      const resolved = resolveTranslationValue(key);
      const base = Array.isArray(resolved) ? resolved[0] : resolved;
      const fallback = base === undefined || base === null ? key : base;
      return formatTranslationText(fallback, replacements);
    },
    [formatTranslationText, resolveTranslationValue]
  );

  const tVariant = useCallback(
    (key, replacements = {}) => {
      const resolved = resolveTranslationValue(key);
      const pool = Array.isArray(resolved)
        ? resolved.filter((value) => typeof value === "string" && value.trim().length > 0)
        : typeof resolved === "string"
        ? [resolved]
        : [];
      const pickSource = pool.length ? pool : [resolved ?? key];
      const choice = pickSource[Math.floor(Math.random() * pickSource.length)] ?? key;
      const fallback = choice === undefined || choice === null ? key : choice;
      return formatTranslationText(fallback, replacements);
    },
    [formatTranslationText, resolveTranslationValue]
  );
  const formatHealthRewardText = useCallback(
    (amount) => formatHealthRewardLabel(amount, language),
    [language]
  );
  const dailyChallengeDisplayTitle = useMemo(
    () =>
      dailyChallenge.templateLabel ||
      dailyChallenge.templateTitle ||
      t("defaultDealTitle"),
    [dailyChallenge.templateLabel, dailyChallenge.templateTitle, t]
  );
  const dailyChallengeRewardLabel = useMemo(
    () => formatHealthRewardText(dailyChallenge.rewardBonus || 0),
    [dailyChallenge.rewardBonus, formatHealthRewardText]
  );
  const currentMood = useMemo(
    () => deriveMoodFromState(moodState, pendingList.length),
    [moodState.events, moodState.lastInteractionAt, moodState.lastVisitAt, pendingList.length]
  );
  const moodPreset = useMemo(() => getMoodPreset(currentMood, language), [currentMood, language]);
  useEffect(() => {
    setMoodGradient(applyThemeToMoodGradient(getMoodGradient(moodPreset?.id), theme));
  }, [moodPreset?.id, theme]);
  const moodGoalInfo = useMemo(() => {
    const aggregatedTargetUSD = heroGoalTargetUSD || 0;
    const savedUSD = heroGoalSavedUSD || 0;
    const isComplete = aggregatedTargetUSD > 0 && savedUSD >= aggregatedTargetUSD;
    return { aggregatedTargetUSD, savedUSD, isComplete };
  }, [heroGoalTargetUSD, heroGoalSavedUSD]);
  const moodDescription = useMemo(() => {
    if (!moodPreset) return "";
    const baseLine = moodGoalInfo.isComplete
      ? moodPreset.heroComplete || t("goalWidgetCompleteTagline")
      : moodPreset.hero || t("heroEconomyContinues");
    return moodPreset.motivation ? `${baseLine} ${moodPreset.motivation}` : baseLine;
  }, [moodGoalInfo.isComplete, moodPreset, t]);
  const moodSessionRecordedRef = useRef(false);
  useEffect(() => {
    if (moodSessionRecordedRef.current) return;
    moodSessionRecordedRef.current = true;
    const now = Date.now();
    setMoodState((prev) =>
      evaluateMoodState(
        {
          ...prev,
          lastVisitAt: now,
        },
        { now, pendingCount: pendingList.length }
      )
    );
  }, [pendingList.length]);
  useEffect(() => {
    if (!moodHydrated) return;
    AsyncStorage.setItem(STORAGE_KEYS.MOOD_STATE, JSON.stringify(moodState)).catch(() => {});
  }, [moodState, moodHydrated]);

  useEffect(() => {
    const now = Date.now();
    const mappedEvents = mapHistoryEventsToMoodEvents(resolvedHistoryEvents, now);
    const latestTimestamp = mappedEvents[0]?.timestamp || null;
    setMoodState((prev) =>
      evaluateMoodState(
        {
          ...prev,
          events: mappedEvents,
          lastInteractionAt: latestTimestamp || prev.lastInteractionAt,
        },
        { now, pendingCount: pendingList.length }
      )
    );
  }, [resolvedHistoryEvents, pendingList.length]);

  useEffect(() => {
    setMoodState((prev) =>
      evaluateMoodState(
        { ...prev, pendingSnapshot: pendingList.length },
        { pendingCount: pendingList.length }
      )
    );
  }, [pendingList.length]);

  const refreshMoodForToday = useCallback(() => {
    const todayKey = getDayKey(Date.now());
    setMoodState((prev) => {
      if (prev.dayKey === todayKey) return prev;
      const refreshed = evaluateMoodState(
        createMoodStateForToday({
          pendingSnapshot: pendingList.length,
          lastVisitAt: Date.now(),
          dayKey: todayKey,
        }),
        { pendingCount: pendingList.length }
      );
      return refreshed;
    });
  }, [pendingList.length]);

  useEffect(() => {
    let timer = null;
    const scheduleNextUpdate = () => {
      const now = new Date();
      const nextMidnight = new Date(now);
      nextMidnight.setHours(24, 0, 0, 0);
      const delay = Math.max(nextMidnight.getTime() - now.getTime() + 1000, 60 * 1000);
      timer = setTimeout(() => {
        refreshMoodForToday();
        scheduleNextUpdate();
      }, delay);
    };
    refreshMoodForToday();
    scheduleNextUpdate();
    return () => {
      if (timer) {
        clearTimeout(timer);
      }
    };
  }, [refreshMoodForToday]);
  const ensureNotificationPermission = useCallback(async () => {
    try {
      let settings = await Notifications.getPermissionsAsync();
      let granted =
        settings.granted ||
        settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL;
      if (!granted) {
        settings = await Notifications.requestPermissionsAsync();
        granted =
          settings.granted ||
          settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL;
      }
      setNotificationPermissionGranted(granted);
      return granted;
    } catch (error) {
      console.warn("notifications", error);
      setNotificationPermissionGranted(false);
      return false;
    }
  }, []);

  useEffect(() => {
    ensureNotificationPermission();
  }, [ensureNotificationPermission]);

  const sendImmediateNotification = useCallback(
    async (content) => {
      if (!content) return false;
      const now = Date.now();
      if (now - lastInstantNotificationRef.current < PUSH_NOTIFICATION_COOLDOWN_MS) {
        return false;
      }
      const allowed = await ensureNotificationPermission();
      if (!allowed) return false;
      try {
        await Notifications.scheduleNotificationAsync({
          content,
          trigger: null,
        });
        lastInstantNotificationRef.current = now;
        return true;
      } catch (error) {
        console.warn("immediate notification", error);
        return false;
      }
    },
    [ensureNotificationPermission]
  );

  useEffect(() => {
    if (Platform.OS !== "android") return;
    Notifications.setNotificationChannelAsync(ANDROID_DAILY_NUDGE_CHANNEL_ID, {
      name: "Daily nudges",
      importance: Notifications.AndroidImportance.HIGH,
      sound: true,
      vibrationPattern: [250, 250, 250],
      lockscreenVisibility: Notifications.AndroidNotificationVisibility.PUBLIC,
    }).catch(() => {});
  }, []);

  useEffect(() => {
    dailyNudgeIdsRef.current = dailyNudgeNotificationIds || {};
  }, [dailyNudgeNotificationIds]);

  useEffect(() => {
    smartRemindersRef.current = smartReminders || [];
  }, [smartReminders]);

  useEffect(() => {
    if (!potentialPushHydrated) return;
    const currencyForStep = profile?.currency || DEFAULT_PROFILE.currency;
    const stepUSD = resolvePotentialPushStepUSD(currencyForStep);
    if (!Number.isFinite(stepUSD) || stepUSD <= 0) return;
    if (!potentialBaselineKey) {
      if (
        potentialPushProgress.baselineKey ||
        potentialPushProgress.lastStep ||
        potentialPushProgress.lastStatus ||
        potentialPushProgress.stepMultiplier !== 1 ||
        potentialPushProgress.lastNotifiedAt
      ) {
        setPotentialPushProgress({ ...DEFAULT_POTENTIAL_PUSH_STATE });
      }
      return;
    }
    const resolvedPotential = Number.isFinite(potentialSavedUSD) ? potentialSavedUSD : 0;
    const currentStep = Math.max(0, Math.floor(resolvedPotential / stepUSD));
    const lastStep = Math.max(0, Number(potentialPushProgress.lastStep) || 0);
    const now = Date.now();
    const lastNotifiedAt = Number(potentialPushProgress.lastNotifiedAt) || 0;
    const rawMultiplier = Math.max(1, Number(potentialPushProgress.stepMultiplier) || 1);
    const cooledDown =
      rawMultiplier > 1 &&
      lastNotifiedAt > 0 &&
      now - lastNotifiedAt > POTENTIAL_PUSH_COOLDOWN_WINDOW_MS;
    const stepMultiplier = cooledDown
      ? 1
      : Math.min(rawMultiplier, POTENTIAL_PUSH_MAX_MULTIPLIER);
    if (cooledDown) {
      setPotentialPushProgress((prev) => {
        if (prev.baselineKey !== potentialBaselineKey || prev.stepMultiplier <= 1) return prev;
        return { ...prev, stepMultiplier: 1 };
      });
    }
    if (potentialPushProgress.baselineKey !== potentialBaselineKey) {
      setPotentialPushProgress({
        ...DEFAULT_POTENTIAL_PUSH_STATE,
        lastStep: currentStep,
        baselineKey: potentialBaselineKey,
      });
      return;
    }
    if (currentStep < lastStep) {
      setPotentialPushProgress((prev) => ({
        ...prev,
        lastStep: currentStep,
      }));
      return;
    }
    if (!profileHydrated || !savedTotalHydrated) return;
    if (currentStep <= 0 || currentStep <= lastStep) return;
    const stepGap = currentStep - lastStep;
    const requiredGap = stepMultiplier;
    if (stepGap < requiredGap) return;
    const fastGain =
      lastNotifiedAt > 0 && now - lastNotifiedAt < POTENTIAL_PUSH_FAST_GAIN_WINDOW_MS;
    if (fastGain && stepMultiplier < POTENTIAL_PUSH_MAX_MULTIPLIER) {
      setPotentialPushProgress((prev) => {
        if (prev.baselineKey !== potentialBaselineKey) return prev;
        if (prev.stepMultiplier >= POTENTIAL_PUSH_MAX_MULTIPLIER) return prev;
        return { ...prev, stepMultiplier: POTENTIAL_PUSH_MAX_MULTIPLIER };
      });
      return;
    }
    let cancelled = false;
    const notify = async () => {
      const ahead = savedTotalUSD >= resolvedPotential && savedTotalUSD > 0;
      const status = ahead ? "ahead" : "behind";
      const formatLocal = (valueUSD = 0) =>
        formatCurrency(convertToCurrency(Math.max(valueUSD, 0), currencyForStep), currencyForStep);
      const replacements = {
        potential: formatLocal(resolvedPotential),
        actual: formatLocal(savedTotalUSD),
        shortfall: formatLocal(Math.max(resolvedPotential - savedTotalUSD, 0)),
      };
      await sendImmediateNotification({
        title: t(
          status === "ahead" ? "potentialPushAheadTitle" : "potentialPushBehindTitle",
          replacements
        ),
        body: t(
          status === "ahead" ? "potentialPushAheadBody" : "potentialPushBehindBody",
          replacements
        ),
      });
      if (cancelled) return;
      setPotentialPushProgress({
        lastStep: currentStep,
        lastStatus: status,
        baselineKey: potentialBaselineKey,
        stepMultiplier,
        lastNotifiedAt: now,
      });
    };
    notify().catch(() => {});
    return () => {
      cancelled = true;
    };
  }, [
    potentialBaselineKey,
    potentialPushHydrated,
    potentialPushProgress.baselineKey,
    potentialPushProgress.lastNotifiedAt,
    potentialPushProgress.lastStatus,
    potentialPushProgress.lastStep,
    potentialPushProgress.stepMultiplier,
    potentialSavedUSD,
    profile?.currency,
    profileHydrated,
    savedTotalHydrated,
    savedTotalUSD,
    sendImmediateNotification,
    t,
  ]);

  useEffect(() => {
    if (!profileHydrated || !customReminderHydrated) return;
    schedulePersonalTemptationReminder(profile.customSpend);
  }, [customReminderHydrated, profile.customSpend, profileHydrated, schedulePersonalTemptationReminder]);

  useEffect(() => {
    const tick = () => {
      setChallengesState((prev) => expireChallenges(prev));
    };
    tick();
    const interval = setInterval(tick, 60000);
    return () => clearInterval(interval);
  }, []);

  useEffect(() => {
    const staleEntries = Object.values(challengesState).filter(
      (entry) => entry?.reminderNotificationIds?.length && entry.status !== CHALLENGE_STATUS.ACTIVE
    );
    if (!staleEntries.length) return;
    staleEntries.forEach((entry) => {
      entry.reminderNotificationIds.forEach((id) => {
        Notifications.cancelScheduledNotificationAsync(id).catch(() => {});
      });
    });
    setChallengesState((prev) => {
      let changed = false;
      const next = { ...prev };
      staleEntries.forEach((entry) => {
        if (next[entry.id]?.reminderNotificationIds?.length) {
          next[entry.id] = { ...next[entry.id], reminderNotificationIds: [] };
          changed = true;
        }
      });
      return changed ? next : prev;
    });
  }, [challengesState]);

  useEffect(() => {
    const prev = challengesPrevRef.current || {};
    const completedIds = [];
    const expiredIds = [];
    Object.keys(challengesState).forEach((id) => {
      const previousStatus = prev[id]?.status;
      const nextStatus = challengesState[id]?.status;
      if (nextStatus === CHALLENGE_STATUS.COMPLETED && previousStatus !== CHALLENGE_STATUS.COMPLETED) {
        completedIds.push(id);
      } else if (
        nextStatus === CHALLENGE_STATUS.EXPIRED &&
        previousStatus === CHALLENGE_STATUS.ACTIVE
      ) {
        expiredIds.push(id);
      }
    });
    completedIds.forEach((challengeId) => {
      const def = CHALLENGE_DEF_MAP[challengeId];
      if (!def) return;
      const copy = getChallengeCopy(def, language);
      const title = copy.title || challengeId;
      triggerOverlayState("reward", t("challengeCompletedOverlay", { title }));
      logEvent("challenge_completed", { challenge_id: challengeId, success: true });
    });
    expiredIds.forEach((challengeId) => {
      logEvent("challenge_completed", { challenge_id: challengeId, success: false });
    });
    challengesPrevRef.current = challengesState;
  }, [challengesState, language, logEvent, t, triggerOverlayState]);

  useEffect(() => {
    impulseAlertCooldownRef.current = impulseTracker.lastAlerts || {};
  }, [impulseTracker.lastAlerts]);


  useEffect(() => {
    return () => {
      if (stormTimerRef.current) {
        clearTimeout(stormTimerRef.current);
      }
    };
  }, []);

  const schedulePendingReminder = useCallback(
    async (title, dueDate) => {
      try {
        const allowed = await ensureNotificationPermission();
        if (!allowed) return null;
        const trigger = new Date(dueDate);
        const pendingTitle =
          moodPreset?.pushPendingTitle && moodPreset.pushPendingTitle.trim()
            ? renderTemplateString(moodPreset.pushPendingTitle, { title })
            : t("pendingNotificationTitle");
        const pendingBody =
          moodPreset?.pushPendingBody && moodPreset.pushPendingBody.trim()
            ? renderTemplateString(moodPreset.pushPendingBody, { title })
            : t("pendingNotificationBody", { title });
        return await Notifications.scheduleNotificationAsync({
          content: {
            title: pendingTitle,
            body: pendingBody,
          },
          trigger,
        });
      } catch (error) {
        console.warn("pending reminder", error);
        return null;
      }
    },
    [ensureNotificationPermission, t, moodPreset]
  );

  const scheduleChallengeReminders = useCallback(
    async (challengeId, def, startAt, expiresAt) => {
      if (!def?.reminderOffsetsHours?.length) return [];
      const permitted = await ensureNotificationPermission();
      if (!permitted) return [];
      const copy = getChallengeCopy(def, language);
      const title = t("challengeReminderTitle", { title: copy.title || challengeId });
      const body = t("challengeReminderBody", { title: copy.title || challengeId });
      const scheduled = [];
      const challengeHash = hashString(challengeId || "");
      const jitterMinutes = challengeHash % 11;
      const windows =
        CHALLENGE_REMINDER_WINDOWS.length > 0
          ? [
              ...CHALLENGE_REMINDER_WINDOWS.slice(challengeHash % CHALLENGE_REMINDER_WINDOWS.length),
              ...CHALLENGE_REMINDER_WINDOWS.slice(0, challengeHash % CHALLENGE_REMINDER_WINDOWS.length),
            ]
          : [];
      for (let index = 0; index < def.reminderOffsetsHours.length; index += 1) {
        const offsetHours = def.reminderOffsetsHours[index];
        const triggerTime = startAt + offsetHours * 60 * 60 * 1000;
        if (!Number.isFinite(triggerTime) || triggerTime <= Date.now()) continue;
        if (expiresAt && triggerTime >= expiresAt) continue;
        const slot = windows[index % (windows.length || 1)];
        let scheduledTime = alignReminderSlotTime(triggerTime, slot, jitterMinutes);
        if (expiresAt && scheduledTime >= expiresAt) {
          scheduledTime = triggerTime + jitterMinutes * 60 * 1000;
        }
        if (!Number.isFinite(scheduledTime)) continue;
        if (expiresAt && scheduledTime >= expiresAt) continue;
        try {
          const notificationId = await Notifications.scheduleNotificationAsync({
            content: { title, body },
            trigger: new Date(scheduledTime),
          });
          scheduled.push(notificationId);
        } catch (error) {
          console.warn("challenge reminder", error);
        }
      }
      return scheduled;
    },
    [ensureNotificationPermission, language, t]
  );

  const categories = useMemo(() => {
    const set = new Set(["all"]);
    products.forEach((product) => product.categories?.forEach((c) => set.add(c)));
    return Array.from(set);
  }, [products]);

  const filteredProducts = useMemo(() => {
    if (activeCategory === "all") return products;
    return products.filter((product) => product.categories?.includes(activeCategory));
  }, [products, activeCategory]);
  const customGoalMap = useMemo(() => {
    const entries = registrationData.customGoals || [];
    return entries.reduce((acc, goal) => {
      acc[goal.id] = goal;
      return acc;
    }, {});
  }, [registrationData.customGoals]);

  const colors = THEMES[theme];
  const isDarkTheme = theme === "dark";
  const overlayDimColor = isDarkTheme ? "rgba(0,0,0,0.65)" : "rgba(5,6,15,0.2)";
  const overlaySystemColor = useMemo(
    () => blendHexColors(colors.background, isDarkTheme ? "#000000" : "#05060F", isDarkTheme ? 0.5 : 0.15),
    [colors.background, isDarkTheme]
  );
  const overlayCardBackground = isDarkTheme ? lightenColor(colors.card, 0.18) : colors.card;
  const overlayBorderColor = isDarkTheme ? lightenColor(colors.border, 0.25) : colors.border;
  const impulseAlertPayload = useMemo(() => {
    if (overlay?.type !== "impulse_alert") return null;
    if (overlay?.message && typeof overlay.message === "object") {
      return overlay.message;
    }
    if (!overlay?.message) return null;
    return { body: overlay.message };
  }, [overlay]);
  const systemOverlayActive = Boolean(overlay || fabMenuVisible);

  useEffect(() => {
    if (!isAndroid) return;
    const targetNavColor = systemOverlayActive ? overlaySystemColor : colors.card;
    const targetButtonStyle = systemOverlayActive ? "light" : isDarkTheme ? "light" : "dark";
    const targetStatusColor = systemOverlayActive ? overlaySystemColor : colors.background;
    const targetNavVisibility = systemOverlayActive ? "hidden" : "visible";
    const applyNav = async () => {
      try {
        await NavigationBar.setBackgroundColorAsync(targetNavColor);
        await NavigationBar.setButtonStyleAsync(targetButtonStyle);
        if (canToggleNavVisibility) {
          await NavigationBar.setVisibilityAsync(targetNavVisibility);
        }
      } catch (err) {
        console.warn("navigation bar color", err);
      }
    };
    applyNav();
    RNStatusBar.setBackgroundColor(targetStatusColor, true);
  }, [canToggleNavVisibility, colors.card, colors.background, isAndroid, isDarkTheme, overlayDimColor, overlaySystemColor, systemOverlayActive]);
  const saveOverlayPayload =
    overlay?.type === "save"
      ? typeof overlay.message === "object" && overlay.message !== null
        ? overlay.message
        : { title: overlay.message }
      : null;
  const saveGlowAnim = useRef(new Animated.Value(0)).current;
  const assignableGoals = useMemo(
    () => (wishes || []).filter((wish) => wish.status !== "done"),
    [wishes]
  );
  const hasPendingGoals = assignableGoals.length > 0;
  const resolveTemptationGoalId = useCallback(
    (templateId) => {
      if (!templateId) return null;
      const assigned = temptationGoalMap[templateId];
      if (!assigned) return null;
      const assignedWish = wishes.find((wish) => wish.id === assigned);
      if (assignedWish && assignedWish.status !== "done") {
        return assignedWish.id;
      }
      return null;
    },
    [temptationGoalMap, wishes]
  );
  const getFallbackGoalId = useCallback(() => {
    if (assignableGoals.length > 0) return assignableGoals[0].id;
    return wishes[0]?.id || null;
  }, [assignableGoals, wishes]);
  useEffect(() => {
    const activeGoalIds = new Set(
      (wishes || [])
        .filter((wish) => wish.status !== "done")
        .map((wish) => wish.id)
    );
    let changed = false;
    const nextMap = {};
    Object.entries(temptationGoalMap || {}).forEach(([templateId, goalId]) => {
      if (goalId && activeGoalIds.has(goalId)) {
        nextMap[templateId] = goalId;
      } else {
        changed = true;
      }
    });
    if (changed) {
      setTemptationGoalMap(nextMap);
    }
  }, [temptationGoalMap, wishes]);
  const syncPrimaryGoalProgress = useCallback(
    (goalId, savedUSD, status = "active") => {
      if (!goalId) return;
      const normalizedSaved = Number.isFinite(savedUSD) ? Math.max(savedUSD, 0) : 0;
      const updateEntry = (profileState = {}) => {
        const goals = Array.isArray(profileState.primaryGoals) ? profileState.primaryGoals : [];
        let changed = false;
        const nextGoals = goals.map((entry) => {
          if (entry.id !== goalId) return entry;
          const nextEntry = { ...entry };
          if (nextEntry.savedUSD !== normalizedSaved) {
            nextEntry.savedUSD = normalizedSaved;
            changed = true;
          }
          if (status && nextEntry.status !== status) {
            nextEntry.status = status;
            changed = true;
          }
          return nextEntry;
        });
        return changed ? { ...profileState, primaryGoals: nextGoals } : profileState;
      };
      setProfile((prev) => updateEntry(prev));
      setProfileDraft((prev) => updateEntry(prev));
    },
    [setProfile, setProfileDraft]
  );

  const assignTemptationGoal = useCallback(
    (templateId, wishId = null) => {
      if (!templateId) return;
      setTemptationGoalMap((prev) => {
        const currentAssignment = prev[templateId];
        if (wishId && currentAssignment === wishId) {
          return prev;
        }
        if (!wishId && !currentAssignment) {
          return prev;
        }
        const next = { ...prev };
        if (wishId) {
          next[templateId] = wishId;
        } else {
          delete next[templateId];
        }
        return next;
      });
    },
    []
  );

  const applySavingsToWish = useCallback(
    (wishId, amountUSD) => {
      if (!wishId || !Number.isFinite(amountUSD) || amountUSD <= 0) return 0;
      let applied = 0;
      let goalSyncMeta = null;
      let completedGoalMeta = null;
      setWishes((prev) => {
        let changed = false;
        const next = prev.map((wish) => {
          if (wish.id !== wishId) return wish;
          const current = wish.savedUSD || 0;
          const target = wish.targetUSD || 0;
          const desired = current + amountUSD;
          const nextSaved = Math.min(desired, target);
          applied = nextSaved - current;
          const status = nextSaved >= target ? "done" : "active";
          const becameDone = status === "done" && wish.status !== "done" && target > 0;
          if (
            nextSaved !== current ||
            wish.status !== status ||
            wish.autoManaged !== false
          ) {
            changed = true;
            if (wish.kind === PRIMARY_GOAL_KIND && wish.goalId) {
              goalSyncMeta = { goalId: wish.goalId, savedUSD: nextSaved, status };
            }
          if (becameDone) {
            completedGoalMeta = {
              goalId: wish.goalId || wish.id,
              wishId: wish.id,
              templateId: wish.templateId || null,
              targetUSD: target,
              createdAt: wish.createdAt || wish.metaCreatedAt || null,
            };
          }
            return {
              ...wish,
              savedUSD: nextSaved,
              status,
              autoManaged: false,
            };
          }
          return wish;
        });
        return changed ? next : prev;
      });
      if (goalSyncMeta) {
        syncPrimaryGoalProgress(goalSyncMeta.goalId, goalSyncMeta.savedUSD, goalSyncMeta.status);
      }
      if (completedGoalMeta) {
        const targetAmountLocal = convertToCurrency(
          completedGoalMeta.targetUSD || 0,
          profile.currency || DEFAULT_PROFILE.currency
        );
        let daysToComplete = null;
        if (completedGoalMeta.createdAt) {
          const createdAtTs = new Date(completedGoalMeta.createdAt).getTime();
          if (Number.isFinite(createdAtTs)) {
            daysToComplete = Math.max(1, Math.round((Date.now() - createdAtTs) / DAY_MS));
          }
        }
        logEvent("goal_completed", {
          goal_id: completedGoalMeta.goalId,
          target_amount: targetAmountLocal,
          days_to_complete: daysToComplete,
        });
      }
      return applied;
    },
    [syncPrimaryGoalProgress, logEvent, profile.currency]
  );
  const getWishTitleById = useCallback(
    (wishId) => wishes.find((wish) => wish.id === wishId)?.title || "",
    [wishes]
  );
  const goalSelectionList = useMemo(
    () => (assignableGoals.length > 0 ? assignableGoals : wishes),
    [assignableGoals, wishes]
  );
  const priceEditorAssignedGoalId = priceEditor.item
    ? resolveTemptationGoalId(priceEditor.item.id)
    : null;
  const priceEditorAssignedGoal =
    priceEditorAssignedGoalId &&
    (wishes || []).find((wish) => wish.id === priceEditorAssignedGoalId);
  const priceEditorAssignedGoalTitle = priceEditorAssignedGoal
    ? getWishTitleWithoutEmoji(priceEditorAssignedGoal)
    : "";
  const goalLinkCurrentGoalId = goalLinkPrompt.item
    ? resolveTemptationGoalId(goalLinkPrompt.item.id)
    : null;

  useEffect(() => {
    if (overlay?.type !== "save") {
      saveGlowAnim.stopAnimation?.();
      return;
    }
    saveGlowAnim.setValue(0);
    const loop = Animated.loop(
      Animated.sequence([
        Animated.timing(saveGlowAnim, {
          toValue: 1,
          duration: 900,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: false,
        }),
        Animated.timing(saveGlowAnim, {
          toValue: 0,
          duration: 900,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: false,
        }),
      ])
    );
    loop.start();
    return () => loop.stop();
  }, [overlay?.type, saveGlowAnim]);

  const saveGlowHighlight = useMemo(
    () => blendColors(overlayCardBackground, isDarkTheme ? "#F5C978" : "#FFE8BA", isDarkTheme ? 0.45 : 0.35),
    [overlayCardBackground, isDarkTheme]
  );
  const saveGlowBorderHighlight = useMemo(
    () => blendColors(overlayBorderColor, "#F2A93B", 0.6),
    [overlayBorderColor]
  );

  const saveOverlayGoalText =
    saveOverlayPayload && saveOverlayPayload.goalTitle
      ? saveOverlayPayload.goalComplete
        ? t("saveGoalComplete", { goal: saveOverlayPayload.goalTitle })
        : Number.isFinite(saveOverlayPayload.remainingTemptations)
        ? t("saveGoalRemaining", {
            goal: saveOverlayPayload.goalTitle,
            count: saveOverlayPayload.remainingTemptations,
          })
        : null
      : null;
  const saveCardBackgroundStyle =
    overlay?.type === "save"
      ? {
          backgroundColor: saveGlowAnim.interpolate({
            inputRange: [0, 1],
            outputRange: [overlayCardBackground, saveGlowHighlight],
          }),
          borderColor: saveGlowAnim.interpolate({
            inputRange: [0, 1],
            outputRange: [overlayBorderColor, saveGlowBorderHighlight],
          }),
        }
      : { backgroundColor: overlayCardBackground, borderColor: overlayBorderColor };

  const achievements = useMemo(() => {
    const built = buildAchievements({
      savedTotalUSD,
      declineCount,
      freeDayStats,
      declineStreak,
      pendingCount: pendingList.length,
      decisionStats,
      currency: profile.currency || DEFAULT_PROFILE.currency,
      t,
      language,
    });
    return built.map((reward) => ({
      ...reward,
      claimed: !!claimedRewards[reward.id],
    }));
  }, [
    savedTotalUSD,
    declineCount,
    freeDayStats,
    pendingList.length,
    decisionStats,
    profile.currency,
    t,
    language,
    claimedRewards,
  ]);


  const challengeList = useMemo(
    () =>
      buildChallengesDisplay({
        state: challengesState,
        currency: profile.currency || DEFAULT_PROFILE.currency,
        language,
        t,
        maxActiveChallenges: MAX_ACTIVE_CHALLENGES,
      }),
    [challengesState, profile.currency, language, t]
  );
  const rewardsBadgeCount = useMemo(() => {
    if (!rewardsReady) return 0;
    const claimableRewards = achievements.filter((reward) => reward.unlocked && !reward.claimed).length;
    const claimableChallenges = challengeList.filter((challenge) => challenge.canClaim).length;
    return claimableRewards + claimableChallenges;
  }, [achievements, challengeList, rewardsReady]);
  const activeDailyChallenge = useMemo(() => {
    if (dailyChallenge.status !== DAILY_CHALLENGE_STATUS.ACTIVE) return null;
    const targetValue = dailyChallenge.target || 1;
    return {
      id: dailyChallenge.id,
      emoji: dailyChallenge.emoji || "‚ú®",
      title: dailyChallenge.templateLabel || dailyChallenge.templateTitle || t("defaultDealTitle"),
      rewardBonus: dailyChallenge.rewardBonus || ECONOMY_RULES.minSaveReward,
      progress: Math.min(dailyChallenge.progress || 0, targetValue),
      target: targetValue,
    };
  }, [dailyChallenge, t]);

  const profileStats = useMemo(() => {
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const totalSavedConverted = formatCurrency(
      convertToCurrency(savedTotalUSD, currencyCode),
      currencyCode
    );
    const spendCount = purchases.length;
    return [
      { label: t("statsSaved"), value: totalSavedConverted },
      { label: t("statsDeclines"), value: `${declineCount}` },
      { label: t("statsSpends"), value: `${spendCount}` },
      { label: t("statsFreeDays"), value: `${freeDayStats.current}`, suffix: "üî•" },
    ];
  }, [savedTotalUSD, declineCount, freeDayStats.current, purchases.length, t, profile.currency]);

  const analyticsStats = useMemo(
    () => [
      { label: t("analyticsPendingToBuy"), value: `${wishes.length}` },
      { label: t("analyticsPendingToDecline"), value: `${declineCount}` },
      { label: t("analyticsFridgeCount"), value: `${purchases.length}` },
    ],
    [wishes.length, declineCount, purchases.length, t]
  );
  const impulseInsights = useMemo(
    () => buildImpulseInsights(impulseTracker.events),
    [impulseTracker.events]
  );
  const temptationPressure = useMemo(
    () => buildTemptationPressureMap(impulseTracker.events),
    [impulseTracker.events]
  );

  useEffect(() => {
    if (!impulseInsights.activeRisk) return;
    notifyImpulseRisk(impulseInsights.activeRisk);
  }, [impulseInsights.activeRisk, notifyImpulseRisk]);
  useEffect(() => {
    if (!focusDigestHydrated) return;
    const todayKey = getDayKey(Date.now());
    if (focusDigestSeenKey === todayKey) return;
    if (pendingFocusDigest?.dateKey === todayKey) return;
    if (!impulseInsights || (impulseInsights.eventCount || 0) < 4) return;
    if (!purchases.length) return;
    if ((impulseInsights.totalSpendCount || 0) === 0) return;
    const strong = impulseInsights.hotWin || null;
    const weak = impulseInsights.hotLose || null;
    if (!strong && !weak) return;
    const positive = (impulseInsights.totalSpendCount || 0) <= (impulseInsights.totalSaveCount || 0);
    const strongTitle = strong?.title || t("focusDigestMissing");
    const weakTitle = weak?.title || t("focusDigestMissing");
    const payload = {
      title: positive ? t("focusDigestPositiveTitle") : t("focusDigestNegativeTitle"),
      body: positive
        ? t("focusDigestPositiveBody", { strong: strongTitle, weak: weakTitle })
        : t("focusDigestNegativeBody", { weak: weakTitle }),
      strong,
      weak,
      positive,
      targetId: weak?.templateId || strong?.templateId || null,
    };
    setPendingFocusDigest({ dateKey: todayKey, payload });
    setFocusDigestPromptShown(false);
  }, [
    focusDigestHydrated,
    focusDigestSeenKey,
    impulseInsights,
    pendingFocusDigest,
    purchases.length,
    t,
  ]);

  useEffect(() => {
    if (!pendingFocusDigest) return;
    if (focusDigestPromptShown) return;
    if (dailyChallengePromptVisible || overlay) return;
    triggerOverlayState("focus_digest", pendingFocusDigest.payload);
    setFocusDigestPromptShown(true);
  }, [pendingFocusDigest, focusDigestPromptShown, dailyChallengePromptVisible, overlay, triggerOverlayState]);
  useEffect(() => {
    if (!dailyChallengeHydrated) return;
    const todayKey = getDayKey(Date.now());
    if (dailyChallenge.dateKey === todayKey && dailyChallenge.templateId) return;
    const targetId = resolveDailyChallengeTemplateId(temptationPressure);
    if (!targetId) {
      setDailyChallenge((prev) => ({
        ...createInitialDailyChallengeState(),
        dateKey: todayKey,
        status: DAILY_CHALLENGE_STATUS.IDLE,
      }));
      return;
    }
    const template = resolveTemplateCard(targetId);
    const priceUSD = template?.priceUSD || template?.basePriceUSD || 0;
    const templateLabel =
      (typeof template?.title === "string"
        ? template.title
        : template?.title?.[language] || template?.title?.en || template?.title?.ru || "") || "";
    const templateTitle = resolveTemplateTitle(targetId, templateLabel) || templateLabel;
    const baseReward = computeRefuseCoinReward(priceUSD, profile.currency || DEFAULT_PROFILE.currency);
    const rewardBonus = computeDailyChallengeBonus(priceUSD, profile.currency || DEFAULT_PROFILE.currency);
    setDailyChallenge({
      ...createInitialDailyChallengeState(),
      id: `daily-${todayKey}-${targetId}`,
      dateKey: todayKey,
      templateId: targetId,
      templateTitle,
      templateLabel,
      emoji: template?.emoji || "‚ú®",
      priceUSD,
      baseReward,
      rewardBonus,
      status: DAILY_CHALLENGE_STATUS.OFFER,
      offerDismissed: false,
    });
  }, [
    dailyChallenge.dateKey,
    dailyChallenge.templateId,
    dailyChallengeHydrated,
    language,
    temptationPressure,
    profile.currency,
    resolveTemplateCard,
    resolveTemplateTitle,
  ]);
  const handleDailyChallengeAccept = useCallback(() => {
    if (!dailyChallenge.templateId) return;
    setDailyChallenge((prev) => {
      if (!prev || prev.status !== DAILY_CHALLENGE_STATUS.OFFER) return prev;
      return {
        ...prev,
        status: DAILY_CHALLENGE_STATUS.ACTIVE,
        acceptedAt: Date.now(),
        offerDismissed: true,
      };
    });
    logEvent("daily_challenge_accepted", { template_id: dailyChallenge.templateId });
  }, [dailyChallenge.templateId, logEvent]);
  const handleDailyChallengeLater = useCallback(() => {
    setDailyChallenge((prev) => {
      if (!prev || prev.offerDismissed) return prev || createInitialDailyChallengeState();
      return { ...prev, offerDismissed: true };
    });
  }, []);
  const completeDailyChallenge = useCallback(() => {
    if (!dailyChallenge.templateId) return;
    setDailyChallenge((prev) => {
      if (!prev || prev.status !== DAILY_CHALLENGE_STATUS.ACTIVE) return prev;
      return {
        ...prev,
        status: DAILY_CHALLENGE_STATUS.COMPLETED,
        progress: prev.target,
        completedAt: Date.now(),
        rewardGranted: true,
      };
    });
    if (dailyChallenge.rewardBonus > 0) {
      setHealthPoints((coins) => coins + dailyChallenge.rewardBonus);
      triggerOverlayState("health", {
        amount: dailyChallenge.rewardBonus,
        reason: t("dailyChallengeRewardReason", {
          temptation: dailyChallenge.templateLabel || dailyChallenge.templateTitle,
        }),
      });
    }
    sendImmediateNotification({
      title: t("dailyChallengeRewardNotificationTitle"),
      body: t("dailyChallengeRewardNotificationBody", {
        temptation: dailyChallenge.templateLabel || dailyChallenge.templateTitle || t("defaultDealTitle"),
        amount: dailyChallengeRewardLabel,
      }),
    });
    logEvent("daily_challenge_completed", {
      template_id: dailyChallenge.templateId,
      reward_bonus: dailyChallenge.rewardBonus,
    });
  }, [
    dailyChallenge.rewardBonus,
    dailyChallenge.templateId,
    dailyChallenge.templateTitle,
    dailyChallengeRewardLabel,
    sendImmediateNotification,
    logEvent,
    setHealthPoints,
    t,
    triggerOverlayState,
  ]);
  const failDailyChallenge = useCallback(() => {
    if (!dailyChallenge.templateId) return;
    setDailyChallenge((prev) => {
      if (!prev || prev.status !== DAILY_CHALLENGE_STATUS.ACTIVE) return prev;
      return {
        ...prev,
        status: DAILY_CHALLENGE_STATUS.FAILED,
        failedAt: Date.now(),
      };
    });
    triggerOverlayState(
      "cancel",
      t("dailyChallengeFailedText", { temptation: dailyChallenge.templateLabel || dailyChallenge.templateTitle })
    );
    logEvent("daily_challenge_failed", { template_id: dailyChallenge.templateId });
  }, [dailyChallenge.templateId, dailyChallenge.templateTitle, logEvent, t, triggerOverlayState]);
  useEffect(() => {
    if (!dailyChallengeHydrated) return;
    if (dailyChallenge.status !== DAILY_CHALLENGE_STATUS.ACTIVE) return;
    if (!dailyChallenge.templateId || !dailyChallenge.dateKey) return;
    const acceptedAt = dailyChallenge.acceptedAt || 0;
    const hasRefuse = resolvedHistoryEvents.some((entry) => {
      if (entry.kind !== "refuse_spend") return false;
      if (entry.meta?.templateId !== dailyChallenge.templateId) return false;
      if (getDayKey(entry.timestamp) !== dailyChallenge.dateKey) return false;
      if (acceptedAt && entry.timestamp < acceptedAt) return false;
      return true;
    });
    if (hasRefuse) {
      completeDailyChallenge();
    }
  }, [
    completeDailyChallenge,
    dailyChallenge.acceptedAt,
    dailyChallenge.dateKey,
    dailyChallenge.status,
    dailyChallenge.templateId,
    dailyChallengeHydrated,
    resolvedHistoryEvents,
  ]);
  useEffect(() => {
    if (!dailyChallengeHydrated) return;
    if (dailyChallenge.status !== DAILY_CHALLENGE_STATUS.ACTIVE) return;
    if (!dailyChallenge.templateId || !dailyChallenge.dateKey) return;
    const acceptedAt = dailyChallenge.acceptedAt || 0;
    const lost = (impulseTracker.events || []).some((event) => {
      if (event.action !== "spend") return false;
      if (event.templateId !== dailyChallenge.templateId) return false;
      if (getDayKey(event.timestamp) !== dailyChallenge.dateKey) return false;
      if (acceptedAt && event.timestamp < acceptedAt) return false;
      return true;
    });
    if (lost) {
      failDailyChallenge();
    }
  }, [
    dailyChallenge.acceptedAt,
    dailyChallenge.dateKey,
    dailyChallenge.status,
    dailyChallenge.templateId,
    dailyChallengeHydrated,
    failDailyChallenge,
    impulseTracker.events,
  ]);

  const persistCustomReminderId = useCallback(
    (id) => {
      setCustomReminderId(id);
      if (id) {
        AsyncStorage.setItem(STORAGE_KEYS.CUSTOM_REMINDER, id).catch(() => {});
      } else {
        AsyncStorage.removeItem(STORAGE_KEYS.CUSTOM_REMINDER).catch(() => {});
      }
    },
    []
  );

  const schedulePersonalTemptationReminder = useCallback(
    async (customSpend) => {
      if (
        !customSpend?.title ||
        !Number.isFinite(customSpend.frequencyPerWeek) ||
        customSpend.frequencyPerWeek <= 0
      ) {
        if (customReminderId) {
          Notifications.cancelScheduledNotificationAsync(customReminderId).catch(() => {});
          persistCustomReminderId(null);
        }
        return;
      }
      const permitted = await ensureNotificationPermission();
      if (!permitted) return;
      if (customReminderId) {
        await Notifications.cancelScheduledNotificationAsync(customReminderId).catch(() => {});
      }
      const frequency = Math.max(1, customSpend.frequencyPerWeek);
      const intervalDays = Math.max(1, Math.round(7 / frequency));
      const seconds = Math.max(6 * 60 * 60, intervalDays * 24 * 60 * 60);
      const title = tVariant("smartReminderTitle", { temptation: customSpend.title });
      const body = tVariant("smartReminderBody", { temptation: customSpend.title });
      try {
        const id = await Notifications.scheduleNotificationAsync({
          content: { title, body },
          trigger: { seconds, repeats: true },
        });
        persistCustomReminderId(id);
      } catch (error) {
        console.warn("custom reminder", error);
        persistCustomReminderId(null);
      }
    },
    [customReminderId, ensureNotificationPermission, persistCustomReminderId, tVariant]
  );
  const clearLegacyDailyNudges = useCallback(async () => {
    try {
      const scheduled = await Notifications.getAllScheduledNotificationsAsync();
      if (!Array.isArray(scheduled) || !scheduled.length) return;
      const identifiers = scheduled
        .filter((entry) => isKnownDailyNudgeNotification(entry?.content))
        .map((entry) => entry?.identifier)
        .filter(Boolean);
      if (!identifiers.length) return;
      await Promise.all(
        identifiers.map((id) =>
          Notifications.cancelScheduledNotificationAsync(id).catch(() => {})
        )
      );
    } catch (error) {
      console.warn("daily nudge cleanup", error);
    }
  }, []);

  const rescheduleDailyNudgeNotifications = useCallback(async () => {
    if (!dailyNudgesHydrated || !DAILY_NUDGE_REMINDERS.length) return;
    const permitted = await ensureNotificationPermission();
    if (!permitted) return;
    const existing = Object.values(dailyNudgeIdsRef.current || {});
    if (existing.length) {
      await Promise.all(
        existing.map((notificationId) =>
          Notifications.cancelScheduledNotificationAsync(notificationId).catch(() => {})
        )
      );
    }
    await clearLegacyDailyNudges();
    const nextMap = {};
    for (const def of DAILY_NUDGE_REMINDERS) {
      try {
        const trigger = buildDailyNudgeTrigger(def.hour, def.minute);
        if (!trigger) continue;
        const notificationId = await Notifications.scheduleNotificationAsync({
          content: {
            title: tVariant(def.titleKey),
            body: tVariant(def.bodyKey),
            data: { type: DAILY_NUDGE_NOTIFICATION_TAG, locale: language },
            ...(Platform.OS === "android" ? { channelId: ANDROID_DAILY_NUDGE_CHANNEL_ID } : null),
          },
          trigger,
        });
        nextMap[def.id] = notificationId;
      } catch (error) {
        console.warn("daily nudge schedule", error);
      }
    }
    setDailyNudgeNotificationIds(nextMap);
  }, [clearLegacyDailyNudges, dailyNudgesHydrated, ensureNotificationPermission, language, tVariant]);

  useEffect(() => {
    if (!dailyNudgesHydrated) return;
    rescheduleDailyNudgeNotifications();
  }, [dailyNudgesHydrated, language, rescheduleDailyNudgeNotifications, tVariant]);

  const loadStoredData = async () => {
    let resolvedHealthPoints = null;
    try {
      const [
        wishesRaw,
        pendingRaw,
        purchasesRaw,
        profileRaw,
        themeRaw,
        languageRaw,
        onboardingRaw,
        catalogRaw,
        pricePrecisionRaw,
        titleRaw,
        emojiOverridesRaw,
        categoryOverridesRaw,
        descriptionOverridesRaw,
        savedTotalRaw,
        declinesRaw,
        freeDayRaw,
        decisionStatsRaw,
        historyRaw,
        refuseStatsRaw,
        temptationInteractionsRaw,
        rewardsCelebratedRaw,
        analyticsOptOutRaw,
        goalMapRaw,
        customTemptationsRaw,
        hiddenTemptationsRaw,
        healthRaw,
        claimedRewardsRaw,
        rewardTotalRaw,
        impulseTrackerRaw,
        moodRaw,
        challengesRaw,
        customReminderRaw,
        dailyNudgesRaw,
        smartRemindersRaw,
        potentialPushProgressRaw,
        tamagotchiRaw,
        dailyChallengeRaw,
        dailySummaryRaw,
        tutorialRaw,
        termsAcceptedRaw,
        focusTargetRaw,
        focusDigestRaw,
        focusDigestPendingRaw,
        tamagotchiSkinRaw,
        tamagotchiSkinsUnlockedRaw,
        savedPeakRaw,
        activeGoalRaw,
        coinSliderMaxRaw,
        fabTutorialRaw,
        northStarMetricRaw,
      ] = await Promise.all([
        AsyncStorage.getItem(STORAGE_KEYS.WISHES),
        AsyncStorage.getItem(STORAGE_KEYS.PENDING),
        AsyncStorage.getItem(STORAGE_KEYS.PURCHASES),
        AsyncStorage.getItem(STORAGE_KEYS.PROFILE),
        AsyncStorage.getItem(STORAGE_KEYS.THEME),
        AsyncStorage.getItem(STORAGE_KEYS.LANGUAGE),
        AsyncStorage.getItem(STORAGE_KEYS.ONBOARDING),
        AsyncStorage.getItem(STORAGE_KEYS.CATALOG),
        AsyncStorage.getItem(STORAGE_KEYS.PRICE_PRECISION_OVERRIDES),
        AsyncStorage.getItem(STORAGE_KEYS.TITLE_OVERRIDES),
        AsyncStorage.getItem(STORAGE_KEYS.EMOJI_OVERRIDES),
        AsyncStorage.getItem(STORAGE_KEYS.CATEGORY_OVERRIDES),
        AsyncStorage.getItem(STORAGE_KEYS.DESCRIPTION_OVERRIDES),
        AsyncStorage.getItem(STORAGE_KEYS.SAVED_TOTAL),
        AsyncStorage.getItem(STORAGE_KEYS.DECLINES),
        AsyncStorage.getItem(STORAGE_KEYS.FREE_DAY),
        AsyncStorage.getItem(STORAGE_KEYS.DECISION_STATS),
        AsyncStorage.getItem(STORAGE_KEYS.HISTORY),
        AsyncStorage.getItem(STORAGE_KEYS.REFUSE_STATS),
        AsyncStorage.getItem(STORAGE_KEYS.TEMPTATION_INTERACTIONS),
        AsyncStorage.getItem(STORAGE_KEYS.REWARDS_CELEBRATED),
        AsyncStorage.getItem(STORAGE_KEYS.ANALYTICS_OPT_OUT),
        AsyncStorage.getItem(STORAGE_KEYS.TEMPTATION_GOALS),
        AsyncStorage.getItem(STORAGE_KEYS.CUSTOM_TEMPTATIONS),
        AsyncStorage.getItem(STORAGE_KEYS.HIDDEN_TEMPTATIONS),
        AsyncStorage.getItem(STORAGE_KEYS.HEALTH),
        AsyncStorage.getItem(STORAGE_KEYS.CLAIMED_REWARDS),
        AsyncStorage.getItem(STORAGE_KEYS.REWARD_TOTAL),
        AsyncStorage.getItem(STORAGE_KEYS.IMPULSE_TRACKER),
        AsyncStorage.getItem(STORAGE_KEYS.MOOD_STATE),
        AsyncStorage.getItem(STORAGE_KEYS.CHALLENGES),
        AsyncStorage.getItem(STORAGE_KEYS.CUSTOM_REMINDER),
        AsyncStorage.getItem(STORAGE_KEYS.DAILY_NUDGES),
        AsyncStorage.getItem(STORAGE_KEYS.SMART_REMINDERS),
        AsyncStorage.getItem(STORAGE_KEYS.POTENTIAL_PUSH_PROGRESS),
        AsyncStorage.getItem(STORAGE_KEYS.TAMAGOTCHI),
        AsyncStorage.getItem(STORAGE_KEYS.DAILY_CHALLENGE),
        AsyncStorage.getItem(STORAGE_KEYS.DAILY_SUMMARY),
        AsyncStorage.getItem(STORAGE_KEYS.TUTORIAL),
        AsyncStorage.getItem(STORAGE_KEYS.TERMS_ACCEPTED),
        AsyncStorage.getItem(STORAGE_KEYS.FOCUS_TARGET),
        AsyncStorage.getItem(STORAGE_KEYS.FOCUS_DIGEST),
        AsyncStorage.getItem(STORAGE_KEYS.FOCUS_DIGEST_PENDING),
        AsyncStorage.getItem(STORAGE_KEYS.TAMAGOTCHI_SKIN),
        AsyncStorage.getItem(STORAGE_KEYS.TAMAGOTCHI_SKINS_UNLOCKED),
        AsyncStorage.getItem(STORAGE_KEYS.SAVED_TOTAL_PEAK),
        AsyncStorage.getItem(STORAGE_KEYS.ACTIVE_GOAL),
        AsyncStorage.getItem(STORAGE_KEYS.COIN_SLIDER_MAX),
        AsyncStorage.getItem(STORAGE_KEYS.FAB_TUTORIAL),
        AsyncStorage.getItem(STORAGE_KEYS.NORTH_STAR_METRIC),
      ]);
      if (wishesRaw) {
        setWishes(JSON.parse(wishesRaw));
      } else {
        setWishes([]);
      }
      setWishesHydrated(true);
      if (pendingRaw) setPendingList(JSON.parse(pendingRaw));
      if (purchasesRaw) setPurchases(JSON.parse(purchasesRaw));
      let parsedProfile = null;
      let hydratedGoalId = DEFAULT_PROFILE.goal;
      if (activeGoalRaw) {
        hydratedGoalId = activeGoalRaw;
      }
      if (profileRaw) {
        parsedProfile = { ...DEFAULT_PROFILE, ...JSON.parse(profileRaw) };
        const normalizedPrimaryGoals = Array.isArray(parsedProfile.primaryGoals)
          ? parsedProfile.primaryGoals
              .map((entry) => {
                const goalId = entry?.id || parsedProfile.goal || DEFAULT_PROFILE.goal;
                if (!goalId) return null;
                const targetUSD =
                  Number.isFinite(entry?.targetUSD) && entry.targetUSD > 0
                    ? entry.targetUSD
                    : getGoalDefaultTargetUSD(goalId);
                const normalized = {
                  id: goalId,
                  targetUSD,
                  savedUSD: Number.isFinite(entry?.savedUSD) ? entry.savedUSD : 0,
                  status: entry?.status && entry.status !== "done" ? entry.status : "active",
                  createdAt: entry?.createdAt || null,
                };
                const customTitle =
                  typeof entry?.customTitle === "string" ? entry.customTitle.trim() : "";
                if (customTitle) {
                  normalized.customTitle = customTitle;
                }
                if (entry?.customEmoji) {
                  normalized.customEmoji = normalizeEmojiValue(entry.customEmoji, DEFAULT_GOAL_EMOJI);
                }
                return normalized;
              })
              .filter((entry) => entry?.id)
          : [];
        if (!normalizedPrimaryGoals.length) {
          const fallbackId = parsedProfile.goal || DEFAULT_PROFILE.goal;
          normalizedPrimaryGoals.push({
            id: fallbackId,
            targetUSD:
              Number.isFinite(parsedProfile.goalTargetUSD) && parsedProfile.goalTargetUSD > 0
                ? parsedProfile.goalTargetUSD
                : getGoalDefaultTargetUSD(fallbackId),
            savedUSD: 0,
            status: "active",
            createdAt: null,
          });
        }
        const storedGoalId = activeGoalRaw || parsedProfile.goal || null;
        const activeGoalEntry =
          storedGoalId && normalizedPrimaryGoals.find((goal) => goal.id === storedGoalId);
        const orderedPrimaryGoals = activeGoalEntry
          ? [activeGoalEntry, ...normalizedPrimaryGoals.filter((goal) => goal.id !== activeGoalEntry.id)]
          : normalizedPrimaryGoals;
        const profileGoalId =
          (activeGoalEntry && activeGoalEntry.id) ||
          parsedProfile.goal ||
          orderedPrimaryGoals[0]?.id ||
          DEFAULT_PROFILE.goal;
        hydratedGoalId = profileGoalId;
        parsedProfile.primaryGoals = orderedPrimaryGoals;
        parsedProfile.goal = profileGoalId;
        const activeTargetEntry =
          orderedPrimaryGoals.find((goal) => goal.id === profileGoalId) || orderedPrimaryGoals[0];
        const activeTargetUSD =
          Number.isFinite(activeTargetEntry?.targetUSD) && activeTargetEntry.targetUSD > 0
            ? activeTargetEntry.targetUSD
            : parsedProfile.goalTargetUSD ||
              getGoalDefaultTargetUSD(profileGoalId || activeTargetEntry?.id || DEFAULT_PROFILE.goal);
        parsedProfile.goalTargetUSD = activeTargetUSD;
        parsedProfile.goalCelebrated = !!parsedProfile.goalCelebrated;
        parsedProfile.spendingProfile = {
          baselineMonthlyWasteUSD: Math.max(
            0,
            Number(parsedProfile.spendingProfile?.baselineMonthlyWasteUSD) || 0
          ),
          baselineStartAt: parsedProfile.spendingProfile?.baselineStartAt || null,
        };
        if (!parsedProfile.joinedAt) {
          parsedProfile.joinedAt =
            parsedProfile.spendingProfile?.baselineStartAt || new Date().toISOString();
        }
        setProfile(parsedProfile);
        setProfileDraft(parsedProfile);
        setRegistrationData((prev) => ({
          ...prev,
          firstName: parsedProfile.firstName || prev.firstName,
          lastName: parsedProfile.lastName || prev.lastName,
          motto: parsedProfile.motto || parsedProfile.subtitle || prev.motto,
          avatar: parsedProfile.avatar || prev.avatar,
          currency: parsedProfile.currency || prev.currency,
          gender: parsedProfile.gender || prev.gender,
          persona: parsedProfile.persona || prev.persona,
        }));
        setActiveCurrency(parsedProfile.currency || DEFAULT_PROFILE.currency);
      } else {
        const freshProfile = { ...DEFAULT_PROFILE, joinedAt: new Date().toISOString() };
        setProfile(freshProfile);
        setProfileDraft(freshProfile);
        setActiveCurrency(DEFAULT_PROFILE.currency);
      }
      if (customReminderRaw) {
        setCustomReminderId(customReminderRaw);
      } else {
        setCustomReminderId(null);
      }
      setCustomReminderHydrated(true);
      if (dailyNudgesRaw) {
        try {
          const parsed = JSON.parse(dailyNudgesRaw);
          if (parsed && typeof parsed === "object") {
            setDailyNudgeNotificationIds(parsed);
            dailyNudgeIdsRef.current = parsed;
          } else {
            setDailyNudgeNotificationIds({});
            dailyNudgeIdsRef.current = {};
          }
        } catch (err) {
          console.warn("daily nudges parse", err);
          setDailyNudgeNotificationIds({});
          dailyNudgeIdsRef.current = {};
        }
      } else {
        setDailyNudgeNotificationIds({});
        dailyNudgeIdsRef.current = {};
      }
      if (smartRemindersRaw) {
        try {
          const parsed = JSON.parse(smartRemindersRaw);
          setSmartReminders((prev) =>
            normalizeSmartReminderEntries([
              ...(Array.isArray(parsed) ? parsed : []),
              ...prev,
            ])
          );
        } catch (err) {
          console.warn("smart reminders parse", err);
          setSmartReminders((prev) => normalizeSmartReminderEntries(prev));
        }
      }
      if (potentialPushProgressRaw) {
        try {
          const parsed = JSON.parse(potentialPushProgressRaw);
          setPotentialPushProgress({
            lastStep: Math.max(0, Number(parsed?.lastStep) || 0),
            lastStatus:
              parsed?.lastStatus === "ahead" || parsed?.lastStatus === "behind"
                ? parsed.lastStatus
                : null,
            baselineKey:
              typeof parsed?.baselineKey === "string" && parsed.baselineKey.trim()
                ? parsed.baselineKey
                : null,
            stepMultiplier: Math.min(
              POTENTIAL_PUSH_MAX_MULTIPLIER,
              Math.max(1, Number(parsed?.stepMultiplier) || 1)
            ),
            lastNotifiedAt:
              Number.isFinite(Number(parsed?.lastNotifiedAt)) && Number(parsed?.lastNotifiedAt) > 0
                ? Number(parsed.lastNotifiedAt)
                : 0,
          });
        } catch (err) {
          console.warn("potential push progress parse", err);
          setPotentialPushProgress({ ...DEFAULT_POTENTIAL_PUSH_STATE });
        }
      } else {
        setPotentialPushProgress({ ...DEFAULT_POTENTIAL_PUSH_STATE });
      }
      setPotentialPushHydrated(true);
      if (tamagotchiRaw) {
        try {
          const parsed = JSON.parse(tamagotchiRaw);
          const parsedHunger = Math.min(
            TAMAGOTCHI_MAX_HUNGER,
            Math.max(0, Number(parsed?.hunger) || 0)
          );
          const parsedCoins = Math.max(
            0,
            Math.floor(Number(parsed?.coins) || TAMAGOTCHI_START_STATE.coins)
          );
          const baseState = {
            ...TAMAGOTCHI_START_STATE,
            ...parsed,
            hunger: parsedHunger,
            coins: parsedCoins,
            lastDecayAt:
              typeof parsed?.lastDecayAt === "number" && Number.isFinite(parsed.lastDecayAt)
                ? parsed.lastDecayAt
                : Number(parsed?.lastDecayAt) || Date.now(),
            coinTick: Math.max(0, Number(parsed?.coinTick) || 0),
          };
          const { state: hydratedState } = computeTamagotchiDecay(baseState);
          setTamagotchiState(hydratedState);
          tamagotchiHungerPrevRef.current = hydratedState.hunger;
          tamagotchiHydratedRef.current = true;
          if (!healthRaw && resolvedHealthPoints === null) {
            resolvedHealthPoints = hydratedState.coins;
          }
        } catch (err) {
          setTamagotchiState({ ...TAMAGOTCHI_START_STATE });
          tamagotchiHungerPrevRef.current = TAMAGOTCHI_START_STATE.hunger;
          tamagotchiHydratedRef.current = true;
        }
      } else {
        tamagotchiHungerPrevRef.current = TAMAGOTCHI_START_STATE.hunger;
        tamagotchiHydratedRef.current = true;
      }
      if (dailyChallengeRaw) {
        try {
          const parsed = JSON.parse(dailyChallengeRaw);
          setDailyChallenge({
            ...createInitialDailyChallengeState(),
            ...(parsed && typeof parsed === "object" ? parsed : {}),
          });
        } catch (err) {
          console.warn("daily challenge parse", err);
          setDailyChallenge(createInitialDailyChallengeState());
        }
      } else {
        setDailyChallenge(createInitialDailyChallengeState());
      }
      setDailyChallengeHydrated(true);
      if (themeRaw) setTheme(themeRaw);
      if (languageRaw) setLanguage(normalizeLanguage(languageRaw));
      if (coinSliderMaxRaw) {
        const parsedSliderMax = parseFloat(coinSliderMaxRaw);
        if (Number.isFinite(parsedSliderMax) && parsedSliderMax > 0) {
          setCoinSliderMaxUSD(parsedSliderMax);
        }
      } else {
        setCoinSliderMaxUSD(DEFAULT_COIN_SLIDER_MAX_USD);
      }
      setCoinSliderHydrated(true);
      if (
        fabTutorialRaw === FAB_TUTORIAL_STATUS.PENDING ||
        fabTutorialRaw === FAB_TUTORIAL_STATUS.SHOWING
      ) {
        setFabTutorialState(fabTutorialRaw);
        fabTutorialStateRef.current = fabTutorialRaw;
      } else {
        setFabTutorialState(FAB_TUTORIAL_STATUS.DONE);
        fabTutorialStateRef.current = FAB_TUTORIAL_STATUS.DONE;
      }
      if (northStarMetricRaw) {
        let logged = false;
        try {
          const parsedNorthStar = JSON.parse(northStarMetricRaw);
          logged = !!parsedNorthStar?.logged;
        } catch (error) {
          logged = northStarMetricRaw === "1";
        }
        setNorthStarLogged(logged);
        northStarLoggedRef.current = logged;
      } else {
        setNorthStarLogged(false);
        northStarLoggedRef.current = false;
      }
      setNorthStarHydrated(true);
      if (dailySummaryRaw) setDailySummarySeenKey(dailySummaryRaw);
      setTutorialSeen(tutorialRaw === "pending" ? false : true);
      if (termsAcceptedRaw === "1") {
        setTermsAccepted(true);
      }
      if (focusTargetRaw) {
        try {
          const parsedFocus = JSON.parse(focusTargetRaw);
          if (parsedFocus && typeof parsedFocus === "object" && typeof parsedFocus.templateId === "string") {
            setFocusTemplateId(parsedFocus.templateId);
            setFocusSaveCount(Math.max(0, Number(parsedFocus.saveCount) || 0));
          } else {
            setFocusTemplateId(null);
            setFocusSaveCount(0);
          }
        } catch (error) {
          setFocusTemplateId(null);
          setFocusSaveCount(0);
        }
      } else {
        setFocusTemplateId(null);
        setFocusSaveCount(0);
      }
      setFocusStateHydrated(true);
      if (focusDigestRaw) {
        setFocusDigestSeenKey(focusDigestRaw || null);
      } else {
        setFocusDigestSeenKey(null);
      }
      setFocusDigestHydrated(true);
      if (focusDigestPendingRaw) {
        try {
          const parsedPending = JSON.parse(focusDigestPendingRaw);
          if (parsedPending && typeof parsedPending === "object" && parsedPending.payload) {
            setPendingFocusDigest(parsedPending);
          } else {
            setPendingFocusDigest(null);
          }
        } catch (error) {
          setPendingFocusDigest(null);
        }
      } else {
        setPendingFocusDigest(null);
      }
      const skinsUnlocked = tamagotchiSkinsUnlockedRaw === "1";
      setTamagotchiSkinsUnlocked(skinsUnlocked);
      setTamagotchiSkinsUnlockHydrated(true);
      if (
        tamagotchiSkinRaw &&
        TAMAGOTCHI_SKINS[tamagotchiSkinRaw] &&
        (skinsUnlocked || tamagotchiSkinRaw === DEFAULT_TAMAGOTCHI_SKIN)
      ) {
        setTamagotchiSkinId(tamagotchiSkinRaw);
      } else {
        setTamagotchiSkinId(DEFAULT_TAMAGOTCHI_SKIN);
      }
      setTamagotchiSkinHydrated(true);
      setActiveGoalId(hydratedGoalId || DEFAULT_PROFILE.goal);
      setActiveGoalHydrated(true);
      if (catalogRaw) {
        try {
          setCatalogOverrides(JSON.parse(catalogRaw));
        } catch (error) {
          console.warn("catalog overrides parse", error);
          setCatalogOverrides({});
        }
      } else {
        setCatalogOverrides({});
      }
      setCatalogHydrated(true);
      if (pricePrecisionRaw) {
        try {
          setPricePrecisionOverrides(JSON.parse(pricePrecisionRaw));
        } catch (error) {
          console.warn("price precision overrides parse", error);
          setPricePrecisionOverrides({});
        }
      } else {
        setPricePrecisionOverrides({});
      }
      setPricePrecisionOverridesHydrated(true);
      if (titleRaw) {
        try {
          setTitleOverrides(JSON.parse(titleRaw));
        } catch (error) {
          console.warn("title overrides parse", error);
          setTitleOverrides({});
        }
      } else {
        setTitleOverrides({});
      }
      setTitleOverridesHydrated(true);
      if (emojiOverridesRaw) {
        try {
          setEmojiOverrides(JSON.parse(emojiOverridesRaw));
        } catch (error) {
          console.warn("emoji overrides parse", error);
          setEmojiOverrides({});
        }
      } else {
        setEmojiOverrides({});
      }
      setEmojiOverridesHydrated(true);
      if (categoryOverridesRaw) {
        try {
          setCategoryOverrides(JSON.parse(categoryOverridesRaw));
        } catch (error) {
          console.warn("category overrides parse", error);
          setCategoryOverrides({});
        }
      } else {
        setCategoryOverrides({});
      }
      setCategoryOverridesHydrated(true);
      if (descriptionOverridesRaw) {
        try {
          setDescriptionOverrides(JSON.parse(descriptionOverridesRaw));
        } catch (error) {
          console.warn("description overrides parse", error);
          setDescriptionOverrides({});
        }
      } else {
        setDescriptionOverrides({});
      }
      setDescriptionOverridesHydrated(true);
      let resolvedSavedTotal = 0;
      if (savedTotalRaw) {
        resolvedSavedTotal = Number(savedTotalRaw) || 0;
        setSavedTotalUSD(resolvedSavedTotal);
      } else {
        setSavedTotalUSD(0);
      }
      setSavedTotalHydrated(true);
      if (savedPeakRaw) {
        const parsedPeak = Number(savedPeakRaw) || 0;
        setLifetimeSavedUSD(Math.max(parsedPeak, resolvedSavedTotal));
      } else {
        setLifetimeSavedUSD(Math.max(0, resolvedSavedTotal));
      }
      setLifetimeSavedHydrated(true);
      if (declinesRaw) setDeclineCount(Number(declinesRaw) || 0);
      if (freeDayRaw) {
        setFreeDayStats({ ...INITIAL_FREE_DAY_STATS, ...JSON.parse(freeDayRaw) });
      }
      if (decisionStatsRaw) {
        setDecisionStats({ ...INITIAL_DECISION_STATS, ...JSON.parse(decisionStatsRaw) });
      }
      if (historyRaw) {
        try {
          const parsedHistory = JSON.parse(historyRaw);
          const now = Date.now();
          const filteredHistory = (Array.isArray(parsedHistory) ? parsedHistory : [])
            .filter((entry) => entry?.timestamp && now - entry.timestamp <= HISTORY_RETENTION_MS)
            .slice(0, MAX_HISTORY_EVENTS);
          setHistoryEvents(filteredHistory);
        } catch (err) {
          console.warn("history parse", err);
          setHistoryEvents([]);
        }
      }
      if (refuseStatsRaw) {
        setRefuseStats(JSON.parse(refuseStatsRaw));
      }
      if (temptationInteractionsRaw) {
        try {
          const parsedInteractions = JSON.parse(temptationInteractionsRaw);
          setTemptationInteractions((prev) =>
            mergeInteractionStatMaps(parsedInteractions || {}, prev || {})
          );
        } catch (err) {
          console.warn("temptation interactions parse", err);
        }
      }
      setTemptationInteractionsHydrated(true);
      if (rewardsCelebratedRaw) {
        try {
          const parsedCelebrated = JSON.parse(rewardsCelebratedRaw);
          setRewardCelebratedMap(parsedCelebrated && typeof parsedCelebrated === "object" ? parsedCelebrated : {});
        } catch (err) {
          console.warn("rewards celebrated parse", err);
          setRewardCelebratedMap({});
        }
      } else {
        setRewardCelebratedMap({});
      }
      setRewardCelebratedHydrated(true);
      if (analyticsOptOutRaw === "1" || analyticsOptOutRaw === "0") {
        setAnalyticsOptOutState(analyticsOptOutRaw === "1");
      } else {
        setAnalyticsOptOutState(true);
      }
      if (goalMapRaw) {
        try {
          setTemptationGoalMap(JSON.parse(goalMapRaw));
        } catch (err) {
          console.warn("goal map parse", err);
        }
      }
      if (customTemptationsRaw) {
        try {
          const parsedCustom = JSON.parse(customTemptationsRaw);
          const fallbackCurrency = parsedProfile?.currency || DEFAULT_PROFILE.currency;
          const normalizedCustom = (Array.isArray(parsedCustom) ? parsedCustom : [parsedCustom])
            .map((entry) => normalizeCustomTemptationEntry(entry, fallbackCurrency))
            .filter(Boolean);
          setQuickTemptations(normalizedCustom);
        } catch (err) {
          console.warn("custom temptations parse", err);
        }
      }
      if (hiddenTemptationsRaw) {
        try {
          setHiddenTemptations(JSON.parse(hiddenTemptationsRaw));
        } catch (err) {
          console.warn("hidden temptations parse", err);
        }
      }
      if (healthRaw) {
        const parsedHealth = Number(healthRaw) || 0;
        resolvedHealthPoints = Math.max(0, parsedHealth);
      } else if (resolvedHealthPoints === null) {
        resolvedHealthPoints = 0;
      }
      let initialClaimedCount = 0;
      if (claimedRewardsRaw) {
        try {
          const parsedClaimed = JSON.parse(claimedRewardsRaw);
          const normalizedClaimed = normalizeClaimedRewardsMap(parsedClaimed);
          initialClaimedCount = Object.keys(normalizedClaimed).length;
          setClaimedRewards(normalizedClaimed);
        } catch (err) {
          console.warn("claimed rewards parse", err);
          setClaimedRewards({});
        }
      } else {
        setClaimedRewards({});
      }
      if (rewardTotalRaw) {
        const parsedRewardTotal = Number(rewardTotalRaw);
        setRewardClaimTotal(Number.isFinite(parsedRewardTotal) ? Math.max(parsedRewardTotal, 0) : 0);
      } else {
        setRewardClaimTotal(initialClaimedCount);
      }
      if (impulseTrackerRaw) {
        try {
          const parsed = JSON.parse(impulseTrackerRaw);
          setImpulseTracker({
            ...INITIAL_IMPULSE_TRACKER,
            ...parsed,
            events: Array.isArray(parsed?.events) ? parsed.events.slice(0, MAX_IMPULSE_EVENTS) : [],
            lastAlerts: parsed?.lastAlerts || {},
          });
        } catch (err) {
          console.warn("impulse tracker parse", err);
        }
      }
      if (challengesRaw) {
        try {
          const parsed = JSON.parse(challengesRaw);
          const normalized = normalizeChallengesState(parsed);
          challengesPrevRef.current = normalized;
          setChallengesState(normalized);
        } catch (err) {
          console.warn("challenges parse", err);
          const fallback = createInitialChallengesState();
          challengesPrevRef.current = fallback;
          setChallengesState(fallback);
        }
      } else {
        const fallback = createInitialChallengesState();
        challengesPrevRef.current = fallback;
        setChallengesState(fallback);
      }
      if (moodRaw) {
        try {
          const parsed = JSON.parse(moodRaw);
          const normalizedEvents = Array.isArray(parsed?.events)
            ? parsed.events.slice(0, MOOD_MAX_EVENTS)
            : [];
          const todayKey = getDayKey(Date.now());
          if (parsed?.dayKey === todayKey) {
            setMoodState({
              ...parsed,
              dayKey: todayKey,
              events: normalizedEvents,
              current: parsed.current || MOOD_IDS.NEUTRAL,
              pendingSnapshot:
                typeof parsed.pendingSnapshot === "number" ? parsed.pendingSnapshot : pendingList.length,
            });
          } else {
            setMoodState(createMoodStateForToday());
          }
        } catch (err) {
          console.warn("mood state parse", err);
        }
      }
      if (onboardingRaw === "done") {
        goToOnboardingStep("done", { recordHistory: false, resetHistory: true });
      } else {
        const placeholderProfile = { ...DEFAULT_PROFILE_PLACEHOLDER, joinedAt: new Date().toISOString() };
        setProfile(placeholderProfile);
        setProfileDraft(placeholderProfile);
        setActiveGoalId(DEFAULT_PROFILE.goal);
        setRegistrationData((prev) => ({
          ...prev,
          firstName: "",
          lastName: "",
          motto: "",
          avatar: "",
          currency: placeholderProfile.currency,
          gender: placeholderProfile.gender,
        }));
        setActiveCurrency(DEFAULT_PROFILE.currency);
        goToOnboardingStep("logo", { recordHistory: false, resetHistory: true });
        setOnboardingStep("logo");
        setActiveGoalHydrated(true);
      }
      setProfileHydrated(true);
    } catch (error) {
      console.warn("load error", error);
      setAnalyticsOptOutState((prev) => (prev === null ? true : prev));
    } finally {
      const safeHealthPoints =
        typeof resolvedHealthPoints === "number" && !Number.isNaN(resolvedHealthPoints)
          ? resolvedHealthPoints
          : 0;
      setHealthPoints((prev) => prev + safeHealthPoints);
      setHealthHydrated(true);
      setNorthStarHydrated(true);
      setWishesHydrated(true);
      setSavedTotalHydrated(true);
      setRewardsReady(true);
      setMoodHydrated(true);
      setFreeDayHydrated(true);
      setCustomReminderHydrated(true);
      setPotentialPushHydrated(true);
      setSmartRemindersHydrated(true);
      setDailyNudgesHydrated(true);
      setCatalogHydrated(true);
      setTitleOverridesHydrated(true);
      setEmojiOverridesHydrated(true);
      setCategoryOverridesHydrated(true);
      setDescriptionOverridesHydrated(true);
      setTamagotchiSkinHydrated(true);
      setLifetimeSavedHydrated(true);
      setProfileHydrated(true);
    }
  };

  useEffect(() => {
    loadStoredData();
  }, []);
  useEffect(() => {
    northStarLoggedRef.current = northStarLogged;
  }, [northStarLogged]);
  useEffect(() => {
    if (onboardingStep !== "done") {
      setHomeLayoutReady(false);
      setTutorialVisible(false);
    }
  }, [onboardingStep]);

  useEffect(() => {
    if (onboardingStep === "done" && !startupLogoDismissedRef.current) {
      setStartupLogoVisible(true);
    }
  }, [onboardingStep]);

  const handleStartupLogoComplete = useCallback(() => {
    startupLogoDismissedRef.current = true;
    setStartupLogoVisible(false);
  }, []);

  const sendTamagotchiHungerNotification = useCallback(
    async (kind) => {
      const copy = TAMAGOTCHI_NOTIFICATION_COPY[language] || TAMAGOTCHI_NOTIFICATION_COPY.ru;
      const body = copy[kind];
      if (!body) return;
      await sendImmediateNotification({
        title: t("tamagotchiName"),
        body,
      });
    },
    [language, sendImmediateNotification, t]
  );

  useEffect(() => {
    const currentHunger = Math.min(
      TAMAGOTCHI_MAX_HUNGER,
      Math.max(0, Number(tamagotchiState.hunger) || 0)
    );
    if (!tamagotchiHydratedRef.current) {
      tamagotchiHungerPrevRef.current = currentHunger;
      return;
    }
    const previousHunger = Math.min(
      TAMAGOTCHI_MAX_HUNGER,
      Math.max(0, Number(tamagotchiHungerPrevRef.current) || 0)
    );
    if (currentHunger <= 0 && previousHunger > 0) {
      sendTamagotchiHungerNotification("starving");
    } else if (
      currentHunger <= TAMAGOTCHI_HUNGER_LOW_THRESHOLD &&
      previousHunger > TAMAGOTCHI_HUNGER_LOW_THRESHOLD
    ) {
      sendTamagotchiHungerNotification("low");
    }
    tamagotchiHungerPrevRef.current = currentHunger;
  }, [sendTamagotchiHungerNotification, tamagotchiState.hunger]);

  const shouldShowTutorial = onboardingStep === "done" && !tutorialSeen && !tutorialVisible;

  useEffect(() => {
    if (!shouldShowTutorial) return;
    if (!APP_TUTORIAL_STEPS.length) return;
    if (!homeLayoutReady) return;
    if (startupLogoVisible) return;
    setTutorialStepIndex(0);
    setTutorialVisible(true);
  }, [homeLayoutReady, shouldShowTutorial, startupLogoVisible]);

  useEffect(() => {
    if (!shouldShowTutorial) return;
    if (!APP_TUTORIAL_STEPS.length) return;
    const fallbackTimer = setTimeout(() => {
      setTutorialStepIndex(0);
      setTutorialVisible(true);
    }, 1600);
    return () => clearTimeout(fallbackTimer);
  }, [shouldShowTutorial]);

  useEffect(() => {
    if (onboardingStep !== "done") return;
    const hour = new Date().getHours();
    if (hour < 20) return;
    const todayKey = getDayKey(Date.now());
    if (dailySummarySeenKey === todayKey) return;
    const todayEvents = resolvedHistoryEvents.filter((e) => getDayKey(e.timestamp) === todayKey);
    if (!todayEvents.length) return;
    const saves = todayEvents.filter((e) => e.kind === "refuse_spend");
    const spends = todayEvents.filter((e) => e.kind === "spend");
    const savedUSD = saves.reduce((sum, e) => sum + (Number(e.meta?.amountUSD) || 0), 0);
    const declines = saves.length;
    if (declines < 3) return;
    const spendCount = spends.length;
    setPendingDailySummaryData({ savedUSD, declines, spends: spendCount, todayKey });
  }, [dailySummarySeenKey, resolvedHistoryEvents, onboardingStep]);

  useEffect(() => {
    if (!pendingDailySummaryData) return;
    if (overlay) return;
    setDailySummaryData(pendingDailySummaryData);
    setDailySummaryVisible(true);
    const todayKey = pendingDailySummaryData.todayKey || getDayKey(Date.now());
    setDailySummarySeenKey(todayKey);
    AsyncStorage.setItem(STORAGE_KEYS.DAILY_SUMMARY, todayKey).catch(() => {});
    setPendingDailySummaryData(null);
  }, [overlay, pendingDailySummaryData]);

  useEffect(() => {
    processTamagotchiDecay();
    const interval = setInterval(() => {
      processTamagotchiDecay();
    }, 60 * 1000);
    return () => clearInterval(interval);
  }, [processTamagotchiDecay]);

  useEffect(() => {
    setTamagotchiState((prev) =>
      prev.coins === healthPoints ? prev : { ...prev, coins: healthPoints }
    );
  }, [healthPoints]);

  useEffect(() => {
    if (tamagotchiVisible) {
      Animated.timing(tamagotchiModalAnim, {
        toValue: 1,
        duration: 220,
        easing: Easing.out(Easing.quad),
        useNativeDriver: true,
      }).start();
    } else {
      Animated.timing(tamagotchiModalAnim, {
        toValue: 0,
        duration: 160,
        easing: Easing.in(Easing.quad),
        useNativeDriver: true,
      }).start();
    }
  }, [tamagotchiVisible, tamagotchiModalAnim]);

  useEffect(() => {
    if (onboardingStep === "done" && (profile.primaryGoals || []).length) {
      ensurePrimaryGoalWish(profile.primaryGoals, language, activeGoalId || profile.goal);
    }
  }, [ensurePrimaryGoalWish, onboardingStep, profile.primaryGoals, activeGoalId, profile.goal, language]);

  useEffect(() => {
    const targetUSD = heroGoalTargetUSD > 0 ? heroGoalTargetUSD : 0;
    const hasMetGoal = targetUSD > 0 && heroGoalSavedUSD >= targetUSD;
    if (hasMetGoal && !profile.goalCelebrated) {
      const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
      const targetLabel = formatCurrency(convertToCurrency(targetUSD, currencyCode), currencyCode);
      setProfile((prev) => ({
        ...prev,
        goalCelebrated: true,
        goalRenewalPending: true,
      }));
      setProfileDraft((prev) => ({
        ...prev,
        goalCelebrated: true,
        goalRenewalPending: true,
      }));
      triggerOverlayState(
        "goal_complete",
        {
          title: t("goalCelebrationTitle"),
          subtitle: t("goalCelebrationSubtitle"),
          targetLabel: t("goalCelebrationTarget", { amount: targetLabel }),
        },
        5200
      );
      if (!hasPendingGoals) {
        goalRenewalPromptPendingRef.current = true;
      }
    }
  }, [
    heroGoalTargetUSD,
    profile.goalCelebrated,
    profile.currency,
    heroGoalSavedUSD,
    hasPendingGoals,
    triggerOverlayState,
    t,
  ]);

  useEffect(() => {
    const targetUSD = heroGoalTargetUSD > 0 ? heroGoalTargetUSD : 0;
    const hasMetGoal = targetUSD > 0 && heroGoalSavedUSD >= targetUSD;
    if (profile.goalCelebrated && !hasMetGoal) {
      setProfile((prev) => ({ ...prev, goalCelebrated: false, goalRenewalPending: false }));
      setProfileDraft((prev) => ({ ...prev, goalCelebrated: false, goalRenewalPending: false }));
      goalRenewalPromptPendingRef.current = false;
    }
  }, [heroGoalTargetUSD, profile.goalCelebrated, heroGoalSavedUSD, setProfile]);

  useEffect(() => {
    AsyncStorage.setItem(STORAGE_KEYS.WISHES, JSON.stringify(wishes)).catch(() => {});
  }, [wishes]);

  useEffect(() => {
    AsyncStorage.setItem(
      STORAGE_KEYS.TEMPTATION_GOALS,
      JSON.stringify(temptationGoalMap)
    ).catch(() => {});
  }, [temptationGoalMap]);

  useEffect(() => {
    AsyncStorage.setItem(STORAGE_KEYS.PURCHASES, JSON.stringify(purchases)).catch(() => {});
  }, [purchases]);

  useEffect(() => {
    if (!profileHydrated) return;
    AsyncStorage.setItem(STORAGE_KEYS.PROFILE, JSON.stringify(profile)).catch(() => {});
  }, [profile, profileHydrated]);

  useEffect(() => {
    if (!activeGoalHydrated) return;
    const value = activeGoalId || "";
    AsyncStorage.setItem(STORAGE_KEYS.ACTIVE_GOAL, value).catch(() => {});
  }, [activeGoalHydrated, activeGoalId]);

  useEffect(() => {
    if (!overlay && goalRenewalPromptPendingRef.current) {
      goalRenewalPromptPendingRef.current = false;
      if (!goalRenewalPromptVisible) {
        setGoalRenewalPromptVisible(true);
      }
    }
  }, [overlay, goalRenewalPromptVisible]);

  useEffect(() => {
    if (!profile.goalRenewalPending) {
      goalRenewalPromptPendingRef.current = false;
      return;
    }
    if (hasPendingGoals) return;
    requestGoalRenewalPrompt();
  }, [profile.goalRenewalPending, hasPendingGoals, requestGoalRenewalPrompt]);

  useEffect(() => {
    setActiveCurrency(profile.currency || DEFAULT_PROFILE.currency);
  }, [profile.currency]);

  useEffect(() => {
    AsyncStorage.setItem(STORAGE_KEYS.THEME, theme).catch(() => {});
  }, [theme]);

  useEffect(() => {
    AsyncStorage.setItem(STORAGE_KEYS.LANGUAGE, language).catch(() => {});
  }, [language]);

  useEffect(() => {
    if (!healthHydrated) return;
    AsyncStorage.setItem(STORAGE_KEYS.HEALTH, String(healthPoints)).catch(() => {});
  }, [healthHydrated, healthPoints]);

  useEffect(() => {
    AsyncStorage.setItem(STORAGE_KEYS.CLAIMED_REWARDS, JSON.stringify(claimedRewards)).catch(() => {});
  }, [claimedRewards]);
  useEffect(() => {
    if (!Number.isFinite(rewardClaimTotal)) return;
    AsyncStorage.setItem(STORAGE_KEYS.REWARD_TOTAL, String(Math.max(0, rewardClaimTotal))).catch(() => {});
  }, [rewardClaimTotal]);

  useEffect(() => {
    AsyncStorage.setItem(STORAGE_KEYS.CHALLENGES, JSON.stringify(challengesState)).catch(() => {});
  }, [challengesState]);
  useEffect(() => {
    if (!dailyChallengeHydrated) return;
    AsyncStorage.setItem(STORAGE_KEYS.DAILY_CHALLENGE, JSON.stringify(dailyChallenge)).catch(() => {});
  }, [dailyChallenge, dailyChallengeHydrated]);

  useEffect(() => {
    AsyncStorage.setItem(STORAGE_KEYS.TAMAGOTCHI, JSON.stringify(tamagotchiState)).catch(() => {});
  }, [tamagotchiState]);

  useEffect(() => {
    if (!tamagotchiSkinHydrated) return;
    AsyncStorage.setItem(STORAGE_KEYS.TAMAGOTCHI_SKIN, tamagotchiSkinId).catch(() => {});
  }, [tamagotchiSkinHydrated, tamagotchiSkinId]);
  useEffect(() => {
    if (!tamagotchiSkinsUnlockHydrated) return;
    AsyncStorage.setItem(
      STORAGE_KEYS.TAMAGOTCHI_SKINS_UNLOCKED,
      tamagotchiSkinsUnlocked ? "1" : "0"
    ).catch(() => {});
  }, [tamagotchiSkinsUnlockHydrated, tamagotchiSkinsUnlocked]);

  useEffect(() => {
    if (!catalogHydrated) return;
    AsyncStorage.setItem(STORAGE_KEYS.CATALOG, JSON.stringify(catalogOverrides)).catch(() => {});
  }, [catalogOverrides, catalogHydrated]);
  useEffect(() => {
    if (!pricePrecisionOverridesHydrated) return;
    AsyncStorage.setItem(
      STORAGE_KEYS.PRICE_PRECISION_OVERRIDES,
      JSON.stringify(pricePrecisionOverrides)
    ).catch(() => {});
  }, [pricePrecisionOverrides, pricePrecisionOverridesHydrated]);

  useEffect(() => {
    if (!titleOverridesHydrated) return;
    AsyncStorage.setItem(STORAGE_KEYS.TITLE_OVERRIDES, JSON.stringify(titleOverrides)).catch(() => {});
  }, [titleOverrides, titleOverridesHydrated]);

  useEffect(() => {
    if (!emojiOverridesHydrated) return;
    AsyncStorage.setItem(STORAGE_KEYS.EMOJI_OVERRIDES, JSON.stringify(emojiOverrides)).catch(() => {});
  }, [emojiOverrides, emojiOverridesHydrated]);
  useEffect(() => {
    if (!categoryOverridesHydrated) return;
    AsyncStorage.setItem(STORAGE_KEYS.CATEGORY_OVERRIDES, JSON.stringify(categoryOverrides)).catch(
      () => {}
    );
  }, [categoryOverrides, categoryOverridesHydrated]);

  useEffect(() => {
    if (!descriptionOverridesHydrated) return;
    AsyncStorage.setItem(STORAGE_KEYS.DESCRIPTION_OVERRIDES, JSON.stringify(descriptionOverrides)).catch(
      () => {}
    );
  }, [descriptionOverrides, descriptionOverridesHydrated]);

  useEffect(() => {
    if (!savedTotalHydrated) return;
    AsyncStorage.setItem(STORAGE_KEYS.SAVED_TOTAL, String(savedTotalUSD)).catch(() => {});
  }, [savedTotalUSD, savedTotalHydrated]);

  useEffect(() => {
    if (!savedTotalHydrated || !lifetimeSavedHydrated) return;
    setLifetimeSavedUSD((prev) => (savedTotalUSD > prev ? savedTotalUSD : prev));
  }, [savedTotalUSD, savedTotalHydrated, lifetimeSavedHydrated]);

  useEffect(() => {
    if (!lifetimeSavedHydrated) return;
    AsyncStorage.setItem(STORAGE_KEYS.SAVED_TOTAL_PEAK, String(lifetimeSavedUSD)).catch(() => {});
  }, [lifetimeSavedUSD, lifetimeSavedHydrated]);

  useEffect(() => {
    AsyncStorage.setItem(STORAGE_KEYS.DECLINES, String(declineCount)).catch(() => {});
  }, [declineCount]);

  useEffect(() => {
    if (!dailyNudgesHydrated) return;
    AsyncStorage.setItem(
      STORAGE_KEYS.DAILY_NUDGES,
      JSON.stringify(dailyNudgeNotificationIds)
    ).catch(() => {});
  }, [dailyNudgeNotificationIds, dailyNudgesHydrated]);

  useEffect(() => {
    if (!smartRemindersHydrated) return;
    AsyncStorage.setItem(STORAGE_KEYS.SMART_REMINDERS, JSON.stringify(smartReminders)).catch(() => {});
  }, [smartReminders, smartRemindersHydrated]);
  useEffect(() => {
    if (!potentialPushHydrated) return;
    AsyncStorage.setItem(
      STORAGE_KEYS.POTENTIAL_PUSH_PROGRESS,
      JSON.stringify({
        lastStep: Math.max(0, Number(potentialPushProgress.lastStep) || 0),
        lastStatus:
          potentialPushProgress.lastStatus === "ahead" || potentialPushProgress.lastStatus === "behind"
            ? potentialPushProgress.lastStatus
            : null,
        baselineKey: potentialPushProgress.baselineKey || null,
        stepMultiplier: Math.min(
          POTENTIAL_PUSH_MAX_MULTIPLIER,
          Math.max(1, Number(potentialPushProgress.stepMultiplier) || 1)
        ),
        lastNotifiedAt:
          Number.isFinite(Number(potentialPushProgress.lastNotifiedAt)) &&
          Number(potentialPushProgress.lastNotifiedAt) > 0
            ? Number(potentialPushProgress.lastNotifiedAt)
            : 0,
      })
    ).catch(() => {});
  }, [potentialPushHydrated, potentialPushProgress]);

  useEffect(() => {
    AsyncStorage.setItem(STORAGE_KEYS.PENDING, JSON.stringify(pendingList)).catch(() => {});
  }, [pendingList]);

  useEffect(() => {
    if (!freeDayHydrated) return;
    AsyncStorage.setItem(STORAGE_KEYS.FREE_DAY, JSON.stringify(freeDayStats)).catch(() => {});
  }, [freeDayStats, freeDayHydrated]);

  useEffect(() => {
    AsyncStorage.setItem(STORAGE_KEYS.REFUSE_STATS, JSON.stringify(refuseStats)).catch(() => {});
  }, [refuseStats]);

  useEffect(() => {
    if (!temptationInteractionsHydrated) return;
    AsyncStorage.setItem(
      STORAGE_KEYS.TEMPTATION_INTERACTIONS,
      JSON.stringify(temptationInteractions)
    ).catch(() => {});
  }, [temptationInteractions, temptationInteractionsHydrated]);

  useEffect(() => {
    if (analyticsOptOut === null) return;
    setAnalyticsOptOutFlag(analyticsOptOut);
    AsyncStorage.setItem(
      STORAGE_KEYS.ANALYTICS_OPT_OUT,
      analyticsOptOut ? "1" : "0"
    ).catch(() => {});
  }, [analyticsOptOut]);

  useEffect(() => {
    AsyncStorage.setItem(
      STORAGE_KEYS.REWARDS_CELEBRATED,
      JSON.stringify(rewardCelebratedMap)
    ).catch(() => {});
  }, [rewardCelebratedMap]);
  useEffect(() => {
    if (analyticsOptOut !== false) return;
    if (!profileHydrated) return;
    if (notificationPermissionGranted === null) return;
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const hasGoalProperty =
      (Array.isArray(profile.primaryGoals) && profile.primaryGoals.length > 0) ||
      (wishes || []).some((wish) => wish.kind === PRIMARY_GOAL_KIND);
    const totalDecisions =
      (decisionStats?.resolvedToDeclines || 0) + (decisionStats?.resolvedToWishes || 0);
    let savingStyle = "balanced";
    if (totalDecisions > 0) {
      const declineShare = (decisionStats.resolvedToDeclines || 0) / totalDecisions;
      if (declineShare >= 0.7) {
        savingStyle = "aggressive";
      } else if (declineShare <= 0.4) {
        savingStyle = "relaxed";
      }
    }
    const personaType = profile.persona || DEFAULT_PERSONA_ID;
    const genderValue = profile.gender || "none";
    const notificationsAllowed = notificationPermissionGranted === true;
    setUserProperties({
      has_goal: !!hasGoalProperty,
      preferred_currency: currencyCode,
      saving_style: savingStyle,
      locale: language,
      is_premium: false,
      gender: genderValue,
      persona_type: personaType,
      notifications_allowed: notificationsAllowed,
    });
  }, [
    analyticsOptOut,
    decisionStats?.resolvedToDeclines,
    decisionStats?.resolvedToWishes,
    language,
    notificationPermissionGranted,
    profile.currency,
    profile.gender,
    profile.persona,
    profile.primaryGoals,
    profileHydrated,
    wishes,
  ]);

  useEffect(() => {
    if (!rewardsReady || !rewardCelebratedHydrated || !achievements.length) return;
    const newlyUnlocked = achievements.filter(
      (reward) => reward.unlocked && !rewardCelebratedMap[reward.id]
    );
    if (!newlyUnlocked.length) return;
    newlyUnlocked.forEach((reward) => {
      logEvent("reward_unlocked", {
        reward_id: reward.id,
        type: "badge",
        condition: ACHIEVEMENT_CONDITION_MAP[reward.metricType] || reward.metricType || "unknown",
      });
    });
    setRewardCelebratedMap((prev) => {
      const next = { ...prev };
      newlyUnlocked.forEach((reward) => {
        next[reward.id] = true;
      });
      return next;
    });
    triggerOverlayState("reward", newlyUnlocked[0].title);
  }, [achievements, logEvent, rewardCelebratedHydrated, rewardCelebratedMap, rewardsReady]);

  useEffect(() => {
    if (!wishesHydrated || !savedTotalHydrated) return;
    setWishes((prev) => {
      if (!prev.length) return prev;
      let changed = false;
      const next = prev.slice();
      let manualReserved = 0;
      const manualEntries = [];
      prev.forEach((wish, index) => {
        const isManualWish = wish.autoManaged === false || wish.kind === PRIMARY_GOAL_KIND;
        if (isManualWish) {
          const saved = Math.max(0, wish.savedUSD || 0);
          manualReserved += saved;
          manualEntries.push({ index, saved });
        }
      });
      if (manualReserved > savedTotalUSD) {
        let deficit = manualReserved - savedTotalUSD;
        for (let i = manualEntries.length - 1; i >= 0 && deficit > 0; i--) {
          const entry = manualEntries[i];
          const currentWish = next[entry.index];
          const savedValue = currentWish.savedUSD || 0;
          if (savedValue <= 0) continue;
          const deduction = Math.min(savedValue, deficit);
          if (deduction > 0) {
            const newSaved = savedValue - deduction;
            const status = newSaved >= (currentWish.targetUSD || 0) ? "done" : "active";
            next[entry.index] = { ...currentWish, savedUSD: newSaved, status };
            changed = true;
            deficit -= deduction;
          }
        }
        manualReserved = Math.min(manualReserved, savedTotalUSD);
      }
      let remaining = Math.max(0, savedTotalUSD - manualReserved);
      for (let i = 0; i < next.length; i++) {
        const wish = next[i];
        const isManualWish = wish.autoManaged === false || wish.kind === PRIMARY_GOAL_KIND;
        if (isManualWish) {
          const status = (wish.savedUSD || 0) >= (wish.targetUSD || 0) ? "done" : "active";
          if (wish.status !== status) {
            next[i] = { ...wish, status };
            changed = true;
          }
          continue;
        }
        const target = wish.targetUSD || 0;
        const newSaved = Math.min(target, Math.max(remaining, 0));
        remaining = Math.max(0, remaining - newSaved);
        const status = newSaved >= target ? "done" : "active";
        if (newSaved !== (wish.savedUSD || 0) || status !== wish.status) {
          next[i] = { ...wish, savedUSD: newSaved, status };
          changed = true;
        }
      }
      return changed ? next : prev;
    });
  }, [savedTotalUSD, wishes, savedTotalHydrated, wishesHydrated]);

  useEffect(() => {
    AsyncStorage.setItem(STORAGE_KEYS.DECISION_STATS, JSON.stringify(decisionStats)).catch(() => {});
  }, [decisionStats]);

  useEffect(() => {
    AsyncStorage.setItem(STORAGE_KEYS.HISTORY, JSON.stringify(resolvedHistoryEvents)).catch(() => {});
  }, [resolvedHistoryEvents]);

  useEffect(() => {
    AsyncStorage.setItem(STORAGE_KEYS.CUSTOM_TEMPTATIONS, JSON.stringify(quickTemptations)).catch(
      () => {}
    );
  }, [quickTemptations]);

  useEffect(() => {
    AsyncStorage.setItem(STORAGE_KEYS.HIDDEN_TEMPTATIONS, JSON.stringify(hiddenTemptations)).catch(
      () => {}
    );
  }, [hiddenTemptations]);

  useEffect(() => {
    AsyncStorage.setItem(STORAGE_KEYS.IMPULSE_TRACKER, JSON.stringify(impulseTracker)).catch(
      () => {}
    );
  }, [impulseTracker]);

  useEffect(() => {
    const nextList = DEFAULT_TEMPTATIONS.map((item) => {
      const overrideCategory = categoryOverrides[item.id];
      const normalizedCategory =
        overrideCategory && IMPULSE_CATEGORY_DEFS[overrideCategory] ? overrideCategory : null;
      const precisionOverride = pricePrecisionOverrides[item.id];
      const normalizedPrecision =
        typeof precisionOverride === "number" && Number.isFinite(precisionOverride) && precisionOverride >= 0
          ? precisionOverride
          : item.pricePrecision ?? null;
      return {
        ...item,
        priceUSD: catalogOverrides[item.id] ?? item.basePriceUSD,
        pricePrecision: normalizedPrecision,
        titleOverride: titleOverrides[item.id] || null,
        emoji: emojiOverrides[item.id] || item.emoji,
        impulseCategoryOverride: normalizedCategory || item.impulseCategoryOverride || null,
        descriptionOverride: descriptionOverrides[item.id] || item.descriptionOverride || null,
      };
    }).sort(
      (a, b) =>
        (a.priceUSD ?? a.basePriceUSD ?? 0) - (b.priceUSD ?? b.basePriceUSD ?? 0)
    );
    const personalized = buildPersonalizedTemptations(profile, nextList).map((card) => {
      const overrideCategory = categoryOverrides[card.id];
      const normalizedCategory =
        overrideCategory && IMPULSE_CATEGORY_DEFS[overrideCategory] ? overrideCategory : null;
      const precisionOverride = pricePrecisionOverrides[card.id];
      const normalizedPrecision =
        typeof precisionOverride === "number" && Number.isFinite(precisionOverride) && precisionOverride >= 0
          ? precisionOverride
          : card.pricePrecision ?? null;
      return {
        ...card,
        priceUSD: catalogOverrides[card.id] ?? card.priceUSD ?? card.basePriceUSD,
        pricePrecision: normalizedPrecision,
        titleOverride: titleOverrides[card.id] ?? card.titleOverride ?? null,
        emoji: emojiOverrides[card.id] || card.emoji,
        impulseCategoryOverride: normalizedCategory || card.impulseCategoryOverride || null,
        descriptionOverride:
          descriptionOverrides[card.id] ?? card.descriptionOverride ?? null,
      };
    });
    const hiddenSet = new Set(hiddenTemptations);
    const personalizedVisible = personalized.filter((card) => !hiddenSet.has(card.id));
    const personalizedIds = new Set(personalizedVisible.map((c) => c.id));
    const quickAdjusted = quickTemptations
      .filter((card) => card && !hiddenSet.has(card.id) && !personalizedIds.has(card.id))
      .map((card) => {
        const overrideCategory = categoryOverrides[card.id];
        const normalizedCategory =
          overrideCategory && IMPULSE_CATEGORY_DEFS[overrideCategory] ? overrideCategory : null;
        const precisionOverride = pricePrecisionOverrides[card.id];
        const normalizedPrecision =
          typeof precisionOverride === "number" && Number.isFinite(precisionOverride) && precisionOverride >= 0
            ? precisionOverride
            : card.pricePrecision ?? null;
        return {
          ...card,
          priceUSD: catalogOverrides[card.id] ?? card.priceUSD ?? card.basePriceUSD,
          pricePrecision: normalizedPrecision,
          titleOverride: titleOverrides[card.id] ?? card.titleOverride ?? null,
          emoji: emojiOverrides[card.id] || card.emoji,
          impulseCategoryOverride: normalizedCategory || card.impulseCategoryOverride || null,
          descriptionOverride:
            descriptionOverrides[card.id] ?? card.descriptionOverride ?? null,
        };
      });
    // –ë—ã—Å—Ç—Ä–∞—è –∫–∞—Å—Ç–æ–º–Ω–∞—è –∫–∞—Ä—Ç–∞ –≤—Å–µ–≥–¥–∞ —Ä–µ–Ω–¥–µ—Ä–∏—Ç—Å—è –ø–µ—Ä–≤–æ–π, –∑–∞—Ç–µ–º –∏–¥—ë—Ç –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫.
    const combined = [...quickAdjusted, ...personalizedVisible];

    setTemptations(combined);
  }, [
    catalogOverrides,
    pricePrecisionOverrides,
    profile,
    titleOverrides,
    emojiOverrides,
    categoryOverrides,
    descriptionOverrides,
    quickTemptations,
    hiddenTemptations,
    onboardingStep,
  ]);

  useEffect(() => {
    return () => {
      if (overlayTimer.current) clearTimeout(overlayTimer.current);
      Object.values(cardFeedbackTimers.current).forEach((timer) => clearTimeout(timer));
    };
  }, []);

  useEffect(() => {
    if (!focusTemplateId) return;
    const exists =
      [...quickTemptations, ...temptations].some((card) => card?.id === focusTemplateId) ||
      focusTemplateId === primaryTemptationId;
    if (!exists) {
      setFocusTemplateId(null);
      setFocusSaveCount(0);
    }
  }, [focusTemplateId, primaryTemptationId, quickTemptations, temptations]);

  const handleCategorySelect = useCallback((category) => {
    triggerHaptic();
    setActiveCategory(category);
  }, []);

  const handleTabChange = (tabKey) => {
    triggerHaptic();
    setActiveTab(tabKey);
  };

  const handleThemeToggle = (mode) => {
    triggerHaptic();
    setTheme(mode);
  };

  const handleLanguageChange = (lng) => {
    const nextLanguage = normalizeLanguage(lng);
    triggerHaptic();
    setLanguage(nextLanguage);
    if (onboardingStep !== "done") {
      logEvent("onboarding_language_chosen", { language: nextLanguage });
    }
  };

  const handleTermsOpen = () => {
    triggerHaptic();
    setTermsContinuePending(false);
    setTermsModalVisible(true);
  };

  const handleTermsCancel = () => {
    triggerHaptic();
    setTermsContinuePending(false);
    setTermsModalVisible(false);
  };

  const handleTermsLinkOpen = () => {
    const normalizedLanguage = normalizeLanguage(language);
    const url = TERMS_LINKS[normalizedLanguage] || TERMS_LINKS.en;
    if (!url) return;
    triggerHaptic();
    Linking.openURL(url).catch((error) => console.warn("terms link", error));
  };

  const handleTermsAccept = () => {
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    const shouldAdvance = termsContinuePending;
    setTermsAccepted(true);
    setTermsModalVisible(false);
    setTermsContinuePending(false);
    AsyncStorage.setItem(STORAGE_KEYS.TERMS_ACCEPTED, "1").catch(() => {});
    logEvent("onboarding_terms_accepted", { language });
    logEvent("consent_terms_accepted", { language });
    if (shouldAdvance) {
      goToOnboardingStep("guide");
    }
  };

  const handleProfileCurrencyChange = (code) => {
    if (!CURRENCIES.includes(code) || profile.currency === code) return;
    triggerHaptic();
    setProfile((prev) => ({ ...prev, currency: code }));
    setProfileDraft((prev) => ({ ...prev, currency: code }));
    setRegistrationData((prev) => ({ ...prev, currency: code }));
    setActiveCurrency(code);
  };

  const handleAnalyticsToggle = (enabled) => {
    if (analyticsOptOut === null) return;
    triggerHaptic();
    setAnalyticsOptOutState(!enabled);
    logEvent("consent_analytics_enabled", { enabled, source: "settings" });
  };

  const handleActiveGoalSelect = useCallback(
    (goalId) => {
      if (!goalId) return;
      triggerHaptic();
      const previousGoalId = activeGoalId || profile.goal;
      clearCompletedPrimaryGoal(previousGoalId);
      setActiveGoalId(goalId);
      setProfile((prev) => ({
        ...prev,
        goal: goalId,
        goalCelebrated: false,
        goalRenewalPending: false,
      }));
      setProfileDraft((prev) => ({
        ...prev,
        goal: goalId,
        goalCelebrated: false,
        goalRenewalPending: false,
      }));
      dismissGoalRenewalPrompt();
    },
    [dismissGoalRenewalPrompt, triggerHaptic, activeGoalId, profile.goal, clearCompletedPrimaryGoal]
  );

  const handleProfileGoalChange = (goalId) => {
    if (!goalId) return;
    triggerHaptic();
    const rawGoals = Array.isArray(profile.primaryGoals) ? profile.primaryGoals : [];
    const normalizedGoals = [];
    const dedupe = new Set();
    rawGoals.forEach((entry) => {
      const id = entry?.id;
      if (!id || dedupe.has(id)) return;
      dedupe.add(id);
      const targetUSD =
        Number.isFinite(entry?.targetUSD) && entry.targetUSD > 0
          ? entry.targetUSD
          : getGoalDefaultTargetUSD(id);
      const normalized = {
        ...entry,
        id,
        targetUSD,
        savedUSD: Number.isFinite(entry?.savedUSD) ? entry.savedUSD : 0,
        status: entry?.status || "active",
        createdAt: entry?.createdAt || Date.now(),
      };
      normalizedGoals.push(normalized);
    });
    const previousGoalId = profile.goal || normalizedGoals[0]?.id || DEFAULT_PROFILE.goal;
    if (previousGoalId === goalId) return;
    const previousWish = wishes.find(
      (wish) =>
        wish.kind === PRIMARY_GOAL_KIND &&
        (wish.goalId === previousGoalId || wish.id === previousGoalId)
    );
    if (!normalizedGoals.some((goal) => goal.id === previousGoalId)) {
      const fallbackTarget = getGoalDefaultTargetUSD(previousGoalId);
      normalizedGoals.unshift({
        id: previousGoalId,
        targetUSD: fallbackTarget,
        savedUSD: Number(previousWish?.savedUSD) || 0,
        status: previousWish?.status || "active",
        createdAt: previousWish?.createdAt || Date.now(),
      });
    } else if (previousWish) {
      const prevIndex = normalizedGoals.findIndex((goal) => goal.id === previousGoalId);
      if (prevIndex !== -1) {
        normalizedGoals[prevIndex] = {
          ...normalizedGoals[prevIndex],
          savedUSD: Number.isFinite(previousWish.savedUSD)
            ? previousWish.savedUSD
            : normalizedGoals[prevIndex].savedUSD || 0,
          status: previousWish.status || normalizedGoals[prevIndex].status || "active",
          createdAt: previousWish.createdAt || normalizedGoals[prevIndex].createdAt || Date.now(),
        };
      }
    }
    const formatGoalLabel = (id, entry = null) => {
      if (!id) return "";
      const preset = getGoalPreset(id);
      const customTitle = typeof entry?.customTitle === "string" ? entry.customTitle.trim() : "";
      const hasCustomTitle = !!customTitle;
      const customEmoji = entry?.customEmoji
        ? normalizeEmojiValue(entry.customEmoji, DEFAULT_GOAL_EMOJI)
        : null;
      const resolvedEmoji = hasCustomTitle
        ? customEmoji || DEFAULT_GOAL_EMOJI
        : preset?.emoji || DEFAULT_GOAL_EMOJI;
      const resolvedLabel = hasCustomTitle ? customTitle : preset?.[language] || preset?.en || id;
      return `${resolvedEmoji} ${resolvedLabel || id}`.trim();
    };
    const existingEntry = normalizedGoals.find((goal) => goal.id === goalId) || null;
    const nextGoalEntry = existingEntry
      ? { ...existingEntry }
      : {
          id: goalId,
          targetUSD: getGoalDefaultTargetUSD(goalId),
          savedUSD: 0,
          status: "active",
          createdAt: Date.now(),
        };
    const filteredGoals = normalizedGoals.filter((goal) => goal.id !== goalId);
    const nextPrimaryGoals = [nextGoalEntry, ...filteredGoals];
    const activeGoal = nextGoalEntry.id || DEFAULT_PROFILE.goal;
    const activeTargetUSD =
      Number.isFinite(nextGoalEntry.targetUSD) && nextGoalEntry.targetUSD > 0
        ? nextGoalEntry.targetUSD
        : getGoalDefaultTargetUSD(activeGoal);
    setActiveGoalId(activeGoal);
    setProfile((prev) => ({
      ...prev,
      primaryGoals: nextPrimaryGoals,
      goal: activeGoal,
      goalTargetUSD: activeTargetUSD,
      goalCelebrated: false,
      goalRenewalPending: false,
    }));
    setProfileDraft((prev) => ({
      ...prev,
      primaryGoals: nextPrimaryGoals,
      goal: activeGoal,
      goalTargetUSD: activeTargetUSD,
      goalCelebrated: false,
      goalRenewalPending: false,
    }));
    ensurePrimaryGoalWish(nextPrimaryGoals, language, activeGoal);
    if (previousGoalId && previousGoalId !== activeGoal) {
      const previousEntry = normalizedGoals.find((goal) => goal.id === previousGoalId) || null;
      logHistoryEvent("goal_cancelled", {
        goalId: previousGoalId,
        title: formatGoalLabel(previousGoalId, previousEntry),
      });
    }
    logHistoryEvent("goal_started", {
      goalId: activeGoal,
      title: formatGoalLabel(activeGoal, nextGoalEntry),
    });
  };

  const handleLanguageContinue = () => {
    triggerHaptic();
    if (!termsAccepted) {
      setTermsModalVisible(true);
      setTermsContinuePending(true);
      return;
    }
    goToOnboardingStep("guide");
  };

  const handleGuideContinue = () => {
    triggerHaptic();
    goToOnboardingStep("register");
  };

  const updateRegistrationData = (field, value) => {
    if (field === "currency") {
      setActiveCurrency(value);
      if (onboardingStep !== "done") {
        logEvent("onboarding_currency_chosen", { currency: value });
      }
    }
    if (field === "persona" && onboardingStep !== "done") {
      const habitType = PERSONA_HABIT_TYPES[value] || "custom";
      logEvent("onboarding_persona_chosen", { persona_id: value, habit_type: habitType });
    }
    setRegistrationData((prev) => ({ ...prev, [field]: value }));
  };

  const ensurePrimaryGoalWish = useCallback(
    (goalEntries = [], lng, activeGoal = null) => {
      const entries = Array.isArray(goalEntries) ? goalEntries : [];
      const targetEntry =
        (activeGoal && entries.find((entry) => entry?.id === activeGoal)) || entries[0] || null;
      const firstEntry = targetEntry ? [targetEntry] : [];
      setWishes((prev) => {
        const existingMap = new Map();
        prev.forEach((wish) => {
          if (
            wish.kind === PRIMARY_GOAL_KIND ||
            wish.id === PRIMARY_GOAL_WISH_ID_LEGACY ||
            (typeof wish.id === "string" && wish.id.startsWith("wish_primary_goal_"))
          ) {
            const key = wish.goalId || wish.id.replace("wish_primary_goal_", "") || "legacy";
            existingMap.set(key, wish);
          }
        });
        const nonPrimary = prev.filter(
          (wish) =>
            wish.kind !== PRIMARY_GOAL_KIND &&
            wish.id !== PRIMARY_GOAL_WISH_ID_LEGACY &&
            !(typeof wish.id === "string" && wish.id.startsWith("wish_primary_goal_"))
        );
        const languageKey = lng || "en";
        const nextPrimary = firstEntry
          .filter((entry) => entry?.id)
          .map((entry) => {
            const goalPreset = getGoalPreset(entry.id);
            const customTitle = typeof entry?.customTitle === "string" ? entry.customTitle.trim() : "";
            const hasCustomTitle = !!customTitle;
            const customEmoji = entry?.customEmoji
              ? normalizeEmojiValue(entry.customEmoji, DEFAULT_GOAL_EMOJI)
              : null;
            const resolvedEmoji = hasCustomTitle
              ? customEmoji || DEFAULT_GOAL_EMOJI
              : goalPreset?.emoji || DEFAULT_GOAL_EMOJI;
        const presetLabel = goalPreset?.[languageKey] || goalPreset?.en || entry.id;
        const resolvedLabel = hasCustomTitle ? customTitle : presetLabel || entry.id;
        const title = `${resolvedEmoji} ${resolvedLabel}`.trim();
        const targetUSD =
          Number.isFinite(entry.targetUSD) && entry.targetUSD > 0
            ? entry.targetUSD
            : getGoalDefaultTargetUSD(entry.id);
        const existing = existingMap.get(entry.id);
        const canReuseExisting = existing && existing.status !== "done";
        const fallbackSavedUSD = Number.isFinite(entry.savedUSD) ? entry.savedUSD : 0;
        const fallbackStatus = entry?.status && entry.status !== "done" ? entry.status : "active";
        const fallbackCreatedAt = entry?.createdAt || Date.now();
        return {
          id: getPrimaryGoalWishId(entry.id),
          templateId: `goal_${entry.id}`,
          title,
          emoji: resolvedEmoji,
          targetUSD,
          savedUSD: canReuseExisting ? existing.savedUSD || 0 : fallbackSavedUSD,
          status: canReuseExisting ? existing.status || "active" : fallbackStatus,
          createdAt: canReuseExisting ? existing.createdAt || Date.now() : fallbackCreatedAt,
              autoManaged: true,
              kind: PRIMARY_GOAL_KIND,
              goalId: entry.id,
            };
          });
        return [...nextPrimary, ...nonPrimary];
      });
    },
    [setWishes]
  );

  const openImagePickerSheet = (resolver) => {
    imagePickerResolver.current = resolver;
    setShowImageSourceSheet(true);
  };

  const closeImagePickerSheet = () => {
    setShowImageSourceSheet(false);
    imagePickerResolver.current = null;
  };

  const handleImageSourceChoice = async (source) => {
    const resolver = imagePickerResolver.current;
    closeImagePickerSheet();
    if (!resolver) return;
    await pickImage(source, (uri) => {
      if (!uri) return;
      resolver(uri);
    });
  };

  const handlePickImage = () => {
    openImagePickerSheet((uri) =>
      setProfileDraft((prev) => ({
        ...prev,
        avatar: uri,
      }))
    );
  };

  const handleRegistrationPickImage = () => {
    openImagePickerSheet((uri) =>
      setRegistrationData((prev) => ({
        ...prev,
        avatar: uri,
      }))
    );
  };

  const handleRegistrationSubmit = () => {
    if (!registrationData.firstName.trim()) {
      Alert.alert("Almost", t("inputFirstName"));
      return;
    }
    if (!registrationData.currency) {
      Alert.alert("Almost", t("currencyLabel"));
      return;
    }
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    goToOnboardingStep("persona");
  };

  const handleCoinSliderMaxUpdate = useCallback((nextUSD) => {
    if (!Number.isFinite(nextUSD) || nextUSD <= 0) return;
    setCoinSliderMaxUSD(nextUSD);
  }, []);
  const openCoinEntry = useCallback(
    (source = "unknown") => {
      coinEntryContextRef.current = {
        source,
        openedAt: Date.now(),
        submitted: false,
      };
      setCoinEntryVisible(true);
      logEvent("coin_entry_opened", { source });
    },
    [logEvent]
  );
  const handleCoinEntryClose = useCallback(() => {
    const context = coinEntryContextRef.current;
    if (context?.source) {
      logEvent("coin_entry_closed", {
        source: context.source,
        result: context.submitted ? "submitted" : "dismissed",
        duration_ms: Math.max(0, Date.now() - (context.openedAt || 0)),
      });
    }
    coinEntryContextRef.current = { source: null, openedAt: 0, submitted: false };
    setCoinEntryVisible(false);
  }, [logEvent]);

  const handleQuickCustomChange = (field, value) => {
    setQuickSpendDraft((prev) => ({
      ...prev,
      [field]:
        field === "emoji"
          ? limitEmojiInput(value)
          : field === "category"
          ? (IMPULSE_CATEGORY_DEFS[value] ? value : prev.category)
          : value,
    }));
  };

  const resolveTemptationCategory = useCallback(
    (item) => {
      if (!item) return DEFAULT_IMPULSE_CATEGORY;
      const override = categoryOverrides[item.id];
      if (override && IMPULSE_CATEGORY_DEFS[override]) {
        return override;
      }
      if (item.impulseCategoryOverride && IMPULSE_CATEGORY_DEFS[item.impulseCategoryOverride]) {
        return item.impulseCategoryOverride;
      }
      if (Array.isArray(item.categories)) {
        const match = IMPULSE_CATEGORY_ORDER.find((slug) => item.categories.includes(slug));
        if (match) return match;
      }
      const inferred = resolveImpulseCategory(item);
      return IMPULSE_CATEGORY_DEFS[inferred] ? inferred : DEFAULT_IMPULSE_CATEGORY;
    },
    [categoryOverrides]
  );

  const handleQuickCustomSubmit = (customData) => {
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const parsedAmount = parseFloat((customData.amount || "").replace(",", "."));
    if (!customData.title?.trim() || !Number.isFinite(parsedAmount) || parsedAmount <= 0) {
      Alert.alert("Almost", t("customSpendTitle"));
      return;
    }
    const amountUSD = convertFromCurrency(parsedAmount, currencyCode);
    const ownerGender = profile.gender || "none";
    const emojiValue = normalizeEmojiValue(customData.emoji, DEFAULT_TEMPTATION_EMOJI);
    const category =
      customData.category && IMPULSE_CATEGORY_DEFS[customData.category]
        ? customData.category
        : DEFAULT_IMPULSE_CATEGORY;
    const newCustom = {
      title: customData.title.trim(),
      amountUSD,
      currency: currencyCode,
      emoji: emojiValue,
      id: customData.id || `custom_habit_${Date.now()}`,
      gender: ownerGender,
      impulseCategory: category,
    };
    const card = createCustomHabitTemptation(newCustom, currencyCode, ownerGender);
    if (card) {
      card.gender = ownerGender;
      setQuickTemptations((prev) => [card, ...prev]);
    }
    setCategoryOverrides((prev) => ({ ...prev, [newCustom.id]: category }));
    logEvent("temptation_created", {
      temptation_id: newCustom.id,
      is_custom: true,
      category,
      price: convertToCurrency(amountUSD, currencyCode),
    });
    setQuickSpendDraft({ title: "", amount: "", emoji: DEFAULT_TEMPTATION_EMOJI, category: DEFAULT_IMPULSE_CATEGORY });
    setShowCustomSpend(false);
    triggerOverlayState("custom_temptation", newCustom.title);
  };

  const handleQuickCustomCancel = () => {
    setQuickSpendDraft({ title: "", amount: "", emoji: DEFAULT_TEMPTATION_EMOJI, category: DEFAULT_IMPULSE_CATEGORY });
    setShowCustomSpend(false);
  };

  const handleCoinEntrySubmit = useCallback(
    async ({ amountUSD, category, direction }) => {
      if (!Number.isFinite(amountUSD) || amountUSD <= 0) return;
      if (!category || !IMPULSE_CATEGORY_DEFS[category]) return;
      const action = direction === "save" ? "save" : "spend";
      const entryId = `coin_entry_${Date.now()}`;
      const categoryDef = IMPULSE_CATEGORY_DEFS[category];
      const title = action === "save" ? t("coinEntrySaveLabel") : t("coinEntrySpendLabel");
      const virtualItem = {
        id: entryId,
        title,
        emoji: categoryDef.emoji || "‚ú®",
        priceUSD: amountUSD,
        basePriceUSD: amountUSD,
        categories: [category],
        impulseCategoryOverride: category,
      };
      const entryContext = coinEntryContextRef.current || {};
      const entrySource = entryContext.source || "unknown";
      logEvent("coin_entry_submit", {
        source: entrySource,
        direction: action,
        amount_usd: amountUSD,
        category,
      });
      coinEntryContextRef.current = {
        source: entrySource,
        openedAt: entryContext.openedAt || Date.now(),
        submitted: true,
      };
      if (action === "save") {
        const fallbackGoal = activeGoalId || profile.goal || getFallbackGoalId();
        await handleTemptationAction("save", virtualItem, {
          skipPrompt: true,
          goalId: fallbackGoal,
          shouldAssign: false,
        });
      } else {
        await handleTemptationAction("spend", virtualItem, {
          bypassSpendPrompt: true,
        });
      }
      handleCoinEntryClose();
    },
    [activeGoalId, getFallbackGoalId, handleCoinEntryClose, handleTemptationAction, logEvent, profile.goal, t]
  );

  const handleFabNewTemptation = useCallback(() => {
    triggerHaptic();
    closeFabMenu();
    setQuickSpendDraft({ title: "", amount: "", emoji: DEFAULT_TEMPTATION_EMOJI, category: DEFAULT_IMPULSE_CATEGORY });
    setShowCustomSpend(true);
  }, [closeFabMenu, triggerHaptic]);

  const handleFabNewGoal = useCallback(() => {
    triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    closeFabMenu();
    openNewGoalModal(false, "fab_menu");
  }, [closeFabMenu, openNewGoalModal, triggerHaptic]);

  const handleNewGoalChange = useCallback((field, value) => {
    setNewGoalModal((prev) => ({
      ...prev,
      [field]: field === "emoji" ? limitEmojiInput(value) : value,
    }));
  }, []);

  const handleNewGoalCancel = useCallback(() => {
    if (newGoalModal.visible) {
      logEvent("goal_creator_cancelled", {
        source: newGoalModal.source || "unknown",
        make_primary: newGoalModal.makePrimary ? 1 : 0,
      });
    }
    setNewGoalModal({
      visible: false,
      name: "",
      target: "",
      emoji: DEFAULT_GOAL_EMOJI,
      makePrimary: false,
      source: "unknown",
    });
  }, [logEvent, newGoalModal]);

  const handleNewGoalSubmit = useCallback(() => {
    const trimmedName = (newGoalModal.name || "").trim();
    if (!trimmedName) {
      Alert.alert("Almost", t("goalEditNameError"));
      return;
    }
    const parsedLocal = parseNumberInputValue(newGoalModal.target);
    if (!Number.isFinite(parsedLocal) || parsedLocal <= 0) {
      Alert.alert("Almost", t("goalEditTargetError"));
      return;
    }
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const targetUSD = convertFromCurrency(parsedLocal, currencyCode);
    const emoji = normalizeEmojiValue(newGoalModal.emoji, DEFAULT_GOAL_EMOJI);
    if (newGoalModal.makePrimary) {
      const goalId = `custom_goal_${Date.now()}`;
      const goalEntry = {
        id: goalId,
        targetUSD,
        customTitle: trimmedName,
        customEmoji: emoji,
        savedUSD: 0,
        status: "active",
        createdAt: Date.now(),
      };
      const existingGoals = Array.isArray(profile.primaryGoals) ? profile.primaryGoals : [];
      const nextPrimaryGoals = [
        goalEntry,
        ...existingGoals.filter((entry) => entry?.id && entry.id !== goalId),
      ];
      const activeTargetUSD = targetUSD > 0 ? targetUSD : getGoalDefaultTargetUSD(goalId);
      setProfile((prev) => ({
        ...prev,
        primaryGoals: nextPrimaryGoals,
        goal: goalId,
        goalTargetUSD: activeTargetUSD,
        goalCelebrated: false,
        goalRenewalPending: false,
      }));
      setProfileDraft((prev) => ({
        ...prev,
        primaryGoals: nextPrimaryGoals,
        goal: goalId,
        goalTargetUSD: activeTargetUSD,
        goalCelebrated: false,
        goalRenewalPending: false,
      }));
      setActiveGoalId(goalId);
      ensurePrimaryGoalWish(nextPrimaryGoals, language, goalId);
      logHistoryEvent("wish_added", {
        title: trimmedName,
        targetUSD,
        templateId: "manual_primary_goal",
        wishId: getPrimaryGoalWishId(goalId),
      });
      logEvent("goal_manual_created", {
        title: trimmedName,
        target_usd: targetUSD,
        currency: currencyCode,
        is_primary: 1,
      });
      logEvent("goal_created", {
        goal_id: goalId,
        goal_type: resolveGoalTypeFromTarget(targetUSD),
        target_amount: convertToCurrency(targetUSD, currencyCode),
      });
    } else {
      const newWish = {
        id: `wish-manual-${Date.now()}`,
        templateId: null,
        title: trimmedName,
        targetUSD,
        savedUSD: 0,
        status: "active",
        createdAt: Date.now(),
        autoManaged: false,
        emoji,
      };
      setWishes((prev) => insertWishAfterPrimary(prev, newWish));
      ensureActiveGoalForNewWish(newWish);
      logHistoryEvent("wish_added", { title: trimmedName, targetUSD, templateId: "manual_goal", wishId: newWish.id });
      logEvent("goal_manual_created", {
        title: trimmedName,
        target_usd: targetUSD,
        currency: currencyCode,
      });
      logEvent("goal_created", {
        goal_id: newWish.id,
        goal_type: resolveGoalTypeFromTarget(targetUSD),
        target_amount: convertToCurrency(targetUSD, currencyCode),
      });
    }
    triggerOverlayState("purchase", t("wishAdded", { title: trimmedName }));
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    dismissGoalRenewalPrompt();
    setNewGoalModal({
      visible: false,
      name: "",
      target: "",
      emoji: DEFAULT_GOAL_EMOJI,
      makePrimary: false,
      source: "unknown",
    });
  }, [
    dismissGoalRenewalPrompt,
    ensureActiveGoalForNewWish,
    ensurePrimaryGoalWish,
    language,
    logEvent,
    logHistoryEvent,
    newGoalModal,
    profile.primaryGoals,
    profile.currency,
    setProfile,
    setProfileDraft,
    setWishes,
    t,
    triggerHaptic,
    triggerOverlayState,
  ]);

  const openOnboardingGoalModal = useCallback(() => {
    triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    setOnboardingGoalModal({ visible: true, name: "", target: "", emoji: DEFAULT_GOAL_EMOJI });
  }, [triggerHaptic]);

  const handleOnboardingGoalChange = useCallback((field, value) => {
    setOnboardingGoalModal((prev) => ({
      ...prev,
      [field]: field === "emoji" ? limitEmojiInput(value) : value,
    }));
  }, []);

  const handleOnboardingGoalCancel = useCallback(() => {
    setOnboardingGoalModal({ visible: false, name: "", target: "", emoji: DEFAULT_GOAL_EMOJI });
  }, []);

  const handleOnboardingGoalSubmit = useCallback(() => {
    const trimmedName = (onboardingGoalModal.name || "").trim();
    if (!trimmedName) {
      Alert.alert("Almost", t("goalEditNameError"));
      return;
    }
    const parsedLocal = parseNumberInputValue(onboardingGoalModal.target);
    if (!Number.isFinite(parsedLocal) || parsedLocal <= 0) {
      Alert.alert("Almost", t("goalEditTargetError"));
      return;
    }
    const currencyCode = registrationData.currency || DEFAULT_PROFILE.currency;
    const targetUSD = convertFromCurrency(parsedLocal, currencyCode);
    const emoji = normalizeEmojiValue(onboardingGoalModal.emoji, DEFAULT_GOAL_EMOJI);
    const id = `custom_goal_${Date.now()}`;
    const formattedLocal = formatNumberInputValue(parsedLocal);
    setRegistrationData((prev) => {
      const selections = prev.goalSelections || [];
      const nextSelections = selections.includes(id) ? selections : [...selections, id];
      return {
        ...prev,
        customGoals: [
          ...(prev.customGoals || []),
          { id, title: trimmedName, emoji, targetUSD, targetLocal: formattedLocal },
        ],
        goalSelections: nextSelections,
        goalTargetMap: {
          ...(prev.goalTargetMap || {}),
          [id]: formattedLocal,
        },
      };
    });
    logEvent("onboarding_goal_custom_created", {
      title: trimmedName,
      target_usd: targetUSD,
      currency: currencyCode,
    });
    logEvent("goal_created", {
      goal_id: id,
      goal_type: resolveGoalTypeFromTarget(targetUSD),
      target_amount: convertToCurrency(targetUSD, currencyCode),
    });
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    setOnboardingGoalModal({ visible: false, name: "", target: "", emoji: DEFAULT_GOAL_EMOJI });
  }, [onboardingGoalModal, registrationData.currency, setRegistrationData, t, triggerHaptic]);

  const handlePersonaSubmit = () => {
    if (!registrationData.persona) {
      Alert.alert("Almost", t("personaHabitLabel"));
      return;
    }
    triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    goToOnboardingStep("habit");
  };

  const handleHabitSubmit = (skip = false) => {
    let sanitizedFrequency = null;
    if (!skip) {
      if (!registrationData.customSpendTitle.trim()) {
        Alert.alert("Almost", t("customSpendTitle"));
        return;
      }
      const parsed = parseFloat((registrationData.customSpendAmount || "").replace(",", "."));
      if (!Number.isFinite(parsed) || parsed <= 0) {
        Alert.alert("Almost", t("customSpendAmountLabel"));
        return;
      }
      const frequencyValue = parseFloat(
        (registrationData.customSpendFrequency || "").replace(",", ".")
      );
      if (!Number.isFinite(frequencyValue) || frequencyValue <= 0) {
        Alert.alert("Almost", t("customSpendFrequencyLabel"));
        return;
      }
      sanitizedFrequency = Math.max(1, Math.round(frequencyValue));
      setRegistrationData((prev) => ({
        ...prev,
        customSpendFrequency: `${sanitizedFrequency}`,
      }));
    } else {
      setRegistrationData((prev) => ({
        ...prev,
        customSpendTitle: "",
        customSpendAmount: "",
        customSpendFrequency: "",
        customSpendCategory: DEFAULT_IMPULSE_CATEGORY,
      }));
    }
    const customAmountLocal = parseFloat((registrationData.customSpendAmount || "").replace(",", "."));
    const hasCustom =
      !skip &&
      registrationData.customSpendTitle.trim() &&
      Number.isFinite(customAmountLocal) &&
      customAmountLocal > 0;
    const customAmountUSD = hasCustom
      ? convertFromCurrency(customAmountLocal, registrationData.currency || DEFAULT_PROFILE.currency)
      : 0;
    const frequencyPerWeek = hasCustom ? sanitizedFrequency || 0 : 0;
    logEvent("onboarding_custom_spend", {
      has_custom: !!hasCustom,
      price_usd: customAmountUSD || 0,
      frequency_per_week: frequencyPerWeek,
    });
    triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    goToOnboardingStep("baseline");
  };

  const handleBaselineSubmit = () => {
    const currencyCode =
      registrationData.currency || profile.currency || DEFAULT_PROFILE.currency;
    const parsedLocal = parseNumberInputValue(registrationData.baselineMonthlyWaste || "");
    if (!Number.isFinite(parsedLocal) || parsedLocal <= 0) {
      Alert.alert("Almost", t("baselineInputError"));
      return;
    }
    triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
    const timestamp = new Date().toISOString();
    setRegistrationData((prev) => ({
      ...prev,
      baselineMonthlyWaste: formatNumberInputValue(parsedLocal),
      baselineCapturedAt: timestamp,
    }));
    goToOnboardingStep("goal");
  };

  const handleBaselineSetupPrompt = () => {
    triggerHaptic();
    setRegistrationData((prev) => ({
      ...prev,
      currency: profile.currency || prev.currency || DEFAULT_PROFILE.currency,
      baselineMonthlyWaste: "",
      baselineCapturedAt: null,
    }));
    goToOnboardingStep("baseline");
  };

  const handleGoalToggle = (goalId) => {
    triggerHaptic();
    const currentSelections = registrationData.goalSelections || [];
    const wasSelected = currentSelections.includes(goalId);
    const preset = getGoalPreset(goalId);
    const customGoal = customGoalMap[goalId];
    setRegistrationData((prev) => {
      const selections = prev.goalSelections || [];
      const nextSelections = selections.includes(goalId)
        ? selections.filter((id) => id !== goalId)
        : [...selections, goalId];
      const currencyCode = prev.currency || DEFAULT_PROFILE.currency;
      const nextTargetMap = { ...(prev.goalTargetMap || {}) };
      if (selections.includes(goalId)) {
        delete nextTargetMap[goalId];
      } else {
        let defaultLocal = "";
        if (customGoal?.targetLocal) {
          defaultLocal = customGoal.targetLocal;
        } else if (Number.isFinite(customGoal?.targetUSD) && customGoal.targetUSD > 0) {
          defaultLocal = formatNumberInputValue(
            convertToCurrency(customGoal.targetUSD, currencyCode)
          );
        }
        if (!(goalId in nextTargetMap)) {
          nextTargetMap[goalId] = defaultLocal;
        }
      }
      const confirmed = (prev.goalTargetConfirmed || []).filter((id) => id !== goalId);
      return {
        ...prev,
        goalSelections: nextSelections,
        goalTargetMap: nextTargetMap,
        goalTargetConfirmed: confirmed,
      };
    });
    if (!wasSelected && onboardingStep !== "done") {
      logEvent("onboarding_goal_chosen", {
        goal_id: goalId,
        target_usd: customGoal?.targetUSD || 0,
      });
    }
  };

  const handleGoalTargetSubmit = async () => {
    const selections = registrationData.goalSelections || [];
    if (!selections.length) {
      Alert.alert("Almost", t("goalTitle"));
      return;
    }
    const currencyCode = registrationData.currency || DEFAULT_PROFILE.currency;
    const targets = [];
    for (const goalId of selections) {
      const draftValue = registrationData.goalTargetMap?.[goalId];
      const parsedLocal = parseNumberInputValue(draftValue || "");
      if (!Number.isFinite(parsedLocal) || parsedLocal <= 0) {
        Alert.alert("Almost", t("goalTargetError"));
        return;
      }
      targets.push({
        id: goalId,
        usd: convertFromCurrency(parsedLocal, currencyCode),
      });
    }
    setPendingGoalTargets(targets);
    setRegistrationData((prev) => ({
      ...prev,
      goalTargetConfirmed: selections.slice(),
    }));
    goToOnboardingStep("analytics_consent");
  };

  const handleGoalTargetDraftChange = (goalId, value) => {
    setRegistrationData((prev) => ({
      ...prev,
      goalTargetMap: {
        ...(prev.goalTargetMap || {}),
        [goalId]: value,
      },
    }));
  };

  const handleGoalStageContinue = async () => {
    const selections = registrationData.goalSelections || [];
    if (!selections.length) {
      Alert.alert("Almost", t("goalTitle"));
      return;
    }
    const currentMap = registrationData.goalTargetMap || {};
    let patchedMap = null;
    let needsTargetStep = false;
    const confirmedSet = new Set(registrationData.goalTargetConfirmed || []);
    for (const goalId of selections) {
      const workingMap = patchedMap || currentMap;
      const draftValue = workingMap[goalId];
      let parsedValue = parseNumberInputValue(draftValue || "");
      if (!Number.isFinite(parsedValue) || parsedValue <= 0) {
        const customGoal = customGoalMap[goalId];
        const fallbackValue = customGoal?.targetLocal || "";
        const fallbackParsed = parseNumberInputValue(fallbackValue || "");
        if (Number.isFinite(fallbackParsed) && fallbackParsed > 0) {
          if (!patchedMap) {
            patchedMap = { ...currentMap };
          }
          patchedMap[goalId] = fallbackValue;
          parsedValue = fallbackParsed;
        }
      }
      if (!Number.isFinite(parsedValue) || parsedValue <= 0) {
        needsTargetStep = true;
      }
      if (!customGoalMap[goalId] && !confirmedSet.has(goalId)) {
        needsTargetStep = true;
      }
    }
    if (patchedMap) {
      const mapToPersist = patchedMap;
      setRegistrationData((prev) => ({
        ...prev,
        goalTargetMap: {
          ...(prev.goalTargetMap || {}),
          ...mapToPersist,
        },
      }));
    }
    triggerHaptic();
    if (needsTargetStep) {
      goToOnboardingStep("goal_target");
      return;
    }
    await handleGoalTargetSubmit();
  };

  const handleGoalComplete = async (targetsOverride = null) => {
    const selections = registrationData.goalSelections || [];
    if (!selections.length) {
      Alert.alert("Almost", t("goalTitle"));
      return;
    }
    const currencyCode = registrationData.currency || DEFAULT_PROFILE.currency;
    const targets =
      targetsOverride && targetsOverride.length
        ? targetsOverride
        : selections.map((goalId) => {
            const draftValue = registrationData.goalTargetMap?.[goalId];
            const parsedLocal = parseNumberInputValue(draftValue || "");
            const usd = Number.isFinite(parsedLocal) && parsedLocal > 0
              ? convertFromCurrency(parsedLocal, currencyCode)
              : getGoalDefaultTargetUSD(goalId);
            return { id: goalId, usd };
          });
    const primaryGoals = targets.map((entry) => {
      const goalId = entry.id;
      const targetUSD = entry.usd > 0 ? entry.usd : getGoalDefaultTargetUSD(goalId);
      const customGoal = customGoalMap[goalId];
      const customTitle = typeof customGoal?.title === "string" ? customGoal.title.trim() : "";
      const base = {
        id: goalId,
        targetUSD,
        savedUSD: 0,
        status: "active",
        createdAt: Date.now(),
      };
      if (customTitle) {
        base.customTitle = customTitle;
      }
      if (customGoal?.emoji) {
        base.customEmoji = normalizeEmojiValue(customGoal.emoji, DEFAULT_GOAL_EMOJI);
      }
      return base;
    });
    const activeGoalTargetUSD =
      Number.isFinite(primaryGoals[0]?.targetUSD) && primaryGoals[0].targetUSD > 0
        ? primaryGoals[0].targetUSD
        : getGoalDefaultTargetUSD(primaryGoals[0]?.id || selections[0] || DEFAULT_PROFILE.goal);
    const displayName = `${registrationData.firstName} ${registrationData.lastName}`.trim()
      || registrationData.firstName.trim()
      || DEFAULT_PROFILE.name;
    const personaId = registrationData.persona || DEFAULT_PERSONA_ID;
    const gender = registrationData.gender || "none";
    let customSpend = null;
    const customName = registrationData.customSpendTitle?.trim();
    const customAmount = parseFloat((registrationData.customSpendAmount || "").replace(",", "."));
    const customFrequency = parseFloat(
      (registrationData.customSpendFrequency || "").replace(",", ".")
    );
    if (customName && Number.isFinite(customAmount) && customAmount > 0) {
      const amountUSD = convertFromCurrency(customAmount, registrationData.currency);
      const categoryValue =
        registrationData.customSpendCategory && IMPULSE_CATEGORY_DEFS[registrationData.customSpendCategory]
          ? registrationData.customSpendCategory
          : DEFAULT_IMPULSE_CATEGORY;
      customSpend = {
        title: customName,
        amountUSD,
        currency: registrationData.currency,
        frequencyPerWeek:
          Number.isFinite(customFrequency) && customFrequency > 0
            ? Math.round(customFrequency)
            : 0,
        impulseCategory: categoryValue,
      };
      logEvent("temptation_created", {
        temptation_id: profile.customSpend?.id || "custom_habit",
        is_custom: true,
        category: categoryValue,
        price: customAmount,
      });
    }
    let spendingProfile = profile.spendingProfile || { ...DEFAULT_PROFILE.spendingProfile };
    const baselineLocal = parseNumberInputValue(registrationData.baselineMonthlyWaste || "");
    if (Number.isFinite(baselineLocal) && baselineLocal > 0) {
      spendingProfile = {
        baselineMonthlyWasteUSD: convertFromCurrency(baselineLocal, currencyCode),
        baselineStartAt: registrationData.baselineCapturedAt || new Date().toISOString(),
      };
    }
    const updatedProfile = {
      ...profile,
      name: displayName,
      firstName: registrationData.firstName,
      lastName: registrationData.lastName,
      subtitle: registrationData.motto || profile.subtitle,
      motto: registrationData.motto || profile.motto,
      avatar: registrationData.avatar || profile.avatar,
      currency: registrationData.currency,
      goal: primaryGoals[0]?.id || DEFAULT_PROFILE.goal,
      primaryGoals,
      goalTargetUSD: activeGoalTargetUSD,
      goalCelebrated: false,
      persona: personaId,
      gender,
      customSpend,
      spendingProfile,
      joinedAt: profile.joinedAt || new Date().toISOString(),
      goalRenewalPending: false,
    };
    setProfile(updatedProfile);
    setProfileDraft(updatedProfile);
    setActiveGoalId(updatedProfile.goal);
    await AsyncStorage.setItem(STORAGE_KEYS.PROFILE, JSON.stringify(updatedProfile)).catch(() => {});
    await AsyncStorage.setItem(STORAGE_KEYS.ONBOARDING, "done").catch(() => {});
    await AsyncStorage.setItem(STORAGE_KEYS.TUTORIAL, "pending").catch(() => {});
    setTutorialSeen(false);
    setFabTutorialVisible(false);
    setFabTutorialStateAndPersist(FAB_TUTORIAL_STATUS.PENDING);
    setFabTutorialEligible(false);
    homeSessionRef.current.sessionCount = 0;
    homeSessionRef.current.pendingIndex = null;
    homeSessionRef.current.dateKey = getDayKey(Date.now());
    setActiveCurrency(updatedProfile.currency);
    ensurePrimaryGoalWish(primaryGoals, language, updatedProfile.goal);
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    const hasPrimaryGoal = primaryGoals.length > 0;
    const startBalanceLocal = convertToCurrency(
      savedTotalUSD || 0,
      updatedProfile.currency || DEFAULT_PROFILE.currency
    );
    logEvent("onboarding_completed", {
      persona_id: personaId,
      goal_id: primaryGoals[0]?.id || selections[0] || DEFAULT_PROFILE.goal,
      has_goal: hasPrimaryGoal,
      start_balance: startBalanceLocal,
    });
    setTimeout(() => {
      goToOnboardingStep("done", { recordHistory: false, resetHistory: true });
      setRegistrationData(INITIAL_REGISTRATION);
    }, 500);
  };

  const handleAnalyticsConsentComplete = async (allowAnalytics) => {
    const optOut = !allowAnalytics;
    setAnalyticsOptOutState(optOut);
    setAnalyticsOptOutFlag(optOut);
    logEvent("consent_analytics_enabled", { enabled: allowAnalytics, source: "onboarding" });
    const targets = pendingGoalTargets;
    setPendingGoalTargets(null);
    await handleGoalComplete(targets && targets.length ? targets : null);
  };

  const ensureMediaPermission = async (type) => {
    if (type === "library" && Platform.OS === "android") {
      return true;
    }
    const getter =
      type === "camera"
        ? ImagePicker.getCameraPermissionsAsync
        : ImagePicker.getMediaLibraryPermissionsAsync;
    const requester =
      type === "camera"
        ? ImagePicker.requestCameraPermissionsAsync
        : ImagePicker.requestMediaLibraryPermissionsAsync;

    const current = await getter();
    if (current?.granted) return true;
    const requestResult = await requester();
    if (requestResult?.granted) return true;

    Alert.alert(
      "Almost",
      requestResult?.canAskAgain ? t("photoPermissionDenied") : t("photoPermissionSettings"),
      [
        {
          text: t("profileCancel"),
          style: "cancel",
        },
        !requestResult?.canAskAgain
          ? {
              text: t("openSettings"),
              onPress: () => Linking.openSettings?.(),
            }
          : null,
      ].filter(Boolean)
    );
    return false;
  };

  const pickImage = async (source = "library", onPicked) => {
    try {
      triggerHaptic();
      const type = source === "camera" ? "camera" : "library";
      const permitted = await ensureMediaPermission(type);
      if (!permitted) return;
      const pickerOptions = {
        mediaTypes: ["images"],
        quality: 0.8,
        ...(SHOULD_USE_ANDROID_LEGACY_MEDIA_PICKER ? { legacy: true } : {}),
      };
      const result =
        source === "camera"
          ? await ImagePicker.launchCameraAsync(pickerOptions)
          : await ImagePicker.launchImageLibraryAsync(pickerOptions);
      if (!result.canceled && result.assets?.length) {
        const uri = result.assets[0].uri;
        onPicked?.(uri);
      }
    } catch (error) {
      const errorMessage =
        error?.message && error.message.includes("canceled")
          ? null
          : `${t("photoPickerError")}\n${error?.message || ""}`.trim();
      if (errorMessage) {
        Alert.alert("Almost", errorMessage);
      }
      console.warn("image picker", error);
    }
  };

  const registerSmartReminder = useCallback(
    async (entry) => {
      if (!entry) return;
      if (!["refuse_spend", "pending_to_decline", "spend"].includes(entry.kind)) return;
      const timestamp = Number(entry.timestamp) || Date.now();
      const now = Date.now();
      const baseTriggerTime = timestamp + SMART_REMINDER_DELAY_MS;
      if (!Number.isFinite(baseTriggerTime) || baseTriggerTime <= now) return;
      // Space reminders so Android does not deliver multiple notifications at once.
      const futureReminders = (smartRemindersRef.current || []).filter((reminder) => {
        const scheduledAt = Number(reminder?.scheduledAt);
        return Number.isFinite(scheduledAt) && scheduledAt > now;
      });
      const lastScheduledAt = futureReminders.reduce(
        (latest, reminder) => Math.max(latest, Number(reminder.scheduledAt) || 0),
        0
      );
      const triggerTime =
        lastScheduledAt > 0
          ? Math.max(baseTriggerTime, lastScheduledAt + SMART_REMINDER_MIN_INTERVAL_MS)
          : baseTriggerTime;
      const permitted = await ensureNotificationPermission();
      if (!permitted) return;
      const templateId = entry.meta?.templateId || entry.meta?.id || entry.meta?.template_id;
      const metaTitle =
        (typeof entry.meta?.title === "string" && entry.meta.title.trim()) ||
        resolveTemplateTitle(templateId, "") ||
        "";
      const title = metaTitle || t("defaultDealTitle");
      const isSpendEvent = entry.kind === "spend";
      try {
        const notificationId = await Notifications.scheduleNotificationAsync({
          content: {
            title: isSpendEvent
              ? t("smartInsightSpendTitle", { temptation: title })
              : t("smartInsightDeclineTitle", { temptation: title }),
            body: isSpendEvent
              ? t("smartInsightSpendBody", { temptation: title })
              : t("smartInsightDeclineBody", { temptation: title }),
          },
          trigger: new Date(triggerTime),
        });
        const payload = {
          id: `smart-${entry.id}`,
          eventId: entry.id,
          kind: entry.kind,
          title,
          timestamp,
          scheduledAt: triggerTime,
          notificationId,
        };
        setSmartReminders((prev) => normalizeSmartReminderEntries([payload, ...prev]));
      } catch (error) {
        console.warn("smart reminder schedule", error);
      }
    },
    [ensureNotificationPermission, resolveTemplateTitle, setSmartReminders, t]
  );

  const logHistoryEvent = useCallback(
    (kind, meta = {}) => {
      const timestamp = Date.now();
      const entry = {
        id: `history-${timestamp}-${Math.random().toString(16).slice(2, 6)}`,
        kind,
        meta,
        timestamp,
      };
      setHistoryEvents((prev) => {
        const next = [entry, ...prev].filter((item) => {
          if (!item?.timestamp) return false;
          return timestamp - item.timestamp <= HISTORY_RETENTION_MS;
        });
        return next.slice(0, MAX_HISTORY_EVENTS);
      });
      setChallengesState((prev) => applyChallengeEvent(prev, entry));
      registerSmartReminder(entry);
    },
    [registerSmartReminder, setChallengesState]
  );

  const recomputeHistoryAggregates = useCallback(
    (list) => {
      let nextDeclines = 0;
      let resolvedToWishes = 0;
      let resolvedToDeclines = 0;
      const nextRefuseStats = {};
      (list || []).forEach((entry) => {
        if (!entry) return;
        if (entry.kind === "refuse_spend") {
          const amount = Math.max(0, Number(entry.meta?.amountUSD) || 0);
          nextDeclines += 1;
          const templateId =
            entry.meta?.templateId || entry.meta?.id || entry.meta?.title || "unknown";
          const current = nextRefuseStats[templateId] || {
            count: 0,
            totalUSD: 0,
            lastSavedAt: 0,
            lastSavedAmountUSD: 0,
          };
          current.count += 1;
          current.totalUSD += amount;
          if (!current.lastSavedAt || (entry.timestamp || 0) > current.lastSavedAt) {
            current.lastSavedAt = entry.timestamp || 0;
            current.lastSavedAmountUSD = amount;
          }
          nextRefuseStats[templateId] = current;
        } else if (entry.kind === "pending_to_wish") {
          resolvedToWishes += 1;
        } else if (entry.kind === "pending_to_decline") {
          resolvedToDeclines += 1;
        }
      });
      setDeclineCount(nextDeclines);
      setRefuseStats(nextRefuseStats);
      setDecisionStats((prev) => ({
        ...prev,
        resolvedToWishes,
        resolvedToDeclines,
      }));
    },
    [setDeclineCount, setDecisionStats, setRefuseStats, setSavedTotalUSD]
  );

  const rebuildSavingsFromHistory = useCallback(
    (list) => {
      const normalized = Array.isArray(list) ? list.filter(Boolean) : [];
      if (!normalized.length) {
        setSavedTotalUSD(0);
        setLifetimeSavedUSD(0);
        return;
      }
      const sorted = normalized.slice().sort((a, b) => {
        const aStamp = typeof a?.timestamp === "number" ? a.timestamp : 0;
        const bStamp = typeof b?.timestamp === "number" ? b.timestamp : 0;
        return aStamp - bStamp;
      });
      let running = 0;
      let peak = 0;
      sorted.forEach((entry) => {
        if (!entry?.kind) return;
        const amount = Math.max(0, Number(entry?.meta?.amountUSD) || 0);
        if (!amount) return;
        if (HISTORY_SAVED_GAIN_EVENTS.has(entry.kind)) {
          running += amount;
        } else if (HISTORY_SAVED_LOSS_EVENTS.has(entry.kind)) {
          running -= amount;
        }
        if (running < 0) running = 0;
        if (running > peak) peak = running;
      });
      setSavedTotalUSD(running);
      setLifetimeSavedUSD(peak);
    },
    [setLifetimeSavedUSD, setSavedTotalUSD]
  );

  const handleHistoryDelete = useCallback(
    (entry) => {
      if (!entry) return;
      const entryId = entry.id;
      if (entry.kind === "refuse_spend") {
        const amountUSD = Math.max(0, Number(entry.meta?.amountUSD) || 0);
        const metaCoinReward = Math.max(0, Number(entry.meta?.coinReward) || 0);
        const resolvedCurrency = entry.meta?.currency || profile.currency || DEFAULT_PROFILE.currency;
        const coinRefund = metaCoinReward > 0
          ? metaCoinReward
          : computeRefuseCoinReward(amountUSD, resolvedCurrency);
        if (coinRefund > 0) {
          setHealthPoints((prev) => Math.max(0, prev - coinRefund));
        }
      }
      setHistoryEvents((prev) => {
        const next = prev.filter((h) => h.id !== entryId);
        AsyncStorage.setItem(STORAGE_KEYS.HISTORY, JSON.stringify(next)).catch(() => {});
        rebuildSavingsFromHistory(next);
        setChallengesState((prevState) => rebuildChallengeProgressFromHistory(next, prevState));
        return next;
      });
      if (entry.kind === "pending_added" && entry.meta?.pendingId) {
        setPendingList((prev) => prev.filter((p) => p.id !== entry.meta.pendingId));
      }
      if (entry.kind === "wish_added" && entry.meta?.wishId) {
        setWishes((prev) => prev.filter((w) => w.id !== entry.meta.wishId));
      }
    },
    [profile.currency, rebuildSavingsFromHistory, setPendingList, setWishes, setHealthPoints, setChallengesState]
  );

  useEffect(() => {
    recomputeHistoryAggregates(resolvedHistoryEvents);
  }, [resolvedHistoryEvents, recomputeHistoryAggregates]);
  const maybeTriggerNorthStarMetric = useCallback(() => {
    if (!northStarHydrated || !profileHydrated || northStarLoggedRef.current) return;
    if (!profileJoinedAt) return;
    const joinedAtTimestamp = new Date(profileJoinedAt).getTime();
    if (!Number.isFinite(joinedAtTimestamp)) return;
    const windowEnd = joinedAtTimestamp + NORTH_STAR_WINDOW_MS;
    let savesInWindow = 0;
    resolvedHistoryEvents.forEach((entry) => {
      if (entry?.kind !== "refuse_spend") return;
      const eventTimestamp = typeof entry.timestamp === "number" ? entry.timestamp : 0;
      if (!eventTimestamp) return;
      if (eventTimestamp >= joinedAtTimestamp && eventTimestamp <= windowEnd) {
        savesInWindow += 1;
      }
    });
    if (savesInWindow < NORTH_STAR_SAVE_THRESHOLD) return;
    const hoursSinceJoinRaw = Math.max(0, (Date.now() - joinedAtTimestamp) / (1000 * 60 * 60));
    const hoursSinceJoin = Math.min(24, Math.round(hoursSinceJoinRaw * 10) / 10);
    setNorthStarLogged(true);
    northStarLoggedRef.current = true;
    AsyncStorage.setItem(
      STORAGE_KEYS.NORTH_STAR_METRIC,
      JSON.stringify({
        logged: true,
        loggedAt: new Date().toISOString(),
        savesInWindow,
      })
    ).catch(() => {});
    logEvent("north_star_two_saves", {
      saves_in_window: savesInWindow,
      hours_since_join: hoursSinceJoin,
    });
  }, [logEvent, northStarHydrated, profileHydrated, profileJoinedAt, resolvedHistoryEvents]);
  useEffect(() => {
    maybeTriggerNorthStarMetric();
  }, [maybeTriggerNorthStarMetric]);

  const triggerCardFeedback = useCallback((templateId) => {
    if (!templateId) return;
    const burstKey = Date.now();
    setCardFeedback((prev) => ({
      ...prev,
      [templateId]: {
        ...(prev[templateId] || {}),
        message: true,
        burstKey,
      },
    }));
    if (cardFeedbackTimers.current[templateId]) {
      clearTimeout(cardFeedbackTimers.current[templateId]);
    }
    cardFeedbackTimers.current[templateId] = setTimeout(() => {
      setCardFeedback((prev) => {
        const entry = prev[templateId];
        if (!entry) return prev;
        return {
          ...prev,
          [templateId]: {
            ...entry,
            message: false,
          },
        };
      });
      delete cardFeedbackTimers.current[templateId];
    }, 2000);
  }, []);

  const triggerCoinHaptics = useCallback(() => {
    const pulses = [0, 90, 180, 270];
    pulses.forEach((delay) => {
      setTimeout(() => {
        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light).catch(() => {});
      }, delay);
    });
  }, []);

  const closeSpendPrompt = useCallback(() => {
    setSpendPrompt({ visible: false, item: null });
  }, []);

  const processMascotQueue = useCallback(() => {
    if (overlay || mascotBusyRef.current) return;
    if (!mascotQueueRef.current.length) return;
    const next = mascotQueueRef.current.shift();
    if (!next) return;
    mascotBusyRef.current = true;
    setMascotOverride({ ...next, key: Date.now() });
  }, [overlay]);

  useEffect(() => {
    if (!overlay) {
      processMascotQueue();
    }
  }, [overlay, processMascotQueue]);

  const requestMascotAnimation = useCallback(
    (type, duration) => {
      const resolvedDuration = duration || TAMAGOTCHI_REACTION_DURATION[type] || 3200;
      mascotQueueRef.current.push({ type, duration: resolvedDuration });
      processMascotQueue();
    },
    [processMascotQueue]
  );

  const feedTamagotchi = useCallback(
    (foodId = TAMAGOTCHI_DEFAULT_FOOD_ID) => {
      const food = TAMAGOTCHI_FOOD_MAP[foodId] || TAMAGOTCHI_FOOD_MAP[TAMAGOTCHI_DEFAULT_FOOD_ID];
      if (!food) return;
      if (tamagotchiState.hunger >= TAMAGOTCHI_MAX_HUNGER) {
        Alert.alert(t("tamagotchiName"), t("tamagotchiFullMessage"));
        return;
      }
      if (tamagotchiCoins < food.cost) {
        const hint = t("tamagotchiEarnCoinsHint");
        const needText = t("tamagotchiNeedCoinsMessage", { cost: food.cost, emoji: food.emoji });
        Alert.alert(t("tamagotchiName"), `${needText}\n\n${hint}`);
        return;
      }
      let hungerBefore = tamagotchiState.hunger;
      let hungerAfter = tamagotchiState.hunger;
      setTamagotchiState((prev) => {
        const prevHunger = Math.max(0, Number(prev.hunger) || 0);
        const nextHunger = Math.min(TAMAGOTCHI_MAX_HUNGER, prevHunger + food.hungerBoost);
        hungerBefore = prevHunger;
        hungerAfter = nextHunger;
        const nextFoodId = resolveNextTamagotchiFoodId(nextHunger, food.id, true);
        return {
          ...prev,
          hunger: nextHunger,
          lastFedAt: new Date().toISOString(),
          desiredFoodId: nextFoodId,
        };
      });
      const coinsAfter = Math.max(0, tamagotchiCoins - food.cost);
      logEvent("tamagotchi_feed", {
        food_id: food.id,
        food_cost: food.cost,
        hunger_before: hungerBefore,
        hunger_after: hungerAfter,
        coins_before: tamagotchiCoins,
        coins_after: coinsAfter,
      });
      triggerHaptic(Haptics.ImpactFeedbackStyle.Heavy);
      setHealthPoints((coins) => Math.max(0, coins - food.cost));
      requestMascotAnimation("happy", 3600);
    },
    [logEvent, requestMascotAnimation, setHealthPoints, t, tamagotchiCoins, tamagotchiState.hunger]
  );

  const stopPartyEffects = useCallback(() => {
    if (partyGlowAnimRef.current) {
      partyGlowAnimRef.current.stop();
      partyGlowAnimRef.current = null;
    }
    partyGlow.setValue(0);
    setPartyActive(false);
  }, [partyGlow]);

  const runPartyEffects = useCallback(
    (cyclesLeft = 2) => {
      const executeCycle = (remaining) => {
        if (remaining <= 0) {
          stopPartyEffects();
          return;
        }
        setPartyBurstKey((prev) => prev + 1);
        const glowPulse = Animated.sequence([
          Animated.timing(partyGlow, {
            toValue: 1,
            duration: 400,
            easing: Easing.out(Easing.quad),
            useNativeDriver: true,
          }),
          Animated.timing(partyGlow, {
            toValue: 0,
            duration: 400,
            easing: Easing.in(Easing.quad),
            useNativeDriver: true,
          }),
          Animated.delay(320),
        ]);
        partyGlowAnimRef.current = glowPulse;
        glowPulse.start(() => executeCycle(remaining - 1));
      };
      executeCycle(cyclesLeft);
    },
    [partyGlow, stopPartyEffects]
  );

  useEffect(() => {
    return () => {
      stopPartyEffects();
    };
  }, [stopPartyEffects]);


  const startParty = useCallback(() => {
    if (tamagotchiCoins < TAMAGOTCHI_PARTY_COST) {
      const hint = t("tamagotchiEarnCoinsHint");
      const needText = t("tamagotchiPartyNeedCoinsMessage", {
        amount: TAMAGOTCHI_PARTY_BLUE_COST,
      });
      Alert.alert(t("tamagotchiName"), `${needText}\n\n${hint}`);
      return;
    }
    setHealthPoints((coins) => Math.max(0, coins - TAMAGOTCHI_PARTY_COST));
    stopPartyEffects();
    setPartyActive(true);
    runPartyEffects(2);
    requestMascotAnimation("happyHeadshake", 3600);
  }, [requestMascotAnimation, runPartyEffects, setHealthPoints, stopPartyEffects, t, tamagotchiCoins]);

  const handleMascotAnimationComplete = useCallback(() => {
    mascotBusyRef.current = false;
    if (!overlay && mascotQueueRef.current.length) {
      const next = mascotQueueRef.current.shift();
      if (next) {
        mascotBusyRef.current = true;
        setMascotOverride({ ...next, key: Date.now() });
        return;
      }
    }
    setMascotOverride(null);
  }, [overlay]);

  const triggerStormEffect = useCallback(() => {
    if (stormTimerRef.current) {
      clearTimeout(stormTimerRef.current);
    }
    setStormActive(true);
    stormTimerRef.current = setTimeout(() => setStormActive(false), 2400);
  }, []);
  const recordTemptationInteraction = useCallback((templateId, actionType) => {
    if (!templateId) return;
    if (actionType !== "save" && actionType !== "spend") return;
    setTemptationInteractions((prev) => {
      const prevEntry = prev?.[templateId] || { saveCount: 0, spendCount: 0, lastInteractionAt: 0 };
      const nextEntry = {
        saveCount: (prevEntry.saveCount || 0) + (actionType === "save" ? 1 : 0),
        spendCount: (prevEntry.spendCount || 0) + (actionType === "spend" ? 1 : 0),
        lastInteractionAt: Date.now(),
      };
      return {
        ...(prev || {}),
        [templateId]: nextEntry,
      };
    });
  }, []);
  const executeSpend = useCallback(
    (item) => {
      if (!item) return;
      const priceUSD = item.priceUSD || item.basePriceUSD || 0;
      const title = `${item.emoji || "‚ú®"} ${
        item.title?.[language] || item.title?.en || item.title || "wish"
      }`;
      registerFocusLoss(item);
      handleFocusSpend(item);
      logHistoryEvent("spend", { title, amountUSD: priceUSD });
      triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
      setSavedTotalUSD((prev) => Math.max(prev - priceUSD, 0));
      setPurchases((prev) => [
        {
          id: `spend-${item.id}-${Date.now()}`,
          title,
          price: priceUSD,
          paidAmount: priceUSD,
          createdAt: Date.now(),
        },
        ...prev,
      ]);
      setFreeDayStats((prev) => {
        const todayKey = getDayKey(Date.now());
        if (!prev) {
          return { ...INITIAL_FREE_DAY_STATS, blockedDate: todayKey };
        }
        if (prev.blockedDate === todayKey && prev.current === 0) {
          return prev;
        }
        const next = {
          ...prev,
          current: 0,
          blockedDate: todayKey,
        };
        return next;
      });
      logImpulseEvent("spend", item, priceUSD, title);
      requestMascotAnimation(Math.random() > 0.5 ? "sad" : "ohno");
      recordTemptationInteraction(item.id, "spend");
    },
    [handleFocusSpend, language, logHistoryEvent, logImpulseEvent, recordTemptationInteraction, registerFocusLoss, requestMascotAnimation, setFreeDayStats]
  );

  const handleSpendConfirm = useCallback(() => {
    if (!spendPrompt.item) return;
    const item = spendPrompt.item;
    closeSpendPrompt();
    triggerStormEffect();
    executeSpend(item);
  }, [closeSpendPrompt, executeSpend, spendPrompt.item, triggerStormEffect]);

  const buildTemptationPayload = useCallback(
    (item, extra = {}) => {
      const priceUSD = item.priceUSD || item.basePriceUSD || 0;
      return {
        item_id: item.id,
        price_usd: priceUSD,
        categories: (item.categories || []).join(","),
        persona: profile.persona || "unknown",
        currency: profile.currency || DEFAULT_PROFILE.currency,
        ...extra,
      };
    },
    [profile.currency, profile.persona]
  );

  const logTemptationAction = useCallback(
    (action, item, extra = {}) => {
      if (!item || !action) return;
      logEvent("temptation_action", buildTemptationPayload(item, { action, ...extra }));
    },
    [buildTemptationPayload]
  );

  const logImpulseEvent = useCallback(
    (action, item, amountUSD = 0, overrideTitle = null) => {
      if (!item || (action !== "save" && action !== "spend")) return;
      const timestamp = Date.now();
      const entryTitle =
        overrideTitle ||
        `${item.emoji || "‚ú®"} ${
          item.title?.[language] || item.title?.en || item.title || t("defaultDealTitle")
        }`;
      const event = {
        id: `impulse-${timestamp}-${Math.random().toString(16).slice(2, 6)}`,
        templateId: item.id,
        title: entryTitle,
        emoji: item.emoji || "‚ú®",
        category: resolveImpulseCategory(item),
        action,
        amountUSD: amountUSD || item.priceUSD || item.basePriceUSD || 0,
        timestamp,
        hour: new Date(timestamp).getHours(),
      };
      setImpulseTracker((prev) => {
        const nextEvents = [event, ...(prev?.events || [])].slice(0, MAX_IMPULSE_EVENTS);
        return {
          ...(prev || INITIAL_IMPULSE_TRACKER),
          events: nextEvents,
        };
      });
    },
    [language, t]
  );

  const handleTemptationAction = useCallback(
    async (type, item, options = {}) => {
      const {
        skipPrompt = false,
        goalId: forcedGoalId = null,
        shouldAssign = false,
        pinnedBy = null,
        bypassSpendPrompt = false,
      } = options || {};
      const priceUSD = item.priceUSD || item.basePriceUSD || 0;
      const title = `${item.emoji || "‚ú®"} ${
        item.title?.[language] || item.title?.en || item.title || "wish"
      }`;
      const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
      const priceLocal = convertToCurrency(priceUSD, currencyCode);
      const balanceLocal = convertToCurrency(savedTotalUSD, currencyCode);
      if (type === "spend") {
        logTemptationAction("spend", item);
        logEvent("temptation_spend", buildTemptationPayload(item, { total_saved_usd: savedTotalUSD }));
        logEvent("temptation_decision", {
          temptation_id: item.id,
          decision: "spend",
          price: priceLocal,
          balance_before: balanceLocal,
        });
        if (bypassSpendPrompt) {
          triggerStormEffect();
          executeSpend(item);
        } else {
          setSpendPrompt({ visible: true, item });
        }
        return;
      }
      if (type === "want") {
        logTemptationAction("wish", item);
        logEvent("temptation_want", buildTemptationPayload(item));
        const newWish = {
          id: `wish-${item.id}-${Date.now()}`,
          templateId: item.id,
          title,
          targetUSD: priceUSD,
          savedUSD: 0,
          status: "active",
          createdAt: Date.now(),
          autoManaged: false,
          emoji: item.emoji || DEFAULT_GOAL_EMOJI,
          pinnedSource: pinnedBy,
        };
        setWishes((prev) => insertWishAfterPrimary(prev, newWish));
        logHistoryEvent("wish_added", { title, targetUSD: priceUSD, templateId: item.id, wishId: newWish.id });
        triggerOverlayState("purchase", t("wishAdded", { title }));
        triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
        return;
      }
      if (type === "save") {
        const saveTimestamp = Date.now();
        const windowStart = saveTimestamp - SAVE_SPAM_WINDOW_MS;
        const recentSaves = saveActionLogRef.current.filter(
          (entry) => entry.timestamp >= windowStart
        );
        const sameItemCount = recentSaves.filter((entry) => entry.itemId === item.id).length;
        const totalSaveCount = recentSaves.length;
        if (sameItemCount >= SAVE_SPAM_ITEM_LIMIT) {
          Alert.alert("Almost", t("saveSpamWarningItem"));
          return;
        }
        if (totalSaveCount >= SAVE_SPAM_GLOBAL_LIMIT) {
          Alert.alert("Almost", t("saveSpamWarningGlobal"));
          return;
        }
        const storedGoalId = resolveTemptationGoalId(item.id);
        const desiredGoalId = forcedGoalId || storedGoalId;
        const shouldPrompt =
          !skipPrompt && assignableGoals.length > 1 && !desiredGoalId;
        if (shouldPrompt) {
          setGoalLinkPrompt({ visible: true, item, intent: "save" });
          return;
        }
        let targetGoalId = desiredGoalId || getFallbackGoalId();
        if (!targetGoalId && assignableGoals.length === 0 && wishes.length > 0) {
          targetGoalId = wishes[0].id;
        }
        const shouldStoreGoal =
          (shouldAssign && !!targetGoalId) ||
          (!storedGoalId && !forcedGoalId && !!targetGoalId);
        if (shouldStoreGoal) {
          assignTemptationGoal(item.id, targetGoalId);
        }
        const targetWish = targetGoalId ? wishes.find((wish) => wish.id === targetGoalId) : null;
        logEvent("temptation_decision", {
          temptation_id: item.id,
          decision: "save",
          price: priceLocal,
          balance_before: balanceLocal,
          saving_target_id: targetGoalId || null,
        });
        let appliedAmount = 0;
        if (targetGoalId) {
          appliedAmount = applySavingsToWish(targetGoalId, priceUSD);
        }
        let saveOverlayPayload = { title, moodLine: moodPreset?.saveOverlay || null };
        if (targetWish && targetWish.targetUSD > 0 && priceUSD > 0) {
          const previousSavedUSD = targetWish.savedUSD || 0;
          const targetUSD = targetWish.targetUSD || 0;
          const nextSavedUSD = Math.min(previousSavedUSD + appliedAmount, targetUSD);
          const remainingUSD = Math.max(targetUSD - nextSavedUSD, 0);
          const remainingTemptations = Math.max(Math.ceil(remainingUSD / priceUSD), 0);
          saveOverlayPayload = {
            ...saveOverlayPayload,
            goalTitle: targetWish.title || "",
            remainingTemptations,
            goalComplete: remainingUSD <= 0,
          };
          const progressPercent =
            targetUSD > 0 ? Math.min((nextSavedUSD / targetUSD) * 100, 100) : 0;
          if (targetGoalId && appliedAmount > 0) {
            logEvent("saving_progress_updated", {
              target_id: targetGoalId,
              amount_added: convertToCurrency(appliedAmount, currencyCode),
              new_progress: progressPercent,
            });
          }
        }
        const timestamp = saveTimestamp;
        setSavedTotalUSD((prev) => prev + priceUSD);
        setDeclineCount((prev) => prev + 1);
        const coinReward = priceUSD
          ? computeRefuseCoinReward(priceUSD, profile.currency || DEFAULT_PROFILE.currency)
          : 0;
        if (coinReward > 0) {
          setHealthPoints((prev) => prev + coinReward);
        }
        setRefuseStats((prev) => {
          const current = prev[item.id] || {};
          const count = (current.count || 0) + 1;
          const totalUSD = (current.totalUSD || 0) + priceUSD;
          return {
            ...prev,
            [item.id]: {
              count,
              totalUSD,
              lastSavedAt: timestamp,
              lastSavedAmountUSD: priceUSD,
            },
          };
        });
        logHistoryEvent("refuse_spend", {
          title,
          amountUSD: priceUSD,
          templateId: item.id,
          coinReward,
          currency: profile.currency || DEFAULT_PROFILE.currency,
        });
        const refuseStatsEntry = refuseStats[item.id] || {};
        logEvent(
          "temptation_save",
          buildTemptationPayload(item, {
            total_saved_usd: savedTotalUSD + priceUSD,
            refuse_count_for_item: (refuseStatsEntry.count || 0) + 1,
          })
        );
        logTemptationAction("save", item, { goal_id: targetGoalId || null });
        logImpulseEvent("save", item, priceUSD, title);
        triggerCardFeedback(item.id);
        triggerCoinHaptics();
        handleFocusSaveProgress(item);
        triggerOverlayState("save", { ...saveOverlayPayload, coinReward });
        requestMascotAnimation("happy");
        saveActionLogRef.current = [...recentSaves, { itemId: item.id, timestamp: saveTimestamp }];
        recordTemptationInteraction(item.id, "save");
        return;
      }
      if (type === "maybe") {
        logEvent(
          "temptation_think_later",
          buildTemptationPayload(item, { reminder_days: REMINDER_DAYS })
        );
        logTemptationAction("pending", item);
        const now = Date.now();
        const pendingEntry = {
          id: `pending-${item.id}-${now}`,
          templateId: item.id,
          title,
          priceUSD,
          pricePrecision: getTemptationPricePrecision(item),
          createdAt: now,
          decisionDue: now + REMINDER_MS,
          notificationId: null,
        };
        logEvent(
          "pending_added",
          buildTemptationPayload(item, {
            remind_at: pendingEntry.decisionDue,
          })
        );
        const reminderId = await schedulePendingReminder(title, pendingEntry.decisionDue);
        if (reminderId) pendingEntry.notificationId = reminderId;
        setPendingList((prev) => [pendingEntry, ...prev]);
        logHistoryEvent("pending_added", { title, amountUSD: priceUSD, pendingId: pendingEntry.id });
        triggerOverlayState("cart", t("pendingAdded"));
        triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
        return;
      }
      Alert.alert("Almost", t("actionSoon"));
    },
    [
      language,
      t,
      schedulePendingReminder,
      logHistoryEvent,
      triggerCardFeedback,
      triggerCoinHaptics,
      buildTemptationPayload,
      savedTotalUSD,
      refuseStats,
      logImpulseEvent,
      logTemptationAction,
      resolveTemptationGoalId,
      assignableGoals.length,
      assignTemptationGoal,
      applySavingsToWish,
      setGoalLinkPrompt,
      getFallbackGoalId,
      wishes,
      moodPreset,
      requestMascotAnimation,
      handleFocusSaveProgress,
      logEvent,
      profile.currency,
      executeSpend,
      triggerStormEffect,
      recordTemptationInteraction,
      triggerOverlayState,
    ]
  );

  const closeGoalLinkPrompt = useCallback(() => {
    setGoalLinkPrompt({ visible: false, item: null, intent: null });
  }, []);

  const handleGoalLinkSelect = useCallback(
    (wishId) => {
      const sourceItem = goalLinkPrompt.item;
      const intent = goalLinkPrompt.intent;
      closeGoalLinkPrompt();
      if (!wishId || !sourceItem) return;
      if (intent === "save") {
        handleTemptationAction("save", sourceItem, {
          skipPrompt: true,
          goalId: wishId,
          shouldAssign: true,
        });
        return;
      }
      assignTemptationGoal(sourceItem.id, wishId);
    },
    [assignTemptationGoal, closeGoalLinkPrompt, goalLinkPrompt, handleTemptationAction]
  );

  const handleGoalLongPress = useCallback(
    (wish) => {
      if (!wish) return;
      triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
      setGoalTemptationPrompt({ visible: true, wish });
    },
    [triggerHaptic]
  );

  const closeGoalTemptationPrompt = useCallback(() => {
    setGoalTemptationPrompt({ visible: false, wish: null });
  }, []);

  const handleGoalTemptationAssign = useCallback(
    (templateId) => {
      const targetWish = goalTemptationPrompt.wish;
      closeGoalTemptationPrompt();
      if (!templateId || !targetWish) return;
      assignTemptationGoal(templateId, targetWish.id);
    },
    [assignTemptationGoal, closeGoalTemptationPrompt, goalTemptationPrompt]
  );

  const handleNewPendingSubmit = useCallback(async () => {
    const trimmedTitle = (newPendingModal.title || "").trim();
    if (!trimmedTitle) {
      Alert.alert("Almost", t("pendingCustomError"));
      return;
    }
    const parsedLocal = parseNumberInputValue(newPendingModal.amount);
    if (!Number.isFinite(parsedLocal) || parsedLocal <= 0) {
      Alert.alert("Almost", t("pendingCustomError"));
      return;
    }
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const amountUSD = convertFromCurrency(parsedLocal, currencyCode);
    const emoji = normalizeEmojiValue(newPendingModal.emoji, DEFAULT_TEMPTATION_EMOJI);
    const manualItem = {
      id: `manual_pending_${Date.now()}`,
      title: trimmedTitle,
      emoji,
      priceUSD: amountUSD,
      basePriceUSD: amountUSD,
      categories: [],
    };
    await handleTemptationAction("maybe", manualItem);
    setNewPendingModal({ visible: false, title: "", amount: "", emoji: DEFAULT_TEMPTATION_EMOJI });
  }, [handleTemptationAction, newPendingModal, profile.currency, t]);

  const openGoalEditorPrompt = useCallback(
    (wish) => {
      if (!wish) return;
      const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
      const targetLocal = formatNumberInputValue(convertToCurrency(wish.targetUSD || 0, currencyCode));
      setGoalEditorPrompt({
        visible: true,
        wish,
        name: getWishTitleWithoutEmoji(wish) || "",
        target: targetLocal,
        emoji: normalizeEmojiValue(wish.emoji || resolveWishEmoji(wish), DEFAULT_GOAL_EMOJI),
      });
    },
    [profile.currency]
  );

  const closeGoalEditorPrompt = useCallback(() => {
    setGoalEditorPrompt({
      visible: false,
      wish: null,
      name: "",
      target: "",
      emoji: DEFAULT_GOAL_EMOJI,
    });
  }, []);

  const handleGoalEditorNameChange = useCallback((value) => {
    setGoalEditorPrompt((prev) => ({ ...prev, name: value }));
  }, []);

  const handleGoalEditorTargetChange = useCallback((value) => {
    setGoalEditorPrompt((prev) => ({ ...prev, target: value }));
  }, []);

  const handleGoalEditorEmojiChange = useCallback((value) => {
    setGoalEditorPrompt((prev) => ({ ...prev, emoji: limitEmojiInput(value) }));
  }, []);

  const saveGoalEditorPrompt = useCallback(() => {
    if (!goalEditorPrompt.wish) return;
    const trimmedName = goalEditorPrompt.name?.trim();
    if (!trimmedName) {
      Alert.alert("Almost", t("goalEditNameError"));
      return;
    }
    const parsed = parseNumberInputValue(goalEditorPrompt.target);
    if (!Number.isFinite(parsed) || parsed <= 0) {
      Alert.alert("Almost", t("goalEditTargetError"));
      return;
    }
    const fallbackEmoji = resolveWishEmoji(goalEditorPrompt.wish);
    const normalizedEmoji = normalizeEmojiValue(
      goalEditorPrompt.emoji,
      fallbackEmoji || DEFAULT_GOAL_EMOJI
    );
    const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
    const nextTargetUSD = convertFromCurrency(parsed, currencyCode);
    let resultingStatus = goalEditorPrompt.wish.status || "active";
    setWishes((prev) => {
      let statusCapture = resultingStatus;
      const next = prev.map((wish) => {
        if (wish.id !== goalEditorPrompt.wish.id) return wish;
        const nextSaved = Math.min(wish.savedUSD || 0, nextTargetUSD);
        const nextStatus = nextSaved >= nextTargetUSD ? "done" : "active";
        statusCapture = nextStatus;
        return {
          ...wish,
          title: trimmedName,
          emoji: normalizedEmoji,
          targetUSD: nextTargetUSD,
          savedUSD: nextSaved,
          status: nextStatus,
        };
      });
      resultingStatus = statusCapture;
      return next;
    });
    const shouldResetCelebration = resultingStatus !== "done";
    if (
      goalEditorPrompt.wish.kind === PRIMARY_GOAL_KIND &&
      goalEditorPrompt.wish.goalId
    ) {
      const goalExtras = {
        customTitle: trimmedName,
        customEmoji: normalizedEmoji,
      };
      setProfile((prev) => {
        const updated = updatePrimaryGoalTargetInProfile(
          prev,
          goalEditorPrompt.wish.goalId,
          nextTargetUSD,
          goalExtras
        );
        return shouldResetCelebration
          ? { ...updated, goalCelebrated: false, goalRenewalPending: false }
          : updated;
      });
      setProfileDraft((prev) => {
        const updated = updatePrimaryGoalTargetInProfile(
          prev,
          goalEditorPrompt.wish.goalId,
          nextTargetUSD,
          goalExtras
        );
        return shouldResetCelebration
          ? { ...updated, goalCelebrated: false, goalRenewalPending: false }
          : updated;
      });
    }
    if (shouldResetCelebration) {
      dismissGoalRenewalPrompt();
    }
    closeGoalEditorPrompt();
  }, [
    closeGoalEditorPrompt,
    dismissGoalRenewalPrompt,
    goalEditorPrompt,
    profile.currency,
    setProfile,
    setProfileDraft,
    t,
  ]);

  const handleGoalRenewalLater = useCallback(() => {
    dismissGoalRenewalPrompt();
    const currentGoalId = mainGoalWish?.goalId || profile.primaryGoals?.[0]?.id || null;
    setProfile((prev) => ({ ...prev, goalRenewalPending: false }));
    setProfileDraft((prev) => ({ ...prev, goalRenewalPending: false }));
    logEvent("goal_renewal_later", { goal_id: currentGoalId });
  }, [dismissGoalRenewalPrompt, mainGoalWish, profile.primaryGoals, setProfile, setProfileDraft]);

  const handleGoalRenewalStart = useCallback(() => {
    dismissGoalRenewalPrompt();
    setProfile((prev) => ({ ...prev, goalRenewalPending: false }));
    setProfileDraft((prev) => ({ ...prev, goalRenewalPending: false }));
    setActiveTab("cart");
    const targetWish = mainGoalWish || selectMainGoalWish(wishes);
    logEvent("goal_renewal_start", { had_existing_goal: !!targetWish });
    setTimeout(() => {
      openNewGoalModal(true, "goal_renewal");
    }, 280);
  }, [
    dismissGoalRenewalPrompt,
    mainGoalWish,
    openNewGoalModal,
    setActiveTab,
    wishes,
    setProfile,
    setProfileDraft,
  ]);

  const handleLogFreeDay = useCallback(() => {
    const today = new Date();
    const todayKey = getDayKey(today);
    if (freeDayStats.lastDate === todayKey) {
      Alert.alert("Almost", t("freeDayLoggedToday"));
      return;
    }
    Alert.alert("Almost", t("freeDayConfirm"), [
      { text: t("priceEditCancel"), style: "cancel" },
      {
        text: t("freeDayButton"),
        onPress: () => {
          const yesterdayKey = getDayKey(new Date(today.getTime() - DAY_MS));
          const continues = freeDayStats.lastDate === yesterdayKey;
          const current = continues ? freeDayStats.current + 1 : 1;
          const best = Math.max(freeDayStats.best, current);
          const total = freeDayStats.total + 1;
          let achievements = [...freeDayStats.achievements];
          const newMilestones = FREE_DAY_MILESTONES.filter(
            (m) => current >= m && !achievements.includes(m)
          );
          achievements = [...achievements, ...newMilestones];
          setFreeDayStats({
            total,
            current,
            best,
            lastDate: todayKey,
            achievements,
            blockedDate: null,
          });
          logHistoryEvent("free_day", { total, current, best });
          logEvent("free_day_logged", {
            total,
            current_streak: current,
            best_streak: best,
            weekday: today.getDay(),
            persona: profile.persona || "unknown",
            goal: profile.goal || "none",
          });
          newMilestones.forEach((milestone) => {
            logEvent("free_day_milestone", {
              milestone,
              current_streak: current,
            });
          });
          const message =
            newMilestones.length > 0
              ? t("freeDayMilestone", { days: current })
              : t("freeDayCongrats", { days: current });
          triggerOverlayState("purchase", message);
          triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
          const rewardBlueCoins = FREE_DAY_LOGIN_BLUE_COINS * current;
          const rewardHealthPoints = rewardBlueCoins * BLUE_HEALTH_COIN_VALUE;
          setHealthPoints((prev) => prev + rewardHealthPoints);
          const rewardReason =
            current > 1
              ? t("freeDayCoinRewardStreak", { coins: rewardBlueCoins, days: current })
              : t("freeDayCoinReward", { coins: rewardBlueCoins });
          triggerOverlayState("health", {
            amount: rewardHealthPoints,
            displayCoins: rewardBlueCoins,
            coinValue: BLUE_HEALTH_COIN_VALUE,
            reason: rewardReason,
          });
          logEvent("free_day_coin_reward", {
            blue_coins: rewardBlueCoins,
            health_points: rewardHealthPoints,
            current_streak: current,
          });
        },
      },
    ]);
  }, [freeDayStats, t, logEvent, logHistoryEvent, profile.goal, profile.persona, setHealthPoints, triggerOverlayState]);

  const toggleTemptationEditor = useCallback(
    (item) => {
      if (!item) return;
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
      triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
      setPriceEditor((prev) => {
        if (prev.item?.id === item.id) {
          return {
            item: null,
            value: "",
            title: "",
            emoji: "",
            category: DEFAULT_IMPULSE_CATEGORY,
            description: "",
          };
        }
        const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
        const currentValue = convertToCurrency(item.priceUSD || item.basePriceUSD || 0, currencyCode);
        const categorySlug = resolveTemptationCategory(item);
        const descriptionString = typeof item.description === "string" ? item.description : null;
        const descriptionMap =
          item.description && typeof item.description === "object" && !Array.isArray(item.description)
            ? item.description
            : null;
        const isCustom =
          Array.isArray(item?.categories) && item.categories.some((category) => category === "custom");
        const customDescriptionFallback = isCustom
          ? buildCustomTemptationDescription(item?.gender || "none")
          : null;
        const customLanguageFallback = customDescriptionFallback
          ? resolveLanguageMapValue(customDescriptionFallback, language)
          : null;
        const descriptionLanguageValue = descriptionMap ? resolveLanguageMapValue(descriptionMap, language) : null;
        const overrideDescription =
          typeof descriptionOverrides[item.id] === "string"
            ? descriptionOverrides[item.id]
            : "";
        const baseDescription = descriptionLanguageValue || descriptionString || "";
        const computedDescription = isCustom ? baseDescription || customLanguageFallback || "" : baseDescription;
        const resolvedDescription =
          (overrideDescription && overrideDescription.length ? overrideDescription : computedDescription);
        logEvent("temptation_viewed", {
          temptation_id: item.id,
          category: categorySlug,
          price: convertToCurrency(item.priceUSD || item.basePriceUSD || 0, currencyCode),
        });
        return {
          item,
          value: formatNumberInputValue(Number(currentValue) || 0),
          title: resolveTemptationTitle(item, language, titleOverrides[item.id]),
          emoji: item.emoji || DEFAULT_TEMPTATION_EMOJI,
          category: categorySlug,
          description: resolvedDescription,
        };
      });
    },
    [language, profile.currency, titleOverrides, descriptionOverrides, resolveTemptationCategory]
  );

  const closePriceEditor = useCallback(() => {
    if (!priceEditor.item) return;
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    setPriceEditor({
      item: null,
      value: "",
      title: "",
      emoji: "",
      category: DEFAULT_IMPULSE_CATEGORY,
      description: "",
    });
  }, [priceEditor.item]);

  useEffect(() => {
    if (priceEditor.item) {
      if (!editOverlayVisible) setEditOverlayVisible(true);
      Animated.timing(editOverlayAnim, {
        toValue: 1,
        duration: 220,
        easing: Easing.out(Easing.cubic),
        useNativeDriver: true,
      }).start();
    } else if (editOverlayVisible) {
      Animated.timing(editOverlayAnim, {
        toValue: 0,
        duration: 180,
        easing: Easing.in(Easing.cubic),
        useNativeDriver: true,
      }).start(({ finished }) => {
        if (finished) setEditOverlayVisible(false);
      });
    }
  }, [priceEditor.item, editOverlayAnim, editOverlayVisible]);

  const handlePriceTitleChange = (value) => {
    setPriceEditor((prev) => ({ ...prev, title: value }));
  };

  const handlePriceEmojiChange = (value) => {
    setPriceEditor((prev) => ({ ...prev, emoji: limitEmojiInput(value) }));
  };

  const handlePriceCategoryChange = (value) => {
    if (!IMPULSE_CATEGORY_DEFS[value]) return;
    setPriceEditor((prev) => ({ ...prev, category: value }));
  };

  const handleQuickGoalToggle = useCallback(
    (item) => {
      if (!item) return;
      const existing = (wishes || []).find((wish) => wish.templateId === item.id);
      if (existing) {
        setWishes((prev) => prev.filter((wish) => wish.id !== existing.id));
        assignTemptationGoal(item.id, null);
        logHistoryEvent("wish_removed", { title: existing.title });
        triggerOverlayState("cart", t("goalRemoved"));
        triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
        return;
      }
      handleTemptationAction("want", item, { pinnedBy: "swipe" });
    },
    [
      assignTemptationGoal,
      handleTemptationAction,
      logHistoryEvent,
      t,
      triggerHaptic,
      triggerOverlayState,
      wishes,
    ]
  );

  const handlePriceInputChange = (value) => {
    setPriceEditor((prev) => ({ ...prev, value }));
  };

  const handlePriceDescriptionChange = (value) => {
    setPriceEditor((prev) => ({ ...prev, description: value }));
  };

  const patchTemptationDisplay = useCallback((templateId, patch = {}) => {
    if (!templateId || !patch || typeof patch !== "object") return;
    setTemptations((prev) =>
      prev.map((card) => (card.id === templateId ? { ...card, ...patch } : card))
    );
    setQuickTemptations((prev) => {
      let changed = false;
      const next = prev.map((card) => {
        if (card.id !== templateId) return card;
        changed = true;
        return { ...card, ...patch };
      });
      return changed ? next : prev;
    });
  }, []);

  const removeTemptationTemplate = useCallback(
    (templateId) => {
      if (!templateId) return;
      const existsInQuick = quickTemptations.some((card) => card.id === templateId);
      if (existsInQuick) {
        setQuickTemptations((prev) => prev.filter((card) => card.id !== templateId));
      } else {
        setHiddenTemptations((prev) => (prev.includes(templateId) ? prev : [...prev, templateId]));
      }
      setTemptationGoalMap((prev) => {
        if (!prev[templateId]) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setCatalogOverrides((prev) => {
        if (!(templateId in prev)) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setPricePrecisionOverrides((prev) => {
        if (!(templateId in prev)) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setTitleOverrides((prev) => {
        if (!(templateId in prev)) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setEmojiOverrides((prev) => {
        if (!(templateId in prev)) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setCategoryOverrides((prev) => {
        if (!(templateId in prev)) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setDescriptionOverrides((prev) => {
        if (!(templateId in prev)) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setRefuseStats((prev) => {
        if (!prev[templateId]) return prev;
        const next = { ...prev };
        delete next[templateId];
        return next;
      });
      setPendingList((prev) => prev.filter((entry) => entry.templateId !== templateId));
    },
    [
      quickTemptations,
      setQuickTemptations,
      setHiddenTemptations,
      setTemptationGoalMap,
      setCatalogOverrides,
      setPricePrecisionOverrides,
      setTitleOverrides,
      setEmojiOverrides,
      setDescriptionOverrides,
      setRefuseStats,
      setPendingList,
    ]
  );

  const persistPriceOverride = (valueUSD = null, precision = null) => {
    const targetId = priceEditor.item?.id;
    if (!targetId) return;
    setCatalogOverrides((prev) => {
      const next = { ...prev };
      if (valueUSD) {
        next[targetId] = valueUSD;
      } else {
        delete next[targetId];
      }
      return next;
    });
    setPricePrecisionOverrides((prev) => {
      const next = { ...prev };
      const hasPrecision = typeof precision === "number" && Number.isFinite(precision) && precision >= 0;
      if (valueUSD && hasPrecision) {
        next[targetId] = precision;
      } else if (!valueUSD || !hasPrecision) {
        delete next[targetId];
      }
      return next;
    });
  };

  const persistTitleOverride = (value = null) => {
    const targetId = priceEditor.item?.id;
    if (!targetId) return;
    setTitleOverrides((prev) => {
      const next = { ...prev };
      if (value && value.length) {
        next[targetId] = value;
      } else {
        delete next[targetId];
      }
      return next;
    });
  };

  const persistEmojiOverride = (value = null) => {
    const targetId = priceEditor.item?.id;
    if (!targetId) return;
    setEmojiOverrides((prev) => {
      const next = { ...prev };
      if (value && value.length) {
        next[targetId] = value;
      } else {
        delete next[targetId];
      }
      return next;
    });
  };

  const persistDescriptionOverride = (value = null) => {
    const targetId = priceEditor.item?.id;
    if (!targetId) return;
    setDescriptionOverrides((prev) => {
      const next = { ...prev };
      const normalized =
        typeof value === "string" && value.trim().length ? value.trim() : null;
      if (normalized) {
        next[targetId] = normalized;
      } else {
        delete next[targetId];
      }
      return next;
    });
  };

  const persistCategoryOverride = (value = null) => {
    const targetId = priceEditor.item?.id;
    if (!targetId) return;
    setCategoryOverrides((prev) => {
      const next = { ...prev };
      if (value && IMPULSE_CATEGORY_DEFS[value]) {
        next[targetId] = value;
      } else {
        delete next[targetId];
      }
      return next;
    });
  };

  const propagateTemptationEdit = useCallback(
    (templateId, { label, emoji, priceUSD, category, pricePrecision = null }) => {
      if (!templateId) return;
      const fallbackTitle = resolveTranslationValueForLanguage(language, "defaultWishTitle") || "Wish";
      const normalizedLabel = (label && label.trim()) || fallbackTitle;
      const decoratedTitle = buildTemptationDisplayTitle(emoji, normalizedLabel, fallbackTitle);
      const numericPrice = Number(priceUSD);
      const hasPrice = Number.isFinite(numericPrice) && numericPrice > 0;
      const normalizedPrecision =
        typeof pricePrecision === "number" && Number.isFinite(pricePrecision) && pricePrecision >= 0
          ? pricePrecision
          : null;
      setPendingList((prev) => {
        let mutated = false;
        const next = prev.map((entry) => {
          if (entry.templateId !== templateId) return entry;
          const updates = {};
          if (decoratedTitle && entry.title !== decoratedTitle) {
            updates.title = decoratedTitle;
          }
          if (hasPrice && entry.priceUSD !== numericPrice) {
            updates.priceUSD = numericPrice;
          }
          if (normalizedPrecision !== null && entry.pricePrecision !== normalizedPrecision) {
            updates.pricePrecision = normalizedPrecision;
          } else if (normalizedPrecision === null && entry.pricePrecision != null) {
            updates.pricePrecision = null;
          }
          if (!Object.keys(updates).length) return entry;
          mutated = true;
          return { ...entry, ...updates };
        });
        return mutated ? next : prev || [];
      });
      setWishes((prev) => {
        let mutated = false;
        const next = prev.map((wish) => {
          if (wish.templateId !== templateId) return wish;
          const updates = {};
          if (decoratedTitle && wish.title !== decoratedTitle) {
            updates.title = decoratedTitle;
          }
          if (emoji && wish.emoji !== emoji) {
            updates.emoji = emoji;
          }
          if (hasPrice && wish.targetUSD !== numericPrice) {
            updates.targetUSD = numericPrice;
          }
          if (!Object.keys(updates).length) return wish;
          mutated = true;
          return { ...wish, ...updates };
        });
        return mutated ? next : prev;
      });
      setImpulseTracker((prev) => {
        const current = prev || INITIAL_IMPULSE_TRACKER;
        let mutated = false;
        const nextEvents = (current.events || []).map((event) => {
          if (event.templateId !== templateId) return event;
          const updates = {};
          if (decoratedTitle && event.title !== decoratedTitle) {
            updates.title = decoratedTitle;
          }
          if (emoji && event.emoji !== emoji) {
            updates.emoji = emoji;
          }
          if (hasPrice && event.amountUSD !== numericPrice) {
            updates.amountUSD = numericPrice;
          }
          if (category && event.category !== category) {
            updates.category = category;
          }
          if (!Object.keys(updates).length) return event;
          mutated = true;
          return { ...event, ...updates };
        });
        if (!mutated) return current;
        return { ...current, events: nextEvents };
      });
      setHistoryEvents((prev) => {
        let mutated = false;
        const next = (prev || []).map((entry) => {
          if (!entry || !entry.meta) return entry;
          const metaTemplateId =
            entry?.meta?.templateId || entry?.meta?.template_id || entry?.meta?.templateID;
          if (metaTemplateId !== templateId) return entry;
          const nextMeta = { ...(entry.meta || {}) };
          let metaChanged = false;
          if (decoratedTitle && nextMeta.title !== decoratedTitle) {
            nextMeta.title = decoratedTitle;
            metaChanged = true;
          }
          if (emoji && nextMeta.emoji !== emoji) {
            nextMeta.emoji = emoji;
            metaChanged = true;
          }
          if (hasPrice) {
            if (typeof nextMeta.amountUSD === "number" && nextMeta.amountUSD !== numericPrice) {
              nextMeta.amountUSD = numericPrice;
              metaChanged = true;
            }
            if (typeof nextMeta.targetUSD === "number" && nextMeta.targetUSD !== numericPrice) {
              nextMeta.targetUSD = numericPrice;
              metaChanged = true;
            }
            if (typeof nextMeta.priceUSD === "number" && nextMeta.priceUSD !== numericPrice) {
              nextMeta.priceUSD = numericPrice;
              metaChanged = true;
            }
          }
          if (!metaChanged) return entry;
          mutated = true;
          return { ...entry, meta: nextMeta };
        });
        return mutated ? next : prev;
      });
    },
    [language, setHistoryEvents, setImpulseTracker, setPendingList, setWishes]
  );

  const savePriceEdit = () => {
    if (!priceEditor.item) return;
    const parsed = parseFloat((priceEditor.value || "").replace(",", "."));
    if (!Number.isFinite(parsed) || parsed <= 0) {
      Alert.alert("Almost", t("priceEditError"));
      return;
    }
    const usdValue = parsed / (CURRENCY_RATES[activeCurrency] || 1);
    const previousPriceUSD = priceEditor.item.priceUSD || priceEditor.item.basePriceUSD || 0;
    const manualPrecision = getManualInputPrecision(priceEditor.value || "");
    persistPriceOverride(usdValue, manualPrecision);
    const titleValue = (priceEditor.title || "").trim();
    persistTitleOverride(titleValue || null);
    const hasCustomEmoji = !!priceEditor.emoji?.trim();
    const resolvedEmoji = hasCustomEmoji
      ? normalizeEmojiValue(priceEditor.emoji, priceEditor.item.emoji || DEFAULT_TEMPTATION_EMOJI)
      : priceEditor.item.emoji || DEFAULT_TEMPTATION_EMOJI;
    persistEmojiOverride(hasCustomEmoji ? resolvedEmoji : null);
    const categoryValue =
      priceEditor.category && IMPULSE_CATEGORY_DEFS[priceEditor.category]
        ? priceEditor.category
        : null;
    const previousCategory = resolveTemptationCategory(priceEditor.item);
    const nextCategory = categoryValue || previousCategory;
    persistCategoryOverride(categoryValue);
    const descriptionValue = (priceEditor.description || "").trim();
    const previousDescriptionOverride =
      typeof descriptionOverrides[priceEditor.item.id] === "string"
        ? descriptionOverrides[priceEditor.item.id]
        : "";
    const changedDescription = descriptionValue !== previousDescriptionOverride;
    persistDescriptionOverride(descriptionValue || null);
    const changedPrice = Math.abs(previousPriceUSD - usdValue) > 0.0001;
    const changedCategory = nextCategory !== previousCategory;
    patchTemptationDisplay(priceEditor.item.id, {
      priceUSD: usdValue,
      pricePrecision: manualPrecision,
      titleOverride: titleValue || null,
      emoji: resolvedEmoji,
      impulseCategoryOverride: categoryValue || null,
      descriptionOverride: descriptionValue || null,
    });
    const fallbackTitle =
      resolveTemptationTitle(
        priceEditor.item,
        language,
        titleOverrides[priceEditor.item.id] || priceEditor.item.titleOverride || null
      ) || resolveTranslationValueForLanguage(language, "defaultWishTitle") || "Wish";
    const normalizedLabel = titleValue || fallbackTitle;
    propagateTemptationEdit(priceEditor.item.id, {
      label: normalizedLabel,
      emoji: resolvedEmoji,
      priceUSD: usdValue,
      category: nextCategory,
      pricePrecision: manualPrecision,
    });
    logEvent("temptation_edited", {
      temptation_id: priceEditor.item.id,
      changed_price: changedPrice,
      changed_category: changedCategory,
      changed_description: changedDescription,
    });
    closePriceEditor();
  };

  const promptTemptationDelete = useCallback(
    (targetItem = null) => {
      const item = targetItem || priceEditor.item;
      if (!item) return;
      Alert.alert(t("priceEditDelete"), t("priceEditDeleteConfirm"), [
        { text: t("priceEditCancel"), style: "cancel" },
        {
          text: t("priceEditDelete"),
          style: "destructive",
          onPress: () => {
            logEvent("temptation_deleted", {
              temptation_id: item.id,
              is_custom: isCustomTemptation(item),
              price: convertToCurrency(
                item.priceUSD || item.basePriceUSD || 0,
                profile.currency || DEFAULT_PROFILE.currency
              ),
            });
            removeTemptationTemplate(item.id);
            if (priceEditor.item?.id === item.id) {
              closePriceEditor();
            }
          },
        },
      ]);
    },
    [closePriceEditor, logEvent, priceEditor.item, profile.currency, removeTemptationTemplate, t]
  );
  const handleTemptationDelete = useCallback(
    (item) => {
      promptTemptationDelete(item);
    },
    [promptTemptationDelete]
  );

  const handleRemoveWish = useCallback(
    (wishId) => {
      const targetWish = wishes.find((wish) => wish.id === wishId);
      if (!targetWish) return;
      const performRemoval = () => {
        setWishes((prev) => prev.filter((wish) => wish.id !== wishId));
        if (
          targetWish.kind === PRIMARY_GOAL_KIND &&
          targetWish.goalId
        ) {
          setProfile((prev) => removePrimaryGoalFromProfile(prev, targetWish.goalId));
          setProfileDraft((prev) => removePrimaryGoalFromProfile(prev, targetWish.goalId));
        }
        logEvent("goal_abandoned", {
          goal_id: targetWish.goalId || targetWish.id,
          reason: "deleted",
        });
      };
      Alert.alert(t("wishlistTitle"), t("wishlistRemoveConfirm"), [
        { text: t("priceEditCancel"), style: "cancel" },
        {
          text: t("wishlistRemove"),
          style: "destructive",
          onPress: performRemoval,
        },
      ]);
    },
    [logEvent, setProfile, setProfileDraft, t, wishes]
  );

  const handlePendingDecision = useCallback(
    async (pendingItem, decision) => {
      if (!pendingItem) return;
      if (pendingItem.notificationId) {
        try {
          await Notifications.cancelScheduledNotificationAsync(pendingItem.notificationId);
        } catch (error) {
          console.warn("cancel reminder", error);
        }
      }
      setPendingList((prev) => prev.filter((entry) => entry.id !== pendingItem.id));
      const template = findTemplateById(pendingItem.templateId);
      const title =
        pendingItem.title || template?.title?.[language] || template?.title?.en || "Wish";
      const priceUSD = pendingItem.priceUSD || template?.basePriceUSD || 0;
      const decisionTimestamp = Date.now();
      const daysWaited = Math.max(
        0,
        Math.round((decisionTimestamp - (pendingItem.createdAt || decisionTimestamp)) / DAY_MS)
      );
      if (decision === "want") {
        const targetUSD = pendingItem.priceUSD || template?.basePriceUSD || 0;
        const newWish = {
          id: `wish-${pendingItem.templateId}-${Date.now()}`,
          templateId: pendingItem.templateId,
          title,
          targetUSD,
          savedUSD: 0,
          status: "active",
          createdAt: Date.now(),
          autoManaged: false,
          emoji: template?.emoji || DEFAULT_GOAL_EMOJI,
        };
        setWishes((prev) => insertWishAfterPrimary(prev, newWish));
        ensureActiveGoalForNewWish(newWish);
        setDecisionStats((prev) => ({
          ...prev,
          resolvedToWishes: prev.resolvedToWishes + 1,
        }));
        logEvent(
          "pending_decide_want",
          buildTemptationPayload(
            { ...pendingItem, priceUSD },
            {
              days_waited: daysWaited,
            }
          )
        );
        logHistoryEvent("pending_to_wish", { title, targetUSD, wishId: newWish.id, pendingId: pendingItem.id });
        triggerOverlayState("purchase", t("wishAdded", { title }));
        triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
        return;
      }
      if (decision === "decline") {
        const price = priceUSD;
        const localAmount = formatCurrency(
          convertToCurrency(price, profile.currency || DEFAULT_PROFILE.currency)
        );
        setSavedTotalUSD((prev) => prev + price);
        setDeclineCount((prev) => prev + 1);
        setDecisionStats((prev) => ({
          ...prev,
          resolvedToDeclines: prev.resolvedToDeclines + 1,
        }));
        logEvent(
          "pending_decide_decline",
          buildTemptationPayload(
            { ...pendingItem, priceUSD: price },
            {
              days_waited: daysWaited,
            }
          )
        );
        logHistoryEvent("pending_to_decline", { title, amountUSD: price });
        triggerOverlayState("cart", t("wishDeclined", { amount: localAmount }));
        triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
      }
    },
    [language, profile.currency, t, logHistoryEvent, buildTemptationPayload]
  );
  const handlePendingDelete = useCallback(
    (pendingItem) => {
      if (!pendingItem) return;
      const template = findTemplateById(pendingItem.templateId);
      const title =
        pendingItem.title || template?.title?.[language] || template?.title?.en || "Wish";
      const performDelete = async () => {
        if (pendingItem.notificationId) {
          try {
            await Notifications.cancelScheduledNotificationAsync(pendingItem.notificationId);
          } catch (error) {
            console.warn("cancel reminder", error);
          }
        }
        setPendingList((prev) => prev.filter((entry) => entry.id !== pendingItem.id));
        logHistoryEvent("pending_removed", { title, pendingId: pendingItem.id });
        logEvent("pending_deleted", { pending_id: pendingItem.id });
      };
      Alert.alert(t("pendingTitle"), t("pendingDeleteConfirm"), [
        { text: t("priceEditCancel"), style: "cancel" },
        {
          text: t("goalSwipeDelete"),
          style: "destructive",
          onPress: () => {
            performDelete();
          },
        },
      ]);
    },
    [findTemplateById, language, logEvent, logHistoryEvent, setPendingList, t]
  );

  useEffect(
    () => () => {
      if (overlayRetryTimerRef.current) {
        clearTimeout(overlayRetryTimerRef.current);
        overlayRetryTimerRef.current = null;
      }
    },
    []
  );

  const processOverlayQueue = useCallback(() => {
    if (!overlayEnvironmentReady) return;
    if (overlayActiveRef.current) return;
    const next = overlayQueueRef.current.shift();
    if (!next) return;
    overlayActiveRef.current = true;
    if (overlayTimer.current) {
      clearTimeout(overlayTimer.current);
    }
    if (next.type === "purchase") {
      setConfettiKey((prev) => prev + 1);
    }
    setOverlay({ type: next.type, message: next.message });
    const defaultDuration =
      next.type === "cart"
        ? 1800
        : next.type === "level"
        ? 3200
        : next.type === "reward"
        ? 3200
        : next.type === "save"
        ? 4200
        : next.type === "impulse_alert"
        ? null
        : next.type === "focus_digest"
        ? null
        : 2600;
    const timeout = next.duration ?? defaultDuration;
    if (typeof timeout === "number" && Number.isFinite(timeout) && timeout > 0) {
      overlayTimer.current = setTimeout(() => {
        setOverlay(null);
        overlayActiveRef.current = false;
        processOverlayQueue();
      }, timeout);
    } else {
      overlayTimer.current = null;
    }
  }, [overlayEnvironmentReady]);

  const scheduleOverlayRetry = useCallback(() => {
    if (overlayRetryTimerRef.current) return;
    if (!overlayQueueRef.current.length) return;
    overlayRetryTimerRef.current = setTimeout(() => {
      overlayRetryTimerRef.current = null;
      if (!overlayEnvironmentReady && overlayQueueRef.current.length) {
        scheduleOverlayRetry();
        return;
      }
      processOverlayQueue();
    }, 250);
  }, [overlayEnvironmentReady, processOverlayQueue]);

  const triggerOverlayState = useCallback(
    (type, message, duration) => {
      overlayQueueRef.current.push({ type, message, duration });
      processOverlayQueue();
      if (!overlayEnvironmentReady) {
        scheduleOverlayRetry();
      }
    },
    [overlayEnvironmentReady, processOverlayQueue, scheduleOverlayRetry]
  );

  useEffect(() => {
    if (overlayEnvironmentReady) {
      processOverlayQueue();
    }
  }, [overlayEnvironmentReady, processOverlayQueue]);

  const dismissOverlay = useCallback(() => {
    if (overlay?.type === "focus_digest" && overlay?.message?.prompt) {
      focusPromptActiveRef.current = false;
    }
    if (overlayTimer.current) {
      clearTimeout(overlayTimer.current);
      overlayTimer.current = null;
    }
    if (overlayActiveRef.current) {
      overlayActiveRef.current = false;
    }
    setOverlay(null);
    processOverlayQueue();
  }, [overlay, processOverlayQueue]);

  const resetFocusLossCounter = useCallback((templateId) => {
    if (!templateId) return;
    focusLossCountersRef.current[templateId] = { count: 0 };
  }, []);

  const promptFocusForTemptation = useCallback(
    (template) => {
      if (!template?.id) return;
      if (focusPromptActiveRef.current) return;
      if (overlay?.type === "focus_digest") return;
      focusPromptActiveRef.current = true;
      const title = resolveTemptationTitle(template, language, titleOverrides[template.id]) || t("defaultDealTitle");
      triggerOverlayState("focus_digest", {
        title: t("focusPromptTitle"),
        body: t("focusPromptBody", { title }),
        strong: null,
        weak: { title, templateId: template.id },
        positive: false,
        targetId: template.id,
        prompt: true,
      }, null);
    },
    [language, overlay, t, titleOverrides, triggerOverlayState]
  );

  const registerFocusLoss = useCallback(
    (template) => {
      if (!template?.id) return;
      const key = template.id;
      const entry = focusLossCountersRef.current[key] || { count: 0 };
      const nextCount = entry.count + 1;
      focusLossCountersRef.current[key] = { count: nextCount };
      if (nextCount >= FOCUS_LOSS_THRESHOLD) {
        focusLossCountersRef.current[key] = { count: 0 };
        if (focusTemplateId === key) return;
        promptFocusForTemptation(template);
      }
    },
    [focusTemplateId, promptFocusForTemptation]
  );

  const celebrateFocusVictory = useCallback(
    (template) => {
      if (!template) return;
      const title = resolveTemptationTitle(template, language, titleOverrides[template.id]) || t("defaultDealTitle");
      setFocusTemplateId(null);
      setFocusSaveCount(0);
      resetFocusLossCounter(template.id);
    setHealthPoints((prev) => prev + FOCUS_VICTORY_REWARD);
    triggerOverlayState("focus_reward", {
      title: t("focusRewardTitle"),
      body: t("focusRewardSubtitle", { title, amount: FOCUS_VICTORY_REWARD }),
      amount: FOCUS_VICTORY_REWARD,
    });
    },
    [language, resetFocusLossCounter, setHealthPoints, t, titleOverrides, triggerOverlayState]
  );

  const handleFocusSaveProgress = useCallback(
    (template) => {
      if (!template?.id || template.id !== focusTemplateId) return;
      resetFocusLossCounter(template.id);
      setFocusSaveCount((prev) => {
        const next = prev + 1;
        if (next >= FOCUS_VICTORY_THRESHOLD) {
          celebrateFocusVictory(template);
          return 0;
        }
        return next;
      });
    },
    [celebrateFocusVictory, focusTemplateId, resetFocusLossCounter]
  );

  const handleFocusSpend = useCallback(
    (template) => {
      if (!template?.id || template.id !== focusTemplateId) return;
      setFocusSaveCount(0);
    },
    [focusTemplateId]
  );

  const applyFocusTarget = useCallback(
    (templateId, source = "manual") => {
      if (!templateId) return;
      setFocusTemplateId(templateId);
      setFocusSaveCount(0);
      resetFocusLossCounter(templateId);
      logEvent("focus_target_set", { template_id: templateId, source });
      triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    },
    [logEvent, resetFocusLossCounter]
  );

  const resolveFocusDigest = useCallback(
    (action = "later") => {
      if (!pendingFocusDigest) return;
      const targetDateKey = pendingFocusDigest.dateKey;
      setFocusDigestSeenKey(targetDateKey);
      setPendingFocusDigest(null);
      setFocusDigestPromptShown(false);
      AsyncStorage.removeItem(STORAGE_KEYS.FOCUS_DIGEST_PENDING).catch(() => {});
      if (action === "later") {
        logEvent("focus_digest_later", { date_key: targetDateKey });
      } else if (action === "focus") {
        logEvent("focus_digest_focus", { date_key: targetDateKey });
      }
    },
    [pendingFocusDigest, logEvent]
  );

  const handleFocusOverlayConfirm = useCallback(
    (templateId, source = "digest") => {
      const isPrompt = overlay?.message?.prompt;
      if (templateId) {
        applyFocusTarget(templateId, source);
      }
      resolveFocusDigest("focus");
      dismissOverlay();
      if (isPrompt) {
        focusPromptActiveRef.current = false;
      }
    },
    [applyFocusTarget, dismissOverlay, overlay, resolveFocusDigest]
  );

  const handleFocusOverlayLater = useCallback(() => {
    const isPrompt = overlay?.message?.prompt;
    resolveFocusDigest("later");
    dismissOverlay();
    if (isPrompt) {
      focusPromptActiveRef.current = false;
    }
  }, [dismissOverlay, overlay, resolveFocusDigest]);

  const notifyImpulseRisk = useCallback(
    async (risk) => {
      if (!risk?.templateId) return;
      const now = Date.now();
      const lastShown = impulseAlertCooldownRef.current?.[risk.templateId] || 0;
      if (now - lastShown < IMPULSE_ALERT_COOLDOWN_MS) return;
      const currencyCode = profile.currency || DEFAULT_PROFILE.currency;
      const amountLabel = formatCurrency(
        convertToCurrency(Math.max(risk.amountUSD || 0, 0), currencyCode),
        currencyCode
      );
      const baseOverlayMessage = t("impulseAlertMessage", {
        temptation: risk.title,
        window: risk.windowLabel || "",
        amount: amountLabel,
      });
      const overlayMessage = moodPreset?.impulseOverlay
        ? `${baseOverlayMessage}\n${moodPreset.impulseOverlay}`
        : baseOverlayMessage;
      const pushTitle =
        moodPreset?.pushImpulseTitle && moodPreset.pushImpulseTitle.trim()
          ? renderTemplateString(moodPreset.pushImpulseTitle, { temptation: risk.title })
          : t("impulseNotificationTitle", { temptation: risk.title });
      const pushBody =
        moodPreset?.pushImpulseBody && moodPreset.pushImpulseBody.trim()
          ? renderTemplateString(moodPreset.pushImpulseBody, {
              temptation: risk.title,
              amount: amountLabel,
            })
          : t("impulseNotificationBody", { temptation: risk.title, amount: amountLabel });
      triggerOverlayState("impulse_alert", {
        title: t("impulseAlertTitle"),
        body: overlayMessage,
        moodLine: moodPreset?.impulseOverlay || null,
        window: risk.windowLabel || null,
        amountLabel,
        temptation: risk.title || "",
      });
      await sendImmediateNotification({
        title: pushTitle,
        body: pushBody,
      });
      impulseAlertCooldownRef.current = {
        ...(impulseAlertCooldownRef.current || {}),
        [risk.templateId]: now,
      };
      setImpulseTracker((prev) => ({
        ...(prev || INITIAL_IMPULSE_TRACKER),
        lastAlerts: {
          ...(prev?.lastAlerts || {}),
          [risk.templateId]: now,
        },
        events: prev?.events || [],
      }));
    },
    [profile.currency, sendImmediateNotification, t, triggerOverlayState, moodPreset]
  );

  const triggerCelebration = () => {
    const messages = getCelebrationMessages(language, activeGender);
    if (!messages.length) return;
    triggerOverlayState("purchase", messages[Math.floor(Math.random() * messages.length)]);
  };

  const handleLevelCelebrate = useCallback(
    (level, levelsEarned = 1) => {
      const rewardCoins = sumLevelRewardCoins(level, levelsEarned);
      if (rewardCoins <= 0) {
        triggerOverlayState("level", level);
        triggerSuccessHaptic();
        return;
      }
      const rewardAmount = rewardCoins * HEALTH_COIN_TIERS[1].value;
      setHealthPoints((prev) => prev + rewardAmount);
      triggerOverlayState("level", level);
      triggerOverlayState(
        "health",
        {
          amount: rewardAmount,
          displayCoins: rewardCoins,
          coinValue: rewardAmount,
          reason: t("healthCelebrateLevel"),
        },
        3200
      );
      triggerSuccessHaptic();
    },
    [t, triggerOverlayState]
  );

  const handleRewardClaim = useCallback(
    (reward) => {
      if (!reward?.id || !reward.unlocked || reward.claimed) return;
      const rewardAmount = reward.rewardHealth || HEALTH_PER_REWARD;
      const claimedAt = Date.now();
      setClaimedRewards((prev) => ({ ...prev, [reward.id]: { claimedAt } }));
      setRewardClaimTotal((prev) => Math.max(0, prev) + 1);
      setHealthPoints((prev) => prev + rewardAmount);
      triggerOverlayState(
        "health",
        {
          amount: rewardAmount,
          reason: t("healthCelebrateReward"),
        },
        3200
      );
      triggerSuccessHaptic();
      logEvent("reward_claimed", { reward_id: reward.id });
      logHistoryEvent("reward_claimed", { rewardId: reward.id, title: reward.title });
    },
    [t, triggerOverlayState, logHistoryEvent]
  );

  const handleChallengeAccept = useCallback(
    async (challengeId) => {
      const def = CHALLENGE_DEF_MAP[challengeId];
      if (!def) return;
      if (getActiveChallengesCount(challengesState) >= MAX_ACTIVE_CHALLENGES) {
        Alert.alert(
          t("challengeLimitReachedTitle", { limit: MAX_ACTIVE_CHALLENGES }),
          t("challengeLimitReachedMessage", { limit: MAX_ACTIVE_CHALLENGES })
        );
        return;
      }
      triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
      let activated = false;
      let startedAt = Date.now();
      let expiresAt = startedAt + def.durationDays * DAY_MS;
      let limitReached = false;
      setChallengesState((prev) => {
        const entry = prev[challengeId] || createChallengeEntry(challengeId);
        const canStart =
          entry.status === CHALLENGE_STATUS.IDLE ||
          entry.status === CHALLENGE_STATUS.EXPIRED ||
          entry.status === CHALLENGE_STATUS.CLAIMED;
        if (!canStart) {
          return prev;
        }
        const activeCount = getActiveChallengesCount(prev);
        if (activeCount >= MAX_ACTIVE_CHALLENGES) {
          limitReached = true;
          return prev;
        }
        activated = true;
        startedAt = Date.now();
        expiresAt = startedAt + def.durationDays * DAY_MS;
        return {
          ...prev,
          [challengeId]: {
            ...createChallengeEntry(challengeId),
            status: CHALLENGE_STATUS.ACTIVE,
            startedAt,
            expiresAt,
          },
        };
      });
      if (limitReached) {
        Alert.alert(
          t("challengeLimitReachedTitle", { limit: MAX_ACTIVE_CHALLENGES }),
          t("challengeLimitReachedMessage", { limit: MAX_ACTIVE_CHALLENGES })
        );
        return;
      }
      if (!activated) return;
      const copy = getChallengeCopy(def, language);
      const title = copy.title || challengeId;
      triggerOverlayState("cart", t("challengeStartedOverlay", { title }));
      logEvent("challenge_started", { challenge_id: challengeId });
      logEvent("challenge_joined", {
        challenge_id: challengeId,
        type: CHALLENGE_TYPE_LABELS[def.metricType] || def.metricType,
      });
      const reminderIds = await scheduleChallengeReminders(challengeId, def, startedAt, expiresAt);
      if (reminderIds.length) {
        setChallengesState((prev) => {
          const entry = prev[challengeId];
          if (!entry || entry.startedAt !== startedAt) return prev;
          return {
            ...prev,
            [challengeId]: {
              ...entry,
              reminderNotificationIds: reminderIds,
            },
          };
        });
      }
    },
    [challengesState, language, scheduleChallengeReminders, t, triggerOverlayState]
  );

  const handleChallengeClaim = useCallback(
    (challengeId) => {
      const def = CHALLENGE_DEF_MAP[challengeId];
      if (!def) return;
      const currentEntry = challengesState[challengeId];
      if (!currentEntry || currentEntry.status !== CHALLENGE_STATUS.COMPLETED) return;
      (currentEntry.reminderNotificationIds || []).forEach((id) => {
        Notifications.cancelScheduledNotificationAsync(id).catch(() => {});
      });
      triggerSuccessHaptic();
      setChallengesState((prev) => {
        const entry = prev[challengeId];
        if (!entry || entry.status !== CHALLENGE_STATUS.COMPLETED) return prev;
        return {
          ...prev,
          [challengeId]: {
            ...entry,
            status: CHALLENGE_STATUS.CLAIMED,
            claimedAt: Date.now(),
            reminderNotificationIds: [],
          },
        };
      });
      const rewardAmount = getScaledChallengeReward(def.rewardHealth);
      const rewardLabel = formatHealthRewardText(rewardAmount);
      setHealthPoints((prev) => prev + rewardAmount);
      const copy = getChallengeCopy(def, language);
      const title = copy.title || challengeId;
      triggerOverlayState(
        "health",
        {
          amount: rewardAmount,
          reason: t("challengeClaimedOverlay", { title, amount: rewardLabel }),
        },
        3200
      );
      logEvent("challenge_claimed", { challenge_id: challengeId });
    },
    [challengesState, formatHealthRewardText, language, t, triggerOverlayState]
  );

  const handleChallengeCancel = useCallback(
    (challengeId) => {
      setChallengesState((prev) => {
        const entry = prev[challengeId];
        if (!entry || entry.status !== CHALLENGE_STATUS.ACTIVE) return prev;
        (entry.reminderNotificationIds || []).forEach((id) => {
          Notifications.cancelScheduledNotificationAsync(id).catch(() => {});
        });
        logEvent("challenge_cancelled", { challenge_id: challengeId });
        return {
          ...prev,
          [challengeId]: createChallengeEntry(challengeId),
        };
      });
    },
    [logEvent]
  );

  const handleFreeDayRescue = useCallback(() => {
    const now = new Date();
    if (!freeDayStats.lastDate || healthPoints < FREE_DAY_RESCUE_COST) return;
    const yesterdayKey = getDayKey(new Date(now.getTime() - DAY_MS));
    const dayBeforeYesterdayKey = getDayKey(new Date(now.getTime() - DAY_MS * 2));
    if (freeDayStats.lastDate !== dayBeforeYesterdayKey) return;
    setHealthPoints((prev) => Math.max(prev - FREE_DAY_RESCUE_COST, 0));
    setFreeDayStats((prev) => ({ ...prev, lastDate: yesterdayKey }));
    triggerOverlayState("reward", t("freeDayRescueOverlay"));
    triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
    logEvent("free_day_rescue", {
      current_streak: freeDayStats.current,
      health_remaining: Math.max(healthPoints - FREE_DAY_RESCUE_COST, 0),
    });
  }, [freeDayStats.lastDate, freeDayStats.current, healthPoints, triggerOverlayState, t]);

  const handleResetData = () => {
    Alert.alert(
      t("developerReset"),
      t("developerResetConfirm"),
      [
        { text: t("developerResetCancel"), style: "cancel" },
        {
          text: t("developerResetApply"),
          style: "destructive",
          onPress: async () => {
            triggerHaptic(Haptics.ImpactFeedbackStyle.Medium);
            try {
              await AsyncStorage.multiRemove(Object.values(STORAGE_KEYS));
            } catch (error) {
              console.warn("reset", error);
            }
            try {
              await Promise.all(
                pendingList
                  .filter((entry) => entry.notificationId)
                  .map((entry) =>
                    Notifications.cancelScheduledNotificationAsync(entry.notificationId).catch(() => {})
                  )
              );
            } catch {}
            try {
              const challengeReminderIds = Object.values(challengesState || {}).flatMap(
                (entry) => entry?.reminderNotificationIds || []
              );
              await Promise.all(
                challengeReminderIds.map((id) =>
                  Notifications.cancelScheduledNotificationAsync(id).catch(() => {})
                )
              );
            } catch {}
            setWishes([]);
            setPendingList([]);
            setPurchases([]);
            setSavedTotalUSD(0);
            setLifetimeSavedUSD(0);
            setDeclineCount(0);
            setCatalogOverrides({});
            setTitleOverrides({});
            setEmojiOverrides({});
            setQuickTemptations([]);
            setFreeDayStats({ ...INITIAL_FREE_DAY_STATS });
            setDecisionStats({ ...INITIAL_DECISION_STATS });
            setHistoryEvents([]);
            setRefuseStats({});
            setTemptationInteractions({});
            const resetProfile = { ...DEFAULT_PROFILE, joinedAt: new Date().toISOString() };
            setProfile(resetProfile);
            setProfileDraft(resetProfile);
            setRegistrationData(INITIAL_REGISTRATION);
            goToOnboardingStep("logo", { recordHistory: false, resetHistory: true });
            setActiveCategory("all");
            setActiveTab("feed");
            setOverlay(null);
            setTheme("light");
            setLanguage(DEFAULT_LANGUAGE);
            setActiveCurrency(DEFAULT_PROFILE.currency);
            setHealthPoints(0);
            setTamagotchiSkinId(DEFAULT_TAMAGOTCHI_SKIN);
            setSkinPickerVisible(false);
            setClaimedRewards({});
            setRewardClaimTotal(0);
            setRewardCelebratedMap({});
            const resetChallenges = createInitialChallengesState();
            challengesPrevRef.current = resetChallenges;
            setChallengesState(resetChallenges);
            setImpulseTracker({ ...INITIAL_IMPULSE_TRACKER });
            setMoodState(createMoodStateForToday());
            impulseAlertCooldownRef.current = {};
            setTabHintsSeen(DEFAULT_TAB_HINTS_STATE);
            setTabHintVisible(null);
            if (customReminderId) {
              Notifications.cancelScheduledNotificationAsync(customReminderId).catch(() => {});
            }
            persistCustomReminderId(null);
          },
        },
      ]
    );
  };

  const startProfileEdit = () => {
    triggerHaptic();
    setProfileDraft(profile);
    setIsEditingProfile(true);
  };

  const cancelProfileEdit = () => {
    triggerHaptic();
    setProfileDraft(profile);
    setIsEditingProfile(false);
  };

  const saveProfileEdit = () => {
    triggerHaptic();
    const normalizedGoals = Array.isArray(profileDraft.primaryGoals) && profileDraft.primaryGoals.length
      ? profileDraft.primaryGoals.map((entry) => {
          const goalId = entry?.id || profileDraft.goal || profile.goal || DEFAULT_PROFILE.goal;
          const targetUSD =
            Number.isFinite(entry?.targetUSD) && entry.targetUSD > 0
              ? entry.targetUSD
              : getGoalDefaultTargetUSD(goalId);
          const normalized = {
            id: goalId,
            targetUSD,
          };
          if (Number.isFinite(entry?.savedUSD)) {
            normalized.savedUSD = entry.savedUSD;
          }
          if (entry?.status) {
            normalized.status = entry.status;
          }
          if (entry?.createdAt) {
            normalized.createdAt = entry.createdAt;
          }
          if (entry?.customTitle) {
            normalized.customTitle = entry.customTitle;
          }
          if (entry?.customEmoji) {
            normalized.customEmoji = entry.customEmoji;
          }
          return normalized;
        })
      : [
          {
            id: profileDraft.goal || profile.goal || DEFAULT_PROFILE.goal,
            targetUSD: getGoalDefaultTargetUSD(profileDraft.goal || profile.goal || DEFAULT_PROFILE.goal),
            savedUSD: 0,
            status: "active",
            createdAt: Date.now(),
          },
        ];
    const activeEntry = normalizedGoals[0];
    const activeTarget =
      Number.isFinite(activeEntry?.targetUSD) && activeEntry.targetUSD > 0
        ? activeEntry.targetUSD
        : getGoalDefaultTargetUSD(activeEntry?.id || profile.goal || DEFAULT_PROFILE.goal);
    const activeSaved = Number.isFinite(activeEntry?.savedUSD) ? Math.max(activeEntry.savedUSD, 0) : 0;
    const hasMetTarget = activeTarget > 0 && activeSaved >= activeTarget;
    const prevCustomId = profile.customSpend?.id || "custom_habit";
    const prevCustomTitle = (profile.customSpend?.title || "").trim();
    const nextCustomId = profileDraft.customSpend?.id || prevCustomId;
    const nextCustomTitle = (profileDraft.customSpend?.title || "").trim();
    const nextProfile = {
      ...profileDraft,
      primaryGoals: normalizedGoals,
      goal: normalizedGoals[0]?.id || DEFAULT_PROFILE.goal,
      goalTargetUSD: activeTarget,
      goalCelebrated: hasMetTarget ? profileDraft.goalCelebrated : false,
    };
    if (nextCustomId && prevCustomTitle !== nextCustomTitle) {
      setTitleOverrides((prev) => {
        const next = { ...prev };
        if (nextCustomTitle) {
          next[nextCustomId] = nextCustomTitle;
        } else {
          delete next[nextCustomId];
        }
        return next;
      });
    }
    const prevBaselineUSD = profile.spendingProfile?.baselineMonthlyWasteUSD || 0;
    const nextBaselineUSD = nextProfile.spendingProfile?.baselineMonthlyWasteUSD || 0;
    if (prevBaselineUSD !== nextBaselineUSD) {
      logEvent("profile_baseline_updated", {
        previous_usd: prevBaselineUSD,
        baseline_usd: nextBaselineUSD,
        currency: nextProfile.currency || DEFAULT_PROFILE.currency,
      });
    }
    const prevCustomSpend = profile.customSpend || null;
    const nextCustomSpend = nextProfile.customSpend || null;
    const prevCustomAmountUSD = resolveCustomPriceUSD(
      prevCustomSpend,
      profile.currency || DEFAULT_PROFILE.currency
    );
    const nextCustomAmountUSD = resolveCustomPriceUSD(
      nextCustomSpend,
      nextProfile.currency || DEFAULT_PROFILE.currency
    );
    const prevCustomFrequency = prevCustomSpend?.frequencyPerWeek || 0;
    const nextCustomFrequency = nextCustomSpend?.frequencyPerWeek || 0;
    const customSpendChanged =
      prevCustomTitle !== nextCustomTitle ||
      prevCustomAmountUSD !== nextCustomAmountUSD ||
      prevCustomFrequency !== nextCustomFrequency;
    if (customSpendChanged) {
      logEvent("profile_custom_spend_updated", {
        title: nextCustomTitle || null,
        amount_usd: nextCustomAmountUSD || 0,
        frequency_per_week: nextCustomFrequency || 0,
        removed: nextCustomSpend ? 0 : 1,
      });
    }
    setProfile(nextProfile);
    setIsEditingProfile(false);
    Keyboard.dismiss();
  };

  const renderActiveScreen = () => {
    switch (activeTab) {
      case "cart":
        return (
          <WishListScreen
            wishes={wishes}
            currency={profile.currency || DEFAULT_PROFILE.currency}
            onRemoveWish={handleRemoveWish}
            t={t}
            colors={colors}
            primaryGoals={profile.primaryGoals}
            onGoalLongPress={handleGoalLongPress}
            onGoalEdit={openGoalEditorPrompt}
            activeGoalId={activeGoalId || profile.goal}
            onSetActiveGoal={handleActiveGoalSelect}
            language={language}
            catCuriousSource={tamagotchiAnimations.curious}
          />
        );
      case "pending":
        return (
          <PendingScreen
            items={pendingList}
            currency={profile.currency || DEFAULT_PROFILE.currency}
            t={t}
            colors={colors}
            onResolve={handlePendingDecision}
            onDelete={handlePendingDelete}
            language={language}
            catCuriousSource={tamagotchiAnimations.curious}
          />
        );
      case "purchases":
        return (
          <RewardsScreen
            achievements={achievements}
            challenges={challengeList}
            activePane={rewardsPane}
            onPaneChange={setRewardsPane}
            onChallengeAccept={handleChallengeAccept}
            onChallengeClaim={handleChallengeClaim}
            onChallengeCancel={handleChallengeCancel}
            t={t}
            colors={colors}
            savedTotalUSD={savedTotalUSD}
            currency={profile.currency || DEFAULT_PROFILE.currency}
            onRewardClaim={handleRewardClaim}
            healthRewardAmount={HEALTH_PER_REWARD}
            language={language}
            dailyChallenge={activeDailyChallenge}
          />
        );
      case "profile":
        return (
          <ProfileScreen
            profile={isEditingProfile ? profileDraft : profile}
            stats={profileStats}
            isEditing={isEditingProfile}
            onFieldChange={(field, value) => setProfileDraft((prev) => ({ ...prev, [field]: value }))}
            onEditPress={startProfileEdit}
            onCancelEdit={cancelProfileEdit}
            onSaveEdit={saveProfileEdit}
            onThemeToggle={handleThemeToggle}
            onLanguageChange={handleLanguageChange}
            onCurrencyChange={handleProfileCurrencyChange}
          onGoalChange={handleProfileGoalChange}
          onResetData={handleResetData}
          onPickImage={handlePickImage}
          theme={theme}
          language={language}
          currencyValue={profile.currency || DEFAULT_PROFILE.currency}
          history={resolvedHistoryEvents}
          onHistoryDelete={handleHistoryDelete}
          freeDayStats={freeDayStats}
          rewardBadgeCount={rewardClaimTotal}
          analyticsOptOut={analyticsOptOutValue}
          onAnalyticsToggle={handleAnalyticsToggle}
          t={t}
          colors={colors}
          moodPreset={moodPreset}
          mascotImageSource={tamagotchiAvatarSource}
        />
      );
      default:
        return (
          <FeedScreen
            products={filteredProducts}
            categories={categories}
            activeCategory={activeCategory}
            onCategorySelect={handleCategorySelect}
            savedTotalUSD={savedTotalUSD}
            wishes={wishes}
            onTemptationAction={handleTemptationAction}
            onTemptationEditToggle={toggleTemptationEditor}
            onTemptationQuickGoalToggle={handleQuickGoalToggle}
            t={t}
            language={language}
            colors={colors}
            currency={profile.currency || DEFAULT_PROFILE.currency}
            freeDayStats={freeDayStats}
            onFreeDayLog={handleLogFreeDay}
            goalAssignments={temptationGoalMap}
            analyticsStats={analyticsStats}
            refuseStats={refuseStats}
            cardFeedback={cardFeedback}
            historyEvents={resolvedHistoryEvents}
            profile={profile}
            titleOverrides={titleOverrides}
            descriptionOverrides={descriptionOverrides}
            onLevelCelebrate={handleLevelCelebrate}
            onBaselineSetup={handleBaselineSetupPrompt}
            healthPoints={healthPoints}
            onFreeDayRescue={handleFreeDayRescue}
            freeDayRescueCost={FREE_DAY_RESCUE_COST}
            impulseInsights={impulseInsights}
            moodPreset={moodPreset}
            onMoodDetailsOpen={openMoodDetails}
            onPotentialDetailsOpen={openPotentialDetails}
            heroGoalTargetUSD={heroGoalTargetUSD}
            heroGoalSavedUSD={heroGoalSavedUSD}
            mascotOverride={mascotOverride}
            onMascotAnimationComplete={handleMascotAnimationComplete}
            hideMascot={tamagotchiVisible}
            onMascotPress={openTamagotchiOverlay}
            editingTemptationId={priceEditor.item?.id || null}
            editingTitleValue={priceEditor.title}
            editingPriceValue={priceEditor.value}
            editingGoalLabel={priceEditorAssignedGoalTitle}
            editingEmojiValue={priceEditor.emoji}
            editingDescriptionValue={priceEditor.description || ""}
            editingCategoryValue={priceEditor.category || DEFAULT_IMPULSE_CATEGORY}
            onTemptationEditTitleChange={handlePriceTitleChange}
            onTemptationEditPriceChange={handlePriceInputChange}
            onTemptationEditEmojiChange={handlePriceEmojiChange}
            onTemptationEditDescriptionChange={handlePriceDescriptionChange}
            onTemptationEditCategoryChange={handlePriceCategoryChange}
            onTemptationEditSave={savePriceEdit}
            onTemptationEditCancel={closePriceEditor}
            onTemptationEditDelete={handleTemptationDelete}
            onTemptationGoalSelect={openGoalLinkPrompt}
            onTemptationSwipeDelete={handleTemptationDelete}
            onSavingsBreakdownPress={openSavingsBreakdown}
            resolveTemplateTitle={resolveTemplateTitle}
            tamagotchiMood={tamagotchiMood}
            tamagotchiDesiredFood={tamagotchiDesiredFood}
            primaryTemptationId={primaryTemptationId}
            primaryTemptationDescription={primaryTemptationDescription}
            focusTemplateId={focusTemplateId}
            tamagotchiAnimations={tamagotchiAnimations}
            lifetimeSavedUSD={lifetimeSavedUSD}
            interactionStats={temptationInteractions}
          />
        );
    }
  };

  useEffect(() => {
    const tabScreens = {
      feed: "feed",
      cart: "wishlist",
      pending: "pending",
      purchases: "rewards",
      profile: "profile",
    };
    const screenName = tabScreens[activeTab] || "feed";
    logScreenView(screenName);
  }, [activeTab]);
  useEffect(() => {
    if (!tabHintsHydrated) return;
    if (!tutorialSeen) return;
    if (tutorialVisible) return;
    if (tabHintVisible) return;
    if (tabHintsSeen[activeTab]) return;
    const config = TAB_HINT_CONFIG[activeTab];
    if (!config) return;
    setTabHintVisible({
      tab: activeTab,
      title: t(config.titleKey),
      body: t(config.bodyKey),
    });
    markTabHintSeen(activeTab);
  }, [
    activeTab,
    markTabHintSeen,
    tabHintVisible,
    tabHintsHydrated,
    tabHintsSeen,
    t,
    tutorialSeen,
    tutorialVisible,
  ]);
  useEffect(() => {
    if (!tutorialVisible && !tutorialSeen) return;
    if (!tabHintVisible) return;
    setTabHintVisible(null);
  }, [tutorialVisible, tutorialSeen, tabHintVisible]);

  useEffect(() => {
    if (!termsAccepted) return;
    const onboardingScreens = {
      logo: "onboarding_logo",
      language: "onboarding_language",
      guide: "onboarding_guide",
      register: "onboarding_register",
      persona: "onboarding_persona",
      habit: "onboarding_custom_spend",
      baseline: "onboarding_baseline",
      goal: "onboarding_goal",
      goal_target: "onboarding_goal_target",
      analytics_consent: "onboarding_analytics_consent",
    };
    const screen = onboardingScreens[onboardingStep];
    if (screen) {
      logScreenView(screen);
    }
  }, [onboardingStep, termsAccepted]);

  if (onboardingStep !== "done") {
    const onboardingBackHandler = canGoBackOnboarding ? handleOnboardingBack : undefined;
    let onboardContent = null;
    if (onboardingStep === "logo") {
      onboardContent = <LogoSplash onDone={() => goToOnboardingStep("language", { recordHistory: false })} />;
    } else if (onboardingStep === "language") {
      onboardContent = (
        <LanguageScreen
          colors={colors}
          t={t}
          selectedLanguage={language}
          selectedCurrency={registrationData.currency || DEFAULT_PROFILE.currency}
          onLanguageChange={handleLanguageChange}
          onCurrencyChange={(code) => updateRegistrationData("currency", code)}
          onContinue={handleLanguageContinue}
          onBack={onboardingBackHandler}
          onShowTerms={handleTermsOpen}
          termsAccepted={termsAccepted}
          mascotWaveSource={tamagotchiAnimations.waving}
        />
      );
    } else if (onboardingStep === "guide") {
      onboardContent = (
        <HowItWorksScreen colors={colors} t={t} onContinue={handleGuideContinue} onBack={onboardingBackHandler} />
      );
    } else if (onboardingStep === "register") {
      onboardContent = (
        <RegistrationScreen
          data={registrationData}
          onChange={updateRegistrationData}
          onSubmit={handleRegistrationSubmit}
          onPickImage={handleRegistrationPickImage}
          colors={colors}
          t={t}
          onBack={onboardingBackHandler}
          mascotImageSource={tamagotchiAvatarSource}
        />
      );
    } else if (onboardingStep === "persona") {
      onboardContent = (
        <PersonaScreen
          data={registrationData}
          onChange={updateRegistrationData}
          onSubmit={handlePersonaSubmit}
          colors={colors}
          t={t}
          language={language}
          onBack={onboardingBackHandler}
        />
      );
    } else if (onboardingStep === "habit") {
      onboardContent = (
        <CustomHabitScreen
          data={registrationData}
          onChange={updateRegistrationData}
          onSubmit={handleHabitSubmit}
          colors={colors}
          t={t}
          currency={registrationData.currency || profile.currency || DEFAULT_PROFILE.currency}
          onBack={onboardingBackHandler}
          language={language}
        />
      );
    } else if (onboardingStep === "baseline") {
      onboardContent = (
        <SpendingBaselineScreen
          value={registrationData.baselineMonthlyWaste || ""}
          currency={registrationData.currency || profile.currency || DEFAULT_PROFILE.currency}
          onChange={(text) => updateRegistrationData("baselineMonthlyWaste", text)}
          onSubmit={handleBaselineSubmit}
          colors={colors}
          t={t}
          onBack={onboardingBackHandler}
        />
      );
    } else if (onboardingStep === "goal") {
      onboardContent = (
        <GoalScreen
          selectedGoals={registrationData.goalSelections || []}
          onToggle={handleGoalToggle}
          onSubmit={handleGoalStageContinue}
          colors={colors}
          t={t}
          language={language}
          onBack={onboardingBackHandler}
          customGoals={registrationData.customGoals || []}
          onCustomGoalCreate={openOnboardingGoalModal}
        />
      );
    } else if (onboardingStep === "goal_target") {
      onboardContent = (
        <GoalTargetScreen
          selections={registrationData.goalSelections || []}
          values={registrationData.goalTargetMap || {}}
          currency={registrationData.currency || profile.currency || DEFAULT_PROFILE.currency}
          onChange={handleGoalTargetDraftChange}
          onSubmit={handleGoalTargetSubmit}
          onBack={onboardingBackHandler}
          colors={colors}
          t={t}
          language={language}
          customGoals={registrationData.customGoals || []}
        />
      );
    } else if (onboardingStep === "analytics_consent") {
      onboardContent = (
        <AnalyticsConsentScreen
          colors={colors}
          t={t}
          onSubmit={(allow) => handleAnalyticsConsentComplete(allow)}
          onBack={onboardingBackHandler}
        />
      );
    }
    const onboardingBackground = onboardingStep === "logo" ? "#fff" : colors.background;
    return (
      <>
        <View style={[styles.appBackground, { backgroundColor: onboardingBackground }]}>
          <SafeAreaView
            style={[
              styles.appShell,
              {
                backgroundColor: onboardingBackground,
                paddingTop: topSafeInset,
              },
            ]}
          >
            {shouldRenderStatusGlass && (
              <StatusGlass
                height={topSafeInset}
                colors={{ ...colors, background: onboardingBackground }}
                theme={theme}
                blurAvailable={statusBlurAvailable}
              />
            )}
            <StatusBar style={theme === "dark" ? "light" : "dark"} backgroundColor={onboardingBackground} />
            {onboardContent || (
              <LogoSplash onDone={() => goToOnboardingStep("language", { recordHistory: false })} />
            )}
          </SafeAreaView>
        </View>
        <ImageSourceSheet
          visible={showImageSourceSheet}
          colors={colors}
          t={t}
          onClose={closeImagePickerSheet}
          onSelect={handleImageSourceChoice}
        />
        <OnboardingGoalModal
          visible={onboardingGoalModal.visible}
          colors={colors}
          t={t}
          currency={registrationData.currency || profile.currency || DEFAULT_PROFILE.currency}
          data={onboardingGoalModal}
          onChange={handleOnboardingGoalChange}
          onSubmit={handleOnboardingGoalSubmit}
          onCancel={handleOnboardingGoalCancel}
          keyboardOffset={keyboardModalOffset}
        />
        <TermsModal
          visible={termsModalVisible}
          colors={colors}
          t={t}
          language={language}
          onAccept={handleTermsAccept}
          onCancel={handleTermsCancel}
          onOpenLink={handleTermsLinkOpen}
        />
      </>
    );
  }

  return (
    <SavingsProvider value={{ savedTotalUSD }}>
      <TouchableWithoutFeedback
        onPress={Keyboard.dismiss}
        accessible={false}
        disabled={!keyboardVisible}
        touchSoundDisabled
      >
        <View style={[styles.appBackground, { backgroundColor: colors.background }]}>
          <SafeAreaView
            style={[
              styles.appShell,
              {
                backgroundColor: colors.background,
                paddingTop: topSafeInset,
              },
            ]}
            onLayout={handleHomeLayout}
          >
            {shouldRenderStatusGlass && (
              <StatusGlass
                height={topSafeInset}
                colors={colors}
                theme={theme}
                blurAvailable={statusBlurAvailable}
              />
            )}
            {startupLogoVisible && (
              <View style={[styles.logoSplashOverlay, { backgroundColor: colors.background }]}>
                <LogoSplash onDone={handleStartupLogoComplete} />
              </View>
            )}
            <StatusBar
              style={theme === "dark" ? "light" : "dark"}
              backgroundColor={systemOverlayActive ? overlaySystemColor : colors.background}
            />
            <View style={[styles.screenWrapper, screenKeyboardAdjustmentStyle]}>{renderActiveScreen()}</View>
        {savingsBreakdownVisible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={closeSavingsBreakdown}>
              <View style={styles.breakdownOverlay}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.breakdownCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <View style={styles.breakdownHeader}>
                      <Text style={[styles.breakdownTitle, { color: colors.text }]}>
                        {t("savingsBreakdownTitle")}
                      </Text>
                      <TouchableOpacity onPress={closeSavingsBreakdown}>
                        <Text style={[styles.breakdownClose, { color: colors.muted }]}>‚úï</Text>
                      </TouchableOpacity>
                    </View>
                  <View style={styles.breakdownBars}>
                    {(() => {
                        const maxTotal = Math.max(...savingsBreakdown.days.map((d) => d.total || 0), 1);
                        return savingsBreakdown.days.map((day) => (
                          <View key={day.label} style={styles.breakdownBarItem}>
                            <View style={[styles.breakdownBarTrack, { backgroundColor: colors.border }]}>
                              {day.stacks.map((stack) => {
                                const share = day.total ? (stack.value / (day.total || 1)) * 100 : 0;
                                const height = Math.max(6, Math.min(90, share));
                                return (
                                  <View
                                    key={stack.title}
                                    style={[
                                      styles.breakdownBarStack,
                                      {
                                        height: `${height}%`,
                                        backgroundColor: stack.color,
                                      },
                                    ]}
                                  />
                                );
                              })}
                            </View>
                            <Text style={[styles.breakdownBarLabel, { color: colors.muted }]}>{day.label}</Text>
                            <View style={styles.breakdownAmountWrapper}>
                              <Text
                                style={[styles.breakdownBarAmount, { color: colors.text }]}
                                numberOfLines={1}
                                adjustsFontSizeToFit
                                minimumFontScale={0.6}
                              >
                                {savingsBreakdown.formatLocal(day.total)}
                              </Text>
                            </View>
                          </View>
                        ));
                      })()}
                    </View>
                    <View style={styles.breakdownLegend}>
                      {savingsBreakdown.legend.map((entry) => (
                        <View
                          key={entry.id}
                          style={[styles.breakdownLegendItem, { borderColor: colors.border }]}
                        >
                          <View
                            style={[styles.breakdownLegendDot, { backgroundColor: entry.color }]}
                          />
                          <Text style={[styles.breakdownLegendText, { color: colors.text }]}>
                            {entry.label} ¬∑ {entry.percent}%
                          </Text>
                        </View>
                      ))}
                    </View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {dailyChallengePromptVisible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={handleDailyChallengeLater}>
              <View style={styles.dailySummaryBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.dailyChallengeCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <View
                      style={[
                        styles.dailyChallengeGlow,
                        { backgroundColor: isDarkTheme ? "rgba(255,200,87,0.4)" : "rgba(255,160,60,0.25)" },
                      ]}
                    />
                    <View style={styles.dailyChallengeContent}>
                      <View style={styles.dailyChallengeHeroRow}>
                        <View style={{ flex: 1, gap: 6 }}>
                          <View
                            style={[
                              styles.dailyChallengeBadge,
                              { borderColor: colors.border, backgroundColor: colors.background },
                            ]}
                          >
                            <Text style={[styles.dailyChallengeBadgeText, { color: colors.muted }]}>
                              {t("dailyChallengeOfferBadge")}
                            </Text>
                          </View>
                          <Text style={[styles.dailyChallengeTitle, { color: colors.text }]}>
                            {t("dailyChallengeOfferTitle")}
                          </Text>
                          <Text style={[styles.dailyChallengeSubtitle, { color: colors.muted }]}>
                            {t("dailyChallengeOfferSubtitle", { temptation: dailyChallengeDisplayTitle })}
                          </Text>
                        </View>
                        <View style={styles.dailyChallengeRewardStack}>
                          <HealthRewardTokens amount={dailyChallenge.rewardBonus} color={colors.text} iconSize={18} />
                          <Text style={[styles.dailyChallengeRewardHint, { color: colors.text }]}>
                            {t("dailyChallengeOfferReward", { amount: dailyChallengeRewardLabel })}
                          </Text>
                        </View>
                      </View>
                      <View style={styles.dailyChallengeTemptationRow}>
                        <View style={styles.dailyChallengeEmojiCard}>
                          <Text style={styles.dailyChallengeEmojiCardText}>{dailyChallenge.emoji || "‚ú®"}</Text>
                        </View>
                        <View style={{ flex: 1, gap: 4 }}>
                          <Text style={[styles.dailyChallengeTemptationTitle, { color: colors.text }]}>
                            {dailyChallengeDisplayTitle}
                          </Text>
                          <Text style={[styles.dailyChallengeTemptationHint, { color: colors.muted }]}>
                            {t("dailyChallengeOfferHint")}
                          </Text>
                        </View>
                      </View>
                      <View style={styles.dailyChallengeActions}>
                        <TouchableOpacity
                          style={[styles.dailyChallengePrimaryButton, { backgroundColor: colors.text }]}
                          activeOpacity={0.92}
                          onPress={handleDailyChallengeAccept}
                        >
                          <Text style={[styles.dailyChallengePrimaryText, { color: colors.background }]}>
                            {t("dailyChallengeOfferAccept")}
                          </Text>
                        </TouchableOpacity>
                        <TouchableOpacity
                          style={[styles.dailyChallengeGhostButton, { borderColor: colors.border }]}
                          activeOpacity={0.85}
                          onPress={handleDailyChallengeLater}
                        >
                          <Text style={[styles.dailyChallengeGhostText, { color: colors.muted }]}>
                            {t("dailyChallengeOfferLater")}
                          </Text>
                        </TouchableOpacity>
                      </View>
                    </View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {dailySummaryVisible && dailySummaryData && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={() => setDailySummaryVisible(false)}>
              <View style={styles.dailySummaryBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.dailySummaryCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <View
                      style={[
                        styles.dailySummaryGlow,
                        { backgroundColor: isDarkTheme ? "#FFC857" : "#111111" },
                      ]}
                    />
                    <View style={styles.dailySummaryCardContent}>
                      <View style={styles.dailySummaryHeroRow}>
                        <View
                          style={[
                            styles.dailySummaryIconWrap,
                            {
                              backgroundColor: isDarkTheme
                                ? "rgba(255,255,255,0.08)"
                                : "rgba(17,17,17,0.05)",
                              borderColor: colors.border,
                            },
                          ]}
                        >
                          <Text style={styles.dailySummaryIconText}>üåô</Text>
                        </View>
                        <View style={styles.dailySummaryHeroText}>
                          <View
                            style={[
                              styles.dailySummaryBadge,
                              { backgroundColor: colors.background, borderColor: colors.border },
                            ]}
                          >
                            <Text style={[styles.dailySummaryBadgeText, { color: colors.muted }]}>
                              {t("dailySummaryBadgeLabel")}
                            </Text>
                          </View>
                          <Text style={[styles.dailySummaryTitle, { color: colors.text }]}>
                            {t("dailySummaryTitle")}
                          </Text>
                          <Text style={[styles.dailySummarySubtitle, { color: colors.muted }]}>
                            {t("dailySummarySubtitle")}
                          </Text>
                        </View>
                      </View>
                      <View
                        style={[
                          styles.dailySummaryHighlight,
                          {
                            backgroundColor: isDarkTheme
                              ? "rgba(255,255,255,0.06)"
                              : "rgba(17,17,17,0.03)",
                            borderColor: isDarkTheme ? "rgba(255,255,255,0.12)" : "rgba(0,0,0,0.06)",
                          },
                        ]}
                      >
                        <Text style={[styles.dailySummaryHighlightLabel, { color: colors.muted }]}>
                          {t("dailySummarySavedLabel")}
                        </Text>
                        <Text style={[styles.dailySummaryHighlightValue, { color: colors.text }]}>
                          {formatCurrency(
                            convertToCurrency(
                              dailySummaryData.savedUSD || 0,
                              profile.currency || DEFAULT_PROFILE.currency
                            ),
                            profile.currency || DEFAULT_PROFILE.currency
                          )}
                        </Text>
                        <Text style={[styles.dailySummaryHighlightSub, { color: colors.muted }]}>
                          {t("dailySummarySavedSub")}
                        </Text>
                      </View>
                      <View style={styles.dailySummaryStatsRow}>
                        <View
                          style={[
                            styles.dailySummaryStatCard,
                            {
                              backgroundColor: isDarkTheme
                                ? "rgba(255,255,255,0.08)"
                                : "rgba(255,255,255,0.94)",
                              borderColor: isDarkTheme ? "rgba(255,255,255,0.12)" : "rgba(0,0,0,0.05)",
                            },
                          ]}
                        >
                          <Text style={[styles.dailySummaryStatValue, { color: colors.text }]}>
                            {dailySummaryData.declines || 0}
                          </Text>
                          <Text style={[styles.dailySummaryStatLabel, { color: colors.muted }]}>
                            {t("statsDeclines")}
                          </Text>
                        </View>
                        <View
                          style={[
                            styles.dailySummaryStatCard,
                            {
                              backgroundColor: isDarkTheme
                                ? "rgba(255,255,255,0.08)"
                                : "rgba(255,255,255,0.94)",
                              borderColor: isDarkTheme ? "rgba(255,255,255,0.12)" : "rgba(0,0,0,0.05)",
                            },
                          ]}
                        >
                        <Text style={[styles.dailySummaryStatValue, { color: colors.text }]}>
                            {dailySummaryData.spends || 0}
                          </Text>
                          <Text style={[styles.dailySummaryStatLabel, { color: colors.muted }]}>
                            {t("dailySummarySpendsLabel")}
                          </Text>
                        </View>
                      </View>
                      <TouchableOpacity
                        style={[styles.dailySummaryButton, { backgroundColor: colors.text }]}
                        onPress={handleDailySummaryContinue}
                        activeOpacity={0.9}
                      >
                        <Text style={[styles.dailySummaryButtonText, { color: colors.background }]}>
                          {t("dailySummaryContinue")}
                        </Text>
                        <Text style={[styles.dailySummaryButtonIcon, { color: colors.background }]}>
                          ‚Üí
                        </Text>
                      </TouchableOpacity>
                      <Text style={[styles.dailySummaryHint, { color: colors.muted }]}>
                        {t("dailySummaryHint")}
                      </Text>
                    </View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {ratingPromptVisible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={handleRatingPromptLater}>
              <View style={styles.ratingPromptBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.ratingPromptCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <Text style={[styles.ratingPromptTitle, { color: colors.text }]}>
                      {t("ratingPromptTitle")}
                    </Text>
                    <Text style={[styles.ratingPromptBody, { color: colors.muted }]}>
                      {t("ratingPromptBody")}
                    </Text>
                    <View style={styles.ratingPromptActions}>
                      <TouchableOpacity
                        style={[styles.ratingPromptSecondary, { borderColor: colors.border }]}
                        activeOpacity={0.85}
                        onPress={handleRatingPromptLater}
                      >
                        <Text style={[styles.ratingPromptSecondaryText, { color: colors.muted }]}>
                          {t("ratingPromptLater")}
                        </Text>
                      </TouchableOpacity>
                      <TouchableOpacity
                        style={[styles.ratingPromptPrimary, { backgroundColor: colors.text }]}
                        activeOpacity={0.92}
                        onPress={handleRatingPromptConfirm}
                      >
                        <Text style={[styles.ratingPromptPrimaryText, { color: colors.background }]}>
                          {t("ratingPromptAction")}
                        </Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {levelShareModal.visible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={closeLevelShareModal}>
              <View style={styles.dailySummaryBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.levelShareModalCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <Text style={[styles.levelShareModalTitle, { color: colors.text }]}>
                      {t("levelShareModalTitle")}
                    </Text>
                    <Text style={[styles.levelShareModalCaption, { color: colors.muted }]}>
                      {t("levelShareModalCaption")}
                    </Text>
                    <ViewShot
                      ref={levelShareCardRef}
                      options={{ format: "png", quality: 0.96, result: "tmpfile" }}
                      style={styles.levelShareShot}
                    >
                      <View style={styles.levelShareCanvas}>
                        <View style={styles.levelShareBadge}>
                          <Text style={styles.levelShareBadgeText}>{t("levelShareCardBadge")}</Text>
                        </View>
                        <Text style={styles.levelShareCanvasTitle}>
                          {t("levelShareCardTitle", { level: levelShareModal.level })}
                        </Text>
                        <Text style={styles.levelShareCanvasSubtitle}>{t("levelShareCardSubtitle")}</Text>
                        <Image source={LEVEL_SHARE_CAT} style={styles.levelShareCat} />
                        <Text style={styles.levelShareJoin}>{t("levelShareJoin")}</Text>
                        <View style={styles.levelShareFooter}>
                          <Image source={LEVEL_SHARE_LOGO} style={styles.levelShareLogo} />
                          <View>
                            <Text style={styles.levelShareFooterBrand}>{t("levelShareFooterBrand")}</Text>
                            <Text style={styles.levelShareFooterHint}>{t("levelShareFooterHint")}</Text>
                          </View>
                        </View>
                      </View>
                    </ViewShot>
                    <View style={styles.levelShareActions}>
                      <TouchableOpacity
                        style={[
                          styles.levelSharePrimary,
                          { backgroundColor: colors.text, opacity: levelShareSharing ? 0.6 : 1 },
                        ]}
                        activeOpacity={0.92}
                        disabled={levelShareSharing}
                        onPress={handleLevelShareConfirm}
                      >
                        <Text style={[styles.levelSharePrimaryText, { color: colors.background }]}>
                          {levelShareSharing ? "..." : t("levelShareModalShare")}
                        </Text>
                      </TouchableOpacity>
                      <TouchableOpacity
                        style={[styles.levelShareGhost, { borderColor: colors.border }]}
                        activeOpacity={0.85}
                        onPress={closeLevelShareModal}
                      >
                        <Text style={[styles.levelShareGhostText, { color: colors.muted }]}>
                          {t("levelShareModalClose")}
                        </Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        <View
          style={[
            styles.tabBar,
            {
              backgroundColor: colors.card,
              borderTopColor: colors.border,
              paddingBottom: tabBarBottomInset,
              marginBottom: Platform.OS === "ios" ? -(safeAreaInsets.bottom || 0) : 0,
              paddingTop: 12,
            },
          ]}
          onLayout={handleTabBarLayout}
        >
          {["feed", "cart", "pending", "purchases", "profile"].map((tab) => {
            const isHighlighted = !!tutorialHighlightTabs?.has(tab);
            const isActiveTab = activeTab === tab;
            const highlightBackground = theme === "dark" ? "rgba(255,255,255,0.2)" : "#FFFFFF";
            const highlightTextColor = theme === "dark" ? "#05070D" : colors.text;
            const defaultTextColor = isActiveTab ? colors.text : colors.muted;
            const textColor = isHighlighted ? highlightTextColor : defaultTextColor;
            const highlightBorderColor =
              theme === "dark" ? "rgba(255,255,255,0.4)" : "rgba(0,0,0,0.08)";
            return (
              <TouchableOpacity
                key={tab}
                style={[
                  styles.tabButton,
                  isHighlighted && styles.tabButtonHighlight,
                  isHighlighted && {
                    borderColor: highlightBorderColor,
                    backgroundColor: highlightBackground,
                  },
                ]}
                onPress={() => handleTabChange(tab)}
              >
                <Text
                  style={[
                    styles.tabButtonText,
                    {
                      color: textColor,
                      fontWeight: isActiveTab || isHighlighted ? "700" : "500",
                      fontSize: tabLabelFontSize,
                    },
                  ]}
                >
                  {tab === "feed"
                    ? t("feedTab")
                    : tab === "cart"
                    ? t("wishlistTab")
                    : tab === "pending"
                    ? t("pendingTab")
                    : tab === "purchases"
                    ? t("purchasesTitle")
                    : t("profileTab")}
                </Text>
                {tab === "purchases" && rewardsBadgeCount > 0 && (
                  <View
                    style={[
                      styles.tabBadge,
                      styles.tabBadgeFloating,
                      {
                        backgroundColor: theme === "dark" ? "#FEE5A8" : colors.text,
                      },
                    ]}
                  >
                    <Text
                      style={[
                        styles.tabBadgeText,
                        { color: theme === "dark" ? "#05070D" : colors.background },
                      ]}
                    >
                      {rewardsBadgeCount > 99 ? "99+" : `${rewardsBadgeCount}`}
                    </Text>
                  </View>
                )}
              </TouchableOpacity>
            );
          })}
        </View>

        {activeTab !== "profile" && activeTab !== "purchases" && (
          <View pointerEvents="box-none" style={styles.fabCenterContainer}>
            <View
              ref={fabButtonWrapperRef}
              style={styles.fabButtonWrapper}
              pointerEvents="box-none"
              onLayout={handleFabWrapperLayout}
            >
              {fabTutorialVisible && (
                <View
                  pointerEvents="none"
                  style={[
                    styles.fabTutorialHalo,
                    {
                      backgroundColor: theme === "dark" ? "rgba(255,214,140,0.22)" : "rgba(245,200,105,0.22)",
                      borderColor: theme === "dark" ? "#FFE08A" : "#F5C869",
                      shadowColor: theme === "dark" ? "#FFE08A" : "#F5C869",
                    },
                  ]}
                />
              )}
              <AnimatedTouchableOpacity
                style={[
                  styles.cartBadge,
                  {
                    backgroundColor: colors.text,
                    borderColor: colors.border,
                    transform: [{ scale: cartBadgeScale }],
                  },
                  fabTutorialVisible && styles.cartBadgeHighlight,
                ]}
                onPress={handleFabPress}
                onLongPress={handleFabLongPress}
                delayLongPress={420}
              >
                <Text style={[styles.cartBadgeIcon, { color: colors.background }]}>+</Text>
              </AnimatedTouchableOpacity>
            </View>
          </View>
        )}

        <CoinEntryModal
          visible={coinEntryVisible}
          colors={colors}
          t={t}
          currency={profile.currency || DEFAULT_PROFILE.currency}
          language={language}
          maxAmountUSD={coinSliderMaxUSD}
          onUpdateMaxUSD={handleCoinSliderMaxUpdate}
          onSubmit={handleCoinEntrySubmit}
          onCancel={handleCoinEntryClose}
        />

        <QuickCustomModal
          visible={showCustomSpend}
          colors={colors}
          t={t}
          currency={profile.currency || DEFAULT_PROFILE.currency}
          data={quickSpendDraft}
          onChange={handleQuickCustomChange}
          onSubmit={handleQuickCustomSubmit}
          onCancel={handleQuickCustomCancel}
          language={language}
          keyboardOffset={keyboardModalOffset}
        />
        <NewPendingModal
          visible={newPendingModal.visible}
          colors={colors}
          t={t}
          currency={profile.currency || DEFAULT_PROFILE.currency}
          data={newPendingModal}
          onChange={handleNewPendingChange}
          onSubmit={handleNewPendingSubmit}
          onCancel={handleNewPendingCancel}
          keyboardOffset={keyboardModalOffset}
        />

        <NewGoalModal
          visible={newGoalModal.visible}
          colors={colors}
          t={t}
          currency={profile.currency || DEFAULT_PROFILE.currency}
          data={newGoalModal}
          onChange={handleNewGoalChange}
          onSubmit={handleNewGoalSubmit}
          onCancel={handleNewGoalCancel}
          keyboardOffset={keyboardModalOffset}
        />

        {activeTab !== "profile" && fabTutorialVisible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={() => handleFabTutorialDismiss("backdrop")}>
              <View style={styles.fabTutorialBackdrop}>
                <Svg
                  pointerEvents="none"
                  width={SCREEN_WIDTH}
                  height={SCREEN_HEIGHT}
                  style={styles.fabTutorialOverlaySvg}
                >
                  <Defs>
                    <Mask id="fabTutorialMask">
                      <SvgRect width={SCREEN_WIDTH} height={SCREEN_HEIGHT} fill="white" />
                      <SvgCircle
                        cx={fabTutorialCutout.centerX}
                        cy={fabTutorialCutout.centerY}
                        r={FAB_TUTORIAL_HALO_SIZE / 2}
                        fill="black"
                      />
                    </Mask>
                  </Defs>
                  <SvgRect
                    width={SCREEN_WIDTH}
                    height={SCREEN_HEIGHT}
                    fill={fabOverlayColor}
                    mask="url(#fabTutorialMask)"
                  />
                </Svg>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View style={styles.fabTutorialContent} pointerEvents="box-none">
                    <View
                      style={[
                        styles.fabTutorialCard,
                        {
                          backgroundColor: colors.card,
                          borderColor: colors.border,
                          marginBottom: tabBarBottomInset + FAB_CONTAINER_BOTTOM + FAB_TUTORIAL_CARD_SPACING,
                        },
                      ]}
                    >
                      <Text style={[styles.fabTutorialTitle, { color: colors.text }]}>
                        {t("fabTutorialTitle")}
                      </Text>
                      <Text style={[styles.fabTutorialDescription, { color: colors.muted }]}>
                        {t("fabTutorialDesc")}
                      </Text>
                      <TouchableOpacity
                        style={[styles.fabTutorialButton, { backgroundColor: colors.text }]}
                        onPress={() => handleFabTutorialDismiss("cta")}
                      >
                        <Text style={[styles.fabTutorialButtonText, { color: colors.background }]}>
                          {t("fabTutorialAction")}
                        </Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}

        {tutorialVisible && activeTutorialStep && (
          <Modal
            visible
            transparent
            animationType="fade"
            statusBarTranslucent
            onRequestClose={handleTutorialSkip}
          >
            <View
              style={[
                styles.tutorialBackdrop,
                { paddingBottom: 24 + tutorialCardOffset },
              ]}
              pointerEvents="box-none"
            >
              <View
                pointerEvents="none"
                style={[
                  StyleSheet.absoluteFillObject,
                  styles.tutorialBackdropDim,
                  { bottom: tutorialOverlayInset },
                ]}
              />
              <View
                style={[
                  styles.tutorialCard,
                  { backgroundColor: colors.card, borderColor: colors.border },
                ]}
              >
                <Text style={styles.tutorialIcon}>{activeTutorialStep.icon}</Text>
                <Text style={[styles.tutorialTitle, { color: colors.text }]}>
                  {t(activeTutorialStep.titleKey)}
                </Text>
                <Text style={[styles.tutorialDescription, { color: colors.muted }]}>
                  {t(activeTutorialStep.descriptionKey)}
                </Text>
                <View style={styles.tutorialProgressRow}>
                  <View style={styles.tutorialDots}>
                    {APP_TUTORIAL_STEPS.map((step, index) => (
                      <View
                        key={step.id}
                        style={[
                          styles.tutorialDot,
                          {
                            backgroundColor:
                              index <= tutorialStepIndex ? colors.text : colors.border,
                          },
                        ]}
                      />
                    ))}
                  </View>
                  <Text style={[styles.tutorialProgressText, { color: colors.muted }]}>
                    {t("tutorialProgress", {
                      current: `${tutorialStepIndex + 1}`,
                      total: `${APP_TUTORIAL_STEPS.length}`,
                    })}
                  </Text>
                </View>
                <View style={styles.tutorialActions}>
                  <TouchableOpacity style={styles.tutorialSkipButton} onPress={handleTutorialSkip}>
                    <Text style={[styles.tutorialSkipText, { color: colors.muted }]}>
                      {t("tutorialSkip")}
                    </Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.tutorialPrimaryButton, { backgroundColor: colors.text }]}
                    onPress={handleTutorialNext}
                  >
                    <Text style={[styles.tutorialPrimaryText, { color: colors.background }]}>
                      {tutorialStepIndex === APP_TUTORIAL_STEPS.length - 1
                        ? t("tutorialDone")
                        : t("tutorialNext")}
                    </Text>
                  </TouchableOpacity>
                </View>
              </View>
            </View>
          </Modal>
        )}
        {tabHintVisible && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissTabHint}>
              <View style={styles.tabHintBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.tabHintCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <Text style={[styles.tabHintTitle, { color: colors.text }]}>
                      {tabHintVisible.title}
                    </Text>
                    <Text style={[styles.tabHintBody, { color: colors.muted }]}>
                      {tabHintVisible.body}
                    </Text>
                    <TouchableOpacity
                      style={[styles.tabHintButton, { backgroundColor: colors.text }]}
                      onPress={dismissTabHint}
                    >
                      <Text style={[styles.tabHintButtonText, { color: colors.background }]}>
                        {t("tabHintGotIt")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}

        <Modal
          visible={tamagotchiVisible}
          transparent
          animationType="fade"
          onRequestClose={closeTamagotchiOverlay}
          statusBarTranslucent
        >
          <TouchableWithoutFeedback onPress={closeTamagotchiOverlay}>
            <View style={styles.tamagotchiBackdrop}>
              {partyActive && <PartyFireworksLayer isDarkMode={isDarkTheme} />}
              <TouchableWithoutFeedback onPress={() => {}}>
                <Animated.View
                  style={[
                    styles.tamagotchiCard,
                    { backgroundColor: colors.card, borderColor: colors.border },
                    {
                      transform: [
                        {
                          translateY: tamagotchiModalAnim.interpolate({
                            inputRange: [0, 1],
                            outputRange: [20, 0],
                          }),
                        },
                        {
                          scale: tamagotchiModalAnim.interpolate({
                            inputRange: [0, 1],
                            outputRange: [0.95, 1],
                          }),
                        },
                      ],
                      opacity: tamagotchiModalAnim,
                    },
                  ]}
                >
                  <View style={styles.tamagotchiHeader}>
                    <Text style={[styles.tamagotchiTitle, { color: colors.text }]}>
                      {t("tamagotchiName")}
                    </Text>
                    <Text style={[styles.tamagotchiMood, { color: colors.muted }]}>
                      {tamagotchiMood.label}
                    </Text>
                  </View>
                  <View style={styles.tamagotchiPreview}>
                    <AlmiTamagotchi
                      override={mascotOverride}
                      onOverrideComplete={handleMascotAnimationComplete}
                      isStarving={tamagotchiMood.tone === "urgent"}
                      animations={tamagotchiAnimations}
                    />
                    <TouchableOpacity
                      style={[
                        styles.skinPickerButton,
                        { borderColor: colors.border, backgroundColor: colors.card },
                      ]}
                      onPress={openSkinPicker}
                    >
                      <Text style={styles.skinPickerIcon}>üß•</Text>
                    </TouchableOpacity>
                  </View>
                  <View style={styles.tamagotchiStatRow}>
                    <Text style={[styles.tamagotchiStatLabel, { color: colors.muted }]}>
                      {t("tamagotchiFullnessLabel")}
                    </Text>
                    <Text style={[styles.tamagotchiStatValue, { color: colors.text }]}>
                      {Math.round(tamagotchiHungerPercent)}%
                    </Text>
                  </View>
                  <View style={[styles.tamagotchiProgress, { backgroundColor: colors.border }]}>
                    <View
                      style={[
                        styles.tamagotchiProgressFill,
                        {
                          backgroundColor: colors.text,
                          width: `${Math.max(8, Math.min(100, tamagotchiHungerPercent))}%`,
                        },
                      ]}
                    />
                  </View>
                  <View style={styles.tamagotchiStatRow}>
                    <Text style={[styles.tamagotchiStatLabel, { color: colors.muted }]}>
                      {t("tamagotchiCoinsLabel")}
                    </Text>
                    <Text style={[styles.tamagotchiStatValue, { color: colors.text }]}>
                      {tamagotchiCoins}
                    </Text>
                  </View>
                  {tamagotchiState.lastFedAt ? (
                    <Text style={[styles.tamagotchiSub, { color: colors.muted }]}>
                      {t("tamagotchiFedAtLabel")}:{" "}
                      {new Date(tamagotchiState.lastFedAt).toLocaleString()}
                    </Text>
                  ) : (
                    <Text style={[styles.tamagotchiSub, { color: colors.muted }]}>
                      {t("tamagotchiAwaitingFirstCoin")}
                    </Text>
                  )}
                  <Text style={[styles.tamagotchiFoodTitle, { color: colors.text }]}>
                    {t("tamagotchiFoodMenuTitle")}
                  </Text>
                  <View style={styles.tamagotchiFoodList}>
                    {TAMAGOTCHI_FOOD_OPTIONS.map((food, index) => {
                      const label = food.label[language] || food.label.en;
                      const coinTier = getHealthCoinTierForAmount(food.cost);
                      const affordable = tamagotchiCoins >= food.cost;
                      const isDesired = tamagotchiDesiredFood?.id === food.id;
                      const isLast = index === TAMAGOTCHI_FOOD_OPTIONS.length - 1;
                      return (
                        <TouchableOpacity
                          key={food.id}
                          style={[
                            styles.tamagotchiFoodButton,
                            { borderColor: colors.border, backgroundColor: colors.card },
                            isDesired && { borderColor: colors.text },
                            tamagotchiIsFull && styles.tamagotchiFoodButtonDisabled,
                            isLast && styles.tamagotchiFoodButtonLast,
                          ]}
                          activeOpacity={0.9}
                          onPress={() => feedTamagotchi(food.id)}
                          disabled={tamagotchiIsFull}
                        >
                          <Text style={styles.tamagotchiFoodEmoji}>{food.emoji}</Text>
                          <View style={styles.tamagotchiFoodInfo}>
                            <Text style={[styles.tamagotchiFoodLabel, { color: colors.text }]}>{label}</Text>
                            <Text style={[styles.tamagotchiFoodBoost, { color: colors.muted }]}>
                              {t("tamagotchiFoodBoostLabel", { percent: food.hungerBoost })}
                            </Text>
                          </View>
                          <View style={styles.tamagotchiFoodCost}>
                            <Image source={coinTier.asset} style={styles.tamagotchiFoodCostIcon} />
                            <Text
                              style={[
                                styles.tamagotchiFoodCostText,
                                { color: colors.text, opacity: affordable ? 1 : 0.5 },
                              ]}
                            >
                              √ó{food.cost}
                            </Text>
                          </View>
                          {isDesired && (
                            <View style={[styles.tamagotchiFoodBadge, { backgroundColor: colors.text }]}>
                              <Text style={[styles.tamagotchiFoodBadgeText, { color: colors.background }]}>
                                {t("tamagotchiFoodWantLabel")}
                              </Text>
                            </View>
                          )}
                        </TouchableOpacity>
                      );
                    })}
                  </View>
                  <View style={styles.tamagotchiActions}>
                    <TouchableOpacity
                      style={[
                        styles.tamagotchiButton,
                        { backgroundColor: colors.card, borderColor: colors.border },
                      ]}
                      onPress={startParty}
                    >
                      <View style={styles.tamagotchiButtonContent}>
                        <Image source={HEALTH_COIN_TIERS[1].asset} style={styles.tamagotchiButtonIcon} />
                        <Text style={[styles.tamagotchiButtonText, { color: colors.text }]}>
                          {t("tamagotchiPartyButtonLabel", { cost: TAMAGOTCHI_PARTY_BLUE_COST })}
                        </Text>
                      </View>
                    </TouchableOpacity>
                  </View>
                  {tamagotchiIsFull && (
                    <Text style={[styles.tamagotchiHint, { color: colors.muted }]}>
                      {t("tamagotchiFullHint")}
                    </Text>
                  )}
                  <TouchableOpacity onPress={closeTamagotchiOverlay} style={styles.tamagotchiClose}>
                    <Text style={[styles.tamagotchiCloseText, { color: colors.muted }]}>
                      {t("levelShareModalClose")}
                    </Text>
                  </TouchableOpacity>
                  {partyActive && (
                    <>
                      <ConfettiCannon
                        key={`party_confetti_${partyBurstKey}`}
                        count={120}
                        origin={{ x: SCREEN_WIDTH / 2, y: 0 }}
                        fadeOut
                        explosionSpeed={420}
                        fallSpeed={3200}
                      />
                      <Animated.View
                        pointerEvents="none"
                        style={[
                          styles.partyGlowOverlay,
                          {
                            opacity: partyGlow.interpolate({
                              inputRange: [0, 1],
                              outputRange: [0.1, 0.4],
                            }),
                            backgroundColor: isDarkTheme ? "rgba(110,155,255,0.6)" : "rgba(255,210,120,0.7)",
                          },
                        ]}
                      />
                    </>
                  )}
                </Animated.View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>
        <Modal
          visible={skinPickerVisible}
          transparent
          animationType="fade"
          statusBarTranslucent
          onRequestClose={closeSkinPicker}
        >
          <TouchableWithoutFeedback onPress={closeSkinPicker}>
            <View style={styles.skinPickerBackdrop}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View
                  style={[
                    styles.skinPickerCard,
                    { backgroundColor: colors.card, borderColor: colors.border },
                  ]}
                >
                  <Text style={[styles.skinPickerTitle, { color: colors.text, textAlign: "center" }]}>
                    {t("tamagotchiSkinTitle")}
                  </Text>
                  <ScrollView
                    contentContainerStyle={styles.skinPickerList}
                    showsVerticalScrollIndicator={false}
                  >
                    {tamagotchiSkinsLocked && (
                      <View
                        style={[
                          styles.skinUnlockCard,
                          {
                            backgroundColor: lightenColor(
                              colors.card,
                              isDarkTheme ? 0.08 : 0.15
                            ),
                            borderColor: colors.border,
                          },
                        ]}
                      >
                        <Text style={[styles.skinUnlockTitle, { color: colors.text }]}>
                          {t("tamagotchiSkinUnlockTitle")}
                        </Text>
                        <Text style={[styles.skinUnlockSubtitle, { color: colors.muted }]}>
                          {t("tamagotchiSkinUnlockDescription", { email: SUPPORT_EMAIL })}
                        </Text>
                        <TouchableOpacity
                          style={[
                            styles.skinUnlockButton,
                            { backgroundColor: colors.text },
                          ]}
                          onPress={handleUnlockSkinsPress}
                          activeOpacity={0.85}
                        >
                          <Text
                            style={[
                              styles.skinUnlockButtonText,
                              { color: colors.background },
                              isRomanceLocale ? { fontSize: scaleFontSize(12) } : null,
                            ]}
                          >
                            {t("tamagotchiSkinUnlockButton")}
                          </Text>
                        </TouchableOpacity>
                      </View>
                    )}
                    {TAMAGOTCHI_SKIN_OPTIONS.map((skin) => {
                      const active = skin.id === tamagotchiSkinId;
                      const locked = tamagotchiSkinsLocked && skin.id !== DEFAULT_TAMAGOTCHI_SKIN;
                      const label = skin.label?.[language] || skin.label?.en || skin.id;
                      const description =
                        skin.description?.[language] || skin.description?.en || "";
                      return (
                        <TouchableOpacity
                          key={skin.id}
                          style={[
                            styles.skinPickerItem,
                            {
                              borderColor: active ? colors.text : colors.border,
                              backgroundColor: active
                                ? lightenColor(colors.card, isDarkTheme ? 0.1 : 0.2)
                                : "transparent",
                              opacity: locked ? 0.55 : 1,
                            },
                          ]}
                          onPress={() => handleSkinSelect(skin.id)}
                          disabled={locked}
                        >
                          <Image source={skin.preview} style={styles.skinPickerAvatar} />
                          <View style={{ flex: 1 }}>
                            <Text style={[styles.skinPickerItemTitle, { color: colors.text }]}>
                              {label}
                            </Text>
                            {!!description && (
                              <Text style={[styles.skinPickerItemSubtitle, { color: colors.muted }]}>
                                {description}
                              </Text>
                            )}
                          </View>
                          {active ? (
                            <View
                              style={[
                                styles.skinPickerBadge,
                                { borderColor: colors.border, backgroundColor: colors.background },
                              ]}
                            >
                              <Text style={[styles.skinPickerBadgeText, { color: colors.text }]}>
                                {t("tamagotchiSkinCurrent")}
                              </Text>
                            </View>
                          ) : locked ? (
                            <View
                              style={[
                                styles.skinPickerBadge,
                                styles.skinPickerLockedBadge,
                                { borderColor: colors.border, backgroundColor: colors.background },
                              ]}
                            >
                              <Text
                                style={[
                                  styles.skinPickerBadgeText,
                                  styles.skinPickerLockedBadgeText,
                                  { color: colors.muted },
                                ]}
                              >
                                {t("tamagotchiSkinLockedBadge")}
                              </Text>
                            </View>
                          ) : null}
                        </TouchableOpacity>
                      );
                    })}
                  </ScrollView>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>

        {editOverlayVisible && (
          <TouchableWithoutFeedback onPress={closePriceEditor}>
            <View
              style={[styles.temptationEditOverlay, modalKeyboardPaddingStyle]}
              pointerEvents="box-none"
            >
              <Animated.View
                style={[
                  styles.temptationEditBackdrop,
                  {
                    opacity: editOverlayAnim.interpolate({
                      inputRange: [0, 1],
                      outputRange: [0, 0.6],
                    }),
                  },
                ]}
              />
              {priceEditor.item && (
                <TouchableWithoutFeedback onPress={() => {}}>
                  <Animated.View
                    style={[
                      styles.temptationEditCardContainer,
                      {
                        opacity: editOverlayAnim,
                        transform: [
                          {
                            scale: editOverlayAnim.interpolate({
                              inputRange: [0, 1],
                              outputRange: [0.92, 1],
                            }),
                          },
                          {
                            translateY: editOverlayAnim.interpolate({
                              inputRange: [0, 1],
                              outputRange: [40, 0],
                            }),
                          },
                        ],
                      },
                    ]}
                  >
                    <TemptationCard
                      item={priceEditor.item}
                      language={language}
                      colors={colors}
                      t={t}
                      isFocusTarget={priceEditor.item?.id === focusTemplateId}
                      descriptionOverride={
                        descriptionOverrides[priceEditor.item.id] ||
                        (priceEditor.item.id === primaryTemptationId
                          ? primaryTemptationDescription
                          : null)
                      }
                      currency={profile.currency || DEFAULT_PROFILE.currency}
                      stats={refuseStats[priceEditor.item.id]}
                      feedback={cardFeedback[priceEditor.item.id]}
                      titleOverride={titleOverrides[priceEditor.item.id]}
                      goalLabel={priceEditorAssignedGoalTitle || null}
                      isEditing
                      showEditorInline
                      cardStyle={styles.temptationOverlayCard}
                      editTitleValue={priceEditor.title}
                      editPriceValue={priceEditor.value}
                      editGoalLabel={priceEditorAssignedGoalTitle || ""}
                      editEmojiValue={priceEditor.emoji}
                      editDescriptionValue={priceEditor.description || ""}
                      editCategoryValue={priceEditor.category}
                      onEditTitleChange={handlePriceTitleChange}
                      onEditPriceChange={handlePriceInputChange}
                      onEditEmojiChange={handlePriceEmojiChange}
                      onEditDescriptionChange={handlePriceDescriptionChange}
                      onEditCategoryChange={handlePriceCategoryChange}
                      onEditSave={savePriceEdit}
                      onEditCancel={closePriceEditor}
                      onEditDelete={() => promptTemptationDelete(priceEditor.item)}
                      onEditGoalSelect={() => {
                        setGoalLinkPrompt({ visible: true, item: priceEditor.item, intent: "edit" });
                      }}
                      onQuickGoalToggle={handleQuickGoalToggle}
                      onSwipeDelete={() => promptTemptationDelete(priceEditor.item)}
                      onAction={async (type) => {
                        await handleTemptationAction(type, priceEditor.item);
                      }}
                    />
                  </Animated.View>
                </TouchableWithoutFeedback>
              )}
            </View>
          </TouchableWithoutFeedback>
        )}

        {moodDetailsVisible && moodPreset && (
          <Modal
            visible
            transparent
            animationType="fade"
            onRequestClose={closeMoodDetails}
            statusBarTranslucent
          >
            <TouchableWithoutFeedback onPress={closeMoodDetails}>
              <View style={styles.moodDetailsBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <MoodGradientBlock colors={moodGradient} style={styles.moodDetailsCard}>
                    <Text style={[styles.moodDetailsLabel, { color: colors.text }]}>
                      {moodPreset.label}
                    </Text>
                    {moodDescription ? (
                      <Text style={[styles.moodDetailsDescription, { color: colors.text }]}>
                        {moodDescription}
                      </Text>
                    ) : null}
                    <TouchableOpacity
                      style={[styles.moodDetailsButton, { borderColor: colors.text }]}
                      onPress={closeMoodDetails}
                    >
                      <Text style={[styles.moodDetailsButtonText, { color: colors.text }]}>
                        {t("profileOk") || "–û–∫"}
                      </Text>
                    </TouchableOpacity>
                  </MoodGradientBlock>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}

        {potentialDetailsVisible && (
          <Modal
            visible
            transparent
            animationType="fade"
            onRequestClose={closePotentialDetails}
            statusBarTranslucent
          >
            <TouchableWithoutFeedback onPress={closePotentialDetails}>
              <View style={styles.moodDetailsBackdrop}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.moodDetailsCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <Text style={[styles.moodDetailsLabel, { color: colors.text }]}>
                      {t("potentialBlockTitle")}
                    </Text>
                    <Text style={[styles.moodDetailsDescription, { color: colors.muted }]}>
                      {potentialDetailsText}
                    </Text>
                    <TouchableOpacity
                      style={[styles.moodDetailsButton, { borderColor: colors.text }]}
                      onPress={closePotentialDetails}
                    >
                      <Text style={[styles.moodDetailsButtonText, { color: colors.text }]}>
                        {t("profileOk") || "–û–∫"}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}

        {activeTab !== "profile" && fabMenuVisible && (
          <View pointerEvents="box-none" style={styles.fabMenuOverlay}>
            <TouchableWithoutFeedback onPress={closeFabMenu}>
              <View style={styles.fabMenuBackdrop} />
            </TouchableWithoutFeedback>
            <Animated.View
              style={[
                styles.fabOption,
                styles.fabOptionRow,
                {
                  opacity: fabMenuAnim,
                  transform: [
                    {
                      translateY: fabMenuAnim.interpolate({
                        inputRange: [0, 1],
                        outputRange: [20, 0],
                      }),
                    },
                    { scale: fabMenuAnim },
                  ],
                },
              ]}
            >
              <View style={styles.fabOptionRowContent}>
                <TouchableOpacity
                  style={[styles.fabCircle, { backgroundColor: colors.card, borderColor: colors.border }]}
                  onPress={handleFabNewGoal}
                >
                  <Text style={[styles.fabOptionText, { color: colors.text }]} numberOfLines={2}>
                    {t("fabNewGoal")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.fabCircle, { backgroundColor: colors.card, borderColor: colors.border }]}
                  onPress={handleFabNewTemptation}
                >
                  <Text style={[styles.fabOptionText, { color: colors.text }]} numberOfLines={2}>
                    {t("fabNewTemptation")}
                  </Text>
                </TouchableOpacity>
              </View>
            </Animated.View>
          </View>
        )}

        {overlay &&
          overlay.type !== "level" &&
          overlay.type !== "save" &&
          overlay.type !== "custom_temptation" &&
          overlay.type !== "reward" &&
          overlay.type !== "health" &&
          overlay.type !== "focus_reward" &&
          overlay.type !== "goal_complete" &&
          overlay.type !== "impulse_alert" &&
          overlay.type !== "focus_digest" && (
            <Modal visible transparent animationType="fade" statusBarTranslucent>
              <TouchableWithoutFeedback onPress={dismissOverlay}>
                <View style={styles.confettiLayer}>
                  <View
                    style={[
                      styles.overlayDim,
                      { backgroundColor: overlayDimColor },
                    ]}
                  />
                  {overlay.type === "cancel" && <RainOverlay colors={colors} />}
                  {overlay.type === "purchase" && (
                    <ConfettiCannon
                      key={confettiKey}
                      count={90}
                      origin={{ x: SCREEN_WIDTH / 2, y: 0 }}
                      fadeOut
                      explosionSpeed={350}
                      fallSpeed={2600}
                    />
                  )}
                  <View
                    style={[
                      styles.celebrationBanner,
                      {
                        backgroundColor: overlayCardBackground,
                        borderColor: overlayBorderColor,
                        borderWidth: overlay.type === "cart" ? 0 : 1,
                      },
                    ]}
                  >
                    {(overlay.type === "cancel" ||
                      overlay.type === "purchase" ||
                      overlay.type === "completion") && (
                      <Image
                        source={
                          overlay.type === "cancel"
                            ? tamagotchiAnimations.sad
                            : tamagotchiAnimations.happy
                        }
                        style={[
                          styles.celebrationCat,
                          overlay.type === "purchase" || overlay.type === "completion"
                            ? styles.catHappy
                            : styles.catSad,
                        ]}
                      />
                    )}
                    <Text style={[styles.celebrationText, { color: colors.text }]}>
                      {overlay.message}
                    </Text>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </Modal>
        )}
        {overlay?.type === "focus_digest" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <View style={styles.overlayFullScreen}>
              <View
                style={[
                  styles.overlayDim,
                  { backgroundColor: overlayDimColor },
                ]}
              />
              <TouchableWithoutFeedback onPress={() => {}}>
                <View
                  style={[
                    styles.focusDigestCard,
                    { backgroundColor: colors.card, borderColor: colors.border },
                  ]}
                >
                  <Text style={[styles.focusDigestTitle, { color: colors.text }]}>
                    {overlay.message?.title || ""}
                  </Text>
                  <Text style={[styles.focusDigestBody, { color: colors.muted }]}>
                    {overlay.message?.body || ""}
                  </Text>
                  <View style={styles.focusDigestStats}>
                    <View
                      style={[
                        styles.focusDigestStat,
                        {
                          borderColor: colors.border,
                          backgroundColor: lightenColor(colors.card, isDarkTheme ? 0.08 : 0.2),
                        },
                      ]}
                    >
                      <Text style={[styles.focusDigestLabel, { color: colors.muted }]}>
                        {t("focusDigestStrongLabel")}
                      </Text>
                      <Text style={[styles.focusDigestValue, { color: colors.text }]}>
                        {overlay.message?.strong?.title || t("focusDigestMissing")}
                      </Text>
                      {overlay.message?.strong?.window && (
                        <Text style={[styles.focusDigestHint, { color: colors.muted }]}>
                          {overlay.message.strong.window}
                        </Text>
                      )}
                    </View>
                    <View
                      style={[
                        styles.focusDigestStat,
                        {
                          borderColor: colors.border,
                          backgroundColor: lightenColor(colors.card, isDarkTheme ? 0.04 : 0.12),
                        },
                      ]}
                    >
                      <Text style={[styles.focusDigestLabel, { color: colors.muted }]}>
                        {t("focusDigestWeakLabel")}
                      </Text>
                      <Text style={[styles.focusDigestValue, { color: colors.text }]}>
                        {overlay.message?.weak?.title || t("focusDigestMissing")}
                      </Text>
                      {overlay.message?.weak?.window && (
                        <Text style={[styles.focusDigestHint, { color: colors.muted }]}>
                          {overlay.message.weak.window}
                        </Text>
                      )}
                    </View>
                  </View>
                  <View style={styles.focusDigestButtons}>
                    <TouchableOpacity
                      style={[styles.focusDigestSecondary, { borderColor: colors.border }]}
                      onPress={handleFocusOverlayLater}
                    >
                      <Text style={[styles.focusDigestSecondaryText, { color: colors.muted }]}>
                        {t("focusDigestDismiss")}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[
                        styles.focusDigestPrimary,
                        {
                          backgroundColor: overlay.message?.targetId ? colors.text : colors.border,
                        },
                      ]}
                      disabled={!overlay.message?.targetId}
                      onPress={() =>
                        handleFocusOverlayConfirm(
                          overlay.message?.targetId,
                          overlay.message?.positive ? "digest_positive" : "digest_negative"
                        )
                      }
                    >
                      <Text
                        style={[
                          styles.focusDigestPrimaryText,
                          { color: overlay.message?.targetId ? colors.background : colors.muted },
                        ]}
                      >
                        {t("focusDigestButton")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </Modal>
        )}
        {overlay?.type === "level" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <View style={styles.overlayFullScreen}>
              <TouchableWithoutFeedback onPress={dismissOverlay}>
                <View style={styles.overlayTouchable} />
              </TouchableWithoutFeedback>
              <LevelUpCelebration
                colors={colors}
                message={overlay.message}
                level={overlay.message}
                t={t}
                onSharePress={handleLevelSharePress}
              />
            </View>
          </Modal>
        )}
        {overlay?.type === "save" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.saveOverlay}>
                <View
                  style={[
                    styles.overlayDim,
                    { backgroundColor: overlayDimColor },
                  ]}
                />
                <CoinRainOverlay dropCount={16} />
                <Animated.View style={[styles.saveCard, saveCardBackgroundStyle]}>
                  <Text style={[styles.saveTitle, { color: colors.text }]}>{t("saveCelebrateTitlePrefix")}</Text>
                  <Text style={[styles.saveGoalText, { color: colors.text }]}>
                    {saveOverlayPayload?.title || ""}
                  </Text>
                  {saveOverlayGoalText ? (
                    <View style={styles.saveGoalBox}>
                      <Text style={[styles.saveGoalText, { color: colors.text }]}>
                        {saveOverlayGoalText}
                      </Text>
                    </View>
                  ) : null}
                  {Boolean(saveOverlayPayload?.coinReward) && (
                    <View
                      style={[
                        styles.saveCoinsRow,
                        {
                          backgroundColor: isDarkTheme
                            ? "rgba(255,255,255,0.08)"
                            : "rgba(33,150,243,0.08)",
                        },
                      ]}
                    >
                      <Image source={HEALTH_COIN_TIERS[0].asset} style={styles.saveCoinIcon} />
                      <Text style={[styles.saveCoinsText, { color: colors.text }]}>
                        {t("saveOverlayCoinReward", { amount: saveOverlayPayload.coinReward })}
                      </Text>
                    </View>
                  )}
                  <Image source={tamagotchiAnimations.happy} style={styles.saveGif} />
                </Animated.View>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "custom_temptation" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.saveOverlay}>
                <View
                  style={[
                    styles.overlayDim,
                    { backgroundColor: overlayDimColor },
                  ]}
                />
                <View
                  style={[
                    styles.customTemptationCard,
                    { backgroundColor: overlayCardBackground, borderColor: overlayBorderColor },
                  ]}
                >
                  <Image source={tamagotchiAnimations.follow} style={styles.customTemptationGif} />
                  <Text style={[styles.customTemptationText, { color: colors.text }]}>
                    {t("customTemptationAdded", { title: overlay.message || "" })}
                  </Text>
                </View>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "reward" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <RewardCelebration
                  colors={colors}
                  message={overlay.message}
                  t={t}
                  mascotHappySource={tamagotchiAnimations.happy}
                />
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "focus_reward" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.focusRewardCard,
                      { backgroundColor: colors.card, borderColor: colors.border },
                    ]}
                  >
                    <View style={styles.focusRewardIconRow}>
                      <Image source={HEALTH_COIN_TIERS[0].asset} style={styles.focusRewardCoin} />
                      <Text style={[styles.focusRewardAmount, { color: colors.text }]}>
                        +{overlay.message?.amount || FOCUS_VICTORY_REWARD}
                      </Text>
                    </View>
                    <Text style={[styles.focusRewardTitle, { color: colors.text }]}>
                      {overlay.message?.title || t("focusRewardTitle")}
                    </Text>
                    <Text style={[styles.focusRewardBody, { color: colors.muted }]}>
                      {overlay.message?.body || ""}
                    </Text>
                    <TouchableOpacity
                      style={[styles.focusRewardButton, { borderColor: colors.text }]}
                      onPress={dismissOverlay}
                    >
                      <Text style={[styles.focusRewardButtonText, { color: colors.text }]}>
                        {t("profileOk") || "–û–∫"}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "health" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <HealthCelebration colors={colors} payload={overlay.message} t={t} language={language} />
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "goal_complete" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <GoalCelebration
                  colors={colors}
                  payload={overlay.message}
                  t={t}
                  mascotHappySource={tamagotchiAnimations.happy}
                />
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}
        {overlay?.type === "impulse_alert" && (
          <Modal visible transparent animationType="fade" statusBarTranslucent>
            <TouchableWithoutFeedback onPress={dismissOverlay}>
              <View style={styles.overlayFullScreen}>
                <View
                  style={[
                    styles.overlayDim,
                    { backgroundColor: overlayDimColor },
                  ]}
                />
                <TouchableWithoutFeedback onPress={() => {}}>
                  <View
                    style={[
                      styles.impulseAlertCard,
                      { backgroundColor: overlayCardBackground, borderColor: overlayBorderColor },
                    ]}
                  >
                    <View
                      style={[
                        styles.impulseAlertGlow,
                        { backgroundColor: isDarkTheme ? "#FFC857" : "#FF8F5A" },
                      ]}
                    />
                    <View style={styles.impulseAlertContent}>
                      <View style={styles.impulseAlertHeader}>
                        <View
                          style={[
                            styles.impulseAlertBadge,
                            { backgroundColor: colors.background, borderColor: colors.border },
                          ]}
                        >
                          <Text style={[styles.impulseAlertBadgeText, { color: colors.muted }]}>
                            {t("impulseAlertBadgeLabel")}
                          </Text>
                        </View>
                        <Text style={styles.impulseAlertEmoji}>‚ö°Ô∏è</Text>
                      </View>
                      <Text style={[styles.impulseAlertTitle, { color: colors.text }]}>
                        {impulseAlertPayload?.title || t("impulseAlertTitle")}
                      </Text>
                      <Text style={[styles.impulseAlertBody, { color: colors.muted }]}>
                        {impulseAlertPayload?.body || ""}
                      </Text>
                      {(impulseAlertPayload?.window || impulseAlertPayload?.amountLabel) && (
                        <View style={styles.impulseAlertStats}>
                          {impulseAlertPayload?.window ? (
                            <View style={styles.impulseAlertStat}>
                              <Text style={[styles.impulseAlertStatLabel, { color: colors.muted }]}>
                                {t("impulseAlertWindowLabel")}
                              </Text>
                              <Text style={[styles.impulseAlertStatValue, { color: colors.text }]}>
                                {impulseAlertPayload.window}
                              </Text>
                            </View>
                          ) : null}
                          {impulseAlertPayload?.amountLabel ? (
                            <View style={styles.impulseAlertStat}>
                              <Text style={[styles.impulseAlertStatLabel, { color: colors.muted }]}>
                                {t("impulseAlertAmountLabel")}
                              </Text>
                              <Text style={[styles.impulseAlertStatValue, { color: colors.text }]}>
                                {impulseAlertPayload.amountLabel}
                              </Text>
                            </View>
                          ) : null}
                        </View>
                      )}
                      {impulseAlertPayload?.moodLine ? (
                        <View
                          style={[
                            styles.impulseAlertMoodCard,
                            {
                              backgroundColor: isDarkTheme
                                ? "rgba(255,255,255,0.08)"
                                : "rgba(17,17,17,0.04)",
                              borderColor: isDarkTheme ? "rgba(255,255,255,0.12)" : "rgba(0,0,0,0.05)",
                            },
                          ]}
                        >
                          <Text style={[styles.impulseAlertMood, { color: colors.text }]}>
                            {impulseAlertPayload.moodLine}
                          </Text>
                        </View>
                      ) : null}
                      <TouchableOpacity
                        style={[styles.impulseAlertButton, { backgroundColor: colors.text }]}
                        onPress={dismissOverlay}
                        activeOpacity={0.9}
                      >
                        <Text style={[styles.impulseAlertButtonText, { color: colors.background }]}>
                          {t("impulseAlertButtonLabel")}
                        </Text>
                        <Text style={[styles.impulseAlertButtonIcon, { color: colors.background }]}>
                          ‚Üí
                        </Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                </TouchableWithoutFeedback>
              </View>
            </TouchableWithoutFeedback>
          </Modal>
        )}

        <Modal
          visible={goalLinkPrompt.visible}
          transparent
          animationType="fade"
          statusBarTranslucent
        >
          <TouchableWithoutFeedback onPress={closeGoalLinkPrompt}>
            <View style={[styles.priceModalBackdrop, modalKeyboardPaddingStyle]}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View style={[styles.goalModalCard, { backgroundColor: colors.card }] }>
                  <Text style={[styles.goalModalTitle, { color: colors.text }]}>
                    {t("goalAssignPromptTitle")}
                  </Text>
                  {goalLinkPrompt.item && (
                    <Text style={[styles.goalModalSubtitle, { color: colors.muted }]}>
                      {t("goalAssignPromptSubtitle", {
                        title: resolveTemptationTitle(
                          goalLinkPrompt.item,
                          language,
                          titleOverrides[goalLinkPrompt.item.id]
                        ),
                      })}
                    </Text>
                  )}
                  <ScrollView style={{ maxHeight: 360 }}>
                    {goalSelectionList.map((goal) => {
                      const active = goalLinkCurrentGoalId === goal.id;
                      const currentLocal = formatCurrency(
                        convertToCurrency(goal.savedUSD || 0, profile.currency || DEFAULT_PROFILE.currency),
                        profile.currency || DEFAULT_PROFILE.currency
                      );
                      const targetLocal = formatCurrency(
                        convertToCurrency(goal.targetUSD || 0, profile.currency || DEFAULT_PROFILE.currency),
                        profile.currency || DEFAULT_PROFILE.currency
                      );
                      return (
                        <TouchableOpacity
                          key={goal.id}
                          style={[
                            styles.goalOptionButton,
                            {
                              borderColor: colors.border,
                              backgroundColor: active ? colors.text : "transparent",
                            },
                          ]}
                          onPress={() => handleGoalLinkSelect(goal.id)}
                        >
                          <Text
                            style={[
                              styles.goalOptionTitle,
                              { color: active ? colors.background : colors.text },
                            ]}
                          >
                            {goal.title}
                          </Text>
                          <Text
                            style={[
                              styles.goalOptionSubtitle,
                              { color: active ? colors.background : colors.muted },
                            ]}
                          >
                            {t("wishlistProgress", { current: currentLocal, target: targetLocal })}
                          </Text>
                        </TouchableOpacity>
                      );
                    })}
                  </ScrollView>
                  {goalLinkPrompt.intent !== "save" && goalLinkPrompt.item && (
                    <TouchableOpacity
                      style={styles.goalPickerReset}
                      onPress={() => {
                        assignTemptationGoal(goalLinkPrompt.item.id, null);
                        closeGoalLinkPrompt();
                      }}
                    >
                      <Text style={[styles.goalPickerResetText, { color: colors.muted }]}>
                        {t("goalAssignClear")}
                      </Text>
                    </TouchableOpacity>
                  )}
                  <TouchableOpacity onPress={closeGoalLinkPrompt}>
                    <Text style={[styles.priceModalCancel, { color: colors.muted }]}>
                      {t("priceEditCancel")}
                    </Text>
                  </TouchableOpacity>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>

        <Modal
          visible={goalTemptationPrompt.visible}
          transparent
          animationType="fade"
          statusBarTranslucent
        >
          <TouchableWithoutFeedback onPress={closeGoalTemptationPrompt}>
            <View style={[styles.priceModalBackdrop, modalKeyboardPaddingStyle]}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View style={[styles.goalModalCard, { backgroundColor: colors.card }] }>
                  <Text style={[styles.goalModalTitle, { color: colors.text }]}>
                    {t("goalAssignTemptationTitle")}
                  </Text>
                  <Text style={[styles.goalModalSubtitle, { color: colors.muted }]}>
                    {t("goalAssignTemptationSubtitle", {
                      goal: goalTemptationPrompt.wish?.title || "",
                    })}
                  </Text>
                  <ScrollView style={{ maxHeight: 360 }}>
                    {temptations.map((template) => {
                      const templateTitle = resolveTemptationTitle(
                        template,
                        language,
                        titleOverrides[template.id]
                      );
                      const assignedGoalId = temptationGoalMap[template.id];
                      const isActive =
                        assignedGoalId && goalTemptationPrompt.wish
                          ? assignedGoalId === goalTemptationPrompt.wish.id
                          : false;
                      const assignedLabel = assignedGoalId
                        ? getWishTitleById(assignedGoalId)
                        : t("goalAssignNone");
                      return (
                        <TouchableOpacity
                          key={template.id}
                          style={[
                            styles.goalOptionButton,
                            {
                              borderColor: colors.border,
                              backgroundColor: isActive ? colors.text : "transparent",
                            },
                          ]}
                          onPress={() => handleGoalTemptationAssign(template.id)}
                        >
                          <Text
                            style={[
                              styles.goalOptionTitle,
                              { color: isActive ? colors.background : colors.text },
                            ]}
                          >
                            {templateTitle}
                          </Text>
                          <Text
                            style={[
                              styles.goalOptionSubtitle,
                              { color: isActive ? colors.background : colors.muted },
                            ]}
                          >
                            {assignedLabel}
                          </Text>
                        </TouchableOpacity>
                      );
                    })}
                  </ScrollView>
                  <TouchableOpacity onPress={closeGoalTemptationPrompt}>
                    <Text style={[styles.priceModalCancel, { color: colors.muted }]}>
                      {t("priceEditCancel")}
                    </Text>
                  </TouchableOpacity>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>

        <Modal
          visible={goalEditorPrompt.visible}
          transparent
          animationType="fade"
          statusBarTranslucent
        >
          <TouchableWithoutFeedback onPress={closeGoalEditorPrompt}>
            <View style={[styles.priceModalBackdrop, modalKeyboardPaddingStyle]}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View style={[styles.priceModalCard, { backgroundColor: colors.card }] }>
                  <Text style={[styles.priceModalTitle, { color: colors.text }]}>
                    {t("goalEditModalTitle")}
                  </Text>
                  <Text style={[styles.priceModalLabel, { color: colors.muted, marginTop: 0 }]}>
                    {t("goalEditNameLabel")}
                  </Text>
                  <TextInput
                    style={[
                      styles.priceModalInput,
                      {
                        borderColor: colors.border,
                        color: colors.text,
                        backgroundColor: colors.card,
                      },
                    ]}
                    value={goalEditorPrompt.name}
                    onChangeText={handleGoalEditorNameChange}
                    placeholder={t("goalEditNameLabel")}
                    placeholderTextColor={colors.muted}
                  />
                  <Text style={[styles.priceModalLabel, { color: colors.muted }]}>
                    {t("goalEditTargetLabel")}
                  </Text>
                  <TextInput
                    style={[
                      styles.priceModalInput,
                      {
                        borderColor: colors.border,
                        color: colors.text,
                        backgroundColor: colors.card,
                      },
                    ]}
                    value={goalEditorPrompt.target}
                    onChangeText={handleGoalEditorTargetChange}
                    placeholder={t("goalEditTargetLabel")}
                    placeholderTextColor={colors.muted}
                    keyboardType="numeric"
                  />
                  <Text style={[styles.priceModalLabel, { color: colors.muted }]}>
                    {t("goalEditEmojiLabel")}
                  </Text>
                  <TextInput
                    style={[
                      styles.priceModalInput,
                      {
                        borderColor: colors.border,
                        color: colors.text,
                        backgroundColor: colors.card,
                      },
                    ]}
                    value={goalEditorPrompt.emoji}
                    onChangeText={handleGoalEditorEmojiChange}
                  placeholder={t("goalEditEmojiLabel")}
                  placeholderTextColor={colors.muted}
                  selectTextOnFocus
                  maxLength={2}
                />
                  <View style={styles.priceModalButtons}>
                    <TouchableOpacity
                      style={[styles.priceModalPrimary, { backgroundColor: colors.text }]}
                      onPress={saveGoalEditorPrompt}
                    >
                      <Text style={[styles.priceModalPrimaryText, { color: colors.background }]}>
                        {t("goalEditSave")}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[styles.priceModalSecondary, { borderColor: colors.border }]}
                      onPress={closeGoalEditorPrompt}
                    >
                      <Text style={[styles.priceModalSecondaryText, { color: colors.muted }]}>
                        {t("goalEditCancel")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>

        <Modal
          visible={goalRenewalPromptVisible}
          transparent
          animationType="fade"
          statusBarTranslucent
        >
          <TouchableWithoutFeedback onPress={handleGoalRenewalLater}>
            <View style={styles.goalRenewalBackdrop}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View
                  style={[
                    styles.goalRenewalCard,
                    { backgroundColor: colors.card, borderColor: colors.border },
                  ]}
                >
                  <Text style={[styles.goalRenewalTitle, { color: colors.text }]}>
                    {t("goalRenewalTitle")}
                  </Text>
                  <Text style={[styles.goalRenewalSubtitle, { color: colors.muted }]}>
                    {t("goalRenewalSubtitle")}
                  </Text>
                  <View style={styles.goalRenewalActions}>
                    <TouchableOpacity
                      style={[styles.goalRenewalSecondary, { borderColor: colors.border }]}
                      onPress={handleGoalRenewalLater}
                    >
                      <Text style={[styles.goalRenewalSecondaryText, { color: colors.muted }]}>
                        {t("goalRenewalLater")}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[styles.goalRenewalPrimary, { backgroundColor: colors.text }]}
                      onPress={handleGoalRenewalStart}
                    >
                      <Text style={[styles.goalRenewalPrimaryText, { color: colors.background }]}>
                        {t("goalRenewalCreate")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>

        <ImageSourceSheet
          visible={showImageSourceSheet}
          colors={colors}
          t={t}
          onClose={closeImagePickerSheet}
          onSelect={handleImageSourceChoice}
        />
        <SpendConfirmSheet
          visible={spendPrompt.visible}
          item={spendPrompt.item}
          currency={profile.currency || DEFAULT_PROFILE.currency}
          language={language}
          onCancel={closeSpendPrompt}
          onConfirm={handleSpendConfirm}
          colors={colors}
          t={t}
        />
        {stormActive && <StormOverlay t={t} />}
      </SafeAreaView>
        </View>
      </TouchableWithoutFeedback>
    </SavingsProvider>
  );
}

function App() {
  return (
    <SafeAreaProvider>
      <AppContent />
    </SafeAreaProvider>
  );
}

export default Sentry.wrap(App);

const StatusGlass = React.memo(({ height, colors, theme, blurAvailable = false }) => {
  const gradientId = useMemo(() => `status-glass-${Math.random().toString(36).slice(2, 10)}`, []);
  const baseColor = colors?.background || "#fff";
  const tintedBase = blendColors(baseColor, "#ffffff", theme === "dark" ? 0.2 : 0.45);
  const highlight = colorWithAlpha("#ffffff", theme === "dark" ? 0.2 : 0.32);
  const softCore = colorWithAlpha(tintedBase, theme === "dark" ? 0.28 : 0.38);
  const fadeOut = colorWithAlpha(baseColor, 0);
  const borderColor = colorWithAlpha(colors?.border || tintedBase, theme === "dark" ? 0.35 : 0.18);
  const borderPosition = Math.max(0, height - 26);
  const overlay = (
    <Svg style={StyleSheet.absoluteFill} pointerEvents="none">
      <Defs>
        <SvgLinearGradient id={gradientId} x1="0" y1="0" x2="0" y2="1">
          <SvgStop offset="0%" stopColor={highlight} />
          <SvgStop offset="55%" stopColor={softCore} />
          <SvgStop offset="100%" stopColor={fadeOut} />
        </SvgLinearGradient>
      </Defs>
      <SvgRect x="0" y="0" width="100%" height="100%" fill={`url(#${gradientId})`} />
    </Svg>
  );
  const border = <View style={[styles.statusGlassBorder, { borderColor, top: borderPosition }]} />;
  if (blurAvailable) {
    return (
      <View pointerEvents="none" style={[styles.statusGlass, { height }]}>
        <BlurView tint={theme === "dark" ? "dark" : "extraLight"} intensity={35} style={StyleSheet.absoluteFill} />
        {overlay}
        {border}
      </View>
    );
  }
  return (
    <View pointerEvents="none" style={[styles.statusGlass, { height }]}>
      {overlay}
      {border}
    </View>
  );
});

const TYPOGRAPHY = {
  logo: {
    fontFamily: INTER_FONTS.extraBold,
    fontSize: scaleFontSize(44),
    letterSpacing: scaleLetterSpacing(-0.5),
  },
  display: {
    fontFamily: INTER_FONTS.bold,
    fontSize: scaleFontSize(34),
    letterSpacing: scaleLetterSpacing(-0.2),
  },
  blockTitle: {
    fontFamily: INTER_FONTS.bold,
    fontSize: scaleFontSize(24),
    letterSpacing: scaleLetterSpacing(-0.2),
  },
  body: {
    fontFamily: INTER_FONTS.regular,
    fontSize: scaleFontSize(15),
    lineHeight: scaleFontSize(20),
  },
  secondary: {
    fontFamily: INTER_FONTS.light,
    fontSize: scaleFontSize(12),
    lineHeight: scaleFontSize(16),
  },
  cta: {
    fontFamily: INTER_FONTS.semiBold,
    fontSize: scaleFontSize(14),
    letterSpacing: scaleLetterSpacing(CTA_LETTER_SPACING),
  },
};

const createBodyText = (overrides = {}) => ({ ...TYPOGRAPHY.body, ...scaleTypographyOverrides(overrides) });
const createSecondaryText = (overrides = {}) => ({
  ...TYPOGRAPHY.secondary,
  ...scaleTypographyOverrides(overrides),
});
const createCtaText = (overrides = {}) => ({ ...TYPOGRAPHY.cta, ...scaleTypographyOverrides(overrides) });

const styles = StyleSheet.create({
  appBackground: {
    flex: 1,
  },
  appShell: {
    flex: 1,
  },
  screenWrapper: {
    flex: 1,
  },
  statusGlass: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    overflow: "hidden",
    zIndex: 10,
  },
  statusGlassBorder: {
    position: "absolute",
    left: 0,
    right: 0,
    borderBottomWidth: StyleSheet.hairlineWidth,
  },
  container: {
    flex: 1,
    paddingHorizontal: BASE_HORIZONTAL_PADDING,
    paddingTop: 24,
    position: "relative",
  },
  feedList: {
    marginHorizontal: -BASE_HORIZONTAL_PADDING,
    overflow: "visible",
  },
  feedListContent: {
    paddingTop: 4,
    paddingBottom: 160,
    paddingHorizontal: BASE_HORIZONTAL_PADDING,
  },
  feedHero: {
    paddingBottom: 12,
  },
  feedHeroTop: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-start",
  },
  moodGradientBlock: {
    position: "relative",
    overflow: "hidden",
  },
  moodGradientOverlay: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.55,
    transform: [{ rotate: "-10deg" }],
  },
  heroMoodGradient: {
    flex: 1,
    width: "100%",
    borderRadius: 28,
    padding: 18,
    paddingBottom: 20,
    position: "relative",
    overflow: "hidden",
  },
  moodBadge: {
    alignSelf: "flex-start",
    paddingHorizontal: 14,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "rgba(255,255,255,0.85)",
    marginTop: 16,
  },
  moodBadgeText: {
    ...createCtaText({ fontSize: 13, textTransform: "uppercase" }),
  },
  moodDetailsBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.5)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  moodDetailsCard: {
    width: "100%",
    borderRadius: 32,
    padding: 24,
    alignItems: "center",
    gap: 12,
  },
  moodDetailsLabel: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 20,
    textAlign: "center",
  },
  moodDetailsDescription: {
    ...createBodyText({ fontSize: 16, textAlign: "center", lineHeight: 22 }),
  },
  moodDetailsButton: {
    marginTop: 12,
    paddingHorizontal: 24,
    paddingVertical: 10,
    borderRadius: 999,
    borderWidth: 1,
  },
  moodDetailsButtonText: {
    ...createCtaText({ textTransform: "uppercase" }),
  },
  heroMascotRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  heroMascotContainer: {
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
  },
  heroTextWrap: {
    flex: 1,
    paddingRight: 6,
  },
  appName: {
    ...TYPOGRAPHY.logo,
  },
  heroTagline: {
    ...TYPOGRAPHY.body,
    marginTop: 4,
  },
  almiMascotWrap: {
    width: 96,
    height: 96,
    borderRadius: 28,
    backgroundColor: "rgba(255,255,255,0.75)",
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden",
    borderWidth: 1,
    borderColor: "rgba(255,255,255,0.5)",
  },
  almiMascotImage: {
    width: "120%",
    height: "120%",
  },
  mascotBubble: {
    position: "absolute",
    top: -28,
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 18,
    borderWidth: 1,
    marginBottom: 0,
    maxWidth: 180,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.25,
    shadowRadius: 10,
    elevation: 4,
  },
  mascotBubbleText: {
    ...createBodyText({ fontSize: 13, textAlign: "center" }),
    fontWeight: "600",
  },
  mascotBubbleTail: {
    position: "absolute",
    bottom: -6,
    width: 12,
    height: 12,
    transform: [{ rotate: "45deg" }],
    borderRadius: 2,
  },
  skinPickerButton: {
    position: "absolute",
    top: 8,
    right: 8,
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 14,
    borderWidth: 1,
    shadowColor: "rgba(0,0,0,0.25)",
    shadowOpacity: 0.25,
    shadowOffset: { width: 0, height: 2 },
    shadowRadius: 4,
    elevation: 3,
  },
  skinPickerIcon: {
    fontSize: 16,
  },
  skinPickerBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.55)",
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 20,
    paddingVertical: 20,
  },
  skinPickerCard: {
    width: "100%",
    maxWidth: 380,
    borderRadius: 28,
    paddingVertical: 16,
    paddingHorizontal: 18,
    borderWidth: 1,
    gap: 8,
  },
  skinPickerTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 20,
  },
  skinPickerSubtitle: {
    ...createBodyText({ fontSize: 15 }),
  },
  skinPickerList: {
    paddingVertical: 6,
    paddingHorizontal: 4,
  },
  skinUnlockCard: {
    borderWidth: 1,
    borderRadius: 20,
    padding: 16,
    marginBottom: 16,
    gap: 10,
  },
  skinUnlockTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 17,
  },
  skinUnlockSubtitle: {
    ...createBodyText({ fontSize: 14 }),
  },
  skinUnlockButton: {
    borderRadius: 999,
    paddingVertical: 12,
    paddingHorizontal: 16,
    alignItems: "center",
  },
  skinUnlockButtonText: {
    ...createCtaText({ fontSize: 14, textTransform: "none" }),
  },
  skinPickerItem: {
    flexDirection: "row",
    alignItems: "center",
    borderWidth: 1,
    borderRadius: 18,
    padding: 12,
    gap: 12,
    marginBottom: 12,
  },
  skinPickerAvatar: {
    width: 56,
    height: 56,
    borderRadius: 18,
  },
  skinPickerItemTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 16,
  },
  skinPickerItemSubtitle: {
    ...createBodyText({ fontSize: 13 }),
  },
  skinPickerBadge: {
    borderWidth: 1,
    borderRadius: 999,
    paddingHorizontal: 10,
    paddingVertical: 4,
  },
  skinPickerBadgeText: {
    ...createCtaText({ fontSize: 10, textTransform: "uppercase" }),
  },
  skinPickerLockedBadge: {
    opacity: 0.85,
  },
  skinPickerLockedBadgeText: {
    letterSpacing: 0.5,
  },
  tamagotchiBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.55)",
    justifyContent: "center",
    alignItems: "center",
    padding: 20,
  },
  partyGlowOverlay: {
    ...StyleSheet.absoluteFillObject,
  },
  partyFireworksOverlay: {
    ...StyleSheet.absoluteFillObject,
  },
  partyFireworkRing: {
    position: "absolute",
    borderWidth: 2,
    opacity: 0,
  },
  tamagotchiCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 24,
    padding: 20,
    borderWidth: 1,
    gap: 10,
  },
  tamagotchiHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  tamagotchiTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 18,
  },
  tamagotchiMood: {
    ...createBodyText({ fontSize: 14 }),
  },
  tamagotchiStatRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  tamagotchiStatLabel: {
    ...createBodyText({ fontSize: 14 }),
  },
  tamagotchiStatValue: {
    ...createBodyText({ fontSize: 16, fontWeight: "700" }),
  },
  tamagotchiProgress: {
    height: 12,
    borderRadius: 999,
    overflow: "hidden",
  },
  tamagotchiProgressFill: {
    height: "100%",
    borderRadius: 999,
  },
  tamagotchiActions: {
    flexDirection: "row",
    gap: 10,
    marginTop: 6,
  },
  tamagotchiButton: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: 14,
    borderWidth: 1,
    alignItems: "center",
  },
  tamagotchiButtonContent: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  tamagotchiButtonIcon: {
    width: 20,
    height: 20,
  },
  tamagotchiPreview: {
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 6,
  },
  tamagotchiButtonText: {
    ...createCtaText({ fontSize: 14 }),
  },
  tamagotchiFoodTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 16,
    marginTop: 12,
  },
  tamagotchiFoodList: {
    marginTop: 6,
  },
  tamagotchiFoodButton: {
    flexDirection: "row",
    alignItems: "center",
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 12,
    paddingHorizontal: 14,
    gap: 12,
    position: "relative",
    marginBottom: 10,
  },
  tamagotchiFoodButtonLast: {
    marginBottom: 0,
  },
  tamagotchiFoodButtonDisabled: {
    opacity: 0.5,
  },
  tamagotchiFoodEmoji: {
    fontSize: 28,
  },
  tamagotchiFoodInfo: {
    flex: 1,
    gap: 2,
  },
  tamagotchiFoodLabel: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 15,
  },
  tamagotchiFoodBoost: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  tamagotchiFoodCost: {
    flexDirection: "row",
    alignItems: "center",
    gap: 4,
  },
  tamagotchiFoodCostIcon: {
    width: 18,
    height: 18,
  },
  tamagotchiFoodCostText: {
    ...createCtaText({ fontSize: 13 }),
  },
  tamagotchiFoodBadge: {
    position: "absolute",
    top: -10,
    right: 12,
    borderRadius: 999,
    paddingHorizontal: 8,
    paddingVertical: 3,
  },
  tamagotchiFoodBadgeText: {
    ...createCtaText({ fontSize: 10, textTransform: "uppercase" }),
    letterSpacing: 0.6,
  },
  tamagotchiSub: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  tamagotchiHint: {
    ...createSecondaryText({ fontSize: 12, textAlign: "center" }),
    marginTop: 4,
  },
  tamagotchiClose: {
    alignSelf: "center",
    marginTop: 6,
    paddingVertical: 6,
    paddingHorizontal: 12,
  },
  tamagotchiCloseText: {
    ...createCtaText({ fontSize: 14 }),
  },
  heroStatCard: {
    padding: 16,
    borderRadius: 24,
    marginTop: 18,
  },
  heroStatRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  heroStatLabel: {
    textTransform: "uppercase",
    fontSize: 12,
  },
  heroStatValue: {
    fontSize: 24,
    fontWeight: "700",
  },
  heroSpendLine: {
    fontSize: Platform.OS === "ios" ? 16 : 18,
    lineHeight: Platform.OS === "ios" ? 20 : 22,
    fontWeight: "600",
    marginTop: Platform.OS === "ios" ? 6 : 10,
  },
  progressHeroCard: {
    marginTop: 8,
    borderRadius: 24,
    padding: 18,
    borderWidth: 1,
  },
  savedHeroCard: {
    marginTop: 12,
    padding: 18,
    borderRadius: 26,
    shadowOpacity: 0.18,
    shadowRadius: 20,
    shadowOffset: { width: 0, height: 8 },
    elevation: 8,
    overflow: "hidden",
    position: "relative",
  },
  savedHeroGlowWrap: {
    ...StyleSheet.absoluteFillObject,
    zIndex: 0,
  },
  savedHeroGlow: {
    position: "absolute",
    width: 140,
    height: 140,
    borderRadius: 70,
    top: -40,
    right: -30,
    opacity: 0.6,
    zIndex: -1,
  },
  savedHeroGlowBottom: {
    width: 120,
    height: 120,
    bottom: -30,
    left: -10,
    zIndex: -1,
  },
  savedHeroContent: {
    position: "relative",
    zIndex: 1,
  },
  savedHeroHeader: {
    marginBottom: 0,
    flexDirection: "row",
    alignItems: "flex-start",
    justifyContent: "space-between",
    gap: 12,
    position: "relative",
    paddingRight: 48,
  },
  savedHeroSubtitle: {
    ...createBodyText({
      fontSize: Platform.OS === "ios" ? 13 : 15,
      marginTop: Platform.OS === "ios" ? 4 : 6,
      marginBottom: 8,
      lineHeight: Platform.OS === "ios" ? 18 : 20,
      width: "100%",
    }),
  },
  savedHeroRecentList: {
    width: "100%",
    alignSelf: "stretch",
    marginTop: 0,
    gap: Platform.OS === "ios" ? 4 : 6,
    marginBottom: 14,
  },
  savedHeroRecentTitle: {
    ...createCtaText({ fontSize: 11 }),
  },
  savedHeroRecentItem: {
    ...createBodyText({
      fontSize: Platform.OS === "ios" ? 11 : 12,
      lineHeight: Platform.OS === "ios" ? 15 : 17,
    }),
    width: "100%",
    flexShrink: 1,
  },
  savedHeroLevelButton: {
    paddingHorizontal: 6,
    paddingVertical: 6,
  },
  savedHeroLevelButtonFloating: {
    position: "absolute",
    top: -8,
    right: -8,
  },
  savedHeroLevelBadge: {
    borderRadius: 999,
    paddingHorizontal: 14,
    paddingVertical: 6,
    borderWidth: 1,
  },
  savedHeroLevelText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  savedHeroAmountWrap: {
    marginTop: 2,
    marginBottom: 4,
  },
  heroLevelDetails: {
    borderRadius: 16,
    borderWidth: 1,
    padding: 12,
    marginBottom: 10,
  },
  heroLevelTitle: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  heroLevelSubtitle: {
    ...createBodyText({ fontSize: 12, marginTop: 6 }),
  },
  heroLevelMeta: {
    ...createSecondaryText({ marginTop: 8 }),
  },
  heroPotentialCard: {
    marginBottom: 12,
    borderRadius: 18,
    padding: 14,
    gap: 8,
  },
  heroPotentialHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  heroPotentialLabel: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  heroPotentialValue: {
    ...createBodyText({ fontSize: 16, fontWeight: "700" }),
  },
  heroPotentialHint: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  heroPotentialStatus: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  heroPotentialButton: {
    borderWidth: 1,
    borderRadius: 999,
    paddingVertical: 8,
    alignItems: "center",
  },
  heroPotentialButtonText: {
    ...createCtaText(),
  },
  savedHeroProgressRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    marginBottom: 10,
  },
  savedHeroBar: {
    flex: 1,
    marginBottom: 0,
  },
  savedHeroPercentTag: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
  },
  savedHeroPercentText: {
    ...createCtaText({ fontSize: 12 }),
  },
  savedHeroGoalRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
  },
  goalLabel: {
    ...createCtaText({ fontSize: 12 }),
  },
  savedHeroGoalMetaRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
    marginTop: 2,
  },
  savedHeroGoalLabel: {
    ...createBodyText({ fontSize: 13, flex: 1 }),
  },
  goalCompleteBadge: {
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 12,
    paddingVertical: 4,
  },
  goalCompleteBadgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  goalSelectButton: {
    marginTop: 10,
    paddingVertical: 10,
    paddingHorizontal: 14,
    borderRadius: 14,
    borderWidth: 1,
    alignItems: "center",
  },
  goalSelectText: {
    ...createCtaText({ fontSize: 13 }),
  },
  breakdownOverlay: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.45)",
    justifyContent: "center",
    alignItems: "center",
    padding: 16,
  },
  dailySummaryBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.6)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  dailySummaryCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 28,
    padding: 24,
    borderWidth: 1,
    overflow: "hidden",
  },
  dailySummaryGlow: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.12,
  },
  dailySummaryCardContent: {
    gap: 18,
  },
  dailySummaryHeroRow: {
    flexDirection: "row",
    gap: 12,
  },
  dailySummaryHeroText: {
    flex: 1,
  },
  dailySummaryIconWrap: {
    width: 56,
    height: 56,
    borderRadius: 18,
    alignItems: "center",
    justifyContent: "center",
    borderWidth: 1,
  },
  dailySummaryIconText: {
    fontSize: 28,
  },
  dailySummaryBadge: {
    alignSelf: "flex-start",
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 999,
    borderWidth: 1,
    marginBottom: 6,
  },
  dailySummaryBadgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  dailySummaryTitle: {
    ...TYPOGRAPHY.blockTitle,
  },
  dailySummarySubtitle: {
    ...createBodyText({ fontSize: 16, marginTop: 4 }),
  },
  dailySummaryHighlight: {
    borderRadius: 22,
    padding: 18,
    borderWidth: 1,
  },
  dailySummaryHighlightLabel: {
    ...createCtaText({ fontSize: 13, textTransform: "uppercase" }),
  },
  dailySummaryHighlightValue: {
    fontSize: 32,
    fontWeight: "800",
    marginTop: 8,
  },
  dailySummaryHighlightSub: {
    ...createBodyText({ fontSize: 14, marginTop: 6 }),
  },
  dailySummaryStatsRow: {
    flexDirection: "row",
    gap: 12,
  },
  dailySummaryStatCard: {
    flex: 1,
    borderRadius: 20,
    paddingVertical: 16,
    borderWidth: 1,
    alignItems: "center",
  },
  dailySummaryStatValue: {
    fontSize: 26,
    fontWeight: "800",
  },
  dailySummaryStatLabel: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase", marginTop: 8 }),
  },
  dailySummaryButton: {
    borderRadius: 18,
    paddingVertical: 14,
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "row",
    gap: 8,
  },
  dailySummaryButtonText: {
    ...createCtaText({ fontSize: 15 }),
  },
  dailySummaryButtonIcon: {
    ...createCtaText({ fontSize: 16 }),
  },
  dailySummaryHint: {
    ...createSecondaryText({ textAlign: "center" }),
  },
  ratingPromptBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.5)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  ratingPromptCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 26,
    padding: 24,
    gap: 16,
    borderWidth: 1,
  },
  ratingPromptTitle: {
    ...TYPOGRAPHY.blockTitle,
    textAlign: "center",
  },
  ratingPromptBody: {
    ...createBodyText({ fontSize: 15, textAlign: "center" }),
  },
  ratingPromptActions: {
    flexDirection: "row",
    gap: 12,
  },
  ratingPromptSecondary: {
    flex: 1,
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
    borderWidth: 1,
  },
  ratingPromptSecondaryText: {
    ...createCtaText({ fontSize: 15 }),
  },
  ratingPromptPrimary: {
    flex: 1,
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
  },
  ratingPromptPrimaryText: {
    ...createCtaText({ fontSize: 15 }),
  },
  levelShareModalCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 28,
    padding: 22,
    borderWidth: 1,
    gap: 12,
  },
  levelShareModalTitle: {
    ...TYPOGRAPHY.blockTitle,
    textAlign: "center",
  },
  levelShareModalCaption: {
    ...createSecondaryText({ textAlign: "center" }),
  },
  levelShareShot: {
    width: "100%",
    borderRadius: 28,
    overflow: "hidden",
  },
  levelShareCanvas: {
    backgroundColor: LEVEL_SHARE_BG,
    borderRadius: 24,
    paddingVertical: 26,
    paddingHorizontal: 20,
    alignItems: "center",
    gap: 12,
  },
  levelShareBadge: {
    borderRadius: 999,
    paddingHorizontal: 18,
    paddingVertical: 6,
    backgroundColor: LEVEL_SHARE_ACCENT,
  },
  levelShareBadgeText: {
    color: "#1E0F00",
    fontWeight: "800",
    fontSize: 12,
    letterSpacing: 1,
  },
  levelShareCanvasTitle: {
    color: "#FFFFFF",
    fontSize: 32,
    fontWeight: "900",
    textTransform: "uppercase",
  },
  levelShareCanvasSubtitle: {
    color: LEVEL_SHARE_MUTED,
    fontSize: 15,
    textAlign: "center",
  },
  levelShareCat: {
    width: 180,
    height: 180,
    resizeMode: "contain",
  },
  levelShareJoin: {
    color: "#FFFFFF",
    fontSize: 16,
    fontWeight: "700",
    textAlign: "center",
  },
  levelShareFooter: {
    marginTop: 12,
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  levelShareLogo: {
    width: 48,
    height: 48,
    borderRadius: 16,
  },
  levelShareFooterBrand: {
    color: "#FFFFFF",
    fontSize: 18,
    fontWeight: "800",
  },
  levelShareFooterHint: {
    color: LEVEL_SHARE_MUTED,
    fontSize: 12,
    textTransform: "uppercase",
  },
  levelShareActions: {
    gap: 10,
  },
  levelSharePrimary: {
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
  },
  levelSharePrimaryText: {
    ...createCtaText({ fontSize: 15 }),
  },
  levelShareGhost: {
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
    borderWidth: 1,
  },
  levelShareGhostText: {
    ...createCtaText({ fontSize: 15 }),
  },
  dailyChallengeCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 30,
    padding: 24,
    borderWidth: 1,
    overflow: "hidden",
  },
  dailyChallengeGlow: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.25,
  },
  dailyChallengeContent: {
    gap: 20,
  },
  dailyChallengeHeroRow: {
    flexDirection: "row",
    gap: 16,
  },
  dailyChallengeBadge: {
    alignSelf: "flex-start",
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 999,
    borderWidth: 1,
  },
  dailyChallengeBadgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  dailyChallengeTitle: {
    ...TYPOGRAPHY.blockTitle,
  },
  dailyChallengeSubtitle: {
    ...createBodyText({ fontSize: 15, marginTop: 4 }),
  },
  dailyChallengeRewardStack: {
    alignItems: "flex-end",
    gap: 6,
  },
  dailyChallengeRewardHint: {
    ...createBodyText({ fontSize: 13 }),
    fontWeight: "700",
  },
  dailyChallengeTemptationRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    borderWidth: 1,
    borderRadius: 24,
    padding: 14,
    backgroundColor: "rgba(17,17,17,0.03)",
  },
  dailyChallengeEmojiCard: {
    width: 58,
    height: 58,
    borderRadius: 18,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "rgba(17,17,17,0.05)",
  },
  dailyChallengeEmojiCardText: {
    fontSize: 32,
  },
  dailyChallengeTemptationTitle: {
    fontSize: 16,
    fontWeight: "700",
  },
  dailyChallengeTemptationHint: {
    ...createBodyText({ fontSize: 14 }),
  },
  dailyChallengeActions: {
    flexDirection: "row",
    gap: 12,
  },
  dailyChallengePrimaryButton: {
    flex: 1,
    borderRadius: 18,
    paddingVertical: 14,
    alignItems: "center",
  },
  dailyChallengePrimaryText: {
    ...createCtaText({ fontSize: 15 }),
  },
  dailyChallengeGhostButton: {
    flex: 1,
    borderRadius: 18,
    paddingVertical: 14,
    alignItems: "center",
    borderWidth: 1,
  },
  dailyChallengeGhostText: {
    ...createCtaText({ fontSize: 15 }),
  },
  breakdownCard: {
    width: "100%",
    maxWidth: 420,
    borderRadius: 20,
    padding: 16,
    borderWidth: 1,
  },
  breakdownHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 12,
  },
  breakdownTitle: {
    fontSize: 18,
    fontWeight: "800",
  },
  breakdownClose: {
    fontSize: 18,
    fontWeight: "700",
  },
  breakdownBars: {
    flexDirection: "row",
    justifyContent: "space-between",
    gap: 10,
    marginBottom: 16,
  },
  breakdownBarItem: {
    flex: 1,
    alignItems: "center",
    gap: 6,
  },
  breakdownBarTrack: {
    width: "100%",
    height: 140,
    borderRadius: 10,
    overflow: "hidden",
    justifyContent: "flex-end",
  },
  breakdownBarStack: {
    width: "100%",
  },
  breakdownBarLabel: {
    fontSize: 12,
    fontWeight: "700",
  },
  breakdownBarAmount: {
    fontSize: 11,
    fontWeight: "600",
    textAlign: "center",
  },
  breakdownAmountWrapper: {
    width: "100%",
    paddingHorizontal: 4,
  },
  breakdownLegend: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  breakdownLegendItem: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 12,
    borderWidth: 1,
  },
  breakdownLegendDot: {
    width: 10,
    height: 10,
    borderRadius: 5,
  },
  breakdownLegendText: {
    fontSize: 12,
    fontWeight: "700",
  },
  savedHeroToggleButton: {
    paddingVertical: 4,
    paddingHorizontal: 8,
  },
  savedHeroToggleText: {
    fontSize: 12,
    fontWeight: "600",
    textAlign: "right",
  },
  savedHeroDaily: {
    marginTop: 12,
    gap: 12,
  },
  savedHeroExpanded: {
    marginTop: 12,
    gap: 16,
  },
  savedHeroCoinsCard: {
    flexDirection: "row",
    alignItems: "center",
    gap: 14,
    borderRadius: 18,
    borderWidth: 1,
    padding: 14,
  },
  savedHeroCoinsText: {
    flex: 1,
    gap: 4,
  },
  savedHeroCoinsLabel: {
    fontSize: 14,
    fontWeight: "800",
  },
  savedHeroCoinsSubtitle: {
    fontSize: 12,
    fontWeight: "600",
  },
  savedHeroCoinsValue: {
    fontSize: 24,
    fontWeight: "900",
  },
  savedHeroDailyTitle: {
    fontSize: 14,
    fontWeight: "700",
  },
  savedHeroBars: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-end",
    gap: 8,
  },
  savedHeroBarItem: {
    flex: 1,
    alignItems: "center",
    gap: 4,
  },
  savedHeroBarAmountWrap: {
    minHeight: 28,
    justifyContent: "flex-end",
    alignItems: "center",
    gap: 2,
    paddingHorizontal: 2,
  },
  savedHeroBarAmountBlock: {
    alignItems: "center",
    maxWidth: 60,
    width: "100%",
  },
  savedHeroBarAmount: {
    fontSize: 9,
    textAlign: "center",
    lineHeight: 11,
    fontWeight: "600",
  },
  savedHeroBarSpend: {
    fontSize: 8,
    textAlign: "center",
    lineHeight: 10,
    fontWeight: "600",
  },
  savedHeroBarCurrency: {
    fontSize: 8,
    fontWeight: "600",
  },
  savedHeroBarTrack: {
    width: 20,
    height: 70,
    borderRadius: 10,
    backgroundColor: "rgba(255,255,255,0.4)",
    justifyContent: "flex-end",
    overflow: "hidden",
    position: "relative",
  },
  savedHeroBarColumn: {
    width: "100%",
    borderRadius: 10,
  },
  savedHeroBarColumnSpend: {
    position: "absolute",
    left: 0,
    bottom: 0,
    width: "100%",
    borderRadius: 10,
  },
  savedHeroBarLabel: {
    fontSize: 11,
    fontWeight: "600",
  },
  savedHeroDailyEmpty: {
    fontSize: 12,
  },
  weeklyTrendRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 12,
    marginTop: 6,
    marginBottom: 2,
  },
  weeklyTrendItem: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  weeklyTrendLabel: {
    ...createSecondaryText({ fontSize: 11 }),
  },
  weeklyTrendValue: {
    ...createSecondaryText({ fontSize: 11 }),
    fontWeight: "700",
  },
  progressHeroHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 12,
  },
  progressHeroTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: Platform.OS === "ios" ? 22 : 24,
    lineHeight: Platform.OS === "ios" ? 26 : undefined,
    fontFamily: INTER_FONTS.extraBold,
    marginRight: Platform.OS === "ios" ? 8 : 0,
  },
  progressHeroAmount: {
    fontSize: 26,
    fontWeight: "900",
    fontFamily: INTER_FONTS.extraBold,
    marginBottom: 6,
  },
  progressHeroLevel: {
    fontSize: 14,
    fontWeight: "600",
  },
  progressHeroBar: {
    height: 10,
    borderRadius: 999,
    overflow: "hidden",
    marginBottom: 8,
  },
  progressHeroFill: {
    height: "100%",
    borderRadius: 999,
  },
  progressHeroNext: {
    fontSize: 13,
    fontWeight: "500",
  },
  savedHeroStatsRow: {
    flexDirection: "row",
    gap: 10,
    marginTop: 14,
  },
  savedHeroStatsItem: {
    flex: 1,
    borderRadius: 18,
    borderWidth: 1,
    paddingVertical: 12,
    paddingHorizontal: 12,
  },
  savedHeroStatsValue: {
    fontSize: 18,
    fontWeight: "800",
  },
  savedHeroStatsLabel: {
    fontSize: 12,
    marginTop: 4,
  },
  categoryChip: {
    marginRight: 12,
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 18,
    borderWidth: 1,
  },
  categoryChipText: {
    fontSize: 12,
    textTransform: "uppercase",
  },
  payBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.5)",
    justifyContent: "flex-end",
  },
  payBackdropHit: {
    flex: 1,
  },
  paySheet: {
    borderTopLeftRadius: 28,
    borderTopRightRadius: 28,
    padding: 24,
    gap: 16,
  },
  paySheetHandle: {
    width: 60,
    height: 4,
    borderRadius: 2,
    backgroundColor: "rgba(255,255,255,0.3)",
    alignSelf: "center",
    marginBottom: 4,
  },
  payBrand: {
    fontSize: 18,
    fontWeight: "700",
    textAlign: "center",
  },
  payCard: {
    flexDirection: "row",
    alignItems: "center",
    borderRadius: 18,
    padding: 16,
    gap: 12,
  },
  payCardIcon: {
    width: 48,
    height: 48,
    borderRadius: 14,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "rgba(0,0,0,0.05)",
  },
  payCardEmoji: {
    fontSize: 26,
  },
  payCardTexts: {
    flex: 1,
  },
  payCardTitle: {
    fontSize: 16,
    fontWeight: "600",
  },
  payCardAmount: {
    fontSize: 18,
    fontWeight: "700",
  },
  paySheetSubtitle: {
    fontSize: 14,
    textAlign: "center",
  },
  paySheetHintRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    justifyContent: "center",
  },
  paySheetHintDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
    backgroundColor: "#FFD93D",
  },
  paySheetHint: {
    fontSize: 12,
    textAlign: "center",
  },
  payConfirm: {
    borderRadius: 999,
    paddingVertical: 12,
    alignItems: "center",
  },
  payConfirmText: {
    fontSize: 15,
    fontWeight: "700",
  },
  payCancel: {
    paddingVertical: 8,
    alignItems: "center",
  },
  payCancelText: {
    fontSize: 14,
    fontWeight: "600",
  },
  freeDayCard: {
    marginTop: 12,
    padding: 18,
    borderRadius: 24,
    borderWidth: 1,
    gap: 12,
    position: "relative",
  },
  freeDayHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    flexWrap: "wrap",
    gap: 12,
  },
  freeDayTitleBlock: {
    flex: 1,
  },
  freeDayLabel: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 18,
    letterSpacing: -0.3,
  },
  freeDayStatsRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 6,
  },
  freeDayStat: {
    flex: 1,
    alignItems: "center",
  },
  freeDayStatLabel: {
    ...createSecondaryText({ marginBottom: 2, textAlign: "center" }),
  },
  freeDayStatValue: {
    ...createBodyText({ fontSize: 16, fontWeight: "700", textAlign: "center" }),
  },
  freeDaySummaryRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginTop: 4,
    flexWrap: "wrap",
    gap: 8,
  },
  freeDayChip: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 999,
    backgroundColor: "rgba(0,0,0,0.05)",
    alignItems: "center",
    flexDirection: "row",
    flexShrink: 1,
  },
  freeDayChipText: {
    ...createCtaText({ fontSize: 12, textAlign: "center" }),
  },
  freeDayToggle: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    alignItems: "center",
  },
  freeDayToggleText: {
    ...createCtaText({ fontSize: 12, textAlign: "center" }),
  },
  freeDayStatusPill: {
    borderRadius: 999,
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderWidth: 1,
    alignSelf: "flex-start",
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "row",
  },
  freeDayStatusText: {
    ...createCtaText({ fontSize: 12, textAlign: "center" }),
  },
  freeDayStatusPillDisabled: {
    opacity: 0.5,
  },
  freeDayStatusCoin: {
    width: 18,
    height: 18,
    marginLeft: 6,
    resizeMode: "contain",
  },
  freeDayHealthBadge: {
    display: "none",
  },
  freeDayRescueBanner: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    borderRadius: 16,
    borderWidth: 1,
    paddingHorizontal: 14,
    paddingVertical: 10,
    gap: 12,
  },
  freeDayRescueTitle: {
    ...createBodyText({ fontSize: 15, marginBottom: 2 }),
  },
  freeDayRescueSubtitle: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  freeDayRescueButton: {
    borderRadius: 999,
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  freeDayRescueButtonText: {
    ...createCtaText({ fontSize: 13, color: "#fff", textAlign: "center" }),
  },
  freeDayRescueButtonDisabled: {
    backgroundColor: "rgba(0,0,0,0.05)",
    borderWidth: 1,
    borderColor: "rgba(0,0,0,0.08)",
  },
  impulseCard: {
    marginTop: 12,
    padding: 16,
    borderRadius: 20,
    borderWidth: 1,
    gap: 12,
  },
  impulseHeaderRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-start",
    gap: 8,
  },
  impulseHeader: {
    gap: 4,
    flex: 1,
  },
  impulseCardTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 22,
  },
  impulseCardSubtitle: {
    ...createBodyText({ fontSize: 15, lineHeight: 22 }),
  },
  impulseToggle: {
    borderWidth: 1,
    borderRadius: 999,
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  impulseToggleText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  impulseSummaryGrid: {
    flexDirection: "row",
    gap: 10,
  },
  impulseBadge: {
    flex: 1,
    borderRadius: 16,
    padding: 12,
    borderWidth: 1,
    gap: 6,
  },
  impulseSummaryLabel: {
    ...createCtaText({ fontSize: 11, textTransform: "none", letterSpacing: 0.2 }),
  },
  impulseSummaryValue: {
    ...createBodyText({ fontSize: 14, lineHeight: 20, fontWeight: "600" }),
  },
  impulseTrendRow: {
    paddingVertical: 4,
  },
  impulseTrendText: {
    ...createBodyText({ fontSize: 13, fontWeight: "700" }),
  },
  impulseCategoryList: {
    marginTop: 8,
    gap: 10,
  },
  impulseCategoryRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    borderWidth: 1,
    borderRadius: 16,
    paddingHorizontal: 12,
    paddingVertical: 10,
  },
  impulseCategoryLabel: {
    ...createBodyText({ fontWeight: "700", flex: 1, marginRight: 12 }),
  },
  impulseCategoryStats: {
    alignItems: "flex-end",
    gap: 2,
  },
  impulseCategoryStat: {
    ...createBodyText({ fontSize: 13, fontWeight: "700" }),
  },
  impulseCategoryStatSecondary: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  freeDayHealthRow: {
    flexDirection: "row",
    alignItems: "center",
    borderWidth: 1,
    borderRadius: 16,
    padding: 12,
    marginBottom: 10,
    gap: 12,
  },
  freeDayHealthIcon: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "rgba(16,91,49,0.08)",
  },
  healthCoinIcon: {
    width: 26,
    height: 26,
    resizeMode: "contain",
  },
  freeDayHealthLabel: {
    fontSize: 14,
    fontWeight: "700",
  },
  freeDayHealthSubtitle: {
    fontSize: 12,
  },
  freeDayCoinRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginTop: 6,
  },
  freeDayCoinBadge: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 999,
    borderWidth: 1,
    gap: 6,
  },
  freeDayCoinImage: {
    width: 20,
    height: 20,
    resizeMode: "contain",
  },
  freeDayCoinCount: {
    fontSize: 12,
    fontWeight: "600",
  },
  freeDayHealthValue: {
    fontSize: 20,
    fontWeight: "800",
    minWidth: 40,
    textAlign: "right",
  },
  freeDayCalendar: {
    marginTop: 4,
    borderRadius: 16,
    padding: 12,
    backgroundColor: "rgba(255,255,255,0.35)",
  },
  freeDayCalendarHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 6,
  },
  freeDayCalendarTitle: {
    fontSize: 12,
    fontWeight: "600",
  },
  freeDayCalendarDays: {
    flexDirection: "row",
    justifyContent: "space-between",
  },
  freeDayCalendarDay: {
    alignItems: "center",
    gap: 4,
    flex: 1,
  },
  freeDayCalendarLabel: {
    fontSize: 11,
    textTransform: "uppercase",
  },
  freeDayCalendarDot: {
    width: 16,
    height: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: "rgba(0,0,0,0.08)",
  },
  freeDayCalendarDotActive: {
    backgroundColor: "#1EB25F",
    borderColor: "#1EB25F",
  },
  freeDayCalendarDotToday: {
    borderColor: "#1EB25F",
    borderWidth: 2,
  },
  stormOverlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(4,6,15,0.92)",
    justifyContent: "center",
    alignItems: "center",
    zIndex: 99,
  },
  stormFlash: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(255,255,255,0.5)",
  },
  stormMessageWrap: {
    paddingHorizontal: 20,
    paddingVertical: 14,
    borderRadius: 18,
    backgroundColor: "rgba(0,0,0,0.55)",
  },
  stormMessage: {
    color: "#F5F6FF",
    fontWeight: "700",
    textAlign: "center",
    fontSize: 14,
  },
  productCard: {
    width: "48%",
    borderRadius: 28,
    padding: 16,
    minHeight: 210,
  },
  productTagline: {
    fontSize: 12,
    color: "#4A3D5E",
  },
  productImage: {
    width: 100,
    height: 100,
    alignSelf: "center",
    marginVertical: 12,
    borderRadius: 16,
  },
  productTitle: {
    fontSize: 18,
    fontWeight: "700",
    color: "#1C1A2A",
  },
  productPrice: {
    marginTop: 4,
    color: "#1C1A2A",
  },
  temptationCard: {
    borderRadius: 28,
    padding: 20,
    gap: 12,
    position: "relative",
    overflow: "visible",
  },
  temptationTextureContainer: {
    ...StyleSheet.absoluteFillObject,
    borderRadius: 28,
    overflow: "hidden",
  },
  temptationTextureOverlay: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.18,
  },
  temptationTextureAccent: {
    transform: [{ rotate: "-8deg" }],
    opacity: 0.12,
    top: -80,
    bottom: -80,
  },
  temptationTextureHighlight: {
    opacity: 0.16,
    transform: [{ rotate: "14deg" }],
    left: "-20%",
    right: "-20%",
    top: "-60%",
    bottom: "-60%",
  },
  temptationSwipeWrapper: {
    marginBottom: 16,
    position: "relative",
  },
  temptationSwipeBackground: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    paddingHorizontal: 16,
  },
  swipeHint: {
    borderWidth: 1,
    borderRadius: 24,
    paddingHorizontal: 12,
    paddingVertical: 6,
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  swipeHintLeft: {
    justifyContent: "flex-start",
  },
  swipeHintRight: {
    justifyContent: "flex-end",
  },
  swipeHintIcon: {
    fontSize: 14,
  },
  swipeHintText: {
    fontSize: 12,
    fontWeight: "600",
  },
  temptationHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  temptationEmoji: {
    fontSize: 28,
  },
  emojiDisplayWrapper: {
    width: 40,
    alignItems: "center",
  },
  temptationBadgeStack: {
    position: "absolute",
    top: 0,
    right: 0,
    alignItems: "flex-end",
    gap: 4,
  },
  temptationPinnedBadge: {
    borderRadius: 999,
    borderWidth: 1,
    paddingHorizontal: 10,
    paddingVertical: 4,
  },
  temptationPinnedBadgeText: {
    fontSize: 11,
    fontWeight: "700",
  },
  temptationTitle: {
    fontSize: 18,
    fontWeight: "700",
    flex: 1,
    flexWrap: "wrap",
  },
  titleEditWrapper: {
    flex: 1,
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  titleEditInputContainer: {
    flex: 1,
    position: "relative",
  },
  titleEditInput: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 14,
    paddingVertical: 6,
    fontSize: 18,
    fontWeight: "700",
  },
  titleEditIcon: {
    position: "absolute",
    right: 12,
    top: "50%",
    transform: [{ translateY: -10 }],
    fontSize: 14,
  },
  emojiEditWrapper: {
    width: 60,
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 12,
    paddingVertical: 6,
    justifyContent: "center",
    position: "relative",
  },
  emojiEditInput: {
    textAlign: "center",
    fontSize: 18,
    fontWeight: "700",
    paddingRight: 14,
  },
  emojiEditIcon: {
    position: "absolute",
    right: 6,
    top: "50%",
    transform: [{ translateY: -9 }],
    fontSize: 12,
  },
  temptationDesc: {
    lineHeight: 20,
    marginTop: 4,
    marginBottom: 8,
  },
  temptationPriceRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginTop: 6,
    marginBottom: 6,
  },
  temptationPricePill: {
    paddingVertical: 6,
    paddingHorizontal: 14,
    borderRadius: 16,
    borderWidth: 1,
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  pricePillInput: {
    minWidth: 60,
    fontSize: 20,
    fontWeight: "700",
    borderWidth: 0,
    backgroundColor: "transparent",
  },
  temptationPrice: {
    fontSize: 20,
    fontWeight: "700",
  },
  temptationGoalBadge: {
    alignSelf: "flex-start",
    paddingHorizontal: 8,
    paddingVertical: 3,
    borderRadius: 999,
    borderWidth: 1,
    marginBottom: 6,
  },
  temptationGoalBadgeFloating: {
    alignSelf: "flex-end",
    marginBottom: 0,
  },
  temptationGoalBadgeEditable: {
    flexDirection: "row",
    alignItems: "center",
  },
  temptationGoalBadgeText: {
    fontSize: 10,
    fontWeight: "700",
  },
  categoryEditSection: {
    marginTop: 10,
    gap: 6,
  },
  categoryEditLabel: {
    ...createSecondaryText({ fontSize: 11, textTransform: "uppercase" }),
  },
  temptationFocusBadge: {
    alignSelf: "flex-start",
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 999,
    borderWidth: 1,
    marginBottom: 6,
  },
  temptationFocusBadgeText: {
    ...createCtaText({ fontSize: 11 }),
  },
  editPriceText: {
    fontSize: 13,
    fontWeight: "600",
  },
  temptationRefuseMeta: {
    fontSize: 12,
    marginBottom: 6,
  },
  temptationFeedbackOverlay: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    borderRadius: 28,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 24,
  },
  temptationFeedbackText: {
    fontSize: 18,
    fontWeight: "700",
    textAlign: "center",
  },
  coinBurst: {
    position: "absolute",
    bottom: 32,
    left: "50%",
    marginLeft: -8,
    width: 16,
    height: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: "#E9A600",
    backgroundColor: "#FFD766",
    shadowColor: "#E9A600",
    shadowOpacity: 0.4,
    shadowRadius: 4,
    shadowOffset: { width: 0, height: 2 },
    elevation: 4,
    justifyContent: "center",
    alignItems: "center",
  },
  coinBurstInner: {
    width: 8,
    height: 8,
    borderRadius: 4,
    backgroundColor: "#FFF4B3",
  },
  temptationEditor: {
    marginTop: 8,
    borderTopWidth: StyleSheet.hairlineWidth,
    paddingTop: 12,
    gap: 14,
  },
  temptationEditorField: {
    gap: 6,
  },
  editorLabelRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  editorHintIcon: {
    fontSize: 14,
  },
  temptationEditorActions: {
    gap: 8,
  },
  temptationBadge: {
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 999,
    borderWidth: 1,
  },
  temptationBadgeText: {
    fontSize: 12,
    fontWeight: "600",
    textTransform: "uppercase",
  },
  temptationActions: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginTop: 8,
  },
  temptationButtonPrimary: {
    flexGrow: 1,
    borderRadius: 16,
    paddingVertical: 12,
    alignItems: "center",
  },
  temptationButtonPrimaryText: {
    fontWeight: "700",
    fontSize: 14,
  },
  temptationButtonGhost: {
    flexGrow: 1,
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 10,
    alignItems: "center",
  },
  temptationButtonGhostText: {
    fontWeight: "600",
  },
  temptationButtonOutline: {
    flexGrow: 1,
    borderRadius: 16,
    paddingVertical: 10,
    borderWidth: 1,
    alignItems: "center",
  },
  temptationButtonOutlineText: {
    fontWeight: "600",
  },
  detailBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.4)",
    justifyContent: "center",
    padding: 24,
  },
  detailCard: {
    borderRadius: 30,
    padding: 20,
  },
  detailHero: {
    borderRadius: 24,
    padding: 24,
    alignItems: "center",
    marginBottom: 16,
  },
  detailImage: {
    width: 160,
    height: 160,
  },
  detailTitle: {
    fontSize: 26,
    fontWeight: "700",
  },
  detailTagline: {
    marginTop: 6,
    fontWeight: "600",
  },
  detailPrice: {
    fontSize: 20,
    fontWeight: "700",
    marginTop: 8,
  },
  detailRating: {
    marginTop: 4,
    fontSize: 14,
  },
  detailDesc: {
    marginTop: 12,
    lineHeight: 20,
  },
  tutorialBackdrop: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  tutorialBackdropDim: {
    backgroundColor: "rgba(0,0,0,0.55)",
  },
  tutorialCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 28,
    padding: 24,
    borderWidth: 1,
    gap: 12,
  },
  tutorialIcon: {
    fontSize: 32,
    textAlign: "center",
  },
  tutorialTitle: {
    fontSize: 22,
    fontWeight: "800",
    textAlign: "center",
  },
  tutorialDescription: {
    fontSize: 15,
    lineHeight: 20,
    textAlign: "center",
  },
  tutorialProgressRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginTop: 8,
  },
  tutorialDots: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  tutorialDot: {
    width: 10,
    height: 10,
    borderRadius: 5,
  },
  tutorialProgressText: {
    fontSize: 12,
    fontWeight: "600",
  },
  tutorialActions: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    marginTop: 4,
  },
  tutorialSkipButton: {
    flex: 1,
    paddingVertical: 12,
  },
  tutorialSkipText: {
    textAlign: "center",
    fontSize: 14,
    fontWeight: "600",
  },
  tutorialPrimaryButton: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: 16,
    alignItems: "center",
  },
  tutorialPrimaryText: {
    fontSize: 15,
    fontWeight: "700",
  },
  tabHintBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.5)",
    justifyContent: "flex-end",
    padding: 24,
  },
  tabHintCard: {
    borderRadius: 24,
    borderWidth: 1,
    padding: 20,
    gap: 10,
  },
  tabHintTitle: {
    ...createBodyText({ fontSize: 17, fontWeight: "700" }),
  },
  tabHintBody: {
    ...createBodyText({ fontSize: 14 }),
  },
  tabHintButton: {
    marginTop: 4,
    borderRadius: 14,
    paddingVertical: 10,
    alignItems: "center",
  },
  tabHintButtonText: {
    ...createCtaText({ fontSize: 14 }),
  },
  variantRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    marginTop: 18,
    gap: 10,
  },
  variantPill: {
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 10,
    paddingHorizontal: 14,
  },
  variantText: {
    fontWeight: "600",
  },
  variantPrice: {
    fontSize: 12,
    marginTop: 4,
  },
  primaryButton: {
    borderRadius: 24,
    paddingVertical: 16,
    alignItems: "center",
    marginTop: 22,
  },
  primaryButtonText: {
    ...createCtaText({ fontSize: 16 }),
  },
  secondaryButtonClear: {
    alignItems: "center",
    paddingVertical: 12,
  },
  secondaryButtonClearText: {
    ...createCtaText({ fontSize: 14 }),
  },
  secondaryButton: {
    borderRadius: 24,
    paddingVertical: 14,
    alignItems: "center",
    marginTop: 12,
    borderWidth: 1,
  },
  secondaryButtonText: {
    ...createCtaText(),
  },
  closeButton: {
    alignSelf: "flex-end",
  },
  closeButtonText: {
    fontSize: 28,
  },
  header: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 30,
    marginBottom: 16,
  },
  subheader: {
    ...TYPOGRAPHY.blockTitle,
    marginTop: 24,
    marginBottom: 12,
  },
  emptyState: {
    alignItems: "center",
    paddingVertical: 60,
  },
  emptyStateTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 20,
  },
  emptyStateText: {
    ...createBodyText({ textAlign: "center", marginTop: 6 }),
  },
  cartEmptyState: {
    alignItems: "center",
    paddingVertical: 60,
    gap: 12,
  },
  catImage: {
    width: 160,
    height: 160,
    opacity: 0.4,
    borderRadius: 32,
  },
  catImageLarge: {
    width: 220,
    height: 220,
    opacity: 0.9,
  },
  cartEmptyTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 22,
  },
  cartEmptySubtitle: {
    ...createBodyText({ fontSize: 16, textAlign: "center" }),
  },
  cartCard: {
    flexDirection: "row",
    alignItems: "center",
    borderRadius: 28,
    padding: 16,
    marginBottom: 14,
  },
  cartImageWrap: {
    width: 70,
    height: 70,
    borderRadius: 22,
    backgroundColor: "#F1F2F6",
    alignItems: "center",
    justifyContent: "center",
    marginRight: 14,
  },
  cartTitleText: {
    fontSize: 16,
    fontWeight: "700",
  },
  cartVariant: {
    marginTop: 4,
  },
  cartRight: {
    alignItems: "flex-end",
  },
  cartPrice: {
    fontWeight: "700",
  },
  cartBuyButton: {
    marginTop: 6,
    borderRadius: 16,
    paddingHorizontal: 14,
    paddingVertical: 6,
  },
  cartBuyText: {
    fontSize: 12,
    fontWeight: "600",
  },
  cartRemove: {
    marginTop: 4,
    fontSize: 12,
  },
  wishCard: {
    borderRadius: 28,
    padding: 18,
    marginBottom: 16,
    gap: 10,
    position: "relative",
  },
  goalSwipeRow: {
    marginBottom: 20,
    overflow: "hidden",
    position: "relative",
  },
  goalSwipeActions: {
    position: "absolute",
    left: 0,
    top: 0,
    bottom: 0,
    width: 160,
    justifyContent: "center",
    alignItems: "flex-start",
    paddingVertical: 12,
    paddingHorizontal: 12,
    gap: 10,
    zIndex: 0,
  },
  goalSwipeButton: {
    paddingVertical: 8,
    paddingHorizontal: 10,
    borderRadius: 12,
    borderWidth: 1,
  },
  goalSwipeButtonDisabled: {
    opacity: 0.4,
  },
  goalSwipeButtonText: {
    ...createCtaText({ fontSize: 14 }),
  },
  goalSwipeContent: {
    width: "100%",
    zIndex: 1,
  },
  wishHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-start",
  },
  wishTitleWrap: {
    flexDirection: "row",
    alignItems: "center",
    flex: 1,
    marginRight: 12,
    gap: 8,
  },
  wishEmoji: {
    fontSize: 22,
  },
  wishTitle: {
    fontSize: 18,
    fontWeight: "700",
    flex: 1,
    paddingRight: 0,
  },
  wishSavedHint: {
    fontSize: 12,
    marginTop: 2,
  },
  wishBadge: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "transparent",
    backgroundColor: "rgba(0,0,0,0.04)",
  },
  wishBadgeText: {
    fontSize: 12,
    fontWeight: "700",
  },
  wishMeta: {
    fontSize: 13,
    marginBottom: 4,
  },
  wishProgressRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    marginTop: 6,
  },
  wishProgressTrack: {
    flex: 1,
    height: 10,
    borderRadius: 999,
    overflow: "hidden",
  },
  wishProgressBar: {
    height: 10,
    borderRadius: 999,
    overflow: "hidden",
    marginTop: 8,
    marginBottom: 12,
  },
  wishProgressFill: {
    height: "100%",
    borderRadius: 999,
  },
  wishProgressLabel: {
    ...createSecondaryText({ fontSize: 13 }),
  },
  wishButtonGhost: {
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 12,
    paddingHorizontal: 16,
    justifyContent: "center",
    alignItems: "center",
  },
  goalDragWrapper: {
    flexDirection: "row",
    alignItems: "stretch",
    gap: 10,
    paddingVertical: 4,
  },
  goalDragWrapperActive: {
    opacity: 0.94,
  },
  goalDragHandle: {
    width: 32,
    alignItems: "center",
    justifyContent: "center",
    borderRadius: 16,
    paddingVertical: 18,
    marginRight: 4,
  },
  goalDragHandleDots: {
    fontSize: 18,
    fontWeight: "700",
  },
  goalDragCardActive: {
    transform: [{ scale: 0.995 }],
  },
  primaryGoalCard: {
    borderRadius: 36,
    padding: 28,
    overflow: "hidden",
  },
  primaryGoalAura: {
    position: "absolute",
    width: 220,
    height: 220,
    borderRadius: 110,
    top: -60,
    right: -40,
  },
  primaryGoalTop: {
    flexDirection: "row",
    alignItems: "flex-start",
    gap: 16,
  },
  primaryGoalBadge: {
    borderRadius: 999,
    paddingHorizontal: 14,
    paddingVertical: 6,
    borderWidth: 1,
    alignSelf: "flex-start",
  },
  primaryGoalBadgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  primaryGoalTitle: {
    ...TYPOGRAPHY.blockTitle,
  },
  primaryGoalSubtitle: {
    ...createBodyText({ fontSize: 15, marginTop: 6 }),
  },
  primaryGoalEmblem: {
    width: 64,
    height: 64,
    borderRadius: 32,
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 1,
  },
  primaryGoalProgressRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    marginTop: 18,
  },
  primaryGoalProgressTrack: {
    flex: 1,
    height: 14,
    borderRadius: 999,
    overflow: "hidden",
  },
  primaryGoalProgressFill: {
    height: "100%",
    borderRadius: 999,
  },
  primaryGoalPercent: {
    ...createBodyText({ fontSize: 16, fontWeight: "800" }),
  },
  pendingCard: {
    borderRadius: 24,
    padding: 18,
    gap: 12,
  },
  pendingSwipeWrapper: {
    position: "relative",
  },
  pendingSwipeBackground: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    justifyContent: "flex-end",
    alignItems: "center",
    paddingHorizontal: 16,
    flexDirection: "row",
  },
  pendingHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    gap: 12,
  },
  pendingTitle: {
    ...createBodyText({ fontSize: 18, fontWeight: "700", flex: 1 }),
  },
  pendingDue: {
    ...createCtaText({ fontSize: 13, textTransform: "uppercase" }),
  },
  pendingPrice: {
    fontSize: 16,
    fontWeight: "600",
  },
  pendingButtons: {
    flexDirection: "row",
    gap: 10,
  },
  pendingCountdown: {
    fontSize: 20,
    fontWeight: "800",
    marginTop: 6,
  },
  pendingButtonPrimary: {
    flex: 1,
    borderRadius: 16,
    paddingVertical: 12,
    alignItems: "center",
  },
  pendingButtonPrimaryText: {
    ...createCtaText(),
  },
  pendingButtonSecondary: {
    borderWidth: 1,
    borderRadius: 16,
    paddingHorizontal: 16,
    paddingVertical: 12,
    alignItems: "center",
  },
  cartTotalRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginTop: 12,
  },
  cartTotalText: {
    ...createBodyText({ fontSize: 18, fontWeight: "600" }),
  },
  cartTotalAmount: {
    ...createBodyText({ fontSize: 18, fontWeight: "700" }),
  },
  buyAllButton: {
    marginTop: 18,
    borderRadius: 24,
    paddingVertical: 16,
    alignItems: "center",
  },
  buyAllButtonText: {
    ...createCtaText(),
  },
  purchasesSubtitle: {
    marginBottom: 16,
  },
  progressCard: {
    borderRadius: 26,
    padding: 18,
    marginBottom: 20,
  },
  progressTextRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginBottom: 12,
  },
  progressLabel: {
    textTransform: "uppercase",
    fontSize: 12,
  },
  progressValue: {
    fontSize: 32,
    fontWeight: "800",
  },
  progressGoal: {
    fontWeight: "700",
  },
  progressBar: {
    height: 12,
    borderRadius: 12,
    overflow: "hidden",
  },
  progressFill: {
    height: "100%",
    borderRadius: 12,
  },
  progressHint: {
    marginTop: 10,
  },
  purchaseCard: {
    borderRadius: 24,
    padding: 16,
    marginBottom: 14,
  },
  purchaseInfo: {
    marginBottom: 8,
  },
  purchaseTitle: {
    fontWeight: "700",
  },
  purchaseDesc: {
    marginTop: 4,
  },
  purchasePrice: {
    fontWeight: "700",
  },
  levelWidget: {
    borderRadius: 28,
    padding: 20,
    borderWidth: 1,
    gap: 12,
  },
  levelWidgetHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  levelWidgetTitle: {
    fontSize: 18,
    fontWeight: "800",
  },
  levelWidgetBadge: {
    borderRadius: 999,
    paddingHorizontal: 14,
    paddingVertical: 6,
  },
  levelWidgetBadgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  levelWidgetSubtitle: {
    ...createBodyText({ fontSize: 14, fontWeight: "600" }),
  },
  levelWidgetBar: {
    height: 8,
    borderRadius: 16,
    overflow: "hidden",
    marginTop: 8,
  },
  levelWidgetFill: {
    height: "100%",
    borderRadius: 16,
  },
  levelWidgetMeta: {
    ...createSecondaryText({ fontSize: 13 }),
  },
  goalCard: {
    borderRadius: 24,
    padding: 20,
    marginBottom: 12,
    gap: 12,
    position: "relative",
  },
  goalTitle: {
    ...createBodyText({ fontWeight: "700", fontSize: 16 }),
  },
  goalDesc: {
    ...createBodyText({ marginTop: 4 }),
  },
  rewardHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 12,
  },
  rewardBadge: {
    borderRadius: 999,
    paddingHorizontal: 12,
    paddingVertical: 5,
    alignSelf: "flex-start",
  },
  rewardBadgeFloating: {
    position: "absolute",
    top: 0,
    right: -6,
  },
  rewardBadgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  rewardBadgeContainer: {
    position: "absolute",
    top: -8,
    right: -10,
    padding: 0,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "flex-end",
    width: "100%",
    pointerEvents: "none",
  },
  healthRewardTokenRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  healthRewardTokenRowCompact: {
    gap: 6,
  },
  healthRewardToken: {
    flexDirection: "row",
    alignItems: "center",
    gap: 4,
  },
  healthRewardTokenIcon: {
    width: 18,
    height: 18,
    resizeMode: "contain",
  },
  healthRewardTokenCount: {
    ...createCtaText({ fontSize: 12 }),
  },
  rewardClaimButton: {
    borderRadius: 16,
    paddingVertical: 10,
    paddingHorizontal: 20,
    marginTop: 6,
  },
  rewardClaimButtonText: {
    ...createCtaText({ fontSize: 14, textAlign: "center", width: "100%" }),
  },
  rewardsTabs: {
    flexDirection: "row",
    gap: 10,
    marginTop: 4,
    marginBottom: 4,
  },
  rewardsTabButton: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 10,
    alignItems: "center",
  },
  rewardsTabText: {
    ...createCtaText({ fontSize: 14 }),
  },
  challengeCard: {
    borderRadius: 22,
    padding: 18,
    gap: 12,
    borderWidth: 1,
    position: "relative",
  },
  challengeHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  challengeEmoji: {
    fontSize: 28,
  },
  challengeTitle: {
    ...createBodyText({ fontSize: CHALLENGE_TITLE_FONT_SIZE, fontWeight: "700" }),
  },
  challengeDesc: {
    ...createBodyText({ fontSize: CHALLENGE_DESC_FONT_SIZE, lineHeight: CHALLENGE_LINE_HEIGHT }),
  },
  challengeMetaRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  challengeStatus: {
    ...createCtaText({ fontSize: CHALLENGE_META_FONT_SIZE, textTransform: "uppercase" }),
  },
  challengeTimer: {
    ...createSecondaryText({ fontSize: CHALLENGE_META_FONT_SIZE }),
    textAlign: "right",
  },
  challengeProgressBar: {
    height: 8,
    borderRadius: 999,
    overflow: "hidden",
  },
  challengeProgressFill: {
    height: "100%",
    borderRadius: 999,
  },
  challengeProgressLabel: {
    ...createSecondaryText({ fontSize: CHALLENGE_META_FONT_SIZE }),
  },
  challengeActionButton: {
    borderRadius: 16,
    paddingVertical: 12,
    alignItems: "center",
  },
  challengeActionText: {
    ...createCtaText(),
  },
  dailyChallengeWidget: {
    borderRadius: 24,
    padding: 18,
    borderWidth: 1,
    gap: 16,
  },
  dailyChallengeWidgetHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  dailyChallengeWidgetBody: {
    flexDirection: "row",
    alignItems: "center",
    gap: 14,
  },
  dailyChallengeEmojiPill: {
    width: 54,
    height: 54,
    borderRadius: 18,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "rgba(0,0,0,0.06)",
  },
  dailyChallengeEmojiText: {
    fontSize: scaleFontSize(30),
  },
  dailyChallengeWidgetTitle: {
    fontSize: scaleFontSize(18),
    fontWeight: "800",
  },
  dailyChallengeWidgetDesc: {
    ...createBodyText({ fontSize: 14 }),
  },
  dailyChallengeProgressBar: {
    height: 8,
    borderRadius: 8,
    overflow: "hidden",
  },
  dailyChallengeProgressFill: {
    height: "100%",
    borderRadius: 8,
  },
  dailyChallengeWidgetFooter: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  dailyChallengeProgressLabel: {
    ...createSecondaryText({ fontSize: 13 }),
  },
  dailyChallengeRewardLabel: {
    fontSize: scaleFontSize(14),
    fontWeight: "800",
  },
  challengeRewardChip: {
    borderRadius: 999,
    paddingHorizontal: 10,
    paddingVertical: 4,
  },
  challengeRewardChipFloating: {
    position: "absolute",
    right: 10,
    top: -6,
  },
  challengeSwipeWrapper: {
    position: "relative",
    borderRadius: 22,
    backgroundColor: "transparent",
  },
  challengeSwipeActions: {
    position: "absolute",
    right: 0,
    top: 0,
    bottom: 0,
    width: CHALLENGE_SWIPE_ACTION_WIDTH,
    justifyContent: "center",
    alignItems: "center",
    borderRadius: 22,
    overflow: "hidden",
  },
  challengeSwipeButton: {
    borderRadius: 16,
    paddingVertical: 12,
    paddingHorizontal: 10,
    width: "80%",
    alignItems: "center",
  },
  challengeSwipeButtonText: {
    ...createCtaText({ fontSize: 13, textAlign: "center" }),
  },
  goalProgressBar: {
    height: 8,
    borderRadius: 999,
    overflow: "hidden",
    marginTop: 16,
    marginBottom: 8,
  },
  goalProgressFill: {
    height: "100%",
    borderRadius: 999,
  },
  profileCard: {
    borderRadius: 30,
    padding: 24,
    alignItems: "center",
    marginBottom: 20,
  },
  profileMoodAura: {
    alignItems: "center",
    width: "100%",
    marginBottom: 12,
  },
  profileMoodGradient: {
    width: 170,
    height: 170,
    borderRadius: 85,
    justifyContent: "center",
    alignItems: "center",
    padding: 8,
  },
  profileMoodStatus: {
    ...createCtaText({ fontSize: 13, textTransform: "uppercase", marginTop: 10 }),
  },
  profileScrollContent: {
    paddingTop: 4,
    paddingBottom: 40,
    flexGrow: 1,
  },
  profileAvatarWrap: {
    alignItems: "center",
    marginBottom: 0,
    position: "relative",
  },
  profileAvatar: {
    width: 120,
    height: 120,
    borderRadius: 60,
  },
  profileNameRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  rewardBadgeSmall: {
    borderRadius: 999,
    paddingHorizontal: 10,
    paddingVertical: 4,
  },
  rewardBadgeSmallText: {
    ...createCtaText({ fontSize: 12 }),
  },
  profileAvatarHint: {
    ...createSecondaryText({ fontSize: 12, marginTop: 12, textAlign: "center" }),
  },
  profileAvatarEditBadge: {
    position: "absolute",
    top: 6,
    right: 6,
    width: 32,
    height: 32,
    borderRadius: 16,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  profileAvatarEditIcon: {
    fontSize: 15,
    fontWeight: "700",
  },
  profileName: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: scaleFontSize(28),
  },
  profileSubtitle: {
    ...createBodyText({ marginTop: 4 }),
    fontSize: PROFILE_SUBTITLE_FONT_SIZE,
    lineHeight: PROFILE_SUBTITLE_LINE_HEIGHT,
    textAlign: "center",
  },
  profileBio: {
    ...createBodyText({ marginTop: 10, textAlign: "center", lineHeight: 20 }),
  },
  profileStatsRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    width: "100%",
    marginTop: 20,
  },
  profileStat: {
    alignItems: "center",
    flex: 1,
    paddingHorizontal: 2,
  },
  profileStatValueRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 4,
  },
  profileStatValue: {
    ...createBodyText({ fontWeight: "700" }),
  },
  profileStatValueSuffix: {
    ...createBodyText({ fontWeight: "700" }),
  },
  profileStatLabel: {
    ...createCtaText({
      fontSize: PROFILE_STAT_LABEL_FONT_SIZE,
      textTransform: "uppercase",
      marginTop: 4,
      letterSpacing: PROFILE_STAT_LETTER_SPACING,
    }),
    textAlign: "center",
    flexShrink: 1,
  },
  profileActions: {
    width: "100%",
    marginTop: 20,
    gap: 12,
  },
  profileActionPrimary: {
    paddingVertical: 14,
    borderRadius: 24,
    alignItems: "center",
  },
  profileActionPrimaryText: {
    ...createCtaText(),
  },
  profileActionSecondary: {
    paddingVertical: 14,
    borderRadius: 24,
    alignItems: "center",
    borderWidth: 1,
  },
  profileActionSecondaryText: {
    ...createCtaText(),
  },
  profileInput: {
    width: "100%",
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 16,
    paddingVertical: 10,
    marginBottom: 10,
  },
  goalTargetInputWrap: {
    flexDirection: "row",
    alignItems: "center",
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 16,
    paddingVertical: 10,
    gap: 10,
  },
  goalTargetInput: {
    flex: 1,
    fontSize: 16,
    fontWeight: "600",
  },
  goalTargetCurrency: {
    fontWeight: "700",
  },
  goalTargetRow: {
    width: "100%",
    marginBottom: 12,
    gap: 6,
  },
  goalTargetLabel: {
    fontSize: 13,
    fontWeight: "600",
  },
  profileInputHalf: {
    flex: 1,
    width: "auto",
  },
  profileHintText: {
    fontSize: 12,
    lineHeight: 18,
  },
  profileSettingValue: {
    fontSize: 16,
    fontWeight: "600",
  },
  profileBioInput: {
    height: 90,
    textAlignVertical: "top",
  },
  inputRow: {
    flexDirection: "row",
    gap: 10,
    width: "100%",
  },
  settingsCard: {
    borderRadius: 26,
    padding: 20,
    marginBottom: 40,
  },
  profileSection: {
    marginBottom: 16,
    gap: 12,
  },
  settingsDivider: {
    height: 1,
    width: "100%",
    backgroundColor: "rgba(0,0,0,0.05)",
    marginVertical: 8,
  },
  settingsTitle: {
    fontSize: 20,
    fontWeight: "700",
    marginBottom: 16,
  },
  settingRow: {
    marginBottom: 18,
  },
  settingLabel: {
    marginBottom: 8,
  },
  settingValue: {
    fontSize: 16,
    fontWeight: "600",
  },
  settingChoices: {
    flexDirection: "row",
    gap: 12,
    flexWrap: "wrap",
  },
  settingCurrencyScrollWrapper: {
    position: "relative",
    marginTop: 4,
    marginRight: -32,
    paddingRight: 32,
  },
  settingCurrencyScroll: {
    marginTop: 0,
  },
  settingCurrencyScrollContent: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    paddingRight: 16,
  },
  profileGoalGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 10,
  },
  profileGoalOption: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    borderWidth: 1,
    borderRadius: 20,
    paddingVertical: 8,
    paddingHorizontal: 12,
  },
  profileGoalEmoji: {
    fontSize: 18,
  },
  profileGoalText: {
    fontWeight: "600",
  },
  goalTargetBlock: {
    width: "100%",
    borderWidth: 1,
    borderRadius: 18,
    padding: 14,
    gap: 8,
  },
  goalTargetHeader: {
    gap: 4,
    marginBottom: 4,
  },
  goalTargetTitle: {
    fontSize: 15,
    fontWeight: "700",
  },
  goalTargetHint: {
    fontSize: 12,
  },
  guideCards: {
    width: "100%",
    gap: 12,
  },
  guideCard: {
    borderRadius: 22,
    padding: 18,
    borderWidth: 1,
    gap: 8,
  },
  guideEmoji: {
    fontSize: 28,
  },
  guideTitle: {
    fontSize: 16,
    fontWeight: "700",
  },
  guideDesc: {
    fontSize: 13,
    lineHeight: 18,
  },
  settingChip: {
    paddingHorizontal: 14,
    paddingVertical: 8,
    borderRadius: 18,
    borderWidth: 1,
  },
  resetButton: {
    marginTop: Platform.OS === "ios" ? 16 : 8,
    paddingVertical: 12,
    borderWidth: 1,
    borderRadius: 18,
    alignItems: "center",
  },
  analyticsCard: {
    borderRadius: 26,
    padding: 20,
    marginBottom: 24,
  },
  analyticsTitle: {
    fontSize: 18,
    fontWeight: "700",
    marginBottom: 12,
  },
  analyticsRow: {
    flexDirection: "row",
    gap: 12,
  },
  analyticsItem: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 14,
    paddingHorizontal: 12,
    alignItems: "center",
  },
  analyticsValue: {
    fontSize: 22,
    fontWeight: "800",
  },
  analyticsLabel: {
    marginTop: 6,
    fontSize: 12,
    textAlign: "center",
  },
  historyCard: {
    borderRadius: 26,
    padding: 20,
    marginBottom: 80,
  },
  historyTitle: {
    fontSize: 20,
    fontWeight: "700",
    marginBottom: 12,
  },
  historyEmpty: {
    fontSize: 14,
  },
  historyList: {
    borderWidth: StyleSheet.hairlineWidth,
    borderRadius: 20,
  },
  historyListContent: {
    paddingHorizontal: 12,
  },
  historyItem: {
    paddingVertical: 12,
  },
  historyRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  historyDeleteBtn: {
    width: 32,
    height: 32,
    borderWidth: 1,
    borderRadius: 16,
    alignItems: "center",
    justifyContent: "center",
  },
  historyDeleteText: {
    fontSize: 16,
    fontWeight: "700",
  },
  historyItemTitle: {
    ...createBodyText({ fontWeight: "600" }),
  },
  historyItemMeta: {
    ...createSecondaryText({ marginTop: 4 }),
  },
  profileLinkButton: {
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 10,
    paddingHorizontal: 14,
    marginBottom: 16,
    gap: 2,
  },
  profileLinkText: {
    ...createCtaText({ fontSize: 14 }),
  },
  profileLinkHint: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  analyticsSwitch: {
    ...(Platform.OS === "ios"
      ? {
          transform: [{ scaleX: 0.85 }, { scaleY: 0.85 }],
          marginLeft: 12,
          marginTop: 6,
        }
      : {}),
  },
  resetButtonText: {
    ...createCtaText(),
  },
  tabBar: {
    flexDirection: "row",
    borderTopWidth: 1,
    paddingHorizontal: 12,
  },
  tabButton: {
    flex: 1,
    paddingVertical: 14,
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
  },
  tabButtonHighlight: {
    borderWidth: 1,
    borderRadius: 18,
    marginHorizontal: 4,
    paddingHorizontal: 10,
    shadowColor: "#000",
    shadowOpacity: 0.08,
    shadowRadius: 8,
    shadowOffset: { width: 0, height: 4 },
    elevation: 4,
  },
  tabButtonText: {
    ...createCtaText({ fontSize: 13, textTransform: "uppercase" }),
  },
  tabBadge: {
    minWidth: 20,
    height: 20,
    borderRadius: 10,
    paddingHorizontal: 6,
    alignItems: "center",
    justifyContent: "center",
  },
  tabBadgeFloating: {
    position: "absolute",
    top: -6,
    right: -2,
  },
  tabBadgeText: {
    ...createCtaText({ fontSize: 11, textTransform: "none" }),
  },
  analyticsConsentScreen: {
    flex: 1,
    justifyContent: "flex-start",
    padding: 24,
    paddingTop: 48,
    gap: 20,
  },
  analyticsConsentCard: {
    borderRadius: 32,
    borderWidth: 1,
    padding: 28,
    gap: 20,
  },
  analyticsConsentTitle: {
    ...TYPOGRAPHY.blockTitle,
  },
  analyticsConsentBody: {
    ...createBodyText({ lineHeight: 22 }),
  },
  analyticsConsentPrimary: {
    borderRadius: 20,
    paddingVertical: 14,
    alignItems: "center",
  },
  analyticsConsentPrimaryText: {
    ...createCtaText({ fontSize: 15 }),
  },
  analyticsConsentSecondary: {
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
  },
  analyticsConsentSecondaryText: {
    ...createCtaText({ fontSize: 14 }),
  },
  modalContainer: {
    flex: 1,
    justifyContent: "flex-end",
    backgroundColor: "rgba(0,0,0,0.4)",
  },
  paySheet: {
    borderTopLeftRadius: 30,
    borderTopRightRadius: 30,
    padding: 24,
  },
  modalTitle: {
    fontSize: 28,
    fontWeight: "700",
    marginBottom: 16,
  },
  payCard: {
    borderRadius: 22,
    padding: 18,
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 14,
  },
  payLabel: {
    fontSize: 12,
    textTransform: "uppercase",
  },
  payDigits: {
    marginTop: 6,
    fontSize: 16,
  },
  payAmount: {
    fontWeight: "700",
    fontSize: 20,
  },
  payOptions: {
    flexDirection: "row",
    gap: 12,
    marginBottom: 10,
  },
  payOptionChip: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 10,
    alignItems: "center",
  },
  partialInputWrap: {
    marginTop: 6,
  },
  partialLabel: {
    marginBottom: 6,
  },
  partialInput: {
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 16,
    paddingVertical: 10,
  },
  partialInfo: {
    ...createBodyText({ marginVertical: 12, textAlign: "center" }),
  },
  appleButton: {
    paddingVertical: 16,
    borderRadius: 26,
    alignItems: "center",
    marginTop: 12,
  },
  appleButtonText: {
    ...createCtaText({ fontSize: 16 }),
  },
  payCancel: {
    ...createSecondaryText({ textAlign: "center", marginTop: 12 }),
  },
  fabCenterContainer: {
    position: "absolute",
    bottom: FAB_CONTAINER_BOTTOM,
    left: 0,
    right: 0,
    alignItems: "center",
    justifyContent: "center",
  },
  fabButtonWrapper: {
    width: FAB_BUTTON_SIZE,
    height: FAB_BUTTON_SIZE,
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
  },
  cartBadge: {
    width: FAB_BUTTON_SIZE,
    height: FAB_BUTTON_SIZE,
    borderRadius: FAB_BUTTON_SIZE / 2,
    justifyContent: "center",
    alignItems: "center",
    shadowColor: "#000",
    shadowOpacity: 0.2,
    shadowOffset: { width: 0, height: 2 },
    shadowRadius: 4,
    elevation: 4,
    borderWidth: 1,
  },
  cartBadgeHighlight: {
    borderColor: "#F5C869",
    shadowColor: "#F5C869",
    shadowOpacity: 0.85,
    shadowRadius: 16,
    elevation: 8,
    borderWidth: 2,
    borderRadius: FAB_BUTTON_SIZE / 2,
  },
  cartBadgeIcon: {
    fontSize: 32,
  },
  fabMenuOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "flex-end",
    alignItems: "center",
    paddingBottom: 180,
    paddingHorizontal: 24,
  },
  fabMenuBackdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(0,0,0,0.15)",
  },
  fabOption: {
    alignItems: "center",
    justifyContent: "center",
  },
  fabOptionRow: {
    alignSelf: "center",
  },
  fabOptionRowContent: {
    flexDirection: "row",
    gap: 12,
  },
  fabCircle: {
    width: 88,
    height: 88,
    borderRadius: 44,
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 1,
    paddingHorizontal: 8,
  },
  fabOptionText: {
    fontSize: 13,
    fontWeight: "700",
    textAlign: "center",
    lineHeight: 16,
  },
  fabTutorialBackdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "transparent",
    justifyContent: "flex-end",
    alignItems: "center",
  },
  fabTutorialOverlaySvg: {
    ...StyleSheet.absoluteFillObject,
  },
  fabTutorialContent: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "flex-end",
    alignItems: "center",
    paddingHorizontal: 24,
  },
  fabTutorialHalo: {
    position: "absolute",
    width: FAB_TUTORIAL_HALO_SIZE,
    height: FAB_TUTORIAL_HALO_SIZE,
    borderRadius: FAB_TUTORIAL_HALO_SIZE / 2,
    borderWidth: 2,
    top: -FAB_TUTORIAL_HALO_INSET,
    left: -FAB_TUTORIAL_HALO_INSET,
    shadowOpacity: 0.65,
    shadowRadius: 28,
    shadowOffset: { width: 0, height: 6 },
    elevation: 6,
    zIndex: -1,
  },
  fabTutorialCard: {
    width: "90%",
    maxWidth: 360,
    borderRadius: 24,
    paddingHorizontal: 20,
    paddingVertical: 20,
    borderWidth: 1,
  },
  fabTutorialTitle: {
    fontSize: 18,
    fontWeight: "700",
    textAlign: "center",
    marginBottom: 8,
  },
  fabTutorialDescription: {
    fontSize: 15,
    lineHeight: 21,
    textAlign: "center",
    marginBottom: 16,
  },
  fabTutorialButton: {
    borderRadius: 16,
    paddingVertical: 12,
    paddingHorizontal: 16,
  },
  fabTutorialButtonText: {
    fontSize: 15,
    fontWeight: "700",
    textAlign: "center",
  },
  quickModalBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.4)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  quickModalCard: {
    width: "100%",
    borderRadius: 28,
    padding: 20,
    gap: 14,
  },
  quickModalTitle: {
    fontSize: 20,
    fontWeight: "700",
  },
  quickModalSubtitle: {
    fontSize: 14,
    lineHeight: 20,
  },
  quickModalActions: {
    flexDirection: "row",
    gap: 12,
    width: "100%",
  },
  quickModalSecondary: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 16,
    justifyContent: "center",
    alignItems: "center",
    paddingVertical: 12,
  },
  quickModalSecondaryText: {
    fontWeight: "600",
  },
  quickModalPrimary: {
    flex: 1,
    borderRadius: 16,
    justifyContent: "center",
    alignItems: "center",
    paddingVertical: 12,
  },
  quickModalPrimaryText: {
    ...createCtaText(),
  },
  coinEntryBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.55)",
    padding: 24,
    justifyContent: "center",
    alignItems: "center",
  },
  coinEntryCard: {
    width: "100%",
    maxWidth: 420,
    borderRadius: 32,
    padding: 22,
    borderWidth: 1,
    gap: 16,
  },
  coinEntryHeader: {
    flexDirection: "row",
    alignItems: "flex-start",
    gap: 12,
  },
  coinEntryTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 24,
  },
  coinEntrySubtitle: {
    ...createBodyText({ fontSize: 15, lineHeight: 20 }),
  },
  coinEntryClose: {
    padding: 4,
  },
  coinEntryCloseText: {
    fontSize: 20,
    fontWeight: "700",
  },
  coinEntryAmountRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  coinEntryAmount: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 28,
  },
  coinSliderWrapper: {
    marginTop: 20,
    alignItems: "center",
    justifyContent: "center",
    minHeight: COIN_SLIDER_SIZE + 40,
    width: "100%",
  },
  coinSliderBackdrop: {
    position: "absolute",
    width: "100%",
    height: "100%",
    borderRadius: 24,
  },
  coinCircle: {
    width: COIN_SLIDER_SIZE,
    height: COIN_SLIDER_SIZE,
    borderRadius: COIN_SLIDER_SIZE / 2,
    borderWidth: 3,
    backgroundColor: "#F6F8FC",
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden",
    shadowOpacity: 0.25,
    shadowRadius: 18,
    shadowOffset: { width: 0, height: 12 },
    elevation: 12,
  },
  coinInnerSurface: {
    width: COIN_SLIDER_SIZE - 24,
    height: COIN_SLIDER_SIZE - 24,
    borderRadius: (COIN_SLIDER_SIZE - 24) / 2,
    backgroundColor: "#ECEFF5",
    borderWidth: 2,
    borderColor: "rgba(255,255,255,0.8)",
    justifyContent: "center",
    alignItems: "center",
    overflow: "hidden",
  },
  coinFillTrack: {
    position: "absolute",
    bottom: 0,
    width: "100%",
    alignItems: "center",
  },
  coinFill: {
    width: "100%",
    borderTopLeftRadius: (COIN_SLIDER_SIZE - 24) / 2,
    borderTopRightRadius: (COIN_SLIDER_SIZE - 24) / 2,
  },
  coinShine: {
    position: "absolute",
    top: 18,
    left: 26,
    width: 86,
    height: 14,
    borderRadius: 14,
    opacity: 0.6,
  },
  coinCurrencySymbol: {
    fontSize: 48,
    fontWeight: "800",
    opacity: 0.2,
  },
  coinDirectionLabels: {
    flexDirection: "row",
    justifyContent: "space-between",
    width: "100%",
    paddingHorizontal: 16,
    marginTop: 12,
  },
  coinDirectionLabel: {
    fontSize: 13,
    fontWeight: "700",
    textTransform: "uppercase",
  },
  coinEntryActions: {
    flexDirection: "row",
    gap: 12,
    marginTop: 16,
  },
  coinEntryActionButton: {
    flex: 1,
    borderRadius: 20,
    paddingVertical: 14,
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "#000",
    shadowOpacity: 0.08,
    shadowRadius: 8,
    shadowOffset: { width: 0, height: 4 },
    elevation: 4,
  },
  coinEntryActionButtonSpend: {
    backgroundColor: COIN_ENTRY_SPEND_BACKGROUND,
  },
  coinEntryActionButtonSave: {
    backgroundColor: COIN_ENTRY_SAVE_BACKGROUND,
  },
  coinEntryActionButtonText: {
    fontSize: 16,
    fontWeight: "700",
  },
  coinEntryActionButtonTextSpend: {
    color: SPEND_ACTION_COLOR,
  },
  coinEntryActionButtonTextSave: {
    color: SAVE_ACTION_COLOR,
  },
  coinEntryHint: {
    ...createBodyText({ fontSize: 13 }),
  },
  coinEntryCategoryLabel: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 18,
  },
  coinEntryError: {
    fontSize: 12,
    fontWeight: "600",
  },
  coinEntryCategoryRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    gap: 10,
  },
  coinEntryCategoryButton: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 14,
    paddingHorizontal: 8,
    alignItems: "center",
    gap: 6,
  },
  coinEntryCategoryEmoji: {
    fontSize: 28,
  },
  coinEntryCategoryText: {
    fontSize: 12,
    fontWeight: "700",
    textAlign: "center",
  },
  coinEntryMaxLabel: {
    fontSize: 14,
    fontWeight: "600",
  },
  coinEntryManualBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.6)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  coinEntryManualCard: {
    width: "100%",
    maxWidth: 360,
    borderRadius: 28,
    padding: 20,
    borderWidth: 1,
    gap: 12,
  },
  coinEntryManualTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 20,
  },
  coinEntryManualInput: {
    borderWidth: 1,
    borderRadius: 16,
    paddingHorizontal: 14,
    paddingVertical: 10,
    fontSize: 18,
    fontWeight: "600",
  },
  coinEntryManualError: {
    fontSize: 12,
    fontWeight: "600",
  },
  coinEntryManualActions: {
    flexDirection: "row",
    gap: 12,
  },
  coinEntryManualButtonGhost: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 12,
    alignItems: "center",
  },
  coinEntryManualButtonGhostText: {
    fontWeight: "600",
  },
  coinEntryManualButtonPrimary: {
    flex: 1,
    borderRadius: 16,
    paddingVertical: 12,
    alignItems: "center",
  },
  coinEntryManualButtonPrimaryText: {
    ...createCtaText(),
  },
  termsCard: {
    width: "100%",
    borderRadius: 28,
    padding: 22,
    gap: 12,
  },
  termsTitle: {
    ...TYPOGRAPHY.blockTitle,
    textAlign: "center",
  },
  termsSubtitle: {
    ...createBodyText({ fontSize: 15, lineHeight: 22, textAlign: "center" }),
  },
  termsScroll: {
    maxHeight: 260,
    marginVertical: 4,
  },
  termsScrollContent: {
    paddingBottom: 4,
    gap: 12,
  },
  termsPoint: {
    flexDirection: "row",
    gap: 8,
  },
  termsPointIndex: {
    ...createCtaText({ fontSize: 13 }),
  },
  termsPointText: {
    ...createBodyText({ flex: 1, fontSize: 15, lineHeight: 22 }),
  },
  termsLinkButton: {
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 10,
    alignItems: "center",
  },
  termsLinkText: {
    ...createCtaText({ fontSize: 14 }),
  },
  termsHint: {
    ...createSecondaryText({ fontSize: 12, textAlign: "center" }),
  },
  languageMascot: {
    width: 220,
    height: 220,
    alignSelf: "center",
    marginBottom: 4,
  },
  confettiLayer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  overlayFullScreen: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
  },
  overlayTouchable: {
    ...StyleSheet.absoluteFillObject,
  },
  overlayDim: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(5, 6, 15, 0.2)",
  },
  celebrationBanner: {
    position: "absolute",
    top: "35%",
    paddingHorizontal: 28,
    paddingVertical: 20,
    borderRadius: 30,
    alignItems: "center",
    gap: 12,
  },
  celebrationText: {
    fontWeight: "700",
    fontSize: 18,
    textAlign: "center",
  },
  celebrationSubtext: {
    fontWeight: "600",
    fontSize: 14,
    textAlign: "center",
  },
  focusDigestCard: {
    width: "86%",
    borderRadius: 30,
    borderWidth: 1,
    padding: 24,
    gap: 14,
  },
  focusDigestTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 22,
    textAlign: "center",
  },
  focusDigestBody: {
    ...createBodyText({ fontSize: 15, lineHeight: 22 }),
    textAlign: "center",
  },
  focusDigestStats: {
    flexDirection: "row",
    gap: 12,
  },
  focusDigestStat: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 18,
    padding: 12,
    gap: 4,
  },
  focusDigestLabel: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase" }),
  },
  focusDigestValue: {
    ...createBodyText({ fontSize: 15, fontWeight: "700" }),
  },
  focusDigestHint: {
    ...createSecondaryText({ fontSize: 12 }),
  },
  focusDigestButtons: {
    flexDirection: "row",
    gap: 12,
    marginTop: 6,
  },
  focusDigestPrimary: {
    flex: 1,
    borderRadius: 16,
    paddingVertical: 12,
    paddingHorizontal: 12,
    alignItems: "center",
  },
  focusDigestPrimaryText: {
    ...createCtaText({ fontSize: 12 }),
  },
  focusDigestSecondary: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 12,
    paddingHorizontal: 12,
    alignItems: "center",
  },
  focusDigestSecondaryText: {
    ...createCtaText({ fontSize: 12 }),
  },
  focusRewardCard: {
    width: "82%",
    borderRadius: 30,
    borderWidth: 1,
    padding: 24,
    gap: 14,
    alignItems: "center",
  },
  focusRewardIconRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  focusRewardCoin: {
    width: 48,
    height: 48,
  },
  focusRewardAmount: {
    ...createCtaText({ fontSize: 24 }),
  },
  focusRewardTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 24,
    textAlign: "center",
  },
  focusRewardBody: {
    ...createBodyText({ fontSize: 15, lineHeight: 22 }),
    textAlign: "center",
  },
  focusRewardButton: {
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 24,
    paddingVertical: 10,
  },
  focusRewardButtonText: {
    ...createCtaText({ fontSize: 14 }),
  },
  impulseCategoryPicker: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
  },
  impulseCategoryPickerCompact: {
    marginTop: 2,
  },
  impulseCategoryChip: {
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 6,
    paddingHorizontal: 12,
  },
  impulseCategoryChipCompact: {
    paddingVertical: 4,
    paddingHorizontal: 10,
  },
  impulseCategoryChipText: {
    ...createCtaText({ fontSize: 12 }),
  },
  impulseAlertCard: {
    marginHorizontal: 24,
    borderRadius: 28,
    borderWidth: 1,
    overflow: "hidden",
    position: "relative",
  },
  impulseAlertGlow: {
    ...StyleSheet.absoluteFillObject,
    opacity: 0.18,
  },
  impulseAlertContent: {
    padding: 24,
    gap: 16,
    position: "relative",
  },
  impulseAlertHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  impulseAlertBadge: {
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 999,
    borderWidth: 1,
  },
  impulseAlertBadgeText: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase" }),
  },
  impulseAlertEmoji: {
    fontSize: 28,
  },
  impulseAlertTitle: {
    ...TYPOGRAPHY.blockTitle,
  },
  impulseAlertBody: {
    ...createBodyText({ fontSize: 15, lineHeight: 22 }),
  },
  impulseAlertStats: {
    flexDirection: "row",
    gap: 12,
  },
  impulseAlertStat: {
    flex: 1,
    borderRadius: 18,
    padding: 14,
    borderWidth: 1,
  },
  impulseAlertStatLabel: {
    ...createCtaText({ fontSize: 11, textTransform: "uppercase" }),
  },
  impulseAlertStatValue: {
    ...createBodyText({ fontSize: 18, fontWeight: "800", marginTop: 6 }),
  },
  impulseAlertMoodCard: {
    borderRadius: 18,
    borderWidth: 1,
    padding: 12,
  },
  impulseAlertMood: {
    ...createBodyText({ fontSize: 14, lineHeight: 20 }),
  },
  impulseAlertButton: {
    borderRadius: 16,
    paddingVertical: 13,
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "row",
    gap: 8,
  },
  impulseAlertButtonText: {
    ...createCtaText({ fontSize: 15 }),
  },
  impulseAlertButtonIcon: {
    ...createCtaText({ fontSize: 16 }),
  },
  celebrationCat: {
    width: 90,
    height: 90,
    borderRadius: 18,
    opacity: 0.9,
  },
  catHappy: {
    transform: [{ scale: 1.05 }],
  },
  catSad: {
    opacity: 0.7,
  },
  levelOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
  },
  levelBackdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(255,247,214,0.95)",
  },
  levelContent: {
    padding: 28,
    borderRadius: 32,
    backgroundColor: "rgba(255,255,255,0.95)",
    borderWidth: 2,
    borderColor: "rgba(255,186,0,0.4)",
    alignItems: "center",
    gap: 12,
  },
  levelTitle: {
    ...TYPOGRAPHY.display,
    fontSize: 32,
  },
  levelSubtitle: {
    ...createBodyText({ fontSize: 16, fontWeight: "700", textAlign: "center" }),
  },
  levelShareButton: {
    borderRadius: 999,
    paddingVertical: 10,
    paddingHorizontal: 26,
    marginTop: 8,
  },
  levelShareButtonText: {
    ...createCtaText({ fontSize: 14 }),
  },
  rewardOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
  },
  rewardBackdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(255,241,225,0.92)",
  },
  rewardCard: {
    paddingVertical: 30,
    paddingHorizontal: 24,
    borderRadius: 36,
    alignItems: "center",
    width: OVERLAY_CARD_MAX_WIDTH,
    maxWidth: OVERLAY_CARD_MAX_WIDTH,
    borderWidth: 2,
    borderColor: "rgba(255,181,115,0.7)",
    gap: 12,
  },
  rewardCat: {
    width: 140,
    height: 140,
    marginBottom: 8,
  },
  rewardTitle: {
    fontSize: 22,
    fontWeight: "800",
    textAlign: "center",
  },
  rewardSubtitle: {
    fontSize: 16,
    fontWeight: "600",
    textAlign: "center",
  },
  healthOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
  },
  healthBackdrop: {
    ...StyleSheet.absoluteFillObject,
  },
  healthHeartWrap: {
    width: 220,
    height: 220,
    borderRadius: 110,
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 20,
  },
  healthCoinImage: {
    width: 140,
    height: 140,
    resizeMode: "contain",
  },
  healthCard: {
    paddingHorizontal: 24,
    paddingVertical: 24,
    borderRadius: 30,
    borderWidth: 1,
    alignItems: "center",
    width: OVERLAY_CARD_MAX_WIDTH,
    maxWidth: OVERLAY_CARD_MAX_WIDTH,
  },
  healthTitle: {
    fontSize: 24,
    fontWeight: "800",
    textAlign: "center",
  },
  healthSubtitle: {
    fontSize: 16,
    marginTop: 8,
    textAlign: "center",
  },
  goalCelebrateOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
  },
  goalCelebrateBackdrop: {
    ...StyleSheet.absoluteFillObject,
  },
  goalCelebrateCard: {
    paddingVertical: 36,
    paddingHorizontal: 26,
    borderRadius: 34,
    borderWidth: 2,
    alignItems: "center",
    width: OVERLAY_CARD_MAX_WIDTH,
    maxWidth: OVERLAY_CARD_MAX_WIDTH,
    gap: 12,
  },
  goalCelebrateCat: {
    width: 120,
    height: 120,
  },
  goalCelebrateTitle: {
    fontSize: 24,
    fontWeight: "900",
    textAlign: "center",
  },
  goalCelebrateSubtitle: {
    fontSize: 16,
    fontWeight: "600",
    textAlign: "center",
  },
  goalCelebrateTarget: {
    fontSize: 15,
    fontWeight: "700",
  },
  rewardHeart: {
    position: "absolute",
    bottom: 40,
    fontSize: 22,
    textShadowColor: "rgba(0,0,0,0.35)",
    textShadowRadius: 6,
  },
  levelCoin: {
    position: "absolute",
    borderRadius: 999,
    backgroundColor: "#FFD93D",
  },
  saveOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: "center",
    alignItems: "center",
  },
  saveCard: {
    backgroundColor: "rgba(255,255,255,0.96)",
    borderRadius: 24,
    padding: 18,
    alignItems: "center",
    gap: 10,
    borderWidth: 1,
    borderColor: "rgba(18,15,40,0.08)",
    marginHorizontal: 24,
    shadowColor: "#000",
    shadowOpacity: 0.12,
    shadowRadius: 18,
    shadowOffset: { width: 0, height: 12 },
  },
  saveGif: {
    width: 96,
    height: 96,
    borderRadius: 22,
    resizeMode: "contain",
  },
  saveTitle: {
    fontSize: 18,
    fontWeight: "800",
    textAlign: "center",
  },
  saveGoalText: {
    fontSize: 16,
    fontWeight: "700",
    textAlign: "center",
  },
  saveGoalBox: {
    backgroundColor: "rgba(18,15,40,0.04)",
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "rgba(18,15,40,0.05)",
    marginTop: 4,
  },
  saveCoinsRow: {
    marginTop: 4,
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
    borderRadius: 14,
    backgroundColor: "rgba(33, 150, 243, 0.08)",
  },
  saveCoinsText: {
    fontSize: 14,
    fontWeight: "700",
  },
  saveCoinIcon: {
    width: 24,
    height: 24,
    resizeMode: "contain",
  },
  customTemptationCard: {
    backgroundColor: "rgba(255,255,255,0.95)",
    borderRadius: 24,
    paddingVertical: 28,
    paddingHorizontal: 24,
    alignItems: "center",
    gap: 16,
    borderWidth: 1,
    borderColor: "rgba(18,15,40,0.08)",
    marginHorizontal: 24,
  },
  customTemptationGif: {
    width: 160,
    height: 160,
    borderRadius: 32,
    resizeMode: "contain",
  },
  customTemptationText: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 18,
    textAlign: "center",
  },
  rainLayer: {
    ...StyleSheet.absoluteFillObject,
  },
  rainDrop: {
    width: 2,
    borderRadius: 1,
    position: "absolute",
    top: 0,
  },
  sheetBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.35)",
    justifyContent: "flex-end",
  },
  sheetCard: {
    borderTopLeftRadius: 28,
    borderTopRightRadius: 28,
    paddingHorizontal: 24,
    paddingTop: 16,
    paddingBottom: 36,
    gap: 14,
  },
  sheetHandle: {
    width: 60,
    height: 4,
    borderRadius: 2,
    alignSelf: "center",
    marginBottom: 6,
  },
  sheetTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 20,
    textAlign: "center",
  },
  sheetSubtitle: {
    ...createBodyText({ fontSize: 15, textAlign: "center" }),
  },
  sheetButton: {
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
  },
  sheetCancel: {
    ...createCtaText({ textAlign: "center", marginTop: 4 }),
  },
  priceModalBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.35)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  priceModalCard: {
    width: "100%",
    borderRadius: 28,
    padding: 20,
    gap: 16,
  },
  priceModalTitle: {
    ...TYPOGRAPHY.blockTitle,
    fontSize: 20,
    textAlign: "center",
  },
  priceModalLabel: {
    ...createCtaText({ fontSize: 12, textTransform: "uppercase", marginTop: 12, marginBottom: 4 }),
  },
  priceModalInput: {
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 16,
    paddingVertical: 10,
    fontSize: 18,
    textAlign: "center",
  },
  priceModalInputCompact: {
    borderWidth: 1,
    borderRadius: 14,
    paddingHorizontal: 12,
    paddingVertical: 8,
    fontSize: 16,
    textAlign: "left",
  },
  goalPickerButton: {
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 12,
    paddingHorizontal: 16,
  },
  goalPickerButtonText: {
    ...createCtaText({ fontSize: 15 }),
  },
  goalPickerReset: {
    marginTop: 6,
  },
  goalPickerResetText: {
    ...createSecondaryText({ fontSize: 13 }),
  },
  temptationEditOverlay: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    zIndex: 400,
    justifyContent: "center",
    alignItems: "center",
  },
  temptationEditBackdrop: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    backgroundColor: "#05060F",
  },
  temptationEditCardContainer: {
    width: "86%",
    maxWidth: 360,
    paddingHorizontal: 0,
    paddingTop: 0,
  },
  temptationOverlayCard: {
    width: "100%",
    alignSelf: "center",
    paddingHorizontal: 16,
    paddingVertical: 16,
    borderRadius: 24,
  },
  priceModalButtons: {
    gap: 10,
  },
  priceModalPrimary: {
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
  },
  priceModalPrimaryText: {
    fontWeight: "700",
  },
  priceModalSecondary: {
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
    borderWidth: 1,
  },
  priceModalSecondaryText: {
    fontWeight: "600",
  },
  priceModalCancel: {
    textAlign: "center",
    fontWeight: "600",
    marginTop: 4,
  },
  priceModalDeleteText: {
    textAlign: "center",
    fontWeight: "700",
    marginTop: 10,
  },
  goalModalCard: {
    width: "100%",
    borderRadius: 28,
    padding: 20,
    gap: 10,
  },
  goalModalTitle: {
    fontSize: 20,
    fontWeight: "700",
    textAlign: "center",
  },
  goalModalSubtitle: {
    fontSize: 14,
    lineHeight: 20,
    textAlign: "center",
  },
  goalOptionButton: {
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 12,
    paddingHorizontal: 16,
    marginTop: 10,
  },
  goalOptionTitle: {
    fontSize: 16,
    fontWeight: "600",
  },
  goalOptionSubtitle: {
    fontSize: 13,
    marginTop: 2,
  },
  goalRenewalBackdrop: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.45)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  goalRenewalCard: {
    width: "100%",
    borderRadius: 32,
    borderWidth: 1,
    padding: 24,
    gap: 12,
  },
  goalRenewalTitle: {
    ...TYPOGRAPHY.blockTitle,
    textAlign: "center",
  },
  goalRenewalSubtitle: {
    ...createBodyText({ fontSize: 16, textAlign: "center", lineHeight: 22 }),
  },
  goalRenewalActions: {
    flexDirection: "row",
    gap: 12,
    marginTop: 8,
  },
  goalRenewalSecondary: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
  },
  goalRenewalSecondaryText: {
    ...createCtaText({ fontSize: 15 }),
  },
  goalRenewalPrimary: {
    flex: 1,
    borderRadius: 18,
    paddingVertical: 12,
    alignItems: "center",
  },
  goalRenewalPrimaryText: {
    ...createCtaText({ fontSize: 15 }),
  },
  onboardContainer: {
    flex: 1,
    paddingHorizontal: BASE_HORIZONTAL_PADDING,
    paddingTop: 40,
    gap: 20,
  },
  onboardContent: {
    gap: 16,
    paddingBottom: 60,
  },
  onboardTitle: {
    ...TYPOGRAPHY.display,
  },
  onboardSubtitle: {
    ...createBodyText({ fontSize: 16, lineHeight: 22 }),
  },
  avatarPreview: {
    borderWidth: 1,
    borderRadius: 24,
    padding: 16,
    alignItems: "center",
  },
  primaryInput: {
    borderWidth: 1,
    borderRadius: 18,
    paddingHorizontal: 16,
    paddingVertical: 12,
    fontSize: 16,
  },
  baselineInputGroup: {
    marginTop: 8,
    gap: 4,
  },
  baselineHint: {
    ...createSecondaryText({ fontSize: 14, lineHeight: 20 }),
  },
  avatarImage: {
    width: 120,
    height: 120,
    borderRadius: 60,
    marginBottom: 8,
  },
  avatarPlaceholder: {
    width: 120,
    height: 120,
    borderRadius: 60,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 8,
  },
  currencyLabel: {
    fontSize: 14,
    textTransform: "uppercase",
    marginTop: 4,
  },
  currencyScrollWrapper: {
    marginTop: 12,
    position: "relative",
    marginRight: -32,
    paddingRight: 32,
  },
    currencyScroll: {
    marginTop: 0,
  },
  currencyScrollContent: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    paddingRight: 12,
  },
  currencyScrollFadeWrapper: {
    position: "absolute",
    right: 0,
    top: 0,
    bottom: 0,
    width: 40,
  },
  currencyScrollFade: {
    height: "100%",
  },
  currencyChipLarge: {
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 8,
    paddingHorizontal: 12,
  },
  goalGrid: {
    flex: 1,
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 12,
  },
  goalCustomSectionTitle: {
    ...createCtaText({ fontSize: 14, textTransform: "uppercase", marginTop: 16 }),
  },
  goalCustomButton: {
    borderWidth: 1,
    borderRadius: 22,
    paddingVertical: 14,
    alignItems: "center",
    marginTop: 16,
  },
  goalCustomButtonText: {
    ...createCtaText({ fontSize: 14 }),
  },
  goalOption: {
    width: "48%",
    borderWidth: 1,
    borderRadius: 22,
    padding: 16,
    alignItems: "center",
    gap: 8,
  },
  personaGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 12,
  },
  personaCard: {
    width: "48%",
    borderWidth: 1,
    borderRadius: 22,
    padding: 16,
    gap: 6,
  },
  personaEmoji: {
    fontSize: 24,
  },
  personaTitle: {
    ...createBodyText({ fontWeight: "700", fontSize: 15 }),
  },
  personaSubtitleCard: {
    ...createBodyText({ fontSize: 14, lineHeight: 20 }),
  },
  goalEmoji: {
    fontSize: 28,
  },
  goalText: {
    ...createBodyText({ fontWeight: "600", textAlign: "center" }),
  },
  languageButtons: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 10,
  },
  languageTermsBlock: {
    width: "100%",
    marginTop: 12,
    gap: 6,
  },
  languageTermsNote: {
    ...createSecondaryText({ fontSize: 12, lineHeight: 16 }),
  },
  languageTermsButton: {
    borderWidth: 1,
    borderRadius: 16,
    paddingVertical: 10,
    alignItems: "center",
  },
  languageTermsButtonText: {
    ...createCtaText({ fontSize: 13 }),
  },
  genderGrid: {
    flexDirection: "row",
    justifyContent: "space-between",
    gap: 12,
  },
  genderChip: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 20,
    paddingVertical: 12,
    alignItems: "center",
    gap: 6,
  },
  genderEmoji: {
    fontSize: 20,
  },
  genderLabel: {
    ...createBodyText({ fontWeight: "600" }),
  },
  languageButton: {
    flexGrow: 1,
    width: "48%",
    borderWidth: 1,
    borderRadius: 20,
    paddingVertical: 18,
    paddingHorizontal: 12,
    alignItems: "center",
  },
  onboardBackButton: {
    flexDirection: "row",
    alignItems: "center",
    alignSelf: "flex-start",
    borderWidth: 1,
    borderRadius: 999,
    paddingHorizontal: 14,
    paddingVertical: 6,
    gap: 6,
    marginBottom: 12,
  },
  onboardBackIcon: {
    fontSize: 14,
  },
  onboardBackLabel: {
    ...createCtaText({ fontSize: 13 }),
  },
  languageHint: {
    ...createSecondaryText({ marginTop: 6, fontSize: 12 }),
  },
  goalTargetHint: {
    ...createSecondaryText({ fontSize: 13, marginTop: 8, marginBottom: 22 }),
  },
  logoSplashOverlay: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    zIndex: 1000,
  },
  logoSplash: {
    flex: 1,
    backgroundColor: "#fff",
    justifyContent: "center",
    alignItems: "center",
  },
  logoSplashText: {
    ...TYPOGRAPHY.logo,
    fontSize: 48,
    letterSpacing: -0.5,
    color: "#111",
  },
});
function ImageSourceSheet({ visible, colors, t, onClose, onSelect }) {
  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onClose}
      statusBarTranslucent
    >
      <TouchableWithoutFeedback onPress={onClose}>
        <View style={styles.sheetBackdrop}>
          <TouchableWithoutFeedback onPress={() => {}}>
            <View style={[styles.sheetCard, { backgroundColor: colors.card }] }>
              <View style={[styles.sheetHandle, { backgroundColor: colors.border }]} />
              <Text style={[styles.sheetTitle, { color: colors.text }]}>{t("photoPromptTitle")}</Text>
              <Text style={[styles.sheetSubtitle, { color: colors.muted }]}>{t("photoPromptSubtitle")}</Text>
              <TouchableOpacity
                style={[styles.sheetButton, { borderColor: colors.border }]}
                onPress={() => onSelect("library")}
              >
                <Text style={{ color: colors.text }}>{t("photoLibrary")}</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.sheetButton, { borderColor: colors.border }]}
                onPress={() => onSelect("camera")}
              >
                <Text style={{ color: colors.text }}>{t("photoCamera")}</Text>
              </TouchableOpacity>
              <TouchableOpacity onPress={onClose}>
                <Text style={[styles.sheetCancel, { color: colors.muted }]}>{t("profileCancel")}</Text>
              </TouchableOpacity>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
}

function RegistrationScreen({
  data,
  onChange,
  onSubmit,
  onPickImage,
  colors,
  t,
  onBack,
  mascotImageSource,
}) {
  const fallbackAvatar = mascotImageSource || CLASSIC_TAMAGOTCHI_ANIMATIONS.idle;
  const fade = useFadeIn();

  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView
        contentContainerStyle={styles.onboardContent}
        showsVerticalScrollIndicator={false}
        keyboardShouldPersistTaps="handled"
      >
        <OnboardingBackButton onPress={onBack} colors={colors} t={t} />
        <Text style={[styles.onboardTitle, { color: colors.text }]}>{t("registrationTitle")}</Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("registrationSubtitle")}</Text>

        <TouchableOpacity
          style={[styles.avatarPreview, { borderColor: colors.border }]}
          onPress={() => onPickImage?.()}
        >
          {data.avatar ? (
            <Image source={{ uri: data.avatar }} style={styles.avatarImage} />
          ) : (
            <Image source={fallbackAvatar} style={styles.avatarImage} />
          )}
          <Text style={{ color: colors.muted }}>{t("photoTapHint")}</Text>
        </TouchableOpacity>

      <View style={styles.inputRow}>
        <TextInput
          style={[
            styles.profileInput,
            styles.profileInputHalf,
            { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
          ]}
          placeholder={t("inputFirstName")}
          placeholderTextColor={colors.muted}
          value={data.firstName}
          onChangeText={(text) => onChange("firstName", text)}
        />
        <TextInput
          style={[
            styles.profileInput,
            styles.profileInputHalf,
            { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
          ]}
          placeholder={t("inputLastName")}
          placeholderTextColor={colors.muted}
          value={data.lastName}
          onChangeText={(text) => onChange("lastName", text)}
        />
      </View>

        <TextInput
          style={[
            styles.profileInput,
            { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
          ]}
          placeholder={t("inputMotto")}
          placeholderTextColor={colors.muted}
          value={data.motto}
          onChangeText={(text) => onChange("motto", text)}
        />

        <TouchableOpacity style={[styles.primaryButton, { backgroundColor: colors.text }]} onPress={onSubmit}>
          <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("nextButton")}</Text>
        </TouchableOpacity>
      </ScrollView>
    </Animated.View>
  );
}

function GoalScreen({
  selectedGoals = [],
  onToggle,
  onSubmit,
  colors,
  t,
  language,
  onBack,
  customGoals = [],
  onCustomGoalCreate,
}) {
  const fade = useFadeIn();
  const selection = Array.isArray(selectedGoals) ? selectedGoals : [];
  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView contentContainerStyle={styles.onboardContent} showsVerticalScrollIndicator={false}>
        <OnboardingBackButton onPress={onBack} colors={colors} t={t} />
        <Text style={[styles.onboardTitle, { color: colors.text }]}>{t("goalTitle")}</Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("goalSubtitle")}</Text>

        <View style={styles.goalGrid}>
          {GOAL_PRESETS.map((goal) => {
            const active = selection.includes(goal.id);
            return (
              <TouchableOpacity
                key={goal.id}
                style={[
                  styles.goalOption,
                  {
                    borderColor: colors.border,
                    backgroundColor: active ? colors.card : "transparent",
                  },
                ]}
                onPress={() => onToggle?.(goal.id)}
              >
                <Text style={styles.goalEmoji}>{goal.emoji}</Text>
                <Text style={[styles.goalText, { color: colors.text }]}>
                  {goal[language] || goal.en}
                </Text>
              </TouchableOpacity>
            );
          })}
        </View>

        {customGoals.length > 0 && (
          <>
            <Text style={[styles.goalCustomSectionTitle, { color: colors.muted }]}>
              {t("goalCustomSectionTitle")}
            </Text>
            <View style={styles.goalGrid}>
              {customGoals.map((goal) => {
                const active = selection.includes(goal.id);
                return (
                  <TouchableOpacity
                    key={goal.id}
                    style={[
                      styles.goalOption,
                      {
                        borderColor: colors.border,
                        backgroundColor: active ? colors.card : "transparent",
                      },
                    ]}
                    onPress={() => onToggle?.(goal.id)}
                  >
                    <Text style={styles.goalEmoji}>{goal.emoji || "üéØ"}</Text>
                    <Text style={[styles.goalText, { color: colors.text }]}>{goal.title}</Text>
                  </TouchableOpacity>
                );
              })}
            </View>
          </>
        )}

        {onCustomGoalCreate && (
          <TouchableOpacity
            style={[styles.goalCustomButton, { borderColor: colors.border }]}
            onPress={onCustomGoalCreate}
          >
            <Text style={[styles.goalCustomButtonText, { color: colors.text }]}>
              {t("goalCustomCreate")}
            </Text>
          </TouchableOpacity>
        )}

        <TouchableOpacity style={[styles.primaryButton, { backgroundColor: colors.text }]} onPress={onSubmit}>
          <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("goalButton")}</Text>
        </TouchableOpacity>
      </ScrollView>
    </Animated.View>
  );
}

function GoalTargetScreen({
  selections = [],
  values = {},
  currency,
  onChange,
  onSubmit,
  onBack,
  colors,
  t,
  language,
  customGoals = [],
}) {
  const fade = useFadeIn();
  const selectionList = Array.isArray(selections) ? selections : [];
  const customGoalMap = useMemo(() => {
    const entries = Array.isArray(customGoals) ? customGoals : [];
    return entries.reduce((acc, goal) => {
      acc[goal.id] = goal;
      return acc;
    }, {});
  }, [customGoals]);
  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView contentContainerStyle={styles.onboardContent} showsVerticalScrollIndicator={false} keyboardShouldPersistTaps="handled">
        <OnboardingBackButton onPress={onBack} colors={colors} t={t} />
        <Text style={[styles.onboardTitle, { color: colors.text }]}>{t("goalTargetTitle")}</Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("goalTargetSubtitle")}</Text>
        {selectionList.map((goalId) => {
          const preset = getGoalPreset(goalId);
          const customGoal = customGoalMap[goalId];
          const goalLabel =
            customGoal?.title || preset?.[language] || preset?.en || goalId;
          return (
            <View key={goalId} style={styles.goalTargetRow}>
              <Text style={[styles.goalTargetLabel, { color: colors.muted }]}>{goalLabel}</Text>
              <View
                style={[
                  styles.goalTargetInputWrap,
                  { borderColor: colors.border, backgroundColor: colors.card },
                ]}
              >
                <TextInput
                  style={[styles.goalTargetInput, { color: colors.text }]}
                  placeholder={t("goalTargetPlaceholder")}
                  placeholderTextColor={colors.muted}
                  keyboardType="decimal-pad"
                  value={values[goalId] || ""}
                  onChangeText={(text) => onChange?.(goalId, text)}
                />
                <Text style={[styles.goalTargetCurrency, { color: colors.muted }]}>{currency}</Text>
              </View>
            </View>
          );
        })}
        <Text style={[styles.goalTargetHint, { color: colors.muted }]}>{t("goalTargetHint")}</Text>
        <TouchableOpacity style={[styles.primaryButton, { backgroundColor: colors.text }]} onPress={onSubmit}>
          <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("goalTargetCTA")}</Text>
        </TouchableOpacity>
      </ScrollView>
    </Animated.View>
  );
}

function AnalyticsConsentScreen({ colors, t, onSubmit, onBack }) {
  return (
    <View style={[styles.analyticsConsentScreen, { backgroundColor: colors.background }]}>
      <OnboardingBackButton onPress={onBack} colors={colors} t={t} />
      <View
        style={[
          styles.analyticsConsentCard,
          { backgroundColor: colors.card, borderColor: colors.border },
        ]}
      >
        <Text style={[styles.analyticsConsentTitle, { color: colors.text }]}>
          {t("analyticsConsentTitle")}
        </Text>
        <Text style={[styles.analyticsConsentBody, { color: colors.muted }]}>
          {t("analyticsConsentBody")}
        </Text>
        <TouchableOpacity
          style={[styles.analyticsConsentPrimary, { backgroundColor: colors.text }]}
          onPress={() => onSubmit(true)}
        >
          <Text style={[styles.analyticsConsentPrimaryText, { color: colors.background }]}>
            {t("analyticsConsentAgree")}
          </Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.analyticsConsentSecondary, { borderColor: colors.border }]}
          onPress={() => onSubmit(false)}
        >
          <Text style={[styles.analyticsConsentSecondaryText, { color: colors.muted }]}>
            {t("analyticsConsentSkip")}
          </Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}

function SpendingBaselineScreen({ value, currency, onChange, onSubmit, colors, t, onBack }) {
  const fade = useFadeIn();
  const baselineSampleLabel = formatSampleAmount(BASELINE_SAMPLE_USD, currency || DEFAULT_PROFILE.currency);
  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView contentContainerStyle={styles.onboardContent} showsVerticalScrollIndicator={false} keyboardShouldPersistTaps="handled">
        <OnboardingBackButton onPress={onBack} colors={colors} t={t} />
        <Text style={[styles.onboardTitle, { color: colors.text }]}>{t("baselineTitle")}</Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("baselineSubtitle")}</Text>
        <View style={styles.baselineInputGroup}>
          <TextInput
            style={[
              styles.primaryInput,
              { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
            ]}
            placeholder={t("baselinePlaceholder", { amount: baselineSampleLabel })}
            placeholderTextColor={colors.muted}
            keyboardType="decimal-pad"
            value={value}
            onChangeText={onChange}
          />
        </View>
        <Text style={[styles.baselineHint, { color: colors.muted }]}>{t("baselineHint")}</Text>
        <TouchableOpacity style={[styles.primaryButton, { backgroundColor: colors.text }]} onPress={onSubmit}>
          <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("baselineCTA")}</Text>
        </TouchableOpacity>
      </ScrollView>
    </Animated.View>
  );
}

function PersonaScreen({ data, onChange, onSubmit, colors, t, language, onBack }) {
  const fade = useFadeIn();
  const personaList = Object.values(PERSONA_PRESETS);
  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView contentContainerStyle={styles.onboardContent} showsVerticalScrollIndicator={false}>
        <OnboardingBackButton onPress={onBack} colors={colors} t={t} />
        <Text style={[styles.onboardTitle, { color: colors.text }]}>{t("personaTitle")}</Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("personaSubtitle")}</Text>

        <Text style={[styles.currencyLabel, { color: colors.muted }]}>{t("personaGenderLabel")}</Text>
        <View style={styles.genderGrid}>
          {GENDER_OPTIONS.map((option) => {
            const active = option.id === data.gender;
            return (
              <TouchableOpacity
                key={option.id}
                style={[
                  styles.genderChip,
                  {
                    borderColor: colors.border,
                    backgroundColor: active ? colors.card : "transparent",
                  },
                ]}
                onPress={() => onChange("gender", option.id)}
              >
                <Text style={styles.genderEmoji}>{option.emoji}</Text>
                <Text style={[styles.genderLabel, { color: colors.text }]}>
                  {option.label[language] || option.label.en}
                </Text>
              </TouchableOpacity>
            );
          })}
        </View>

        <Text style={[styles.currencyLabel, { color: colors.muted, marginTop: 16 }]}>
          {t("personaHabitLabel")}
        </Text>
        <View style={styles.personaGrid}>
          {personaList.map((persona) => {
            const active = data.persona === persona.id;
            return (
              <TouchableOpacity
                key={persona.id}
                style={[
                  styles.personaCard,
                  {
                    borderColor: colors.border,
                    backgroundColor: active ? colors.card : "transparent",
                  },
                ]}
                onPress={() => onChange("persona", persona.id)}
              >
                <Text style={styles.personaEmoji}>{persona.emoji}</Text>
                <Text style={[styles.personaTitle, { color: colors.text }]}>
                  {persona.title[language] || persona.title.en}
                </Text>
                <Text style={[styles.personaSubtitleCard, { color: colors.muted }]}>
                  {persona.description[language] || persona.description.en}
                </Text>
              </TouchableOpacity>
            );
          })}
        </View>

        <TouchableOpacity style={[styles.primaryButton, { backgroundColor: colors.text }]} onPress={onSubmit}>
          <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("personaConfirm")}</Text>
        </TouchableOpacity>
      </ScrollView>
    </Animated.View>
  );
}

function CustomHabitScreen({ data, onChange, onSubmit, colors, t, currency, onBack, language }) {
  const fade = useFadeIn();
  const customSpendSampleLabel = formatSampleAmount(CUSTOM_SPEND_SAMPLE_USD, currency || DEFAULT_PROFILE.currency);
  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView contentContainerStyle={styles.onboardContent} showsVerticalScrollIndicator={false}>
        <OnboardingBackButton onPress={onBack} colors={colors} t={t} />
        <Text style={[styles.onboardTitle, { color: colors.text }]}>{t("customSpendTitle")}</Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("customSpendSubtitle")}</Text>

        <TextInput
          style={[
            styles.primaryInput,
            { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
          ]}
          placeholder={t("customSpendNamePlaceholder")}
          placeholderTextColor={colors.muted}
          value={data.customSpendTitle}
          onChangeText={(text) => onChange("customSpendTitle", text)}
        />
        <View style={{ gap: 6 }}>
          <Text style={[styles.currencyLabel, { color: colors.muted }]}>{t("customSpendAmountLabel")}</Text>
          <TextInput
            style={[
              styles.primaryInput,
              { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
            ]}
            placeholder={t("customSpendAmountPlaceholder", { amount: customSpendSampleLabel })}
            placeholderTextColor={colors.muted}
            keyboardType="decimal-pad"
            value={data.customSpendAmount}
            onChangeText={(text) => onChange("customSpendAmount", text)}
          />
        </View>
        <View style={{ gap: 6 }}>
          <Text style={[styles.currencyLabel, { color: colors.muted }]}>{t("customSpendFrequencyLabel")}</Text>
          <TextInput
            style={[
              styles.primaryInput,
              { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
            ]}
            placeholder={t("customSpendFrequencyPlaceholder")}
            placeholderTextColor={colors.muted}
            keyboardType="number-pad"
            value={data.customSpendFrequency}
            onChangeText={(text) => onChange("customSpendFrequency", text)}
          />
        </View>
        <View style={{ gap: 6 }}>
          <Text style={[styles.currencyLabel, { color: colors.muted }]}>{t("impulseCategoryLabel")}</Text>
          <ImpulseCategorySelector
            value={data.customSpendCategory || DEFAULT_IMPULSE_CATEGORY}
            onChange={(cat) => onChange("customSpendCategory", cat)}
            colors={colors}
            language={language}
          />
        </View>
        <Text style={{ color: colors.muted }}>{t("customSpendHint")}</Text>

        <TouchableOpacity style={[styles.primaryButton, { backgroundColor: colors.text }]} onPress={() => onSubmit(false)}>
          <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("personaConfirm")}</Text>
        </TouchableOpacity>
        <TouchableOpacity style={styles.secondaryButtonClear} onPress={() => onSubmit(true)}>
          <Text style={[styles.secondaryButtonClearText, { color: colors.muted }]}>{t("customSpendSkip")}</Text>
        </TouchableOpacity>
      </ScrollView>
    </Animated.View>
  );
}

function ImpulseCategorySelector({ value, onChange, colors, language, compact = false }) {
  const selected = value && IMPULSE_CATEGORY_DEFS[value] ? value : DEFAULT_IMPULSE_CATEGORY;
  return (
    <View
      style={[
        styles.impulseCategoryPicker,
        compact && styles.impulseCategoryPickerCompact,
      ]}
    >
      {IMPULSE_CATEGORY_ORDER.map((categoryId) => {
        const active = selected === categoryId;
        return (
          <TouchableOpacity
            key={categoryId}
            style={[
              styles.impulseCategoryChip,
              compact && styles.impulseCategoryChipCompact,
              {
                borderColor: active ? colors.text : colors.border,
                backgroundColor: active ? colors.text : "transparent",
              },
            ]}
            onPress={() => onChange?.(categoryId)}
            activeOpacity={0.85}
          >
            <Text
              style={[
                styles.impulseCategoryChipText,
                { color: active ? colors.background : colors.text },
              ]}
            >
              {getImpulseCategoryLabel(categoryId, language)}
            </Text>
          </TouchableOpacity>
        );
      })}
    </View>
  );
}

function CoinEntryModal({
  visible,
  colors,
  t,
  currency,
  language,
  maxAmountUSD = DEFAULT_COIN_SLIDER_MAX_USD,
  onUpdateMaxUSD,
  onSubmit,
  onCancel,
}) {
  const [sliderValue, setSliderValue] = useState(0.25);
  const [trackHeight, setTrackHeight] = useState(260);
  const [selectedCategory, setSelectedCategory] = useState(null);
  const [categoryError, setCategoryError] = useState(false);
  const [manualMode, setManualMode] = useState(null);
  const [manualValue, setManualValue] = useState("");
  const [manualError, setManualError] = useState("");
  const [manualExactLocal, setManualExactLocal] = useState(null);
  const directionAnim = useRef(new Animated.Value(0)).current;
  const sliderValueRef = useRef(0.25);
  const sliderValueCommitRef = useRef(0.25);
  const sliderValueThrottleRef = useRef(0);
  const hapticStepRef = useRef(0);
  const sliderHapticCooldownRef = useRef(0);
  const tossingRef = useRef(false);
  const [actionsUnlocked, setActionsUnlocked] = useState(false);
  const sliderGestureRef = useRef({
    axis: "pending",
  });
  const touchStartRef = useRef(0);
  const manualVisible = manualMode !== null;
  const manualIsAmountMode = manualMode === "amount";
  useEffect(() => {
    if (!visible) return;
    updateSliderValue(0.25, { force: true });
    hapticStepRef.current = Math.round(0.25 * 20);
    sliderHapticCooldownRef.current = 0;
    sliderGestureRef.current = {
      axis: "pending",
    };
    setSelectedCategory(null);
    setCategoryError(false);
    setManualMode(null);
    setManualValue("");
    setManualError("");
    setManualExactLocal(null);
    directionAnim.setValue(0);
    tossingRef.current = false;
    touchStartRef.current = 0;
    setActionsUnlocked(false);
  }, [directionAnim, updateSliderValue, visible]);
  const currencySymbol =
    CURRENCY_SIGNS[currency] ||
    CURRENCY_SIGNS[DEFAULT_PROFILE.currency] ||
    DEFAULT_PROFILE.currency ||
    "$";
  const computeAmountUSDForValue = useCallback(
    (value) => {
      if (!Number.isFinite(value) || maxAmountUSD <= 0) return 0;
      const localAmount = roundCurrencyValue(
        convertToCurrency(maxAmountUSD * value, currency),
        currency
      );
      const usd = convertFromCurrency(localAmount, currency);
      return Math.max(0, Math.min(maxAmountUSD, usd));
    },
    [currency, maxAmountUSD]
  );
  const sliderAmountUSD = computeAmountUSDForValue(sliderValue);
  const sliderLocalValue = snapCurrencyValue(convertToCurrency(sliderAmountUSD, currency), currency);
  const sliderAmountLocal = manualExactLocal
    ? formatCurrencyWhole(manualExactLocal.value, currency, manualExactLocal.precision)
    : formatCurrencyWhole(sliderLocalValue, currency);
  const sliderMaxLocalValue = useMemo(
    () => snapCurrencyValue(convertToCurrency(maxAmountUSD, currency), currency),
    [currency, maxAmountUSD]
  );
  const sliderMaxLocal = formatCurrencyWhole(sliderMaxLocalValue, currency);
  const sliderFillHeight = Math.max(COIN_FILL_MIN_HEIGHT, Math.min(trackHeight, trackHeight * sliderValue));
  const coinHasValue = sliderValue > 0.02;
  const coinFillColor = coinHasValue ? "#F7C45D" : "#DADDE3";
  const coinShineColor = coinHasValue ? "rgba(255,255,255,0.5)" : "rgba(255,255,255,0.25)";
  const isDarkTheme = colors.background === THEMES.dark.background;
  const coinSurfaceOuter = isDarkTheme ? "#111525" : "#F6F8FC";
  const coinSurfaceInner = isDarkTheme ? "#181D31" : "#ECEFF5";
  const coinSurfaceBorder = isDarkTheme ? "rgba(255,255,255,0.14)" : "rgba(255,255,255,0.8)";
  const coinSymbolColor = isDarkTheme ? "rgba(5,7,13,0.55)" : "rgba(5,7,13,0.25)";
  const coinSymbolOpacity = isDarkTheme ? 0.55 : 0.2;
  const sliderBackground = directionAnim.interpolate({
    inputRange: [-1, 0, 1],
    outputRange: ["rgba(217,72,98,0.18)", "rgba(0,0,0,0)", "rgba(46,184,115,0.18)"],
    extrapolate: "clamp",
  });
  const coinTranslateX = directionAnim.interpolate({
    inputRange: [-3, -1, 0, 1, 3],
    outputRange: [-SCREEN_WIDTH, -48, 0, 48, SCREEN_WIDTH],
    extrapolate: "clamp",
  });
  const currencyFineStep = useMemo(() => getCurrencyFineStep(currency), [currency]);
  const computeSteppedValue = useCallback(
    (rawValue) => {
      const clamped = Math.max(0, Math.min(1, rawValue));
      if (!Number.isFinite(clamped) || maxAmountUSD <= 0 || sliderMaxLocalValue <= 0) {
        return clamped;
      }
      const targetLocal = clamped * sliderMaxLocalValue;
      const stepLocal = currencyFineStep;
      let roundedLocal;
      if (stepLocal > 0) {
        const normalizedIndex = stepLocal > 0 ? targetLocal / stepLocal : 0;
        const baseIndex = Math.floor(normalizedIndex);
        const remainder = normalizedIndex - baseIndex;
        const stickingThreshold = Math.max(0.6, Math.min(0.98, COIN_SLIDER_STEP_STICKINESS));
        const downThreshold = Math.max(0.02, 1 - stickingThreshold);
        const previousLocal = sliderValueRef.current * sliderMaxLocalValue;
        const movingUp = targetLocal >= previousLocal;
        let finalIndex = baseIndex;
        if (movingUp) {
          finalIndex = remainder >= stickingThreshold ? baseIndex + 1 : baseIndex;
        } else {
          finalIndex = remainder > downThreshold ? baseIndex + 1 : baseIndex;
        }
        roundedLocal = roundCurrencyValue(finalIndex * stepLocal, currency);
      } else {
        roundedLocal = roundCurrencyValue(targetLocal, currency);
      }
      const limitedLocal = Math.max(0, Math.min(sliderMaxLocalValue, roundedLocal));
      const roundedUSD = convertFromCurrency(limitedLocal, currency);
      if (!Number.isFinite(roundedUSD) || roundedUSD < 0) {
        return clamped;
      }
      return Math.max(0, Math.min(1, roundedUSD / maxAmountUSD));
    },
    [currency, currencyFineStep, sliderMaxLocalValue, maxAmountUSD]
  );
  const computeValueFromTouch = useCallback(
    (locationY) => {
      if (!Number.isFinite(locationY) || trackHeight <= 0) {
        return sliderValueRef.current;
      }
      const clamped = Math.max(0, Math.min(trackHeight, locationY));
      const normalized = 1 - clamped / trackHeight;
      return computeSteppedValue(normalized);
    },
    [computeSteppedValue, sliderValueRef, trackHeight]
  );
  const updateSliderValue = useCallback(
    (value, { force = false, fromUser = false, manualOverride = false } = {}) => {
      if (!manualOverride) {
        setManualExactLocal(null);
      }
      const clamped = Math.max(0, Math.min(1, Number.isFinite(value) ? value : 0));
      sliderValueRef.current = clamped;
      const now = Date.now();
      if (force) {
        sliderValueCommitRef.current = clamped;
        sliderValueThrottleRef.current = now;
        setSliderValue(clamped);
        if (!fromUser && clamped <= COIN_SLIDER_VALUE_DEADBAND) {
          setActionsUnlocked(false);
        }
        return clamped;
      }
      const diff = Math.abs(clamped - sliderValueCommitRef.current);
      if (diff < COIN_SLIDER_VALUE_DEADBAND && now - sliderValueThrottleRef.current < COIN_SLIDER_STATE_MIN_INTERVAL) {
        return sliderValueCommitRef.current;
      }
      const smoothing = 0.35;
      const smoothed = sliderValueCommitRef.current + (clamped - sliderValueCommitRef.current) * smoothing;
      sliderValueCommitRef.current = smoothed;
      sliderValueThrottleRef.current = now;
      setSliderValue(smoothed);
      if (fromUser && smoothed > COIN_SLIDER_VALUE_DEADBAND) {
        setActionsUnlocked(true);
      }
      return smoothed;
    },
    [actionsUnlocked, setManualExactLocal]
  );
  const openManual = useCallback(
    (mode) => {
      setManualMode(mode);
      setManualError("");
      if (mode === "amount") {
        const formatted = sliderLocalValue > 0 ? formatNumberInputValue(sliderLocalValue) : "";
        setManualValue(formatted);
      } else {
        setManualValue("");
      }
    },
    [sliderLocalValue]
  );
  const closeManual = useCallback(() => {
    setManualMode(null);
    setManualError("");
  }, []);
  const finalizeSliderValue = useCallback(() => {
    const committed = sliderValueCommitRef.current;
    sliderValueRef.current = committed;
    updateSliderValue(committed, { force: true });
  }, [updateSliderValue]);
  const panResponder = useMemo(
    () =>
      PanResponder.create({
        onStartShouldSetPanResponder: () => true,
        onPanResponderGrant: (evt) => {
          sliderGestureRef.current = {
            axis: "vertical",
          };
          const touchY = evt.nativeEvent?.locationY;
          if (Number.isFinite(touchY)) {
            const nextValue = computeValueFromTouch(touchY);
            if (Math.abs(nextValue - sliderValueRef.current) >= COIN_SLIDER_GESTURE_DEADBAND) {
              const applied = updateSliderValue(nextValue, { force: true, fromUser: true });
              hapticStepRef.current = Math.round(applied * 20);
            }
          }
          touchStartRef.current = Date.now();
          directionAnim.stopAnimation();
          directionAnim.setValue(0);
        },
        onPanResponderMove: (evt) => {
          if (tossingRef.current) return;
          if (trackHeight <= 0) return;
          const touchY = evt.nativeEvent?.locationY;
          const nextValue = computeValueFromTouch(touchY);
          if (Math.abs(nextValue - sliderValueRef.current) >= COIN_SLIDER_GESTURE_DEADBAND) {
            const applied = updateSliderValue(nextValue, { fromUser: true });
            const nextStep = Math.round(applied * 20);
            if (nextStep !== hapticStepRef.current) {
              const now = Date.now();
              if (now - sliderHapticCooldownRef.current >= COIN_SLIDER_HAPTIC_COOLDOWN_MS) {
                triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
                sliderHapticCooldownRef.current = now;
              }
              hapticStepRef.current = nextStep;
            }
          }
        },
        onPanResponderRelease: (_, gesture) => {
          const elapsed = Date.now() - (touchStartRef.current || 0);
          const isTap =
            Math.abs(gesture.dx) < 6 && Math.abs(gesture.dy) < 6 && elapsed < 200 && !tossingRef.current;
          sliderGestureRef.current = {
            axis: "pending",
          };
          finalizeSliderValue();
          if (isTap) {
            openManual("amount");
          }
        },
        onPanResponderTerminate: () => {
          sliderGestureRef.current = {
            axis: "pending",
          };
          finalizeSliderValue();
        },
      }),
    [computeValueFromTouch, directionAnim, finalizeSliderValue, openManual, trackHeight]
  );
  const handleManualSave = () => {
    const parsed = parseNumberInputValue(manualValue);
    if (!Number.isFinite(parsed) || parsed <= 0) {
      setManualError(t("coinEntryManualError"));
      return;
    }
    const normalizedLocal = manualIsAmountMode ? parsed : snapCurrencyValue(parsed, currency);
    if (manualIsAmountMode) {
      if (!Number.isFinite(maxAmountUSD) || maxAmountUSD <= 0) {
        setManualError(t("coinEntryManualError"));
        return;
      }
      const limitedLocal = Math.max(0, Math.min(sliderMaxLocalValue, normalizedLocal));
      const parsedUSD = convertFromCurrency(limitedLocal, currency);
      if (!Number.isFinite(parsedUSD)) {
        setManualError(t("coinEntryManualError"));
        return;
      }
      const normalized = Math.max(0, Math.min(1, parsedUSD / maxAmountUSD));
      updateSliderValue(normalized, { force: true, fromUser: true, manualOverride: true });
      hapticStepRef.current = Math.round(normalized * 20);
      const manualPrecision = getManualInputPrecision(manualValue);
      setManualExactLocal({
        value: limitedLocal,
        precision: manualPrecision,
      });
      sliderGestureRef.current = {
        axis: "pending",
      };
      closeManual();
      return;
    }
    const parsedUSD = convertFromCurrency(normalizedLocal, currency);
    if (!Number.isFinite(parsedUSD) || parsedUSD <= 0) {
      setManualError(t("coinEntryManualError"));
      return;
    }
    onUpdateMaxUSD?.(parsedUSD);
    closeManual();
  };
  const categoryLabelKey = getShortLanguageKey(language);
  const manualTitle = manualIsAmountMode ? t("coinEntryManualAmountTitle") : t("coinEntryManualTitle");
  const manualPlaceholder = manualIsAmountMode
    ? t("coinEntryManualAmountPlaceholder", { amount: sliderAmountLocal })
    : t("coinEntryManualPlaceholder", { amount: sliderMaxLocal });
  const handleAction = useCallback(
    (direction) => {
      if (tossingRef.current) return;
      const value = sliderValueRef.current;
      const hasAmount = value >= 0.02;
      if (!hasAmount) {
        triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
        return;
      }
      if (!selectedCategory) {
        setCategoryError(true);
        triggerHaptic(Haptics.ImpactFeedbackStyle.Light);
        return;
      }
      const computedAmountUSD = computeAmountUSDForValue(value);
      tossingRef.current = true;
      Animated.timing(directionAnim, {
        toValue: direction === "save" ? 3.2 : -3.2,
        duration: 180,
        easing: Easing.out(Easing.circle),
        useNativeDriver: false,
      }).start(() => {
        tossingRef.current = false;
        directionAnim.setValue(0);
        onSubmit?.({
          amountUSD: computedAmountUSD,
          category: selectedCategory,
          direction,
        });
      });
    },
    [computeAmountUSDForValue, directionAnim, onSubmit, selectedCategory]
  );
  const showActionButtons = actionsUnlocked && sliderValue > COIN_SLIDER_VALUE_DEADBAND;
  return (
    <Modal visible={visible} transparent animationType="fade" onRequestClose={onCancel} statusBarTranslucent>
      <TouchableWithoutFeedback onPress={onCancel}>
        <View style={styles.coinEntryBackdrop}>
          <TouchableWithoutFeedback onPress={() => {}}>
            <View
              style={[
                styles.coinEntryCard,
                { backgroundColor: colors.card, borderColor: colors.border },
              ]}
            >
              <View style={styles.coinEntryHeader}>
                <View style={{ flex: 1 }}>
                  <Text style={[styles.coinEntryTitle, { color: colors.text }]}>{t("coinEntryTitle")}</Text>
                  <Text style={[styles.coinEntrySubtitle, { color: colors.muted }]}>
                    {t("coinEntrySubtitle")}
                  </Text>
                </View>
                <TouchableOpacity onPress={onCancel} style={styles.coinEntryClose}>
                  <Text style={[styles.coinEntryCloseText, { color: colors.muted }]}>‚úï</Text>
                </TouchableOpacity>
              </View>
              <View style={styles.coinEntryAmountRow}>
                <Text style={[styles.coinEntryAmount, { color: colors.text }]}>{sliderAmountLocal}</Text>
                <TouchableOpacity
                  onPress={() => openManual("max")}
                  hitSlop={{ top: 8, bottom: 8, left: 8, right: 8 }}
                >
                  <Text style={[styles.coinEntryMaxLabel, { color: colors.muted }]}>
                    {sliderMaxLocal}
                  </Text>
                </TouchableOpacity>
              </View>
              <View style={styles.coinSliderWrapper}>
                <Animated.View style={[styles.coinSliderBackdrop, { backgroundColor: sliderBackground }]} />
                <Animated.View
                  style={[
                    styles.coinCircle,
                    {
                      borderColor: coinHasValue ? "rgba(247,196,93,0.5)" : colors.border,
                      backgroundColor: coinSurfaceOuter,
                      shadowColor: coinHasValue ? "#F7C45D" : "#A0A5B6",
                      transform: [{ translateX: coinTranslateX }],
                    },
                  ]}
                  onLayout={(event) => {
                    const { height } = event.nativeEvent.layout;
                    if (height) setTrackHeight(height);
                  }}
                  {...panResponder.panHandlers}
                >
                  <View
                    style={[
                      styles.coinInnerSurface,
                      { backgroundColor: coinSurfaceInner, borderColor: coinSurfaceBorder },
                    ]}
                  >
                    <View style={styles.coinFillTrack}>
                      <View
                        style={[
                          styles.coinFill,
                          {
                            height: sliderFillHeight,
                            backgroundColor: coinFillColor,
                          },
                        ]}
                      />
                    </View>
                    <View style={[styles.coinShine, { backgroundColor: coinShineColor }]} />
                    <Text
                      style={[
                        styles.coinCurrencySymbol,
                        { color: coinSymbolColor, opacity: coinSymbolOpacity },
                      ]}
                    >
                      {currencySymbol}
                    </Text>
                  </View>
                </Animated.View>
              </View>
              {showActionButtons && (
                <View style={styles.coinEntryActions}>
                  <TouchableOpacity
                    style={[styles.coinEntryActionButton, styles.coinEntryActionButtonSpend]}
                    onPress={() => handleAction("spend")}
                    activeOpacity={0.85}
                  >
                    <Text style={[styles.coinEntryActionButtonText, styles.coinEntryActionButtonTextSpend]}>
                      {t("spendAction")}
                    </Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.coinEntryActionButton, styles.coinEntryActionButtonSave]}
                    onPress={() => handleAction("save")}
                    activeOpacity={0.85}
                  >
                    <Text style={[styles.coinEntryActionButtonText, styles.coinEntryActionButtonTextSave]}>
                      {t("saveAction")}
                    </Text>
                  </TouchableOpacity>
                </View>
              )}
              <Text style={[styles.coinEntryHint, { color: colors.muted }]}>{t("coinEntryHint")}</Text>
              <Text style={[styles.coinEntryCategoryLabel, { color: colors.text }]}>
                {t("coinEntryCategoryLabel")}
              </Text>
              {categoryError && (
                <Text style={[styles.coinEntryError, { color: SPEND_ACTION_COLOR }]}>
                  {t("coinEntryCategoryError")}
                </Text>
              )}
              <View style={styles.coinEntryCategoryRow}>
                {IMPULSE_CATEGORY_ORDER.map((categoryId) => {
                  const def = IMPULSE_CATEGORY_DEFS[categoryId];
                  const active = selectedCategory === categoryId;
                  return (
                    <TouchableOpacity
                      key={categoryId}
                      style={[
                        styles.coinEntryCategoryButton,
                        {
                          borderColor: active ? colors.text : colors.border,
                          backgroundColor: active ? colors.text : "transparent",
                        },
                      ]}
                      onPress={() => {
                        setSelectedCategory(categoryId);
                        setCategoryError(false);
                      }}
                    >
                      <Text style={styles.coinEntryCategoryEmoji}>{def.emoji}</Text>
                      <Text
                        style={[
                          styles.coinEntryCategoryText,
                          { color: active ? colors.background : colors.text },
                        ]}
                        numberOfLines={2}
                      >
                        {def[categoryLabelKey]}
                      </Text>
                    </TouchableOpacity>
                  );
                })}
              </View>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
      {manualVisible && (
        <Modal visible transparent animationType="fade" onRequestClose={closeManual}>
          <TouchableWithoutFeedback onPress={closeManual}>
            <View style={styles.coinEntryManualBackdrop}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View
                  style={[
                    styles.coinEntryManualCard,
                    { backgroundColor: colors.card, borderColor: colors.border },
                  ]}
                >
                  <Text style={[styles.coinEntryManualTitle, { color: colors.text }]}>
                    {manualTitle}
                  </Text>
                  <TextInput
                    style={[styles.coinEntryManualInput, { color: colors.text, borderColor: colors.border }]}
                    placeholder={manualPlaceholder}
                    placeholderTextColor={colors.muted}
                    keyboardType="numeric"
                    value={manualValue}
                    onChangeText={setManualValue}
                  />
                  {!!manualError && (
                    <Text style={[styles.coinEntryManualError, { color: SPEND_ACTION_COLOR }]}>{manualError}</Text>
                  )}
                  <View style={styles.coinEntryManualActions}>
                    <TouchableOpacity
                      style={[styles.coinEntryManualButtonGhost, { borderColor: colors.border }]}
                      onPress={closeManual}
                    >
                      <Text style={[styles.coinEntryManualButtonGhostText, { color: colors.muted }]}>
                        {t("coinEntryManualCancel")}
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[styles.coinEntryManualButtonPrimary, { backgroundColor: colors.text }]}
                      onPress={handleManualSave}
                    >
                      <Text style={[styles.coinEntryManualButtonPrimaryText, { color: colors.background }]}>
                        {t("coinEntryManualSave")}
                      </Text>
                    </TouchableOpacity>
                  </View>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>
      )}
    </Modal>
  );
}

function QuickCustomModal({
  visible,
  colors,
  t,
  currency,
  data,
  onChange,
  onSubmit,
  onCancel,
  language,
  keyboardOffset = 0,
}) {
  const keyboardPaddingStyle = keyboardOffset ? { paddingBottom: keyboardOffset } : null;
  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onCancel}
      statusBarTranslucent
    >
      <TouchableWithoutFeedback onPress={onCancel}>
        <View style={[styles.quickModalBackdrop, keyboardPaddingStyle]}>
          <TouchableWithoutFeedback onPress={() => {}}>
            <View style={[styles.quickModalCard, { backgroundColor: colors.card }] }>
              <Text style={[styles.quickModalTitle, { color: colors.text }]}>{t("quickCustomTitle")}</Text>
              <Text style={[styles.quickModalSubtitle, { color: colors.muted }]}>{t("quickCustomSubtitle")}</Text>
              <View style={{ gap: 8, width: "100%" }}>
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("quickCustomNameLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.title}
                  onChangeText={(text) => onChange("title", text)}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("quickCustomAmountLabel", { currency })}
                  placeholderTextColor={colors.muted}
                  keyboardType="decimal-pad"
                  value={data.amount}
                  onChangeText={(text) => onChange("amount", text)}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("quickCustomEmojiLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.emoji || ""}
                  onChangeText={(text) => onChange("emoji", text)}
                  selectTextOnFocus
                  maxLength={2}
                />
                <View style={{ gap: 6 }}>
                  <Text style={[styles.currencyLabel, { color: colors.muted }]}>
                    {t("impulseCategoryLabel")}
                  </Text>
                  <ImpulseCategorySelector
                    value={data.category || DEFAULT_IMPULSE_CATEGORY}
                    onChange={(cat) => onChange("category", cat)}
                    colors={colors}
                    language={language}
                  />
                </View>
              </View>
              <View style={styles.quickModalActions}>
                <TouchableOpacity
                  style={[styles.quickModalSecondary, { borderColor: colors.border }]}
                  onPress={onCancel}
                >
                  <Text style={[styles.quickModalSecondaryText, { color: colors.muted }]}>
                    {t("quickCustomCancel")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
                  onPress={() => onSubmit(data)}
                >
                  <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>
                    {t("quickCustomConfirm")}
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
}

function NewGoalModal({
  visible,
  colors,
  t,
  currency,
  data,
  onChange,
  onSubmit,
  onCancel,
  keyboardOffset = 0,
}) {
  const keyboardPaddingStyle = keyboardOffset ? { paddingBottom: keyboardOffset } : null;
  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onCancel}
      statusBarTranslucent
    >
      <TouchableWithoutFeedback onPress={onCancel}>
        <View style={[styles.quickModalBackdrop, keyboardPaddingStyle]}>
          <TouchableWithoutFeedback onPress={() => {}}>
            <View style={[styles.quickModalCard, { backgroundColor: colors.card }] }>
              <Text style={[styles.quickModalTitle, { color: colors.text }]}>{t("newGoalTitle")}</Text>
              <Text style={[styles.quickModalSubtitle, { color: colors.muted }]}>{t("newGoalSubtitle")}</Text>
              <View style={{ gap: 8, width: "100%" }}>
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newGoalNameLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.name}
                  onChangeText={(text) => onChange("name", text)}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newGoalTargetLabel", { currency })}
                  placeholderTextColor={colors.muted}
                  keyboardType="decimal-pad"
                  value={data.target}
                  onChangeText={(text) => onChange("target", text)}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newGoalEmojiLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.emoji || ""}
                  onChangeText={(text) => onChange("emoji", text)}
                  selectTextOnFocus
                  maxLength={2}
                />
              </View>
              <View style={styles.quickModalActions}>
                <TouchableOpacity
                  style={[styles.quickModalSecondary, { borderColor: colors.border }]}
                  onPress={onCancel}
                >
                  <Text style={[styles.quickModalSecondaryText, { color: colors.muted }]}>
                    {t("newGoalCancel")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
                  onPress={onSubmit}
                >
                  <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>
                    {t("newGoalCreate")}
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
}

function NewPendingModal({
  visible,
  colors,
  t,
  currency,
  data,
  onChange,
  onSubmit,
  onCancel,
  keyboardOffset = 0,
}) {
  const keyboardPaddingStyle = keyboardOffset ? { paddingBottom: keyboardOffset } : null;
  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onCancel}
      statusBarTranslucent
    >
      <TouchableWithoutFeedback onPress={onCancel}>
        <View style={[styles.quickModalBackdrop, keyboardPaddingStyle]}>
          <TouchableWithoutFeedback onPress={() => {}}>
            <View style={[styles.quickModalCard, { backgroundColor: colors.card }] }>
              <Text style={[styles.quickModalTitle, { color: colors.text }]}>{t("newPendingTitle")}</Text>
              <Text style={[styles.quickModalSubtitle, { color: colors.muted }]}>{t("newPendingSubtitle")}</Text>
              <View style={{ gap: 8, width: "100%" }}>
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newPendingNameLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.title}
                  onChangeText={(text) => onChange("title", text)}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newPendingAmountLabel", { currency })}
                  placeholderTextColor={colors.muted}
                  keyboardType="decimal-pad"
                  value={data.amount}
                  onChangeText={(text) => onChange("amount", text)}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newPendingEmojiLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.emoji || ""}
                  onChangeText={(text) => onChange("emoji", text)}
                  selectTextOnFocus
                  maxLength={2}
                />
              </View>
              <View style={styles.quickModalActions}>
                <TouchableOpacity
                  style={[styles.quickModalSecondary, { borderColor: colors.border }]}
                  onPress={onCancel}
                >
                  <Text style={[styles.quickModalSecondaryText, { color: colors.muted }]}>
                    {t("newPendingCancel")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
                  onPress={onSubmit}
                >
                  <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>
                    {t("newPendingCreate")}
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
}

function OnboardingGoalModal({
  visible,
  colors,
  t,
  currency,
  data,
  onChange,
  onSubmit,
  onCancel,
  keyboardOffset = 0,
}) {
  const keyboardPaddingStyle = keyboardOffset ? { paddingBottom: keyboardOffset } : null;
  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onCancel}
      statusBarTranslucent
    >
      <TouchableWithoutFeedback onPress={onCancel}>
        <View style={[styles.quickModalBackdrop, keyboardPaddingStyle]}>
          <TouchableWithoutFeedback onPress={() => {}}>
            <View style={[styles.quickModalCard, { backgroundColor: colors.card }] }>
              <Text style={[styles.quickModalTitle, { color: colors.text }]}>{t("newGoalTitle")}</Text>
              <Text style={[styles.quickModalSubtitle, { color: colors.muted }]}>{t("newGoalSubtitle")}</Text>
              <View style={{ gap: 8, width: "100%" }}>
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newGoalNameLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.name}
                  onChangeText={(text) => onChange("name", text)}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newGoalTargetLabel", { currency })}
                  placeholderTextColor={colors.muted}
                  keyboardType="decimal-pad"
                  value={data.target}
                  onChangeText={(text) => onChange("target", text)}
                />
                <TextInput
                  style={[
                    styles.primaryInput,
                    { borderColor: colors.border, color: colors.text, backgroundColor: colors.card },
                  ]}
                  placeholder={t("newGoalEmojiLabel")}
                  placeholderTextColor={colors.muted}
                  value={data.emoji || ""}
                  onChangeText={(text) => onChange("emoji", text)}
                  selectTextOnFocus
                  maxLength={2}
                />
              </View>
              <View style={styles.quickModalActions}>
                <TouchableOpacity
                  style={[styles.quickModalSecondary, { borderColor: colors.border }]}
                  onPress={onCancel}
                >
                  <Text style={[styles.quickModalSecondaryText, { color: colors.muted }]}>
                    {t("newGoalCancel")}
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
                  onPress={onSubmit}
                >
                  <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>
                    {t("goalCustomCreate")}
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
}

function TermsModal({ visible, colors, t, language, onAccept, onCancel, onOpenLink }) {
  const normalizedLanguage = normalizeLanguage(language);
  const points = TERMS_POINTS[normalizedLanguage] || TERMS_POINTS.en;
  return (
    <Modal visible={visible} transparent animationType="fade" statusBarTranslucent onRequestClose={onCancel}>
      <View style={styles.quickModalBackdrop}>
        <View style={[styles.termsCard, { backgroundColor: colors.card }]}>
          <Text style={[styles.termsTitle, { color: colors.text }]}>{t("termsTitle")}</Text>
          <Text style={[styles.termsSubtitle, { color: colors.muted }]}>{t("termsSubtitle")}</Text>
          <ScrollView
            style={styles.termsScroll}
            contentContainerStyle={styles.termsScrollContent}
            showsVerticalScrollIndicator={false}
          >
            {points.map((point, index) => (
              <View key={`${index}-${language}`} style={styles.termsPoint}>
                <Text style={[styles.termsPointIndex, { color: colors.muted }]}>{index + 1}.</Text>
                <Text style={[styles.termsPointText, { color: colors.text }]}>{point}</Text>
              </View>
            ))}
          </ScrollView>
          <TouchableOpacity
            style={[styles.termsLinkButton, { borderColor: colors.border }]}
            onPress={onOpenLink}
          >
            <Text style={[styles.termsLinkText, { color: colors.text }]}>{t("termsViewFull")}</Text>
          </TouchableOpacity>
          <Text style={[styles.termsHint, { color: colors.muted }]}>{t("termsLinkHint")}</Text>
          <View style={styles.quickModalActions}>
            <TouchableOpacity
              style={[styles.quickModalSecondary, { borderColor: colors.border }]}
              onPress={onCancel}
            >
              <Text style={[styles.quickModalSecondaryText, { color: colors.muted }]}>{t("termsDecline")}</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.quickModalPrimary, { backgroundColor: colors.text }]}
              onPress={onAccept}
            >
              <Text style={[styles.quickModalPrimaryText, { color: colors.background }]}>{t("termsAccept")}</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
}

function OnboardingBackButton({ onPress, colors, t }) {
  if (!onPress) return null;
  return (
    <TouchableOpacity
      style={[styles.onboardBackButton, { borderColor: colors.border }]}
      onPress={onPress}
      hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
    >
      <Text style={[styles.onboardBackIcon, { color: colors.text }]}>‚Üê</Text>
      <Text style={[styles.onboardBackLabel, { color: colors.text }]}>{t("onboardingBack")}</Text>
    </TouchableOpacity>
  );
}

function HowItWorksScreen({ colors, t, onContinue, onBack }) {
  const fade = useFadeIn();
  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <ScrollView
        contentContainerStyle={[styles.onboardContent, { gap: 18 }]}
        showsVerticalScrollIndicator={false}
      >
        <OnboardingBackButton onPress={onBack} colors={colors} t={t} />
        <Text style={[styles.onboardTitle, { color: colors.text }]}>{t("onboardingGuideTitle")}</Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("onboardingGuideSubtitle")}</Text>
        <View style={styles.guideCards}>
          {HOW_IT_WORKS_STEPS.map((step) => (
            <View
              key={step.id}
              style={[
                styles.guideCard,
                {
                  backgroundColor: colors.card,
                  borderColor: colors.border,
                },
              ]}
            >
              <Text style={styles.guideEmoji}>{step.emoji}</Text>
              <Text style={[styles.guideTitle, { color: colors.text }]}>{t(step.titleKey)}</Text>
              <Text style={[styles.guideDesc, { color: colors.muted }]}>{t(step.descKey)}</Text>
            </View>
          ))}
        </View>
        <TouchableOpacity
          style={[styles.primaryButton, { backgroundColor: colors.text }]}
          onPress={onContinue}
        >
          <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("onboardingGuideButton")}</Text>
        </TouchableOpacity>
      </ScrollView>
    </Animated.View>
  );
}
function LanguageScreen({
  colors,
  t,
  selectedLanguage,
  selectedCurrency,
  onLanguageChange,
  onCurrencyChange,
  onContinue,
  onBack,
  onShowTerms,
  termsAccepted,
  mascotWaveSource,
}) {
  const fade = useFadeIn();
  const wavingSource = mascotWaveSource || CLASSIC_TAMAGOTCHI_ANIMATIONS.waving;
  const [currencyIndicatorVisible, setCurrencyIndicatorVisible] = useState(true);
  const currencyScrollRef = useRef(null);
  const currencyNudgeRan = useRef(false);
  const [shouldAnimateCurrencyNudge, setShouldAnimateCurrencyNudge] = useState(false);
  const handleCurrencyScroll = useCallback(
    (event) => {
      const { contentOffset, contentSize, layoutMeasurement } = event.nativeEvent;
      const scrollable = contentSize.width > layoutMeasurement.width + 4;
      if (!scrollable) {
        setCurrencyIndicatorVisible(false);
        return;
      }
      const atEnd = contentOffset.x + layoutMeasurement.width >= contentSize.width - 8;
      setCurrencyIndicatorVisible(!atEnd);
    },
    [setCurrencyIndicatorVisible]
  );
  useEffect(() => {
    let cancelled = false;
    AsyncStorage.getItem(STORAGE_KEYS.LANGUAGE_CURRENCY_NUDGE)
      .then((value) => {
        if (!cancelled && !value) setShouldAnimateCurrencyNudge(true);
      })
      .catch(() => {});
    return () => {
      cancelled = true;
    };
  }, []);
  useEffect(() => {
    if (!shouldAnimateCurrencyNudge || currencyNudgeRan.current) return undefined;
    currencyNudgeRan.current = true;
    let backTimeout;
    const forwardTimeout = setTimeout(() => {
      currencyScrollRef.current?.scrollTo({ x: 48, animated: true });
      backTimeout = setTimeout(() => {
        currencyScrollRef.current?.scrollTo({ x: 0, animated: true });
      }, 650);
    }, 900);
    AsyncStorage.setItem(STORAGE_KEYS.LANGUAGE_CURRENCY_NUDGE, "1").catch(() => {});
    return () => {
      clearTimeout(forwardTimeout);
      if (backTimeout) clearTimeout(backTimeout);
    };
  }, [shouldAnimateCurrencyNudge]);
  return (
    <Animated.View style={[styles.onboardContainer, { backgroundColor: colors.background, opacity: fade }]}>
      <View style={styles.onboardContent}>
        <OnboardingBackButton onPress={onBack} colors={colors} t={t} />
        <Image source={wavingSource} style={styles.languageMascot} />
        <Text style={[styles.onboardTitle, { color: colors.text }]}>{t("languageTitle")}</Text>
        <Text style={[styles.onboardSubtitle, { color: colors.muted }]}>{t("languageSubtitle")}</Text>
        <View style={styles.languageButtons}>
          {SUPPORTED_LANGUAGES.map((langKey) => {
            const label = LANGUAGE_NATIVE_LABELS[langKey] || langKey.toUpperCase();
            const active = selectedLanguage === langKey;
            return (
              <TouchableOpacity
                key={langKey}
                style={[
                  styles.languageButton,
                  {
                    borderColor: colors.border,
                    backgroundColor: active ? colors.card : "transparent",
                  },
                ]}
                onPress={() => onLanguageChange?.(langKey)}
              >
                <Text style={{ color: colors.text, fontWeight: "700" }}>{label}</Text>
              </TouchableOpacity>
            );
          })}
        </View>
        <View style={{ width: "100%", marginTop: 20 }}>
          <Text style={[styles.currencyLabel, { color: colors.muted }]}>
            {t("currencyLabel")} <Text style={{ fontSize: 16 }}>‚Üí</Text>
          </Text>
          <View style={styles.currencyScrollWrapper}>
            <ScrollView
              ref={currencyScrollRef}
              horizontal
              showsHorizontalScrollIndicator={false}
              style={styles.currencyScroll}
              contentContainerStyle={styles.currencyScrollContent}
              onScroll={handleCurrencyScroll}
              scrollEventThrottle={16}
            >
              {CURRENCIES.map((currency) => {
                const active = currency === selectedCurrency;
                return (
                  <TouchableOpacity
                    key={currency}
                    style={[
                      styles.currencyChipLarge,
                      {
                        backgroundColor: active ? colors.text : "transparent",
                        borderColor: colors.border,
                      },
                    ]}
                    onPress={() => onCurrencyChange?.(currency)}
                  >
                    <Text
                      style={{
                        color: active ? colors.background : colors.text,
                        fontWeight: "600",
                      }}
                    >
                      {currency}
                    </Text>
                  </TouchableOpacity>
                );
              })}
            </ScrollView>
            {currencyIndicatorVisible && (
              <View pointerEvents="none" style={styles.currencyScrollFadeWrapper}>
                <Svg style={styles.currencyScrollFade} width="100%" height="100%">
                  <Defs>
                    <SvgLinearGradient id="currencyFade" x1="0" y1="0" x2="1" y2="0">
                      <SvgStop offset="0%" stopColor={colors.background} stopOpacity="0" />
                      <SvgStop offset="100%" stopColor={colors.background} stopOpacity="1" />
                    </SvgLinearGradient>
                  </Defs>
                  <SvgRect x="0" y="0" width="100%" height="100%" fill="url(#currencyFade)" />
                </Svg>
              </View>
            )}
          </View>
          <Text style={[styles.languageHint, { color: colors.muted }]}>{t("languageCurrencyHint")}</Text>
        </View>
        <TouchableOpacity
          style={[styles.primaryButton, { backgroundColor: colors.text, marginTop: 20 }]}
          onPress={onContinue}
        >
          <Text style={[styles.primaryButtonText, { color: colors.background }]}>{t("nextButton")}</Text>
        </TouchableOpacity>
        <View style={styles.languageTermsBlock}>
          <Text style={[styles.languageTermsNote, { color: colors.muted }]}>
            {termsAccepted ? t("languageTermsAccepted") : t("languageTermsHint")}
          </Text>
          <TouchableOpacity
            style={[styles.languageTermsButton, { borderColor: colors.border }]}
            onPress={() => onShowTerms?.()}
          >
            <Text style={[styles.languageTermsButtonText, { color: colors.text }]}>{t("languageTermsLink")}</Text>
          </TouchableOpacity>
        </View>
      </View>
    </Animated.View>
  );
}

function LogoSplash({ onDone }) {
  const [text, setText] = useState("");
  const onDoneRef = useRef(onDone);
  useEffect(() => {
    onDoneRef.current = onDone;
  }, [onDone]);
  const handleLayout = useCallback(() => {
    SplashScreen.hideAsync().catch(() => {});
  }, []);
  useEffect(() => {
    const word = "Almost";
    let index = 0;
    let timeoutId = null;
    const intervalId = setInterval(() => {
      index += 1;
      setText(word.slice(0, index));
      if (index === word.length) {
        clearInterval(intervalId);
        timeoutId = setTimeout(() => onDoneRef.current?.(), 600);
      }
    }, 140);
    return () => {
      clearInterval(intervalId);
      if (timeoutId) clearTimeout(timeoutId);
    };
  }, []);

  return (
    <View style={styles.logoSplash} onLayout={handleLayout}>
      <Text style={styles.logoSplashText}>{text}</Text>
    </View>
  );
}
const LevelUpCelebration = ({ colors, message, t, onSharePress }) => {
  const coins = useMemo(
    () =>
      Array.from({ length: 28 }).map((_, index) => ({
        id: `level_coin_${index}`,
        delay: Math.random() * 400,
        left: Math.random() * SCREEN_WIDTH,
        size: 14 + Math.random() * 20,
        duration: 1500 + Math.random() * 600,
      })),
    []
  );
  const levelNumber = Number(message) || 1;
  return (
    <View style={styles.levelOverlay} pointerEvents="box-none">
      <View style={styles.levelBackdrop} />
      <View style={styles.levelContent}>
        <Text style={[styles.levelTitle, { color: colors.text }]}>{t("progressHeroLevel", { level: levelNumber })}</Text>
        <Text style={[styles.levelSubtitle, { color: colors.text }]}>
          {t("levelCelebrate", { level: levelNumber })}
        </Text>
        {onSharePress && (
          <TouchableOpacity
            style={[styles.levelShareButton, { backgroundColor: colors.text }]}
            activeOpacity={0.92}
            onPress={() => onSharePress(levelNumber)}
          >
            <Text style={[styles.levelShareButtonText, { color: colors.background }]}>
              {t("levelShareButton")}
            </Text>
          </TouchableOpacity>
        )}
      </View>
      {coins.map((coin) => (
        <FallingCoin key={coin.id} {...coin} />
      ))}
    </View>
  );
};

const FallingCoin = ({ left, size, delay, duration }) => {
  const progress = useRef(new Animated.Value(0)).current;
  useEffect(() => {
    const animation = Animated.sequence([
      Animated.delay(delay),
      Animated.timing(progress, {
        toValue: 1,
        duration,
        easing: Easing.in(Easing.quad),
        useNativeDriver: true,
      }),
    ]);
    animation.start();
    return () => animation.stop();
  }, [delay, duration, progress]);

  const translateY = progress.interpolate({
    inputRange: [0, 1],
    outputRange: [-80, Dimensions.get("window").height],
  });
  const rotate = progress.interpolate({
    inputRange: [0, 1],
    outputRange: ["-40deg", "40deg"],
  });
  const opacity = progress.interpolate({
    inputRange: [0, 0.1, 0.9, 1],
    outputRange: [0, 1, 1, 0],
  });

  return (
    <Animated.View
      pointerEvents="none"
      style={[
        styles.levelCoin,
        {
          width: size,
          height: size,
          left,
          opacity,
          transform: [{ translateY }, { rotate }],
        },
      ]}
    />
  );
};

const RewardCelebration = ({ colors, message, t, mascotHappySource }) => {
  const happySource = mascotHappySource || CLASSIC_TAMAGOTCHI_ANIMATIONS.happy;
  const hearts = useMemo(
    () =>
      Array.from({ length: 18 }).map((_, index) => ({
        id: `reward_heart_${index}`,
        left: Math.random() * SCREEN_WIDTH,
        delay: Math.random() * 1200,
        duration: 1800 + Math.random() * 800,
      })),
    []
  );
  const isDarkTheme = colors.background === THEMES.dark.background;
  const rewardBackdropColor = isDarkTheme ? "rgba(0,0,0,0.85)" : "rgba(255,241,225,0.92)";
  const rewardCardBg = isDarkTheme ? lightenColor(colors.card, 0.12) : colors.card;
  const rewardCardBorder = isDarkTheme ? lightenColor(colors.border, 0.25) : "rgba(255,181,115,0.7)";
  return (
    <View style={styles.rewardOverlay} pointerEvents="none">
      <View style={[styles.rewardBackdrop, { backgroundColor: rewardBackdropColor }]} />
      {hearts.map((heart) => (
        <RewardHeart key={heart.id} {...heart} />
      ))}
      <View
        style={[
          styles.rewardCard,
          { backgroundColor: rewardCardBg, borderColor: rewardCardBorder },
        ]}
      >
        <Image source={happySource} style={styles.rewardCat} />
        <Text style={[styles.rewardTitle, { color: colors.text }]}>
          {t("rewardCelebrateTitle", { title: message })}
        </Text>
        <Text style={[styles.rewardSubtitle, { color: colors.muted }]}>
          {t("rewardCelebrateSubtitle")}
        </Text>
      </View>
    </View>
  );
};

const HealthCelebration = ({ colors, payload, t, language }) => {
  const scale = useRef(new Animated.Value(1)).current;
  useEffect(() => {
    const pulse = Animated.loop(
      Animated.sequence([
        Animated.timing(scale, {
          toValue: 1.2,
          duration: 460,
          useNativeDriver: true,
        }),
        Animated.timing(scale, {
          toValue: 1,
          duration: 460,
          useNativeDriver: true,
        }),
      ])
    );
    pulse.start();
    return () => pulse.stop();
  }, [scale]);
  const data = payload && typeof payload === "object" ? payload : { reason: payload };
  const amount =
    typeof data.amount === "number" && Number.isFinite(data.amount) ? data.amount : HEALTH_PER_REWARD;
  const coinValue =
    typeof data.coinValue === "number" && Number.isFinite(data.coinValue) ? data.coinValue : amount;
  const baseSubtitle = t("healthCelebrateSubtitle");
  const reason = data.reason || baseSubtitle;
  const isDarkTheme = colors.background === THEMES.dark.background;
  const backdropColor = isDarkTheme ? "rgba(0,0,0,0.85)" : "rgba(6,9,19,0.35)";
  const cardBg = isDarkTheme ? lightenColor(colors.card, 0.15) : colors.card;
  const cardBorder = isDarkTheme ? lightenColor(colors.border, 0.25) : "rgba(0,0,0,0.1)";
  const heartBackground = isDarkTheme ? "rgba(255,255,255,0.05)" : "rgba(255,255,255,0.8)";
  const rewardCoinTier = getHealthCoinTierForAmount(coinValue);
  const titleAmount = formatHealthRewardLabel(coinValue, language);
  return (
    <View style={styles.healthOverlay} pointerEvents="none">
      <View style={[styles.healthBackdrop, { backgroundColor: backdropColor }]} />
      <Animated.View
        style={[
          styles.healthHeartWrap,
          { transform: [{ scale }], backgroundColor: heartBackground },
        ]}
      >
        <Image source={rewardCoinTier.asset} style={styles.healthCoinImage} />
      </Animated.View>
      <View style={[styles.healthCard, { backgroundColor: cardBg, borderColor: cardBorder }]}>
        <Text style={[styles.healthTitle, { color: colors.text }]}>
          {t("healthCelebrateTitle", { amount: titleAmount })}
        </Text>
        <Text style={[styles.healthSubtitle, { color: colors.muted }]}>{reason}</Text>
        {reason !== baseSubtitle && (
          <Text style={[styles.healthSubtitle, { color: colors.muted }]}>{baseSubtitle}</Text>
        )}
      </View>
    </View>
  );
};

const GoalCelebration = ({ colors, payload, t, mascotHappySource }) => {
  const happySource = mascotHappySource || CLASSIC_TAMAGOTCHI_ANIMATIONS.happy;
  const hearts = useMemo(
    () =>
      Array.from({ length: 14 }).map((_, index) => ({
        id: `goal_heart_${index}`,
        left: Math.random() * SCREEN_WIDTH,
        delay: Math.random() * 900,
        duration: 1600 + Math.random() * 900,
      })),
    []
  );
  const data =
    payload && typeof payload === "object"
      ? payload
      : { title: payload || t("goalCelebrationTitle"), subtitle: t("goalCelebrationSubtitle") };
  const isDarkTheme = colors.background === THEMES.dark.background;
  const backdropColor = isDarkTheme ? "rgba(0,0,0,0.85)" : "rgba(7,44,23,0.85)";
  const cardBg = isDarkTheme ? lightenColor(colors.card, 0.15) : "#E7FFE9";
  const cardBorder = isDarkTheme ? lightenColor(colors.border, 0.25) : "#8FD7AE";
  return (
    <View style={styles.goalCelebrateOverlay} pointerEvents="none">
      <View style={[styles.goalCelebrateBackdrop, { backgroundColor: backdropColor }]} />
      {hearts.map((heart) => (
        <RewardHeart key={heart.id} {...heart} />
      ))}
      <View style={[styles.goalCelebrateCard, { backgroundColor: cardBg, borderColor: cardBorder }]}>
        <Image source={happySource} style={styles.goalCelebrateCat} />
        <Text style={[styles.goalCelebrateTitle, { color: colors.text }]}>
          {data.title || t("goalCelebrationTitle")}
        </Text>
        <Text style={[styles.goalCelebrateSubtitle, { color: colors.muted }]}>
          {data.subtitle || t("goalCelebrationSubtitle")}
        </Text>
        {data.targetLabel && (
          <Text style={[styles.goalCelebrateTarget, { color: colors.text }]}>{data.targetLabel}</Text>
        )}
      </View>
    </View>
  );
};

const RewardHeart = ({ left, delay, duration }) => {
  const translateY = useRef(new Animated.Value(60)).current;
  const opacity = useRef(new Animated.Value(0)).current;
  useEffect(() => {
    const anim = Animated.sequence([
      Animated.delay(delay),
      Animated.parallel([
        Animated.timing(translateY, {
          toValue: -160,
          duration,
          useNativeDriver: true,
        }),
        Animated.sequence([
          Animated.timing(opacity, {
            toValue: 1,
            duration: duration * 0.4,
            useNativeDriver: true,
          }),
          Animated.timing(opacity, {
            toValue: 0,
            duration: duration * 0.6,
            useNativeDriver: true,
          }),
        ]),
      ]),
    ]);
    anim.start();
    return () => anim.stop();
  }, [delay, duration, opacity, translateY]);

  return (
    <Animated.Text
      style={[
        styles.rewardHeart,
        {
          left,
          opacity,
          transform: [{ translateY }],
        },
      ]}
    >
      ‚ù§Ô∏è
    </Animated.Text>
  );
};
