require File.join(File.dirname(`node --print "require.resolve('expo/package.json')"`), "scripts/autolinking")
require File.join(File.dirname(`node --print "require.resolve('react-native/package.json')"`), "scripts/react_native_pods")

require 'json'
require 'fileutils'
require 'xcodeproj'
podfile_properties = JSON.parse(File.read(File.join(__dir__, 'Podfile.properties.json'))) rescue {}

# CocoaPods 1.16 + xcodeproj 1.27 misses compatibility for objectVersion 70.
# Patch in-place so pod install works on newer Xcode project formats.
unless Xcodeproj::Constants::COMPATIBILITY_VERSION_BY_OBJECT_VERSION.key?(70)
  compatibility = Xcodeproj::Constants::COMPATIBILITY_VERSION_BY_OBJECT_VERSION.dup
  compatibility[70] = 'Xcode 16.0'
  Xcodeproj::Constants.send(:remove_const, :COMPATIBILITY_VERSION_BY_OBJECT_VERSION)
  Xcodeproj::Constants.const_set(:COMPATIBILITY_VERSION_BY_OBJECT_VERSION, compatibility.freeze)
end

ENV['RCT_NEW_ARCH_ENABLED'] ||= '0' if podfile_properties['newArchEnabled'] == 'false'
ENV['EX_DEV_CLIENT_NETWORK_INSPECTOR'] ||= podfile_properties['EX_DEV_CLIENT_NETWORK_INSPECTOR']
ENV['RCT_USE_RN_DEP'] ||= '1' if podfile_properties['ios.buildReactNativeFromSource'] != 'true' && podfile_properties['newArchEnabled'] != 'false'
ENV['RCT_USE_PREBUILT_RNCORE'] ||= '1' if podfile_properties['ios.buildReactNativeFromSource'] != 'true' && podfile_properties['newArchEnabled'] != 'false'
platform :ios, podfile_properties['ios.deploymentTarget'] || '15.1'

prepare_react_native_project!

target 'Almost' do
  use_modular_headers!
# @generated begin AppsFlyer Strict Mode - expo prebuild (DO NOT MODIFY) sync-b29372208dd0dbd1274e957795cd756926086c3a
$RNAppsFlyerStrictMode=false
# @generated end AppsFlyer Strict Mode
  use_expo_modules!
# @generated begin AppsFlyer Purchase Connector - expo prebuild (DO NOT MODIFY) sync-40d043aa4472dc51990344aee6329be6fe164eba
$AppsFlyerPurchaseConnector=false
# @generated end AppsFlyer Purchase Connector

  if ENV['EXPO_USE_COMMUNITY_AUTOLINKING'] == '1'
    config_command = ['node', '-e', "process.argv=['', '', 'config'];require('@react-native-community/cli').run()"];
  else
    config_command = [
      'npx',
      'expo-modules-autolinking',
      'react-native-config',
      '--json',
      '--platform',
      'ios'
    ]
  end

  config = use_native_modules!(config_command)

  use_frameworks! :linkage => podfile_properties['ios.useFrameworks'].to_sym if podfile_properties['ios.useFrameworks']
  use_frameworks! :linkage => ENV['USE_FRAMEWORKS'].to_sym if ENV['USE_FRAMEWORKS']

  use_react_native!(
    :path => config[:reactNativePath],
    :hermes_enabled => podfile_properties['expo.jsEngine'] == nil || podfile_properties['expo.jsEngine'] == 'hermes',
    # An absolute path to your application root.
    :app_path => "#{Pod::Config.instance.installation_root}/..",
    :privacy_file_aggregation_enabled => podfile_properties['apple.privacyManifestAggregationEnabled'] != 'false',
  )

  post_install do |installer|
    react_native_post_install(
      installer,
      config[:reactNativePath],
      :mac_catalyst_enabled => false,
      :ccache_enabled => podfile_properties['apple.ccacheEnabled'] == 'true',
    )

    sentry_profiling_header = File.join(
      installer.sandbox.root,
      'Sentry',
      'Sources',
      'Sentry',
      'Public',
      'SentryProfilingConditionals.h'
    )
    if File.exist?(sentry_profiling_header)
      FileUtils.chmod('u+w', sentry_profiling_header)
      header_contents = File.read(sentry_profiling_header)
      unless header_contents.include?('ifndef SENTRY_TARGET_PROFILING_SUPPORTED')
        header_contents = header_contents.gsub(
          /#if TARGET_OS_WATCH \|\| TARGET_OS_TV\n#    define SENTRY_TARGET_PROFILING_SUPPORTED 0\n#else\n#    define SENTRY_TARGET_PROFILING_SUPPORTED 1\n#endif/,
          "#if !defined(SENTRY_TARGET_PROFILING_SUPPORTED)\n#    if TARGET_OS_WATCH || TARGET_OS_TV\n#        define SENTRY_TARGET_PROFILING_SUPPORTED 0\n#    else\n#        define SENTRY_TARGET_PROFILING_SUPPORTED 1\n#    endif\n#endif"
        )
        File.write(sentry_profiling_header, header_contents)
      end
    end

    sentry_features_builder = File.join(
      installer.sandbox.root,
      'Sentry',
      'Sources',
      'Swift',
      'Helper',
      'SentryEnabledFeaturesBuilder.swift'
    )
    if File.exist?(sentry_features_builder)
      FileUtils.chmod('u+w', sentry_features_builder)
      builder_contents = File.read(sentry_features_builder)
      unless builder_contents.include?('enableAppLaunchProfiling")')
        builder_contents = builder_contents.gsub(
          /#if os\(iOS\) \|\| os\(macOS\) \|\| targetEnvironment\(macCatalyst\)\n        if options\.enableAppLaunchProfiling \{\n            features\.append\("appLaunchProfiling"\)\n        \}\n#endif/s,
          "#if os(iOS) || os(macOS) || targetEnvironment(macCatalyst)\n        if options.responds(to: NSSelectorFromString(\"enableAppLaunchProfiling\")) {\n            if let value = options.value(forKey: \"enableAppLaunchProfiling\") as? Bool, value {\n                features.append(\"appLaunchProfiling\")\n            }\n        }\n#endif"
        )
        File.write(sentry_features_builder, builder_contents)
      end
    end

    installer.pods_project.targets.each do |target|
      next unless target.name.include?('Sentry')

      target.build_configurations.each do |config|
        # Sentry's profiling code fails to compile under C++20 with some toolchains.
        config.build_settings['CLANG_CXX_LANGUAGE_STANDARD'] = 'c++17'
        config.build_settings['CLANG_CXX_LIBRARY'] = 'libc++'
        # Force-disable profiling in native Sentry SDK (prevents allocator errors).
        config.build_settings['OTHER_CPLUSPLUSFLAGS'] = [
          '$(inherited)',
          '-DSENTRY_TARGET_PROFILING_SUPPORTED=0',
          '-DSENTRY_PROFILING_SUPPORTED=0',
          '-DSENTRY_DISABLE_PROFILING=1'
        ].join(' ')
        config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] = [
          '$(inherited)',
          'SENTRY_TARGET_PROFILING_SUPPORTED=0',
          'SENTRY_PROFILING_SUPPORTED=0',
          'SENTRY_DISABLE_PROFILING=1'
        ]
      end
    end

    # Keep RNFB scripts after widget embedding to avoid Xcode dependency cycles.
    installer.aggregate_targets.map(&:user_project).uniq.compact.each do |project|
      app_target = project.targets.find { |target| target.name == 'Almost' }
      next unless app_target

      embed_phase = app_target.build_phases.find do |phase|
        phase.isa == 'PBXCopyFilesBuildPhase' && phase.name == 'Embed Foundation Extensions'
      end
      core_phase = app_target.build_phases.find do |phase|
        phase.isa == 'PBXShellScriptBuildPhase' && phase.name == '[CP-User] [RNFB] Core Configuration'
      end
      crash_phase = app_target.build_phases.find do |phase|
        phase.isa == 'PBXShellScriptBuildPhase' && phase.name == '[CP-User] [RNFB] Crashlytics Configuration'
      end

      [core_phase, crash_phase].compact.each do |phase|
        phase.input_paths = []
        phase.output_paths = []
      end

      if embed_phase
        [core_phase, crash_phase].compact.each { |phase| app_target.build_phases.delete(phase) }
        embed_index = app_target.build_phases.index(embed_phase)
        insert_index = embed_index ? embed_index + 1 : app_target.build_phases.length
        [core_phase, crash_phase].compact.each_with_index do |phase, offset|
          app_target.build_phases.insert(insert_index + offset, phase)
        end
      end

      project.save
    end
  end
end
